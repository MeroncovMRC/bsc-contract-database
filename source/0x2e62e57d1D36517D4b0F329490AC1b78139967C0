{"Address.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\n\nlibrary Address {\n\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256(\u0027\u0027)`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash \u0026\u0026 codehash != 0x0);\n    }\n\n    /**\n     * @dev Replacement for Solidity\u0027s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n\n}\n"},"IERC20.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\ninterface IERC20 {\n\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n    \n    /**\n     * @dev Returns the number of decimal places\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"},"IStakableSurge.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"./IERC20.sol\";\n\n/**\n * Exempt Surge Interface\n */\ninterface IStakableSurge is IERC20 {\n    function sell(uint256 amount) external;\n    function getUnderlyingAsset() external returns(address);\n    function stakeUnderlyingAsset(uint256 numTokens) external returns(bool);\n    function enableEmergencyMode() external;\n}\n"},"IUselessBypass.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\n/**\n * Useless Bypass Interface\n */\ninterface IUselessBypass {\n    function uselessBypass(address receiver, uint256 amount) external returns (bool);\n}\n"},"ReentrantGuard.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nabstract contract ReentrancyGuard {\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private _status;\n    constructor () {\n        _status = _NOT_ENTERED;\n    }\n\n    modifier nonReentrant() {\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n        _status = _ENTERED;\n        _;\n        _status = _NOT_ENTERED;\n    }\n}\n"},"SafeMath.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"},"SurgeUSELESS.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"./SafeMath.sol\";\nimport \"./Address.sol\";\nimport \"./ReentrantGuard.sol\";\nimport \"./IERC20.sol\";\nimport \"./IStakableSurge.sol\";\nimport \"./IUselessBypass.sol\";\n\n/**\n * Contract: Surge Token\n * Developed By: Markymark (aka DeFi Mark)\n *\n * Liquidity-less Token, DEX built into Contract\n * Send BNB to contract and it mints Surge Token to your receive Address\n * Sell this token by interacting with contract directly\n * Price is calculated as a ratio between Total Supply and underlying asset in Contract\n *\n */\ncontract SurgeToken is ReentrancyGuard, IStakableSurge {\n    \n    using SafeMath for uint256;\n    using SafeMath for uint8;\n    using Address for address;\n\n    // token data\n    string public _name = \"SurgeToken\";\n    string public _symbol = \"S_Ticker\";\n    uint8 public constant _decimals = 0;\n    \n    // 1 Billion Total Supply\n    uint256 public _totalSupply = 1 * 10**9;\n    \n    // balances\n    mapping (address =\u003e uint256) _balances;\n    mapping (address =\u003e mapping (address =\u003e uint256)) _allowances;\n\n    // Fees\n    uint256 public sellFee;\n    uint256 public buyFee;\n    uint256 public transferFee;\n    uint256 public stakeFee;\n    \n    // Emergency Mode Only\n    bool public emergencyModeEnabled;\n    \n    // Pegged Asset\n    address public immutable _token;\n    \n    // swapper contract for Useless\n    IUselessBypass public immutable _uselessSwapper;\n\n    // Garbage Collector\n    uint256 garbageCollectorThreshold = 10**10;\n    \n    // owner\n    address _owner;\n    \n    // Activates Surge Token Trading\n    bool Surge_Token_Activated;\n\n    // launch time\n    bool _allowStaking;\n    \n    // disables the use of the Useless Bypass\n    bool _useUselessBypass;\n    \n    // surge fund data \n    bool allowFunding;\n    address _surgeFund;\n    uint256 _fundingBuyFeeDenominator;\n    uint256 _fundingTransferFeeDenominator;\n    \n    // LP Management\n    mapping (address =\u003e bool) approvedLP;\n\n    modifier onlyOwner() {\n        require(msg.sender == _owner, \u0027Only Owner Function\u0027);\n        _;\n    }\n\n    // initialize some stuff\n    constructor ( address peggedToken, string memory tokenName, string memory tokenSymbol, uint256 _buyFee, uint256 _sellFee, uint256 _transferFee\n    ) {\n        // ensure arguments meet criteria\n        require(_buyFee \u003c= 100 \u0026\u0026 _sellFee \u003c= 100 \u0026\u0026 _transferFee \u003c= 100 \u0026\u0026 _buyFee \u003e= 50 \u0026\u0026 _sellFee \u003e= 50 \u0026\u0026 _transferFee \u003e= 50, \u0027Invalid Fees, Must Range From 50 - 100\u0027);\n        require(peggedToken != address(0), \u0027cannot peg to zero address\u0027);\n        // underlying asset\n        _token = peggedToken;\n        // token stats\n        _name = tokenName;\n        _symbol = tokenSymbol;\n        // fees\n        buyFee = _buyFee;\n        sellFee = _sellFee;\n        transferFee = _transferFee;\n        stakeFee = 94125;\n        // Swaps + Funding\n        _surgeFund = 0x95c8eE08b40107f5bd70c28c4Fd96341c8eaD9c7;\n        _fundingBuyFeeDenominator = 200;\n        _fundingTransferFeeDenominator = 4;\n        _uselessSwapper = IUselessBypass(payable(0xd63760b15DDC89E78C6D429AC3c03A494A3F5e30));\n        _useUselessBypass = true;\n        // Approved LPs\n        approvedLP[0x10ED43C718714eb63d5aA57B78B54704E256024E] = true;\n        // ownership\n        _owner = msg.sender;\n        // allot starting 1 billion to contract to be Garbage Collected\n        _balances[address(this)] = _totalSupply;\n        emit Transfer(address(0), address(this), _totalSupply);\n    }\n\n    function totalSupply() external view override returns (uint256) { return _totalSupply; }\n    function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }\n    function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }\n    \n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return _decimals;\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n  \n    /** Transfer Function */\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\n        return _transferFrom(msg.sender, recipient, amount);\n    }\n\n    /** Transfer Function */\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\n        if (approvedLP[msg.sender]) {\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount, \u0027Insufficient Allowance\u0027);\n        } else {\n            require(sender == msg.sender, \u0027Only Owner Can Move Tokens\u0027);\n        }\n        \n        return _transferFrom(sender, recipient, amount);\n    }\n    \n    /** Internal Transfer */\n    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\n        // make standard checks\n        require(recipient != address(0) \u0026\u0026 sender != address(0), \"Transfer To Zero Address\");\n        require(amount \u003e 0, \"Transfer amount must be greater than zero\");\n        // track price change\n        uint256 oldPrice = calculatePrice();\n        // subtract form sender, give to receiver, burn the fee\n        uint256 tAmount = amount.mul(transferFee).div(10**2);\n        uint256 tax = amount.sub(tAmount);\n        // subtract from sender\n        _balances[sender] = _balances[sender].sub(amount, \"Insufficient Balance\");\n        // give reduced amount to receiver\n        _balances[recipient] = _balances[recipient].add(tAmount);\n        \n        if (allowFunding \u0026\u0026 sender != _surgeFund \u0026\u0026 recipient != _surgeFund) {\n            // allocate percentage of the tax for Surge Fund\n            uint256 allocation = tax.div(_fundingTransferFeeDenominator);\n            // how much are we removing from total supply\n            tax = tax.sub(allocation);\n            // allocate funding to Surge Fund\n            _balances[_surgeFund] = _balances[_surgeFund].add(allocation);\n            // Emit Donation To Surge Fund\n            emit Transfer(sender, _surgeFund, allocation);\n        }\n        // burn the tax\n        _totalSupply = _totalSupply.sub(tax);\n        // Price difference\n        uint256 currentPrice = calculatePrice();\n        // Require Current Price \u003e= Last Price\n        require(currentPrice \u003e= oldPrice, \u0027Price Must Rise For Transaction To Conclude\u0027);\n        // Transfer Event\n        emit Transfer(sender, recipient, tAmount);\n        // Emit The Price Change\n        emit PriceChange(oldPrice, currentPrice, _totalSupply);\n        return true;\n    }\n    \n    /** Purchases SURGE Tokens and Deposits Them in Sender\u0027s Address */\n    function purchase() private nonReentrant returns (bool) {\n        // make sure emergency mode is disabled\n        require((!emergencyModeEnabled \u0026\u0026 Surge_Token_Activated) || _owner == msg.sender, \u0027EMERGENCY MODE ENABLED\u0027);\n        // calculate price change\n        uint256 oldPrice = calculatePrice();\n        // previous amount of Tokens before we received any\n        uint256 prevTokenAmount = IERC20(_token).balanceOf(address(this));\n        // buy useless with bnb\n        (bool success,) = payable(address(_uselessSwapper)).call{value: msg.value}(\"\");\n        require(success, \u0027Failure on Useless Purchase\u0027);\n        // balance of tokens after swap\n        uint256 currentTokenAmount = IERC20(_token).balanceOf(address(this));\n        // number of Tokens we have purchased\n        uint256 difference = currentTokenAmount.sub(prevTokenAmount);\n        // if this is the first purchase, use new amount\n        prevTokenAmount = prevTokenAmount == 0 ? currentTokenAmount : prevTokenAmount;\n        // make sure total supply is greater than zero\n        uint256 calculatedTotalSupply = _totalSupply == 0 ? _totalSupply.add(1) : _totalSupply;\n        // find the number of tokens we should mint to keep up with the current price\n        uint256 nShouldPurchase = calculatedTotalSupply.mul(difference).div(prevTokenAmount);\n        // apply our spread to tokens to inflate price relative to total supply\n        uint256 tokensToSend = nShouldPurchase.mul(buyFee).div(10**2);\n        // revert if under 1\n        require(tokensToSend \u003e 0, \u0027Must Purchase At Least One Surge\u0027);\n\n        if (allowFunding \u0026\u0026 msg.sender != _surgeFund) {\n            // allocate tokens to go to the Surge Fund\n            uint256 allocation = tokensToSend.div(_fundingBuyFeeDenominator);\n            // the rest go to purchaser\n            tokensToSend = tokensToSend.sub(allocation);\n            // mint to Fund\n            mint(_surgeFund, allocation);\n            // Tell Blockchain\n            emit Transfer(address(this), _surgeFund, allocation);\n        }\n        \n        // mint to Buyer\n        mint(msg.sender, tokensToSend);\n        // Calculate Price After Transaction\n        uint256 currentPrice = calculatePrice();\n        // Require Current Price \u003e= Last Price\n        require(currentPrice \u003e= oldPrice, \u0027Price Must Rise For Transaction To Conclude\u0027);\n        // Emit Transfer\n        emit Transfer(address(this), msg.sender, tokensToSend);\n        // Emit The Price Change\n        emit PriceChange(oldPrice, currentPrice, _totalSupply);\n        return true;\n    }\n    \n    /** Stake Tokens and Deposits Surge in Sender\u0027s Address, Must Have Prior Approval */\n    function stakeUnderlyingAsset(uint256 numTokens) external nonReentrant override returns (bool) {\n        // make sure emergency mode is disabled\n        require((!emergencyModeEnabled \u0026\u0026 Surge_Token_Activated \u0026\u0026 _allowStaking) || _owner == msg.sender, \u0027STAKING NOT ENABLED\u0027);\n        // users token balance\n        uint256 userTokenBalance = IERC20(_token).balanceOf(msg.sender);\n        // ensure user has enough to send\n        require(userTokenBalance \u003e 0 \u0026\u0026 numTokens \u003c= userTokenBalance, \u0027Insufficient Balance\u0027);\n        // calculate price change\n        uint256 oldPrice = calculatePrice();\n        // previous amount of Tokens before any are received\n        uint256 prevTokenAmount = IERC20(_token).balanceOf(address(this));\n        // move asset into Surge Token\n        bool success = IERC20(_token).transferFrom(msg.sender, address(this), numTokens);\n        // balance of tokens after transfer\n        uint256 currentTokenAmount = IERC20(_token).balanceOf(address(this));\n        // number of Tokens we have purchased\n        uint256 difference = currentTokenAmount.sub(prevTokenAmount);\n        // ensure nothing unexpected happened\n        require(difference \u003c= numTokens, \u0027Failure on Token Evaluation\u0027);\n        // ensure a successful transfer\n        require(success, \u0027Failure On Token Transfer\u0027);\n        // if this is the first purchase, use new amount\n        prevTokenAmount = prevTokenAmount == 0 ? currentTokenAmount : prevTokenAmount;\n        // make sure total supply is greater than zero\n        uint256 calculatedTotalSupply = _totalSupply == 0 ? _totalSupply.add(1) : _totalSupply;\n        // find the number of tokens we should mint to keep up with the current price\n        uint256 nShouldPurchase = calculatedTotalSupply.mul(difference).div(prevTokenAmount);\n        // apply our spread to tokens to inflate price relative to total supply\n        uint256 tokensToSend = nShouldPurchase.mul(stakeFee).div(10**5);\n        // revert if under 1\n        require(tokensToSend \u003e 0, \u0027Must Purchase At Least One Surge\u0027);\n\n        if (allowFunding \u0026\u0026 msg.sender != _surgeFund) {\n            // less fee for staking \n            uint256 denom = _fundingBuyFeeDenominator.mul(4);\n            // allocate tokens to go to the Surge Fund\n            uint256 allocation = tokensToSend.div(denom);\n            // the rest go to purchaser\n            tokensToSend = tokensToSend.sub(allocation);\n            // mint to Fund\n            mint(_surgeFund, allocation);\n            // Tell Blockchain\n            emit Transfer(address(this), _surgeFund, allocation);\n        }\n        \n        // mint to Buyer\n        mint(msg.sender, tokensToSend);\n        // Calculate Price After Transaction\n        uint256 currentPrice = calculatePrice();\n        // Require Current Price \u003e= Last Price\n        require(currentPrice \u003e= oldPrice, \u0027Price Must Rise For Transaction To Conclude\u0027);\n        // Emit Transfer\n        emit Transfer(address(this), msg.sender, tokensToSend);\n        // Emit The Price Change\n        emit PriceChange(oldPrice, currentPrice, _totalSupply);\n        // Emit Staked Event\n        emit TokenStaked(difference);\n        return true;\n    }\n    \n    /** Sells SURGE Tokens And Deposits the Underlying Asset into Seller\u0027s Address */\n    function sell(uint256 tokenAmount) external nonReentrant override {\n        // calculate price change\n        uint256 oldPrice = calculatePrice();\n        // calculate the sell fee from this transaction\n        uint256 tokensToSwap = tokenAmount.mul(sellFee).div(10**2);\n        // subtract full amount from sender\n        _balances[msg.sender] = _balances[msg.sender].sub(tokenAmount, \u0027Insufficient Balance\u0027);\n\n        if (allowFunding \u0026\u0026 msg.sender != _surgeFund) {\n            // allocate percentage to Surge Fund\n            uint256 allocation = tokensToSwap.div(_fundingBuyFeeDenominator);\n            // subtract allocation from tokensToSwap\n            tokensToSwap = tokensToSwap.sub(allocation);\n            // burn tokenAmount - allocation\n            tokenAmount = tokenAmount.sub(allocation);\n            // Allocate Tokens To Surge Fund\n            _balances[_surgeFund] = _balances[_surgeFund].add(allocation);\n            // Tell Blockchain\n            emit Transfer(msg.sender, _surgeFund, allocation);\n        }\n        \n        // how many Tokens are these tokens worth?\n        uint256 amountToken = tokensToSwap.mul(calculatePrice());\n        // Remove tokens from supply\n        _totalSupply = _totalSupply.sub(tokenAmount);\n        // transfer success\n        bool successful;\n        // send Tokens to Seller\n        if (_useUselessBypass) {\n            // approve of bypass\n            IERC20(_token).approve(address(_uselessSwapper), amountToken);\n            successful = _uselessSwapper.uselessBypass(msg.sender, amountToken);\n        } else {\n            successful = IERC20(_token).transfer(msg.sender, amountToken);\n        }\n        // ensure Tokens were delivered\n        require(successful, \u0027Unable to Complete Transfer of Tokens\u0027);\n        // get current price\n        uint256 currentPrice = calculatePrice();\n        // Require Current Price \u003e= Last Price\n        require(currentPrice \u003e= oldPrice, \u0027Price Must Rise For Transaction To Conclude\u0027);\n        // Emit Transfer\n        emit Transfer(msg.sender, address(this), tokenAmount);\n        // Emit The Price Change\n        emit PriceChange(oldPrice, currentPrice, _totalSupply);\n    }\n    \n    /** Allows A User To Erase Their Holdings From Supply */\n    function eraseHoldings() external {\n        // get balance of caller\n        uint256 bal = _balances[msg.sender];\n        // require balance is greater than zero\n        require(bal \u003e 0, \u0027cannot erase zero holdings\u0027);\n        // Track Change In Price\n        uint256 oldPrice = calculatePrice();\n        // remove tokens from sender\n        _balances[msg.sender] = 0;\n        // remove tokens from supply\n        _totalSupply = _totalSupply.sub(bal, \u0027total supply cannot be negative\u0027);\n        // Emit Price Difference\n        emit PriceChange(oldPrice, calculatePrice(), _totalSupply);\n        // Emit Call\n        emit ErasedHoldings(msg.sender, bal);\n    }\n    \n    \n    ///////////////////////////////////\n    //////  INTERNAL FUNCTIONS  ///////\n    ///////////////////////////////////\n    \n    \n    /** Mints Tokens to the Receivers Address */\n    function mint(address receiver, uint amount) private {\n        _balances[receiver] = _balances[receiver].add(amount);\n        _totalSupply = _totalSupply.add(amount);\n    }\n\n    /** Make Sure there\u0027s no Native Tokens in contract */\n    function checkGarbageCollector() internal {\n        uint256 bal = _balances[address(this)];\n        if (bal \u003e= garbageCollectorThreshold) {\n            // Track Change In Price\n            uint256 oldPrice = calculatePrice();\n            // destroy token balance inside contract\n            _balances[address(this)] = 0;\n            // remove tokens from supply\n            _totalSupply = _totalSupply.sub(bal, \u0027total supply cannot be negative\u0027);\n            // Emit Call\n            emit GarbageCollected(bal);\n            // Emit Price Difference\n            emit PriceChange(oldPrice, calculatePrice(), _totalSupply);\n        }\n    }\n    \n    \n    ///////////////////////////////////\n    //////    READ FUNCTIONS    ///////\n    ///////////////////////////////////\n    \n    \n    /** Returns true if manager is a registered xTokenManager */\n    function isApprovedLP(address manager) external view returns (bool) {\n        return approvedLP[manager];\n    }\n    \n    /** Returns the Current Price of the Token */\n    function calculatePrice() public view returns (uint256) {\n        uint256 tokenBalance = IERC20(_token).balanceOf(address(this));\n        return _totalSupply == 0 ? tokenBalance : tokenBalance.div(_totalSupply);\n    }\n\n    /** Returns the value of your holdings before the sell fee */\n    function getValueOfHoldings(address holder) public view returns(uint256) {\n        return _balances[holder].mul(calculatePrice());\n    }\n\n    /** Returns the value of your holdings after the sell fee */\n    function getValueOfHoldingsAfterTax(address holder) external view returns(uint256) {\n        return getValueOfHoldings(holder).mul(sellFee).div(10**2);\n    }\n\n    /** Returns The Address of the Underlying Asset */\n    function getUnderlyingAsset() external override view returns(address) {\n        return _token;\n    }\n    \n    \n    ///////////////////////////////////\n    //////   OWNER FUNCTIONS    ///////\n    ///////////////////////////////////\n    \n    \n    /** Enables Trading For This Surge Token, This Action Cannot be Undone */\n    function ActivateSurgeToken() external onlyOwner {\n        require(!Surge_Token_Activated, \u0027Already Activated Token\u0027);\n        Surge_Token_Activated = true;\n        allowFunding = true;\n        emit SurgeTokenActivated();\n    }\n    \n    /*\n    * Fail Safe Incase Withdrawal is Absolutely Necessary\n    * Allows Users To Withdraw 100% Of Their Share Of The Underlying Asset\n    * This will disable the ability to purchase or stake Surge Tokens\n    * THIS ACTION CANNOT BE UNDONE\n    */\n    function enableEmergencyMode() external override onlyOwner {\n        require(!emergencyModeEnabled, \u0027Emergency Mode Already Enabled\u0027);\n        // disable fees\n        sellFee = 100;\n        transferFee = 100;\n        buyFee = 0;\n        stakeFee = 0;\n        // disable purchases\n        emergencyModeEnabled = true;\n        // disable funding\n        allowFunding = false;\n        // Let Everyone Know\n        emit EmergencyModeEnabled();\n    }\n    \n    /** Allows Users To Stake Underlying Asset Into Surge */\n    function setAllowSurgeStaking(bool allow) external onlyOwner {\n        _allowStaking = allow;\n        emit UpdatedAllowSurgeStaking(allow);\n    }\n    \n    /** Updates The Buy/Sell/Stake and Transfer Fee Allocated Toward Funding */\n    function updateFundingValues(bool allowSurgeFunding, uint256 transferDenom, uint256 buySellDenom) external onlyOwner {\n        require(transferDenom \u003e= 2 \u0026\u0026 buySellDenom \u003e= 50, \u0027Fees Too High\u0027);\n        allowFunding = allowSurgeFunding;\n        _fundingTransferFeeDenominator = transferDenom;\n        _fundingBuyFeeDenominator = buySellDenom;\n        emit UpdatedFundingValues(allowSurgeFunding, transferDenom, buySellDenom);\n    }\n    \n    /** Updates The Address Of The SurgeFund */\n    function updateSurgeFundAddress(address newSurgeFund) external onlyOwner {\n        _surgeFund = newSurgeFund;\n        emit UpdatedSurgeFundAddress(newSurgeFund);\n    }\n    \n    /** Sets an Address To Be An Approved Liquidity Pool */\n    function setIsApprovedLP(address LP, bool isLP) external onlyOwner {\n        approvedLP[LP] = isLP;\n        emit SetApprovedLP(LP, isLP);\n    }\n    \n    /** Whether or Not Contract Uses the Useless Bypass to Transfer Tokens */\n    function updateUseOfUselessBypass(bool useBypass) external onlyOwner {\n        _useUselessBypass = useBypass;\n        emit UpdatedUseUselessBypass(useBypass);\n    }\n\n    /** Updates The Threshold To Trigger The Garbage Collector */\n    function changeGarbageCollectorThreshold(uint256 garbageThreshold) external onlyOwner {\n        require(garbageThreshold \u003e 0 \u0026\u0026 garbageThreshold \u003c= 10**12, \u0027invalid threshold\u0027);\n        garbageCollectorThreshold = garbageThreshold;\n        emit UpdatedGarbageCollectorThreshold(garbageThreshold);\n    }\n    \n    /** Transfers Ownership To Another User */\n    function transferOwnership(address newOwner) external onlyOwner {\n        _owner = newOwner;\n        emit TransferOwnership(newOwner);\n    }\n    \n    /** Transfers Ownership To Zero Address */\n    function renounceOwnership() external onlyOwner {\n        _owner = address(0);\n        emit TransferOwnership(address(0));\n    }\n    \n    /** Mint Tokens to Buyer */\n    receive() external payable {\n        checkGarbageCollector();\n        purchase();\n    }\n    \n    \n    ///////////////////////////////////\n    //////        EVENTS        ///////\n    ///////////////////////////////////\n    \n    event UpdatedFundingValues(bool allowSurgeFunding, uint256 transferDenom, uint256 buySellDenom);\n    event PriceChange(uint256 previousPrice, uint256 currentPrice, uint256 totalSupply);\n    event ErasedHoldings(address who, uint256 amountTokensErased);\n    event UpdatedGarbageCollectorThreshold(uint256 newThreshold);\n    event UpdatedSurgeFundAddress(address newSurgeFund);\n    event GarbageCollected(uint256 amountTokensErased);\n    event UpdatedUseUselessBypass(bool canUseBypass);\n    event UpgradeSurgeDatabase(address newDatabase);\n    event UpdatedAllowFunding(bool _allowFunding);\n    event SetApprovedLP(address LP, bool isLP);\n    event UpdatedAllowSurgeStaking(bool allow);\n    event TransferOwnership(address newOwner);\n    event TokenStaked(uint256 numTokens);\n    event EmergencyModeEnabled();\n    event SurgeTokenActivated();\n    \n}\n"}}