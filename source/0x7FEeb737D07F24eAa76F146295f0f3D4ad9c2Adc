{"Address.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\n\r\n\r\nlibrary Address {\r\n\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256(\u0027\u0027)`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash \u0026\u0026 codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity\u0027s `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length \u003e 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n\r\n}"},"FlashLoanProvider.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\n\r\nimport \"./Address.sol\";\r\nimport \"./Ownable.sol\";\r\nimport \"./IERC20.sol\";\r\n\r\ninterface IFlashBorrower {\r\n    /**\r\n     * @dev Receive a flash loan.\r\n     * @param initiator The initiator of the loan.\r\n     * @param tokenToBorrow The loan currency, must be an approved stable coin.\r\n     * @param tokenToRepay The repayment currency, must be an approved stable coin.\r\n     * @param amount The amount of tokens lent.\r\n     * @param fee The additional amount of tokens to repay.\r\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\r\n     * @return The keccak256 hash of \"ERC3156FlashBorrower.onFlashLoan\"\r\n     */\r\n    function onFlashLoan(\r\n        address initiator,\r\n        address tokenToBorrow,\r\n        address tokenToRepay,\r\n        uint256 amount,\r\n        uint256 fee,\r\n        bytes calldata data\r\n    ) external returns (bytes32);\r\n}\r\n\r\ninterface IFlashLender {\r\n    /**\r\n     * @dev The amount of currency available to be lent.\r\n     * @param token The loan currency.\r\n     * @return The amount of `token` that can be borrowed.\r\n     */\r\n    function maxFlashLoan(address token) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev The fee to be charged for a given loan.\r\n     * @param token The loan currency.\r\n     * @param amount The amount of tokens lent.\r\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\r\n     */\r\n    function flashFee(address token, uint256 amount) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Initiate a flash loan.\r\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\r\n     * @param tokenToBorrow The loan currency, must be an approved stable coin\r\n     * @param tokenToRepay The Repayment currency, must be an approved stable coin\r\n     * @param amount The amount of tokens lent.\r\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\r\n     */\r\n    function flashLoan(\r\n        IFlashBorrower receiver,\r\n        address tokenToBorrow,\r\n        address tokenToRepay,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external returns (bool);\r\n}\r\n\r\ninterface IXUSD {\r\n    function isUnderlyingAsset(address stable) external view returns (bool);\r\n    function requestFlashLoan(\r\n        address stable,\r\n        address stableToRepay,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n    function resourceCollector() external view returns (address);\r\n}\r\n\r\ncontract FlashLoanProvider is IFlashLender, Ownable {\r\n\r\n    using Address for address;\r\n\r\n    // Data Structure\r\n    struct Data {\r\n        IFlashBorrower receiver;\r\n        address stableToBorrow;\r\n        address stableToRepay;\r\n        uint256 amount;\r\n        bytes _data;\r\n        address sender;\r\n        uint256 fee;\r\n    }\r\n\r\n    // Callback Success\r\n    bytes32 public constant CALLBACK_SUCCESS = keccak256(\u0027ERC3156FlashBorrower.onFlashLoan\u0027);\r\n\r\n    // last saved data\r\n    Data private data;\r\n\r\n    // XUSD Contract\r\n    address public XUSD;\r\n\r\n    // Address =\u003e Fee Rank\r\n    mapping ( address =\u003e uint8 ) public feeRank;\r\n\r\n    uint8 public bottomRank                = 25;\r\n    uint8 public constant middleRank       = 10;\r\n    uint8 public constant topRank          = 0;\r\n    uint256 public maxLoanRate             = 1000 * 10**18;\r\n    uint256 public constant feeDenominator = 10**5;\r\n\r\n    constructor(address XUSD_) {\r\n        require(XUSD_ != address(0), \u0027Zero Address\u0027);\r\n        XUSD = XUSD_;\r\n    }\r\n\r\n    function setXUSD(address XUSD_) external onlyOwner {\r\n        require(XUSD_ != address(0), \u0027Zero Address\u0027);\r\n        XUSD = XUSD_;\r\n    }\r\n\r\n    function setFeeRank(address user, uint8 rank) external onlyOwner {\r\n        require(rank \u003c= uint8(2), \u0027Invalid Rank\u0027);\r\n        feeRank[user] = rank;\r\n    }\r\n\r\n    function withdraw(address token) external onlyOwner {\r\n        IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this)));\r\n    }\r\n\r\n    function setMaxLoanRate(uint newMaxRate) external onlyOwner {\r\n        require(newMaxRate \u003e= 10**18, \u0027Max Rate Too Low\u0027);\r\n        maxLoanRate = newMaxRate;\r\n    }\r\n\r\n    function setBottomRate(uint8 newBottomRate) external onlyOwner {\r\n        require(newBottomRate \u003c= 100 \u0026\u0026 newBottomRate \u003e= middleRank, \u0027Bottom Rate Too High Or Lower Than Middle Rank\u0027);\r\n        bottomRank = newBottomRate;\r\n    }\r\n\r\n    /**\r\n        Max Flash Loan Capable\r\n     */\r\n    function maxFlashLoan(address token) public view override returns (uint256) {\r\n        return IXUSD(XUSD).isUnderlyingAsset(token) ? IERC20(token).balanceOf(XUSD) : 0;\r\n    }\r\n\r\n    function getFeeForUser(address user) public view returns (uint256) {\r\n        return feeRank[user] \u003e= 2 ? uint256(topRank) : feeRank[user] == 1 ? uint256(middleRank) : uint256(bottomRank);\r\n    }\r\n\r\n    /**\r\n        Flash Fee Taken From Transaction, capped at Maximum Rate\r\n     */\r\n    function flashFee(address borrower, uint256 amount) public view override returns (uint256) {\r\n        uint256 fee = ( getFeeForUser(borrower) * amount ) / feeDenominator;\r\n        return fee \u003e= maxLoanRate ? maxLoanRate : fee;\r\n    }\r\n\r\n    /**\r\n        Allows receiver to borrow amount stable from XUSD\r\n        As long as it repays amount stable + fee within the same transaction\r\n        When flashloan is initiated, all token functionality is halted\r\n     */\r\n    function flashLoan(\r\n        IFlashBorrower receiver,\r\n        address tokenToBorrow,\r\n        address tokenToRepay,\r\n        uint256 amount,\r\n        bytes calldata data_\r\n    ) external override returns (bool) {\r\n        require(\r\n            amount \u003e 0 \u0026\u0026\r\n            amount \u003c= maxFlashLoan(tokenToBorrow),         \r\n            \"Insufficient Borrow Balance\"\r\n        );\r\n        require(\r\n            IXUSD(XUSD).isUnderlyingAsset(tokenToRepay),\r\n            \u0027Repayment Token Not Approved\u0027\r\n        );\r\n        require(\r\n            address(receiver) != address(0) \u0026\u0026\r\n            tokenToBorrow != address(0) \u0026\u0026\r\n            tokenToRepay != address(0),\r\n            \u0027Zero Address\u0027\r\n        );\r\n        require(\r\n            address(receiver).isContract(),\r\n            \"Borrower must be a deployed contract\"\r\n        );\r\n\r\n        // calculate fee for loan\r\n        uint256 fee = flashFee(msg.sender, amount);\r\n\r\n        data = Data({\r\n            receiver: receiver,\r\n            stableToBorrow: tokenToBorrow,\r\n            stableToRepay: tokenToRepay,\r\n            amount: amount,\r\n            _data: data_,\r\n            sender: msg.sender,\r\n            fee: fee\r\n        });\r\n\r\n        // get tokens from XUSD\r\n        require(\r\n            IXUSD(XUSD).requestFlashLoan(tokenToBorrow, tokenToRepay, amount),\r\n            \u0027Flash Loan Request Failed\u0027\r\n        );\r\n        \r\n        delete data;\r\n        return true;\r\n    }\r\n    \r\n    function fulfillFlashLoanRequest() external returns (bool) {\r\n        require(msg.sender == XUSD, \u0027Only XUSD\u0027);\r\n        require(data.amount \u003e 0 \u0026\u0026 data.stableToBorrow != address(0) \u0026\u0026 data.stableToRepay != address(0), \u0027Data Not Set\u0027);\r\n\r\n        // transfer amount to sender\r\n        IERC20(data.stableToBorrow).transfer(address(data.receiver), data.amount);\r\n\r\n        // trigger functionality on external contract\r\n        require(\r\n            data.receiver.onFlashLoan(data.sender, data.stableToBorrow, data.stableToRepay, data.amount, data.fee, data._data) == CALLBACK_SUCCESS,\r\n            \u0027CALLBACK_FAILED\u0027\r\n        );\r\n        \r\n        // require more stable has been acquired\r\n        require(\r\n            IERC20(data.stableToRepay).balanceOf(address(this)) \u003e= ( data.amount + data.fee ), \r\n            \"Flash loan not paid back\"\r\n        );\r\n\r\n        // send tokens back to XUSD\r\n        require(\r\n            IERC20(data.stableToRepay).transfer(\r\n                XUSD,\r\n                data.amount + data.fee/2\r\n            ),\r\n            \u0027Failure on XUSD Repayment\u0027\r\n        );\r\n\r\n        // send tokens to XUSD Resource Collector\r\n        uint256 remainderToRepay = IERC20(data.stableToRepay).balanceOf(address(this));\r\n        address collector = IXUSD(XUSD).resourceCollector();\r\n        if (remainderToRepay \u003e 0 \u0026\u0026 collector != address(0)) {\r\n            require(\r\n                IERC20(data.stableToRepay).transfer(\r\n                    collector,\r\n                    remainderToRepay\r\n                ),\r\n                \u0027Failure On Collector Repayment\u0027\r\n            );\r\n        }\r\n        return true;\r\n    }\r\n\r\n}"},"IERC20.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    \r\n    function symbol() external view returns(string memory);\r\n    \r\n    function name() external view returns(string memory);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n    \r\n    /**\r\n     * @dev Returns the number of decimal places\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"},"Ownable.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity 0.8.4;\r\n\r\n/**\r\n * @title Owner\r\n * @dev Set \u0026 change owner\r\n */\r\ncontract Ownable {\r\n\r\n    address private owner;\r\n    \r\n    // event for EVM logging\r\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\r\n    \r\n    // modifier to check if caller is owner\r\n    modifier onlyOwner() {\r\n        // If the first argument of \u0027require\u0027 evaluates to \u0027false\u0027, execution terminates and all\r\n        // changes to the state and to Ether balances are reverted.\r\n        // This used to consume all gas in old EVM versions, but not anymore.\r\n        // It is often a good idea to use \u0027require\u0027 to check if functions are called correctly.\r\n        // As a second argument, you can also provide an explanation about what went wrong.\r\n        require(msg.sender == owner, \"Caller is not owner\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Set contract deployer as owner\r\n     */\r\n    constructor() {\r\n        owner = msg.sender; // \u0027msg.sender\u0027 is sender of current call, contract deployer for a constructor\r\n        emit OwnerSet(address(0), owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Change owner\r\n     * @param newOwner address of new owner\r\n     */\r\n    function changeOwner(address newOwner) public onlyOwner {\r\n        emit OwnerSet(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Return owner address \r\n     * @return address of owner\r\n     */\r\n    function getOwner() external view returns (address) {\r\n        return owner;\r\n    }\r\n}"}}