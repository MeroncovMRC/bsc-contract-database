{"IERC721TokenReceiver.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.18;\r\n\r\ninterface IERC721TokenReceiver {\r\n\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data) external returns (bytes4);\r\n\r\n}\r\n"},"IRedCat.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.18;\r\n\r\ninterface IRedCat {\r\n\r\n    function ownerOf(uint tokenId) external view returns (address);\r\n    function getBuyTime(uint tokenId) external view returns (uint, uint);\r\n    function getBan(uint tokenId) external view returns (uint, bool);\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function walletOfOwner(address _owner) external view returns(uint256[] memory);\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n}\r\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.18;\r\n\r\ncontract Ownable {\r\n\r\n    // attributes\r\n    address private _owner;\r\n\r\n    // modifier\r\n    modifier onlyOwner() {\r\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    // event\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _transferOwnership(msg.sender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n\r\n}\r\n"},"RedCatJail.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.18;\r\n\r\nimport \u0027./Ownable.sol\u0027;\r\nimport \"./IRedCat.sol\";\r\nimport \"./IERC721TokenReceiver.sol\";\r\nimport \"./ReentrancyGuard.sol\";\r\n\r\nstruct RedCatOrder {\r\n    address borrowAddress;\r\n    uint borrowMoney;\r\n    uint borrowTime;\r\n    uint salePrice;\r\n}\r\n\r\ncontract RedCatJail is Ownable, IERC721TokenReceiver, ReentrancyGuard {\r\n\r\n    // constant\r\n    IRedCat immutable RedCat;\r\n\r\n    // attributes\r\n    bool public saleOpen = false;\r\n    bool public borrowOpen = false;\r\n    uint public borrowPrice = 0.2 ether;\r\n    uint public mintPrice = 0.3 ether;\r\n    uint public holdTime = 60 days;\r\n    uint public redemptionTime = 90 days;\r\n    uint public abandonTime = 180 days;\r\n\r\n    mapping(address =\u003e mapping(uint tokenId =\u003e RedCatOrder)) jail;\r\n    mapping(address =\u003e mapping(uint tokenId =\u003e RedCatOrder)) abandon;\r\n\r\n    // event\r\n    event BorrowMoney(address borrower, uint borrowMoney, uint tokenId);\r\n    event DepositMoney(address depositor, uint money);\r\n    event BuyRedCat(address buyer, uint tokenId, uint money);\r\n    event RedemptionRedCat(address redeemer, uint tokenId, uint money);\r\n\r\n    constructor(address RedCatAddress) payable {\r\n        RedCat = IRedCat(RedCatAddress);\r\n        emit DepositMoney(msg.sender, msg.value);\r\n    }\r\n\r\n    receive() external payable {\r\n        emit DepositMoney(msg.sender, msg.value);\r\n    }\r\n\r\n    function borrowMoney(uint[] calldata tokenIds) external nonReentrant {\r\n        require(borrowOpen, \"market not open\");\r\n        require(RedCat.balanceOf(msg.sender) - tokenIds.length \u003e= 1, \"hold at least one\");\r\n\r\n        for(uint i = 0; i \u003c tokenIds.length; i++) {\r\n            (uint tokenId, uint buyTime) = RedCat.getBuyTime(tokenIds[i]);\r\n            (, bool ban) = RedCat.getBan(tokenId);\r\n\r\n            require(block.timestamp - buyTime \u003e= holdTime, \"holding time too short\");\r\n            require(RedCat.ownerOf(tokenId) == msg.sender, \"RedCat is not yours\");\r\n            require(!ban, \"RedCat has been banned\");\r\n\r\n            RedCat.safeTransferFrom(msg.sender, address(this), tokenId);\r\n            jail[address(this)][tokenId] = RedCatOrder(msg.sender, borrowPrice, block.timestamp, 0);\r\n\r\n            (bool success, ) = msg.sender.call{value: borrowPrice}(\"\");\r\n            require(success, \"failed\");\r\n\r\n            emit BorrowMoney(msg.sender, borrowPrice, tokenId);\r\n        }\r\n    }\r\n\r\n    function redemptionRedCat(uint[] calldata tokenIds) external payable {\r\n        for(uint i = 0; i \u003c tokenIds.length; i++) {\r\n            uint tokenId = tokenIds[i];\r\n            RedCatOrder memory redCatOrder = jail[address(this)][tokenId];\r\n            require(redCatOrder.borrowAddress == msg.sender, \"not yours\");\r\n            require(!getAbandomTime(tokenId), \"has been abandoned\");\r\n            require(!getRedemptionTime(tokenId), \"has been overRedemption\");\r\n\r\n            require(msg.value / tokenIds.length \u003e= redCatOrder.borrowMoney, \"wrong amount\");\r\n\r\n            RedCat.safeTransferFrom(address(this), msg.sender, tokenId);\r\n            delete jail[address(this)][tokenId];\r\n\r\n            emit RedemptionRedCat(msg.sender, tokenId, redCatOrder.borrowMoney);\r\n        }\r\n    }\r\n\r\n    function overRedemptionRedCat(uint tokenId) external payable {\r\n        RedCatOrder memory redCatOrder = jail[address(this)][tokenId];\r\n        require(redCatOrder.borrowAddress == msg.sender, \"not yours\");\r\n        require(!getAbandomTime(tokenId), \"has been abandoned\");\r\n        require(getRedemptionTime(tokenId), \"not overRedemption\");\r\n\r\n        uint totalAmount = getTotalAmount(tokenId);\r\n        require(msg.value \u003e= totalAmount, \"wrong amount\");\r\n\r\n        RedCat.safeTransferFrom(address(this), msg.sender, tokenId);\r\n        delete jail[address(this)][tokenId];\r\n\r\n        (bool success, ) = msg.sender.call{value: msg.value - totalAmount}(\"\");\r\n        require(success, \"failed\");\r\n\r\n        emit RedemptionRedCat(msg.sender, tokenId, totalAmount);\r\n    }\r\n\r\n    function confirmAbandon() external {\r\n        uint256[] memory jailRedCat = RedCat.walletOfOwner(address(this));\r\n\r\n        for(uint i = 0; i \u003c jailRedCat.length; i++) {\r\n            uint tokenId = jailRedCat[i];\r\n\r\n            if(getAbandomTime(tokenId)) {\r\n                abandon[address(this)][tokenId] = jail[address(this)][tokenId];\r\n                delete jail[address(this)][tokenId];\r\n            }\r\n        }\r\n    }\r\n\r\n    function buyRedCat(uint tokenId) external payable nonReentrant {\r\n        require(saleOpen, \"market not open\");\r\n        uint salePrice = abandon[address(this)][tokenId].salePrice;\r\n        require(salePrice \u003e 0 \u0026\u0026 msg.value \u003e= salePrice, \"Insufficient expenses\");\r\n\r\n        RedCat.safeTransferFrom(address(this), msg.sender, tokenId);\r\n        delete abandon[address(this)][tokenId];\r\n\r\n        emit BuyRedCat(msg.sender, tokenId, msg.value);\r\n    }\r\n\r\n    // onlyOwner\r\n    function setBorrowOpen() external onlyOwner {\r\n        borrowOpen = !borrowOpen;\r\n    }\r\n\r\n    function setSaleOpen() external onlyOwner {\r\n        saleOpen = !saleOpen;\r\n    }\r\n\r\n    function setSalePrice(uint tokenId, uint price) external onlyOwner {\r\n        require(getAbandonTokenOrder(tokenId).borrowAddress != address(0), \"not abandon\");\r\n        abandon[address(this)][tokenId].salePrice = price;\r\n    }\r\n\r\n    function setBorrowPrice(uint _borrowPrice) external onlyOwner {\r\n        borrowPrice = _borrowPrice;\r\n    }\r\n\r\n    function setMintPrice(uint _mintPrice) external onlyOwner {\r\n        mintPrice = _mintPrice;\r\n    }\r\n\r\n    function setHoldTime(uint _holdTime) external onlyOwner {\r\n        holdTime = _holdTime;\r\n    }\r\n\r\n    function setRedemptionTime(uint _redemptionTime) external onlyOwner {\r\n        redemptionTime = _redemptionTime;\r\n    }\r\n\r\n    function setAbandonTime(uint _abandonTime) external onlyOwner {\r\n        abandonTime = _abandonTime;\r\n    }\r\n\r\n    function withdrawERC20(address _address, uint _amount) external onlyOwner {\r\n        (bool success, ) = _address.call(abi.encodeWithSignature(\"transfer(address,uint256)\", msg.sender, _amount));\r\n        require(success, \"failed\");\r\n    }\r\n\r\n    function withdraw() external onlyOwner {\r\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\"\");\r\n        require(success, \"failed\");\r\n    }\r\n\r\n    function getBalance() public view returns (uint) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function getRedemptionTime(uint tokenId) public view returns (bool) {\r\n        return block.timestamp - jail[address(this)][tokenId].borrowTime \u003e= redemptionTime;\r\n    }\r\n\r\n    function getAbandomTime(uint tokenId) public view returns (bool) {\r\n        return block.timestamp - jail[address(this)][tokenId].borrowTime \u003e= abandonTime;\r\n    }\r\n\r\n    function getJailTokenOrder(uint tokenId) public view returns (RedCatOrder memory) {\r\n        return jail[address(this)][tokenId];\r\n    }\r\n\r\n    function getAbandonTokenOrder(uint tokenId) public view returns (RedCatOrder memory) {\r\n        return abandon[address(this)][tokenId];\r\n    }\r\n\r\n    function getTotalAmount(uint tokenId) public view returns (uint totalAmount) {\r\n        require(RedCat.ownerOf(tokenId) == address(this), \"not yours\");\r\n        RedCatOrder memory redCatOrder = getJailTokenOrder(tokenId);\r\n        totalAmount = (mintPrice - redCatOrder.borrowMoney) / (abandonTime - redemptionTime) * (block.timestamp - (redCatOrder.borrowTime + redemptionTime)) + redCatOrder.borrowMoney;\r\n    }\r\n\r\n    function onERC721Received(address, address, uint, bytes calldata) external pure returns (bytes4) {\r\n        return IERC721TokenReceiver.onERC721Received.selector;\r\n    }\r\n\r\n}\r\n"},"ReentrancyGuard.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.18;\r\n\r\ncontract ReentrancyGuard {\r\n\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == _ENTERED;\r\n    }\r\n}\r\n"}}