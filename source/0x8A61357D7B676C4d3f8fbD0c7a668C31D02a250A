{"Chain.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface AggregatorV3Interface {\r\n  function decimals() external view returns (uint8);\r\n\r\n  function description() external view returns (string memory);\r\n\r\n  function version() external view returns (uint256);\r\n\r\n  function getRoundData(uint80 _roundId)\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n\r\n  function latestRoundData()\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n}\r\n"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.7;\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n    * @dev Initializes the contract setting the deployer as the initial owner.\r\n    */\r\n    constructor () {\r\n      address msgSender = _msgSender();\r\n      _owner = msgSender;\r\n      emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the address of the current owner.\r\n    */\r\n    function owner() public view returns (address) {\r\n      return _owner;\r\n    }\r\n\r\n    \r\n    modifier onlyOwner() {\r\n      require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n      _;\r\n    }\r\n\r\n    function renounceOwnership() public onlyOwner {\r\n      emit OwnershipTransferred(_owner, address(0));\r\n      _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n      _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal {\r\n      require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n      emit OwnershipTransferred(_owner, newOwner);\r\n      _owner = newOwner;\r\n    }\r\n}\r\n"},"TSLA.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.7;\r\n\r\n// File: @chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\r\nimport \"./IERC20.sol\";\r\nimport \"./Ownable.sol\";\r\nimport \"./Chain.sol\";\r\n\r\ninterface _BUSDOracle {\r\n   function OracleHolder() external view returns(address);\r\n   function getWhitelist() external view returns(address[] memory);\r\n   function Topdeposit() external view returns(uint256);\r\n}\r\n\r\ncontract TSLAoracle is Context, Ownable {\r\n    AggregatorV3Interface internal priceFeed;\r\n\r\n    //address public BUSDaddress = 0xAC82EF603D3Faf774be7A648A46529EF9ff4DfBA; //BUSD Oracle Teestnet address\r\n    address public BUSDaddress = 0xAC82EF603D3Faf774be7A648A46529EF9ff4DfBA; //BUSD Oracle Mainnet address\r\n    uint256 public constant min = 50 ether;\r\n    uint256 public max = 100000 ether;\r\n    uint256 roi = 20;\r\n    uint256 public fee = 10;\r\n    uint256 public constant ref_fee = 5;\r\n    int256 public pricediff;\r\n    uint256 resets;\r\n    uint256 smallresets;\r\n    uint256 public WhiteTime;\r\n    int256 public lastprice;\r\n    address public teamwallet;\r\n    address public mkt;\r\n    IERC20 private BusdInterface;\r\n    address public tokenAdress;\r\n    address TSLAholder = address(0);\r\n    address smallTSLAholder = address(0);\r\n    address Kingholder = address(0);\r\n    uint256 topdeposit;\r\n    uint256 smalltopdeposit;\r\n    bool public init = false;\r\n    address[] public Whitelist_TSLA = _BUSDOracle(BUSDaddress).getWhitelist();\r\n\r\n    constructor(address _teamwallet, address _mkt) {\r\n       teamwallet =_teamwallet;\r\n       mkt =_mkt;\r\n        priceFeed = AggregatorV3Interface(0xEEA2ae9c074E87596A85ABE698B2Afebc9B57893); //TSLA/usd pricefeed mainnet\r\n        //priceFeed = AggregatorV3Interface(0x2514895c72f50D8bd4B4F9b1110F0D6bD2c97526); //BNB/usd pricefeed testnet\r\n        //tokenAdress = 0x25C7c87B42ec086b01528eE72465F1e3c49B7B9D; //testnet\r\n        tokenAdress = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56; //Mainnet\r\n        BusdInterface = IERC20(tokenAdress);\r\n        lastprice = getLatestPrice();\r\n        }\r\n\r\n    struct refferal_system {\r\n        address ref_address;\r\n        uint256 reward;\r\n    }\r\n\r\n    struct refferal_withdraw {\r\n        address ref_address;\r\n        uint256 totalWithdraw;\r\n    }\r\n\r\n    struct user_investment_details {\r\n        address user_address;\r\n        uint256 invested;\r\n    }\r\n\r\n    struct user_weekly_details {\r\n        address user_address;\r\n        uint256 invested;\r\n        uint256 smallinvested;\r\n        uint256 reset_pasttime;\r\n        uint256 smallreset_pasttime;\r\n    }\r\n\r\n    struct weeklyWithdraw {\r\n        address user_address;\r\n        uint256 startTime;\r\n        uint256 deadline;\r\n    }\r\n\r\n    struct claimDaily {\r\n        address user_address;\r\n        uint256 startTime;\r\n        uint256 deadline;\r\n    }\r\n\r\n    struct userWithdrawal {\r\n        address user_address;\r\n        uint256 amount;\r\n    }\r\n\r\n    struct userTotalWithdraw {\r\n        address user_address;\r\n        uint256 amount;\r\n    }\r\n     struct userTotalRewards {\r\n        address user_address;\r\n        uint256 amount;\r\n    } \r\n    struct userROI {\r\n        address user_address;\r\n        uint256 amount;\r\n    }\r\n\r\n    mapping(address =\u003e refferal_system) public refferal;\r\n    mapping(address =\u003e user_investment_details) public investments;\r\n    mapping(address =\u003e user_weekly_details) public weekly_investments;\r\n    mapping(address =\u003e weeklyWithdraw) public weekly;\r\n    mapping(address =\u003e claimDaily) public claimTime;\r\n    mapping(address =\u003e userWithdrawal) public approvedWithdrawal;\r\n    mapping(address =\u003e userTotalWithdraw) public totalWithdraw;\r\n    mapping(address =\u003e userTotalRewards) public totalRewards; \r\n    mapping(address =\u003e refferal_withdraw) public refTotalWithdraw;\r\n    mapping(address =\u003e userROI) public currentROI;\r\n\r\n    //check if address is whitelisted in BUSD Oracle\r\n    function isWhiteListed(address _address) public view returns (bool) {\r\n    for (uint i = 0; i \u003c Whitelist_TSLA.length; i++) {\r\n        if (Whitelist_TSLA[i] == _address) {\r\n            return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function ChangeROI() private {\r\n        if (getLatestPrice() - lastprice != 0){\r\n        pricediff = getLatestPrice() - lastprice;\r\n            if (pricediff \u003c 0 \u0026\u0026 roi \u003c= 29) {\r\n                roi += 1;\r\n            }else if (pricediff \u003e 0 \u0026\u0026 roi \u003e= 11) {\r\n                roi -= 1;    \r\n            }\r\n            if (pricediff \u003e 0 \u0026\u0026 currentROI[msg.sender].amount \u003e= 11) {currentROI[msg.sender].amount -= 1;}\r\n            else if (pricediff \u003c 0 \u0026\u0026 currentROI[msg.sender].amount \u003c= 29) {currentROI[msg.sender].amount += 1;}\r\n            }\r\n        lastprice = getLatestPrice();\r\n    }\r\n\r\n    //get BUSDoracle current holder\r\n    function currentBUSDHolder() external view returns(address) {\r\n            return _BUSDOracle(BUSDaddress).OracleHolder();\r\n    }\r\n\r\n    function Oraclemanagement(address _user, uint256 _amount) internal {\r\n\r\n            uint256 _nowtime = block.timestamp;\r\n\r\n             //weekly deposits reset for a new Oracle to be assigned, this event happens weekly only\r\n            if (_nowtime \u003e= resets){\r\n                TSLAholder = address(0);\r\n                topdeposit = 0;\r\n                resets = _nowtime + 7 days;\r\n            }\r\n\r\n            if (block.timestamp \u003e= smallresets){\r\n                smallTSLAholder = address(0);\r\n                smalltopdeposit = 0;\r\n                smallresets = _nowtime + 3 days;\r\n            }\r\n\r\n            //check needed to reset weekly investement of the user\r\n            if (weekly_investments[_user].reset_pasttime != resets){\r\n                weekly_investments[_user].reset_pasttime = resets;\r\n                weekly_investments[_user].invested = 0;\r\n                }\r\n            if (weekly_investments[_user].smallreset_pasttime != smallresets){\r\n                weekly_investments[_user].smallreset_pasttime = smallresets;\r\n                weekly_investments[_user].smallinvested = 0;\r\n                }\r\n                \r\n            uint256 totinvested = weekly_investments[_user].invested + _amount;\r\n            uint256 mintotinvested = weekly_investments[_user].smallinvested + _amount;\r\n            //if weekly top depositor, users gets the oracle\r\n            if (totinvested \u003e topdeposit \u0026\u0026 totinvested \u003e= 3000 ether){\r\n                TSLAholder =  _user;\r\n                topdeposit = totinvested;\r\n            }\r\n\r\n            else if (mintotinvested \u003e smalltopdeposit \u0026\u0026 mintotinvested \u003c 3000 ether){\r\n                smallTSLAholder =  _user;\r\n                smalltopdeposit = mintotinvested;\r\n            }\r\n        }\r\n\r\n    // invest function \r\n    function deposit(address _ref, uint256 _amount) public  {\r\n        require(init \u0026\u0026 !isContract(msg.sender));\r\n        require(_amount \u003e= min \u0026\u0026 _amount \u003c= max, \"Cannot Deposit\");\r\n\r\n        Oraclemanagement(msg.sender, _amount);\r\n        uint256 total_fee = depositFee(_amount);\r\n        uint256 nowtimer = block.timestamp;\r\n        \r\n        //fees whitelist can access 2 days before with 50% discount\r\n        if (nowtimer - WhiteTime \u003c= 2 days){\r\n            //update whitelist\r\n            Whitelist_TSLA = _BUSDOracle(BUSDaddress).getWhitelist();\r\n            require (isWhiteListed(msg.sender) == true, \"only whitelists allowed for the first 2 days\");\r\n            uint256 fee_gen = (total_fee / 10); //1% fees\r\n            uint256 total_contract = _amount - total_fee;\r\n            BusdInterface.transferFrom(msg.sender,teamwallet,fee_gen * 3);  //2% goes to the dev\r\n            BusdInterface.transferFrom(msg.sender,mkt,fee_gen * 2);  //2% goes to mkt\r\n            BusdInterface.transferFrom(msg.sender,address(this),total_contract);\r\n        } else {\r\n            uint256 fee_oracle = total_fee / 10 * 4;  //4% goes into BUSD Oracle\r\n            uint256 total_contract = _amount - total_fee;\r\n            BusdInterface.transferFrom(msg.sender,teamwallet,fee_oracle);  //4% goes to the dev\r\n            BusdInterface.transferFrom(msg.sender,mkt,fee_oracle / 2);  //2% goes to mkt\r\n            BusdInterface.transferFrom(msg.sender,BUSDaddress,fee_oracle); //4% to the BUSD oracle\r\n            BusdInterface.transferFrom(msg.sender,address(this),total_contract);\r\n        }\r\n\r\n        //ref system, only 1 ref for new deposits\r\n        if(!checkAlready()){  \r\n            uint256 ref_fee_add = refFee(_amount);\r\n\r\n            //if user is new their ROI = General ROI\r\n            currentROI[msg.sender] = userROI(msg.sender,roi);\r\n        if(_ref != address(0) \u0026\u0026 _ref != msg.sender) {\r\n            uint256 ref_last_balance = refferal[_ref].reward;\r\n            uint256 totalRefFee = ref_fee_add + ref_last_balance;   \r\n            refferal[_ref] = refferal_system(_ref,totalRefFee);\r\n            }\r\n        } \r\n\r\n        //If user not new, update user ROI\r\n        else {ChangeROI();}\r\n        \r\n        // investment details\r\n        uint256 userLastInvestment = investments[msg.sender].invested;\r\n        uint256 userCurrentInvestment = _amount - depositFee(_amount);\r\n        \r\n        //totalweekly is the amount that users deposit in a 7 days range, unlike the total user deposit, this refreshes weekly\r\n        uint256 totalweekly = weekly_investments[msg.sender].invested + _amount;\r\n\r\n        //total days refreshes every 48 hours and it is needed to assign the small oracle, total amount has to be less than 3k BUSD\r\n        uint256 totaldays = weekly_investments[msg.sender].smallinvested;\r\n        if (totalweekly \u003c 3000 ether){\r\n            totaldays += _amount;\r\n        }\r\n        \r\n        weekly_investments[msg.sender] = user_weekly_details(msg.sender,totalweekly,totaldays,resets,smallresets);\r\n\r\n        uint256 totalInvestment = userLastInvestment + userCurrentInvestment;\r\n        investments[msg.sender] = user_investment_details(msg.sender,totalInvestment);\r\n\r\n        //oracle swap\r\n        \r\n        UpdateTime();        \r\n    }\r\n\r\n    function UpdateTime() internal {\r\n       \r\n        uint256 claimTimeStart = block.timestamp;\r\n        uint256 claimTimeEnd = block.timestamp + 4 days;\r\n        claimTime[msg.sender] = claimDaily(msg.sender,claimTimeStart,claimTimeEnd);\r\n\r\n        uint256 weeklyStart = block.timestamp;\r\n        uint256 deadline_weekly = block.timestamp + 8 days;\r\n        weekly[msg.sender] = weeklyWithdraw(msg.sender,weeklyStart,deadline_weekly);\r\n        \r\n    }\r\n\r\n    function userReward(address _userAddress) public view returns(uint256) {\r\n        uint256 userInvestment = investments[_userAddress].invested;\r\n\r\n        //daily rewards need to be mutiplied for max claiming deadline (4 days)\r\n        uint256 userDailyReturn = DailyRoi(userInvestment, _userAddress) * 4;\r\n    \r\n        // invested time\r\n        uint256 claimInvestTime = claimTime[_userAddress].startTime;\r\n        uint256 claimInvestEnd = claimTime[_userAddress].deadline;\r\n\r\n        uint256 totalTime = claimInvestEnd - claimInvestTime;\r\n        uint256 value = userDailyReturn / totalTime;\r\n        uint256 nowTime = block.timestamp;\r\n\r\n        if(claimInvestEnd \u003e= nowTime) { \r\n        uint256 earned = nowTime - claimInvestTime;\r\n        uint256 totalEarned = earned * value;\r\n\r\n        return totalEarned;\r\n        }\r\n        else {\r\n            return userDailyReturn;\r\n        }\r\n    }\r\n\r\n    function withdrawal() public {\r\n    require(init, \"Not Started Yet\");   \r\n    require(weekly[msg.sender].deadline \u003c= block.timestamp, \"You cant withdraw\");    \r\n    Oraclemanagement(msg.sender, 0);\r\n\r\n    uint256 weeklyStart = block.timestamp;\r\n    uint256 deadline_weekly = block.timestamp + 8 days;\r\n    weekly[msg.sender] = weeklyWithdraw(msg.sender,weeklyStart,deadline_weekly);\r\n    \r\n    uint256 aval_withdraw = approvedWithdrawal[msg.sender].amount;\r\n    BusdInterface.transfer(msg.sender,aval_withdraw);\r\n    approvedWithdrawal[msg.sender] = userWithdrawal(msg.sender , 0 ); \r\n    uint256 amount = totalWithdraw[msg.sender].amount;\r\n    uint256 totalAmount = amount + aval_withdraw; \r\n    totalWithdraw[msg.sender] = userTotalWithdraw(msg.sender,totalAmount);\r\n\r\n    ChangeROI();\r\n\r\n    }\r\n    \r\n    function compound() public {\r\n    require(init, \"Not Started Yet\");   \r\n   \r\n    if (weekly[msg.sender].deadline \u003c= block.timestamp){\r\n            weekly[msg.sender].deadline = block.timestamp + 2 days; \r\n        }\r\n        else {\r\n            weekly[msg.sender].deadline += 2 days;\r\n        }\r\n    \r\n    uint256 aval_withdraw = approvedWithdrawal[msg.sender].amount;\r\n    approvedWithdrawal[msg.sender] = userWithdrawal(msg.sender , 0);\r\n\r\n    Oraclemanagement(msg.sender, aval_withdraw);\r\n    weekly_investments[msg.sender].invested += aval_withdraw;\r\n\r\n    if (weekly_investments[msg.sender].invested \u003c 3000 ether)\r\n        {\r\n            weekly_investments[msg.sender].smallinvested += aval_withdraw;\r\n        }\r\n    \r\n\r\n    uint256 claimTimeStart = block.timestamp;\r\n    uint256 claimTimeEnd = block.timestamp + 4 days;\r\n    claimTime[msg.sender] = claimDaily(msg.sender,claimTimeStart,claimTimeEnd);\r\n\r\n    // investment details\r\n    uint256 userLastInvestment = investments[msg.sender].invested;\r\n    uint256 userCurrentInvestment = aval_withdraw;\r\n    uint256 totalInvestment = userLastInvestment + userCurrentInvestment;\r\n    investments[msg.sender] = user_investment_details(msg.sender,totalInvestment);\r\n\r\n    ChangeROI();\r\n    }\r\n    \r\n    function claimDailyRewards() public {\r\n        require(init, \"Not Started Yet\");\r\n        \r\n        //Users can claim only after 1 days or keep accumulating rewards up to 4 days\r\n        require(claimTime[msg.sender].deadline - 3 days \u003c= block.timestamp, \"You cant claim before 24 hours\");  \r\n\r\n        Oraclemanagement(msg.sender, 0);\r\n        //claim rewards before assigning a new claiming time\r\n        uint256 rewards = userReward(msg.sender);\r\n        uint256 claimTimeStart = block.timestamp;\r\n\r\n        uint256 claimTimeEnd = claimTimeStart + 4 days;\r\n        claimTime[msg.sender] = claimDaily(msg.sender,claimTimeStart,claimTimeEnd);\r\n\r\n        \r\n        uint256 currentApproved = approvedWithdrawal[msg.sender].amount;\r\n        uint256 value = rewards + currentApproved;\r\n\r\n        approvedWithdrawal[msg.sender] = userWithdrawal(msg.sender,value);\r\n        uint256 amount = totalRewards[msg.sender].amount; \r\n        uint256 totalRewardAmount = amount + rewards; \r\n        totalRewards[msg.sender].amount = totalRewardAmount;\r\n        address nowholder = _BUSDOracle(BUSDaddress).OracleHolder();\r\n\r\n        //the oracle holder receives a bonus on any claim, if they holder holds both Oracles this bonus is doubled\r\n        if (nowholder == TSLAholder){\r\n            Kingholder = TSLAholder;\r\n            if (msg.sender != TSLAholder){\r\n                uint256 BonusOracle = (rewards * 6 / 100) + approvedWithdrawal[TSLAholder].amount;\r\n                approvedWithdrawal[TSLAholder] = userWithdrawal(TSLAholder,BonusOracle);\r\n                } \r\n            }\r\n                else {\r\n                Kingholder = address(0);\r\n                uint256 BonusOracle = (rewards * 3 / 100) + approvedWithdrawal[TSLAholder].amount;\r\n                approvedWithdrawal[TSLAholder] = userWithdrawal(TSLAholder,BonusOracle);\r\n                }\r\n\r\n        if (msg.sender != smallTSLAholder \u0026\u0026 msg.sender != TSLAholder){\r\n                uint256 BonusOracle = (rewards / 100) + approvedWithdrawal[smallTSLAholder].amount;\r\n                approvedWithdrawal[smallTSLAholder] = userWithdrawal(smallTSLAholder,BonusOracle);\r\n                } \r\n            \r\n        //set new ROI\r\n        ChangeROI();\r\n    }\r\n\r\n\r\n    function Ref_Withdraw() external {\r\n        require(init, \"Not Started Yet\");\r\n        uint256 value = refferal[msg.sender].reward;\r\n\r\n        BusdInterface.transfer(msg.sender,value);\r\n        refferal[msg.sender] = refferal_system(msg.sender,0);\r\n\r\n        uint256 lastWithdraw = refTotalWithdraw[msg.sender].totalWithdraw;\r\n        uint256 totalValue = value + lastWithdraw;\r\n\r\n        refTotalWithdraw[msg.sender] = refferal_withdraw(msg.sender,totalValue);\r\n    }\r\n\r\n    // initialized the market\r\n    function signal_market() external {\r\n        require (msg.sender == teamwallet \u0026\u0026 init == false, \"Already Init\");\r\n        init = true;\r\n        WhiteTime = block.timestamp;\r\n\r\n        //the first cycle of resets has 1 more day (1 full day is wasted before users can claim)\r\n        resets = block.timestamp + 8 days;\r\n        smallresets = block.timestamp + 3 days;\r\n    }\r\n\r\n    //Owner can call Oraclemanagement to update the platform (in case there there are few claims to trigger it in the first few days after 1 week)\r\n    function callmanagement() external onlyOwner {\r\n        require(block.timestamp \u003e= resets,\"Oracle can reset every 7 days only\");\r\n        Oraclemanagement(msg.sender, 0);\r\n    }\r\n\r\n    //Multisign requried to change address\r\n    function changeOracle (address _neworacle) external onlyOwner {\r\n       BUSDaddress = _neworacle;\r\n    }\r\n\r\n    function changeMkt (address _mkt) external {\r\n    require (msg.sender == mkt, \"sender must be mkt\");\r\n       mkt = _mkt;\r\n    }\r\n\r\n    function changeDev (address _dev) external {\r\n    require (msg.sender == teamwallet, \"sender must be dev\");\r\n       teamwallet = _dev;\r\n    }\r\n\r\n    function resetRoi() external {\r\n        require(init, \"Not Started Yet\");\r\n        BusdInterface.transferFrom(msg.sender,address(this), 50 ether);\r\n        currentROI[msg.sender].amount = 20;\r\n    }\r\n\r\n    //to be used if the max is reached so the Oracle can be passed again\r\n    function changeMaxdep (uint256 _max) external onlyOwner {\r\n        require (_max \u003e max, \"you cant lower max deposit\");\r\n        max = _max;\r\n    }\r\n\r\n    \r\n\r\n    // only view functions\r\n    function isContract(address addr) internal view returns (bool) {\r\n        uint size;\r\n        assembly { size := extcodesize(addr) }\r\n        return size \u003e 0;\r\n    }\r\n\r\n    // call Chainlink to fetch a new BNB price\r\n    function getLatestPrice() public view returns (int) {\r\n        (\r\n            ,\r\n            /*uint80 roundID*/ int price /*uint startedAt*/ /*uint timeStamp*/ /*uint80 answeredInRound*/,\r\n            ,\r\n            ,\r\n        ) = priceFeed.latestRoundData();\r\n        return price;\r\n    }\r\n\r\n    function DailyRoi(uint256 _amount, address _sender) public view returns(uint256) {\r\n        uint256 currentrr = currentROI[_sender].amount;\r\n            return _amount * currentrr / 1000;\r\n    }\r\n\r\n    function OracleHolder() external view returns(address) {\r\n            return TSLAholder;\r\n    }\r\n\r\n    function smallOracleHolder() external view returns(address) {\r\n            return smallTSLAholder;\r\n    }\r\n\r\n    function smallTopdeposit() external view returns(uint256) {\r\n            return smalltopdeposit;\r\n    }\r\n\r\n    function KNGHolder() external view returns(address) {\r\n            if (_BUSDOracle(BUSDaddress).OracleHolder() == TSLAholder){\r\n            return TSLAholder;\r\n    }       else{\r\n            return address(0);\r\n            }\r\n    }\r\n\r\n    function BUSDoracleHolder() external view returns(address) {\r\n            return _BUSDOracle(BUSDaddress).OracleHolder();\r\n    }\r\n\r\n    function BUSDoracledeposit() external view returns(uint256) {\r\n            return _BUSDOracle(BUSDaddress).Topdeposit();\r\n    }\r\n\r\n    function returnROI() external view returns(uint256) {\r\n            return roi;\r\n    }\r\n    \r\n    function returnDIFF() external view returns(int256) {\r\n            return pricediff;\r\n    }\r\n\r\n    function Topdeposit() external view returns(uint256) {\r\n            return topdeposit;\r\n    }\r\n\r\n    function resetTime() external view returns(uint256) {\r\n            return resets;\r\n    }\r\n\r\n    function smallresetTime() external view returns(uint256) {\r\n            return smallresets;\r\n    }\r\n\r\n    function MinClaim(address _user) external view returns(uint256) {\r\n            return claimTime[_user].deadline - 3 days;\r\n    }\r\n\r\n    function checkAlready() public view returns(bool) {\r\n         address _address= msg.sender;\r\n        if(investments[_address].user_address == _address){\r\n            return true;\r\n        }\r\n        else{\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function depositFee(uint256 _amount) private view returns(uint256){\r\n     return _amount * fee / 100;\r\n    }\r\n\r\n    function refFee(uint256 _amount) public pure returns(uint256) {\r\n        return _amount * ref_fee / 100;\r\n    }\r\n\r\n    function getBalance() public view returns(uint256){\r\n         return BusdInterface.balanceOf(address(this));\r\n    }\r\n}\r\n"}}