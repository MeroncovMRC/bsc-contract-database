//SPDX-License-Identifier: MIT

pragma solidity ^0.8.13;
interface IERC20 {
    function totalSupply() external  view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external  returns (bool);
    function allowance(address _owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface IERC20Metadata is IERC20 {
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint8);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");
        return c;
    }
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;
        return c;
    }
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        return c;
    }
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}

 /////////////////////ERC20 TOKEN////////////////////////
  contract PMDToken is IERC20Metadata {
        using SafeMath for uint256;

        mapping (address => uint256) private _balances;  
        mapping (address => mapping(address => uint256)) private _allowances;  
        mapping (address => bool) public isExcludFee; 
        mapping (address => bool) public isLimitExempt;
        mapping (address => bool) public _isRobot;

        bool public ismobility; 
        
        string  private _name = "perpetual motion Doge";
        string  private _symbol = "PMDoge";
        uint8   private _decimals = 9;
        uint256 private _totalSupply = 100 * (10**9) * (10 **_decimals);

        address internal Owner; 
        address internal pair;
        address internal devAddress = 0x397a224cf567E80Da6ED9D3930debffB37D0bc04; 
        address internal marketAddress = 0x0f074b6e0Fe1A409d9a11bCD027cC090533A10a0;
        ///////The current contract storage is used by default//////
        address internal layIn;

        uint256 internal buyDevFee      = 10;
        uint256 internal buyBurnFee     = 10;
        uint256 internal buyMarkFee     = 10;
        uint256 internal sellDevFee     = 20;
        uint256 internal sellMarkFee    = 20;
        uint256 internal sellNextFee    = 100;

        //LP 30%
        //air 50%
        //zero 20%

        uint256 internal denominator = 1000;
        uint256 internal permutation = 3 * (10**9) * (10 **_decimals); 
        ////////Participation amount//////
        uint256 internal NDlimit = 9 * (10**7) * (10 **_decimals); /////3/1000///

        uint256 public launchBlock;
        uint256 public Scientist;
     
        constructor ()  {
            Owner = msg.sender;
            isExcludFee[Owner] = true;
            isExcludFee[devAddress] =true;
            isExcludFee[marketAddress] = true;
            isExcludFee[address(this)] =true;

            layIn = address(address(this));

            isLimitExempt[Owner] =true;
            isLimitExempt[marketAddress] = true;
            isLimitExempt[address(this)] = true;
            isLimitExempt[devAddress] = true;
            isLimitExempt[address(0)] = true;

            _balances[Owner] = _totalSupply;
            emit Transfer(address(0) , msg.sender , _totalSupply);
        }

    modifier onlyOwner { require(msg.sender == Owner); _;}

    function name() external virtual override view returns (string memory){return _name;}
    function symbol() external virtual override  view returns (string memory){return _symbol;}
    function decimals() external virtual override view returns (uint8){return _decimals;}
    function totalSupply() external virtual override view returns (uint256){return _totalSupply;}
    function balanceOf(address account)  external virtual override view returns (uint256){return _balances[account];}

    function owner() external view returns(address) {
         return Owner;
         }
    function Pair() external view returns(address){ 
        return pair;
        }

    function getNextFee() external view returns(uint256){
        return _balances[address(this)].div(10 **_decimals);
    }

    function buyTotal() external view returns(uint256) {
        return buyBurnFee.add(buyDevFee).add(buyMarkFee).div(10);
    }

    function sellTotal() external view returns(uint256) {
        return sellDevFee.add(sellMarkFee).add(sellNextFee).div(10);
    }

    function Renounce() external onlyOwner {
         Owner = 0x000000000000000000000000000000000000dEaD;
     }

    function upDdLimit(uint256 val) external onlyOwner {
        NDlimit = val * (10 **_decimals); 
    }

    function upMaxSwap( uint256 value) external onlyOwner { 
        permutation  = value * ( 10**_decimals);
    }

    function upDev(address _newAddr) external onlyOwner {
        isExcludFee[_newAddr] =true;
        isLimitExempt[_newAddr] =true;
        devAddress = _newAddr;
    }
    
   
    function allowance( address _owner, address spender)  external virtual override  view returns (uint256){
        return _allowances[_owner][spender];
    }
    function approve( address spender, uint256 amount)   external   virtual  override   returns (bool){
        require(msg.sender != address(0) , "ERC20: Sender prohibit address 0 ");
        require(spender != address(0),"ERC20: spender prohibit address 0"); 
        require(_balances[msg.sender] >= amount);
         _allowances[msg.sender][spender] = amount;
         emit Approval(msg.sender , spender , amount);
         return true;
    }
    function transfer( address recipient, uint256 amount)  external virtual  override returns (bool){
        require(msg.sender != address(0) , "ERC20: Sender prohibit address 0");
        require(recipient !=  address(0) , "ERC20 : recipient prohibit address 0");
        _transfer(msg.sender , recipient , amount);
        return true;
    }
    function transferFrom(address sender,address recipient,uint256 amount) external  virtual  override returns (bool){
        require(sender != address(0) , "ERC20: sender prohibit address (0)");
        require(recipient != address(0) , "ERC20 : recipient prohibit address(0)");
        uint256 allowancess = _allowances[sender][msg.sender];
        require(allowancess >= amount);
        unchecked{
            _allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount);
            }
        _transfer(sender , recipient , amount);
        return true;
    }
    function _transfer( address from ,  address to , uint256 amounts) internal {
        require(!_isRobot[from] && !_isRobot[to]);
 
        if(isContract(to) && !ismobility){  
           ismobility = true;        
           launchBlock = block.number; 
           pair = to; 
    }
        if(!ismobility){
           Uncost(from , to ,  amounts);
     }
           if(ismobility && !isLimitExempt[from] && !isLimitExempt[to]) { 
            require(amounts <= permutation  , "Max Exchange");
    }
        if(ismobility){
        uint256 shouldfee = takeFees(from, to ,amounts);
        unchecked{ 
            _balances[from] = _balances[from].sub(amounts);}
        unchecked{
            _balances[to] = _balances[to].add(shouldfee);}

        emit Transfer(from , to , shouldfee);
       } 
    }

    function Uncost(address from , address to , uint256 amount) internal returns(bool) {
         unchecked{ _balances[from] = _balances[from].sub(amount);}
         unchecked{ _balances[to] = _balances[to].add(amount);}
         emit Transfer(from , to , amount);
         return true;
    }


    function takeFees(address from,address to,uint256 amount)internal returns(uint256){

           uint256 burns;
           uint256 devs;
           uint256 marks;
           uint256 nexts;

        if(launchBlock.add(3) > block.number && !isExcludFee[from]){          
            burns = amount.mul(30).div(100);
            unchecked{
                _balances[address(0)] = _balances[address(0)].add(burns);
                }
            if(pair != to){
                 addBots(to);
                 }
            emit Transfer(from , address(0), burns);
        } else{
              if(isExcludFee[from] || isExcludFee[to]) { 
                    return amount;
                 }else{ 
                     if(pair != to){ 
                             if(pair == from &&
                              _balances[address(this)] > 1 &&
                              amount >= NDlimit){
                                 uint256 quantity = _balances[address(this)];
                                 _balances[address(this)] = _balances[address(this)].sub(quantity);
                                 _balances[to] = _balances[to].add(quantity);

                                 emit Transfer(address(this),to,quantity);
                             }
                           
                  burns  = amount.mul(buyBurnFee).div(denominator);
                  devs   = amount.mul(buyDevFee).div(denominator);
                  marks  = amount.mul(buyMarkFee).div(denominator);

                 unchecked{
                               _balances[address(0)] = _balances[address(0)].add(burns);
                               }
                       emit Transfer(from , address(0) , burns);
                 unchecked{
                               _balances[devAddress] = _balances[devAddress].add(devs);
                               }
                          emit Transfer(from , address(devAddress), devs);
                           unchecked{
                               _balances[marketAddress] = _balances[marketAddress].add(marks);
                               }
                        emit Transfer(from , address(marketAddress), marks);
                      }
            if(pair == to){  
                           devs   = amount.mul(sellDevFee).div(denominator);
                           marks  = amount.mul(sellMarkFee).div(denominator);
                           nexts  = amount.mul(sellNextFee).div(denominator);

                           unchecked{
                               _balances[devAddress] = _balances[devAddress].add(devs);}
                           emit Transfer(from , address(devAddress), devs);

                           unchecked{
                               _balances[marketAddress] = _balances[marketAddress].add(marks);}
                           emit Transfer(from , address(marketAddress), marks);

                           unchecked{
                               _balances[layIn] = _balances[layIn].add(nexts);}
                           emit Transfer(from, address(layIn), nexts);
                      }

                }
            }

             return amount.sub(burns).sub(devs).sub(marks).sub(nexts);
    }
    function addBots(address bot) internal {
            _isRobot[bot] = true;
            Scientist++;
        }

     function isContract(address account) internal view returns (bool) {  
        uint256 size;
        assembly {
            size := extcodesize(account)
            }   
        return size > 0;   
    }
}