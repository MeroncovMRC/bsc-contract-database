/********************** @2022 Wizarre, All rights reserved *********************
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMmMMMMMMMMMMMMMNNMMMMNddNMMMMmmmmmNMMMMNddNMMMMNMMMMMMMMMMMMMMmMMMMMMMMM
MMMMMMMMdysNhoossydNMmosyyMM+ddd-NhssdNMMNdsshN-ddd+MMsysomMNdyssoohNysdMMMMMMMM
MMMMMMMMmss::NMMh/+o+/-ohhMMhhdm`:hNNmMMMMmMNy:.mdhhMNhho-/+o+/dMMN-:ssmMMMMMMMM
MMMMMMMMNoMhyhdNNNmsoyNh/:mMMMs.oNMhoNMMMMmodMNo.yMMMd:/hNyoymNNNdhyhNoNMMMMMMMM
MMMMMMMNy/:shhhhy/-syyhhy`.hho :hho-yhhhhhhy-shh: ohh.`yhhyyo./yhhhhs:/hNMMMMMMM
MMMMMMMd `+://sso:`.`---/:osoo.syhh+yyyssyyyohhyo-osso:/---`.`/oss//:o  mMMMMMMM
MMMMMMMd `s+s+:..``.-+yhmyddhhsmyoyosddyyddsoyoymsyhdhymhy+-.``..:+s+y  mMMMMMMM
MMMMMMMd  sm`  -shhy. sMNys+ho+ssymyoodmmhooydyos+oh+yyMMo -yhhs-  `ms  mMMMMMMM
MMMMMMMd `yds` `/ss+:/hddddhhodNNhdssyNMMNyssdhNNhshhddddh/:+ss/` `ydy  mMMMMMMM
MMMMMMMd  ooNh/-..`````     :sdhdssddshmmhsddsydhdo-     `````..-/dNoo  mMMMMMMM
MMMMMMMd `md+ymddysohs.   `odmmdoyNoNmohhoNNoNssdmmho`   .yhosyddmy+dm  mMMMMMMM
MMMMMMMd `Nmh+/oyo-+o` `  syMMsM/dy/NhdyhhhN:yd+MsMNyo  ` `o+-oyo:+hmm  mMMMMMMM
MMMMMMMd  -NNy+/+yy.  :../odyhohssohyhsooshshossh+hyd+/`-:  -yy+/+yNm.  mMMMMMMM
MMMMMMMd -/-::yNN/   +/`so/shhssyhyy+yy++hy+hshysyhho:oo`++   +Nms::-/. mMMMMMMM
MMMMMMMd oMy/MMh.   ss hMNNhs+:/++++/yhyyhy/++++::oshNhNy ys   .hMM:hM+ mMMMMMMM
MMMMMMMd hMooMo    ym`oMdhymhyo/    `ooo+oo`    .shhdmyhM+`ms    oM+oMy mMMMMMMM
MMMMMMMd mMsy-    yM:`Nmsdyhysys:  ` `:ys/` ` `hmMMdsshsom /My    :ysMm mMMMMMMM
MMMMMMMd.MMd.    yMh :yssMNhshymNy: /``Nm .: .yNdMN/hmMddM- dMs    .mMM`mMMMMMMM
MMMMMMMdoMh`    oMM- :omdoMMMMdhddm/ s.--.s /mhshMhydhhdoN/ :MM+    `dM+mMMMMMMM
MMMMMMMdmh`    :MMd  /yhhh+s:ysyy+hN+`d..d`+ddhyyssNNyddss+  mMM-    `ddmMMMMMMM
MMMMMMMMh`     dMMy  :hodoNoy+hysdmym-+dd/-mymhdhdyd+NNmyN-  hMMd     `hMMMMMMMM
MMMMMMMM.      .sNMh- /yddyms+NMm:mmhs`Nm yMmhdssyhs+dy+o: -dMNs`      .MMMMMMMM
MMMMMMMNd:       .sNNs.`sNNyhhoNMm+dh-`dd`:Moymhhdyhsdho`.sNNs.       /mMMMMMMMM
MMMMMMMdhmo:`      .odm+`:sddmmsmmo/o +--+ /dymddhhmms-`+md+`      `:sNymMMMMMMM
MMMMMMMd/sy:do-      `:hh/`:sdmdydm- ./  /``odmyhydo-./dy:`      -sh:yy:mMMMMMMM
MMMMMMMd`m/.+shh+-      .os/`:ohdds  - // - `hMNhs-./s+.     `-+hhs/./m mMMMMMMM
MMMMMMMd -.mho/-hNds:.    `-/-`.oo`    --    `oo-`-/-`   `./sdNy-/sdm`- mMMMMMMM
MMMMMMMd  oMoo/.mNyooss+/-`  ``       `/:`       ``  .-/+ssoohMm.+osMo  mMMMMMMM
MMMMMMMd  myssh+hN.`o++/oNmo+/-.`  `.+hddh/.`  `.-++smm+/++o`.Nhohssyd  mMMMMMMM
MMMMMMMd  ++++osys-..--:/++:/yso+/:/o+-``-+o/:/+oss::++/:--..:syso++++  mMMMMMMM
MMMMMMMMh/.`-+hdmoohdmmmmddhmmmy+ooh/ .ys` +hoo+ymmmhddmmmmdhoomdh+-`.+hMMMMMMMM
MMMMMMMMMNmhs.`::`yhymdyoshNdsddyy. .+mNNm+` -yydhsmNhsoymdyhs /:`.sdmNMMMMMMMMM
MMMMMMMMMsohh.ymhy+//+./NMNssh+::.`+dmymmymd/`.::+hosNMm/.+//+yhmy.dh+yMMMMMMMMM
MMMMMMMMMNhysmMMMMMMMMh+MNhNMMMNNMdysyNMMNssydMNNMMMNhNN+dMMMMMMMMmsydNMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/
// SPDX-License-Identifier: None

// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.4.1

// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}


// File @openzeppelin/contracts/interfaces/IERC20.sol@v4.4.1

// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)

pragma solidity ^0.8.0;



pragma solidity 0.8.6;

// Based on StableMath from mStable
// https://github.com/mstable/mStable-contracts/blob/master/contracts/shared/StableMath.sol

library StableMath {
    /**
     * @dev Scaling unit for use in specific calculations,
     * where 1 * 10**18, or 1e18 represents a unit '1'
     */
    uint256 private constant FULL_SCALE = 1e18;

    /**
     * @dev Provides an interface to the scaling unit
     * @return Scaling unit (1e18 or 1 * 10**18)
     */
    function getFullScale() internal pure returns (uint256) {
        return FULL_SCALE;
    }

    /**
     * @dev Scales a given integer to the power of the full scale.
     * @param x   Simple uint256 to scale
     * @return    Scaled value a to an exact number
     */
    function scaleInteger(uint256 x) internal pure returns (uint256) {
        return x * FULL_SCALE;
    }

    /***************************************
              PRECISE ARITHMETIC
    ****************************************/

    /**
     * @dev Multiplies two precise units, and then truncates by the full scale
     * @param x     Left hand input to multiplication
     * @param y     Right hand input to multiplication
     * @return      Result after multiplying the two inputs and then dividing by the shared
     *              scale unit
     */
    function mulTruncate(uint256 x, uint256 y) internal pure returns (uint256) {
        return mulTruncateScale(x, y, FULL_SCALE);
    }

    /**
     * @dev Multiplies two precise units, and then truncates by the given scale. For example,
     * when calculating 90% of 10e18, (10e18 * 9e17) / 1e18 = (9e36) / 1e18 = 9e18
     * @param x     Left hand input to multiplication
     * @param y     Right hand input to multiplication
     * @param scale Scale unit
     * @return      Result after multiplying the two inputs and then dividing by the shared
     *              scale unit
     */
    function mulTruncateScale(
        uint256 x,
        uint256 y,
        uint256 scale
    ) internal pure returns (uint256) {
        // e.g. assume scale = fullScale
        // z = 10e18 * 9e17 = 9e36
        // return 9e36 / 1e18 = 9e18
        return (x * y) / scale;
    }

    /**
     * @dev Multiplies two precise units, and then truncates by the full scale, rounding up the result
     * @param x     Left hand input to multiplication
     * @param y     Right hand input to multiplication
     * @return      Result after multiplying the two inputs and then dividing by the shared
     *              scale unit, rounded up to the closest base unit.
     */
    function mulTruncateCeil(uint256 x, uint256 y) internal pure returns (uint256) {
        // e.g. 8e17 * 17268172638 = 138145381104e17
        uint256 scaled = x * y;
        // e.g. 138145381104e17 + 9.99...e17 = 138145381113.99...e17
        uint256 ceil = scaled + FULL_SCALE - 1;
        // e.g. 13814538111.399...e18 / 1e18 = 13814538111
        return ceil / FULL_SCALE;
    }

    /**
     * @dev Precisely divides two units, by first scaling the left hand operand. Useful
     *      for finding percentage weightings, i.e. 8e18/10e18 = 80% (or 8e17)
     * @param x     Left hand input to division
     * @param y     Right hand input to division
     * @return      Result after multiplying the left operand by the scale, and
     *              executing the division on the right hand input.
     */
    function divPrecisely(uint256 x, uint256 y) internal pure returns (uint256) {
        // e.g. 8e18 * 1e18 = 8e36
        // e.g. 8e36 / 10e18 = 8e17
        return (x * FULL_SCALE) / y;
    }

    /***************************************
                    HELPERS
    ****************************************/

    /**
     * @dev Calculates minimum of two numbers
     * @param x     Left hand input
     * @param y     Right hand input
     * @return      Minimum of the two inputs
     */
    function min(uint256 x, uint256 y) internal pure returns (uint256) {
        return x > y ? y : x;
    }

    /**
     * @dev Calculated maximum of two numbers
     * @param x     Left hand input
     * @param y     Right hand input
     * @return      Maximum of the two inputs
     */
    function max(uint256 x, uint256 y) internal pure returns (uint256) {
        return x > y ? x : y;
    }

    /**
     * @dev Clamps a value to an upper bound
     * @param x           Left hand input
     * @param upperBound  Maximum possible value to return
     * @return            Input x clamped to a maximum value, upperBound
     */
    function clamp(uint256 x, uint256 upperBound) internal pure returns (uint256) {
        return x > upperBound ? upperBound : x;
    }
}




pragma solidity 0.8.6;

contract OwnableData {
    address public owner;
    address public pendingOwner;
}

contract Ownable is OwnableData {
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev `owner` defaults to msg.sender on construction.
     */
    constructor() {
        _setOwner(msg.sender);
    }

    /**
     * @dev Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.
     *      Can only be invoked by the current `owner`.
     * @param _newOwner Address of the new owner.
     * @param _direct True if `_newOwner` should be set immediately. False if `_newOwner` needs to use `claimOwnership`.
     * @param _renounce Allows the `_newOwner` to be `address(0)` if `_direct` and `_renounce` is True. Has no effect otherwise
     */
    function transferOwnership(
        address _newOwner,
        bool _direct,
        bool _renounce
    ) external onlyOwner {
        if (_direct) {
            require(_newOwner != address(0) || _renounce, "zero address");

            emit OwnershipTransferred(owner, _newOwner);
            owner = _newOwner;
            pendingOwner = address(0);
        } else {
            pendingOwner = _newOwner;
        }
    }

    /**
     * @dev Needs to be called by `pendingOwner` to claim ownership.
     */
    function claimOwnership() external {
        address _pendingOwner = pendingOwner;
        require(msg.sender == _pendingOwner, "caller != pending owner");

        emit OwnershipTransferred(owner, _pendingOwner);
        owner = _pendingOwner;
        pendingOwner = address(0);
    }

    /**
     * @dev Throws if called by any account other than the Owner.
     */
    modifier onlyOwner() {
        require(msg.sender == owner, "caller is not the owner");
        _;
    }

    function _setOwner(address newOwner) internal {
        address oldOwner = owner;
        owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}




pragma solidity 0.8.6;

contract LockableData {
    bool public locked;
}

contract Lockable is LockableData, Ownable {
    /**
     * @dev Locks functions with whenNotLocked modifier
     */
    function lock() external onlyOwner {
        locked = true;
    }

    /**
     * @dev Throws if called when unlocked.
     */
    modifier whenLocked {
        require(locked, "Lockable: unlocked");
        _;
    }

    /**
     * @dev Throws if called after it was locked.
     */
    modifier whenNotLocked {
        require(!locked, "Lockable: locked");
        _;
    }
}





pragma solidity 0.8.6;




contract SCRLVesting is Ownable, Lockable {
    using StableMath for uint256;

    // @notice address of vested token
    address public token;
    // @notice total tokens vested in contract
    uint256 public totalVested;
    // @notice total tokens already claimed form vesting
    uint256 public totalClaimed;

    struct Vest {
        uint256 dateStart; // start of claiming, can claim startTokens
        uint256 dateEnd; // after it all tokens can be claimed
        uint256 totalTokens; // total tokens to claim
        uint256 startTokens; // tokens to claim on start
        uint256 claimedTokens; // tokens already claimed
        uint256 cliffLength;
    }
    // @notice storage of vestings
    Vest[] internal vestings;
    // @notice map of vestings for user
    mapping(address => uint256[]) internal user2vesting;

    // @dev events
    event Claimed(address indexed user, uint256 amount);
    event Vested(address indexed user, uint256 totalAmount, uint256 endDate);

    /**
     * @dev Contract initiator
     * @param _token address of vested token
     */
    function init(address _token) external onlyOwner {
        require(_token != address(0), "_token address cannot be 0");
        require(token == address(0), "init already done");
        token = _token;
    }

    /**
     * @dev Add multiple vesting to contract by arrays of data
     * @param _users[] addresses of holders
     * @param _startTokens[] tokens that can be withdrawn at startDate
     * @param _totalTokens[] total tokens in vesting
     * @param _startDate date from when tokens can be claimed
     * @param _cliff cliff length after TGE initial distribution
     * @param _duration duration of the vesting after the cliff
     */
    function massAddHolders(
        address[] calldata _users,
        uint256[] calldata _startTokens,
        uint256[] calldata _totalTokens,
        uint256 _startDate,
        uint256 _cliff,
        uint256 _duration
    ) external onlyOwner whenNotLocked {
        uint256 len = _users.length;
        //cheaper to use one variable
        require((len == _startTokens.length) && (len == _totalTokens.length), "data size mismatch");
        uint256 i;
        for (i; i < len; i++) {
            _addHolder(_users[i], _startTokens[i], _totalTokens[i], _startDate, _cliff, _duration);
        }
    }

    /**
     * @dev Add new vesting to contract
     * @param _user address of a holder
     * @param _startTokens how many tokens are claimable at start date
     * @param _totalTokens total number of tokens in added vesting
     * @param _startDate date from when tokens can be claimed
     * @param _cliff cliff length after TGE initial distribution
     * @param _duration duration of the vesting after the cliff
     */
    function _addHolder(
        address _user,
        uint256 _startTokens,
        uint256 _totalTokens,
        uint256 _startDate,
        uint256 _cliff,
        uint256 _duration
    ) internal {
        require(_user != address(0), "user address cannot be 0");
        Vest memory v;
        v.startTokens = _startTokens;
        v.totalTokens = _totalTokens;
        v.dateStart = _startDate;
        v.cliffLength = _cliff;
        v.dateEnd = _startDate + _cliff + _duration;

        totalVested += _totalTokens;
        vestings.push(v);
        user2vesting[_user].push(vestings.length);
        // we are skipping index "0" for reasons
        emit Vested(_user, v.totalTokens, v.dateEnd);
    }

    /**
     * @dev Claim tokens from msg.sender vestings
     */
    function claim() external {
        _claim(msg.sender, msg.sender);
    }

    /**
     * @dev Claim tokens from msg.sender vestings to external address
     * @param _target transfer address for claimed tokens
     */
    function claimTo(address _target) external {
        _claim(msg.sender, _target);
    }

    /**
     * @dev internal claim function
     * @param _user address of holder
     * @param _target where tokens should be send
     * @return amt number of tokens claimed
     */
    function _claim(address _user, address _target) internal returns (uint256 amt) {
        require(_target != address(0), "claim, then burn");
        uint256 len = user2vesting[_user].length;
        require(len > 0, "no vestings for user");
        uint256 cl;
        uint256 i;
        for (i; i < len; i++) {
            Vest storage v = vestings[user2vesting[_user][i] - 1];
            cl = _claimable(v);
            v.claimedTokens += cl;
            amt += cl;
        }
        if (amt > 0) {
            totalClaimed += amt;
            _transfer(_target, amt);
            emit Claimed(_user, amt);
        } else revert("nothing to claim");
    }

    /**
     * @dev Internal function to send out claimed tokens
     * @param _user address that we send tokens
     * @param _amt amount of tokens
     */
    function _transfer(address _user, uint256 _amt) internal {
        require(IERC20(token).transfer(_user, _amt), "token transfer failed");
    }

    /**
     * @dev Count how many tokens can be claimed from vesting to date
     * @param _vesting Vesting object
     * @return canWithdraw number of tokens
     */
    function _claimable(Vest memory _vesting) internal view returns (uint256 canWithdraw) {
        uint256 currentTime = block.timestamp;
        uint256 cliffTime = _vesting.dateStart + _vesting.cliffLength;

        // not started
        if (_vesting.dateStart > currentTime) return 0;

        if (currentTime <= cliffTime) {
            // we are after start but before cliff
            canWithdraw = _vesting.startTokens;
        } else if (currentTime > cliffTime && currentTime < _vesting.dateEnd) {
            // we are somewhere in the middle

            // how much time passed (as fraction * 10^18)
            // timeRatio = (time passed * 1e18) / duration
            uint256 timeRatio = (currentTime - cliffTime).divPrecisely(_vesting.dateEnd - cliffTime);
            // how much tokens we can get in total to date
            canWithdraw = (_vesting.totalTokens - _vesting.startTokens).mulTruncate(timeRatio) + _vesting.startTokens;
        }
        // time has passed, we can take all tokens
        else {
            canWithdraw = _vesting.totalTokens;
        }
        // but maybe we take something earlier?
        canWithdraw -= _vesting.claimedTokens;
    }

    /**
     * @dev Read number of claimable tokens by user and vesting no
     * @param _user address of holder
     * @param _id his vesting number (starts from 0)
     * @return amount number of tokens
     */
    function getClaimable(address _user, uint256 _id) external view returns (uint256 amount) {
        amount = _claimable(vestings[user2vesting[_user][_id] - 1]);
    }

    /**
     * @dev Read total amount of tokens that user can claim to date from all vestings
     *      Function also includes tokens to claim from sale contracts that were not
     *      yet initiated for user.
     * @param _user address of holder
     * @return amount number of tokens
     */
    function getAllClaimable(address _user) public view returns (uint256 amount) {
        uint256 len = user2vesting[_user].length;
        uint256 i;
        for (i; i < len; i++) {
            amount += _claimable(vestings[user2vesting[_user][i] - 1]);
        }
    }

    /**
     * @dev Extract all the vestings for the user
     *      Also extract not initialized vestings from
     *      sale contracts.
     * @param _user address of holder
     * @return v array of Vest objects
     */
    function getVestings(address _user) external view returns (Vest[] memory) {
        uint256 len = user2vesting[_user].length;
        Vest[] memory v = new Vest[](len);

        // copy vestings
        uint256 i;
        for (i; i < len; i++) {
            v[i] = vestings[user2vesting[_user][i] - 1];
        }

        return v;
    }

    /**
     * @dev Read total number of vestings registered
     * @return number of registered vestings on contract
     */
    function getVestingsCount() external view returns (uint256) {
        return vestings.length;
    }

    /**
     * @dev Read single registered vesting entry
     * @param _id index of vesting in storage
     * @return Vest object
     */
    function getVestingByIndex(uint256 _id) external view returns (Vest memory) {
        return vestings[_id];
    }

    /**
     * @dev Read registered vesting list by range from-to
     * @param _start first index
     * @param _end last index
     * @return array of Vest objects
     */
    function getVestingsByRange(uint256 _start, uint256 _end) external view returns (Vest[] memory) {
        uint256 cnt = _end - _start + 1;
        uint256 len = vestings.length;
        require(_end < len, "range error");
        Vest[] memory v = new Vest[](cnt);
        uint256 i;
        for (i; i < cnt; i++) {
            v[i] = vestings[_start + i];
        }
        return v;
    }

    /**
     * @dev Recover BSC from contract to owner address.
     */
    function recoverBSC() external onlyOwner {
        payable(owner).transfer(address(this).balance);
    }

    /**
     * @dev Recover given ERC20 token from contract to owner address.
     *      Can't recover vested tokens.
     * @param _token address of ERC20 token to recover
     */
    function recoverErc20(address _token) external onlyOwner {
        uint256 _tokenBalance = IERC20(_token).balanceOf(address(this));
        require(_tokenBalance > 0, "nothing to recover");

        uint256 _tokenAvailableToClaim = _tokenBalance - (totalVested - totalClaimed);
        require(_tokenAvailableToClaim > 0, "not available to recover");

        IBadErc20(_token).transfer(owner, _tokenAvailableToClaim);
    }
}

/**
 * @title IBadErc20
 * @dev Interface for emergency recover any ERC20-tokens,
 *      even non-erc20-compliant like USDT not returning boolean
 */
interface IBadErc20 {
    function transfer(address _recipient, uint256 _amount) external;
}