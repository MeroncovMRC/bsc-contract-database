{"BaseFatToken.sol":{"content":"/**\n *  Created By: Fatsale\n *  Website: https://fatsale.finance\n *  Telegram: https://t.me/fatsale\n *  The Best Tool for Token Presale\n **/\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./ownable.sol\";\n\ncontract BaseFatToken is IERC20, Ownable {\n    bool public currencyIsEth;\n\n    bool public enableOffTrade;\n    bool public enableKillBlock;\n    bool public enableBlacklist;\n    bool public enableMint;\n    bool public enableSwapLimit;\n    bool public enableWalletLimit;\n    bool public enableChangeTax;\n\n    address public currency;\n    address public fundAddress;\n\n    uint256 public _buyFundFee = 0;\n    uint256 public _buyLPFee = 0;\n    uint256 public _buyBurnFee = 0;\n    uint256 public _sellFundFee = 500;\n    uint256 public _sellLPFee = 0;\n    uint256 public _sellBurnFee = 0;\n\n    uint256 public kb = 0;\n\n    uint256 public maxSwapAmount;\n    uint256 public maxWalletAmount;\n    uint256 public startTradeBlock;\n\n    string public override name;\n    string public override symbol;\n    uint256 public override decimals;\n    uint256 public override totalSupply;\n\n    uint256 public mintCycle;\n    uint256 public mintPercent;\n    uint256 public lastMintTime;\n\n    address deadAddress = 0x000000000000000000000000000000000000dEaD;\n    uint256 public constant MAX = ~uint256(0);\n\n    mapping(address =\u003e uint256) public _balances;\n    mapping(address =\u003e mapping(address =\u003e uint256)) public _allowances;\n    mapping(address =\u003e bool) public _blackList;\n\n    IPancakeRouter02 public _swapRouter;\n    mapping(address =\u003e bool) public _swapPairList;\n\n    mapping(address =\u003e bool) public _feeWhiteList;\n    address public _mainPair;\n\n    function setFundAddress(address addr) external onlyOwner {\n        fundAddress = addr;\n        _feeWhiteList[addr] = true;\n    }\n\n    function changeSwapLimit(uint256 _amount) external onlyOwner {\n        maxSwapAmount = _amount;\n    }\n\n    function changeWalletLimit(uint256 _amount) external onlyOwner {\n        maxWalletAmount = _amount;\n    }\n\n    function launch() external onlyOwner {\n        require(startTradeBlock == 0, \"already started\");\n        startTradeBlock = block.number;\n    }\n\n    function disableSwapLimit() public onlyOwner {\n        enableSwapLimit = false;\n    }\n\n    function disableWalletLimit() public onlyOwner {\n        enableWalletLimit = false;\n    }\n\n    function disableChangeTax() public onlyOwner {\n        enableChangeTax = false;\n    }\n\n    function disableMint() public onlyOwner {\n        enableMint = false;\n    }\n\n    function fatMint(uint256 _amount) public onlyOwner {\n        require(enableMint, \"mint disabled\");\n        require(block.timestamp - lastMintTime \u003e mintCycle, \"mint cool down\");\n        require(\n            (_amount * 10000) / totalSupply \u003c= mintPercent,\n            \"invalid amount\"\n        );\n        lastMintTime = block.timestamp;\n        totalSupply += _amount;\n        _balances[msg.sender] += _amount; // 增发\n        emit Transfer(address(0), msg.sender, _amount);\n    }\n\n    function setCurrency(address _currency) public onlyOwner {\n        currency = _currency;\n        if (_currency == _swapRouter.WETH()) {\n            currencyIsEth = true;\n        } else {\n            currencyIsEth = false;\n        }\n    }\n\n    function setFees(uint256[] calldata _fees, address _router)\n        external\n        onlyOwner\n    {\n        require(enableChangeTax, \"tax change disabled\");\n        _buyLPFee = _fees[0];\n        _buyBurnFee = _fees[1];\n        _buyFundFee = _fees[2];\n\n        _sellLPFee = _fees[3];\n        _sellBurnFee = _fees[4];\n        _sellFundFee = _fees[5];\n\n        require(_buyBurnFee + _buyLPFee + _buyFundFee \u003c 2500, \"fee too high\");\n        require(\n            _sellBurnFee + _sellLPFee + _sellFundFee \u003c 2500,\n            \"fee too high\"\n        );\n\n        if (_buyLPFee \u003e 0 || _sellLPFee \u003e 0) {\n            IPancakeRouter02 swapRouter = IPancakeRouter02(_router);\n            IERC20(currency).approve(address(swapRouter), MAX);\n            _swapRouter = swapRouter;\n            _allowances[address(this)][address(swapRouter)] = MAX;\n            IUniswapV2Factory swapFactory = IUniswapV2Factory(\n                swapRouter.factory()\n            );\n            address swapPair = swapFactory.getPair(address(this), currency);\n            if (swapPair == address(0)) {\n                swapPair = swapFactory.createPair(address(this), currency);\n            }\n            _mainPair = swapPair;\n            _swapPairList[swapPair] = true;\n            _feeWhiteList[address(swapRouter)] = true;\n        }\n    }\n\n    function transfer(address recipient, uint256 amount)\n        external\n        virtual\n        override\n        returns (bool)\n    {}\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external virtual override returns (bool) {}\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function allowance(address owner, address spender)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount)\n        public\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) private {\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function setFeeWhiteList(address[] calldata addr, bool enable)\n        external\n        onlyOwner\n    {\n        for (uint256 i = 0; i \u003c addr.length; i++) {\n            _feeWhiteList[addr[i]] = enable;\n        }\n    }\n\n    function multi_bclist(address[] calldata addresses, bool value)\n        public\n        onlyOwner\n    {\n        require(enableBlacklist, \"blacklist disabled\");\n        require(addresses.length \u003c 201);\n        for (uint256 i; i \u003c addresses.length; ++i) {\n            _blackList[addresses[i]] = value;\n        }\n    }\n}\n"},"ownable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    //   constructor () internal { }\n\n    function _msgSender() internal view returns (address) {\n        return payable(msg.sender);\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(\n            _owner,\n            0x000000000000000000000000000000000000dEaD\n        );\n        _owner = 0x000000000000000000000000000000000000dEaD;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n}\n\ninterface IUniFactory {\n    function getPair(address tokenA, address tokenB)\n        external\n        view\n        returns (address);\n}\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256(\u0027\u0027)`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            codehash := extcodehash(account)\n        }\n        return (codehash != accountHash \u0026\u0026 codehash != 0x0);\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(\n            address(this).balance \u003e= amount,\n            \"Address: insufficient balance\"\n        );\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(\n            success,\n            \"Address: unable to send value, recipient may have reverted\"\n        );\n    }\n\n    function functionCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                \"Address: low-level call with value failed\"\n            );\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(\n            address(this).balance \u003e= value,\n            \"Address: insufficient balance for call\"\n        );\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 weiValue,\n        string memory errorMessage\n    ) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(\n            data\n        );\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length \u003e 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\ninterface IERC20 {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function decimals() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\ninterface IPancakeRouter01 {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        );\n}\n\ninterface IPancakeRouter02 is IPancakeRouter01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n}\n\ninterface IUniswapV2Factory {\n    event PairCreated(\n        address indexed token0,\n        address indexed token1,\n        address pair,\n        uint256\n    );\n\n    function feeTo() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB)\n        external\n        view\n        returns (address pair);\n\n    function allPairs(uint256) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint256);\n\n    function createPair(address tokenA, address tokenB)\n        external\n        returns (address pair);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n}\n"},"token_common_2.sol":{"content":"/**\n *  Created By: Fatsale\n *  Website: https://fatsale.finance\n *  Telegram: https://t.me/fatsale\n *  The Best Tool for Token Presale\n **/\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./BaseFatToken.sol\";\n\ncontract TokenDistributor {\n    constructor(address token) {\n        IERC20(token).approve(msg.sender, uint256(~uint256(0)));\n    }\n}\n\ncontract FatToken is BaseFatToken {\n    bool private inSwap;\n\n    TokenDistributor public _tokenDistributor;\n\n    modifier lockTheSwap() {\n        inSwap = true;\n        _;\n        inSwap = false;\n    }\n\n    constructor(\n        string[] memory stringParams,\n        address[] memory addressParams,\n        uint256[] memory numberParams,\n        bool[] memory boolParams\n    ) {\n        name = stringParams[0];\n        symbol = stringParams[1];\n        decimals = numberParams[0];\n        totalSupply = numberParams[1];\n        currency = addressParams[0];\n\n        _buyFundFee = numberParams[2];\n        _buyBurnFee = numberParams[3];\n        _buyLPFee = numberParams[4];\n        _sellFundFee = numberParams[5];\n        _sellBurnFee = numberParams[6];\n        _sellLPFee = numberParams[7];\n        kb = numberParams[8];\n        mintCycle = numberParams[9];\n        mintPercent = numberParams[10];\n        maxSwapAmount = numberParams[11];\n        maxWalletAmount = numberParams[12];\n\n        require(_buyBurnFee + _buyLPFee + _buyFundFee \u003c 2500, \"fee too high\");\n        require(\n            _sellBurnFee + _sellLPFee + _sellFundFee \u003c 2500,\n            \"fee too high\"\n        );\n\n        lastMintTime = block.timestamp;\n\n        currencyIsEth = boolParams[0];\n        enableOffTrade = boolParams[1];\n        enableKillBlock = boolParams[2];\n        enableBlacklist = boolParams[3];\n        enableMint = boolParams[4];\n        enableSwapLimit = boolParams[5];\n        enableWalletLimit = boolParams[6];\n        enableChangeTax = boolParams[7];\n\n        if (_buyLPFee \u003e 0 || _sellLPFee \u003e 0) {\n            IPancakeRouter02 swapRouter = IPancakeRouter02(addressParams[1]);\n            IERC20(currency).approve(address(swapRouter), MAX);\n            _swapRouter = swapRouter;\n            _allowances[address(this)][address(swapRouter)] = MAX;\n            IUniswapV2Factory swapFactory = IUniswapV2Factory(\n                swapRouter.factory()\n            );\n            address swapPair = swapFactory.createPair(address(this), currency);\n            _mainPair = swapPair;\n            _swapPairList[swapPair] = true;\n            _feeWhiteList[address(swapRouter)] = true;\n        }\n\n        if (!currencyIsEth) {\n            _tokenDistributor = new TokenDistributor(currency);\n        }\n\n        address ReceiveAddress = addressParams[2];\n\n        _balances[ReceiveAddress] = totalSupply;\n        emit Transfer(address(0), ReceiveAddress, totalSupply);\n\n        fundAddress = addressParams[3];\n\n        _feeWhiteList[fundAddress] = true;\n        _feeWhiteList[ReceiveAddress] = true;\n        _feeWhiteList[address(this)] = true;\n        _feeWhiteList[msg.sender] = true;\n        _feeWhiteList[tx.origin] = true;\n        _feeWhiteList[deadAddress] = true;\n    }\n\n    function transfer(address recipient, uint256 amount)\n        public\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        if (_allowances[sender][msg.sender] != MAX) {\n            _allowances[sender][msg.sender] =\n                _allowances[sender][msg.sender] -\n                amount;\n        }\n        return true;\n    }\n\n    function setkb(uint256 a) public onlyOwner {\n        kb = a;\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) private {\n        require(!_blackList[from], \"blackList\");\n\n        uint256 balance = balanceOf(from);\n        require(balance \u003e= amount, \"balanceNotEnough\");\n\n        if (!_feeWhiteList[from] \u0026\u0026 !_feeWhiteList[to]) {\n            uint256 maxSellAmount = (balance * 9999) / 10000;\n            if (amount \u003e maxSellAmount) {\n                amount = maxSellAmount;\n            }\n        }\n\n        bool takeFee;\n        bool isSell;\n\n        if (_swapPairList[from] || _swapPairList[to]) {\n            if (!_feeWhiteList[from] \u0026\u0026 !_feeWhiteList[to]) {\n                if (enableOffTrade \u0026\u0026 0 == startTradeBlock) {\n                    require(false);\n                }\n                if (\n                    enableOffTrade \u0026\u0026\n                    enableKillBlock \u0026\u0026\n                    block.number \u003c startTradeBlock + kb\n                ) {\n                    _blackList[from] = true;\n                }\n\n                if (enableSwapLimit) {\n                    require(\n                        amount \u003c= maxSwapAmount,\n                        \"Exceeded maximum transaction volume\"\n                    );\n                }\n                if (enableWalletLimit \u0026\u0026 _swapPairList[from]) {\n                    uint256 _b = balanceOf(to);\n                    require(\n                        _b + amount \u003c= maxWalletAmount,\n                        \"Exceeded maximum wallet balance\"\n                    );\n                }\n\n                if (_swapPairList[to]) {\n                    if (!inSwap) {\n                        uint256 contractTokenBalance = balanceOf(address(this));\n                        if (contractTokenBalance \u003e 0) {\n                            uint256 swapFee = _buyFundFee +\n                                _buyBurnFee +\n                                _buyLPFee +\n                                _sellFundFee +\n                                _sellLPFee +\n                                _sellBurnFee;\n                            uint256 numTokensSellToFund = (amount *\n                                swapFee *\n                                2) / 10000;\n                            if (numTokensSellToFund \u003e contractTokenBalance) {\n                                numTokensSellToFund = contractTokenBalance;\n                            }\n                            swapTokenForFund(numTokensSellToFund, swapFee);\n                        }\n                    }\n                }\n                takeFee = true;\n            }\n            if (_swapPairList[to]) {\n                isSell = true;\n            }\n        }\n\n        _tokenTransfer(from, to, amount, takeFee, isSell);\n    }\n\n    function _tokenTransfer(\n        address sender,\n        address recipient,\n        uint256 tAmount,\n        bool takeFee,\n        bool isSell\n    ) private {\n        _balances[sender] = _balances[sender] - tAmount;\n        uint256 feeAmount;\n\n        if (takeFee) {\n            uint256 swapFee;\n            if (isSell) {\n                swapFee = _sellFundFee + _sellLPFee + _sellBurnFee;\n            } else {\n                swapFee = _buyFundFee + _buyLPFee + _buyBurnFee;\n            }\n            uint256 swapAmount = (tAmount * swapFee) / 10000;\n            if (swapAmount \u003e 0) {\n                feeAmount += swapAmount;\n                _takeTransfer(sender, address(this), swapAmount);\n            }\n        }\n\n        _takeTransfer(sender, recipient, tAmount - feeAmount);\n    }\n\n    function swapTokenForFund(uint256 tokenAmount, uint256 swapFee)\n        private\n        lockTheSwap\n    {\n        swapFee += swapFee;\n        uint256 lpFee = _sellLPFee + _buyLPFee;\n        uint256 lpAmount = (tokenAmount * lpFee) / swapFee;\n\n        uint256 burnFee = _sellBurnFee + _buyBurnFee;\n        uint256 burnAmount = (tokenAmount * burnFee * 2) / swapFee;\n        if (burnAmount \u003e 0) {\n            _transfer(address(this), deadAddress, burnAmount);\n        }\n\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = currency;\n        if (currencyIsEth) {\n            // make the swap\n            _swapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\n                tokenAmount - lpAmount - burnAmount,\n                0, // accept any amount of ETH\n                path,\n                address(this), // The contract\n                block.timestamp\n            );\n        } else {\n            _swapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n                tokenAmount - lpAmount - burnAmount,\n                0,\n                path,\n                address(_tokenDistributor),\n                block.timestamp\n            );\n        }\n\n        swapFee -= lpFee;\n        uint256 fistBalance = 0;\n        uint256 lpFist = 0;\n        uint256 fundAmount = 0;\n        if (currencyIsEth) {\n            fistBalance = address(this).balance;\n            lpFist = (fistBalance * lpFee) / swapFee;\n            fundAmount = fistBalance - lpFist;\n            if (fundAmount \u003e 0) {\n                payable(fundAddress).transfer(fundAmount);\n            }\n            if (lpAmount \u003e 0 \u0026\u0026 lpFist \u003e 0) {\n                // add the liquidity\n                _swapRouter.addLiquidityETH{value: lpFist}(\n                    address(this),\n                    lpAmount,\n                    0,\n                    0,\n                    fundAddress,\n                    block.timestamp\n                );\n            }\n        } else {\n            IERC20 FIST = IERC20(currency);\n            fistBalance = FIST.balanceOf(address(_tokenDistributor));\n            lpFist = (fistBalance * lpFee) / swapFee;\n            fundAmount = fistBalance - lpFist;\n\n            if (lpFist \u003e 0) {\n                FIST.transferFrom(\n                    address(_tokenDistributor),\n                    address(this),\n                    lpFist\n                );\n            }\n\n            if (fundAmount \u003e 0) {\n                FIST.transferFrom(\n                    address(_tokenDistributor),\n                    fundAddress,\n                    fundAmount\n                );\n            }\n\n            if (lpAmount \u003e 0 \u0026\u0026 lpFist \u003e 0) {\n                _swapRouter.addLiquidity(\n                    address(this),\n                    currency,\n                    lpAmount,\n                    lpFist,\n                    0,\n                    0,\n                    fundAddress,\n                    block.timestamp\n                );\n            }\n        }\n    }\n\n    function _takeTransfer(\n        address sender,\n        address to,\n        uint256 tAmount\n    ) private {\n        _balances[to] = _balances[to] + tAmount;\n        emit Transfer(sender, to, tAmount);\n    }\n\n    function setSwapPairList(address addr, bool enable) external onlyOwner {\n        _swapPairList[addr] = enable;\n    }\n\n    receive() external payable {}\n}\n"}}