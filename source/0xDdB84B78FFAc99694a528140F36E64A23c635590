{"Auth.sol":{"content":"pragma solidity ^0.7.4;\n\n\nabstract contract Auth {\n    address internal owner;\n    mapping (address =\u003e bool) internal authorizations;\n\n    constructor(address _owner) {\n        owner = _owner;\n        authorizations[_owner] = true;\n    }\n\n    modifier onlyOwner() {\n        require(isOwner(msg.sender), \"!OWNER\"); _;\n    }\n\n    modifier authorized() {\n        require(isAuthorized(msg.sender), \"!AUTHORIZED\"); _;\n    }\n\n    function authorize(address adr) public onlyOwner {\n        authorizations[adr] = true;\n    }\n\n    function unauthorize(address adr) public onlyOwner {\n        authorizations[adr] = false;\n    }\n\n    function isOwner(address account) public view returns (bool) {\n        return account == owner;\n    }\n\n    function isAuthorized(address adr) public view returns (bool) {\n        return authorizations[adr];\n    }\n\n    function transferOwnership(address payable adr) public onlyOwner {\n        owner = adr;\n        authorizations[adr] = true;\n        emit OwnershipTransferred(adr);\n    }\n\n    event OwnershipTransferred(address owner);\n}\n"},"Dividend.sol":{"content":"pragma solidity ^0.7.4;\n\nimport \"./SafeMath.sol\";\nimport \"./IBEP20.sol\";\nimport \"./IDEX.sol\";\n\ninterface IDividendDistributor {\n    function setDistributionCriteria(uint256 _minPeriod, uint256 _minDistribution) external;\n    function setShare(address shareholder, uint256 amount) external;\n    function deposit() external payable;\n    function process(uint256 gas) external;\n}\n\ncontract DividendDistributor is IDividendDistributor {\n    using SafeMath for uint256;\n\n    address _token;\n\n    struct Share {\n        uint256 amount;\n        uint256 totalExcluded;\n        uint256 totalRealised;\n    }\n\n    IBEP20 RWRD = IBEP20(0x3EE2200Efb3400fAbB9AacF31297cBdD1d435D47);\n    address WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\n    IDEXRouter router;\n\n    address[] shareholders;\n    mapping (address =\u003e uint256) shareholderIndexes;\n    mapping (address =\u003e uint256) shareholderClaims;\n\n    mapping (address =\u003e Share) public shares;\n\n    uint256 public totalShares;\n    uint256 public totalDividends;\n    uint256 public totalDistributed;\n    uint256 public dividendsPerShare;\n    uint256 public dividendsPerShareAccuracyFactor = 10 ** 36;\n\n    uint256 public minPeriod = 60 * 60;\n    uint256 public minDistribution = 1 * (10 ** 18);\n\n    uint256 currentIndex;\n\n    bool initialized;\n    modifier initialization() {\n        require(!initialized);\n        _;\n        initialized = true;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == _token); _;\n    }\n\n    constructor (address _router) {\n        router = _router != address(0)\n            ? IDEXRouter(_router)\n            : IDEXRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n        _token = msg.sender;\n    }\n\n    function setDistributionCriteria(uint256 _minPeriod, uint256 _minDistribution) external override onlyToken {\n        minPeriod = _minPeriod;\n        minDistribution = _minDistribution;\n    }\n\n    function setShare(address shareholder, uint256 amount) external override onlyToken {\n        if(shares[shareholder].amount \u003e 0){\n            distributeDividend(shareholder);\n        }\n\n        if(amount \u003e 0 \u0026\u0026 shares[shareholder].amount == 0){\n            addShareholder(shareholder);\n        }else if(amount == 0 \u0026\u0026 shares[shareholder].amount \u003e 0){\n            removeShareholder(shareholder);\n        }\n\n        totalShares = totalShares.sub(shares[shareholder].amount).add(amount);\n        shares[shareholder].amount = amount;\n        shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);\n    }\n\n    function deposit() external payable override onlyToken {\n        uint256 balanceBefore = RWRD.balanceOf(address(this));\n\n        address[] memory path = new address[](2);\n        path[0] = WBNB;\n        path[1] = address(RWRD);\n\n        router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: msg.value}(\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n\n        uint256 amount = RWRD.balanceOf(address(this)).sub(balanceBefore);\n\n        totalDividends = totalDividends.add(amount);\n        dividendsPerShare = dividendsPerShare.add(dividendsPerShareAccuracyFactor.mul(amount).div(totalShares));\n    }\n\n    function process(uint256 gas) external override onlyToken {\n        uint256 shareholderCount = shareholders.length;\n\n        if(shareholderCount == 0) { return; }\n\n        uint256 gasUsed = 0;\n        uint256 gasLeft = gasleft();\n\n        uint256 iterations = 0;\n\n        while(gasUsed \u003c gas \u0026\u0026 iterations \u003c shareholderCount) {\n            if(currentIndex \u003e= shareholderCount){\n                currentIndex = 0;\n            }\n\n            if(shouldDistribute(shareholders[currentIndex])){\n                distributeDividend(shareholders[currentIndex]);\n            }\n\n            gasUsed = gasUsed.add(gasLeft.sub(gasleft()));\n            gasLeft = gasleft();\n            currentIndex++;\n            iterations++;\n        }\n    }\n    \n    function shouldDistribute(address shareholder) internal view returns (bool) {\n        return shareholderClaims[shareholder] + minPeriod \u003c block.timestamp\n                \u0026\u0026 getUnpaidEarnings(shareholder) \u003e minDistribution;\n    }\n\n    function distributeDividend(address shareholder) internal {\n        if(shares[shareholder].amount == 0){ return; }\n\n        uint256 amount = getUnpaidEarnings(shareholder);\n        if(amount \u003e 0){\n            totalDistributed = totalDistributed.add(amount);\n            RWRD.transfer(shareholder, amount);\n            shareholderClaims[shareholder] = block.timestamp;\n            shares[shareholder].totalRealised = shares[shareholder].totalRealised.add(amount);\n            shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);\n        }\n    }\n    \n    function claimDividend() external {\n        distributeDividend(msg.sender);\n    }\n\n    function getUnpaidEarnings(address shareholder) public view returns (uint256) {\n        if(shares[shareholder].amount == 0){ return 0; }\n\n        uint256 shareholderTotalDividends = getCumulativeDividends(shares[shareholder].amount);\n        uint256 shareholderTotalExcluded = shares[shareholder].totalExcluded;\n\n        if(shareholderTotalDividends \u003c= shareholderTotalExcluded){ return 0; }\n\n        return shareholderTotalDividends.sub(shareholderTotalExcluded);\n    }\n\n    function getCumulativeDividends(uint256 share) internal view returns (uint256) {\n        return share.mul(dividendsPerShare).div(dividendsPerShareAccuracyFactor);\n    }\n\n    function addShareholder(address shareholder) internal {\n        shareholderIndexes[shareholder] = shareholders.length;\n        shareholders.push(shareholder);\n    }\n\n    function removeShareholder(address shareholder) internal {\n        shareholders[shareholderIndexes[shareholder]] = shareholders[shareholders.length-1];\n        shareholderIndexes[shareholders[shareholders.length-1]] = shareholderIndexes[shareholder];\n        shareholders.pop();\n    }\n}\n"},"IBEP20.sol":{"content":"pragma solidity ^0.7.4;\n\ninterface IBEP20 {\n    function totalSupply() external view returns (uint256);\n    function decimals() external view returns (uint8);\n    function symbol() external view returns (string memory);\n    function name() external view returns (string memory);\n    function getOwner() external view returns (address);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address _owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"},"IDEX.sol":{"content":"pragma solidity ^0.7.4;\n\n\ninterface IDEXFactory {\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n}\n\ninterface IDEXRouter {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}"},"MiniGolfADA.sol":{"content":"pragma solidity ^0.7.4;\n\nimport \"./IBEP20.sol\";\nimport \"./Auth.sol\";\nimport \"./SafeMath.sol\";\nimport \"./IDEX.sol\";\nimport \"./Dividend.sol\";\n\ncontract MINIGOLF_ADA is IBEP20, Auth{\n    using SafeMath for uint256;\n\n    address WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\n    address DEAD = 0x000000000000000000000000000000000000dEaD;\n    address ZERO = 0x0000000000000000000000000000000000000000;\n\n    string constant _name = \"MiniGolf_ADA\";\n    string constant _symbol = \"MIADA\";\n    uint8 constant _decimals = 9;\n\n    uint256 _totalSupply = 1 * 10**9 * 10**_decimals;\n\n    uint256 public _maxTxAmount = 5 * 10**10 * 10**_decimals;\n    uint256 public _maxWalletToken = 1 * 10**10 * 10**_decimals;\n\n    mapping (address =\u003e uint256) _balances;\n    mapping (address =\u003e mapping (address =\u003e uint256)) _allowances;\n\n    mapping (address =\u003e bool) isFeeExempt;\n    mapping (address =\u003e bool) isTxLimitExempt;\n    mapping (address =\u003e bool) isTimelockExempt;\n    mapping (address =\u003e bool) isDividendExempt;\n\n    uint256 public liquidityFee    = 1;\n    uint256 public reflectionFee   = 1;\n    uint256 public marketingFee    = 1;\n    uint256 public totalFee        = marketingFee + reflectionFee + liquidityFee;\n    uint256 public feeDenominator  = 100;\n\n    uint256 public sellMultiplier  = 100;\n\n    address public autoLiquidityReceiver;\n    address public marketingFeeReceiver;\n\n    uint256 targetLiquidity = 50;\n    uint256 targetLiquidityDenominator = 100;\n\n    IDEXRouter public router;\n    address public pair;\n\n    bool public tradingOpen = false;\n\n    DividendDistributor public distributor;\n    uint256 distributorGas = 300000;\n\n    bool public buyCooldownEnabled = false;\n    uint8 public cooldownTimerInterval = 60;\n    mapping (address =\u003e uint) private cooldownTimer;\n\n    bool public swapEnabled = true;\n    uint256 public swapThreshold = 3 * 10**2 * 10**_decimals;\n    bool inSwap;\n    modifier swapping() { inSwap = true; _; inSwap = false; }\n\n    constructor () Auth(msg.sender) {\n        router = IDEXRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n        pair = IDEXFactory(router.factory()).createPair(WBNB, address(this));\n        _allowances[address(this)][address(router)] = uint256(-1);\n\n        distributor = new DividendDistributor(address(router));\n\n        isFeeExempt[msg.sender] = true;\n        isTxLimitExempt[msg.sender] = true;\n\n        isTimelockExempt[msg.sender] = true;\n        isTimelockExempt[DEAD] = true;\n        isTimelockExempt[address(this)] = true;\n\n        isDividendExempt[pair] = true;\n        isDividendExempt[address(this)] = true;\n        isDividendExempt[DEAD] = true;\n\n        autoLiquidityReceiver = msg.sender;\n        marketingFeeReceiver = msg.sender;\n\n        _balances[msg.sender] = _totalSupply;\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n\n    receive() external payable { }\n\n    function totalSupply() external view override returns (uint256) { return _totalSupply; }\n    function decimals() external pure override returns (uint8) { return _decimals; }\n    function symbol() external pure override returns (string memory) { return _symbol; }\n    function name() external pure override returns (string memory) { return _name; }\n    function getOwner() external view override returns (address) { return owner; }\n    function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }\n    function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function approveMax(address spender) external returns (bool) {\n        return approve(spender, uint256(-1));\n    }\n\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\n        return _transferFrom(msg.sender, recipient, amount);\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\n        if(_allowances[sender][msg.sender] != uint256(-1)){\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount, \"Insufficient Allowance\");\n        }\n\n        return _transferFrom(sender, recipient, amount);\n    }\n\n    function setMaxWalletPercent(uint256 maxWallPercent_base1000) external onlyOwner() {\n        _maxWalletToken = (_totalSupply * maxWallPercent_base1000 ) / 1000;\n    }\n    function setMaxTxPercent(uint256 maxTXPercentage_base1000) external onlyOwner() {\n        _maxTxAmount = (_totalSupply * maxTXPercentage_base1000 ) / 1000;\n    }\n\n    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\n        if(inSwap){ return _basicTransfer(sender, recipient, amount); }\n\n        if(!authorizations[sender] \u0026\u0026 !authorizations[recipient]){\n            require(tradingOpen,\"Trading not open yet\");\n        }\n\n\n        if (!authorizations[sender] \u0026\u0026 recipient != address(this)  \u0026\u0026 recipient != address(DEAD) \u0026\u0026 recipient != pair \u0026\u0026 recipient != marketingFeeReceiver \u0026\u0026 recipient != autoLiquidityReceiver){\n            uint256 heldTokens = balanceOf(recipient);\n            require((heldTokens + amount) \u003c= _maxWalletToken,\"Total Holding is currently limited, you can not buy that much.\");}\n        \n        if (sender == pair \u0026\u0026\n            buyCooldownEnabled \u0026\u0026\n            !isTimelockExempt[recipient]) {\n            require(cooldownTimer[recipient] \u003c block.timestamp,\"Please wait for 1min between two buys\");\n            cooldownTimer[recipient] = block.timestamp + cooldownTimerInterval;\n        }\n\n        // Checks max transaction limit\n        checkTxLimit(sender, amount);\n\n        if(shouldSwapBack()){ swapBack(); }\n\n        //Exchange tokens\n        _balances[sender] = _balances[sender].sub(amount, \"Insufficient Balance\");\n\n        uint256 amountReceived = shouldTakeFee(sender) ? takeFee(sender, amount,(recipient == pair)) : amount;\n        _balances[recipient] = _balances[recipient].add(amountReceived);\n\n        // Dividend tracker\n        if(!isDividendExempt[sender]) {\n            try distributor.setShare(sender, _balances[sender]) {} catch {}\n        }\n\n        if(!isDividendExempt[recipient]) {\n            try distributor.setShare(recipient, _balances[recipient]) {} catch {} \n        }\n\n        try distributor.process(distributorGas) {} catch {}\n\n        emit Transfer(sender, recipient, amountReceived);\n        return true;\n    }\n    \n    function _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\n        _balances[sender] = _balances[sender].sub(amount, \"Insufficient Balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function checkTxLimit(address sender, uint256 amount) internal view {\n        require(amount \u003c= _maxTxAmount || isTxLimitExempt[sender], \"TX Limit Exceeded\");\n    }\n\n    function shouldTakeFee(address sender) internal view returns (bool) {\n        return !isFeeExempt[sender];\n    }\n\n    function takeFee(address sender, uint256 amount, bool isSell) internal returns (uint256) {\n        \n        uint256 multiplier = isSell ? sellMultiplier : 100;\n        uint256 feeAmount = amount.mul(totalFee).mul(multiplier).div(feeDenominator * 100);\n        \n\n        _balances[address(this)] = _balances[address(this)].add(feeAmount);\n        emit Transfer(sender, address(this), feeAmount);\n\n        return amount.sub(feeAmount);\n    }\n\n    function shouldSwapBack() internal view returns (bool) {\n        return msg.sender != pair\n        \u0026\u0026 !inSwap\n        \u0026\u0026 swapEnabled\n        \u0026\u0026 _balances[address(this)] \u003e= swapThreshold;\n    }\n\n    function clearStuckBalance(uint256 amountPercentage) external onlyOwner {\n        uint256 amountBNB = address(this).balance;\n        payable(marketingFeeReceiver).transfer(amountBNB * amountPercentage / 100);\n    }\n\n    function set_sell_multiplier(uint256 Multiplier) external onlyOwner{\n        sellMultiplier = Multiplier;        \n    }\n\n    // switch Trading\n    function tradingStatus(bool _status) public onlyOwner {\n        tradingOpen = _status;\n    }\n\n    // enable cooldown between trades\n    function cooldownEnabled(bool _status, uint8 _interval) public onlyOwner {\n        buyCooldownEnabled = _status;\n        cooldownTimerInterval = _interval;\n    }\n\n    function swapBack() internal swapping {\n        uint256 dynamicLiquidityFee = isOverLiquified(targetLiquidity, targetLiquidityDenominator) ? 0 : liquidityFee;\n        uint256 amountToLiquify = swapThreshold.mul(dynamicLiquidityFee).div(totalFee).div(2);\n        uint256 amountToSwap = swapThreshold.sub(amountToLiquify);\n\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = WBNB;\n\n        uint256 balanceBefore = address(this).balance;\n\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            amountToSwap,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n\n        uint256 amountBNB = address(this).balance.sub(balanceBefore);\n\n        uint256 totalBNBFee = totalFee.sub(dynamicLiquidityFee.div(2));\n        \n        uint256 amountBNBLiquidity = amountBNB.mul(dynamicLiquidityFee).div(totalBNBFee).div(2);\n        uint256 amountBNBReflection = amountBNB.mul(reflectionFee).div(totalBNBFee);\n        uint256 amountBNBMarketing = amountBNB.mul(marketingFee).div(totalBNBFee);\n\n        try distributor.deposit{value: amountBNBReflection}() {} catch {}\n        (bool tmpSuccess,) = payable(marketingFeeReceiver).call{value: amountBNBMarketing, gas: 30000}(\"\");\n        \n        // only to supress warning msg\n        tmpSuccess = false;\n\n        if(amountToLiquify \u003e 0){\n            router.addLiquidityETH{value: amountBNBLiquidity}(\n                address(this),\n                amountToLiquify,\n                0,\n                0,\n                autoLiquidityReceiver,\n                block.timestamp\n            );\n            emit AutoLiquify(amountBNBLiquidity, amountToLiquify);\n        }\n    }\n\n\n    function setTxLimit(uint256 amount) external authorized {\n        _maxTxAmount = amount;\n    }\n\n    function setIsDividendExempt(address holder, bool exempt) external authorized {\n        require(holder != address(this) \u0026\u0026 holder != pair);\n        isDividendExempt[holder] = exempt;\n        if(exempt){\n            distributor.setShare(holder, 0);\n        }else{\n            distributor.setShare(holder, _balances[holder]);\n        }\n    }\n\n    function setIsFeeExempt(address holder, bool exempt) external authorized {\n        isFeeExempt[holder] = exempt;\n    }\n\n    function setIsTxLimitExempt(address holder, bool exempt) external authorized {\n        isTxLimitExempt[holder] = exempt;\n    }\n\n    function setIsTimelockExempt(address holder, bool exempt) external authorized {\n        isTimelockExempt[holder] = exempt;\n    }\n\n    function setFees(uint256 _liquidityFee, uint256 _reflectionFee, uint256 _marketingFee, uint256 _feeDenominator) external authorized {\n        liquidityFee = _liquidityFee;\n        reflectionFee = _reflectionFee;\n        marketingFee = _marketingFee;\n        totalFee = _liquidityFee.add(_reflectionFee).add(_marketingFee);\n        feeDenominator = _feeDenominator;\n        require(totalFee \u003c feeDenominator/3, \"Fees cannot be more than 33%\");\n    }\n\n    function setFeeReceivers(address _autoLiquidityReceiver, address _marketingFeeReceiver) external authorized {\n        autoLiquidityReceiver = _autoLiquidityReceiver;\n        marketingFeeReceiver = _marketingFeeReceiver;\n    }\n\n    function setSwapBackSettings(bool _enabled, uint256 _amount) external authorized {\n        swapEnabled = _enabled;\n        swapThreshold = _amount;\n    }\n\n    function setTargetLiquidity(uint256 _target, uint256 _denominator) external authorized {\n        targetLiquidity = _target;\n        targetLiquidityDenominator = _denominator;\n    }\n\n    function setDistributionCriteria(uint256 _minPeriod, uint256 _minDistribution) external authorized {\n        distributor.setDistributionCriteria(_minPeriod, _minDistribution);\n    }\n\n    function setDistributorSettings(uint256 gas) external authorized {\n        require(gas \u003c 750000);\n        distributorGas = gas;\n    }\n    \n    function getCirculatingSupply() public view returns (uint256) {\n        return _totalSupply.sub(balanceOf(DEAD)).sub(balanceOf(ZERO));\n    }\n\n    function getLiquidityBacking(uint256 accuracy) public view returns (uint256) {\n        return accuracy.mul(balanceOf(pair).mul(2)).div(getCirculatingSupply());\n    }\n\n    function isOverLiquified(uint256 target, uint256 accuracy) public view returns (bool) {\n        return getLiquidityBacking(accuracy) \u003e target;\n    }\n\n\n\n/* Airdrop Begins */\nfunction multiTransfer(address from, address[] calldata addresses, uint256[] calldata tokens) external onlyOwner {\n\n    require(addresses.length \u003c 201,\"GAS Error: max airdrop limit is 200 addresses\"); // hello rainmaker\n    require(addresses.length == tokens.length,\"Mismatch between Address and token count\");\n\n    uint256 SCCC = 0;\n\n    for(uint i=0; i \u003c addresses.length; i++){\n        SCCC = SCCC + tokens[i];\n    }\n\n    require(balanceOf(from) \u003e= SCCC, \"Not enough tokens in wallet\");\n\n    for(uint i=0; i \u003c addresses.length; i++){\n        _basicTransfer(from,addresses[i],tokens[i]);\n        if(!isDividendExempt[addresses[i]]) {\n            try distributor.setShare(addresses[i], _balances[addresses[i]]) {} catch {} \n        }\n    }\n\n    // Dividend tracker\n    if(!isDividendExempt[from]) {\n        try distributor.setShare(from, _balances[from]) {} catch {}\n    }\n}\n\nevent AutoLiquify(uint256 amountBNB, uint256 amountBOG);\n\n}"},"SafeMath.sol":{"content":"pragma solidity ^0.7.4;\n\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        return c;\n    }\n}"}}