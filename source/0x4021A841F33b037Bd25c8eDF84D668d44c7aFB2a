{"Ownable.sol":{"content":"//SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable {\r\n    address private _owner;\r\n    address private _newOwner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function newOwner() public view virtual returns (address) {\r\n        return _newOwner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address transferOwner) public onlyOwner {\r\n        require(transferOwner != newOwner());\r\n        _newOwner = transferOwner;\r\n    }\r\n\r\n    function acceptOwnership() virtual public {\r\n        require(msg.sender == newOwner(), \"Ownable: caller is not the new owner\");\r\n        emit OwnershipTransferred(_owner, _newOwner);\r\n        _owner = _newOwner;\r\n        _newOwner = address(0);\r\n    }\r\n}\r\n"},"Proxy.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\r\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\r\n * be specified by overriding the virtual {_implementation} function.\r\n *\r\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\r\n * different contract through the {_delegate} function.\r\n *\r\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\r\n */\r\nabstract contract Proxy {\r\n    /**\r\n     * @dev Delegates the current call to `implementation`.\r\n     *\r\n     * This function does not return to its internall call site, it will return directly to the external caller.\r\n     */\r\n    function _delegate(address implementation) internal virtual {\r\n        assembly {\r\n            // Copy msg.data. We take full control of memory in this inline assembly\r\n            // block because it will not return to Solidity code. We overwrite the\r\n            // Solidity scratch pad at memory position 0.\r\n            calldatacopy(0, 0, calldatasize())\r\n\r\n            // Call the implementation.\r\n            // out and outsize are 0 because we don\u0027t know the size yet.\r\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\r\n\r\n            // Copy the returned data.\r\n            returndatacopy(0, 0, returndatasize())\r\n\r\n            switch result\r\n            // delegatecall returns 0 on error.\r\n            case 0 {\r\n                revert(0, returndatasize())\r\n            }\r\n            default {\r\n                return(0, returndatasize())\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\r\n     * and {_fallback} should delegate.\r\n     */\r\n    function _implementation() internal view virtual returns (address);\r\n\r\n    /**\r\n     * @dev Delegates the current call to the address returned by `_implementation()`.\r\n     *\r\n     * This function does not return to its internall call site, it will return directly to the external caller.\r\n     */\r\n    function _fallback() internal virtual {\r\n        _delegate(_implementation());\r\n    }\r\n\r\n    /**\r\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\r\n     * function in the contract matches the call data.\r\n     */\r\n    fallback() external payable virtual {\r\n        _fallback();\r\n    }\r\n\r\n    /**\r\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\r\n     * is empty.\r\n     */\r\n    receive() external payable virtual {\r\n        _fallback();\r\n    }\r\n}\r\n"},"SnakeArtifactsNFTProxy.sol":{"content":"//SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./Proxy.sol\";\r\nimport \"./Ownable.sol\";\r\nimport \"./TokenStorage.sol\";\r\n\r\ncontract SnakeArtifactsNFTProxy is Proxy, Ownable, TokenStorage {\r\n\r\n    event ReplaceImplementation(address oldTarget, address newTarget);\r\n\r\n    constructor(address target) {\r\n        _implementationAddress = target;\r\n        emit ReplaceImplementation(address(0), target);\r\n    }\r\n    \r\n    function implementation() public view returns (address) { \r\n        return _implementationAddress; \r\n    }\r\n\r\n    function _implementation() internal view override returns (address) { \r\n        return _implementationAddress; \r\n    }\r\n\r\n    function replaceImplementation(address newTarget) external onlyOwner {\r\n        require(newTarget != address(0), \"SnakeArtifactsNFTProxy: target\u0027s address is equal to zero address\");\r\n        address oldTarget = _implementationAddress;\r\n        _implementationAddress = newTarget;\r\n        emit ReplaceImplementation(oldTarget, newTarget);\r\n    }\r\n}"},"TokenStorage.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity ^0.8.0;\r\n\r\nstruct TokenMetadata {\r\n    string Name;\r\n    string Description;\r\n    string URI;\r\n}\r\n\r\nabstract contract TokenStorage {\r\n    address internal _implementationAddress;\r\n    mapping(uint256 =\u003e TokenMetadata) public tokenMetadata;\r\n    mapping(uint256 =\u003e mapping(address =\u003e uint256)) internal _balances;\r\n    mapping(address =\u003e mapping(address =\u003e bool)) internal _operatorApprovals;\r\n}"}}