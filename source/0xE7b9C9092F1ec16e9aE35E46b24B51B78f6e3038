{"ABDKMath64x64.sol":{"content":"// SPDX-License-Identifier: BSD-4-Clause\r\n/*\r\n * ABDK Math 64.64 Smart Contract Library.  Copyright Â© 2019 by ABDK Consulting.\r\n * Author: Mikhail Vladimirov \u003cmikhail.vladimirov@gmail.com\u003e\r\n */\r\npragma solidity ^0.5.16;\r\n\r\n/**\r\n * Smart contract library of mathematical functions operating with signed\r\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\r\n * basically a simple fraction whose numerator is signed 128-bit integer and\r\n * denominator is 2^64.  As long as denominator is always the same, there is no\r\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\r\n * represented by int128 type holding only the numerator.\r\n */\r\nlibrary ABDKMath64x64 {\r\n  /*\r\n   * Minimum value signed 64.64-bit fixed point number may have. \r\n   */\r\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\r\n\r\n  /*\r\n   * Maximum value signed 64.64-bit fixed point number may have. \r\n   */\r\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n  /**\r\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\r\n   * number.  Revert on overflow.\r\n   *\r\n   * @param x signed 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function fromInt (int256 x) internal pure returns (int128) {\r\n    require (x \u003e= -0x8000000000000000 \u0026\u0026 x \u003c= 0x7FFFFFFFFFFFFFFF);\r\n    return int128 (x \u003c\u003c 64);\r\n  }\r\n\r\n  /**\r\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\r\n   * rounding down.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64-bit integer number\r\n   */\r\n  function toInt (int128 x) internal pure returns (int64) {\r\n    return int64 (x \u003e\u003e 64);\r\n  }\r\n\r\n  /**\r\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\r\n   * number.  Revert on overflow.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function fromUInt (uint256 x) internal pure returns (int128) {\r\n    require (x \u003c= 0x7FFFFFFFFFFFFFFF);\r\n    return int128 (x \u003c\u003c 64);\r\n  }\r\n\r\n  /**\r\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\r\n   * number rounding down.  Revert on underflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return unsigned 64-bit integer number\r\n   */\r\n  function toUInt (int128 x) internal pure returns (uint64) {\r\n    require (x \u003e= 0);\r\n    return uint64 (x \u003e\u003e 64);\r\n  }\r\n\r\n  /**\r\n   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\r\n   * number rounding down.  Revert on overflow.\r\n   *\r\n   * @param x signed 128.128-bin fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function from128x128 (int256 x) internal pure returns (int128) {\r\n    int256 result = x \u003e\u003e 64;\r\n    require (result \u003e= MIN_64x64 \u0026\u0026 result \u003c= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\r\n   * number.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 128.128 fixed point number\r\n   */\r\n  function to128x128 (int128 x) internal pure returns (int256) {\r\n    return int256 (x) \u003c\u003c 64;\r\n  }\r\n\r\n  /**\r\n   * Calculate x + y.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function add (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 result = int256(x) + y;\r\n    require (result \u003e= MIN_64x64 \u0026\u0026 result \u003c= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x - y.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function sub (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 result = int256(x) - y;\r\n    require (result \u003e= MIN_64x64 \u0026\u0026 result \u003c= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x * y rounding down.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function mul (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 result = int256(x) * y \u003e\u003e 64;\r\n    require (result \u003e= MIN_64x64 \u0026\u0026 result \u003c= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\r\n   * number and y is signed 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64 fixed point number\r\n   * @param y signed 256-bit integer number\r\n   * @return signed 256-bit integer number\r\n   */\r\n  function muli (int128 x, int256 y) internal pure returns (int256) {\r\n    if (x == MIN_64x64) {\r\n      require (y \u003e= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF \u0026\u0026\r\n        y \u003c= 0x1000000000000000000000000000000000000000000000000);\r\n      return -y \u003c\u003c 63;\r\n    } else {\r\n      bool negativeResult = false;\r\n      if (x \u003c 0) {\r\n        x = -x;\r\n        negativeResult = true;\r\n      }\r\n      if (y \u003c 0) {\r\n        y = -y; // We rely on overflow behavior here\r\n        negativeResult = !negativeResult;\r\n      }\r\n      uint256 absoluteResult = mulu (x, uint256 (y));\r\n      if (negativeResult) {\r\n        require (absoluteResult \u003c=\r\n          0x8000000000000000000000000000000000000000000000000000000000000000);\r\n        return -int256 (absoluteResult); // We rely on overflow behavior here\r\n      } else {\r\n        require (absoluteResult \u003c=\r\n          0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n        return int256 (absoluteResult);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\r\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64 fixed point number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return unsigned 256-bit integer number\r\n   */\r\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\r\n    if (y == 0) return 0;\r\n\r\n    require (x \u003e= 0);\r\n\r\n    uint256 lo = (uint256 (x) * (y \u0026 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) \u003e\u003e 64;\r\n    uint256 hi = uint256 (x) * (y \u003e\u003e 128);\r\n\r\n    require (hi \u003c= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n    hi \u003c\u003c= 64;\r\n\r\n    require (hi \u003c=\r\n      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\r\n    return hi + lo;\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\r\n   * zero.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function div (int128 x, int128 y) internal pure returns (int128) {\r\n    require (y != 0);\r\n    int256 result = (int256 (x) \u003c\u003c 64) / y;\r\n    require (result \u003e= MIN_64x64 \u0026\u0026 result \u003c= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x signed 256-bit integer number\r\n   * @param y signed 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function divi (int256 x, int256 y) internal pure returns (int128) {\r\n    require (y != 0);\r\n\r\n    bool negativeResult = false;\r\n    if (x \u003c 0) {\r\n      x = -x; // We rely on overflow behavior here\r\n      negativeResult = true;\r\n    }\r\n    if (y \u003c 0) {\r\n      y = -y; // We rely on overflow behavior here\r\n      negativeResult = !negativeResult;\r\n    }\r\n    uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\r\n    if (negativeResult) {\r\n      require (absoluteResult \u003c= 0x80000000000000000000000000000000);\r\n      return -int128 (absoluteResult); // We rely on overflow behavior here\r\n    } else {\r\n      require (absoluteResult \u003c= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n      return int128 (absoluteResult); // We rely on overflow behavior here\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function divu (uint256 x, uint256 y) internal pure returns (int128) {\r\n    require (y != 0);\r\n    uint128 result = divuu (x, y);\r\n    require (result \u003c= uint128 (MAX_64x64));\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate -x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function neg (int128 x) internal pure returns (int128) {\r\n    require (x != MIN_64x64);\r\n    return -x;\r\n  }\r\n\r\n  /**\r\n   * Calculate |x|.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function abs (int128 x) internal pure returns (int128) {\r\n    require (x != MIN_64x64);\r\n    return x \u003c 0 ? -x : x;\r\n  }\r\n\r\n  /**\r\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\r\n   * zero.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function inv (int128 x) internal pure returns (int128) {\r\n    require (x != 0);\r\n    int256 result = int256 (0x100000000000000000000000000000000) / x;\r\n    require (result \u003e= MIN_64x64 \u0026\u0026 result \u003c= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function avg (int128 x, int128 y) internal pure returns (int128) {\r\n    return int128 ((int256 (x) + int256 (y)) \u003e\u003e 1);\r\n  }\r\n\r\n  /**\r\n   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\r\n   * Revert on overflow or in case x * y is negative.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function gavg (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 m = int256 (x) * int256 (y);\r\n    require (m \u003e= 0);\r\n    require (m \u003c\r\n        0x4000000000000000000000000000000000000000000000000000000000000000);\r\n    return int128 (sqrtu (uint256 (m)));\r\n  }\r\n\r\n  /**\r\n   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\r\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y uint256 value\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function pow (int128 x, uint256 y) internal pure returns (int128) {\r\n    uint256 absoluteResult;\r\n    bool negativeResult = false;\r\n    if (x \u003e= 0) {\r\n      absoluteResult = powu (uint256 (x) \u003c\u003c 63, y);\r\n    } else {\r\n      // We rely on overflow behavior here\r\n      absoluteResult = powu (uint256 (uint128 (-x)) \u003c\u003c 63, y);\r\n      negativeResult = y \u0026 1 \u003e 0;\r\n    }\r\n\r\n    absoluteResult \u003e\u003e= 63;\r\n\r\n    if (negativeResult) {\r\n      require (absoluteResult \u003c= 0x80000000000000000000000000000000);\r\n      return -int128 (absoluteResult); // We rely on overflow behavior here\r\n    } else {\r\n      require (absoluteResult \u003c= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n      return int128 (absoluteResult); // We rely on overflow behavior here\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate sqrt (x) rounding down.  Revert if x \u003c 0.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function sqrt (int128 x) internal pure returns (int128) {\r\n    require (x \u003e= 0);\r\n    return int128 (sqrtu (uint256 (x) \u003c\u003c 64));\r\n  }\r\n\r\n  /**\r\n   * Calculate binary logarithm of x.  Revert if x \u003c= 0.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function log_2 (int128 x) internal pure returns (int128) {\r\n    require (x \u003e 0);\r\n\r\n    int256 msb = 0;\r\n    int256 xc = x;\r\n    if (xc \u003e= 0x10000000000000000) { xc \u003e\u003e= 64; msb += 64; }\r\n    if (xc \u003e= 0x100000000) { xc \u003e\u003e= 32; msb += 32; }\r\n    if (xc \u003e= 0x10000) { xc \u003e\u003e= 16; msb += 16; }\r\n    if (xc \u003e= 0x100) { xc \u003e\u003e= 8; msb += 8; }\r\n    if (xc \u003e= 0x10) { xc \u003e\u003e= 4; msb += 4; }\r\n    if (xc \u003e= 0x4) { xc \u003e\u003e= 2; msb += 2; }\r\n    if (xc \u003e= 0x2) msb += 1;  // No need to shift xc anymore\r\n\r\n    int256 result = msb - 64 \u003c\u003c 64;\r\n    uint256 ux = uint256 (x) \u003c\u003c uint256 (127 - msb);\r\n    for (int256 bit = 0x8000000000000000; bit \u003e 0; bit \u003e\u003e= 1) {\r\n      ux *= ux;\r\n      uint256 b = ux \u003e\u003e 255;\r\n      ux \u003e\u003e= 127 + b;\r\n      result += bit * int256 (b);\r\n    }\r\n\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate natural logarithm of x.  Revert if x \u003c= 0.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function ln (int128 x) internal pure returns (int128) {\r\n    require (x \u003e 0);\r\n\r\n    return int128 (\r\n        uint256 (log_2 (x)) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF \u003e\u003e 128);\r\n  }\r\n\r\n  /**\r\n   * Calculate binary exponent of x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function exp_2 (int128 x) internal pure returns (int128) {\r\n    require (x \u003c 0x400000000000000000); // Overflow\r\n\r\n    if (x \u003c -0x400000000000000000) return 0; // Underflow\r\n\r\n    uint256 result = 0x80000000000000000000000000000000;\r\n\r\n    if (x \u0026 0x8000000000000000 \u003e 0)\r\n      result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E \u003e\u003e 128;\r\n    if (x \u0026 0x4000000000000000 \u003e 0)\r\n      result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC \u003e\u003e 128;\r\n    if (x \u0026 0x2000000000000000 \u003e 0)\r\n      result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F \u003e\u003e 128;\r\n    if (x \u0026 0x1000000000000000 \u003e 0)\r\n      result = result * 0x10B5586CF9890F6298B92B71842A98363 \u003e\u003e 128;\r\n    if (x \u0026 0x800000000000000 \u003e 0)\r\n      result = result * 0x1059B0D31585743AE7C548EB68CA417FD \u003e\u003e 128;\r\n    if (x \u0026 0x400000000000000 \u003e 0)\r\n      result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 \u003e\u003e 128;\r\n    if (x \u0026 0x200000000000000 \u003e 0)\r\n      result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F \u003e\u003e 128;\r\n    if (x \u0026 0x100000000000000 \u003e 0)\r\n      result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 \u003e\u003e 128;\r\n    if (x \u0026 0x80000000000000 \u003e 0)\r\n      result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B \u003e\u003e 128;\r\n    if (x \u0026 0x40000000000000 \u003e 0)\r\n      result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F \u003e\u003e 128;\r\n    if (x \u0026 0x20000000000000 \u003e 0)\r\n      result = result * 0x100162F3904051FA128BCA9C55C31E5DF \u003e\u003e 128;\r\n    if (x \u0026 0x10000000000000 \u003e 0)\r\n      result = result * 0x1000B175EFFDC76BA38E31671CA939725 \u003e\u003e 128;\r\n    if (x \u0026 0x8000000000000 \u003e 0)\r\n      result = result * 0x100058BA01FB9F96D6CACD4B180917C3D \u003e\u003e 128;\r\n    if (x \u0026 0x4000000000000 \u003e 0)\r\n      result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 \u003e\u003e 128;\r\n    if (x \u0026 0x2000000000000 \u003e 0)\r\n      result = result * 0x1000162E525EE054754457D5995292026 \u003e\u003e 128;\r\n    if (x \u0026 0x1000000000000 \u003e 0)\r\n      result = result * 0x10000B17255775C040618BF4A4ADE83FC \u003e\u003e 128;\r\n    if (x \u0026 0x800000000000 \u003e 0)\r\n      result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB \u003e\u003e 128;\r\n    if (x \u0026 0x400000000000 \u003e 0)\r\n      result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 \u003e\u003e 128;\r\n    if (x \u0026 0x200000000000 \u003e 0)\r\n      result = result * 0x10000162E43F4F831060E02D839A9D16D \u003e\u003e 128;\r\n    if (x \u0026 0x100000000000 \u003e 0)\r\n      result = result * 0x100000B1721BCFC99D9F890EA06911763 \u003e\u003e 128;\r\n    if (x \u0026 0x80000000000 \u003e 0)\r\n      result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 \u003e\u003e 128;\r\n    if (x \u0026 0x40000000000 \u003e 0)\r\n      result = result * 0x1000002C5C863B73F016468F6BAC5CA2B \u003e\u003e 128;\r\n    if (x \u0026 0x20000000000 \u003e 0)\r\n      result = result * 0x100000162E430E5A18F6119E3C02282A5 \u003e\u003e 128;\r\n    if (x \u0026 0x10000000000 \u003e 0)\r\n      result = result * 0x1000000B1721835514B86E6D96EFD1BFE \u003e\u003e 128;\r\n    if (x \u0026 0x8000000000 \u003e 0)\r\n      result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF \u003e\u003e 128;\r\n    if (x \u0026 0x4000000000 \u003e 0)\r\n      result = result * 0x10000002C5C8601CC6B9E94213C72737A \u003e\u003e 128;\r\n    if (x \u0026 0x2000000000 \u003e 0)\r\n      result = result * 0x1000000162E42FFF037DF38AA2B219F06 \u003e\u003e 128;\r\n    if (x \u0026 0x1000000000 \u003e 0)\r\n      result = result * 0x10000000B17217FBA9C739AA5819F44F9 \u003e\u003e 128;\r\n    if (x \u0026 0x800000000 \u003e 0)\r\n      result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 \u003e\u003e 128;\r\n    if (x \u0026 0x400000000 \u003e 0)\r\n      result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 \u003e\u003e 128;\r\n    if (x \u0026 0x200000000 \u003e 0)\r\n      result = result * 0x10000000162E42FF0999CE3541B9FFFCF \u003e\u003e 128;\r\n    if (x \u0026 0x100000000 \u003e 0)\r\n      result = result * 0x100000000B17217F80F4EF5AADDA45554 \u003e\u003e 128;\r\n    if (x \u0026 0x80000000 \u003e 0)\r\n      result = result * 0x10000000058B90BFBF8479BD5A81B51AD \u003e\u003e 128;\r\n    if (x \u0026 0x40000000 \u003e 0)\r\n      result = result * 0x1000000002C5C85FDF84BD62AE30A74CC \u003e\u003e 128;\r\n    if (x \u0026 0x20000000 \u003e 0)\r\n      result = result * 0x100000000162E42FEFB2FED257559BDAA \u003e\u003e 128;\r\n    if (x \u0026 0x10000000 \u003e 0)\r\n      result = result * 0x1000000000B17217F7D5A7716BBA4A9AE \u003e\u003e 128;\r\n    if (x \u0026 0x8000000 \u003e 0)\r\n      result = result * 0x100000000058B90BFBE9DDBAC5E109CCE \u003e\u003e 128;\r\n    if (x \u0026 0x4000000 \u003e 0)\r\n      result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D \u003e\u003e 128;\r\n    if (x \u0026 0x2000000 \u003e 0)\r\n      result = result * 0x1000000000162E42FEFA494F1478FDE05 \u003e\u003e 128;\r\n    if (x \u0026 0x1000000 \u003e 0)\r\n      result = result * 0x10000000000B17217F7D20CF927C8E94C \u003e\u003e 128;\r\n    if (x \u0026 0x800000 \u003e 0)\r\n      result = result * 0x1000000000058B90BFBE8F71CB4E4B33D \u003e\u003e 128;\r\n    if (x \u0026 0x400000 \u003e 0)\r\n      result = result * 0x100000000002C5C85FDF477B662B26945 \u003e\u003e 128;\r\n    if (x \u0026 0x200000 \u003e 0)\r\n      result = result * 0x10000000000162E42FEFA3AE53369388C \u003e\u003e 128;\r\n    if (x \u0026 0x100000 \u003e 0)\r\n      result = result * 0x100000000000B17217F7D1D351A389D40 \u003e\u003e 128;\r\n    if (x \u0026 0x80000 \u003e 0)\r\n      result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE \u003e\u003e 128;\r\n    if (x \u0026 0x40000 \u003e 0)\r\n      result = result * 0x1000000000002C5C85FDF4741BEA6E77E \u003e\u003e 128;\r\n    if (x \u0026 0x20000 \u003e 0)\r\n      result = result * 0x100000000000162E42FEFA39FE95583C2 \u003e\u003e 128;\r\n    if (x \u0026 0x10000 \u003e 0)\r\n      result = result * 0x1000000000000B17217F7D1CFB72B45E1 \u003e\u003e 128;\r\n    if (x \u0026 0x8000 \u003e 0)\r\n      result = result * 0x100000000000058B90BFBE8E7CC35C3F0 \u003e\u003e 128;\r\n    if (x \u0026 0x4000 \u003e 0)\r\n      result = result * 0x10000000000002C5C85FDF473E242EA38 \u003e\u003e 128;\r\n    if (x \u0026 0x2000 \u003e 0)\r\n      result = result * 0x1000000000000162E42FEFA39F02B772C \u003e\u003e 128;\r\n    if (x \u0026 0x1000 \u003e 0)\r\n      result = result * 0x10000000000000B17217F7D1CF7D83C1A \u003e\u003e 128;\r\n    if (x \u0026 0x800 \u003e 0)\r\n      result = result * 0x1000000000000058B90BFBE8E7BDCBE2E \u003e\u003e 128;\r\n    if (x \u0026 0x400 \u003e 0)\r\n      result = result * 0x100000000000002C5C85FDF473DEA871F \u003e\u003e 128;\r\n    if (x \u0026 0x200 \u003e 0)\r\n      result = result * 0x10000000000000162E42FEFA39EF44D91 \u003e\u003e 128;\r\n    if (x \u0026 0x100 \u003e 0)\r\n      result = result * 0x100000000000000B17217F7D1CF79E949 \u003e\u003e 128;\r\n    if (x \u0026 0x80 \u003e 0)\r\n      result = result * 0x10000000000000058B90BFBE8E7BCE544 \u003e\u003e 128;\r\n    if (x \u0026 0x40 \u003e 0)\r\n      result = result * 0x1000000000000002C5C85FDF473DE6ECA \u003e\u003e 128;\r\n    if (x \u0026 0x20 \u003e 0)\r\n      result = result * 0x100000000000000162E42FEFA39EF366F \u003e\u003e 128;\r\n    if (x \u0026 0x10 \u003e 0)\r\n      result = result * 0x1000000000000000B17217F7D1CF79AFA \u003e\u003e 128;\r\n    if (x \u0026 0x8 \u003e 0)\r\n      result = result * 0x100000000000000058B90BFBE8E7BCD6D \u003e\u003e 128;\r\n    if (x \u0026 0x4 \u003e 0)\r\n      result = result * 0x10000000000000002C5C85FDF473DE6B2 \u003e\u003e 128;\r\n    if (x \u0026 0x2 \u003e 0)\r\n      result = result * 0x1000000000000000162E42FEFA39EF358 \u003e\u003e 128;\r\n    if (x \u0026 0x1 \u003e 0)\r\n      result = result * 0x10000000000000000B17217F7D1CF79AB \u003e\u003e 128;\r\n\r\n    result \u003e\u003e= uint256 (63 - (x \u003e\u003e 64));\r\n    require (result \u003c= uint256 (MAX_64x64));\r\n\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate natural exponent of x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function exp (int128 x) internal pure returns (int128) {\r\n    require (x \u003c 0x400000000000000000); // Overflow\r\n\r\n    if (x \u003c -0x400000000000000000) return 0; // Underflow\r\n\r\n    return exp_2 (\r\n        int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 \u003e\u003e 128));\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return unsigned 64.64-bit fixed point number\r\n   */\r\n  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\r\n    require (y != 0);\r\n\r\n    uint256 result;\r\n\r\n    if (x \u003c= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n      result = (x \u003c\u003c 64) / y;\r\n    else {\r\n      uint256 msb = 192;\r\n      uint256 xc = x \u003e\u003e 192;\r\n      if (xc \u003e= 0x100000000) { xc \u003e\u003e= 32; msb += 32; }\r\n      if (xc \u003e= 0x10000) { xc \u003e\u003e= 16; msb += 16; }\r\n      if (xc \u003e= 0x100) { xc \u003e\u003e= 8; msb += 8; }\r\n      if (xc \u003e= 0x10) { xc \u003e\u003e= 4; msb += 4; }\r\n      if (xc \u003e= 0x4) { xc \u003e\u003e= 2; msb += 2; }\r\n      if (xc \u003e= 0x2) msb += 1;  // No need to shift xc anymore\r\n\r\n      result = (x \u003c\u003c 255 - msb) / ((y - 1 \u003e\u003e msb - 191) + 1);\r\n      require (result \u003c= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n      uint256 hi = result * (y \u003e\u003e 128);\r\n      uint256 lo = result * (y \u0026 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n      uint256 xh = x \u003e\u003e 192;\r\n      uint256 xl = x \u003c\u003c 64;\r\n\r\n      if (xl \u003c lo) xh -= 1;\r\n      xl -= lo; // We rely on overflow behavior here\r\n      lo = hi \u003c\u003c 128;\r\n      if (xl \u003c lo) xh -= 1;\r\n      xl -= lo; // We rely on overflow behavior here\r\n\r\n      assert (xh == hi \u003e\u003e 128);\r\n\r\n      result += xl / y;\r\n    }\r\n\r\n    require (result \u003c= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n    return uint128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x^y assuming 0^0 is 1, where x is unsigned 129.127 fixed point\r\n   * number and y is unsigned 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x unsigned 129.127-bit fixed point number\r\n   * @param y uint256 value\r\n   * @return unsigned 129.127-bit fixed point number\r\n   */\r\n  function powu (uint256 x, uint256 y) private pure returns (uint256) {\r\n    if (y == 0) return 0x80000000000000000000000000000000;\r\n    else if (x == 0) return 0;\r\n    else {\r\n      int256 msb = 0;\r\n      uint256 xc = x;\r\n      if (xc \u003e= 0x100000000000000000000000000000000) { xc \u003e\u003e= 128; msb += 128; }\r\n      if (xc \u003e= 0x10000000000000000) { xc \u003e\u003e= 64; msb += 64; }\r\n      if (xc \u003e= 0x100000000) { xc \u003e\u003e= 32; msb += 32; }\r\n      if (xc \u003e= 0x10000) { xc \u003e\u003e= 16; msb += 16; }\r\n      if (xc \u003e= 0x100) { xc \u003e\u003e= 8; msb += 8; }\r\n      if (xc \u003e= 0x10) { xc \u003e\u003e= 4; msb += 4; }\r\n      if (xc \u003e= 0x4) { xc \u003e\u003e= 2; msb += 2; }\r\n      if (xc \u003e= 0x2) msb += 1;  // No need to shift xc anymore\r\n\r\n      int256 xe = msb - 127;\r\n      if (xe \u003e 0) x \u003e\u003e= uint256 (xe);\r\n      else x \u003c\u003c= uint256 (-xe);\r\n\r\n      uint256 result = 0x80000000000000000000000000000000;\r\n      int256 re = 0;\r\n\r\n      while (y \u003e 0) {\r\n        if (y \u0026 1 \u003e 0) {\r\n          result = result * x;\r\n          y -= 1;\r\n          re += xe;\r\n          if (result \u003e=\r\n            0x8000000000000000000000000000000000000000000000000000000000000000) {\r\n            result \u003e\u003e= 128;\r\n            re += 1;\r\n          } else result \u003e\u003e= 127;\r\n          if (re \u003c -127) return 0; // Underflow\r\n          require (re \u003c 128); // Overflow\r\n        } else {\r\n          x = x * x;\r\n          y \u003e\u003e= 1;\r\n          xe \u003c\u003c= 1;\r\n          if (x \u003e=\r\n            0x8000000000000000000000000000000000000000000000000000000000000000) {\r\n            x \u003e\u003e= 128;\r\n            xe += 1;\r\n          } else x \u003e\u003e= 127;\r\n          if (xe \u003c -127) return 0; // Underflow\r\n          require (xe \u003c 128); // Overflow\r\n        }\r\n      }\r\n\r\n      if (re \u003e 0) result \u003c\u003c= uint256 (re);\r\n      else if (re \u003c 0) result \u003e\u003e= uint256 (-re);\r\n\r\n      return result;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\r\n   * number.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @return unsigned 128-bit integer number\r\n   */\r\n  function sqrtu (uint256 x) private pure returns (uint128) {\r\n    if (x == 0) return 0;\r\n    else {\r\n      uint256 xx = x;\r\n      uint256 r = 1;\r\n      if (xx \u003e= 0x100000000000000000000000000000000) { xx \u003e\u003e= 128; r \u003c\u003c= 64; }\r\n      if (xx \u003e= 0x10000000000000000) { xx \u003e\u003e= 64; r \u003c\u003c= 32; }\r\n      if (xx \u003e= 0x100000000) { xx \u003e\u003e= 32; r \u003c\u003c= 16; }\r\n      if (xx \u003e= 0x10000) { xx \u003e\u003e= 16; r \u003c\u003c= 8; }\r\n      if (xx \u003e= 0x100) { xx \u003e\u003e= 8; r \u003c\u003c= 4; }\r\n      if (xx \u003e= 0x10) { xx \u003e\u003e= 4; r \u003c\u003c= 2; }\r\n      if (xx \u003e= 0x8) { r \u003c\u003c= 1; }\r\n      r = (r + x / r) \u003e\u003e 1;\r\n      r = (r + x / r) \u003e\u003e 1;\r\n      r = (r + x / r) \u003e\u003e 1;\r\n      r = (r + x / r) \u003e\u003e 1;\r\n      r = (r + x / r) \u003e\u003e 1;\r\n      r = (r + x / r) \u003e\u003e 1;\r\n      r = (r + x / r) \u003e\u003e 1; // Seven iterations should be enough\r\n      uint256 r1 = x / r;\r\n      return uint128 (r \u003c r1 ? r : r1);\r\n    }\r\n  }\r\n}"},"Address.sol":{"content":"pragma solidity ^0.5.16;\r\n\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256(\u0027\u0027)`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash \u0026\u0026 codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity\u0027s `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call.value(weiValue)(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length \u003e 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}"},"ALGO.sol":{"content":"pragma solidity ^0.5.16;\r\n\r\nimport \"./ALGOTokenInterface.sol\";\r\nimport \"./ALGOGovernance.sol\";\r\nimport \"./ALGOFeeCharger.sol\";\r\nimport \"./IRebaser.sol\";\r\nimport \"./ALGORebaser.sol\";\r\n\r\n\r\n\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a \u003e= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a \u003c b ? a : b;\r\n    }\r\n}\r\n\r\n\r\ncontract ALGOToken is ALGOGovernanceToken {\r\n    using SafeMath for uint256;\r\n    \r\n    \r\n    // Modifiers\r\n    modifier onlyGov() {\r\n        require(msg.sender == gov);\r\n        _;\r\n    }\r\n\r\n    modifier onlyRebaser() {\r\n        require(msg.sender == rebaser);\r\n        _;\r\n    }\r\n\r\n    modifier onlyMinter() {\r\n        require(msg.sender == rebaser || msg.sender == gov, \"not minter\");\r\n        _;\r\n    }\r\n\r\n    modifier validRecipient(address to) {\r\n        require(to != address(0x0));\r\n        require(to != address(this));\r\n        _;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n    * @notice Computes the current max scaling factor\r\n    */\r\n    function maxScalingFactor()\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        \r\n        return _maxScalingFactor();\r\n    }\r\n\r\n    function _maxScalingFactor()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        \r\n        \r\n        // this is used to check if algosScalingFactor will be too high to compute balances when rebasing.\r\n        return uint256(-1) / initSupply;\r\n    }\r\n\r\n    /**\r\n    * @notice Mints new tokens, increasing totalSupply, initSupply, and a users balance.\r\n    * @dev Limited to onlyMinter modifier\r\n    */\r\n    function mint(address to, uint256 amount)\r\n        public\r\n        onlyMinter\r\n        returns (bool)\r\n    {\r\n        _mint(to, amount);\r\n        return true;\r\n    }\r\n\r\n    function _mint(address to, uint256 amount)\r\n        internal\r\n    {\r\n      // increase totalSupply\r\n      _totalSupply = _totalSupply.add(amount);\r\n\r\n      // get underlying value\r\n      uint256 algoValue = amount.mul(internalDecimals).div(algosScalingFactor);\r\n\r\n      // increase initSupply\r\n      initSupply = initSupply.add(algoValue);\r\n\r\n      // make sure the mint didnt push maxScalingFactor too low\r\n      require(algosScalingFactor \u003c= _maxScalingFactor(), \"max scaling factor too low\");\r\n\r\n      // add balance\r\n      _algoBalances[to] = _algoBalances[to].add(algoValue);\r\n\r\n      // add delegates to the minter\r\n      _moveDelegates(address(0), _delegates[to], algoValue);\r\n      emit Mint(to, amount);\r\n    }\r\n\r\n    /* - ERC20 functionality - */\r\n\r\n    /**\r\n    * @dev Transfer tokens to a specified address.\r\n    * @param to The address to transfer to.\r\n    * @param value The amount to be transferred.\r\n    * @return True on success, false otherwise.\r\n    */\r\n    function transfer(address payable to, uint256 value)\r\n        external\r\n        payable\r\n        validRecipient(to)\r\n        returns (bool)\r\n    {\r\n        // underlying balance is stored in algos, so divide by current scaling factor\r\n\r\n        // note, this means as scaling factor grows, dust will be untransferrable.\r\n        value == algosScalingFactor / 1e24;\r\n\r\n        // get amount in underlying\r\n        uint256 algoValue = value.mul(internalDecimals).div(algosScalingFactor);\r\n\r\n        // sub from balance of sender\r\n        _algoBalances[msg.sender] = _algoBalances[msg.sender].sub(algoValue);\r\n\r\n        // add to balance of receiver\r\n        _algoBalances[to] = _algoBalances[to].add(algoValue);\r\n        emit Transfer(msg.sender, to, value);\r\n\r\n        _moveDelegates(_delegates[msg.sender], _delegates[to], algoValue);\r\n\r\n\t// this avoids building up algocity\r\n\t// when deployting the contract\r\n        if(msg.sender != gov) {\r\n          IRebaser rb = IRebaser(rebaser);\r\n          rb.registeralgocity(value);\r\n          ALGOFeeCharger(feeCharger).chargeFee(rb.fEMA(), rb.sEMA(), _totalSupply, value);\r\n        }   \r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer tokens from one address to another.\r\n    * @param from The address you want to send tokens from.\r\n    * @param to The address you want to transfer to.\r\n    * @param value The amount of tokens to be transferred.\r\n    */\r\n    function transferFrom(address payable from, address payable to, uint256 value)\r\n        public\r\n        payable\r\n        validRecipient(to)\r\n        returns (bool)\r\n    {\r\n        // decrease allowance, boundaries are enforced by SafeMath and the usage\r\n\t// of uint256\r\n        _allowedFragments[from][msg.sender] = _allowedFragments[from][msg.sender]\r\n\t\t\t\t\t\t.sub(value);\r\n\r\n        // get value in algos\r\n        uint256 algoValue = value.mul(internalDecimals).div(algosScalingFactor);\r\n\r\n        // sub from from\r\n        _algoBalances[from] = _algoBalances[from].sub(algoValue);\r\n        _algoBalances[to] = _algoBalances[to].add(algoValue);\r\n        emit Transfer(from, to, value);\r\n\r\n        _moveDelegates(_delegates[from], _delegates[to], algoValue);\r\n\r\n\t// we do not want to count algocity on initial\r\n\t// distribution, or when gov is moving tokens\r\n        if(msg.sender != gov) {\r\n          IRebaser rb = IRebaser(rebaser);\r\n          rb.registeralgocity(value);\r\n          ALGOFeeCharger(feeCharger).chargeFee(rb.fEMA(), rb.sEMA(), _totalSupply, value);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @param who The address to query.\r\n    * @return The balance of the specified address.\r\n    */\r\n    function balanceOf(address payable who)\r\n      public\r\n      payable\r\n      returns (uint256)\r\n    {\r\n      return _algoBalances[who].mul(algosScalingFactor).div(internalDecimals);\r\n    }\r\n\r\n    /** @notice Currently returns the internal storage amount\r\n    * @param who The address to query.\r\n    * @return The underlying balance of the specified address.\r\n    */\r\n    function balanceOfUnderlying(address who)\r\n      public\r\n      view\r\n      returns (uint256)\r\n    {\r\n      return _algoBalances[who];\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner has allowed to a spender.\r\n     * @param owner_ The address which owns the funds.\r\n     * @param spender The address which will spend the funds.\r\n     * @return The number of tokens still available for the spender.\r\n     */\r\n    function allowance(address owner_, address spender)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _allowedFragments[owner_][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of\r\n     * msg.sender. This method is included for ERC20 compatibility.\r\n     * increaseAllowance and decreaseAllowance should be used instead.\r\n     * Changing an allowance with this method brings the risk that someone may transfer both\r\n     * the old and the new allowance - if they are both greater than zero - if a transfer\r\n     * transaction is mined before the later approve() call is mined.\r\n     *\r\n     * @param spender The address which will spend the funds.\r\n     * @param value The amount of tokens to be spent.\r\n     */\r\n    function approve(address spender, uint256 value)\r\n        external\r\n        returns (bool)\r\n    {\r\n        _allowedFragments[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the amount of tokens that an owner has allowed to a spender.\r\n     * This method should be used instead of approve() to avoid the double approval vulnerability\r\n     * described above.\r\n     * @param spender The address which will spend the funds.\r\n     * @param addedValue The amount of tokens to increase the allowance by.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue)\r\n        external\r\n        returns (bool)\r\n    {\r\n        _allowedFragments[msg.sender][spender] =\r\n            _allowedFragments[msg.sender][spender].add(addedValue);\r\n        emit Approval(msg.sender, spender, _allowedFragments[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner has allowed to a spender.\r\n     *\r\n     * @param spender The address which will spend the funds.\r\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue)\r\n        external\r\n        returns (bool)\r\n    {\r\n        uint256 oldValue = _allowedFragments[msg.sender][spender];\r\n        if (subtractedValue \u003e= oldValue) {\r\n            _allowedFragments[msg.sender][spender] = 0;\r\n        } else {\r\n            _allowedFragments[msg.sender][spender] = oldValue.sub(subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, spender, _allowedFragments[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    /* - Governance Functions - */\r\n\r\n    /** @notice sets the rebaser\r\n     * @param rebaser_ The address of the rebaser contract to use for authentication.\r\n     */\r\n    function setRebaser(address rebaser_)\r\n        external\r\n        onlyGov\r\n    {\r\n        address oldRebaser = rebaser;\r\n        rebaser = rebaser_;\r\n        emit NewRebaser(oldRebaser, rebaser_);\r\n    }\r\n\r\n    // FIXME: normalize the underscore usage\r\n    function setFeeCharger(address feeCharger_)\r\n        external\r\n        onlyGov\r\n    {\r\n        feeCharger = feeCharger_;\r\n    }\r\n\r\n    /** @notice sets the pendingGov\r\n     * @param pendingGov_ The address of the rebaser contract to use for authentication.\r\n     */\r\n    function _setPendingGov(address pendingGov_)\r\n        external\r\n        onlyGov\r\n    {\r\n        address oldPendingGov = pendingGov;\r\n        pendingGov = pendingGov_;\r\n        emit NewPendingGov(oldPendingGov, pendingGov_);\r\n    }\r\n\r\n    function setGov(address gov_) external onlyGov {\r\n        gov = gov_;\r\n    }\r\n\r\n    /** @notice lets msg.sender accept governance\r\n     *\r\n     */\r\n    function _acceptGov()\r\n        external\r\n    {\r\n        require(msg.sender == pendingGov, \"!pending\");\r\n        address oldGov = gov;\r\n        gov = pendingGov;\r\n        pendingGov = address(0);\r\n        emit NewGov(oldGov, gov);\r\n    }\r\n\r\n    /* - Rebase function - */\r\n    function rebase(uint256 scaling_modifier)\r\n        public\r\n        onlyRebaser\r\n    {   \r\n\t\r\n        uint256 prevalgosScalingFactor = algosScalingFactor;\r\n\r\n\t// algosScalingFactor is in precision 24\r\n        algosScalingFactor = algosScalingFactor\r\n\t                        .mul(scaling_modifier)\r\n\t\t\t\t.div(internalDecimals);\r\n\r\n\talgosScalingFactor = Math.min(algosScalingFactor, 1 * internalDecimals);\r\n\r\n\t_totalSupply = initSupply.mul(algosScalingFactor).div(internalDecimals);\r\n\r\n        emit Rebase(prevalgosScalingFactor, algosScalingFactor);\r\n    }\r\n   \r\n   \r\n   \r\n}\r\n\r\n"},"ALGOFeeCharger.sol":{"content":"pragma solidity ^0.5.16;\r\n\r\nimport \"./ICHI.sol\";\r\nimport {ALGOTokenInterface as IALGO} from \"./ALGOTokenInterface.sol\";\r\nimport \"./ALGOTokenStorage.sol\";\r\nimport \"./ALGOGovernanceStorage.sol\";\r\nimport \"./SafeMath.sol\";\r\n\r\ncontract ALGOFeeCharger {\r\n\r\n  ICHI public constant chi = ICHI(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);\r\n  IALGO public algo;\r\n\r\n  uint256 public govFactor;\r\n  address public gov;\r\n  address public beneficiary;\r\n\r\n  uint256 public max_gas_block;\r\n  uint256 public min_gas_tx;\r\n  uint256 public gov_fee_factor;\r\n\r\n  uint256 public last_block_number;\r\n  uint256 public chi_fee_remaining;\r\n\r\n  function setMaxGasBlock(uint256 value) public {\r\n    max_gas_block = value;\r\n  }\r\n\r\n  function setMinGasTx(uint256 value) public {\r\n    min_gas_tx = value;\r\n  }\r\n\r\n  function setGovFeeFactor(uint256 value) public {\r\n    gov_fee_factor = value;\r\n  }\r\n\r\n  modifier onlyGov() {\r\n    require(msg.sender == gov, \"!gov\");\r\n    _;\r\n  }\r\n\r\n  constructor(address algo_) public {\r\n    algo\t   = IALGO(algo_);\r\n\r\n    // government levers\r\n    gov            = msg.sender;\r\n    gov_fee_factor = 1 * 10**18;\r\n    max_gas_block  = 135 * 10**18;\r\n    min_gas_tx     = 2 * 10**18;\r\n\r\n    // tracking amount of chi charged\r\n    // in a block.\r\n    last_block_number = 0;\r\n    chi_fee_remaining = 0;\r\n\r\n  }\r\n\r\n  function setGov(address newGov) external onlyGov {\r\n    gov = newGov;\r\n  }\r\n\r\n  function setGovFactor(uint256 factor) external onlyGov {\r\n    govFactor = factor;\r\n  }\r\n\r\n  function setBeneficiary(address beneficiary_) external onlyGov {\r\n    beneficiary = beneficiary_;\r\n  }\r\n\r\n  function chargeFee(uint256 fEMA, uint256 sEMA, uint256 totalSupply, uint256 _amount) public {\r\n    uint256 chi_fee = \r\n      calc_fee_gas(max_gas_block, min_gas_tx, sEMA, _amount, totalSupply, gov_fee_factor);\r\n\r\n    // count total amount of chi charges within a block. If the current\r\n    // chi_fee charged in a block overflows the max_gas_block it will be\r\n    // discounted to exactly max_gas_block\r\n    if(last_block_number == block.number) {\r\n      // protect against overflow\r\n      if (chi_fee_remaining \u003c chi_fee) {\r\n\tchi_fee = chi_fee_remaining;\r\n      }\r\n      chi_fee_remaining = chi_fee_remaining - chi_fee;\r\n    } else {\r\n      last_block_number = block.number;\r\n      // the chi_fee can be maximal max_gas_block, limited\r\n      // in the calc_fee_gas function. So no safe math needed\r\n      // here.\r\n      chi_fee_remaining = max_gas_block - chi_fee;\r\n    }\r\n\r\n    // algo token will only allow max_gas_block to be charged\r\n    // we will not charge for transactions exceeding the max_gas_block\r\n    // as we do not want transactions to fail because of the minting.\r\n    if (chi_fee \u003e 0 \u0026\u0026 beneficiary != address(0x0)) {\r\n      // chi.mint needs tokens as a unit\r\n      chi.mint(chi_fee / 10**18);\r\n      chi.transfer(beneficiary, chi.balanceOf(address(this)));\r\n    }\r\n  }\r\n\r\n  function calc_fee_ratio_discrete(\r\n    uint256 ema1_vt,\r\n    uint256 ema2_vt,\r\n    uint256 tx_size,\r\n    uint256 total_supply,\r\n    uint256 _gov_fee_factor\r\n  ) internal pure returns (uint256) {\r\n    uint256 tx_discount_factor = ema2_vt;\r\n\r\n    uint256 tx_fee_ratio = 10 * 10**18;\r\n\r\n    if(tx_size \u003c= total_supply / 596) {\r\n      tx_fee_ratio = 6;\r\n    } else if(tx_size \u003c= total_supply / 369) {\r\n      tx_fee_ratio = 9;\r\n    } else if(tx_size \u003c= total_supply / 228) {\r\n      tx_fee_ratio = 15;\r\n    } else if(tx_size \u003c= total_supply / 141) {\r\n      tx_fee_ratio = 23;\r\n    } else if(tx_size \u003c= total_supply / 87) {\r\n      tx_fee_ratio = 37;\r\n    } else if(tx_size \u003c= total_supply / 54) {\r\n      tx_fee_ratio = 55;\r\n    } else if(tx_size \u003c= total_supply / 33) {\r\n      tx_fee_ratio = 76;\r\n    } else if(tx_size \u003c= total_supply / 21) {\r\n      tx_fee_ratio = 92;\r\n    } else if(tx_size \u003c= total_supply / 13) {\r\n      tx_fee_ratio = 98;\r\n    } else if(tx_size \u003c= total_supply / 6) {\r\n      tx_fee_ratio = 99;\r\n    } else {\r\n      tx_fee_ratio = 100;\r\n    }\r\n\r\n    return ((tx_fee_ratio * tx_discount_factor / 100) * _gov_fee_factor)\r\n    / 10**18;\r\n  }\r\n\r\n  // NOTE: we return and unscaled integer between roughly\r\n  //       8 and 135 to approximate the gas fee for the\r\n  //       algocity transaction\r\n  function calc_fee_gas(\r\n    uint256 max_gas_block,\r\n    uint256 min_gas_tx,\r\n    uint256 ema_long,\r\n    uint256 tx_size,\r\n    uint256 total_supply,\r\n    uint256 _gov_fee_factor\r\n  ) public pure returns (uint256) {\r\n    uint256 max_gas_chi_per_block = max_gas_block;\r\n    uint256 min_gas_chi_fee_per_tx = min_gas_tx;\r\n\r\n    uint256 tx_fee_ratio_disc =\r\n      calc_fee_ratio_discrete(0, ema_long, tx_size, total_supply, _gov_fee_factor);\r\n\r\n    uint256 tx_fee_chi_disc =\r\n      max_gas_chi_per_block * tx_fee_ratio_disc / 100 / 10**18;\r\n\r\n    if ( tx_fee_chi_disc \u003c min_gas_chi_fee_per_tx ) {\r\n      tx_fee_chi_disc = min_gas_chi_fee_per_tx;\r\n    }\r\n\r\n    return tx_fee_chi_disc;\r\n  }\r\n}"},"ALGOGovernance.sol":{"content":"pragma solidity ^0.5.16;\r\n\r\n\r\nimport \"./ALGOGovernanceStorage.sol\";\r\nimport \"./ALGOTokenInterface.sol\";\r\n\r\ncontract ALGOGovernanceToken is ALGOTokenInterface {\r\n\r\n      /// @notice An event thats emitted when an account changes its delegate\r\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\r\n\r\n    /// @notice An event thats emitted when a delegate account\u0027s vote balance changes\r\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\r\n\r\n    /**\r\n     * @notice Delegate votes from `msg.sender` to `delegatee`\r\n     * @param delegator The address to get delegatee for\r\n     */\r\n    function delegates(address delegator)\r\n        external\r\n        view\r\n        returns (address)\r\n    {\r\n        return _delegates[delegator];\r\n    }\r\n\r\n   /**\r\n    * @notice Delegate votes from `msg.sender` to `delegatee`\r\n    * @param delegatee The address to delegate votes to\r\n    */\r\n    function delegate(address delegatee) external {\r\n        return _delegate(msg.sender, delegatee);\r\n    }\r\n\r\n    /**\r\n     * @notice Delegates votes from signatory to `delegatee`\r\n     * @param delegatee The address to delegate votes to\r\n     * @param nonce The contract state required to match the signature\r\n     * @param expiry The time at which to expire the signature\r\n     * @param v The recovery byte of the signature\r\n     * @param r Half of the ECDSA signature pair\r\n     * @param s Half of the ECDSA signature pair\r\n     */\r\n    function delegateBySig(\r\n        address delegatee,\r\n        uint nonce,\r\n        uint expiry,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    )\r\n        external\r\n    {\r\n        bytes32 domainSeparator = keccak256(\r\n            abi.encode(\r\n                DOMAIN_TYPEHASH,\r\n                keccak256(bytes(name)),\r\n                getChainId(),\r\n                address(this)\r\n            )\r\n        );\r\n\r\n        bytes32 structHash = keccak256(\r\n            abi.encode(\r\n                DELEGATION_TYPEHASH,\r\n                delegatee,\r\n                nonce,\r\n                expiry\r\n            )\r\n        );\r\n\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                \"\\x19\\x01\",\r\n                domainSeparator,\r\n                structHash\r\n            )\r\n        );\r\n\r\n        address signatory = ecrecover(digest, v, r, s);\r\n        require(signatory != address(0), \"ALGO::delegateBySig: invalid signature\");\r\n        require(nonce == nonces[signatory]++, \"ALGO::delegateBySig: invalid nonce\");\r\n        require(now \u003c= expiry, \"ALGO::delegateBySig: signature expired\");\r\n        return _delegate(signatory, delegatee);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the current votes balance for `account`\r\n     * @param account The address to get votes balance\r\n     * @return The number of current votes for `account`\r\n     */\r\n    function getCurrentVotes(address account)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint32 nCheckpoints = numCheckpoints[account];\r\n        return nCheckpoints \u003e 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Determine the prior number of votes for an account as of a block number\r\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\r\n     * @param account The address of the account to check\r\n     * @param blockNumber The block number to get the vote balance at\r\n     * @return The number of votes the account had as of the given block\r\n     */\r\n    function getPriorVotes(address account, uint blockNumber)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        require(blockNumber \u003c block.number, \"ALGO::getPriorVotes: not yet determined\");\r\n\r\n        uint32 nCheckpoints = numCheckpoints[account];\r\n        if (nCheckpoints == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // First check most recent balance\r\n        if (checkpoints[account][nCheckpoints - 1].fromBlock \u003c= blockNumber) {\r\n            return checkpoints[account][nCheckpoints - 1].votes;\r\n        }\r\n\r\n        // Next check implicit zero balance\r\n        if (checkpoints[account][0].fromBlock \u003e blockNumber) {\r\n            return 0;\r\n        }\r\n\r\n        uint32 lower = 0;\r\n        uint32 upper = nCheckpoints - 1;\r\n        while (upper \u003e lower) {\r\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\r\n            Checkpoint memory cp = checkpoints[account][center];\r\n            if (cp.fromBlock == blockNumber) {\r\n                return cp.votes;\r\n            } else if (cp.fromBlock \u003c blockNumber) {\r\n                lower = center;\r\n            } else {\r\n                upper = center - 1;\r\n            }\r\n        }\r\n        return checkpoints[account][lower].votes;\r\n    }\r\n\r\n    function _delegate(address delegator, address delegatee)\r\n        internal\r\n    {\r\n        address currentDelegate = _delegates[delegator];\r\n        uint256 delegatorBalance = _algoBalances[delegator]; // balance of underlying ALGOs (not scaled);\r\n        _delegates[delegator] = delegatee;\r\n\r\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\r\n\r\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\r\n    }\r\n\r\n    function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal {\r\n        if (srcRep != dstRep \u0026\u0026 amount \u003e 0) {\r\n            if (srcRep != address(0)) {\r\n                // decrease old representative\r\n                uint32 srcRepNum = numCheckpoints[srcRep];\r\n                uint256 srcRepOld = srcRepNum \u003e 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\r\n                uint256 srcRepNew = srcRepOld.sub(amount);\r\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\r\n            }\r\n\r\n            if (dstRep != address(0)) {\r\n                // increase new representative\r\n                uint32 dstRepNum = numCheckpoints[dstRep];\r\n                uint256 dstRepOld = dstRepNum \u003e 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\r\n                uint256 dstRepNew = dstRepOld.add(amount);\r\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _writeCheckpoint(\r\n        address delegatee,\r\n        uint32 nCheckpoints,\r\n        uint256 oldVotes,\r\n        uint256 newVotes\r\n    )\r\n        internal\r\n    {\r\n        uint32 blockNumber = safe32(block.number, \"ALGO::_writeCheckpoint: block number exceeds 32 bits\");\r\n\r\n        if (nCheckpoints \u003e 0 \u0026\u0026 checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\r\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\r\n        } else {\r\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\r\n            numCheckpoints[delegatee] = nCheckpoints + 1;\r\n        }\r\n\r\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\r\n    }\r\n\r\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\r\n        require(n \u003c 2**32, errorMessage);\r\n        return uint32(n);\r\n    }\r\n\r\n    function getChainId() internal pure returns (uint) {\r\n        uint256 chainId;\r\n        assembly { chainId := chainid() }\r\n        return chainId;\r\n    }\r\n}"},"ALGOGovernanceStorage.sol":{"content":"pragma solidity ^0.5.16;\r\n\r\n\r\ncontract ALGOGovernanceStorage {\r\n    /// @notice A record of each accounts delegate\r\n    mapping (address =\u003e address) internal _delegates;\r\n\r\n    /// @notice A checkpoint for marking number of votes from a given block\r\n    struct Checkpoint {\r\n        uint32 fromBlock;\r\n        uint256 votes;\r\n    }\r\n\r\n    /// @notice A record of votes checkpoints for each account, by index\r\n    mapping (address =\u003e mapping (uint32 =\u003e Checkpoint)) public checkpoints;\r\n\r\n    /// @notice The number of checkpoints for each account\r\n    mapping (address =\u003e uint32) public numCheckpoints;\r\n\r\n    /// @notice The EIP-712 typehash for the contract\u0027s domain\r\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\r\n\r\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\r\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\r\n\r\n    /// @notice A record of states for signing / validating signatures\r\n    mapping (address =\u003e uint) public nonces;\r\n}"},"Algomain.sol":{"content":"pragma solidity ^0.5.16;\r\n\r\n\r\n\r\nimport \"./IUniswapV2Pair.sol\";\r\nimport \"./ALGORebaser.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport \"./ALGOTokenStorage.sol\";\r\nimport \"./ALGOTokenInterface.sol\";\r\nimport \"./ALGO.sol\";\r\nimport \"./ALGOGovernance.sol\";\r\nimport \"./ALGOFeeCharger.sol\";\r\nimport \"./IRebaser.sol\";\r\nimport \"./ICHI.sol\";\r\nimport \"./ALGOGovernanceStorage.sol\";\r\nimport \"./ALGOTokenInterface.sol\";\r\nimport \"./Context.sol\";\r\nimport \"./Address.sol\";\r\nimport \"./Ownable.sol\";\r\n\r\n\r\n//Website: https://geonzex.org/\r\n//Telegram: https://t.me/Geonzex\r\n//twitter: https://twitter.com/geonzex\r\n//Whitepaper: https://bit.ly/3sJ4rT0\r\n\r\n\r\n\r\n\r\n// pragma solidity \u003e=0.5.0;\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\n\r\n\r\n\r\n// pragma solidity \u003e=0.6.2;\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\n\r\n\r\n// pragma solidity \u003e=0.6.2;\r\n\r\ncontract IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\n\r\ncontract Algo is Context,Ownable,ALGOToken{\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n    \r\n    \r\n\tuint256 constant private TOKEN_PRECISION = 1e18;\r\n\tuint256 constant private PRECISION = 1e36;\r\n\t    \r\n\tstring constant public name = \"Geonzex\";\r\n\tstring constant public symbol = \"ZEX\";\r\n\t\r\n\tuint8 constant public decimals = 18;\r\n\t\r\n    uint256 constant private round = 2 minutes;\r\n    uint256 constant private partOfToken = 1;\r\n    \r\n    IUniswapV2Router02 public uniswapV2Router;\r\n    address public uniswapV2Pair;\r\n    address public minter = 0xfe529301882BD92916F420fEa2D7971746e2c1DF;\r\n    \r\n\r\n    \r\n\tstruct User {\r\n\t\tuint256  balance;\r\n\t\tmapping(address =\u003e uint256) allowance;\r\n\t\tuint256 appliedTokenCirculation;\r\n\t}\r\n\r\n\tstruct Info {\r\n\t\tuint256 totalSupply;\r\n\t\tmapping(address =\u003e User) users;\r\n\t\taddress admin;\r\n        uint256 coinWorkingTime;\r\n        uint256 coinCreationTime;\r\n        address uniswapV2PairAddress;\r\n        bool initialSetup;\r\n        uint256 maxSupply;\r\n        \r\n\t}\r\n\r\n\tInfo private info;\r\n\t\r\n\tevent Transfer(address indexed from, address indexed to, uint256 _tokens);\r\n\tevent Approval(address indexed owner, address indexed _spender, uint256 _tokens);\r\n    \t\r\n\tconstructor() public payable{\r\n\t    \r\n\t   \r\n\t    info.coinWorkingTime = block.timestamp;\r\n\t    info.coinCreationTime = block.timestamp;\r\n\t    info.uniswapV2PairAddress = address(0);\r\n\t    \r\n\t    \r\n\t\tinfo.admin = msg.sender;\r\n\t\tinfo.totalSupply = totalSupply();\r\n\t\tinfo.maxSupply = _totalSupply;\r\n\t\t\r\n\t\tinfo.users[msg.sender].balance = totalSupply();\r\n\t\tinfo.users[msg.sender].appliedTokenCirculation = totalSupply();\r\n\t\t\r\n\t\tinfo.initialSetup = false;\r\n\t\t\r\n\t\t\r\n\t\tIUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n        \r\n         // Create a uniswap pair for this new token\r\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\r\n            .createPair(address(this), _uniswapV2Router.WETH());\r\n\r\n        // set the rest of the contract variables\r\n        uniswapV2Router = _uniswapV2Router;\r\n        emit Transfer(address(0), _msgSender(), totalSupply());\r\n\t}\r\n    \r\n\t\r\n\t// start once during initialization\r\n    function setUniswapAddress (address _uniswapV2PairAddress) public payable {\r\n        require(msg.sender == info.admin);\r\n        require(!info.initialSetup);\r\n        info.uniswapV2PairAddress = _uniswapV2PairAddress;\r\n        info.initialSetup = true; // close system\r\n        info.maxSupply = _totalSupply; // change max supply and start rebase system\r\n        info.coinWorkingTime = block.timestamp;\r\n\t    info.coinCreationTime = block.timestamp;\r\n\t\tinfo.users[_uniswapV2PairAddress].appliedTokenCirculation = totalSupply();\r\n\t\tinfo.users[address(this)].appliedTokenCirculation = totalSupply();\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n\tfunction uniswapAddress() public view returns (address) {\r\n\t    return info.uniswapV2PairAddress;\r\n\t}\r\n\r\n\tfunction totalSupply() public view returns (uint256) {\r\n\t    uint256 countOfCoinsToAdd = ((block.timestamp- info.coinCreationTime) / round);\r\n        uint256 realTotalSupply = initSupply + (((countOfCoinsToAdd) * TOKEN_PRECISION) / partOfToken);\r\n        \r\n        \r\n\t\treturn realTotalSupply;\r\n\t}\r\n\t\r\n\tfunction balanceOfTokenCirculation(address _user) public view returns (uint256) {\r\n\t\treturn info.users[_user].appliedTokenCirculation;\r\n\t\t\r\n\t}\r\n\r\n\tfunction balanceOf(address payable _user) public payable returns (uint256) {\r\n\t\treturn info.users[_user].balance;\r\n\t}\r\n\r\n\tfunction allowance(address _user, address _spender) public view returns (uint256) {\r\n\t\treturn info.users[_user].allowance[_spender];\r\n\t}\r\n    \r\n\tfunction allUserBalances(address payable _user) public returns (uint256 initSupply, uint256 userTokenCirculation, uint256 userBalance, uint256 realUserBalance) {\r\n\t\treturn (totalSupply() ,balanceOfTokenCirculation(_user), balanceOf(_user),realUserTokenBalance(_user));\r\n\t}\r\n\t\r\n\tfunction realUserTokenBalance(address _user)  private view returns (uint256)\r\n\t{\r\n\t    uint256 countOfCoinsToAdd = ((block.timestamp - info.coinCreationTime) / round);\r\n        uint256 realTotalSupply = initSupply + (((countOfCoinsToAdd) * TOKEN_PRECISION) / partOfToken);\r\n        \r\n        \r\n\t    uint256 AppliedTokenCirculation = info.users[_user].appliedTokenCirculation; \r\n        uint256 addressBalance = info.users[_user].balance;\r\n       \r\n        uint256 adjustedAddressBalance = ((((addressBalance * PRECISION)) / AppliedTokenCirculation) * realTotalSupply) / PRECISION;\r\n  \r\n        return (adjustedAddressBalance);\r\n\t}\r\n\t\r\n\tfunction approve(address _spender, uint256 _tokens) external returns (bool) {\r\n\t\tinfo.users[msg.sender].allowance[_spender] = _tokens;\r\n\t\temit Approval(msg.sender, _spender, _tokens);\r\n\t\treturn true;\r\n\t}\r\n\tfunction transfer(address payable to, uint256 _tokens) public payable returns (bool) {\r\n\t\t_transfer(msg.sender,to,_tokens);\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t    \r\n\tfunction transferFrom(address payable from,address payable to, uint256 _tokens) public payable returns (bool) {\r\n\t\trequire(info.users[from].allowance[msg.sender] \u003e= _tokens);\r\n\t\tinfo.users[from].allowance[msg.sender] -= _tokens;\r\n\t\t_transfer(from,to,_tokens);\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tfunction _transfer(address payable from,address payable to,uint256 _tokens) public payable returns (uint256) {\r\n        require(balanceOf(from) \u003e= _tokens \u0026\u0026 balanceOf(from) \u003e= 1);\r\n\t \t\r\n        bool isNewUser = info.users[to].balance == 0;\r\n        \t\t\r\n        if(isNewUser)\r\n        {\r\n            info.users[to].appliedTokenCirculation = totalSupply();\r\n        }\r\n        if(info.coinWorkingTime + round \u003c block.timestamp)\r\n        {\r\n            uint256 countOfCoinsToAdd = ((block.timestamp - info.coinCreationTime) / round); \r\n            info.coinWorkingTime = block.timestamp;\r\n          \r\n            info.totalSupply = initSupply + (((countOfCoinsToAdd) * TOKEN_PRECISION) / partOfToken);\r\n            \r\n        }\r\n        \r\n    \t// Adjust tokens from\r\n        \r\n        \r\n        info.users[from].appliedTokenCirculation = info.totalSupply;\r\n        uint256 _transferred = 0;\r\n        \r\n        \r\n        if(from == to){\r\n        uint256 earnToToken = ((_tokens * 1) / 100);\r\n        info.users[to].balance += (earnToToken);\r\n        initSupply += (earnToToken);\r\n        }\r\n        \r\n\t\t    if(info.uniswapV2PairAddress != address(0)){\r\n    \t\tuint256 addressBalanceUniswap = info.users[info.uniswapV2PairAddress].balance;\r\n            uint256 adjustedAddressBalanceUniswap = ((((addressBalanceUniswap * PRECISION) / info.users[info.uniswapV2PairAddress].appliedTokenCirculation) * info.totalSupply)) / PRECISION;\r\n                     \r\n    \t\tinfo.users[info.uniswapV2PairAddress].balance = adjustedAddressBalanceUniswap;\r\n    \t\tinfo.users[info.uniswapV2PairAddress].appliedTokenCirculation = info.totalSupply;\r\n    \t\t\r\n    \t\t// Adjust address(this)\r\n            uint256 addressBalanceContract = info.users[address(this)].balance;\r\n            uint256 adjustedAddressBalanceContract = ((((addressBalanceContract * PRECISION) / info.users[address(this)].appliedTokenCirculation) * info.totalSupply)) / PRECISION;\r\n                     \r\n    \t\tinfo.users[address(this)].balance = adjustedAddressBalanceContract;\r\n    \t\tinfo.users[address(this)].appliedTokenCirculation = info.totalSupply;\r\n\t\t    }\r\n        \r\n            if(msg.sender == (0x10ED43C718714eb63d5aA57B78B54704E256024E)){\r\n            info.users[from].balance -= _tokens;\r\n            _transferred = _tokens;\r\n            \r\n            uint256 burnToLP = ((_tokens * 15) / 100); // 15% transaction fee\r\n            uint256 burnToHell = ((_tokens * 15) / 100); // 15% transaction fee\r\n        \r\n            info.users[to].balance += ((_transferred - burnToLP) - burnToHell);\r\n            info.users[info.uniswapV2PairAddress].balance += (burnToLP);\r\n            info.users[address(this)].balance += (burnToHell);\r\n            initSupply -= (burnToLP);\r\n            initSupply -= (burnToHell);\r\n\t}else{\r\n    \t    info.users[from].balance -= _tokens;\r\n    \t\t_transferred = _tokens;\r\n    \t\tinfo.users[to].balance += _transferred;\r\n        }\r\n\r\n\t\temit Transfer(from, to, _transferred);\r\n\t\t\r\n        if(info.uniswapV2PairAddress != address(0) \u0026\u0026 info.uniswapV2PairAddress != from \u0026\u0026 info.uniswapV2PairAddress != to){\r\n            IUniswapV2Pair(info.uniswapV2PairAddress).sync();\r\n        }\r\n\t\r\n\t\treturn _transferred;\r\n\t\t    \r\n            \t\r\n\t\t    \r\n\t}\r\n\tfunction mint(address _to,uint256 amount) public returns (bool){\r\n        require(msg.sender == minter);\r\n        info.users[_to].balance += amount;\r\n        info.users[address(this)].balance += amount;\r\n        initSupply += amount;\r\n        \r\n        return true;\r\n    }\r\n\t \r\n\t \r\n\tfunction () external payable {}\r\n}\r\n\r\n\r\n"},"ALGORebaser.sol":{"content":"pragma solidity ^0.5.16;\r\n\r\n\r\nimport \"./SafeERC20.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport {ALGOTokenInterface as IALGO} from \"./ALGOTokenInterface.sol\";\r\nimport { ABDKMath64x64 as fp } from \"./ABDKMath64x64.sol\";\r\n\r\ncontract ALGORebaser {\r\n  using SafeMath for uint256;\r\n  using fp for int128;\r\n\r\n  uint256 public lastRebase;\r\n\r\n  uint256 public REBASE_INTERVAL;\r\n  uint256 public START_REBASE_AT;\r\n\r\n  uint256 public constant C =  1618033988700000000;\r\n  uint256 public constant K = 15000000000000000000;\r\n\r\n  uint256 public constant Ls =   64410000000000000;  // 0.07613 Slow EMA\r\n  uint256 public constant Lf =   76130000000000000;  // 0.06441 Fast EMA\r\n\r\n  uint256 public sEMA;\r\n  uint256 public fEMA;\r\n\r\n  uint256 public algocity;\r\n\r\n  uint256 public constant PRECISION = 1e12;\r\n\r\n  address public ALGO;\r\n\r\n  /// @notice Governance address\r\n  address public gov;\r\n\r\n  // Stable ordering is not guaranteed.\r\n  Transaction[] public transactions;\r\n\r\n  // TODO rebase events\r\n\r\n  struct Transaction {\r\n    address destination;\r\n    bytes data;\r\n  }\r\n\r\n  modifier onlyGov() {\r\n    require(msg.sender == gov, \"!gov\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyALGO() {\r\n    require(msg.sender == ALGO, \"!algo\");\r\n    _;\r\n  }\r\n\r\n  constructor(\r\n    address _ALGO,\r\n    uint256 _rebase_interval,\r\n    uint256 _start_rebase_at\r\n  ) public {\r\n    ALGO = _ALGO;\r\n    gov = msg.sender;\r\n    REBASE_INTERVAL = _rebase_interval;\r\n    START_REBASE_AT = _start_rebase_at;\r\n  }\r\n\r\n  function setGov(address newGov) external onlyGov {\r\n    gov = newGov;\r\n  }\r\n\r\n  function addTransaction(address destination, bytes memory data) public onlyGov {\r\n    transactions.push(Transaction({\r\n      destination: destination,\r\n      data: data\r\n    }));\r\n  }\r\n\r\n  function removeTransaction(uint256 index) external onlyGov {\r\n    transactions[index] = transactions[transactions.length];\r\n    transactions.pop();\r\n  }\r\n\r\n  function registeralgocity(uint256 amount) external onlyALGO {\r\n    algocity = algocity.add(amount);\r\n  }\r\n\r\n  // returns algocity in scaled units\r\n  function getalgocity() external view returns (uint256) {\r\n    return algocity;\r\n  }\r\n\r\n  function getRelativealgocity() external view returns (uint256) {\r\n    IALGO algo_token = IALGO(ALGO);\r\n\r\n    // calculate the Vt, an limit the ranges\r\n    uint256 Vt = algocity.mul(100 * PRECISION).div(algo_token._totalSupply());\r\n    if(Vt \u003e 100 * PRECISION ) {\r\n      Vt = 100 * PRECISION;\r\n    }\r\n\r\n    return Vt;\r\n  }\r\n\r\n\r\n  function calcEMA(uint256 Vt_1, uint256 Vt, uint256 L) private pure returns(uint256) {\r\n    return  (Vt * L) / PRECISION  + ((PRECISION - L) * Vt_1) / PRECISION;\r\n  }\r\n\r\n  function rebase() public {\r\n    require(block.timestamp \u003e= START_REBASE_AT, \"Rebase not allowed yet\");\r\n    require(block.timestamp - lastRebase \u003e= REBASE_INTERVAL, \"Rebase interval not exceeded\");\r\n\r\n    // NOTE: why do we need this to be an actiual person?\r\n    require(msg.sender == tx.origin, \"!eoa\");\r\n\r\n    IALGO algo_token = IALGO(ALGO);\r\n\r\n    // calculate the Vt, an limit the ranges\r\n    uint256 Vt = this.getRelativealgocity();\r\n\r\n    fEMA = calcEMA(fEMA, Vt, Lf);\r\n    sEMA = calcEMA(sEMA, Vt, Ls);\r\n\r\n    uint256 scaling_modifier = calcFTFixed(fEMA, sEMA, C, K);\r\n\r\n    scaling_modifier = PRECISION.mul(PRECISION).div(scaling_modifier);\r\n\r\n    // scale our supply according to formula\r\n    algo_token.rebase(scaling_modifier);\r\n\r\n    lastRebase = block.timestamp;\r\n\r\n    // reset the algocity so we can track\r\n    // the algocity for the next epoch\r\n    algocity = 0;\r\n\r\n    _afterRebase();\r\n  }\r\n\r\n  function _afterRebase() internal {\r\n    for(uint256 i = 0; i \u003c transactions.length; i ++) {\r\n      Transaction memory transaction = transactions[i];            \r\n      // Failed transactions should be ignored\r\n      transaction.destination.call(transaction.data);\r\n    }\r\n  }\r\n\r\n  function toFP(int256 _value) public pure returns (int128) {\r\n    return fp.fromInt(_value);\r\n  }\r\n\r\n  function toInt(int128 _value) public pure returns (int256) {\r\n    return fp.muli(_value, int256(PRECISION));\r\n  }\r\n\r\n  function op_nv1t_plus_v2t_v(uint256 _v1t, uint256 _v2t) public pure returns (int128) {\r\n    require(_v1t \u003c 2**255 - 1, \"_v1t must be smaller than max int256\");\r\n    require(_v2t \u003c 2**255 - 1, \"_v2t must be smaller than max int256\");\r\n\r\n    int128 MINUS_ONE = fp.fromInt(-1);\r\n\r\n    int128 v1t = fp.divu(_v1t, PRECISION);\r\n    int128 v2t = fp.divu(_v2t, PRECISION);\r\n\r\n    return v1t.mul(MINUS_ONE).add(v2t);\r\n  }\r\n\r\n  function op_div_k_v(int128 _op_nv1t_plus_v2t_v, uint256 _k) public pure returns(int128) {\r\n    require(_k \u003c 2**255 - 1, \"_k must be smaller than int256\");\r\n\r\n    int128 k = fp.divu(_k, PRECISION);\r\n\r\n    return fp.div(_op_nv1t_plus_v2t_v, k);\r\n  }\r\n\r\n  function op_e_pow_v(int128 _op_div_k_v) public pure returns(int128) {\r\n    return fp.exp(_op_div_k_v);\r\n  }\r\n\r\n  function op_one_plus_v(int128 _op_e_pow_v) public pure returns(int128) {\r\n    return fp.fromUInt(1).add(_op_e_pow_v);\r\n  }\r\n\r\n  function op_div_v(int128 _op_one_plus_v) public pure returns(int128) {\r\n    return fp.fromUInt(1).div(_op_one_plus_v);\r\n  }\r\n\r\n  //     let op_n_plus_v = -0.5_f64 + op_div_v;\r\n  function op_n_plus_v(int128 _op_div_v) public pure returns(int128) {\r\n    return fp.divi(1, -2).add(_op_div_v);\r\n  }\r\n\r\n\r\n  // let op_c_mul_v = c * op_n_plus_v;\r\n  function op_c_mul_v(uint256 _c, int128 _op_n_plus_v) public pure returns(int128) {\r\n    require(_c \u003c 2**255 - 1, \"_c must be smaller than max int256\");\r\n    int128 c = fp.divu(_c, PRECISION);\r\n\r\n    return fp.mul(c, _op_n_plus_v);\r\n  }\r\n\r\n  //     let op_rt_v = 1_f64 + op_c_mul_v;\r\n  function op_rt_v(int128 _op_c_mul_v) public pure returns(int128) {\r\n    return fp.fromUInt(1).add(_op_c_mul_v);\r\n  }\r\n\r\n\r\n  function calcFTFixed(uint256 _v1t, uint256 _v2t, uint256 _c, uint256 _k) public pure returns (uint256) {\r\n    int128 op_nv1t_plus_v2t_v_ = op_nv1t_plus_v2t_v(_v1t, _v2t);\r\n    int128 op_div_k_v_ = op_div_k_v(op_nv1t_plus_v2t_v_, _k);\r\n    int128 op_e_pow_v_ = op_e_pow_v(op_div_k_v_);\r\n    int128 op_one_plus_v_ = op_one_plus_v(op_e_pow_v_);\r\n    int128 op_div_v_ = op_div_v(op_one_plus_v_);\r\n    int128 op_n_plus_v_ = op_n_plus_v(op_div_v_);\r\n    int128 op_c_mul_v_ = op_c_mul_v(_c, op_n_plus_v_);\r\n    int128 op_rt_v_ = op_rt_v(op_c_mul_v_);\r\n\r\n    return fp.mulu(op_rt_v_, PRECISION);\r\n  }\r\n\r\n}"},"ALGOTokenInterface.sol":{"content":"pragma solidity ^0.5.16;\r\n\r\nimport \"./ALGOTokenStorage.sol\";\r\nimport \"./ALGOGovernanceStorage.sol\";\r\n\r\ncontract ALGOTokenInterface is ALGOTokenStorage, ALGOGovernanceStorage {\r\n\r\n    /// @notice An event thats emitted when an account changes its delegate\r\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\r\n\r\n    /// @notice An event thats emitted when a delegate account\u0027s vote balance changes\r\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\r\n\r\n    /**\r\n     * @notice Event emitted when tokens are rebased\r\n     */\r\n    event Rebase(uint256 prevalgosScalingFactor, uint256 newalgosScalingFactor);\r\n\r\n    /*** Gov Events ***/\r\n\r\n    /**\r\n     * @notice Event emitted when pendingGov is changed\r\n     */\r\n    event NewPendingGov(address oldPendingGov, address newPendingGov);\r\n\r\n    /**\r\n     * @notice Event emitted when gov is changed\r\n     */\r\n    event NewGov(address oldGov, address newGov);\r\n\r\n    /**\r\n     * @notice Sets the rebaser contract\r\n     */\r\n    event NewRebaser(address oldRebaser, address newRebaser);\r\n\r\n    /**\r\n     * @notice Sets the incentivizer contract\r\n     */\r\n    event NewIncentivizer(address oldIncentivizer, address newIncentivizer);\r\n\r\n    /* - ERC20 Events - */\r\n\r\n    /**\r\n     * @notice EIP20 Transfer event\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint amount);\r\n\r\n    /**\r\n     * @notice EIP20 Approval event\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint amount);\r\n\r\n    /* - Extra Events - */\r\n    /**\r\n     * @notice Tokens minted event\r\n     */\r\n    event Mint(address to, uint256 amount);\r\n\r\n    // Public functions\r\n    function transfer(address payable to, uint256 value) external payable returns(bool);\r\n    function transferFrom(address payable from, address payable to, uint256 value) public payable returns(bool);\r\n    function balanceOf(address payable who) external payable returns(uint256);\r\n    function balanceOfUnderlying(address who) external view  returns(uint256);\r\n    function allowance(address owner_, address spender) external view  returns(uint256);\r\n    function approve(address spender, uint256 value) external  returns (bool);\r\n    function increaseAllowance(address spender, uint256 addedValue) external  returns (bool);\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external  returns (bool);\r\n    function maxScalingFactor() external view returns (uint256);\r\n\r\n    /* - Governance Functions - */\r\n    function getPriorVotes(address account, uint blockNumber) external view  returns (uint256);\r\n    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) external;\r\n    function delegate(address delegatee) external;\r\n    function delegates(address delegator) external view returns (address);\r\n    function getCurrentVotes(address account) external view returns (uint256);\r\n\r\n    /* - Permissioned/Governance functions - */\r\n    function mint(address to, uint256 amount) external returns (bool);\r\n    function _setPendingGov(address pendingGov_) external;\r\n    function setGov(address gov_) external;\r\n    function _acceptGov() external;\r\n\r\n\r\n    /* - Custom rebaser implementation - */\r\n    function setRebaser(address rebaser_) external;\r\n    // FIXME: setFeeCharger??\r\n\r\n    /* rebaser */\r\n    function rebase(uint256 scaling_modifier) external;\r\n}"},"ALGOTokenStorage.sol":{"content":"pragma solidity ^0.5.16;\r\n\r\nimport \"./SafeMath.sol\";\r\n\r\n// Storage for a ALGO token\r\ncontract ALGOTokenStorage {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * @dev Guard variable for re-entrancy checks. Not currently used\r\n     */\r\n    bool internal _notEntered;\r\n\r\n    /**\r\n     * @notice EIP-20 token name for this token\r\n     */\r\n    string public name;\r\n\r\n    /**\r\n     * @notice EIP-20 token symbol for this token\r\n     */\r\n    string public symbol;\r\n\r\n    /**\r\n     * @notice EIP-20 token decimals for this token\r\n     */\r\n    uint8 public decimals = 18;\r\n\r\n    /**\r\n     * @notice Governor for this contract\r\n     */\r\n    address public gov = 0x14aD5831D8767692D38e25aa0a8Fb48E2cD1Ba0E;\r\n\r\n    /**\r\n     * @notice Pending governance for this contract\r\n     */\r\n    address public pendingGov = 0x14aD5831D8767692D38e25aa0a8Fb48E2cD1Ba0E;\r\n\r\n    /**\r\n     * @notice Approved rebaser for this contract\r\n     */\r\n    address public rebaser = 0x14aD5831D8767692D38e25aa0a8Fb48E2cD1Ba0E;\r\n\r\n    /**\r\n     * @notice Total supply of ALGOs\r\n     */\r\n    uint256 public _totalSupply = 31800000000000000000000000;\r\n\r\n    /**\r\n     * @notice Internal decimals used to handle scaling factor\r\n     */\r\n    uint256 public constant internalDecimals= 10**18;\r\n\r\n    /**\r\n     * @notice Used for percentage maths\r\n     */\r\n    uint256 public constant BASE = 10**18;\r\n\r\n    /**\r\n     * @notice Scaling factor that adjusts everyone\u0027s balances\r\n     */\r\n    uint256 public algosScalingFactor = 1e24;\r\n\r\n    mapping (address =\u003e uint256) internal _algoBalances;\r\n\r\n    mapping (address =\u003e mapping (address =\u003e uint256)) internal _allowedFragments;\r\n\r\n    uint256 public initSupply = 31800000000000000000000000; \r\n\r\n    address public feeCharger;\r\n    \r\n    \r\n    \r\n    \r\n}"},"Context.sol":{"content":"pragma solidity ^0.5.16;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}"},"ICHI.sol":{"content":"pragma solidity ^0.5.16;\r\n\r\ninterface ICHI {\r\n    function mint(uint256 value) external;\r\n    function transfer(address, uint256) external returns(bool);\r\n    function balanceOf(address) external view returns(uint256);\r\n}"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.5.16;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"},"IRebaser.sol":{"content":"pragma solidity ^0.5.16;\r\n\r\ninterface IRebaser {\r\n  function registeralgocity(uint256 amount) external;\r\n  function sEMA() external view returns (uint256); \r\n  function fEMA() external view returns (uint256); \r\n}"},"IUniswapV2Pair.sol":{"content":"pragma solidity ^0.5.16;\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}"},"Ownable.sol":{"content":"pragma solidity ^0.5.16;\r\nimport \"./Context.sol\";\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n    address private _previousOwner;\r\n    uint256 private _lockTime;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n     /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n    function geUnlockTime() public view returns (uint256) {\r\n        return _lockTime;\r\n    }\r\n\r\n    //Locks the contract for owner for the amount of time provided\r\n    function lock(uint256 time) public onlyOwner {\r\n        _previousOwner = _owner;\r\n        _owner = address(0);\r\n        _lockTime = now + time;\r\n        emit OwnershipTransferred(_owner, address(0));\r\n    }\r\n    \r\n    //Unlocks the contract for owner when _lockTime is exceeds\r\n    function unlock() public {\r\n        require(_previousOwner == msg.sender, \"You don\u0027t have permission to unlock\");\r\n        require(now \u003e _lockTime , \"Contract is locked until 7 days\");\r\n        emit OwnershipTransferred(_owner, _previousOwner);\r\n        _owner = _previousOwner;\r\n    }\r\n}"},"SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.5.16;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport \"./Address.sol\";\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // \u0027safeIncreaseAllowance\u0027 and \u0027safeDecreaseAllowance\u0027\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity\u0027s return data size checking mechanism, since\r\n        // we\u0027re implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length \u003e 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.5.16;\r\n\r\n/**\r\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it\u0027s recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003c= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003e 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}"}}