{"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.19;\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n"},"index.sol":{"content":"//@dev SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.19;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./Ownable.sol\";\r\n\r\ncontract Nine2Five is Context, Ownable {\r\n    uint256 public constant min = 30 ether;\r\n    uint256 public constant max = 100000 ether;\r\n\r\n    uint256 public tot_taken = 0;\r\n    uint256 revenue = 0;\r\n    uint256 divisor = 2;\r\n\r\n    //@devroi is 2% each 8 hours but only from Mon to Fri 9am-5pm\r\n    uint256 roi = 20;\r\n    uint256 public n_users = 0;\r\n    uint256 public ref_fee = 4;\r\n\r\n    address public teamwallet;\r\n    address public multisig;\r\n    address public mkt;\r\n\r\n    IERC20 private BusdInterface;\r\n    address public tokenAdress;\r\n    bool private firstwithdraw;\r\n\r\n    uint256 public lastwithdraw;\r\n\r\n    uint256 MONDAY_START = 1683504000;  //@devthis is used to calculate each day of the week, always change this value to any Monday 0.00\r\n    uint256 PLATFORM_START = 1683536400; //@devdate of launch Mon May 8 9 am UTC\r\n    uint256 private constant SECONDS_IN_DAY = 86400;\r\n    uint256 private constant SECONDS_IN_HOUR = 3600;\r\n    uint256 private constant ELIGIBLE_MINUTES_PER_DAY = 480;\r\n\r\n    //bonuses\r\n    uint256 WORK_PERC = 3;\r\n    uint256 COMP_PERC = 5;\r\n\r\n\r\n    //@devteam fees\r\n    struct WalletInfo {\r\n        address wallet;\r\n        uint256 percentage;\r\n    }\r\n\r\n    struct refferal_system {\r\n        address ref_address;\r\n        uint256 reward;\r\n    }\r\n\r\n    struct user_investment_details {\r\n        address user_address;\r\n        uint256 invested;\r\n        uint256 ROI;\r\n        bool hasinvested;\r\n    }\r\n\r\n    struct claimDaily {\r\n        address user_address;\r\n        uint256 startTime;\r\n        uint256 deadline;\r\n    }\r\n\r\n    struct userTotalWithdraw {\r\n        address user_address;\r\n        uint256 amount;\r\n    }\r\n\r\n    mapping(address =\u003e refferal_system) public refferal;\r\n    mapping(address =\u003e user_investment_details) public investments;\r\n    mapping(address =\u003e claimDaily) public claimTime;\r\n    mapping(address =\u003e userTotalWithdraw) public totalWithdraw;\r\n\r\n    WalletInfo[] public wallets;\r\n\r\n    event Deposit(address indexed user, address indexed ref, uint256 amount);\r\n    event Compound(address indexed user, uint256 amount);\r\n    event Workhard(address indexed user, uint256 amount);\r\n    event Ownerwithdraw(address indexed user, uint256 amount);\r\n\r\n    constructor(address _teamwallet, address _mkt, address _dev) {\r\n        teamwallet = _teamwallet;\r\n        multisig = teamwallet;\r\n        wallets.push(WalletInfo({wallet: _teamwallet, percentage: 400}));\r\n        wallets.push(WalletInfo({wallet: _mkt, percentage:50}));\r\n        wallets.push(WalletInfo({wallet: _mkt, percentage: 60}));\r\n        wallets.push(WalletInfo({wallet: _mkt, percentage: 100}));\r\n        wallets.push(WalletInfo({wallet: _mkt, percentage: 125}));\r\n        wallets.push(WalletInfo({wallet: _mkt, percentage: 50}));\r\n        wallets.push(WalletInfo({wallet: _mkt, percentage:65}));\r\n        wallets.push(WalletInfo({wallet: _dev, percentage: 150}));\r\n\r\n        //tokenAdress = 0x25C7c87B42ec086b01528eE72465F1e3c49B7B9D; //@devtestnet\r\n        tokenAdress = 0x55d398326f99059fF775485246999027B3197955; //@devmainnet\r\n        BusdInterface = IERC20(tokenAdress);\r\n    }\r\n\r\n    //@dev invest function\r\n    function deposit(address _ref, uint256 _amount) public {\r\n        require(PLATFORM_START \u003c= block.timestamp \u0026\u0026 !isContract(msg.sender));\r\n        require(_amount \u003e= min \u0026\u0026 _amount \u003c= max, \"Cannot Deposit\");\r\n        uint256 userLastInvestment = investments[msg.sender].invested;\r\n\r\n        //@dev claim before reinvesting\r\n        if (userLastInvestment != 0) {\r\n            Claim(msg.sender);\r\n        } else {\r\n            n_users++;\r\n        }\r\n\r\n        //@dev setup new claiming time\r\n        UpdateTime(msg.sender);\r\n        uint256 total_contract = _amount;\r\n        BusdInterface.transferFrom(msg.sender, address(this), total_contract);\r\n        uint256 total_fee = distributeFees(_amount);\r\n\r\n        //@dev Adjust the contract\u0027s balance after fee distribution\r\n        total_contract -= total_fee;\r\n\r\n        uint256 ref_fee_add = refFee(_amount);\r\n        if (_ref != address(0) \u0026\u0026 _ref != msg.sender) {\r\n            uint256 ref_last_balance = refferal[_ref].reward;\r\n            uint256 totalRefFee = ref_fee_add + ref_last_balance;\r\n            refferal[_ref] = refferal_system(_ref, totalRefFee);\r\n        }\r\n\r\n        uint256 userCurrentInvestment = _amount - total_fee;\r\n        uint256 totalInvestment = userLastInvestment + userCurrentInvestment;\r\n        investments[msg.sender] = user_investment_details(\r\n            msg.sender,\r\n            totalInvestment,\r\n            roi,\r\n            true\r\n        );\r\n\r\n        emit Deposit(msg.sender, _ref, _amount);\r\n    }\r\n\r\n    function UpdateTime(address _user) internal {\r\n        uint256 claimTimeStart = block.timestamp;\r\n        uint256 claimTimeEnd = block.timestamp + 7 days;\r\n        claimTime[_user] = claimDaily(_user, claimTimeStart, claimTimeEnd);\r\n    }\r\n\r\n    function compound() public {\r\n        require(PLATFORM_START \u003c= block.timestamp);\r\n        require(investments[msg.sender].hasinvested == true);\r\n        require(\r\n            claimTime[msg.sender].deadline - 5 days \u003c= block.timestamp,\r\n            \"You cant compound before 48 hours\"\r\n        );\r\n\r\n        uint256 aval_withdraw = userReward(msg.sender);\r\n        UpdateTime(msg.sender);\r\n\r\n        //@dev investment details\r\n        uint256 userLastInvestment = investments[msg.sender].invested;\r\n        uint256 userCurrentInvestment = aval_withdraw;\r\n        uint256 totalInvestment = userLastInvestment + userCurrentInvestment;\r\n        investments[msg.sender] = user_investment_details(\r\n            msg.sender,\r\n            totalInvestment,\r\n            roi + COMP_PERC,\r\n            true\r\n        );\r\n\r\n        emit Compound(msg.sender, aval_withdraw);\r\n    }\r\n\r\n    function workharder() public {\r\n        require(PLATFORM_START \u003c= block.timestamp);\r\n        require(investments[msg.sender].hasinvested == true);\r\n        require(\r\n            claimTime[msg.sender].deadline - 3 days \u003c= block.timestamp,\r\n            \"You cant compound before 24 hours\"\r\n        );\r\n\r\n        uint256 half_amount = userReward(msg.sender) / 2;\r\n        UpdateTime(msg.sender);\r\n\r\n        //@dev investment details\r\n        uint256 userLastInvestment = investments[msg.sender].invested;\r\n        uint256 userCurrentInvestment = half_amount;\r\n        uint256 totalInvestment = userLastInvestment + userCurrentInvestment;\r\n\r\n        //@dev roi is set to roi + .3%\r\n        investments[msg.sender] = user_investment_details(\r\n            msg.sender,\r\n            totalInvestment,\r\n            roi + WORK_PERC,\r\n            true\r\n        );\r\n\r\n        BusdInterface.transfer(msg.sender, half_amount);\r\n        emit Workhard(msg.sender, half_amount);\r\n    }\r\n\r\n    function claimDailyRewards() public {\r\n        require(PLATFORM_START \u003c= block.timestamp);\r\n        require(\r\n            investments[msg.sender].hasinvested == true \u0026\u0026\r\n                totalWithdraw[msg.sender].amount \u003c=\r\n                investments[msg.sender].invested * 3\r\n        );\r\n        //@dev Users can claim only after 1 day\r\n        require(\r\n            claimTime[msg.sender].deadline - 6 days \u003c= block.timestamp,\r\n            \"You cant claim before 24 hours\"\r\n        );\r\n        Claim(msg.sender);\r\n    }\r\n\r\n    //@dev claim internal so Deposit can claim before redepositing\r\n    function Claim(address _user) internal {\r\n        uint256 rewards = userReward(_user);\r\n        uint256 untilnow = totalWithdraw[_user].amount + rewards;\r\n        totalWithdraw[_user] = userTotalWithdraw(_user, untilnow);\r\n        uint256 claimTimeStart = block.timestamp;\r\n        uint256 claimTimeEnd = claimTimeStart + 7 days;\r\n        claimTime[_user] = claimDaily(_user, claimTimeStart, claimTimeEnd);\r\n        investments[_user].ROI = 20;\r\n        BusdInterface.transfer(_user, rewards);\r\n    }\r\n\r\n    function Ref_Withdraw() external {\r\n        require(PLATFORM_START \u003c= block.timestamp);\r\n        require(\r\n            investments[msg.sender].hasinvested == true \u0026\u0026\r\n                totalWithdraw[msg.sender].amount \u003c=\r\n                investments[msg.sender].invested * 3\r\n        );\r\n\r\n        uint256 value = refferal[msg.sender].reward;\r\n        uint256 untilnow = totalWithdraw[msg.sender].amount + value;\r\n        //@devref count in the x3 invest limit\r\n        totalWithdraw[msg.sender] = userTotalWithdraw(msg.sender, untilnow);\r\n        //@devtax 30% for withdrawals from refs\r\n        BusdInterface.transfer(msg.sender, (value / 100) * 70);\r\n        refferal[msg.sender] = refferal_system(msg.sender, 0);\r\n    }\r\n\r\n    function Ref_Compound() external {\r\n        require(PLATFORM_START \u003c= block.timestamp);\r\n        require(investments[msg.sender].hasinvested == true);\r\n        uint256 value = refferal[msg.sender].reward;\r\n        refferal[msg.sender] = refferal_system(msg.sender, 0);\r\n\r\n        uint256 userLastInvestment = investments[msg.sender].invested;\r\n        uint256 totalInvestment = userLastInvestment + value;\r\n        investments[msg.sender] = user_investment_details(\r\n            msg.sender,\r\n            totalInvestment,\r\n            roi,\r\n            true\r\n        );\r\n    }\r\n\r\n    //@devRewards functions to accumulate only during specific hours\r\n    function userReward(address _userAddress) public view returns (uint256) {\r\n        uint256 userInvestment = investments[_userAddress].invested;\r\n        //@devuser roi is mul by 5 working days\r\n        uint256 userweeklyroi = investments[_userAddress].ROI * 5;\r\n        //@dev 2% of the user\u0027s investment during eligible hours and days, 2% daily ROI is 10% from Monday to friday\r\n        // div100 is used to get the %, div10 accounts for the extra digit in ROI == /1000\r\n        uint256 userWeeklyReturn = ((userInvestment * userweeklyroi) / 1000);\r\n\r\n        uint256 claimStartTime = claimTime[_userAddress].startTime;\r\n        uint256 claimDeadline = claimTime[_userAddress].deadline;\r\n\r\n        uint256 currentTime = block.timestamp;\r\n        uint256 totalEligibleMinutesInWeek = 5 * (17 - 9) * 60; //@dev 5 days * 8 hours * 60 minutes\r\n\r\n        //@dev If the current time is before the claim start time, the user has no rewards yet\r\n        if (currentTime \u003c claimStartTime) {\r\n            return 0;\r\n        } else if (currentTime \u003e claimDeadline) {\r\n            return userWeeklyReturn; //@dev this excludes non working day which is why weekly roi is mul by 5 and not 7\r\n        } else {\r\n            uint256 effectiveClaimEndTime = currentTime \u003c claimDeadline\r\n                ? currentTime\r\n                : claimDeadline;\r\n            uint256 userEligibleMinutes = countEligibleMinutes(\r\n                claimStartTime,\r\n                effectiveClaimEndTime\r\n            );\r\n            uint256 userRewards = (userWeeklyReturn * userEligibleMinutes) /\r\n                totalEligibleMinutesInWeek;\r\n            return userRewards;\r\n        }\r\n    }\r\n\r\n    function countEligibleMinutes(\r\n        uint256 startTimestamp,\r\n        uint256 endTimestamp\r\n    ) public view returns (uint256) {\r\n        uint256 eligibleMinutes = 0;\r\n\r\n        uint256 startDay = (startTimestamp - MONDAY_START) / SECONDS_IN_DAY;\r\n        uint256 endDay = (endTimestamp - MONDAY_START) / SECONDS_IN_DAY;\r\n\r\n        for (uint256 day = startDay; day \u003c= endDay; day++) {\r\n            uint256 dayStartTimestamp = MONDAY_START + day * SECONDS_IN_DAY;\r\n\r\n            uint256 dayEligibleStart = dayStartTimestamp + 9 * 3600; //@dev 9 AM\r\n            uint256 dayEligibleEnd = dayStartTimestamp + 17 * 3600; //@dev 5 PM\r\n\r\n            if (startTimestamp \u003e dayEligibleStart) {\r\n                dayEligibleStart = startTimestamp;\r\n            }\r\n\r\n            if (endTimestamp \u003c dayEligibleEnd) {\r\n                dayEligibleEnd = endTimestamp;\r\n            }\r\n\r\n            if (\r\n                isEligibleTime(dayEligibleStart) \u0026\u0026\r\n                dayEligibleEnd \u003e dayEligibleStart\r\n            ) {\r\n                eligibleMinutes += (dayEligibleEnd - dayEligibleStart) / 60;\r\n            }\r\n        }\r\n\r\n        return eligibleMinutes;\r\n    }\r\n\r\n    function isEligibleTime(uint256 timestamp) public view returns (bool) {\r\n        uint256 daysSinceFirstMonday = (timestamp - MONDAY_START) /\r\n            SECONDS_IN_DAY;\r\n        uint256 dayOfWeek = (daysSinceFirstMonday % 7) + 1;\r\n\r\n        //@dev Check if the current day is between Monday (1) and Friday (5)\r\n        if (dayOfWeek \u003e= 1 \u0026\u0026 dayOfWeek \u003c= 5) {\r\n            uint256 secondsIntoDay = timestamp % SECONDS_IN_DAY;\r\n            uint256 minutesIntoDay = secondsIntoDay / 60;\r\n            uint256 hourOfDay = minutesIntoDay / 60;\r\n\r\n            //@dev Check if the current hour is between 9 and 17 (5 PM)\r\n            return hourOfDay \u003e= 9 \u0026\u0026 hourOfDay \u003c 17;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function Teamwithdraw(address _tosend) external {\r\n        require(msg.sender == multisig, \"sender must be multisig\");\r\n        uint256 _current = BusdInterface.balanceOf(address(this));\r\n        uint256 _towithdraw;\r\n        if (firstwithdraw == false) {\r\n            _towithdraw = (_current * 70) / 100;\r\n            firstwithdraw = true;\r\n            lastwithdraw = block.timestamp;\r\n        } else {\r\n            require(block.timestamp \u003e= lastwithdraw + 7 days);\r\n            _towithdraw = _current / divisor;\r\n        }\r\n        BusdInterface.transfer(_tosend, _towithdraw);\r\n        tot_taken += _towithdraw;\r\n        emit Ownerwithdraw(multisig, _towithdraw);\r\n    }\r\n\r\n    //@devuseful to dispaly balance without accounting for withdrawals and revenues\r\n    function depositrevenue(uint256 amount) external {\r\n        require(msg.sender == wallets[0].wallet, \"sender must be team\");\r\n        BusdInterface.transferFrom(msg.sender, address(this), amount);\r\n        revenue += amount;\r\n        //@devtot taken cannot be negative\r\n        if (amount \u003c tot_taken) {\r\n            tot_taken -= amount;\r\n        } else {\r\n            tot_taken = 0;\r\n        }\r\n    }\r\n\r\n    function changeComp_Work(uint256 _comp , uint256 _work) external {\r\n        require(msg.sender == wallets[0].wallet, \"sender must be team\");\r\n        require(_comp \u003c= 10 \u0026\u0026 _work \u003c= 10, \"max is 1%\");\r\n        WORK_PERC = _work;\r\n        COMP_PERC = _comp;\r\n    }\r\n\r\n    function change_reffees(uint256 _fee) external {\r\n        require(msg.sender == wallets[0].wallet, \"sender must be team\");\r\n        require(_fee \u003c= 5, \"max is 5%\");\r\n        ref_fee = _fee;\r\n    }\r\n\r\n    function changeMulti(address _multisig) external {\r\n        require(msg.sender == multisig, \"sender must be multisig\");\r\n        multisig = _multisig;\r\n    }\r\n\r\n    \r\n\r\n    //@dev Update wallet addresses\r\n    function updateWalletAddresses(\r\n        address newTeamWallet,\r\n        address newMkt,\r\n        address newMkt2,\r\n        address newMkt3,\r\n        address newMkt4,\r\n        address newMkt5,\r\n        address newMkt6\r\n    ) external {\r\n        require(\r\n            msg.sender == wallets[0].wallet,\r\n            \"Caller needs to be teamwallet\"\r\n        );\r\n\r\n        wallets[0].wallet = newTeamWallet;\r\n        wallets[1].wallet = newMkt;\r\n        wallets[2].wallet = newMkt2;\r\n        wallets[3].wallet = newMkt3;\r\n        wallets[4].wallet = newMkt4;\r\n        wallets[5].wallet = newMkt5;\r\n        wallets[6].wallet = newMkt6;\r\n    }\r\n\r\n    //@dev Update wallet addresses\r\n    function updateWDev(\r\n        address newDev\r\n    ) external {\r\n        require(\r\n            msg.sender == wallets[7].wallet,\r\n            \"Caller needs to be teamwallet\"\r\n        );\r\n\r\n        wallets[7].wallet = newDev;\r\n    }\r\n\r\n    //@dev Update wallet percentages\r\n    function updateWalletPercentages(\r\n        uint256 newTeamWalletPercentage,\r\n        uint256 newMktPercentage,\r\n        uint256 newMkt2Percentage,\r\n        uint256 newMkt3Percentage,\r\n        uint256 newMkt4Percentage,\r\n        uint256 newMkt5Percentage,\r\n        uint256 newMkt6Percentage\r\n    ) external {\r\n        require(\r\n            msg.sender == wallets[0].wallet,\r\n            \"Caller needs to be teamwallet\"\r\n        );\r\n\r\n        uint256 currentTotalPercentage = getCurrentTotalPercentage();\r\n        uint256 newTotalPercentage = newTeamWalletPercentage +\r\n            newMktPercentage +\r\n            newMkt2Percentage +\r\n            newMkt3Percentage +\r\n            newMkt4Percentage +\r\n            newMkt5Percentage +\r\n            newMkt6Percentage;\r\n\r\n        require(\r\n            newTotalPercentage == currentTotalPercentage,\r\n            \"Total percentage cannot exceed the current total percentage\"\r\n        );\r\n\r\n        wallets[0].percentage = newTeamWalletPercentage;\r\n        wallets[1].percentage = newMktPercentage;\r\n        wallets[2].percentage = newMkt2Percentage;\r\n        wallets[3].percentage = newMkt3Percentage;\r\n        wallets[4].percentage = newMkt4Percentage;\r\n        wallets[5].percentage = newMkt5Percentage;\r\n        wallets[6].percentage = newMkt6Percentage;\r\n    }\r\n\r\n    //@dev Function to get the current total percentage\r\n    function getCurrentTotalPercentage() public view returns (uint256) {\r\n        uint256 totalPercentage = 0;\r\n        for (uint256 i = 0; i \u003c wallets.length; i++) {\r\n            totalPercentage += wallets[i].percentage;\r\n        }\r\n        return totalPercentage;\r\n    }\r\n\r\n    //@dev Function to handle fee distribution\r\n    function distributeFees(uint256 _amount) internal returns (uint256) {\r\n        uint256 total_fee = 0;\r\n\r\n        for (uint256 i = 0; i \u003c wallets.length; i++) {\r\n            uint256 wallet_fee = (_amount * wallets[i].percentage) / 10000;\r\n            total_fee += wallet_fee;\r\n            BusdInterface.transfer(wallets[i].wallet, wallet_fee);\r\n        }\r\n\r\n        return total_fee;\r\n    }\r\n\r\n    function changeRoi(uint256 _roi) external {\r\n        require(msg.sender == wallets[0].wallet, \"sender must be teamwallet\");\r\n        require(_roi \u003e= 5 \u0026\u0026 _roi \u003c= 30, \"only 0.5 to 3% daily\");\r\n        roi = _roi;\r\n    }\r\n\r\n    function incrementWeektoCalc(uint256 _weeks) external {\r\n        require(msg.sender == wallets[0].wallet, \"sender must be teamwallet\");\r\n        require(_weeks \u003e 0 \u0026\u0026 _weeks \u003c= 10, \"max 10 weeks allowed\");\r\n        require(MONDAY_START + (7 days * _weeks) \u003c block.timestamp, \"cannot be in the future\");\r\n        MONDAY_START += 7 days * _weeks;\r\n    }\r\n\r\n    function changeDivisor(uint256 _divisor) external {\r\n        require(\r\n            msg.sender == multisig \u0026\u0026 _divisor \u003e= 2,\r\n            \"sender must be multisig\"\r\n        );\r\n        divisor = _divisor;\r\n    }\r\n\r\n    function isContract(address addr) internal view returns (bool) {\r\n        uint size;\r\n        assembly {\r\n            size := extcodesize(addr)\r\n        }\r\n        return size \u003e 0;\r\n    }\r\n\r\n    function Users() public view returns (uint256) {\r\n        return n_users;\r\n    }\r\n\r\n    function checkAlready() public view returns (bool) {\r\n        address _address = msg.sender;\r\n        if (investments[_address].user_address == _address) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function theoffice() public view returns (uint256 _timenow, bool _isopen) {\r\n        uint256 timenow = block.timestamp;\r\n        bool isopen = isEligibleTime(timenow);\r\n        return (timenow, isopen);\r\n    }\r\n\r\n    function refFee(uint256 _amount) public view returns (uint256) {\r\n        return (_amount * ref_fee) / 100;\r\n    }\r\n\r\n    function getBalance() public view returns (uint256) {\r\n        uint256 totbalance = BusdInterface.balanceOf(address(this)) + tot_taken;\r\n        return totbalance;\r\n    }\r\n\r\n\r\n    function getRevenue() public view returns (uint256) {\r\n        return revenue;\r\n    }\r\n\r\n}\r\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n    * @dev Initializes the contract setting the deployer as the initial owner.\r\n    */\r\n    constructor () {\r\n      address msgSender = _msgSender();\r\n      _owner = msgSender;\r\n      emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the address of the current owner.\r\n    */\r\n    function owner() public view returns (address) {\r\n      return _owner;\r\n    }\r\n\r\n    \r\n    modifier onlyOwner() {\r\n      require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n      _;\r\n    }\r\n\r\n    function renounceOwnership() public onlyOwner {\r\n      emit OwnershipTransferred(_owner, address(0));\r\n      _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n      _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal {\r\n      require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n      emit OwnershipTransferred(_owner, newOwner);\r\n      _owner = newOwner;\r\n    }\r\n}\r\n"}}