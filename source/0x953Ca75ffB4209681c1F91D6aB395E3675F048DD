{"Smart_Binance.sol":{"content":"// SPDX-License-Identifier: Unlicensed\npragma solidity \u003e=0.4.22 \u003c0.9.0;\nimport \"./Smart_Binary.sol\";\ncontract Smart_Binance is Context {\n    using SafeERC20 for IERC20; struct Node { uint32 LD; uint32 RD; uint32 TCP; uint256 DP; uint8 CH; uint8 OR; address UPA; address LDA; address RDA; }\n    mapping(address =\u003e Node) private _users;\n    mapping(uint256 =\u003e address) private ALUSA;\n    address private owner;\n    address[] private CNDA;\n    mapping(uint256 =\u003e address) private _DUP;\n    address[] private _PYLst;\n    uint256 private _userId;\n    uint256 private _Chck_AdId;\n    uint256 private _DUPId;\n    uint256 private lstRn;\n    uint256 private lstRnSMG;\n    uint64 private _cnt_SMG_CNDA;\n    uint64 private _cnt_PYLst;\n    uint256 private VL_SMG;\n    uint256[] private _rndNums; \n    uint8 private Lock;\n    uint8 private Count_Old_User;\n    uint8 Check_Gift;\n    IERC20 private S_Coin;\n    string private Note;\n    string private NFT_SITE;\n    Smart_Binary private Nobj;\n    constructor() {owner = _msgSender();\n        lstRn = block.timestamp;\n        S_Coin = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n        Nobj = Smart_Binary(0x3164B3841D2b603ddB43C909C7f6Efd787058541);        }\n    function Reward_12() public {require(Lock == 0, \"Proccesing\");\n            require( _users[_msgSender()].TCP \u003e 0, \"You Dont Have Any Point Today\" );\n            // require( block.timestamp \u003e lstRn + 12 hours, \"Reward_12 Time Has Not Come\" );\n            Lock = 1;\n            uint256 V_Rwd = (PRP() * 90) - (Total_Point() * 10**18); VL_SMG = (PRP() * 10);\n            uint256 V_Pnt = ((V_Rwd)) / Total_Point();\n            uint256 RwdCl = (Total_Point()) * 10**18;\n        for(uint256 i = 0; i \u003c= _userId; i = unsafe_inc(i)) { Node memory TMPNDE = _users[ALUSA[i]];\n            uint32 Pnt; uint32 Result = TMPNDE.LD \u003c= TMPNDE.RD ? TMPNDE.LD : TMPNDE.RD;\n            if (Result \u003e 0) { if (Result \u003e 25) { Pnt = 25;\n            if (TMPNDE.LD \u003c Result) { TMPNDE.LD = 0; TMPNDE.RD -= Result; } \n            else if (TMPNDE.RD \u003c Result) { TMPNDE.LD -= Result; TMPNDE.RD = 0; } \n            else {TMPNDE.LD -= Result; TMPNDE.RD -= Result; } } \n            else {Pnt = Result; \n            if (TMPNDE.LD \u003c Pnt) { TMPNDE.LD = 0; TMPNDE.RD -= Pnt; } \n            else if (TMPNDE.RD \u003c Pnt) { TMPNDE.LD -= Pnt; TMPNDE.RD = 0; } \n            else { TMPNDE.LD -= Pnt; TMPNDE.RD -= Pnt;}} TMPNDE.TCP = 0; _users[ALUSA[i]] = TMPNDE;\n            if ( Pnt * V_Pnt \u003e S_Coin.balanceOf(address(this))) { S_Coin.safeTransfer(ALUSA[i],S_Coin.balanceOf(address(this))); } \n            else { S_Coin.safeTransfer( ALUSA[i], Pnt * V_Pnt);}_PYLst.push(ALUSA[i]);  _cnt_PYLst++;}   } lstRn = block.timestamp;\n            if (RwdCl \u003c= S_Coin.balanceOf(address(this))) { S_Coin.safeTransfer(_msgSender(), RwdCl);}\n            Lock = 0; Check_Gift = 1; lstRnSMG = block.timestamp;}\n    function Register(address upline) public {\n            require( _users[upline].CH != 2,\"Upline Has Two Directs!\" );\n            require( _msgSender() != upline, \"You Can Not Enter Your Address!\");\n            bool TsUs = false;\n        for(uint256 i = 0; i \u003c= _userId; i = unsafe_inc(i)) {\n            if (ALUSA[i] == _msgSender()) { TsUs = true; break; } }\n            require(TsUs == false, \"You Were Registered!\");\n            bool TSUP = false;\n        for(uint256 i = 0; i \u003c= _userId; i = unsafe_inc(i)) {\n            if (ALUSA[i] == upline) { TSUP = true; break;}}\n            require(TSUP == true, \"Upline Is Not Exist!\");\n            S_Coin.safeTransferFrom( _msgSender(), address(this), 100 * 10**18 ); ALUSA[_userId] = _msgSender(); _userId++;\n            uint256 DPCh = _users[upline].DP + 1; _users[_msgSender()] = Node(\n            0, 0, 0, DPCh, 0, _users[upline].CH, upline, address(0), address(0) );\n            if (_users[upline].CH == 0) { _users[upline].LD++; _users[upline].LDA = _msgSender(); } \n            else {_users[upline].RD++; _users[upline].RDA = _msgSender(); } _users[upline].CH++; setTDP(upline);\n            address UPN = _users[upline].UPA;  address ChNde = upline;\n        for( uint256 j = 0; j \u003c _users[upline].DP; j = unsafe_inc(j)) \n            { if (_users[ChNde].OR == 0) { _users[UPN].LD++; } \n            else { _users[UPN].RD++; } setTDP(UPN); ChNde = UPN; UPN = _users[UPN].UPA; } }\n    function Gift_3() public {           \n            require(Check_Gift == 1,\"Gift_3 Time Has Not Come!\" );\n            require( block.timestamp \u003e lstRnSMG + 1 hours, \"Gift_3 Time Has Not Come\" );\n            require(VL_SMG \u003e 20*10**18, \"Gift Balance Is not Enough!\" );\n            require(_cnt_SMG_CNDA \u003e 0, \"There is No Candidate!\" );\n            bool TsUsSMG = false;\n        for(uint256 i = 0; i \u003c= _cnt_SMG_CNDA; i = unsafe_inc(i)) {\n            if (CNDA[i] == _msgSender()) { TsUsSMG = true; break; } }\n            require(TsUsSMG == true, \"You Are Not Candidated!\"); S_Coin.safeTransfer(_msgSender(),10 * 10**18 );\n            uint256 Num_Win = ((VL_SMG - 10*10**18) / 10**18) / 10;\n            if (Num_Win != 0 \u0026\u0026 _cnt_SMG_CNDA != 0) {\n            if (_cnt_SMG_CNDA \u003e Num_Win) {\n        for(uint256 i = 1; i \u003c= _cnt_SMG_CNDA; i = unsafe_inc(i) ) {_rndNums.push(i); }\n        for(uint256 i = 1; i \u003c= Num_Win; i = unsafe_inc(i)) {\n            uint256 randomIndex = uint256(keccak256(abi.encodePacked(block.timestamp, msg.sender, i))) % _cnt_SMG_CNDA;\n            uint256 rsltNumb = _rndNums[randomIndex]; _rndNums[randomIndex] = _rndNums[ _rndNums.length - 1 ]; _rndNums.pop();\n            if(_users[CNDA[rsltNumb - 1]].TCP == 0){ S_Coin.safeTransfer(CNDA[rsltNumb - 1], 10 * 10**18 ); } }\n        for( uint256 i = 0; i \u003c (_cnt_SMG_CNDA - Num_Win); i = unsafe_inc(i)) {_rndNums.pop(); } } \n            else { for ( uint256 i = 0; i \u003c _cnt_SMG_CNDA; i = unsafe_inc(i))\n            { S_Coin.safeTransfer(CNDA[i], 10 * 10**18 );}}} delete CNDA; _cnt_SMG_CNDA = 0;\n             VL_SMG = 0; Check_Gift = 0; delete _PYLst; _cnt_PYLst=0;}\n    function Smart_Gift() public { require(Check_Gift == 1,\"Smart_Gift Time Has Not Come!\" );\n            bool TsUsPY = false;\n            for(uint256 i = 0; i \u003c= _cnt_PYLst; i = unsafe_inc(i)) {\n                if (_PYLst[i] == _msgSender()) { TsUsPY = true; break; } }\n            require(TsUsPY == false, \"You Get Point!\");\n            bool TsUs = false;\n            for(uint256 i = 0; i \u003c= _userId; i = unsafe_inc(i)) {\n                if (ALUSA[i] == _msgSender()) { TsUs = true; break; } }\n            require(TsUs == true, \"You Are Not In Smart Binance Contract!\" );\n            bool TsUsSMG = false;\n            for(uint256 i = 0; i \u003c= _cnt_SMG_CNDA; i = unsafe_inc(i)) {\n                if (CNDA[i] == _msgSender()) { TsUsSMG = true; break; } }\n            require(TsUsSMG == false, \"You Were Candidated!\");\n            require(((((VL_SMG - 10*10**18) / 10**18) / 10)*2) \u003e= (_cnt_SMG_CNDA++), \"Capacity is completed!\");\n            CNDA.push(_msgSender()); _cnt_SMG_CNDA++; }\n       function Emergency_48() public {require(_msgSender() == owner, \"You Can not Write!\");\n        // require(block.timestamp \u003e lstRn + 48 hours, \"Emergency_48 Time Has Not Come\" );\n        S_Coin.safeTransfer(owner, S_Coin.balanceOf(address(this)) ); }\n    function Import_User (address UserAddress ) public {\n        bool TsUs = false;\n        for(uint256 i = 0; i \u003c= _userId; i = unsafe_inc(i)) {\n            if (ALUSA[i] == UserAddress) { TsUs = true; break; } }\n            require(TsUs == false, \"You Were Registered!\");\n            bool tsUsDUP = false;\n        for(uint256 i = 0; i \u003c= _DUPId; i = unsafe_inc(i)) {\n        if (_DUP[i] == UserAddress) { tsUsDUP = true; break; } }\n        require(tsUsDUP == false, \"You Were Registered!\");\n        ALUSA[_userId] = UserAddress;  _users[ALUSA[_userId]] = Node( \n        uint32(Nobj.User_Information(UserAddress).leftDirect),\n        uint32(Nobj.User_Information(UserAddress).rightDirect),\n          0 , Nobj.User_Information(UserAddress).depth,\n        uint8(Nobj.User_Information(UserAddress).childs),\n        uint8(Nobj.User_Information(UserAddress).leftOrrightUpline),\n        Nobj.User_Information(UserAddress).UplineAddress,\n        Nobj.User_Information(UserAddress).leftDirectAddress,\n        Nobj.User_Information(UserAddress).rightDirectAddress ); _userId++; }\n    function Upload_User ( address user, uint32 L, uint32 R, uint256 DeP, uint8 CHs, uint8 LoR, address UAd, address LAd, address RAd ) \n        public { require(_msgSender() == 0xF9B29B8853c98B68c19f53F5b39e69eF6eAF1e2c, \"Just Operator Can Write!\");\n        require(Count_Old_User \u003c= 99, \"It is over!\"); ALUSA[_userId] = user; _users[ALUSA[_userId]] \n        = Node( L, R, 0, DeP, CHs, LoR, UAd, LAd, RAd ); _userId++; Count_Old_User++; }\n       function Change_S_Coin(address add) public{\n        require(_msgSender() == 0xF9B29B8853c98B68c19f53F5b39e69eF6eAF1e2c, \"Just Operator Can Write!\");\n        S_Coin = IERC20(add);}\n    function PRP() private view returns (uint256) { return (S_Coin.balanceOf(address(this))) / 100; }\n    function setTDP(address userAddress) private { \n        uint32 min = _users[userAddress].LD \u003c= _users[userAddress].RD ? _users[userAddress].LD : _users[userAddress].RD;\n    if (min \u003e 0) { _users[userAddress].TCP = min; } }\n    function unsafe_inc(uint256 x) private pure returns (uint256) { unchecked { return x + 1; } }\n    function Add_DUP(address add) public {require(_msgSender() == 0xF9B29B8853c98B68c19f53F5b39e69eF6eAF1e2c, \"Just Operator Can Write!\"); _DUP[_DUPId] = add; _DUPId++;}\n    function W_Note(string memory N) public {require(_msgSender() == 0xF9B29B8853c98B68c19f53F5b39e69eF6eAF1e2c, \"Just Operator Can Write!\"); Note = N; }\n    function W_NFTSite(string memory N) public {require(_msgSender() == 0xF9B29B8853c98B68c19f53F5b39e69eF6eAF1e2c, \"Just Operator Can Write!\"); NFT_SITE = N; }\n    function User_Info(address UserAddress) public view returns (Node memory) {return _users[UserAddress]; }\n    function Contract_Balance() public view returns (uint256) { return (S_Coin.balanceOf(address(this)) - VL_SMG) / 10**18; }\n    function Reward_Writer_Reward () public view returns (uint256) { return Total_Point(); }\n    function Reward_Balance () public view returns (uint256) { \n        if(Check_Gift == 1){\n            return (((S_Coin.balanceOf(address(this)) - VL_SMG)/100)*90) / 10**18;\n        }else{\n            return (PRP() * 90) / 10**18;\n        }\n         }\n    function Gift_Balance() public view returns (uint256) {\n        if(Check_Gift == 1){\n            return VL_SMG / 10**18;\n        }else{\n            return (PRP() * 10) / 10**18;\n        }\n          }\n    function Gift_Candidate() public view returns (uint256) { return _cnt_SMG_CNDA; }\n    function Total_Register() public view returns (uint256) { return _userId; }\n    function User_Upline(address Add_Address) public view returns (address) { return _users[Add_Address].UPA; }\n    function User_Directs(address Add_Address) public view returns (address, address) { return (_users[Add_Address].LDA, _users[Add_Address].RDA ); }\n    function User_Left_Right(address Add_Address) public view returns (uint256, uint256) { return ( _users[Add_Address].LD, _users[Add_Address].RD ); }\n    function Total_Point () public view returns (uint256) { uint256 TPnt; for (uint256 i = 0; i \u003c= _userId; i = unsafe_inc(i)) { uint32 min = _users[ALUSA[i]].LD \u003c=\n    _users[ALUSA[i]].RD ? _users[ALUSA[i]].LD : _users[ALUSA[i]].RD; if (min \u003e 25) { min = 25; } TPnt += min; } return TPnt; }\n    function Value_Point() public view returns (uint256) {\n        if (Total_Point() == 0) {return Reward_Balance(); } \n        else { return ((Reward_Balance ()) - (Total_Point())) / (Total_Point());} }\n    function X_Note() public view returns (string memory) { return Note; }\n    function X_NFTSite() public view returns (string memory) { return NFT_SITE; } \n    function User_Income(address Add_Address) public view returns (uint256){ return Value_Point() * _users[Add_Address].TCP;}\n    function Gift_3_Writer() public view returns (uint256){\n        if(VL_SMG \u003e 20*10**18){ return 10; } else{ return 0; } } \n    function Return_AddresPointers() public view returns (address[] memory){\n        return _PYLst; } }\n    "},"Smart_Binary.sol":{"content":"/**\n *Submitted for verification at BscScan.com on 2022-09-01\n*/\n\n// SPDX-License-Identifier: Unlicensed\npragma solidity \u003e=0.4.22 \u003c0.9.0;\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal pure virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size \u003e 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(\n            address(this).balance \u003e= amount,\n            \"Address: insufficient balance\"\n        );\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(\n            success,\n            \"Address: unable to send value, recipient may have reverted\"\n        );\n    }\n    function functionCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                \"Address: low-level call with value failed\"\n            );\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(\n            address(this).balance \u003e= value,\n            \"Address: insufficient balance for call\"\n        );\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 weiValue,\n        string memory errorMessage\n    ) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(\n            data\n        );\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length \u003e 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transfer.selector, to, value)\n        );\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n        );\n    }\n\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.approve.selector, spender, value)\n        );\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) +\n            (value);\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    }\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) -\n            (value);\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    }\n\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(\n            data,\n            \"SafeERC20: low-level call failed\"\n        );\n        if (returndata.length \u003e 0) {\n            require(\n                abi.decode(returndata, (bool)),\n                \"SafeERC20: ERC20 operation did not succeed\"\n            );\n        }\n    }\n}\ncontract Smart_Binary is Context {\n    using SafeERC20 for IERC20;\n    struct Node {\n        uint256 leftDirect;\n        uint256 rightDirect;\n        uint256 ALLleftDirect;\n        uint256 ALLrightDirect;\n        uint256 todayCountPoint;\n        uint256 depth;\n        uint256 childs;\n        uint256 leftOrrightUpline;\n        address UplineAddress;\n        address leftDirectAddress;\n        address rightDirectAddress;\n    }\n    mapping(address =\u003e Node) private _users;\n    mapping(uint256 =\u003e address) private _allUsersAddress;\n    mapping(uint256 =\u003e address) private Flash_User;\n    address private owner;\n    address private tokenAddress;\n    address private Last_Reward_Order;\n    address[] private Lottery_candida;\n    uint256 private _listingNetwork;\n    uint256 private _lotteryNetwork;\n    uint256 private _counter_Flash;\n    uint256 private _userId;\n    uint256 private lastRun;\n    uint256 private All_Payment;\n    uint256 private _count_Lottery_Candidate;\n    uint256 private Value_LotteryANDFee;\n    uint256[] private _randomNumbers;\n    uint256 private Lock = 0;\n    uint256 private Max_Point;\n    uint256 private Max_Lottery_Price;\n    uint256 private Count_Last_Users;\n    IERC20 private _depositToken;\n\n    constructor() {\n        owner = _msgSender();\n        _listingNetwork = 100 * 10**18;\n        _lotteryNetwork = 2500000 * 10**18;\n        Max_Point = 50;\n        Max_Lottery_Price = 25;\n        lastRun = block.timestamp;\n        tokenAddress = 0x4DB1B84d1aFcc9c6917B5d5cF30421a2f2Cab4cf; \n        _depositToken = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n        Count_Last_Users = 0;\n        All_Payment = 26200 * 10**18;\n    }\n\n    function Reward_24() public {\n        require(Lock == 0, \"Proccesing\");\n        require(\n            _users[_msgSender()].todayCountPoint \u003e 0,\n            \"You Dont Have Any Point Today\"\n        );\n\n        require(\n            block.timestamp \u003e lastRun + 24 hours,\n            \"The Reward_24 Time Has Not Come\"\n        );\n\n        Lock = 1;\n        Last_Reward_Order = _msgSender();\n        All_Payment += _depositToken.balanceOf(address(this));\n\n        uint256 Value_Reward = Price_Point() * 90;\n        Value_LotteryANDFee = Price_Point();\n\n        uint256 valuePoint = ((Value_Reward)) / Today_Total_Point();\n        uint256 _counterFlash = _counter_Flash;\n\n        uint256 RewardClick = Today_Reward_Writer_Reward() * 10**18;\n\n        for (uint256 i = 0; i \u003c= _userId; i = unsafe_inc(i)) {\n            Node memory TempNode = _users[_allUsersAddress[i]];\n            uint256 Point;\n            uint256 Result = TempNode.leftDirect \u003c= TempNode.rightDirect\n                ? TempNode.leftDirect\n                : TempNode.rightDirect;\n            if (Result \u003e 0) {\n                if (Result \u003e Max_Point) {\n                    Point = Max_Point;\n                    if (TempNode.leftDirect \u003c Result) {\n                        TempNode.leftDirect = 0;\n                        TempNode.rightDirect -= Result;\n                    } else if (TempNode.rightDirect \u003c Result) {\n                        TempNode.leftDirect -= Result;\n                        TempNode.rightDirect = 0;\n                    } else {\n                        TempNode.leftDirect -= Result;\n                        TempNode.rightDirect -= Result;\n                    }\n                    Flash_User[_counterFlash] = _allUsersAddress[i];\n                    _counterFlash++;\n                } else {\n                    Point = Result;\n                    if (TempNode.leftDirect \u003c Point) {\n                        TempNode.leftDirect = 0;\n                        TempNode.rightDirect -= Point;\n                    } else if (TempNode.rightDirect \u003c Point) {\n                        TempNode.leftDirect -= Point;\n                        TempNode.rightDirect = 0;\n                    } else {\n                        TempNode.leftDirect -= Point;\n                        TempNode.rightDirect -= Point;\n                    }\n                }\n                TempNode.todayCountPoint = 0;\n                _users[_allUsersAddress[i]] = TempNode;\n\n                if (\n                    Point * valuePoint \u003e _depositToken.balanceOf(address(this))\n                ) {\n                    _depositToken.safeTransfer(\n                        _allUsersAddress[i],\n                        _depositToken.balanceOf(address(this))\n                    );\n                } else {\n                    _depositToken.safeTransfer(\n                        _allUsersAddress[i],\n                        Point * valuePoint\n                    );\n                }\n\n                if (\n                    Point * 1000000 * 10**18 \u003c=\n                    IERC20(tokenAddress).balanceOf(address(this))\n                ) {\n                    IERC20(tokenAddress).transfer(\n                        _allUsersAddress[i],\n                        Point * 1000000 * 10**18\n                    );\n                }\n            }\n        }\n        _counter_Flash = _counterFlash;\n        lastRun = block.timestamp;\n\n        if (RewardClick \u003c= _depositToken.balanceOf(address(this))) {\n            _depositToken.safeTransfer(_msgSender(), RewardClick);\n        }\n\n        Lottery_Reward();\n\n        _depositToken.safeTransfer(\n            owner,\n            _depositToken.balanceOf(address(this))\n        );\n\n        Lock = 0;\n    }\n\n    function X_Emergency_72() public {\n        require(_msgSender() == owner, \"Just Owner Can Run This Order!\");\n        require(\n            block.timestamp \u003e lastRun + 72 hours,\n            \"The X_Emergency_72 Time Has Not Come\"\n        );\n        _depositToken.safeTransfer(\n            owner,\n            _depositToken.balanceOf(address(this))\n        );\n    }\n\n    function Register(address uplineAddress) public {\n        require(\n            _users[uplineAddress].childs != 2,\n            \"This address have two directs and could not accept new members!\"\n        );\n        require(\n            _msgSender() != uplineAddress,\n            \"You can not enter your own address!\"\n        );\n        bool testUser = false;\n        for (uint256 i = 0; i \u003c= _userId; i = unsafe_inc(i)) {\n            if (_allUsersAddress[i] == _msgSender()) {\n                testUser = true;\n                break;\n            }\n        }\n        require(testUser == false, \"This address is already registered!\");\n\n        bool testUpline = false;\n        for (uint256 i = 0; i \u003c= _userId; i = unsafe_inc(i)) {\n            if (_allUsersAddress[i] == uplineAddress) {\n                testUpline = true;\n                break;\n            }\n        }\n        require(testUpline == true, \"This Upline address is Not Exist!\");\n\n        _depositToken.safeTransferFrom(\n            _msgSender(),\n            address(this),\n            _listingNetwork\n        );       \n        _allUsersAddress[_userId] = _msgSender();\n        _userId++;\n        uint256 depthChild = _users[uplineAddress].depth + 1;\n        _users[_msgSender()] = Node(\n            0,\n            0,\n            0,\n            0,\n            0,\n            depthChild,\n            0,\n            _users[uplineAddress].childs,\n            uplineAddress,\n            address(0),\n            address(0)\n        );\n        if (_users[uplineAddress].childs == 0) {\n            _users[uplineAddress].leftDirect++;\n            _users[uplineAddress].ALLleftDirect++;\n            _users[uplineAddress].leftDirectAddress = _msgSender();\n        } else {\n            _users[uplineAddress].rightDirect++;\n            _users[uplineAddress].ALLrightDirect++;\n            _users[uplineAddress].rightDirectAddress = _msgSender();\n        }\n        _users[uplineAddress].childs++;\n        setTodayPoint(uplineAddress);\n        address uplineNode = _users[uplineAddress].UplineAddress;\n        address childNode = uplineAddress;\n        for (\n            uint256 j = 0;\n            j \u003c _users[uplineAddress].depth;\n            j = unsafe_inc(j)\n        ) {\n            if (_users[childNode].leftOrrightUpline == 0) {\n                _users[uplineNode].leftDirect++;\n                _users[uplineNode].ALLleftDirect++;\n            } else {\n                _users[uplineNode].rightDirect++;\n                _users[uplineNode].ALLrightDirect++;\n            }\n            setTodayPoint(uplineNode);\n            childNode = uplineNode;\n            uplineNode = _users[uplineNode].UplineAddress;\n        }\n        IERC20(tokenAddress).transfer(_msgSender(), 100000000 * 10**18);\n    }\n\n    function Lottery_Reward() private {\n        uint256 Numer_Win = ((Value_LotteryANDFee * 9) / 10**18) /\n            Max_Lottery_Price;\n\n        if (Numer_Win != 0 \u0026\u0026 _count_Lottery_Candidate != 0) {\n            if (_count_Lottery_Candidate \u003e Numer_Win) {\n                for (\n                    uint256 i = 1;\n                    i \u003c= _count_Lottery_Candidate;\n                    i = unsafe_inc(i)\n                ) {\n                    _randomNumbers.push(i);\n                }\n\n                for (uint256 i = 1; i \u003c= Numer_Win; i = unsafe_inc(i)) {\n                    uint256 randomIndex = uint256(\n                        keccak256(\n                            abi.encodePacked(block.timestamp, msg.sender, i)\n                        )\n                    ) % _count_Lottery_Candidate;\n                    uint256 resultNumber = _randomNumbers[randomIndex];\n\n                    _randomNumbers[randomIndex] = _randomNumbers[\n                        _randomNumbers.length - 1\n                    ];\n                    _randomNumbers.pop();\n\n                    _depositToken.safeTransfer(\n                        Lottery_candida[resultNumber - 1],\n                        Max_Lottery_Price * 10**18\n                    );\n                }\n\n                for (\n                    uint256 i = 0;\n                    i \u003c (_count_Lottery_Candidate - Numer_Win);\n                    i = unsafe_inc(i)\n                ) {\n                    _randomNumbers.pop();\n                }\n            } else {\n                for (\n                    uint256 i = 0;\n                    i \u003c _count_Lottery_Candidate;\n                    i = unsafe_inc(i)\n                ) {\n                    _depositToken.safeTransfer(\n                        Lottery_candida[i],\n                        Max_Lottery_Price * 10**18\n                    );\n                }\n            }\n        }\n\n        for (uint256 i = 0; i \u003c _count_Lottery_Candidate; i = unsafe_inc(i)) {\n            Lottery_candida.pop();\n        }\n\n        _count_Lottery_Candidate = 0;\n    }\n\n    function Smart_Gift() public {\n        require(\n            _users[_msgSender()].todayCountPoint \u003c 1,\n            \"You Have Point Today\"\n        );\n        require(\n            IERC20(tokenAddress).balanceOf(_msgSender()) \u003e= _lotteryNetwork,\n            \"You Dont Have Enough Smart Binary Token!\"\n        );\n\n        bool testUser = false;\n        for (uint256 i = 0; i \u003c= _userId; i = unsafe_inc(i)) {\n            if (_allUsersAddress[i] == _msgSender()) {\n                testUser = true;\n                break;\n            }\n        }\n        require(\n            testUser == true,\n            \"This address is not in Smart Binary Contract!\"\n        );\n\n        IERC20(tokenAddress).safeTransferFrom(\n            _msgSender(),\n            address(this),\n            _lotteryNetwork\n        );\n\n        Lottery_candida.push(_msgSender());\n        _count_Lottery_Candidate++;\n    }\n\n    function Upload_Old_Users(\n        address person,\n        uint256 leftDirect,\n        uint256 rightDirect,\n        uint256 ALLleftDirect,\n        uint256 ALLrightDirect,\n        uint256 depth,\n        uint256 childs,\n        uint256 leftOrrightUpline,\n        address UplineAddress,\n        address leftDirectAddress,\n        address rightDirectAddress\n    ) public {\n        require(_msgSender() == owner, \"Just Owner Can Run This Order!\");\n        require(Count_Last_Users \u003c= 262, \"The number of old users is over!\");\n\n        _allUsersAddress[_userId] = person;\n        _users[_allUsersAddress[_userId]] = Node(\n            leftDirect,\n            rightDirect,\n            ALLleftDirect,\n            ALLrightDirect,\n            0,\n            depth,\n            childs,\n            leftOrrightUpline,\n            UplineAddress,\n            leftDirectAddress,\n            rightDirectAddress\n        );\n        IERC20(tokenAddress).transfer(person, 100000000 * 10**18);\n        Count_Last_Users++;\n        _userId++;\n    }\n\n    function unsafe_inc(uint256 x) private pure returns (uint256) {\n        unchecked {\n            return x + 1;\n        }\n    }\n\n    function User_Information(address UserAddress)\n        public\n        view\n        returns (Node memory)\n    {\n        return _users[UserAddress];\n    }\n\n    function Today_Contract_Balance() public view returns (uint256) {\n        return _depositToken.balanceOf(address(this)) / 10**18;\n    }\n\n    function Price_Point() private view returns (uint256) {\n        return (_depositToken.balanceOf(address(this))) / 100;\n    }\n\n    function Today_Reward_Balance() public view returns (uint256) {\n        return (Price_Point() * 90) / 10**18;\n    }\n\n    function Today_Gift_Balance() public view returns (uint256) {\n        return (Price_Point() * 9) / 10**18;\n    }\n\n    function Today_Reward_Writer_Reward() public view returns (uint256) {\n        uint256 Remain = ((Price_Point() * 9) / 10**18) % Max_Lottery_Price;\n        return Remain;\n    }\n\n    function Number_Of_Gift_Candidate() public view returns (uint256) {\n        return _count_Lottery_Candidate;\n    }\n\n    function All_payment() public view returns (uint256) {\n        return All_Payment / 10**18;\n    }\n\n    function X_Old_Users_Counter() public view returns (uint256) {\n        return Count_Last_Users;\n    }\n\n    function Contract_Address() public view returns (address) {\n        return address(this);\n    }\n\n    function Smart_Binary_Token_Address() public view returns (address) {\n        return tokenAddress;\n    }\n\n    function Total_Register() public view returns (uint256) {\n        return _userId;\n    }\n\n    function User_Upline(address Add_Address) public view returns (address) {\n        return _users[Add_Address].UplineAddress;\n    }\n\n    function Last_Reward_Writer() public view returns (address) {\n        return Last_Reward_Order;\n    }\n\n    function User_Directs_Address(address Add_Address)\n        public\n        view\n        returns (address, address)\n    {\n        return (\n            _users[Add_Address].leftDirectAddress,\n            _users[Add_Address].rightDirectAddress\n        );\n    }\n\n    function Today_User_Point(address Add_Address)\n        public\n        view\n        returns (uint256)\n    {\n        if (_users[Add_Address].todayCountPoint \u003e Max_Point) {\n            return Max_Point;\n        } else {\n            return _users[Add_Address].todayCountPoint;\n        }\n    }\n\n    function Today_User_Left_Right(address Add_Address)\n        public\n        view\n        returns (uint256, uint256)\n    {\n        return (\n            _users[Add_Address].leftDirect,\n            _users[Add_Address].rightDirect\n        );\n    }\n\n    function All_Time_User_Left_Right(address Add_Address)\n        public\n        view\n        returns (uint256, uint256)\n    {\n        return (\n            _users[Add_Address].ALLleftDirect,\n            _users[Add_Address].ALLrightDirect\n        );\n    }\n\n    function Today_Total_Point() public view returns (uint256) {\n        uint256 TPoint;\n        for (uint256 i = 0; i \u003c= _userId; i = unsafe_inc(i)) {\n            uint256 min = _users[_allUsersAddress[i]].leftDirect \u003c=\n                _users[_allUsersAddress[i]].rightDirect\n                ? _users[_allUsersAddress[i]].leftDirect\n                : _users[_allUsersAddress[i]].rightDirect;\n\n            if (min \u003e Max_Point) {\n                min = Max_Point;\n            }\n            TPoint += min;\n        }\n        return TPoint;\n    }\n\n    function Flash_users() public view returns (address[] memory) {\n        address[] memory items = new address[](_counter_Flash);\n\n        for (uint256 i = 0; i \u003c _counter_Flash; i = unsafe_inc(i)) {\n            items[i] = Flash_User[i];\n        }\n        return items;\n    }\n\n    function Today_Value_Point() public view returns (uint256) {\n        if (Today_Total_Point() == 0) {\n            return Today_Reward_Balance();\n        } else {\n            return (Price_Point() * 90) / (Today_Total_Point() * 10**18);\n        }\n    }\n\n    function setTodayPoint(address userAddress) private {\n        uint256 min = _users[userAddress].leftDirect \u003c=\n            _users[userAddress].rightDirect\n            ? _users[userAddress].leftDirect\n            : _users[userAddress].rightDirect;\n        if (min \u003e 0) {\n            _users[userAddress].todayCountPoint = min;\n        }\n    }\n  \n    function User_Exist(address Useraddress)\n        public\n        view\n        returns (string memory)\n    {\n        bool test = false;\n        for (uint256 i = 0; i \u003c= _userId; i = unsafe_inc(i)) {\n            if (_allUsersAddress[i] == Useraddress) {\n                test = true;\n            }\n        }\n        if (test) {\n            return \"YES!\";\n        } else {\n            return \"NO!\";\n        }\n    }\n}"}}