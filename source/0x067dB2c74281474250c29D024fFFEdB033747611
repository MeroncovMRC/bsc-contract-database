{"IERC20.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\ninterface IERC20 {\n\n    function totalSupply() external view returns (uint256);\n    \n    function symbol() external view returns(string memory);\n    \n    function name() external view returns(string memory);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n    \n    /**\n     * @dev Returns the number of decimal places\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"},"Ownable.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.14;\n\n/**\n * @title Owner\n * @dev Set \u0026 change owner\n */\ncontract Ownable {\n\n    address private owner;\n    \n    // event for EVM logging\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\n    \n    // modifier to check if caller is owner\n    modifier onlyOwner() {\n        // If the first argument of \u0027require\u0027 evaluates to \u0027false\u0027, execution terminates and all\n        // changes to the state and to Ether balances are reverted.\n        // This used to consume all gas in old EVM versions, but not anymore.\n        // It is often a good idea to use \u0027require\u0027 to check if functions are called correctly.\n        // As a second argument, you can also provide an explanation about what went wrong.\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n    \n    /**\n     * @dev Set contract deployer as owner\n     */\n    constructor() {\n        owner = msg.sender; // \u0027msg.sender\u0027 is sender of current call, contract deployer for a constructor\n        emit OwnerSet(address(0), owner);\n    }\n\n    /**\n     * @dev Change owner\n     * @param newOwner address of new owner\n     */\n    function changeOwner(address newOwner) public onlyOwner {\n        emit OwnerSet(owner, newOwner);\n        owner = newOwner;\n    }\n\n    /**\n     * @dev Return owner address \n     * @return address of owner\n     */\n    function getOwner() external view returns (address) {\n        return owner;\n    }\n}"},"Presale.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\nimport \"./IERC20.sol\";\nimport \"./Ownable.sol\";\n\ncontract Presale is Ownable {\n\n    // User Structure\n    struct User {\n        uint256 donated;\n        uint256 toReceive;\n        bool isWhitelisted;\n    }\n\n    // Address =\u003e User\n    mapping ( address =\u003e User ) public donors;\n\n    // Has Whitelist\n    bool public whitelistEnabled = false;\n\n    // Can Claim\n    bool public canClaim = false;\n\n    // List Of All Donors\n    address[] private _allDonors;\n\n    // Total Amount Donated\n    uint256 private _totalDonated;\n\n    // Receiver Of Donation\n    address private constant presaleReceiver = 0xF39C34005989aD92E238b00e28C316544aEA4E22;\n\n    // maximum contribution\n    uint256 public min_contribution = 10 * 10**18;\n\n    // minimum contribution\n    uint256 public max_contribution = 2000 * 10**18;\n\n    // soft / hard cap\n    uint256 public hardCap = 40_000 * 10**18;\n\n    // exchange rates\n    uint256 public exchangeRate = 100 * 10**18;\n\n    // sale has ended\n    bool public hasStarted;\n\n    // Raise Token\n    IERC20 public constant BUSD = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    IERC20 public constant token = IERC20(0xBEDe3f314EF415fe8070534F61b2619349803520);\n\n    // Donation Event, Trackers Donor And Amount Donated\n    event Donated(address donor, uint256 amountDonated, uint256 totalInSale);\n\n    function startSale() external onlyOwner {\n        hasStarted = true;\n    }\n\n    function endSale() external onlyOwner {\n        hasStarted = false;\n    }\n\n    function withdraw(IERC20 token_) external onlyOwner {\n        token_.transfer(presaleReceiver, token_.balanceOf(address(this)));\n    }\n\n    function setExchangeRate(uint newRate) external onlyOwner {\n        exchangeRate = newRate;\n    }\n\n    function setMinContributions(uint min) external onlyOwner {\n        min_contribution = min;\n    }\n\n    function setMaxContribution(uint max) external onlyOwner {\n        max_contribution = max;\n    }\n\n    function setHardCap(uint hardCap_) external onlyOwner {\n        hardCap = hardCap_;\n    }\n\n    function enableWhitelist() external onlyOwner {\n        whitelistEnabled = true;\n    }\n\n    function disableWhitelist() external onlyOwner {\n        whitelistEnabled = false;\n    }\n\n    function enableClaiming() external onlyOwner {\n        canClaim = true;\n    }\n\n    function disableClaiming() external onlyOwner {\n        canClaim = false;\n    }\n\n    function setWhitelist(address[] calldata users, bool isWhitelisted) external onlyOwner {\n        uint len = users.length;\n        for (uint i = 0; i \u003c len;) {\n            donors[users[i]].isWhitelisted = isWhitelisted;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function claim() external {\n        require(\n            canClaim,\n            \u0027Claiming Disabled\u0027\n        );\n\n        uint toReceive = donors[msg.sender].toReceive;\n        require(\n            toReceive \u003e 0,\n            \u0027Zero To Receive\u0027\n        );\n\n        delete donors[msg.sender].toReceive;\n        token.transfer(msg.sender, toReceive);\n    }\n\n    function donate(uint256 amount) external {\n        uint received = _transferIn(amount);\n        _process(msg.sender, received);\n    }\n\n    function donated(address user) external view returns(uint256) {\n        return donors[user].donated;\n    }\n\n    function tokensToReceive(address user) external view returns(uint256) {\n        return donors[user].toReceive;\n    }\n\n    function allDonors() external view returns (address[] memory) {\n        return _allDonors;\n    }\n\n    function allDonorsAndTokensToReceive() external view returns (address[] memory, uint256[] memory) {\n        uint len = _allDonors.length;\n        uint256[] memory toReceive = new uint256[](len);\n        for (uint i = 0; i \u003c len;) {\n            toReceive[i] = donors[_allDonors[i]].toReceive;\n            unchecked { ++i; }\n        }\n        return (_allDonors, toReceive);\n    }\n\n    function donorAtIndex(uint256 index) external view returns (address) {\n        return _allDonors[index];\n    }\n\n    function numberOfDonors() external view returns (uint256) {\n        return _allDonors.length;\n    }\n\n    function totalDonated() external view returns (uint256) {\n        return _totalDonated;\n    }\n\n    function _process(address user, uint amount) internal {\n        require(\n            amount \u003e 0,\n            \u0027Zero Amount\u0027\n        );\n        require(\n            hasStarted,\n            \u0027Sale Has Not Started\u0027\n        );\n        if (whitelistEnabled) {\n            require(\n                donors[user].isWhitelisted,\n                \u0027Not Whitelisted\u0027\n            );\n        }\n\n        // add to donor list if first donation\n        if (donors[user].donated == 0) {\n            _allDonors.push(user);\n        }\n\n        // increment amounts donated\n        donors[user].donated += amount;\n        _totalDonated += amount;\n\n        // give exchange amount\n        donors[user].toReceive += ( amount * exchangeRate ) / 10**18;\n\n        require(\n            donors[user].donated \u003c= max_contribution,\n            \u0027Exceeds Max Contribution\u0027\n        );\n        require(\n            donors[user].donated \u003e= min_contribution,\n            \u0027Contribution too low\u0027\n        );\n        require(\n            _totalDonated \u003c= hardCap,\n            \u0027Hard Cap Reached\u0027\n        );\n        emit Donated(user, amount, _totalDonated);\n    }\n\n    function _transferIn(uint amount) internal returns (uint256) {\n        require(\n            BUSD.allowance(msg.sender, address(this)) \u003e= amount,\n            \u0027Insufficient Allowance\u0027\n        );\n        uint before = BUSD.balanceOf(presaleReceiver);\n        require(\n            BUSD.transferFrom(\n                msg.sender,\n                presaleReceiver,\n                amount\n            ),\n            \u0027Failure On BUSD Transfer\u0027\n        );\n        uint After = BUSD.balanceOf(presaleReceiver);\n        require(\n            After \u003e before,\n            \u0027No Tokens Received\u0027\n        );\n        return After - before;\n    }\n}"}}