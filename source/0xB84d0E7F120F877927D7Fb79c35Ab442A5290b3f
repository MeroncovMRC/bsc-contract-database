// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.7.4;
pragma experimental ABIEncoderV2;

library Address {
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }

    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");
        (bool success, ) = recipient.call{ value: amount }("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
      return functionCall(target, data, "Address: low-level call failed");
    }

    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");
        (bool success, bytes memory returndata) = target.call{ value: value }(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");
        (bool success, bytes memory returndata) = target.staticcall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        require(isContract(target), "Address: delegate call to non-contract");
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
        if (success) {
            return returndata;
        } else {
            if (returndata.length > 0) {
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

library Math {
    function max(uint256 a, uint256 b) internal pure returns (uint256) {
        return a >= b ? a : b;
    }

    function min(uint x, uint y) internal pure returns (uint z) {
        z = x < y ? x : y;
    }

    function abs(uint x, uint y) internal pure returns (uint) {
        return x >= y ? x - y : y - x;
    }

    function sqrt(uint y) internal pure returns (uint z) {
        if (y > 3) {
            z = y;
            uint x = y / 2 + 1;
            while (x < z) {
                z = x;
                x = (y / x + x) / 2;
            }
        } else if (y != 0) {
            z = 1;
        }
    }
}

library SafeERC20 {
    using SafeMath for uint256;
    using Address for address;

    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint256 value) internal {        
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
        if (returndata.length > 0) {
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");
        return c;
    }
    
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}

interface IOwned {
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    function owner() external view returns (address);

    function transferOwnership(address newOwner) external;
    function claimOwnership() external;
}

interface IERC20 {
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    function totalSupply() external view returns (uint256);
    function balanceOf(address _account) external view returns (uint256);
    function transfer(address _recipient, uint256 _amount) external returns (bool);
    function allowance(address _owner, address _spender) external view returns (uint256);
    function approve(address _spender, uint256 _amount) external returns (bool);
    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool);

    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint8);
}

interface IExternalOracle {
    function getPrice(address tokenAddress) external view returns (uint256);
}

interface ITokensRecoverable {
    function recoverTokens(IERC20 token) external;
}

abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this;
        return msg.data;
    }
}

abstract contract Pausable is Context {

    event Paused(address account);
    event Unpaused(address account);

    bool private _paused;

    modifier whenNotPaused() {
        require(!paused(), "Pausable: paused");
        _;
    }

    modifier whenPaused() {
        require(paused(), "Pausable: not paused");
        _;
    }

    constructor () {
        _paused = false;
    }

    function paused() public view virtual returns (bool) {
        return _paused;
    }

    function _pause() internal virtual whenNotPaused {
        _paused = true;
        emit Paused(_msgSender());
    }

    function _unpause() internal virtual whenPaused {
        _paused = false;
        emit Unpaused(_msgSender());
    }
}

abstract contract Owned is IOwned {
    address public override owner = msg.sender;
    address internal pendingOwner;

    modifier ownerOnly() {
        require (msg.sender == owner, "Owner only");
        _;
    }

    function transferOwnership(address newOwner) public override ownerOnly() {
        pendingOwner = newOwner;
    }

    function claimOwnership() public override {
        require (pendingOwner == msg.sender);
        pendingOwner = address(0);
        emit OwnershipTransferred(owner, msg.sender);
        owner = msg.sender;
    }
}

contract Whitelist is Owned {

    modifier onlyWhitelisted() {
        if(active){
            require(whitelist[msg.sender], 'not whitelisted');
        }
        _;
    }

    bool active = true;

    mapping(address => bool) public whitelist;

    event WhitelistedAddressAdded(address addr);
    event WhitelistedAddressRemoved(address addr);

    function activateDeactivateWhitelist() public ownerOnly() {
        active = !active;
    }

    function addAddressToWhitelist(address addr) public ownerOnly() returns(bool success) {
        if (!whitelist[addr]) {
            whitelist[addr] = true;
            emit WhitelistedAddressAdded(addr);
            success = true;
        }
    }

    function addAddressesToWhitelist(address[] calldata addrs) public ownerOnly() returns(bool success) {
        for (uint256 i = 0; i < addrs.length; i++) {
            if (addAddressToWhitelist(addrs[i])) {
                success = true;
            }
        }
    }

    function removeAddressFromWhitelist(address addr) ownerOnly() public returns(bool success) {
        if (whitelist[addr]) {
            whitelist[addr] = false;
            emit WhitelistedAddressRemoved(addr);
            success = true;
        }
    }

    function removeAddressesFromWhitelist(address[] calldata addrs) ownerOnly() public returns(bool success) {
        for (uint256 i = 0; i < addrs.length; i++) {
            if (removeAddressFromWhitelist(addrs[i])) {
                success = true;
            }
        }
    }
}

abstract contract TokensRecoverable is Owned, ITokensRecoverable {
    using SafeERC20 for IERC20;

    function recoverTokens(IERC20 token) public override ownerOnly() {
        require (canRecoverTokens(token));
        token.safeTransfer(msg.sender, token.balanceOf(address(this)));
    }

    function canRecoverTokens(IERC20 token) internal virtual view returns (bool) { 
        return address(token) != address(this); 
    }
}

abstract contract ReentrancyGuard {
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    modifier nonReentrant() {
        _nonReentrantBefore();
        _;
        _nonReentrantAfter();
    }

    function _nonReentrantBefore() private {
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
        _status = _ENTERED;
    }

    function _nonReentrantAfter() private {
        _status = _NOT_ENTERED;
    }

    function _reentrancyGuardEntered() internal view returns (bool) {
        return _status == _ENTERED;
    }
}

contract PredictionGame is Pausable, Whitelist, ReentrancyGuard, TokensRecoverable {
    using Address for address;
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    struct Round {
        uint256 epoch;
        uint256 startBlock;
        uint256 endBlock;
        uint256 lockPrice;
        uint256 endPrice;
        uint256 totalAmount;
        uint256 bullAmount;
        uint256 bearAmount;
        uint256 rewardBaseCalAmount;
        uint256 rewardAmount;
    }

    struct CallInfo {
        bool direction;
        uint256 amount;
        bool claimed; // default false
    }

    struct UserInfo {
        uint256 totalWins;
        uint256 totalLosses;
        uint256 xBidBull;
        uint256 xBidBear;
    }

    /////////////////////////
    // CONTRACT INTERFACES //
    /////////////////////////

    IERC20 public gameToken;
    IERC20 public priceToken;
    IExternalOracle public oracle;

    ///////////////////////////////
    // CONFIGURABLES & VARIABLES //
    ///////////////////////////////

    address public feeRecipient;

    uint256 public currentEpoch;

    uint256 public winners;
    uint256 public losers;

    bool private BULL = true;
    bool private BEAR = false;

    ///////////////////
    // DATA MAPPINGS //
    ///////////////////

    mapping (uint256 => Round) public rounds;
    mapping (address => UserInfo) public userInfo;
    mapping (uint256 => mapping(address => CallInfo)) public ledger;

    /////////////////////
    // CONTRACT EVENTS //
    /////////////////////

    event NextRound(uint256 indexed epoch);
    event onCallBull(address indexed sender, uint256 indexed currentEpoch, uint256 price);
    event onCallBear(address indexed sender, uint256 indexed currentEpoch, uint256 price);
    event Claim(address indexed sender, uint256 indexed currentEpoch, uint256 price);

    ////////////////////////////
    // CONSTRUCTOR & FALLBACK //
    ////////////////////////////

    constructor(IExternalOracle _oracle, address _gameToken, address _marketToken, address _feeRecipient) {
        oracle = _oracle;
        feeRecipient = _feeRecipient;
        gameToken = IERC20(_gameToken);
        priceToken = IERC20(_marketToken);
    }

    receive() external payable {
        
    }

    ////////////////////
    // VIEW FUNCTIONS //
    ////////////////////

    // Check net-positive status & value of a user
    function npv(address _user) public view returns (bool _netPositive, uint256 _amount) {
        UserInfo memory user = userInfo[_user];
        
        if (user.totalWins > user.totalLosses) {
            return (true, user.totalWins.sub(user.totalLosses));
        } else {
            return (false, user.totalLosses.sub(user.totalWins));
        }
    }

    // Blocks of current round remaining
    function blocksRemaining() public view returns(uint256) {
        Round storage round = rounds[currentEpoch];

        if (block.number >= round.endBlock) return 0;

        return (round.endBlock).sub(block.number);
    }

    // Get the claimable stats of specific epoch and user account
    function claimable(uint256 epoch, address user) public view returns(bool res) {
        CallInfo memory callInfo = ledger[epoch][user];
        Round memory round = rounds[epoch];
        if (round.lockPrice == round.endPrice || round.endPrice == 0) return false;
        return (round.lockPrice < round.endPrice) == callInfo.direction;
    }

    /////////////////////
    // WRITE FUNCTIONS //
    /////////////////////

    // Bid on Bear
    function bidBear(uint256 _amount) external whenNotPaused() {
        require(gameToken.transferFrom(msg.sender, address(this), _amount));

        _trackBid(msg.sender, _amount);
        _bearish(msg.sender, _amount);
        _trackNPV(msg.sender);

        emit onCallBear(msg.sender, currentEpoch + 1, _amount);
    }

    // Bid on Bull
    function bidBull(uint256 _amount) external whenNotPaused() {
        require(gameToken.transferFrom(msg.sender, address(this), _amount));

        _trackBid(msg.sender, _amount);
        _bullish(msg.sender, _amount);
        _trackNPV(msg.sender);

        emit onCallBull(msg.sender, currentEpoch + 1, _amount);
    }

    // Claim the reward you win
    function claim(uint256 epoch) external returns (bool _success) {
        require (currentEpoch > epoch, 'not correct epoch');
        CallInfo storage callInfo = ledger[epoch][msg.sender];
        UserInfo storage user = userInfo[msg.sender];

        require (!callInfo.claimed, 'claimed already');
        require (claimable(epoch, msg.sender), 'unclaimable');
        
        Round memory round = rounds[epoch];
        callInfo.claimed = true;

        uint256 reward = callInfo.amount.mul(round.rewardAmount).div(round.rewardBaseCalAmount);
        
        user.totalWins += reward;

        gameToken.transfer(msg.sender, reward);

        emit Claim(msg.sender, epoch, reward);
        return true;
    }

    //////////////////////////
    // RESTRICTED FUNCTIONS //
    //////////////////////////

    // Pause the contract
    function pause() external onlyWhitelisted() {
        _pause();
    }

    // Unpause the contract
    function unpause() external onlyWhitelisted() {
        _unpause();
    }

    // ONCE-ONLY: Kickstart the first round
    function kickstart() external onlyWhitelisted() {
        currentEpoch = 0;
        rounds[currentEpoch].startBlock = block.number;
        rounds[currentEpoch].lockPrice = oracle.getPrice(address(priceToken));
        rounds[currentEpoch].epoch = currentEpoch;
        rounds[currentEpoch].totalAmount = 0;
    }

    // REPEATED: Start a new round
    function nextRound() external onlyWhitelisted() {
        Round storage round = rounds[currentEpoch];
        
        // set current epoch info
        round.endBlock = block.number;
        round.endPrice = oracle.getPrice(address(priceToken));
        rounds[currentEpoch + 1].rewardAmount = rounds[currentEpoch + 1].totalAmount.mul(19).div(20);
        
        if (round.endPrice > round.lockPrice) {
            round.rewardBaseCalAmount = round.bullAmount;
        } else {
            round.rewardBaseCalAmount = round.bearAmount;
        }

        // 5% fee goes to Fee Recipient
        uint256 feeAmount = rounds[currentEpoch + 1].totalAmount.div(20);
        gameToken.transfer(feeRecipient, feeAmount);

        // set next epoch info
        currentEpoch = currentEpoch + 1;
        rounds[currentEpoch].startBlock = block.number;
        rounds[currentEpoch].lockPrice = oracle.getPrice(address(priceToken));
        rounds[currentEpoch].epoch = currentEpoch;
        rounds[currentEpoch].totalAmount = 0;

        // emit event
        emit NextRound(currentEpoch);
    }

    // ONLY OWNER: Set the address of the game token
    function setGameToken(address _token) external ownerOnly() {
        gameToken = IERC20(_token);
    }

    // ONLY OWNER: Set the address of the price token
    function setPriceToken(address _token) external ownerOnly() {
        priceToken = IERC20(_token);
    }

    // ONLY OWNER: Set the address of the oracle
    function setOracle(address _oracle) external ownerOnly() {
        oracle = IExternalOracle(_oracle);
    }

    // ONLY OWNER: Set the address of the fee recipient
    function setFeeRecipient(address _feeRecipient) external ownerOnly() {
        feeRecipient = _feeRecipient;
    }

    ////////////////////////
    // OVERRIDE FUNCTIONS //
    ////////////////////////

    ////////////////////////
    // INTERNAL FUNCTIONS //
    ////////////////////////

    function _bearish(address _user, uint256 _amount) private {
        UserInfo storage user = userInfo[_user];
        Round storage round = rounds[currentEpoch + 1];
        CallInfo storage callInfo = ledger[currentEpoch + 1][_user];

        // first time to play
        if (callInfo.amount == 0) {
            round.totalAmount = round.totalAmount.add(_amount);
            callInfo.direction = BEAR;
            callInfo.amount = _amount;
            round.bearAmount = round.bearAmount.add(_amount);
            user.xBidBear++;
        }

        // not first time to play, same direction
        else if (callInfo.amount > 0 && callInfo.direction == BEAR) {
            round.totalAmount = round.totalAmount.add(_amount);
            callInfo.amount = callInfo.amount.add(_amount);
            round.bearAmount = round.bearAmount.add(_amount);
        }
        
        // change the direction
        else if (callInfo.amount > 0 && callInfo.direction == BULL) {
            round.bullAmount = round.bullAmount.sub(callInfo.amount);
            round.bearAmount = round.bearAmount.add(callInfo.amount).add(_amount);
            round.totalAmount = round.totalAmount.add(_amount);
            callInfo.direction = BEAR;
            callInfo.amount = callInfo.amount.add(_amount);
            user.xBidBear++;
            user.xBidBull--;
        }
    }

    function _bullish(address _user, uint256 _amount) private {
        UserInfo storage user = userInfo[_user];
        Round storage round = rounds[currentEpoch + 1];
        CallInfo storage callInfo = ledger[currentEpoch + 1][_user];

        // first time to play
        if (callInfo.amount == 0) {
            round.totalAmount = round.totalAmount.add(_amount);
            callInfo.direction = BULL;
            callInfo.amount = _amount;
            round.bullAmount = round.bullAmount.add(_amount);
            user.xBidBull++;
        }
        // not first time to play, same direction
        else if (callInfo.amount > 0 && callInfo.direction == BULL) {
            round.totalAmount = round.totalAmount.add(_amount);
            callInfo.amount = callInfo.amount.add(_amount);
            round.bullAmount = round.bullAmount.add(_amount);
        }
        // change the direction
        else if (callInfo.amount > 0 && callInfo.direction == BEAR) {
            round.bearAmount = round.bearAmount.sub(callInfo.amount);
            round.bullAmount = round.bullAmount.add(callInfo.amount).add(_amount);
            round.totalAmount = round.totalAmount.add(_amount);
            callInfo.direction = BULL;
            callInfo.amount = callInfo.amount.add(_amount);
            user.xBidBull++;
            user.xBidBear--;
        }
    }

    function _trackBid(address _user, uint256 _amount) private {
        UserInfo storage user = userInfo[_user];
        user.totalLosses += _amount;
    }

    function _trackNPV(address _user) private {
        (bool _isNPV,) = npv(_user);
        if (_isNPV) {
            winners++;
            losers--;
        }
    }
}