{"ABDKMath64x64.sol":{"content":"// SPDX-License-Identifier: BSD-4-Clause\r\n/*\r\n * ABDK Math 64.64 Smart Contract Library.  Copyright Â© 2019 by ABDK Consulting.\r\n * Author: Mikhail Vladimirov \u003cmikhail.vladimirov@gmail.com\u003e\r\n */\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * Smart contract library of mathematical functions operating with signed\r\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\r\n * basically a simple fraction whose numerator is signed 128-bit integer and\r\n * denominator is 2^64.  As long as denominator is always the same, there is no\r\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\r\n * represented by int128 type holding only the numerator.\r\n */\r\nlibrary ABDKMath64x64 {\r\n  /*\r\n   * Minimum value signed 64.64-bit fixed point number may have. \r\n   */\r\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\r\n\r\n  /*\r\n   * Maximum value signed 64.64-bit fixed point number may have. \r\n   */\r\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n  /**\r\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\r\n   * number.  Revert on overflow.\r\n   *\r\n   * @param x signed 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function fromInt (int256 x) internal pure returns (int128) {\r\n    unchecked {\r\n      require (x \u003e= -0x8000000000000000 \u0026\u0026 x \u003c= 0x7FFFFFFFFFFFFFFF);\r\n      return int128 (x \u003c\u003c 64);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\r\n   * rounding down.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64-bit integer number\r\n   */\r\n  function toInt (int128 x) internal pure returns (int64) {\r\n    unchecked {\r\n      return int64 (x \u003e\u003e 64);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\r\n   * number.  Revert on overflow.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function fromUInt (uint256 x) internal pure returns (int128) {\r\n    unchecked {\r\n      require (x \u003c= 0x7FFFFFFFFFFFFFFF);\r\n      return int128 (int256 (x \u003c\u003c 64));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\r\n   * number rounding down.  Revert on underflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return unsigned 64-bit integer number\r\n   */\r\n  function toUInt (int128 x) internal pure returns (uint64) {\r\n    unchecked {\r\n      require (x \u003e= 0);\r\n      return uint64 (uint128 (x \u003e\u003e 64));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\r\n   * number rounding down.  Revert on overflow.\r\n   *\r\n   * @param x signed 128.128-bin fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function from128x128 (int256 x) internal pure returns (int128) {\r\n    unchecked {\r\n      int256 result = x \u003e\u003e 64;\r\n      require (result \u003e= MIN_64x64 \u0026\u0026 result \u003c= MAX_64x64);\r\n      return int128 (result);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\r\n   * number.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 128.128 fixed point number\r\n   */\r\n  function to128x128 (int128 x) internal pure returns (int256) {\r\n    unchecked {\r\n      return int256 (x) \u003c\u003c 64;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x + y.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function add (int128 x, int128 y) internal pure returns (int128) {\r\n    unchecked {\r\n      int256 result = int256(x) + y;\r\n      require (result \u003e= MIN_64x64 \u0026\u0026 result \u003c= MAX_64x64);\r\n      return int128 (result);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x - y.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function sub (int128 x, int128 y) internal pure returns (int128) {\r\n    unchecked {\r\n      int256 result = int256(x) - y;\r\n      require (result \u003e= MIN_64x64 \u0026\u0026 result \u003c= MAX_64x64);\r\n      return int128 (result);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x * y rounding down.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function mul (int128 x, int128 y) internal pure returns (int128) {\r\n    unchecked {\r\n      int256 result = int256(x) * y \u003e\u003e 64;\r\n      require (result \u003e= MIN_64x64 \u0026\u0026 result \u003c= MAX_64x64);\r\n      return int128 (result);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\r\n   * number and y is signed 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64 fixed point number\r\n   * @param y signed 256-bit integer number\r\n   * @return signed 256-bit integer number\r\n   */\r\n  function muli (int128 x, int256 y) internal pure returns (int256) {\r\n    unchecked {\r\n      if (x == MIN_64x64) {\r\n        require (y \u003e= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF \u0026\u0026\r\n          y \u003c= 0x1000000000000000000000000000000000000000000000000);\r\n        return -y \u003c\u003c 63;\r\n      } else {\r\n        bool negativeResult = false;\r\n        if (x \u003c 0) {\r\n          x = -x;\r\n          negativeResult = true;\r\n        }\r\n        if (y \u003c 0) {\r\n          y = -y; // We rely on overflow behavior here\r\n          negativeResult = !negativeResult;\r\n        }\r\n        uint256 absoluteResult = mulu (x, uint256 (y));\r\n        if (negativeResult) {\r\n          require (absoluteResult \u003c=\r\n            0x8000000000000000000000000000000000000000000000000000000000000000);\r\n          return -int256 (absoluteResult); // We rely on overflow behavior here\r\n        } else {\r\n          require (absoluteResult \u003c=\r\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n          return int256 (absoluteResult);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\r\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64 fixed point number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return unsigned 256-bit integer number\r\n   */\r\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\r\n    unchecked {\r\n      if (y == 0) return 0;\r\n\r\n      require (x \u003e= 0);\r\n\r\n      uint256 lo = (uint256 (int256 (x)) * (y \u0026 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) \u003e\u003e 64;\r\n      uint256 hi = uint256 (int256 (x)) * (y \u003e\u003e 128);\r\n\r\n      require (hi \u003c= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n      hi \u003c\u003c= 64;\r\n\r\n      require (hi \u003c=\r\n        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\r\n      return hi + lo;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\r\n   * zero.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function div (int128 x, int128 y) internal pure returns (int128) {\r\n    unchecked {\r\n      require (y != 0);\r\n      int256 result = (int256 (x) \u003c\u003c 64) / y;\r\n      require (result \u003e= MIN_64x64 \u0026\u0026 result \u003c= MAX_64x64);\r\n      return int128 (result);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x signed 256-bit integer number\r\n   * @param y signed 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function divi (int256 x, int256 y) internal pure returns (int128) {\r\n    unchecked {\r\n      require (y != 0);\r\n\r\n      bool negativeResult = false;\r\n      if (x \u003c 0) {\r\n        x = -x; // We rely on overflow behavior here\r\n        negativeResult = true;\r\n      }\r\n      if (y \u003c 0) {\r\n        y = -y; // We rely on overflow behavior here\r\n        negativeResult = !negativeResult;\r\n      }\r\n      uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\r\n      if (negativeResult) {\r\n        require (absoluteResult \u003c= 0x80000000000000000000000000000000);\r\n        return -int128 (absoluteResult); // We rely on overflow behavior here\r\n      } else {\r\n        require (absoluteResult \u003c= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n        return int128 (absoluteResult); // We rely on overflow behavior here\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function divu (uint256 x, uint256 y) internal pure returns (int128) {\r\n    unchecked {\r\n      require (y != 0);\r\n      uint128 result = divuu (x, y);\r\n      require (result \u003c= uint128 (MAX_64x64));\r\n      return int128 (result);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate -x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function neg (int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n      require (x != MIN_64x64);\r\n      return -x;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate |x|.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function abs (int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n      require (x != MIN_64x64);\r\n      return x \u003c 0 ? -x : x;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\r\n   * zero.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function inv (int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n      require (x != 0);\r\n      int256 result = int256 (0x100000000000000000000000000000000) / x;\r\n      require (result \u003e= MIN_64x64 \u0026\u0026 result \u003c= MAX_64x64);\r\n      return int128 (result);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function avg (int128 x, int128 y) internal pure returns (int128) {\r\n    unchecked {\r\n      return int128 ((int256 (x) + int256 (y)) \u003e\u003e 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\r\n   * Revert on overflow or in case x * y is negative.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function gavg (int128 x, int128 y) internal pure returns (int128) {\r\n    unchecked {\r\n      int256 m = int256 (x) * int256 (y);\r\n      require (m \u003e= 0);\r\n      require (m \u003c\r\n          0x4000000000000000000000000000000000000000000000000000000000000000);\r\n      return int128 (sqrtu (uint256 (m)));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\r\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y uint256 value\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function pow (int128 x, uint256 y) internal pure returns (int128) {\r\n    unchecked {\r\n      bool negative = x \u003c 0 \u0026\u0026 y \u0026 1 == 1;\r\n\r\n      uint256 absX = uint128 (x \u003c 0 ? -x : x);\r\n      uint256 absResult;\r\n      absResult = 0x100000000000000000000000000000000;\r\n\r\n      if (absX \u003c= 0x10000000000000000) {\r\n        absX \u003c\u003c= 63;\r\n        while (y != 0) {\r\n          if (y \u0026 0x1 != 0) {\r\n            absResult = absResult * absX \u003e\u003e 127;\r\n          }\r\n          absX = absX * absX \u003e\u003e 127;\r\n\r\n          if (y \u0026 0x2 != 0) {\r\n            absResult = absResult * absX \u003e\u003e 127;\r\n          }\r\n          absX = absX * absX \u003e\u003e 127;\r\n\r\n          if (y \u0026 0x4 != 0) {\r\n            absResult = absResult * absX \u003e\u003e 127;\r\n          }\r\n          absX = absX * absX \u003e\u003e 127;\r\n\r\n          if (y \u0026 0x8 != 0) {\r\n            absResult = absResult * absX \u003e\u003e 127;\r\n          }\r\n          absX = absX * absX \u003e\u003e 127;\r\n\r\n          y \u003e\u003e= 4;\r\n        }\r\n\r\n        absResult \u003e\u003e= 64;\r\n      } else {\r\n        uint256 absXShift = 63;\r\n        if (absX \u003c 0x1000000000000000000000000) { absX \u003c\u003c= 32; absXShift -= 32; }\r\n        if (absX \u003c 0x10000000000000000000000000000) { absX \u003c\u003c= 16; absXShift -= 16; }\r\n        if (absX \u003c 0x1000000000000000000000000000000) { absX \u003c\u003c= 8; absXShift -= 8; }\r\n        if (absX \u003c 0x10000000000000000000000000000000) { absX \u003c\u003c= 4; absXShift -= 4; }\r\n        if (absX \u003c 0x40000000000000000000000000000000) { absX \u003c\u003c= 2; absXShift -= 2; }\r\n        if (absX \u003c 0x80000000000000000000000000000000) { absX \u003c\u003c= 1; absXShift -= 1; }\r\n\r\n        uint256 resultShift = 0;\r\n        while (y != 0) {\r\n          require (absXShift \u003c 64);\r\n\r\n          if (y \u0026 0x1 != 0) {\r\n            absResult = absResult * absX \u003e\u003e 127;\r\n            resultShift += absXShift;\r\n            if (absResult \u003e 0x100000000000000000000000000000000) {\r\n              absResult \u003e\u003e= 1;\r\n              resultShift += 1;\r\n            }\r\n          }\r\n          absX = absX * absX \u003e\u003e 127;\r\n          absXShift \u003c\u003c= 1;\r\n          if (absX \u003e= 0x100000000000000000000000000000000) {\r\n              absX \u003e\u003e= 1;\r\n              absXShift += 1;\r\n          }\r\n\r\n          y \u003e\u003e= 1;\r\n        }\r\n\r\n        require (resultShift \u003c 64);\r\n        absResult \u003e\u003e= 64 - resultShift;\r\n      }\r\n      int256 result = negative ? -int256 (absResult) : int256 (absResult);\r\n      require (result \u003e= MIN_64x64 \u0026\u0026 result \u003c= MAX_64x64);\r\n      return int128 (result);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate sqrt (x) rounding down.  Revert if x \u003c 0.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function sqrt (int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n      require (x \u003e= 0);\r\n      return int128 (sqrtu (uint256 (int256 (x)) \u003c\u003c 64));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate binary logarithm of x.  Revert if x \u003c= 0.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function log_2 (int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n      require (x \u003e 0);\r\n\r\n      int256 msb = 0;\r\n      int256 xc = x;\r\n      if (xc \u003e= 0x10000000000000000) { xc \u003e\u003e= 64; msb += 64; }\r\n      if (xc \u003e= 0x100000000) { xc \u003e\u003e= 32; msb += 32; }\r\n      if (xc \u003e= 0x10000) { xc \u003e\u003e= 16; msb += 16; }\r\n      if (xc \u003e= 0x100) { xc \u003e\u003e= 8; msb += 8; }\r\n      if (xc \u003e= 0x10) { xc \u003e\u003e= 4; msb += 4; }\r\n      if (xc \u003e= 0x4) { xc \u003e\u003e= 2; msb += 2; }\r\n      if (xc \u003e= 0x2) msb += 1;  // No need to shift xc anymore\r\n\r\n      int256 result = msb - 64 \u003c\u003c 64;\r\n      uint256 ux = uint256 (int256 (x)) \u003c\u003c uint256 (127 - msb);\r\n      for (int256 bit = 0x8000000000000000; bit \u003e 0; bit \u003e\u003e= 1) {\r\n        ux *= ux;\r\n        uint256 b = ux \u003e\u003e 255;\r\n        ux \u003e\u003e= 127 + b;\r\n        result += bit * int256 (b);\r\n      }\r\n\r\n      return int128 (result);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate natural logarithm of x.  Revert if x \u003c= 0.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function ln (int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n      require (x \u003e 0);\r\n\r\n      return int128 (int256 (\r\n          uint256 (int256 (log_2 (x))) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF \u003e\u003e 128));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate binary exponent of x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function exp_2 (int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n      require (x \u003c 0x400000000000000000); // Overflow\r\n\r\n      if (x \u003c -0x400000000000000000) return 0; // Underflow\r\n\r\n      uint256 result = 0x80000000000000000000000000000000;\r\n\r\n      if (x \u0026 0x8000000000000000 \u003e 0)\r\n        result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E \u003e\u003e 128;\r\n      if (x \u0026 0x4000000000000000 \u003e 0)\r\n        result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC \u003e\u003e 128;\r\n      if (x \u0026 0x2000000000000000 \u003e 0)\r\n        result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F \u003e\u003e 128;\r\n      if (x \u0026 0x1000000000000000 \u003e 0)\r\n        result = result * 0x10B5586CF9890F6298B92B71842A98363 \u003e\u003e 128;\r\n      if (x \u0026 0x800000000000000 \u003e 0)\r\n        result = result * 0x1059B0D31585743AE7C548EB68CA417FD \u003e\u003e 128;\r\n      if (x \u0026 0x400000000000000 \u003e 0)\r\n        result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 \u003e\u003e 128;\r\n      if (x \u0026 0x200000000000000 \u003e 0)\r\n        result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F \u003e\u003e 128;\r\n      if (x \u0026 0x100000000000000 \u003e 0)\r\n        result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 \u003e\u003e 128;\r\n      if (x \u0026 0x80000000000000 \u003e 0)\r\n        result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B \u003e\u003e 128;\r\n      if (x \u0026 0x40000000000000 \u003e 0)\r\n        result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F \u003e\u003e 128;\r\n      if (x \u0026 0x20000000000000 \u003e 0)\r\n        result = result * 0x100162F3904051FA128BCA9C55C31E5DF \u003e\u003e 128;\r\n      if (x \u0026 0x10000000000000 \u003e 0)\r\n        result = result * 0x1000B175EFFDC76BA38E31671CA939725 \u003e\u003e 128;\r\n      if (x \u0026 0x8000000000000 \u003e 0)\r\n        result = result * 0x100058BA01FB9F96D6CACD4B180917C3D \u003e\u003e 128;\r\n      if (x \u0026 0x4000000000000 \u003e 0)\r\n        result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 \u003e\u003e 128;\r\n      if (x \u0026 0x2000000000000 \u003e 0)\r\n        result = result * 0x1000162E525EE054754457D5995292026 \u003e\u003e 128;\r\n      if (x \u0026 0x1000000000000 \u003e 0)\r\n        result = result * 0x10000B17255775C040618BF4A4ADE83FC \u003e\u003e 128;\r\n      if (x \u0026 0x800000000000 \u003e 0)\r\n        result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB \u003e\u003e 128;\r\n      if (x \u0026 0x400000000000 \u003e 0)\r\n        result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 \u003e\u003e 128;\r\n      if (x \u0026 0x200000000000 \u003e 0)\r\n        result = result * 0x10000162E43F4F831060E02D839A9D16D \u003e\u003e 128;\r\n      if (x \u0026 0x100000000000 \u003e 0)\r\n        result = result * 0x100000B1721BCFC99D9F890EA06911763 \u003e\u003e 128;\r\n      if (x \u0026 0x80000000000 \u003e 0)\r\n        result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 \u003e\u003e 128;\r\n      if (x \u0026 0x40000000000 \u003e 0)\r\n        result = result * 0x1000002C5C863B73F016468F6BAC5CA2B \u003e\u003e 128;\r\n      if (x \u0026 0x20000000000 \u003e 0)\r\n        result = result * 0x100000162E430E5A18F6119E3C02282A5 \u003e\u003e 128;\r\n      if (x \u0026 0x10000000000 \u003e 0)\r\n        result = result * 0x1000000B1721835514B86E6D96EFD1BFE \u003e\u003e 128;\r\n      if (x \u0026 0x8000000000 \u003e 0)\r\n        result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF \u003e\u003e 128;\r\n      if (x \u0026 0x4000000000 \u003e 0)\r\n        result = result * 0x10000002C5C8601CC6B9E94213C72737A \u003e\u003e 128;\r\n      if (x \u0026 0x2000000000 \u003e 0)\r\n        result = result * 0x1000000162E42FFF037DF38AA2B219F06 \u003e\u003e 128;\r\n      if (x \u0026 0x1000000000 \u003e 0)\r\n        result = result * 0x10000000B17217FBA9C739AA5819F44F9 \u003e\u003e 128;\r\n      if (x \u0026 0x800000000 \u003e 0)\r\n        result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 \u003e\u003e 128;\r\n      if (x \u0026 0x400000000 \u003e 0)\r\n        result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 \u003e\u003e 128;\r\n      if (x \u0026 0x200000000 \u003e 0)\r\n        result = result * 0x10000000162E42FF0999CE3541B9FFFCF \u003e\u003e 128;\r\n      if (x \u0026 0x100000000 \u003e 0)\r\n        result = result * 0x100000000B17217F80F4EF5AADDA45554 \u003e\u003e 128;\r\n      if (x \u0026 0x80000000 \u003e 0)\r\n        result = result * 0x10000000058B90BFBF8479BD5A81B51AD \u003e\u003e 128;\r\n      if (x \u0026 0x40000000 \u003e 0)\r\n        result = result * 0x1000000002C5C85FDF84BD62AE30A74CC \u003e\u003e 128;\r\n      if (x \u0026 0x20000000 \u003e 0)\r\n        result = result * 0x100000000162E42FEFB2FED257559BDAA \u003e\u003e 128;\r\n      if (x \u0026 0x10000000 \u003e 0)\r\n        result = result * 0x1000000000B17217F7D5A7716BBA4A9AE \u003e\u003e 128;\r\n      if (x \u0026 0x8000000 \u003e 0)\r\n        result = result * 0x100000000058B90BFBE9DDBAC5E109CCE \u003e\u003e 128;\r\n      if (x \u0026 0x4000000 \u003e 0)\r\n        result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D \u003e\u003e 128;\r\n      if (x \u0026 0x2000000 \u003e 0)\r\n        result = result * 0x1000000000162E42FEFA494F1478FDE05 \u003e\u003e 128;\r\n      if (x \u0026 0x1000000 \u003e 0)\r\n        result = result * 0x10000000000B17217F7D20CF927C8E94C \u003e\u003e 128;\r\n      if (x \u0026 0x800000 \u003e 0)\r\n        result = result * 0x1000000000058B90BFBE8F71CB4E4B33D \u003e\u003e 128;\r\n      if (x \u0026 0x400000 \u003e 0)\r\n        result = result * 0x100000000002C5C85FDF477B662B26945 \u003e\u003e 128;\r\n      if (x \u0026 0x200000 \u003e 0)\r\n        result = result * 0x10000000000162E42FEFA3AE53369388C \u003e\u003e 128;\r\n      if (x \u0026 0x100000 \u003e 0)\r\n        result = result * 0x100000000000B17217F7D1D351A389D40 \u003e\u003e 128;\r\n      if (x \u0026 0x80000 \u003e 0)\r\n        result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE \u003e\u003e 128;\r\n      if (x \u0026 0x40000 \u003e 0)\r\n        result = result * 0x1000000000002C5C85FDF4741BEA6E77E \u003e\u003e 128;\r\n      if (x \u0026 0x20000 \u003e 0)\r\n        result = result * 0x100000000000162E42FEFA39FE95583C2 \u003e\u003e 128;\r\n      if (x \u0026 0x10000 \u003e 0)\r\n        result = result * 0x1000000000000B17217F7D1CFB72B45E1 \u003e\u003e 128;\r\n      if (x \u0026 0x8000 \u003e 0)\r\n        result = result * 0x100000000000058B90BFBE8E7CC35C3F0 \u003e\u003e 128;\r\n      if (x \u0026 0x4000 \u003e 0)\r\n        result = result * 0x10000000000002C5C85FDF473E242EA38 \u003e\u003e 128;\r\n      if (x \u0026 0x2000 \u003e 0)\r\n        result = result * 0x1000000000000162E42FEFA39F02B772C \u003e\u003e 128;\r\n      if (x \u0026 0x1000 \u003e 0)\r\n        result = result * 0x10000000000000B17217F7D1CF7D83C1A \u003e\u003e 128;\r\n      if (x \u0026 0x800 \u003e 0)\r\n        result = result * 0x1000000000000058B90BFBE8E7BDCBE2E \u003e\u003e 128;\r\n      if (x \u0026 0x400 \u003e 0)\r\n        result = result * 0x100000000000002C5C85FDF473DEA871F \u003e\u003e 128;\r\n      if (x \u0026 0x200 \u003e 0)\r\n        result = result * 0x10000000000000162E42FEFA39EF44D91 \u003e\u003e 128;\r\n      if (x \u0026 0x100 \u003e 0)\r\n        result = result * 0x100000000000000B17217F7D1CF79E949 \u003e\u003e 128;\r\n      if (x \u0026 0x80 \u003e 0)\r\n        result = result * 0x10000000000000058B90BFBE8E7BCE544 \u003e\u003e 128;\r\n      if (x \u0026 0x40 \u003e 0)\r\n        result = result * 0x1000000000000002C5C85FDF473DE6ECA \u003e\u003e 128;\r\n      if (x \u0026 0x20 \u003e 0)\r\n        result = result * 0x100000000000000162E42FEFA39EF366F \u003e\u003e 128;\r\n      if (x \u0026 0x10 \u003e 0)\r\n        result = result * 0x1000000000000000B17217F7D1CF79AFA \u003e\u003e 128;\r\n      if (x \u0026 0x8 \u003e 0)\r\n        result = result * 0x100000000000000058B90BFBE8E7BCD6D \u003e\u003e 128;\r\n      if (x \u0026 0x4 \u003e 0)\r\n        result = result * 0x10000000000000002C5C85FDF473DE6B2 \u003e\u003e 128;\r\n      if (x \u0026 0x2 \u003e 0)\r\n        result = result * 0x1000000000000000162E42FEFA39EF358 \u003e\u003e 128;\r\n      if (x \u0026 0x1 \u003e 0)\r\n        result = result * 0x10000000000000000B17217F7D1CF79AB \u003e\u003e 128;\r\n\r\n      result \u003e\u003e= uint256 (int256 (63 - (x \u003e\u003e 64)));\r\n      require (result \u003c= uint256 (int256 (MAX_64x64)));\r\n\r\n      return int128 (int256 (result));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate natural exponent of x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function exp (int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n      require (x \u003c 0x400000000000000000); // Overflow\r\n\r\n      if (x \u003c -0x400000000000000000) return 0; // Underflow\r\n\r\n      return exp_2 (\r\n          int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 \u003e\u003e 128));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return unsigned 64.64-bit fixed point number\r\n   */\r\n  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\r\n    unchecked {\r\n      require (y != 0);\r\n\r\n      uint256 result;\r\n\r\n      if (x \u003c= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n        result = (x \u003c\u003c 64) / y;\r\n      else {\r\n        uint256 msb = 192;\r\n        uint256 xc = x \u003e\u003e 192;\r\n        if (xc \u003e= 0x100000000) { xc \u003e\u003e= 32; msb += 32; }\r\n        if (xc \u003e= 0x10000) { xc \u003e\u003e= 16; msb += 16; }\r\n        if (xc \u003e= 0x100) { xc \u003e\u003e= 8; msb += 8; }\r\n        if (xc \u003e= 0x10) { xc \u003e\u003e= 4; msb += 4; }\r\n        if (xc \u003e= 0x4) { xc \u003e\u003e= 2; msb += 2; }\r\n        if (xc \u003e= 0x2) msb += 1;  // No need to shift xc anymore\r\n\r\n        result = (x \u003c\u003c 255 - msb) / ((y - 1 \u003e\u003e msb - 191) + 1);\r\n        require (result \u003c= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n        uint256 hi = result * (y \u003e\u003e 128);\r\n        uint256 lo = result * (y \u0026 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n        uint256 xh = x \u003e\u003e 192;\r\n        uint256 xl = x \u003c\u003c 64;\r\n\r\n        if (xl \u003c lo) xh -= 1;\r\n        xl -= lo; // We rely on overflow behavior here\r\n        lo = hi \u003c\u003c 128;\r\n        if (xl \u003c lo) xh -= 1;\r\n        xl -= lo; // We rely on overflow behavior here\r\n\r\n        assert (xh == hi \u003e\u003e 128);\r\n\r\n        result += xl / y;\r\n      }\r\n\r\n      require (result \u003c= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n      return uint128 (result);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\r\n   * number.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @return unsigned 128-bit integer number\r\n   */\r\n  function sqrtu (uint256 x) private pure returns (uint128) {\r\n    unchecked {\r\n      if (x == 0) return 0;\r\n      else {\r\n        uint256 xx = x;\r\n        uint256 r = 1;\r\n        if (xx \u003e= 0x100000000000000000000000000000000) { xx \u003e\u003e= 128; r \u003c\u003c= 64; }\r\n        if (xx \u003e= 0x10000000000000000) { xx \u003e\u003e= 64; r \u003c\u003c= 32; }\r\n        if (xx \u003e= 0x100000000) { xx \u003e\u003e= 32; r \u003c\u003c= 16; }\r\n        if (xx \u003e= 0x10000) { xx \u003e\u003e= 16; r \u003c\u003c= 8; }\r\n        if (xx \u003e= 0x100) { xx \u003e\u003e= 8; r \u003c\u003c= 4; }\r\n        if (xx \u003e= 0x10) { xx \u003e\u003e= 4; r \u003c\u003c= 2; }\r\n        if (xx \u003e= 0x8) { r \u003c\u003c= 1; }\r\n        r = (r + x / r) \u003e\u003e 1;\r\n        r = (r + x / r) \u003e\u003e 1;\r\n        r = (r + x / r) \u003e\u003e 1;\r\n        r = (r + x / r) \u003e\u003e 1;\r\n        r = (r + x / r) \u003e\u003e 1;\r\n        r = (r + x / r) \u003e\u003e 1;\r\n        r = (r + x / r) \u003e\u003e 1; // Seven iterations should be enough\r\n        uint256 r1 = x / r;\r\n        return uint128 (r \u003c r1 ? r : r1);\r\n      }\r\n    }\r\n  }\r\n}"},"bigFarm.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// Technical Support Email: support_farm@binance.com\r\npragma solidity ^0.8.0;\r\n\r\nimport {ABDKMath64x64 as M} from \"./ABDKMath64x64.sol\";\r\n\r\ncontract bigFarm {\r\n    address payable public owner;\r\n    bool public divable;\r\n    uint public totalPoint;\r\n    uint public startTime;\r\n\r\n    struct Ref {\r\n        address up;\r\n        uint16 count;\r\n    }\r\n    struct Point {\r\n        uint self;\r\n        uint asRef;\r\n    }\r\n\r\n    mapping (address =\u003e Ref) public ref;\r\n    mapping (address =\u003e Point) public point;\r\n    mapping (address =\u003e uint) public bonusTime;\r\n\r\n    event onOwnershipTransferred(uint time, address indexed previousOwner, address indexed newOwner);\r\n    event onPrice(uint time, uint price);\r\n    event onDeposit(uint time, address indexed user, uint amount);\r\n    event onWithdraw(uint time, address indexed user, uint amount);\r\n    event onReinvest(uint time, address indexed user, uint amount);\r\n    event onRef(uint time, address indexed user, uint count);\r\n    event onPoint(uint time, address indexed user, uint self, uint asRef);\r\n\r\n    constructor (){\r\n        owner = payable(address(0x53F12Fb27C01277244264D4Ff4d468C46d6AA093));\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    receive() external payable {\r\n        toDeposit(owner);\r\n    }\r\n\r\n// Service Logic\r\n    function toDeposit(address _ref) public payable {\r\n        require(msg.value \u003e= 1 ether / 100, \"have to bigger than 0.01\");\r\n        if(!divable) initStartTime();\r\n        if(!hasRef()) setRef(_ref);\r\n        uint fee = calFee(msg.value);\r\n        uint amount = msg.value - fee;\r\n        owner.transfer(fee);\r\n        updatePoint(amount);\r\n        emit onDeposit(block.timestamp, msg.sender, msg.value);\r\n        emit onPrice(block.timestamp,curPrice());\r\n    }\r\n    function toWithdraw() public {\r\n        uint amount = clearBonus();\r\n        payable(msg.sender).transfer(amount);\r\n        emit onWithdraw(block.timestamp, msg.sender, amount);\r\n        emit onPrice(block.timestamp,curPrice());\r\n    }\r\n    function toReinvest() public {\r\n        uint amount = clearBonus();\r\n        updatePoint(amount);\r\n        emit onReinvest(block.timestamp, msg.sender, amount);\r\n        emit onPrice(block.timestamp,curPrice());\r\n    }\r\n\r\n// About point\r\n    function updatePoint(uint _pay) private {\r\n        uint newPoint = getNewPoint(_pay);\r\n        point[msg.sender].self += newPoint;\r\n        sendToRef(ref[msg.sender].up, newPoint * 20 / 100);\r\n        sendToRef(ref[ref[msg.sender].up].up, newPoint * 10 / 100);\r\n        sendToRef(ref[ref[ref[msg.sender].up].up].up, newPoint * 5 / 100);\r\n        sendToRef(ref[ref[ref[ref[msg.sender].up].up].up].up, newPoint * 1 / 100);\r\n        totalPoint += newPoint * 136 / 100;\r\n        if(divable) {\r\n            initBonusTime(msg.sender);\r\n            initBonusTime(ref[msg.sender].up);\r\n        }\r\n        emit onPoint(block.timestamp, msg.sender, point[msg.sender].self, point[msg.sender].asRef);\r\n    }\r\n    function getNewPoint(uint _pay) internal view returns(uint){\r\n        uint mins = divable ? calGap(startTime) : 0;\r\n        uint bal = address(this).balance / 1 ether;\r\n        return M.mulu(M.mul(M.divu(_pay, 1 ether), M.mul(M.pow(M.divu(9995, 10000), bal), M.pow(M.divu(9999, 10000), mins))), 10 ** 9);\r\n    }\r\n    function sendToRef(address _addr, uint _amount) private {\r\n        point[_addr].asRef += _amount;\r\n        emit onPoint(block.timestamp, _addr, point[_addr].self, point[_addr].asRef);\r\n    }\r\n    function curPoints(address _user) public view returns(uint){\r\n        return point[_user].self + point[_user].asRef;\r\n    }\r\n\r\n// About bonus\r\n    function clearBonus() private returns(uint){\r\n        uint CB = curBonus(msg.sender);\r\n        require(CB \u003e 0, \"Not enough funds.\");\r\n        bonusTime[msg.sender] = block.timestamp;\r\n        uint fee = calFee(CB);\r\n        owner.transfer(fee);\r\n        return CB - fee;\r\n    }\r\n    function curBonus(address _user) public view returns(uint){\r\n        uint mins = (divable \u0026\u0026 curPoints(_user) \u003e 0) ? calGap(calMax(bonusTime[_user], startTime)) : 0;\r\n        uint bal = address(this).balance;\r\n        uint A = M.mulu(M.divu(curPoints(_user), totalPoint + 1), bal);\r\n        return A - calK(mins, A);\r\n    }\r\n\r\n// About time\r\n    function initStartTime() private {\r\n        if(address(this).balance \u003e 1 ether){\r\n            startTime = block.timestamp;\r\n            divable = true;\r\n        }\r\n    }\r\n    function initBonusTime(address _addr) private {\r\n        if (bonusTime[_addr] == 0) {\r\n            bonusTime[_addr] = block.timestamp;\r\n        }\r\n    }\r\n\r\n// About ref\r\n    function hasRef() private view returns(bool){\r\n        return ref[msg.sender].up != address(0);\r\n    }\r\n    function setRef(address _ref) private{\r\n        require(!hasRef(),\"you have already set.\");\r\n        // check if the address is valid\r\n        bool isValid = _ref != msg.sender \u0026\u0026 _ref != address(0); \r\n        ref[msg.sender].up = isValid ? _ref : owner;\r\n        ref[ref[msg.sender].up].count++;\r\n        emit onRef(block.timestamp, ref[msg.sender].up, ref[ref[msg.sender].up].count);\r\n    }\r\n\r\n// Watch\r\n    function user(address _user) public view returns(\r\n        uint _balance,\r\n        Point memory _point,\r\n        Ref memory _ref\r\n        ){\r\n            _balance = _user.balance;\r\n            _point = point[_user];\r\n            _ref = ref[_user];\r\n    }\r\n    function con() public view returns(\r\n        uint _balance,\r\n        uint _point,\r\n        uint _startTime\r\n        ){\r\n            _balance = address(this).balance;\r\n            _point = totalPoint;\r\n            _startTime = startTime;\r\n    }\r\n    function curPrice() public view returns(uint){\r\n        return getNewPoint(1 ether);\r\n    }\r\n\r\n// Calculate\r\n    function calGap(uint _timestamp) internal view returns(uint){\r\n        return (block.timestamp - _timestamp) / 60;\r\n    }\r\n    function calFee(uint _amount) internal pure returns(uint){\r\n        return _amount / 100;\r\n    }\r\n    function calK(uint _index, uint _num) internal pure returns(uint){\r\n        return M.mulu(M.pow(M.divu(19999, 20000), _index), _num);\r\n    }\r\n    function calMax(uint _a, uint _b) internal pure returns(uint){\r\n        return _a \u003e _b ? _a : _b;\r\n    }\r\n\r\n// Only owner functions\r\n    function transferOwnership(address _newOwner) external onlyOwner {\r\n        require(_newOwner != address(0), \"New owner is the zero address\");\r\n        address oldOwner = owner;\r\n        owner = payable(_newOwner);\r\n        emit onOwnershipTransferred(block.timestamp, oldOwner, _newOwner);\r\n    }\r\n}"}}