/**
 *Submitted for verification at BscScan.com on 2022-03-16
*/

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return payable(msg.sender);
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this;
        // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}

interface IERC20 {
    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function transfer(address recipient, uint256 amount)
    external
    returns (bool);

    function allowance(address owner, address spender)
    external
    view
    returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
}


library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    function sub(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    function div(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    function mod(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}

library Address {
    function isContract(address account) internal view returns (bool) {
        bytes32 codehash;
        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            codehash := extcodehash(account)
        }
        return (codehash != accountHash && codehash != 0x0);
    }

    function sendValue(address payable recipient, uint256 amount) internal {
        require(
            address(this).balance >= amount,
            "Address: insufficient balance"
        );

        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value
        (bool success,) = recipient.call{value : amount}("");
        require(
            success,
            "Address: unable to send value, recipient may have reverted"
        );
    }

    function functionCall(address target, bytes memory data)
    internal
    returns (bytes memory)
    {
        return functionCall(target, data, "Address: low-level call failed");
    }

    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return _functionCallWithValue(target, data, 0, errorMessage);
    }

    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return
        functionCallWithValue(
            target,
            data,
            value,
            "Address: low-level call with value failed"
        );
    }

    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(
            address(this).balance >= value,
            "Address: insufficient balance for call"
        );
        return _functionCallWithValue(target, data, value, errorMessage);
    }

    function _functionCallWithValue(
        address target,
        bytes memory data,
        uint256 weiValue,
        string memory errorMessage
    ) private returns (bytes memory) {
        require(isContract(target), "Address: call to non-contract");

        (bool success, bytes memory returndata) = target.call{value : weiValue}(
        data
        );
        if (success) {
            return returndata;
        } else {
            if (returndata.length > 0) {
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

contract Ownable is Context {
    address private _owner;
    address private _previousOwner;

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    constructor() {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(_owner == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    function waiveOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(
            newOwner != address(0),
            "Ownable: new owner is the zero address"
        );
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

interface IUniswapV2Factory {
    function getPair(address tokenA, address tokenB)
    external
    view
    returns (address pair);

    function createPair(address tokenA, address tokenB)
    external
    returns (address pair);
}

interface IUniswapRouter {
    function factory() external pure returns (address);

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;
}

 

contract LeopardToken is Context, IERC20, Ownable {
    using SafeMath for uint256;
    using Address for address;

    string private _name ;
    string private _symbol ;
    uint8 private  _decimals;
 
    uint256 private _totalSupply;

 
    address public deadAddress = 0x000000000000000000000000000000000000dEaD;
 
    address public  receiveAddress = 0xB6f0Fe081D974e8DA8fb2B4C0537D9A8692F27CA;

 
    address public  backFlowAddress = 0xE82e152d18001ad1CF0aE187D44570BbBCf5f225;
 
    address public  lpAddress = 0x7a11d8D70E9B3d62fF16c2d21d788ECb687F7D2a;
 
    address public  marketingAddress = 0x165566d6d1DA9DC28E33B06DDF362dEdB4c33A3F;
 
    address public  fundingAddress = 0xd4AfCb4915F604E421F454fd8cAECCB1bbD2E172;
 
    address public  luckyPoolAddress = 0xDA0788B41895638E2266D0870Ac2D5F08828D6E9;
    
 
     mapping(address => bool) public tradeWhiteMap;
    mapping(address => bool) public whiteMap;
    mapping(address => uint256) public _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    mapping(uint256 => address) public rankListMap;
    uint256 public commonId = 1;

 
    uint256 public destroyBuyrate = 10;
 
    uint256 public backFlowBuyRate = 15;
 
    uint256 public rankBuyRate = 5;
 
    uint256 public lpBuyRate = 40;
 
    uint256 public marketingBuyRate = 50;
 
    uint256 public fundingBuyRate = 20;
 
    uint256 public luckyPoolBuyRate = 10;
    uint256 public tradeBuyTotalRate = 150;
 
 
    uint256 public destroySellrate = 10;
 
    uint256 public backFlowSellRate = 20;
 
    uint256 public lpSellRate = 40;
 
    uint256 public marketingSellRate = 50;
 
    uint256 public fundingSellRate = 20;
 
    uint256 public luckyPoolSellRate = 10; 
    uint256 public tradeSellTotalRate = 150;
    
 
    uint256 public transferRate = 150;
    uint256 public maxRate = 1000;

    uint256 public startTTime = 1653753600;
    uint256 public minSupply = 100000000 * 1e18;
 
    // uint256 public temporaryLPAmount;
    // uint256 public temporaryMarketingAmount;
    // uint256 public temporaryFundingAmount;
    // uint256 public temporaryLuckyPoolAmount;

    address public uniswapPair;
    IUniswapRouter uniswapV2Router;

    constructor() {
        _name = "Leopard Token";
        _symbol = "Leopard";
        _decimals = 18;

        _totalSupply = 10000000000 * 1e18;
        _balances[receiveAddress] = 10000000000 * 1e18;
        emit Transfer(address(0), receiveAddress, 10000000000 * 1e18);

 
        whiteMap[msg.sender] = true;
        whiteMap[address(this)] = true;
        whiteMap[receiveAddress] = true;
        
        whiteMap[backFlowAddress] = true;
        whiteMap[lpAddress] = true;
        whiteMap[marketingAddress] = true;
        whiteMap[fundingAddress] = true;
        whiteMap[luckyPoolAddress] = true; 

 
        uniswapV2Router = IUniswapRouter(
            0x10ED43C718714eb63d5aA57B78B54704E256024E
        );
        uniswapPair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(
            address(this),
            0x55d398326f99059fF775485246999027B3197955
        );
        _allowances[address(this)][address(uniswapV2Router)] = _totalSupply;
    }

    function setStartTradeTime(uint256 _value)public onlyOwner {
        startTTime = _value;
    }

    function setTradeWhiteAddress(address _user, bool _value )public onlyOwner {
        tradeWhiteMap[_user] = _value;
    }

    function setWhiteAddress(address _user, bool _value )public onlyOwner {
        whiteMap[_user] = _value;
    }

    function setLpAddress(address _uniswapPair )public onlyOwner {
        uniswapPair = _uniswapPair;
    }

    function initAddress(address _backFlowAddress, address _lpAddress,  address _marketingAddress,
                         address _fundingAddress, address _luckyPoolAddress) public onlyOwner {
        backFlowAddress = _backFlowAddress;
        lpAddress = _lpAddress;
        marketingAddress = _marketingAddress;
        fundingAddress = _fundingAddress;
        luckyPoolAddress = _luckyPoolAddress;
    }
 
    function initBuyRate(uint256 _destroyBuyrate, uint256 _backFlowBuyRate, uint256 _rankBuyRate,
                        uint256 _lpBuyRate, uint256 _marketingBuyRate , uint256 _fundingBuyRate,
                        uint256 _luckyPoolBuyRate, uint256 _tradeBuyTotalRate) public onlyOwner {
        destroyBuyrate = _destroyBuyrate;
        backFlowBuyRate = _backFlowBuyRate;
        rankBuyRate = _rankBuyRate;
        lpBuyRate = _lpBuyRate;
        marketingBuyRate = _marketingBuyRate;
        fundingBuyRate = _fundingBuyRate;
        luckyPoolBuyRate = _luckyPoolBuyRate;
        tradeBuyTotalRate = _tradeBuyTotalRate;
    } 

    function initSellRate(uint256 _destroySellrate, uint256 _backFlowSellRate, uint256 _lpSellRate,
                            uint256 _marketingSellRate, uint256 _fundingSellRate ,
                            uint256 _luckyPoolSellRate , uint256 _tradeSellTotalRate) public onlyOwner {
        destroySellrate = _destroySellrate;
        backFlowSellRate = _backFlowSellRate;
        lpSellRate = _lpSellRate;
        marketingSellRate = _marketingSellRate;
        fundingSellRate = _fundingSellRate;
        luckyPoolSellRate = _luckyPoolSellRate; 
        tradeSellTotalRate = _tradeSellTotalRate ;
    } 

    event SwapTokensForToken(uint256 amountIn, address[] path);

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function totalSupply() public view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function allowance(address owner, address spender)public view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
         _approve(
            _msgSender(),
            spender,
            _allowances[_msgSender()][spender].add(addedValue)
        );
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve( _msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue,"ERC20: decreased allowance below zero")
        );
        return true;
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function _approve( address owner, address spender, uint256 amount) private {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
  
    // function getCirculatingSupply() public view returns (uint256) {
    //     return _totalSupply.sub(balanceOf(deadAddress));
    // }

    function transferToAddressETH(address payable recipient, uint256 amount) private{
        recipient.transfer(amount);
    }

    function transfer(address recipient, uint256 amount) public override returns (bool){
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function transferFrom(address sender,address recipient,uint256 amount) public override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender,_msgSender(), _allowances[sender][_msgSender()].sub(amount,"ERC20: transfer amount exceeds allowance" )
        );
        return true;
    }

    function _transfer( address sender,address recipient, uint256 amount ) private returns (bool) {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");
       
        if(block.timestamp < startTTime){
            require( tradeWhiteMap[sender]  || tradeWhiteMap[recipient]   , " ERC20: error");
        }

        if (whiteMap[sender] || whiteMap[recipient]) {
 
            return _basicTransfer(sender, recipient, amount);
            
        }else{
            
            uint256 feeTotalAmount ;
            if (sender == uniswapPair ) {
 
                feeTotalAmount = amount.mul(tradeBuyTotalRate).div(maxRate);
                _balances[address(this)] = _balances[address(this)].add(feeTotalAmount);
                emit Transfer(sender, address(this), feeTotalAmount);

 
                _destroy(amount,destroyBuyrate);
 
                _backFlow(amount,backFlowBuyRate);
 
               // uint256 rankBuyAmount = amount.mul(rankBuyRate).div(maxRate);
                rankReward(amount);
                rankListMap[commonId]=recipient;
                commonId++;
 
                uint256 lpBuyAmount = amount.mul(lpBuyRate).div(maxRate);
                //temporaryLPAmount = temporaryLPAmount.add(lpBuyAmount);
                _balances[lpAddress] = _balances[lpAddress].add(lpBuyAmount);
                _balances[address(this)] = _balances[address(this)].sub(lpBuyAmount);
                emit Transfer(address(this), lpAddress, lpBuyAmount);

 
                uint256 marketingBuyAmount = amount.mul(marketingBuyRate).div(maxRate);
                // temporaryMarketingAmount = temporaryMarketingAmount.add(marketingBuyAmount);
                 _balances[marketingAddress] = _balances[marketingAddress].add(marketingBuyAmount);
                 _balances[address(this)] = _balances[address(this)].sub(marketingBuyAmount);
                emit Transfer(address(this), marketingAddress, marketingBuyAmount);

 
                uint256 fundingBuyAmount = amount.mul(fundingBuyRate).div(maxRate);
                //temporaryFundingAmount = temporaryFundingAmount.add(fundingBuyAmount);
                 _balances[fundingAddress] = _balances[fundingAddress].add(fundingBuyAmount);
                 _balances[address(this)] = _balances[address(this)].sub(fundingBuyAmount);
                emit Transfer(address(this), fundingAddress, fundingBuyAmount);

 
                uint256 luckyPoolBuyAmount = amount.mul(luckyPoolBuyRate).div(maxRate);
                // temporaryLuckyPoolAmount = temporaryLuckyPoolAmount.add(luckyPoolBuyAmount);
                 _balances[luckyPoolAddress] = _balances[luckyPoolAddress].add(luckyPoolBuyAmount);
                 _balances[address(this)] = _balances[address(this)].sub(luckyPoolBuyAmount);
                emit Transfer(address(this), luckyPoolAddress, luckyPoolBuyAmount);
 
            }else if( recipient == uniswapPair){
 
                require(amount <= _balances[sender].mul(99).div(100)   , " ERC20: error");

                feeTotalAmount = amount.mul(tradeSellTotalRate).div(maxRate);
                _balances[address(this)] = _balances[address(this)].add(feeTotalAmount);
                emit Transfer(sender, address(this), feeTotalAmount);

 
                _destroy(amount,destroySellrate);
 
                _backFlow(amount,backFlowSellRate);

 
                _swapLpUsdt(amount);
 
                _swapMarketUsdt(amount);
 
                _swapFundingUsdt(amount);
 
                _swapLuckypoolUsdt(amount);

            }  else {
                
                feeTotalAmount = amount.mul(transferRate).div(maxRate);
                _balances[address(this)] = _balances[address(this)].add(feeTotalAmount);
                emit Transfer(sender, address(this), feeTotalAmount);
           
                 _destroy(amount,transferRate);
            }

            _balances[sender] = _balances[sender].sub(amount);
            _balances[recipient] = _balances[recipient].add(amount.sub(feeTotalAmount));
            emit Transfer(sender, recipient, amount.sub(feeTotalAmount));
            return true;
        } 
        
    }

    function rankReward(uint256 _amount) internal {
        if(commonId==1){
            _destroy(_amount,rankBuyRate);
        }else{
            uint256 perReward= _amount.mul(rankBuyRate).div(5).div(maxRate);
            uint256 deadCoiunt;
            uint256 count = 5 ;
            if(commonId < 5 ){
               count = commonId; 
            }
 
            for(uint256 i=0; i< count; i++ ){
                address _user =  rankListMap[commonId-i-1];
                if(_user!=address(0)){
                    deadCoiunt ++;
                    _balances[_user] = _balances[_user].add(perReward);
                    _balances[address(this)] = _balances[address(this)].sub(perReward);
                    emit Transfer(address(this), _user, perReward); 
                }
            }

            if(deadCoiunt < 5 ){
                 _destroy(_amount, (5-deadCoiunt).mul(rankBuyRate).div(5));
            }
        }
    }

    
 
    function _backFlow(uint256 amount, uint256 _backFlowBuyRate) internal returns(uint256) {
        uint256 backFlowAmount = amount.mul(_backFlowBuyRate).div(maxRate);
        if (backFlowAmount > 0) {
            _balances[backFlowAddress] = _balances[backFlowAddress].add(backFlowAmount);
            _balances[address(this)] = _balances[address(this)].sub(backFlowAmount);
            emit Transfer(address(this), backFlowAddress, backFlowAmount);
        }
        return backFlowAmount;
    }

 
    function _destroy(uint256 amount, uint256 _destroyFeeRate) internal returns(uint256) {
        uint256 feeAmount = amount.mul(_destroyFeeRate).div(maxRate);
        if (feeAmount > 0) {
            uint256 maxDestroyAmount = _totalSupply.sub(minSupply);
            uint256 remainingAmount;
            if(maxDestroyAmount < feeAmount){
                remainingAmount = feeAmount.sub(maxDestroyAmount);
                feeAmount = maxDestroyAmount;
            }
            if(feeAmount>0){
                _balances[deadAddress] = _balances[deadAddress].add(feeAmount);
                _balances[address(this)] = _balances[address(this)].sub(feeAmount);
                emit Transfer(address(this), deadAddress, feeAmount);
                _totalSupply = _totalSupply.sub(feeAmount);
            }
            
            if(remainingAmount > 0){
                _balances[address(this)] = _balances[address(this)].add(remainingAmount); 
            }
        }
        return feeAmount;
    }

    function _basicTransfer( address sender,address recipient, uint256 amount) internal returns (bool) {
        _balances[sender] = _balances[sender].sub( amount,"Insufficient Balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
        return true;
    }

 
    function _swapFundingUsdt(uint256 amount ) internal {
        uint256 feeAmount = amount.mul(fundingSellRate).div(maxRate);
        uint256 temporaryFundingAmount = _balances[fundingAddress];
        if(temporaryFundingAmount > 0){
            _balances[fundingAddress] = _balances[fundingAddress].sub(temporaryFundingAmount);
            _balances[address(this)] = _balances[address(this)].add(temporaryFundingAmount);
            emit Transfer(fundingAddress , address(this), temporaryFundingAmount);
        }

        feeAmount = temporaryFundingAmount.add(feeAmount);
        if (feeAmount > 0) {
            temporaryFundingAmount = 0;
           address[] memory path = new address[](2);
            path[0] = address(this);
            path[1] = 0x55d398326f99059fF775485246999027B3197955;
            swapTokensForToken(feeAmount, fundingAddress, path);
        }
    }

 
    function _swapMarketUsdt(uint256 amount ) internal {
        uint256 feeAmount = amount.mul(marketingSellRate).div(maxRate);
        uint256 temporaryMarketingAmount = _balances[marketingAddress];
        if(temporaryMarketingAmount > 0){
            _balances[marketingAddress] = _balances[marketingAddress].sub(temporaryMarketingAmount);
            _balances[address(this)] = _balances[address(this)].add(temporaryMarketingAmount);
            emit Transfer( marketingAddress,address(this), temporaryMarketingAmount);
        }

        feeAmount = temporaryMarketingAmount.add(feeAmount);
        if (feeAmount > 0) {
            temporaryMarketingAmount = 0;
            address[] memory path = new address[](2);
            path[0] = address(this);
            path[1] = 0x55d398326f99059fF775485246999027B3197955; 
            swapTokensForToken(feeAmount, marketingAddress, path );
        }
    }

 
    function  _swapLpUsdt (uint256 amount ) internal {
        uint256 feeAmount = amount.mul(lpSellRate).div(maxRate);
        uint256 temporaryLPAmount = _balances[lpAddress];
        if(temporaryLPAmount > 0){
            _balances[lpAddress] = _balances[lpAddress].sub(temporaryLPAmount);
            _balances[address(this)] = _balances[address(this)].add(temporaryLPAmount);
            emit Transfer(lpAddress,address(this),  temporaryLPAmount);
        }

        feeAmount = feeAmount.add(temporaryLPAmount);
        if (feeAmount > 0) {
            temporaryLPAmount=0;
            address[] memory path = new address[](2);
            path[0] = address(this);
            path[1] = 0x55d398326f99059fF775485246999027B3197955;
            swapTokensForToken(feeAmount, lpAddress, path);
        }
    }

 
    function _swapLuckypoolUsdt(uint256 amount ) internal {
        uint256 feeAmount = amount.mul(luckyPoolSellRate).div(maxRate);
        uint256 temporaryLuckyPoolAmount = _balances[luckyPoolAddress];
        if(temporaryLuckyPoolAmount > 0){
            _balances[luckyPoolAddress] = _balances[luckyPoolAddress].sub(temporaryLuckyPoolAmount);
            _balances[address(this)] = _balances[address(this)].add(temporaryLuckyPoolAmount);
            emit Transfer(luckyPoolAddress, address(this),  temporaryLuckyPoolAmount);
        }
        feeAmount = feeAmount.add(temporaryLuckyPoolAmount);
        if (feeAmount > 0) {
            temporaryLuckyPoolAmount = 0;
            address[] memory path = new address[](2);
            path[0] = address(this);
            path[1] = 0x55d398326f99059fF775485246999027B3197955;
            swapTokensForToken(feeAmount, luckyPoolAddress,path);
        }
    }


    function swapTokensForToken(uint256 tokenAmount, address to,  address[] memory path) internal {
        _approve(address(this), address(uniswapV2Router), _totalSupply);
        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            tokenAmount,
            0, // accept any amount of token
            path,
            to, // The contract
            block.timestamp
        );
        emit SwapTokensForToken(tokenAmount, path);
    }

    function tokenToken(address _token, uint256 amount) public onlyOwner {
        require(IERC20(_token).balanceOf(address(this)) >= amount, "Insufficient balance");
        IERC20(_token).transfer(msg.sender, amount);
    }
 

}