{"Context.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.17;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}"},"O5CT.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.17;\r\nimport \"./Context.sol\";\r\ncontract OCTAGRAMFIVE is Context {\r\n    mapping(address =\u003e uint256) private _balances; \r\n    mapping (address =\u003e bool) private suspendedAddresses;\r\n    mapping (address =\u003e uint256) public lastBuyBlockNumber;\r\n    mapping(address =\u003e uint256) lastSellBlockNumber;\r\n    mapping(address =\u003e bool) private allowedAddresses;\r\n    uint256 public exchangeRate;\r\n    uint256 public _totalSupply;\r\n    uint256 public totalEtherBalance; \r\n    string public _name;\r\n    string public _symbol;\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    address public owner;\r\n    address payable public feeRecipient;\r\n    uint256 public tokenDistributionFactor;\r\n    uint256 public transactionFeePercentage = 3;\r\n    bool private locked;\r\n    uint256 public lastCallTime;\r\n    uint256 public constant minTimeBetweenCalls = 60 seconds;\r\n    event LogBuy( uint256  tokensToBeAdded, uint256 exchangeRate, address buyer, uint256 etherAmount, uint256 fee);\r\n    event LogSell(address indexed seller, uint256 amount, uint256 exchangeRate, uint256 etherSent, uint256 fee);\r\n    bool private paused = false;\r\n    \r\nconstructor() {\r\n    _name = \"OCTAGRAMFIVE\";\r\n    _symbol = \"O5CT\";\r\n    _mint(msg.sender, 100 * 100 ** decimals());\r\n    owner = msg.sender;\r\n    feeRecipient = payable (0x51d6724C950690006b676D8bE7083C3312069342);\r\n    tokenDistributionFactor = 9 / 10 * 100;\r\n    }\r\n receive() external payable {\r\n    revert(\"Invalid transaction: Ether not accepted\");\r\n}\r\nmodifier onlyOwner {\r\n    require(msg.sender == owner, \"Sender is not the contract owner\");\r\n    _;\r\n    }\r\nmodifier nonReentrant() {\r\n    require(!locked, \"Function is locked\");\r\n    locked = true;\r\n    _;\r\n    locked = false;\r\n}\r\nmodifier onlyBuyAndConstructor() {\r\n    require(msg.sender == address(this) || msg.sender == tx.origin, \"Mint function can only be called from the buy function or constructor\");\r\n    _;\r\n}\r\nmodifier onlySell() {\r\n    require(msg.sender == address(this) || msg.sender == _msgSender(), \"Function can only be called from the sell function.\");\r\n    _;\r\n}\r\nmodifier onlyEOA(address recipient) {\r\n    require(!isContract(recipient), \"Transfer to contract address not allowed\");\r\n    _;\r\n}\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0), \"Invalid new owner address\");\r\n    require(msg.sender != newOwner, \"New owner address must be different from current owner address\");\r\n    require(tx.origin == owner, \"Only the original caller can transfer ownership\");\r\n        owner = newOwner;\r\n    }\r\nfunction isContract(address addr) private view returns (bool) {\r\n    uint size;\r\n    assembly { size := extcodesize(addr) }\r\n    return size \u003e 0;\r\n}\r\n// Function to pause the contract\r\nfunction pause() public onlyOwner {\r\n    paused = true;\r\n}\r\n// Function to unpause the contract\r\nfunction unpause() public onlyOwner {\r\n    paused = false;\r\n}\r\nfunction setTokenDistributionFactor(uint256 _tokenDistributionFactor) public onlyOwner {\r\n        tokenDistributionFactor = _tokenDistributionFactor;\r\n    }\r\nfunction changeFeeRecipient(address _newRecipient) public onlyOwner{\r\n    feeRecipient = payable ( _newRecipient);\r\n\r\n    }\r\n// Function to update the transaction fee percentage\r\nfunction setFeePercentage(uint256 newFeePercentage) public onlyOwner {\r\n    require(newFeePercentage \u003e= 0, \"Fee percentage cannot be negative.\");\r\n    transactionFeePercentage = newFeePercentage;\r\n}\r\nfunction name() public view virtual returns (string memory) {\r\n        return _name;\r\n    }\r\nfunction symbol() public view virtual  returns (string memory) {\r\n        return _symbol;\r\n    }\r\nfunction decimals() public view virtual  returns (uint8) {\r\n        return 0;\r\n    }\r\nfunction totalSupply() public view virtual  returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\nfunction balanceOf(address account) public view virtual  returns (uint256) {\r\n        return _balances[account];\r\n    }\r\nfunction suspendAddress(address _address) public onlyOwner {\r\n    suspendedAddresses[_address] = true;\r\n    }\r\nfunction unsuspendAddress(address _address) public onlyOwner {\r\n    suspendedAddresses[_address] = false;\r\n    }\r\nfunction transfer(address to, uint256 amount) public virtual onlyEOA(to) returns (bool) { \r\n    require(_balances[msg.sender] \u003e= amount, \"Insufficient balance\");\r\n    require(!suspendedAddresses[msg.sender], \"Sender address is suspended\");\r\n    require(msg.sender != to, \"Cannot transfer tokens to yourself\");\r\n    require(_balances[to] + amount \u003e _balances[to], \"Transfer amount causes integer overflow\");\r\n    require(lastCallTime + minTimeBetweenCalls \u003c= block.timestamp, \"Function can only be called once every 60 seconds.\");\r\n    _balances[msg.sender] -= amount;\r\n    _balances[to] += amount;\r\n    emit Transfer(msg.sender, to, amount);\r\n    return true;\r\n}\r\nfunction transferFrom(address from, address to, uint256 amount ) public virtual onlyEOA(to) returns (bool) {\r\n    require(_balances[from] \u003e= amount, \"Insufficient balance\");\r\n    require(!suspendedAddresses[from], \"Sender address is suspended\");\r\n    require(from != to, \"Cannot transfer tokens to yourself\");\r\n    require(_balances[to] + amount \u003e _balances[to], \"Transfer amount causes integer overflow\");\r\n    require(lastCallTime + minTimeBetweenCalls \u003c= block.timestamp, \"Function can only be called once every 60 seconds.\");\r\n    transfer(from, to, amount);\r\n        return true;\r\n    }\r\nfunction trade(address _to, uint256 _value) private {\r\n    // Check if the trade is a swap\r\n    if (msg.data.length \u003e 4) {\r\n        // Revert the transaction if the trade is a swap\r\n        revert();\r\n    }\r\n    // Perform the trade\r\n    transfer(_to, _value);\r\n}\r\nfunction add() public payable onlyOwner {\r\n    totalEtherBalance += msg.value;\r\n    // Calculate the new exchange rate based on the AMM algorithm\r\n    exchangeRate = calculateExchangeRate();\r\n}\r\nfunction calculateExchangeRate() internal view returns (uint256) {\r\n    // Use an AMM algorithm to calculate the new exchange rate based on the total supply and total ether balance\r\n    // Example algorithm: y = k / x where y is the exchange rate, x is the total supply and k is the total ether balance\r\n    return totalEtherBalance / _totalSupply;\r\n}\r\nfunction calculateTokenValue() public view returns (uint256) {\r\n    // Retrieve the user\u0027s token balance\r\n    address user = msg.sender;\r\n    uint256 tokenBalance = balanceOf(user);\r\n    // Calculate the value of the tokens using the exchange rate\r\n    return tokenBalance * exchangeRate;\r\n}\r\nfunction buy() public payable nonReentrant onlyBuyAndConstructor{\r\n    // Make sure the amount of ether sent is greater than 0\r\n    require(!paused || msg.sender == owner, \"Buying tokens is currently paused.\");\r\n    require(lastCallTime + minTimeBetweenCalls \u003c= block.timestamp, \"Function can only be called once every 60 seconds.\");\r\n    lastCallTime = block.timestamp;\r\n    require(!suspendedAddresses[msg.sender], \"Sender address is suspended\");\r\n    require(msg.value \u003e 0, \"Amount of ether must be greater than zero.\");\r\n\trequire(msg.value \u003e= exchangeRate * 100, \"Minimum amount of ether to buy tokens is 5 times the exchange rate.\");\r\n    require(exchangeRate \u003e 0, \"Exchange rate cannot be zero.\");\r\n    require(lastBuyBlockNumber[msg.sender] != block.number, \"Sender has already bought tokens during this block.\");\r\n    // Check if the buyer has enough ether to cover the amount of tokens they are trying to buy\r\n    require(msg.value \u003e= exchangeRate);\r\n    // Update the total ether balance\r\n    uint256 fee = msg.value * transactionFeePercentage / 100;\r\n    totalEtherBalance += msg.value - fee;\r\n    // Calculate the number of tokens that will be added to the buyer\u0027s balance\r\n    uint256 tokensToBeAdded = (msg.value - fee) / exchangeRate * tokenDistributionFactor / 100;\r\n    // Add the tokens that will be added to the buyer\u0027s balance to the buyer\u0027s balance\r\n    _mint(msg.sender, tokensToBeAdded);\r\n    // Send the fee to the designated recipient\r\n    feeRecipient.transfer(fee);\r\n    emit LogBuy( tokensToBeAdded, exchangeRate, msg.sender, msg.value, fee);\r\n    // Calculate the new exchange rate based on the AMM algorithm\r\n    exchangeRate = calculateExchangeRate(); \r\n}\r\nfunction sell(uint256 amount) public payable nonReentrant onlySell{\r\n     // Check that the user has enough tokens to sell\r\n    require(lastCallTime + minTimeBetweenCalls \u003c= block.timestamp, \"Function can only be called once every 60 seconds.\");\r\n    lastCallTime = block.timestamp;\r\n    require(!suspendedAddresses[msg.sender], \"Sender address is suspended\");\r\n    require(amount \u003e 0, \"Amount of tokens to be sold must be greater than zero.\");\r\n    require(balanceOf(_msgSender()) \u003e= amount);\r\n    require(exchangeRate \u003e 0, \"Exchange rate cannot be zero.\");\r\n    require(lastSellBlockNumber[msg.sender] \u003c block.number, \"Sender has already sold tokens during this block.\");\r\n    // Calculate the amount of ether to be sent to the seller\r\n    uint256 etherToBeSent = amount * exchangeRate;\r\n    // Calculate the transaction fee\r\n    uint256 fee = etherToBeSent * transactionFeePercentage / 100;\r\n    // Subtract the fee from the ether to be sent to the seller\r\n    etherToBeSent -= fee;\r\n    // Update the total ether balance\r\n    totalEtherBalance -= etherToBeSent + fee;\r\n    // Burn the desired number of tokens from the seller\u0027s balance\r\n    _burn(_msgSender(), amount);\r\n    // Send the ether (minus the fee) to the seller\r\n    address payable seller = payable(_msgSender());\r\n    seller.transfer(etherToBeSent); \r\n    // Send the fee to the specified address\r\n    feeRecipient.transfer(fee);\r\n    emit LogSell(seller, amount, exchangeRate, etherToBeSent, fee);\r\n    // Calculate the new exchange rate based on the AMM algorithm\r\n    exchangeRate = calculateExchangeRate();\r\n}\r\nfunction transfer(address from,address to,uint256 amount ) internal onlyEOA(to) virtual {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n        require(msg.sender != to, \"Cannot transfer tokens to yourself\");\r\n        require(_balances[to] + amount \u003e _balances[to], \"Transfer amount causes integer overflow\");\r\n        require(lastCallTime + minTimeBetweenCalls \u003c= block.timestamp, \"Function can only be called once every 10 seconds.\");\r\n        _beforeTokenTransfer(from, to, amount);\r\n        uint256 fromBalance = _balances[from];\r\n        require(fromBalance \u003e= amount, \"ERC20: transfer amount exceeds balance\");\r\n         _balances[from] = fromBalance - amount;\r\n         _balances[to] += amount;\r\n        _afterTokenTransfer(from, to, amount);\r\n}\r\nfunction _mint(address account, uint256 amount) internal virtual onlyBuyAndConstructor {\r\n    require(account != address(0), \"ERC20: mint to the zero address\");\r\n    _beforeTokenTransfer(address(0), account, amount);\r\n    _totalSupply += amount;\r\n     _balances[account] += amount;\r\n     _afterTokenTransfer(address(0), account, amount);\r\n}\r\nfunction _burn(address account, uint256 amount) internal virtual onlySell{\r\n    require(account != address(0), \"ERC20: burn from the zero address\");\r\n    uint256 accountBalance = _balances[account];\r\n    require(accountBalance \u003e= amount, \"ERC20: burn amount exceeds balance\");   \r\n     _totalSupply -= amount;\r\n     _balances[account] = accountBalance - amount;  \r\n}\r\n    function _burnFromTotalSupply(uint256 amount) internal onlySell{\r\n    // Decrease the total supply by the specified amount\r\n    _totalSupply = _totalSupply - amount;\r\n   }\r\nfunction _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {\r\n    // Override this function to execute code before a token transfer\r\n}\r\nfunction _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {\r\n    // Override this function to execute code after a token transfer\r\n}\r\n}\r\n"}}