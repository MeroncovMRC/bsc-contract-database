{"NEMO (1).sol":{"content":"pragma solidity ^0.4.21;\n\ncontract simpleToken {\n\n    uint256 totalSupply_; \n    string public constant name = \"NEMO\";\n    string public constant symbol = \"NEMO\";\n    uint8 public constant decimals = 18;\n    uint256 public constant initialSupply = 1000000*(10**uint256(decimals));\nuint256 public _taxFee = 10;\nuint256 private _previousTaxFee = _taxFee;\nuint256 public _liquidityFee = 5;\nuint256 private _previousLiquidityFee = _liquidityFee;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    mapping (address =\u003e uint256) balances; \n    mapping (address =\u003e mapping (address =\u003e uint256)) allowed;\n    \n    function totalSupply() public view returns (uint256){\n        return totalSupply_;\n    }\n\n    function balanceOf(address _owner) public view returns (uint256){\n        return balances[_owner];\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256) {\n        return allowed[_owner][_spender];\n  }\n\n    function transfer(address _to, uint256 _value) public returns (bool ) {\n        require(_to != address(0));\n        require(balances[msg.sender] \u003e= _value); \n        balances[msg.sender] = balances[msg.sender] - _value; \n        balances[_to] = balances[_to] + _value; \n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(_value \u003c= balances[_from]);\n        require(_value \u003c= allowed[_from][msg.sender]); \n        balances[_from] = balances[_from] - _value; \n        balances[_to] = balances[_to] + _value; \n        allowed[_from][msg.sender] = allowed[_from][msg.sender] - _value; \n        emit Transfer(_from, _to, _value); \n        return true; \n        } \n\n     function increaseApproval(address _spender, uint _addedValue) public returns (bool) { \n     allowed[msg.sender][_spender] = allowed[msg.sender][_spender] + _addedValue; \n     emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); \n     return true; \n     } \n \n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { \n    uint oldValue = allowed[msg.sender][_spender]; \n    if (_subtractedValue \u003e oldValue) {\n\n        allowed[msg.sender][_spender] = 0;\n    } \n        else {\n        allowed[msg.sender][_spender] = oldValue - _subtractedValue;\n    }\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n    }\n\n    function simpleToken() public {\n        totalSupply_ = initialSupply;\n        balances[msg.sender] = initialSupply;\n        emit Transfer(0x0, msg.sender, initialSupply);\n    }\n}"},"NEMO.sol":{"content":"pragma solidity ^0.4.21;\n\ncontract simpleToken {\n\n    uint256 totalSupply_; \n    string public constant name = \"NEMO\";\n    string public constant symbol = \"NEMO\";\n    uint8 public constant decimals = 18;\n    uint256 public constant initialSupply = 1000000*(10**uint256(decimals));\nuint256 public _taxFee = 10;\nuint256 private _previousTaxFee = _taxFee;\nuint256 public _liquidityFee = 5;\nuint256 private _previousLiquidityFee = _liquidityFee;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    mapping (address =\u003e uint256) balances; \n    mapping (address =\u003e mapping (address =\u003e uint256)) allowed;\n    \n    function totalSupply() public view returns (uint256){\n        return totalSupply_;\n    }\n\n    function balanceOf(address _owner) public view returns (uint256){\n        return balances[_owner];\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256) {\n        return allowed[_owner][_spender];\n  }\n\n    function transfer(address _to, uint256 _value) public returns (bool ) {\n        require(_to != address(0));\n        require(balances[msg.sender] \u003e= _value); \n        balances[msg.sender] = balances[msg.sender] - _value; \n        balances[_to] = balances[_to] + _value; \n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(_value \u003c= balances[_from]);\n        require(_value \u003c= allowed[_from][msg.sender]); \n        balances[_from] = balances[_from] - _value; \n        balances[_to] = balances[_to] + _value; \n        allowed[_from][msg.sender] = allowed[_from][msg.sender] - _value; \n        emit Transfer(_from, _to, _value); \n        return true; \n        } \n\n     function increaseApproval(address _spender, uint _addedValue) public returns (bool) { \n     allowed[msg.sender][_spender] = allowed[msg.sender][_spender] + _addedValue; \n     emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); \n     return true; \n     } \n \n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { \n    uint oldValue = allowed[msg.sender][_spender]; \n    if (_subtractedValue \u003e oldValue) {\n\n        allowed[msg.sender][_spender] = 0;\n    } \n        else {\n        allowed[msg.sender][_spender] = oldValue - _subtractedValue;\n    }\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n    }\n\n    function simpleToken() public {\n        totalSupply_ = initialSupply;\n        balances[msg.sender] = initialSupply;\n        emit Transfer(0x0, msg.sender, initialSupply);\n    }\n}"}}