// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

   /** By using opXOns.com, you acknowledge that you have read, understood, and you accept full responsibility for your investment decisions.
* OpXOns.com operates using decentralized smart contracts, which eliminates the need for registration or storing user information in a database.
* We never request your wallet’s private keys or maintain your funds.
* To interact with the smart contract options, you’ll need a web3-compatible browser equipped with a wallet extension like MetaMask and the appropriate network configuration.
* Even if the opXOns website experiences disruptions, the smart contracts on the blockchain will continue to function.
* The “Current Price” is obtained through the Binance API, while the “Reserved Price” is retrieved via the “AggregatorV3Interface” address embedded within the smart contract code.
* Blockchain timestamps are determined by the network’s consensus mechanism, which considers the timestamps generated by various nodes in the network. Slight discrepancies may occur due to differences in system clocks or time zones among nodes. To ensure the successful execution of a smart contract option, avoid waiting until the last minute to initiate the process.
* Market Volatility: Cryptocurrency markets are known for their high price volatility. The value of your investments may fluctuate significantly within short periods, leading to potential losses.
* Regulatory Risks: Cryptocurrencies are subject to evolving regulations across different jurisdictions. Changes in regulations may impact the value, liquidity, or legality of your investments.
* Technological Risks: Cryptocurrency investments rely on blockchain technology and digital wallets. Technical issues, cyberattacks, or software vulnerabilities may lead to the loss or theft of your assets.
* Liquidity Risks: Some cryptocurrencies may have limited liquidity, making it difficult to buy or sell them at desired prices or within desired timeframes. This could impact your ability to realize gains or exit positions.
* No Guarantees: Investing in cryptocurrencies is speculative, and there are no guarantees of profit or returns. You should be prepared to lose some or all of your investment.
* Tax Implications: Cryptocurrency transactions may have tax implications, depending on your jurisdiction. It is your responsibility to understand and comply with your local tax laws.
     */

interface AggregatorV3Interface {
  function decimals() external view returns (uint8);
  function description() external view returns (string memory);
  function version() external view returns (uint256);
  function getRoundData(uint80 _roundId)
    external
    view
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    );
  function latestRoundData()
    external
    view
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    );
}

interface IERC20 {
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
    function releaseAfter() external view returns (uint256);
}

interface IERC20Permit {
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
    function nonces(address owner) external view returns (uint256);
    function DOMAIN_SEPARATOR() external view returns (bytes32);
}

library Address {
    function isContract(address account) internal view returns (bool) {
        return account.code.length > 0;
    }
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");
        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, "Address: low-level call failed");
    }
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }
    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }
    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }
    function verifyCallResultFromTarget(
        address target,
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        if (success) {
            if (returndata.length == 0) {
                require(isContract(target), "Address: call to non-contract");
            }
            return returndata;
        } else {
            _revert(returndata, errorMessage);
        }
    }
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            _revert(returndata, errorMessage);
        }
    }
    function _revert(bytes memory returndata, string memory errorMessage) private pure {
        if (returndata.length > 0) {
            assembly {
                let returndata_size := mload(returndata)
                revert(add(32, returndata), returndata_size)
            }
        } else {
            revert(errorMessage);
        }
    }
}

library SafeERC20 {
    using Address for address;
    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }
    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }
    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        require(
            (value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }
    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 oldAllowance = token.allowance(address(this), spender);
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));
    }
    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        unchecked {
            uint256 oldAllowance = token.allowance(address(this), spender);
            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");
            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));
        }
    }
    function forceApprove(IERC20 token, address spender, uint256 value) internal {
        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);
        if (!_callOptionalReturnBool(token, approvalCall)) {
            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));
            _callOptionalReturn(token, approvalCall);
        }
    }
    function safePermit(
        IERC20Permit token,
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal {
        uint256 nonceBefore = token.nonces(owner);
        token.permit(owner, spender, value, deadline, v, r, s);
        uint256 nonceAfter = token.nonces(owner);
        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");
    }
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
    }
    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {
        (bool success, bytes memory returndata) = address(token).call(data);
        return
            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));
    }
}

abstract contract ReentrancyGuard {
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;
    uint256 private _status;
    constructor() {
        _status = _NOT_ENTERED;
    }
    modifier nonReentrant() {
        _nonReentrantBefore();
        _;
        _nonReentrantAfter();
    }
    function _nonReentrantBefore() private {
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
        _status = _ENTERED;
    }
    function _nonReentrantAfter() private {
        _status = _NOT_ENTERED;
    }
    function _reentrancyGuardEntered() internal view returns (bool) {
        return _status == _ENTERED;
    }
}

contract opXOns is ReentrancyGuard {
    using SafeERC20 for IERC20;    
    IERC20 public USDTToken; 
    IERC20 public WBTCToken; 
    address public beneficiary;
    uint64 public holdDuration;
    uint64 public maxTimeToWithdraw;
    address payable public feeAddress;
    uint256 public feePercentage;
    uint256 public releaseTime;
    uint256 public btcAmount;
    uint256 public marketPrice;
    uint256 public strikePrice;
    uint256 public bnbFees;
    bool public isActive = false;
    AggregatorV3Interface internal priceBTCUSDFeed;
    AggregatorV3Interface internal priceBNBUSDFeed;
    constructor(
        uint64 _holdDurationInDays,
        uint64 _maxTimeToWithdrawHours,
        uint256 _btcAmount, 
        uint256 _feePercentage
    ) {
        require(_holdDurationInDays > 0, "Release time must be in the future");
        require(_maxTimeToWithdrawHours > 1, "you should give the option at least 1 hour to withdraw");
        require(_btcAmount > 0, "you need a positive number");
        require(_feePercentage > 0 && _feePercentage <= 100, "Invalid fee percentage");
        priceBTCUSDFeed = AggregatorV3Interface(address(0x264990fbd0A4796A3E3d8E37C4d5F87a3aCa5Ebf));
        priceBNBUSDFeed = AggregatorV3Interface(address(0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE));
        USDTToken = IERC20(0x55d398326f99059fF775485246999027B3197955);
        WBTCToken = IERC20(0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c);
        btcAmount = _btcAmount;
        feePercentage = _feePercentage;
        holdDuration = _holdDurationInDays * 86400;
        maxTimeToWithdraw = _maxTimeToWithdrawHours * 3600;
        feeAddress = payable (msg.sender);
        isActive = true;
    }
    function buyOption() public payable {
        require(isActive = true);
        require(beneficiary == 0x0000000000000000000000000000000000000000, "the option is already bought");
        (, int _priceBTC, , ,) = priceBTCUSDFeed.latestRoundData();
        (, int _priceBNB, , ,) = priceBNBUSDFeed.latestRoundData();
        uint256 _marketPrice = uint256(_priceBTC);
        uint256 _strikePrice = (_marketPrice * btcAmount) / 100000000;
        uint256 _bnbFees = _strikePrice * feePercentage * 1000000 / uint256(_priceBNB);
        require (msg.value > _bnbFees);

        beneficiary = msg.sender;
        releaseTime = block.timestamp + holdDuration;
        marketPrice = _marketPrice;
        strikePrice = _strikePrice;
        feeAddress.transfer(msg.value);
    }
    function balanceOfBTC() public view returns (uint256) {
        return WBTCToken.balanceOf(address(this));
    }
    function balanceOfUSDT() public view returns (uint256) {
        return USDTToken.balanceOf(address(this));
    }
    function release() public nonReentrant {
        require(isActive = true);
        require(block.timestamp >= releaseTime, "Release time has not yet come");
        require(block.timestamp <= releaseTime + maxTimeToWithdraw, "You have will not abel to withdraw any more");
        uint256 amountOfUSDT = balanceOfUSDT();
        require(amountOfUSDT >= strikePrice, "You did not transfer the required amount of USDT to release your BTC");
        uint256 amountOfBTC = balanceOfBTC();
        require(amountOfBTC >= 0, "There is no BTC to Withdraw");
        WBTCToken.safeTransfer(beneficiary, amountOfBTC);
        USDTToken.safeTransfer(feeAddress, amountOfUSDT);
    }
    function refundAll() public {
        require(isActive = true);
        require(msg.sender == feeAddress);
        require(block.timestamp > releaseTime + maxTimeToWithdraw, "The buyer still have a time");
        uint256 amountOfBTC = balanceOfBTC();
        require(amountOfBTC >= 0, "There is no BTC to Refund");
        require(beneficiary != 0x0000000000000000000000000000000000000000);
        WBTCToken.safeTransfer(feeAddress, amountOfBTC);
        uint256 amountOfUSDT = balanceOfUSDT();
        if (amountOfUSDT > 0) {
            USDTToken.safeTransfer(feeAddress, amountOfUSDT);
        }
    }
    function closeContract() public {
        require(isActive = true);
        require(msg.sender == feeAddress);
        uint256 amountOfBTC = balanceOfBTC();
        require(amountOfBTC >= 0, "There is no BTC to Refund");
        require(beneficiary == 0x0000000000000000000000000000000000000000);
        WBTCToken.safeTransfer(feeAddress, amountOfBTC);
        isActive = false;
    }

}