pragma solidity ^0.8.0;

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _setOwner(_msgSender());
    }

    function owner() public view virtual returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract ProxyRegistry is Ownable {
    string public name;
    mapping(address => OwnableDelegateProxy) public proxies;
    mapping(address => bool) public contracts;

    event AuthenticationWhitelisted(address indexed _addr, bool _whitelisted);

    constructor (string memory _name) {
        name = _name;
    }
    
    function registerProxy() public returns (bool) {
        require(address(proxies[_msgSender()]) == address(0));
        OwnableDelegateProxy proxy = new OwnableDelegateProxy(_msgSender(), ProxyRegistry(this));
        proxies[_msgSender()] = proxy;
        return true;
    }
    
    function grantAuthentication (address addr) public onlyOwner {
        contracts[addr] = true;

        emit AuthenticationWhitelisted(addr, true);
    }
    
    function revokeAuthentication (address addr) public onlyOwner {
        contracts[addr] = false;

        emit AuthenticationWhitelisted(addr, false);
    }
}

contract OwnableDelegateProxy is Context {
    address public owner;
    ProxyRegistry public registry;
    bool public revoked;
    
    event Revoked(bool revoked);

    enum HowToCall { Call, DelegateCall }
  
    modifier onlyOwner() {
        require(owner == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    constructor(address newOwner, ProxyRegistry addrRegistry) {
        owner = newOwner;
        registry = addrRegistry;
    }
    
    function setRevoke(bool revoke) public onlyOwner {
        revoked = revoke;
        emit Revoked(revoke);
    }
    
    function proxy(address dest, HowToCall howToCall, bytes memory calldata1) public returns (bool result) {
        require(_msgSender() == owner || (!revoked && registry.contracts(_msgSender())));
        if (howToCall == HowToCall.Call) {
            (result,) = dest.call(calldata1);
        } else if (howToCall == HowToCall.DelegateCall) {
            (result,) = dest.delegatecall(calldata1);
        }
        return result;
    }
    
    function proxyAssert(address dest, HowToCall howToCall, bytes memory calldata1) public {
        require(proxy(dest, howToCall, calldata1));
    }
}