// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.18;

interface IERC20 {
    function totalSupply() external view returns (uint);
    function balanceOf(address account) external view returns (uint);
    function transfer(address recipient, uint amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint);
    function approve(address spender, uint amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint value);
    event Approval(address indexed owner, address indexed spender, uint value);
}

interface IPancakeRouter {
    function addLiquidity(address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline) external returns (uint amountA, uint amountB, uint liquidity);
    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);
}

library SafeERC20 {
    using SafeMath for uint;

    function safeTransfer(IERC20 token, address to, uint value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint value) internal {
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }
    function callOptionalReturn(IERC20 token, bytes memory data) private {
        require(isContract(address(token)), "SafeERC20: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length > 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }

	function isContract(address addr) internal view returns (bool) {
        uint size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}

library SafeMath {

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;

        return c;
    }
}

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
    * @dev Initializes the contract setting the deployer as the initial owner.
    */
    constructor () {
      address msgSender = _msgSender();
      _owner = msgSender;
      emit OwnershipTransferred(address(0), msgSender);
    }

    /**
    * @dev Returns the address of the current owner.
    */
    function owner() public view returns (address) {
      return _owner;
    }
    
    modifier onlyOwner() {
      require(_owner == _msgSender(), "Ownable: caller is not the owner");
      _;
    }

    function transferOwnership(address newOwner) public onlyOwner {
      _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) internal {
      require(newOwner != address(0), "Ownable: new owner is the zero address");
      emit OwnershipTransferred(_owner, newOwner);
      _owner = newOwner;
    }
}
abstract contract ReentrancyGuard {
    bool internal locked;

    modifier noReentrant() {
        require(!locked, "No re-entrancy");
        locked = true;
        _;
        locked = false;
    }
}

contract AbundanceDefi is Ownable, ReentrancyGuard {

    using SafeMath for uint256;
	using SafeERC20 for IERC20;

    address private BUSD_address = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;
    address private WealthToken_address = 0xa9d398823B2CEb247cB47C5CB22be03Fb7c73ACb;
    
    IERC20 public BUSDToken;
    IERC20 public WealthToken;
    IPancakeRouter public pancakeRouter;

    uint256 public constant PERCENTS_DIVIDER = 1000;
    uint256 public constant ADMIN_FEE = 40;
    uint256 public constant ORIGIN_REFERRER_FEE = 750;
    uint256 public  REFERRAL_BREAK_STEP = 4;
    uint256 public  ADD_LIQUIDITY_STEP = 50 ether;
    bool public  ADD_LIQUIDITY_ENABLED = true;
    uint256[] public REFERRAL_PERCENTS = [
        390,
        120,
        75,
        40,
        35,
        30,
        25,
        20,
        15,
        10
    ];
    uint256[] public LEVEL_PRICE = [
        2.5 ether,
        5 ether,
        10 ether,
        25 ether,
        50 ether,
        100 ether,
        250 ether,
        500 ether,
        1000 ether,
        2500 ether  
    ];
    uint256[] public UNLOCK_TOKEN_DISTRIBUTION = [
        250 ether,
        500 ether,
        1_000 ether,
        2_500 ether,
        5_000 ether,
        10_000 ether,
        25_000 ether,
        50_000 ether,
        100_000 ether,
        250_000 ether
    ];
    
    uint256[] public REFERRAL_TOKEN_DISTRIBUTION = [
        15 ether,
        25 ether,
        50 ether,
        100 ether,
        200 ether,
        500 ether,
        1_250 ether,
        2_000 ether,
        4_000 ether,
        10_000 ether
    ];
    

    uint256 public totalParticipate;
    uint256 public totalBUSDReferral;
    uint256 public totalWealthTokenReferral;
    uint256 public totalWealthTokenJoinReward;
    uint256 public totalMissedBUSD;
    uint256 public totalUser;
    

    struct User {
        uint256 start;
        address referrer;
        address originReferrer;
        uint256 currentLevel;
        uint256 totalDeposit;
        uint256 directReferralCount;
        uint256 breakCount;
        uint256 totalJoinReward;
        uint256 totalTokenDirectReward;
        uint256 totalTokenRewardPayed;
        mapping(uint256 => address) directReferrals;
        uint256[10] levels;
        uint256[10] commissionsBUSD;
        uint256[10] teamTurnover;
        uint256[10] MissedBUSD;
    }

    mapping(address => User) public users;

    address payable public projectWallet;
    address payable public FeeWallet;
    address payable public marketingWallet;

    bool public init = false;

    event Newbie(address user);
    event NewParticipate(address indexed user, uint256 time);
    event NewReward(
        address indexed user,
        uint256 totalDeposit,
        uint256 reward,
        uint256 round,
        uint256 time
    );
    event RefBonus(
        address indexed referrer,
        address indexed referral,
        uint256 indexed level,
        uint256 amount
    );
     event referralTokenReward(
        address indexed referrer,
        address indexed referral,
        uint256 amount
    );
    event FeePayed(address indexed user, uint256 amount);
    event unlockTokenReward(address indexed user, uint256 amount);

    constructor() {
        projectWallet = payable(0xefeA72adfB19b8e83718cE8846a94B08ee08e5a4);
        marketingWallet = payable(0x035735Bb4C8496d5C4B8637F06326f6D6D47ebaf);
        FeeWallet = payable(0x3AAb43608c86983e852C2129d24c2E9c5ccD9E7d);

        BUSDToken = IERC20(BUSD_address);
        WealthToken = IERC20(WealthToken_address);
    }

    // initialized the Project
    function launch() public {
        require(msg.sender == projectWallet, "Only owner");
        require(init == false, "Only once");
        init = true;
        users[projectWallet].start = block.timestamp;
        users[projectWallet].currentLevel = 9;
        pancakeRouter = IPancakeRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);
    }

    function unlockLevel(address _upline, uint256 _level, uint256 _amount) public noReentrant {
        require(init, "Not Started Yet");

        User storage user = users[msg.sender];
        require(_level >= 0 && _level <= 9, "Enter correct level");

        if(user.totalDeposit > 0){
            require(user.currentLevel < _level, "you activated this level");
        }
        
        require(_amount + user.totalDeposit == LEVEL_PRICE[_level], "Wrong activate amount");
        require(_amount <= BUSDToken.allowance(msg.sender, address(this)),"Low allowance for BUSD");
        BUSDToken.safeTransferFrom(msg.sender, address(this), _amount);

        user.currentLevel = _level;

        _setUpline(_upline, _amount);
        _updateUplineTurnover(user.referrer, _amount);
        _payCommission(_amount);

        uint256 MarketingFee = _amount * ADMIN_FEE / PERCENTS_DIVIDER;
        BUSDToken.safeTransfer(marketingWallet, MarketingFee);
        emit FeePayed(msg.sender, MarketingFee);


        uint256 tokenJoinReward = UNLOCK_TOKEN_DISTRIBUTION[_level] - user.totalJoinReward;
        user.totalJoinReward += tokenJoinReward;
        totalWealthTokenJoinReward += tokenJoinReward;
        WealthToken.safeTransfer(msg.sender, tokenJoinReward);
        emit unlockTokenReward(msg.sender, tokenJoinReward);

        if(getContractBUSDBalance() >= ADD_LIQUIDITY_STEP && ADD_LIQUIDITY_ENABLED){
            _handleAddLiquidity(getContractBUSDBalance());
        }

        totalUser++;
        if(user.start == 0){
            user.start = block.timestamp;
            emit Newbie(msg.sender);
        }
        user.totalDeposit += _amount;
        
        totalParticipate += _amount;
        emit NewParticipate(msg.sender, block.timestamp);
    }

    function _setUpline(address _upline, uint256 _amount) private {
        User storage user = users[msg.sender];
        User storage uplineUser = users[_upline];
        if (user.referrer == address(0)) {
            if((_upline != address(0) && uplineUser.start > 0) || _upline == projectWallet){
                uplineUser.directReferralCount++;
                if(user.originReferrer == address(0)){
                    user.originReferrer = _upline;
                }
                if(uplineUser.directReferralCount % REFERRAL_BREAK_STEP == 0){
                    address newUpline;
                    newUpline = uplineUser.directReferrals[uplineUser.breakCount];
                    uplineUser.breakCount++;
                    if(newUpline == address(0)){
                        uplineUser.breakCount++;
                        newUpline = uplineUser.directReferrals[uplineUser.breakCount];
                    }
                    if(newUpline != address(0)){
                        _setUpline(newUpline, _amount);
                    }else{
                        _setUpline(projectWallet, _amount);
                    }
                }else{
                    user.referrer = _upline;
                    uplineUser.directReferrals[uplineUser.directReferralCount - 1] = msg.sender;
                    address uplineAddress = user.referrer;
                    for (uint256 i = 0; i < REFERRAL_PERCENTS.length; i++) {
                        if (uplineAddress != address(0)) {
                            users[uplineAddress].levels[i] += 1;
                            uplineAddress = users[uplineAddress].referrer;
                        } else break;
                    }
                }
            }else{
                revert("Invalid referrer address");
            }
        }
    }

    function _updateUplineTurnover(address upline, uint256 depositAmount) internal {
        for (uint256 i = 0; i < REFERRAL_PERCENTS.length; i++) {
            if (upline != address(0)) {
                users[upline].teamTurnover[i] += depositAmount;
                upline = users[upline].referrer;
            } else break;
        }
    }

    function manualAddLiquidity() public onlyOwner {
        if(getContractBUSDBalance() >= ADD_LIQUIDITY_STEP && ADD_LIQUIDITY_ENABLED){
            _handleAddLiquidity(getContractBUSDBalance());
        }
    }

    function _handleAddLiquidity(uint256 contractBUSDBalance) private {
        uint256 amountBusdToSpend = contractBUSDBalance / 2;
        BUSDToken.approve(address(pancakeRouter), amountBusdToSpend);

        address[] memory path = new address[](2);
        path[0] = address(BUSD_address);
        path[1] = address(WealthToken_address);

        uint[] memory amounts = pancakeRouter.swapExactTokensForTokens(amountBusdToSpend, 0, path, address(this), block.timestamp + 10 minutes);
        
        uint256 amountToken = amounts[1];

        uint256 amountBusd = BUSDToken.balanceOf(address(this));
        WealthToken.approve(address(pancakeRouter), amountToken);
        BUSDToken.approve(address(pancakeRouter), amountBusd);

        pancakeRouter.addLiquidity(address(WealthToken_address), address(BUSD_address), amountToken, amountBusd, 0, 0, address(this), block.timestamp + 10 minutes);
    }

    function _payCommission(uint256 _amount) internal {
        User storage user = users[msg.sender];
        address upline = user.referrer;
        address originUpline = user.originReferrer;
        uint256 resCommission;
        uint256 amountRef;
        uint256 finalOriginBUSDCommission;
        for (uint256 i = 0; i < REFERRAL_PERCENTS.length; i++) {
            finalOriginBUSDCommission = _amount;
            if(upline != address(0) && user.currentLevel > users[upline].currentLevel && LEVEL_PRICE[users[upline].currentLevel] > user.totalDeposit){
                finalOriginBUSDCommission = LEVEL_PRICE[users[upline].currentLevel] - user.totalDeposit;
            }
            amountRef = finalOriginBUSDCommission * REFERRAL_PERCENTS[i] / PERCENTS_DIVIDER;
            if (upline != address(0) && LEVEL_PRICE[users[upline].currentLevel] > user.totalDeposit) {
                if(i == 0){
                    uint256 WealthTokenCommission = REFERRAL_TOKEN_DISTRIBUTION[user.currentLevel] - user.totalTokenDirectReward;
                    if(user.currentLevel > users[upline].currentLevel){
                        WealthTokenCommission = REFERRAL_TOKEN_DISTRIBUTION[users[upline].currentLevel] - user.totalTokenDirectReward;
                    }
                    if(upline != originUpline){
                        uint256 WealthTokenCommissionOrigin = WealthTokenCommission * ORIGIN_REFERRER_FEE / PERCENTS_DIVIDER;
                        WealthTokenCommission = WealthTokenCommission - WealthTokenCommissionOrigin;
                        user.totalTokenDirectReward += WealthTokenCommissionOrigin;
                        users[originUpline].totalTokenRewardPayed += WealthTokenCommissionOrigin;
                        totalWealthTokenReferral += WealthTokenCommissionOrigin;
                        WealthToken.safeTransfer(originUpline, WealthTokenCommissionOrigin);
                        emit referralTokenReward(originUpline, msg.sender, WealthTokenCommissionOrigin);
                    }
                    user.totalTokenDirectReward +=  WealthTokenCommission;
                    users[upline].totalTokenRewardPayed += WealthTokenCommission;
                    WealthToken.safeTransfer(upline, WealthTokenCommission);
                    totalWealthTokenReferral += WealthTokenCommission;
                    emit referralTokenReward(upline, msg.sender, WealthTokenCommission);
                }
                users[upline].commissionsBUSD[i] += amountRef;
                BUSDToken.safeTransfer(upline, amountRef);
                totalBUSDReferral += amountRef;
                emit RefBonus(upline, msg.sender, i, amountRef);

                if(user.currentLevel > users[upline].currentLevel){
                    uint256 restLevelAmount = (_amount * REFERRAL_PERCENTS[i] / PERCENTS_DIVIDER) - amountRef;
                    totalMissedBUSD += restLevelAmount;
                    users[upline].MissedBUSD[i] += restLevelAmount;
                    resCommission += restLevelAmount;
                }
                
                upline = users[upline].referrer;
            }else{
                totalMissedBUSD += amountRef;
                users[upline].MissedBUSD[i] += amountRef;
                resCommission += amountRef;
                
                if(upline != address(0)){
                    upline = users[upline].referrer;
                }
            }
        }
        if(resCommission > 0){
            BUSDToken.safeTransfer(FeeWallet, resCommission);
        }
    }

    function getContractBUSDBalance() public view returns (uint256) {
        return BUSDToken.balanceOf(address(this));
    }

    function getContractWealthTokenBalance() public view returns (uint256) {
        return WealthToken.balanceOf(address(this));
    }

    function getUserTotalBUSDEarn(address userAddress)
        public
        view
        returns (uint256)
    {
         uint256 totalBUSDCommissions;
        for(uint256 i = 0; i < 10; i++) {
            totalBUSDCommissions += users[userAddress].commissionsBUSD[i];
        }
        return totalBUSDCommissions;
    }

    function getUserTotalMissedBUSD(address userAddress)
        public
        view
        returns (uint256)
    {
         uint256 totalBUSDMissed;
        for(uint256 i = 0; i < 10; i++) {
            totalBUSDMissed += users[userAddress].MissedBUSD[i];
        }
        return totalBUSDMissed;
    }

    function getUserTotalWealthTokenEarn(address userAddress)
        public
        view
        returns (uint256)
    {
        return users[userAddress].totalTokenRewardPayed;
    }

    function getUserTotalTeamTurnover(address userAddress)
        public
        view
        returns (uint256)
    {
         uint256 teamTurnover;
        for(uint256 i = 0; i < 10; i++) {
            teamTurnover += users[userAddress].teamTurnover[i];
        }
        return teamTurnover;
    }

    function getUserReferrer(address userAddress)
        public
        view
        returns (address)
    {
        return users[userAddress].referrer;
    }

    function getUserDirectReferralMapping(address userAddress, uint256 _index)
        public
        view
        returns (address)
    {
        return users[userAddress].directReferrals[_index];
    }

    function getUserDownlineCount(address userAddress)
        public
        view
        returns (uint256[10] memory referrals)
    {
        return (users[userAddress].levels);
    }

    function getUserMissedBUSD(address userAddress)
        public
        view
        returns (uint256[10] memory missed)
    {
        return (users[userAddress].MissedBUSD);
    }

    function getUserTeamTurnover(address userAddress)
        public
        view
        returns (uint256[10] memory turnover)
    {
        return (users[userAddress].teamTurnover);
    }

    function getUserBUSDCommissions(address userAddress)
        public
        view
        returns (uint256[10] memory commissions)
    {
        return (users[userAddress].commissionsBUSD);
    }

    function getUserTotalReferrals(address userAddress)
        public
        view
        returns (uint256)
    {
        return users[userAddress].levels[0];
    }
    function getUserTotalReferralsCount(address userAddress)
        public
        view
        returns (uint256[10] memory count)
    {
        return users[userAddress].levels;
    }
    function getUserTotalDownline(address userAddress)
        public
        view
        returns (uint256)
    {
        uint256 downlineCount;
        for(uint256 i = 0; i < 10; i++) {
            downlineCount += users[userAddress].levels[i];
        }
        return downlineCount;
    }

    function getSiteInfo()
        public
        view
        returns (
            uint256 _totalInvested,
            uint256 _totalBUSDBonus,
            uint256 _totalWealthTokenBonus,
            uint256 _totalUser,
            uint256 _contractBUSDBalance,
            uint256 _contractWealthTokenBalance,
            uint256 _totalMissedBUSD,
            uint256 _totalWealthTokenJoinReward,
            uint256 _totalWealthTokenReward
        )
    {
        return (totalParticipate, totalBUSDReferral,totalWealthTokenReferral, totalUser, getContractBUSDBalance(), getContractWealthTokenBalance(), totalMissedBUSD, totalWealthTokenJoinReward, (totalWealthTokenReferral + totalWealthTokenJoinReward));
    }

    function getUserInfo(address userAddress)
        public
        view
        returns (
            uint256 startCheckpoint,
            uint256 downlineCount,
            uint256 userTotalBUSDCommissions,
            uint256 userTotalWealthTokenCommissions,
            uint256 userTotalMissedBUSD,
            uint256 currentLevel,
            uint256 totalDeposit
        )
    {
        return (
            users[userAddress].start,
            getUserTotalDownline(userAddress),
            getUserTotalBUSDEarn(userAddress),
            getUserTotalWealthTokenEarn(userAddress),
            getUserTotalMissedBUSD(userAddress),
            users[userAddress].currentLevel,
            users[userAddress].totalDeposit
        );
    }

    function getUserTotalWealthTokenReward(address userAddress)
        public
        view
        returns (uint256)
    {
        return getUserTotalWealthTokenEarn(userAddress) + users[userAddress].totalJoinReward;
    }

    function getRequireAmountToActivate(address userAddress)
        public
        view
        returns (uint256)
    {
        uint256 amount;
        User storage user = users[userAddress];
        amount =  LEVEL_PRICE[user.currentLevel] - user.totalDeposit;
        return amount;
    }

    function setAddLiquidityStep(uint256 amount)
        public
        onlyOwner
    {
        ADD_LIQUIDITY_STEP = amount;
    }

    function setAddLiquidityStatus(bool status)
        public
        onlyOwner
    {
        ADD_LIQUIDITY_ENABLED = status;
    }

    function isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(addr)
        }
        return size > 0;
    }
}