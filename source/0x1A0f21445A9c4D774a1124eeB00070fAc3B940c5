
// File: contracts/interface/IPair.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IPair {
    function token0() external view returns (address);
    function token1() external view returns (address);
    function balanceOf(address owner) external view returns (uint);
    function getReserves() external view returns ( uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast );
    function mint(address to) external returns (uint liquidity);
    function burn(address to) external returns (uint amount0, uint amount1);
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
    function skim(address to) external;
    function sync() external;
    function totalSupply() external view returns (uint);
}


// File: contracts/utils/ERC20.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20 {

    uint internal _totalSupply;
    mapping(address => uint) internal _balanceOf;
    mapping(address => mapping(address => uint)) internal _allowance;

    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);

    function _mint(address to, uint value) internal {
        _totalSupply += value;
        _balanceOf[to] += value;
        emit Transfer(address(0), to, value);
    }

    function _burn(address from, uint value) internal {
        _balanceOf[from] -= value;
        _totalSupply -= value;
        emit Transfer(from, address(0), value);
    }

    function _approve(
        address owner,
        address spender,
        uint value
    ) internal virtual {
        _allowance[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    function _transfer(
        address from,
        address to,
        uint value
    ) internal virtual {
        _balanceOf[from] -= value;
        _balanceOf[to] += value;
        emit Transfer(from, to, value);
    }

    function allowance(address owner, address spender) external view virtual returns (uint) {
        return _allowance[owner][spender];
    }

    function _spendAllowance(address owner, address spender, uint value) internal virtual {
        if (_allowance[owner][spender] != type(uint256).max) {
            require(_allowance[owner][spender] >= value, "ERC20: insufficient allowance");
            _allowance[owner][spender] -= value;
        }
    }

    function totalSupply() external view virtual returns (uint) {
        return _totalSupply;
    }

    function balanceOf(address owner) external view virtual returns (uint) {
        return _balanceOf[owner];
    }

    function approve(address spender, uint value) external virtual returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    function transfer(address to, uint value) external virtual returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }
    
    function transferFrom(
        address from,
        address to,
        uint value
    ) external virtual returns (bool) {
        _spendAllowance(from, msg.sender, value);
        _transfer(from, to, value);
        return true;
    }
}


// File: contracts/utils/Permissions.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;


contract Permissions {

    /// @notice permission tpye
    /// mian permission
    uint8 public constant OWNER = 0;
    /// @notice type => address => bool
    mapping (uint8 => mapping(address => bool)) public permissions;
    /// @notice set permission event
    event PermissionSet(uint8 indexed permission, address indexed account, bool indexed value);

    /// @notice check permission
    modifier onlyCaller(uint8 _permission) {
        require(permissions[_permission][msg.sender], "Calls have not allowed");
        _;
    }

    /// @notice set permission
    function _setPermission(uint8 _permission, address _account, bool _value) internal {
        permissions[_permission][_account] = _value;
        emit PermissionSet(_permission, _account, _value);
    }

    /// @notice set permissions
    function setPermissions(uint8[] calldata _permissions, address[] calldata _accounts, bool[] calldata _values) external onlyCaller(OWNER) {
        require(_permissions.length == _accounts.length && _accounts.length == _values.length, "Lengths are not equal");
        for (uint i = 0; i < _permissions.length; i++) {
            _setPermission(_permissions[i], _accounts[i], _values[i]);
        }
    }
    
}

// File: contracts/utils/SafeToken.sol
//SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

interface ERC20Interface {
    function balanceOf(address user) external view returns (uint256);
    function allowance(address owner, address spender) external view returns (uint256);
    function transfer(address to,uint256 amount) external returns(bool);
}

library SafeToken {

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address token,address owner, address spender) internal view returns (uint256) {
        return ERC20Interface(token).allowance(owner,spender);
    }


    function myBalance(address token) internal view returns (uint256) {
        return ERC20Interface(token).balanceOf(address(this));
    }

    function balanceOf(address token, address user) internal view returns (uint256) {
        return ERC20Interface(token).balanceOf(user);
    }

    function safeApprove(address token, address to, uint256 value) internal {
        // bytes4(keccak256(bytes('approve(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), "!safeApprove");
    }

    function safeTransfer(address token, address to, uint256 value) internal {
        // bytes4(keccak256(bytes('transfer(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), "!safeTransfer");
    }

    function safeTransferFrom(address token, address from, address to, uint256 value) internal {
        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), "!safeTransferFrom");
    }

    function safeTransferETH(address to, uint256 value) internal {
        (bool success, ) = to.call{value:value}(new bytes(0));
        require(success, "!safeTransferETH");
    }
}

// File: contracts/utils/SimpliRoute.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../utils/SafeToken.sol";
import "../interface/IPair.sol";

contract SimpliRoute {

    using SafeToken for address;

    /// @notice SimpliRoute
    /// given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset
    function getAmountOut(
        uint amountIn,
        uint reserveIn,
        uint reserveOut,
        uint feeE4
    ) internal pure returns (uint amountOut) {
        uint amountInWithFee = amountIn * feeE4;
        uint numerator = amountInWithFee * reserveOut;
        uint denominator = reserveIn * 10000 + amountInWithFee;
        amountOut = numerator / denominator;
    }

    /// @dev Compute optimal deposit amount
    /// @param amtA amount of token A desired to deposit
    /// @param amtB amonut of token B desired to deposit
    /// @param resA amount of token A in reserve
    /// @param resB amount of token B in reserve
    function optimalDeposit(
        uint256 amtA,
        uint256 amtB,
        uint256 resA,
        uint256 resB,
        uint256 feeE4
    ) internal pure returns (uint256 swapAmt, bool isReversed) {
        if (amtA * resB == amtB * resA) {
            swapAmt = 0;
            isReversed = false;
        }
        // else fix gas
        else if (amtA * resB > amtB * resA) {
            swapAmt = _optimalDepositA(amtA, amtB, resA, resB, feeE4);
            isReversed = false;
        }
        else {
            swapAmt = _optimalDepositA(amtB, amtA, resB, resA, feeE4);
            isReversed = true;
        }
    }

    function _optimalDepositA(
        uint256 amtA,
        uint256 amtB,
        uint256 resA,
        uint256 resB,
        uint256 feeE4
    ) internal pure returns (uint256) {
        require(amtA * resB >= amtB * resA, "Reversed");
        uint256 a = feeE4;
        uint256 b = (1e4 + feeE4) * resA;
        uint256 _c = amtA * resB - amtB * resA;
        uint256 c = _c * 1e4  * resA / (amtB + resB);

        uint256 d = 4 * a * c;
        uint256 e = sqrt(b ** 2 + d);
        uint256 numerator = e - b;
        uint256 denominator = 2*a;
        return numerator / denominator;
    }

    /// @notice get price
    function _price(
        address _tokenIn,
        address _tokenOut,
        address _lpAddress,
        uint _amountIn,
        uint _feeE4
    ) internal view returns(uint _buyAmount){
        IPair _lp = IPair(_lpAddress);
        (uint112 reserveIn, uint112 reserveOut,) = _lp.getReserves();
        /// defult _tokenOut = _token1
        if ( _tokenIn > _tokenOut ) (reserveIn, reserveOut) = (reserveOut, reserveIn);
        _buyAmount = getAmountOut(_amountIn, reserveIn, reserveOut, _feeE4);
    }

    /// @notice get need token amount
    function _getAmountsForLiquidity(
        address _token0,
        address _token1,
        address _lpAddress,
        uint _liquidity
    ) internal view returns(uint _amount0, uint _amount1){
        IPair _lp = IPair(_lpAddress);
        (uint112 reserve0, uint112 reserve1,) = _lp.getReserves();
        /// 默认 _tokenOut = _token1
        if ( _token0 > _token1 ) (reserve0, reserve1) = (reserve1, reserve0);
        uint _totalSupply = _lp.totalSupply();
        _amount0 = _liquidity * reserve0 / _totalSupply;
        _amount1 = _liquidity * reserve1 / _totalSupply;  
    }

    /// @notice swap
    function _sawp(
        address _tokenIn,
        address _tokenOut,
        address _lpAddress,
        uint _amountIn,
        uint _feeE4, // 9975 = 99.75 % => 0.25% fee
        uint _slipE4, // 9000 = 90 % => 10% slippage
        address _to
    ) internal returns(uint _buyAmount){
        IPair _lp = IPair(_lpAddress);
        (uint112 reserveIn, uint112 reserveOut,) = _lp.getReserves();
        /// _tokenOut = _token1
        if ( _tokenIn > _tokenOut ) (reserveIn, reserveOut) = (reserveOut, reserveIn);


        _tokenIn.safeTransfer(_lpAddress, _amountIn);
        
        _amountIn = _tokenIn.balanceOf(_lpAddress) - reserveIn;

        uint _amount1 = getAmountOut(_amountIn, reserveIn, reserveOut, _feeE4);
        uint _amount0 = 0;
        
        if ( _tokenIn > _tokenOut ) (_amount0, _amount1) = (_amount1, _amount0);


        uint _before = _tokenOut.balanceOf(_to);
        _lp.swap(_amount0, _amount1, _to, new bytes(0));
        _buyAmount = _tokenOut.balanceOf(_to) - _before;
        require(_buyAmount >=  _slipE4 * _amount1 / 1e5, "buy error");
    }

    /// @notice buy for add liquidity
    function _addLpForBuy(
        address _tokenA,
        address _tokenB,
        address _lpAddress,
        uint _amountA,
        uint _amountB,
        uint _feeE4,
        address _to
    ) internal {
        IPair _lp = IPair(_lpAddress);
        (uint112 _resA, uint112 _resB,) = _lp.getReserves();
        if ( _tokenA > _tokenB ) (_resA, _resB) = (_resB, _resA);

        (uint _swapAmount, bool _isReversed) = optimalDeposit(_amountA, _amountB, _resA, _resB, _feeE4);
        
        if ( _isReversed ) {
            (_tokenA, _tokenB) = (_tokenB, _tokenA);
            (_amountA, _amountB) = (_amountB, _amountA);
        }
        
        _amountA -= _swapAmount;
        _amountB += _sawp(_tokenA, _tokenB, _lpAddress, _swapAmount, _feeE4, 0, address(this));

        _tokenA.safeTransfer(_lpAddress, _amountA);
        _tokenB.safeTransfer(_lpAddress, _amountB);

        _lp.mint(_to);
    }

    /// @notice mint for add liquidity
    /// @param _minterProvider token provider
    function _addLpForMint(
        address _tokenA,
        address _tokenB,
        address _lpAddress,
        uint _amountA,
        uint _amountB,
        address _minterProvider,
        address _to
    ) internal returns(uint _lpAmount) {
        IPair _lp = IPair(_lpAddress);
        (uint112 _resA, uint112 _resB,) = _lp.getReserves();
        if ( _tokenA > _tokenB ) (_resA, _resB) = (_resB, _resA);
        
        /// @dev A more，mint B
        bool _isMintA = _resA * _amountB > _resB * _amountA;
        uint _addAmount = 0;
        address _mintAddress = _tokenA;
        if (_isMintA ) {
            _addAmount = _amountB * _resA / _resB;
        }
        else {
            /// @dev A more
            _addAmount = _amountA * _resB / _resA;
            _mintAddress = _tokenB;
        }

        if (_addAmount > 0) {
            if (_minterProvider != address(this)) {
                _mintAddress.safeTransferFrom(_minterProvider, address(_lp), _addAmount);
            } else {
               if( _mintAddress == _tokenB ) _amountB += _addAmount;
               else _amountA += _addAmount;
            }
        }
        
        _tokenA.safeTransfer(address(_lp), _amountA);
        _tokenB.safeTransfer(address(_lp), _amountB);

        _lpAmount = _lp.balanceOf(_to);
        _lp.mint(_to);
        _lpAmount = _lp.balanceOf(_to) - _lpAmount;
    }

    /// @notice get back lp
    function _removeLp(
        address _lp,
        uint _liquidity,
        address _to
    ) internal {
        _lp.safeTransfer(_lp, _liquidity);
        IPair(_lp).burn(_to);
    }

    function sqrt(uint x) public pure returns (uint) {
        if (x == 0) return 0;
        uint xx = x;
        uint r = 1;
    
        if (xx >= 0x100000000000000000000000000000000) {
            xx >>= 128;
            r <<= 64;
        }
    
        if (xx >= 0x10000000000000000) {
            xx >>= 64;
            r <<= 32;
        }
        if (xx >= 0x100000000) {
            xx >>= 32;
            r <<= 16;
        }
        if (xx >= 0x10000) {
            xx >>= 16;
            r <<= 8;
        }
        if (xx >= 0x100) {
            xx >>= 8;
            r <<= 4;
        }
        if (xx >= 0x10) {
            xx >>= 4;
            r <<= 2;
        }
        if (xx >= 0x8) {
            r <<= 1;
        }
    
        r = (r + x / r) >> 1;
        r = (r + x / r) >> 1;
        r = (r + x / r) >> 1;
        r = (r + x / r) >> 1;
        r = (r + x / r) >> 1;
        r = (r + x / r) >> 1;
        r = (r + x / r) >> 1; // Seven iterations should be enough
        uint r1 = x / r;
        return (r < r1 ? r : r1);
    }
}

// File: contracts/utils/SlippageERC20.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./ERC20.sol";

contract SlippageERC20 is ERC20 {

    /// @notice permission tpye
    /// main permission
    uint8 public constant OWNER = 0;
    /// mint permission
    uint8 public constant MINTER = 1;

    /// @notice param tpye
    /// from slip, general for sell
    uint8 public constant FROM_SLIP = 2;
    /// to slip, general for buy
    uint8 public constant TO_SLIP = 3;
    /// set slip white list
    uint8 public constant SLIP_WHITE_LIST = 4;
    /// set black list
    uint8 public constant BLACK_LIST = 5;
    /// withdraw token
    uint8 public constant WITHDRAW = 6;
    /// set default tax rate
    uint8 public constant DEFAULT_TAX_RATE = 7;

    /// default tax rate, transfer tax rate except fromSlip, toSlip, slipWhiteList
    uint32 public defaultTaxRateE5 = 0;

    /// @notice permission => caller => isPermission
    mapping (uint8 => mapping(address => bool)) public permissions;
    /// @notice set permission event
    event PermissionSet(uint8 indexed permission, address indexed account, bool indexed value);

    /// @notice check permission
    modifier onlyCaller(uint8 _permission) {
        require(permissions[_permission][msg.sender], "Calls have not allowed");
        _;
    }

    /// @notice from
    mapping(address => uint32) public fromSlipE5;
    /// @notice to
    mapping(address => uint32) public toSlipE5;

    mapping(address => bool) public slipWhiteList;
    mapping(address => bool) public blackList;

    constructor() {
        // set permission for own
        address _owner = msg.sender;
        
        _setPermission(OWNER, _owner, true);
        _setPermission(MINTER, _owner, true);
    }

    /// @notice set permission
    function _setPermission(uint8 _permission, address _account, bool _value) internal {
        permissions[_permission][_account] = _value;
        emit PermissionSet(_permission, _account, _value);
    }

    /// @notice set permissions
    function setPermissions(uint8[] calldata _permissions, address[] calldata _accounts, bool[] calldata _values) external onlyCaller(OWNER) {
        require(_permissions.length == _accounts.length && _accounts.length == _values.length, "Lengths are not equal");
        for (uint i = 0; i < _permissions.length; i++) {
            _setPermission(_permissions[i], _accounts[i], _values[i]);
        }
    }

    /// @notice set
    function setConfig(uint8[] calldata _configTypes, bytes[] calldata _datas) external onlyCaller(OWNER) {
        uint len = _configTypes.length;
        for(uint i = 0; i < len; i++) {
            if (_configTypes[i] == FROM_SLIP) {
                (address _from, uint32 _feeE5) = abi.decode(_datas[i], (address, uint32));
                fromSlipE5[_from] = _feeE5;
            } else if (_configTypes[i] == TO_SLIP) {
                (address _to, uint32 _feeE5) = abi.decode(_datas[i], (address, uint32));
                toSlipE5[_to] = _feeE5;
            } else if (_configTypes[i] == SLIP_WHITE_LIST) {
                (address _account, bool _value) = abi.decode(_datas[i], (address, bool));
                slipWhiteList[_account] = _value;
            } else if (_configTypes[i] == BLACK_LIST) {
                (address _account, bool _value) = abi.decode(_datas[i], (address, bool));
                blackList[_account] = _value;
            } else if (_configTypes[i] == WITHDRAW) {
                (address _to, uint _amount) = abi.decode(_datas[i], (address, uint));
                _balanceOf[address(this)] -= _amount;
                _balanceOf[_to] += _amount;
                emit Transfer(address(this), _to, _amount);
            } else if (_configTypes[i] == DEFAULT_TAX_RATE) {
                (uint32 _feeE5) = abi.decode(_datas[i], (uint32));
                defaultTaxRateE5 = _feeE5;
            }
        }
    }

    /// @notice slipperage transfer
    function _transfer(address _from, address _to, uint256 _amount) internal override {
        require(!blackList[_from] && !blackList[_to], "blacklisted");
        uint _fee = 0;
        if (!slipWhiteList[_from] && !slipWhiteList[_to]) {
            _fee = _amount * (fromSlipE5[_from] + toSlipE5[_to]) / 1e5;
            /// @dev default tax rate without slip
            if ( defaultTaxRateE5 > 0 && _fee == 0) {
                _fee = _amount * defaultTaxRateE5 / 1e5;
            }
            
            if (_fee > 0) {
                _transferSlippage(_from, _to, _amount, _fee);
            }
        }
        _balanceOf[_from] -= _amount;
        _balanceOf[_to] += _amount - _fee;
        emit Transfer(_from, _to, _amount);
        _transferAfter(_from, _to, _amount, _fee);
    }

    /// @notice default transfer fee
    function _transferSlippage(address _from, address, uint256, uint _fee) internal virtual {
        _balanceOf[address(this)] += _fee;
        emit Transfer(_from, address(this), _fee);
    }

    function _transferAfter(address _from, address _to, uint _amount, uint _fee) internal virtual {}

    function burn(uint256 _amount) external {
        _burn(msg.sender, _amount);
    }
}

// File: contracts/work/COIN.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../utils/SlippageERC20.sol";
import "../utils/Permissions.sol";
import "../utils/SimpliRoute.sol";

/// @title SEE
/// @notice total supply 21_000_000, transfer tax 1%, buy and sell tax 10%, sell to u, all tax to taxOwner

contract SEE is SlippageERC20 {
    
    address public taxOwner;
    /// @notice min limit except address
    mapping(address => bool) public noMinLimit;
    event SetNoMinLimit(address indexed _address, bool _noMinLimit);

    address public avoidRobot;
    /// @notice avoid robot, purchase after 20 blocks after sell
    mapping(address => uint) public lastSellBlock;


    function name() external pure returns (string memory) {
        return "SEE Coin";
    }

    function symbol() external pure returns (string memory) {
        return "SEE";
    }

    function decimals() external pure returns (uint8) {
        return 18;
    }

    constructor(address _taxOwner) {
        _mint(msg.sender, 21_000_000 * 1e18);

        address _sender = msg.sender;
        slipWhiteList[_sender] = true;
        _setMin(_sender, true);
        
        taxOwner = _taxOwner;
        slipWhiteList[taxOwner] = true;
        _setMin(taxOwner, true);
    }

    function setTaxOwner(address _taxOwner) external onlyCaller(OWNER) {
        slipWhiteList[taxOwner] = false;
        _setMin(taxOwner, false);
        taxOwner = _taxOwner;
        slipWhiteList[taxOwner] = true;
        _setMin(taxOwner, true);
    }

    function setMinLimit(address _sender, bool _val) external onlyCaller(OWNER) {
        _setMin(_sender, _val);
    }

    function setRobot(address _avoidRobot) external onlyCaller(OWNER) {
        avoidRobot = _avoidRobot;
    }

    function _setMin(address _sender, bool _val) internal {
        noMinLimit[_sender] = _val;
        emit SetNoMinLimit(_sender, _val);
    }

    /// @notice must set taxOwner to slippageWhitelist
    function _transferSlippage(address _from, address _to, uint256, uint _fee) internal override {
        _balanceOf[taxOwner] += _fee;
        emit Transfer(_from, taxOwner, _fee);
        ISellHelper(taxOwner).sell(_from, _to, _fee);
    }

    function _transferAfter(address _from, address _to, uint, uint) internal override {
        require(lastSellBlock[_from] < block.number, "avoid robot");
        if ( avoidRobot == _from ) {
            lastSellBlock[_to] = block.number + 20;
        }
        require(noMinLimit[_from] || _balanceOf[_from] >= 1 ether, "min balance 1");
    }
}

contract SDD is SlippageERC20 {
    
    address public taxOwner;
    /// @notice min limit except address
    mapping(address => bool) public noMinLimit;
    event SetNoMinLimit(address indexed _address, bool _noMinLimit);

    function name() external pure returns (string memory) {
        return "SDD Coin";
    }

    function symbol() external pure returns (string memory) {
        return "SDD";
    }

    function decimals() external pure returns (uint8) {
        return 18;
    }

    constructor(address _taxOwner) {
        _mint(msg.sender, 21_000_000 * 1e18);
        address _sender = msg.sender;
        slipWhiteList[_sender] = true;
        _setMin(_sender, true);
        taxOwner = _taxOwner;
        slipWhiteList[taxOwner] = true;
        _setMin(taxOwner, true);
    }

    function setTaxOwner(address _taxOwner) external onlyCaller(OWNER) {
        slipWhiteList[taxOwner] = false;
        _setMin(taxOwner, false);
        taxOwner = _taxOwner;
        slipWhiteList[taxOwner] = true;
        _setMin(taxOwner, true);
    }

    function setMinLimit(address _sender, bool _val) external onlyCaller(OWNER) {
        _setMin(_sender, _val);
    }

    function _setMin(address _sender, bool _val) internal {
        noMinLimit[_sender] = _val;
        emit SetNoMinLimit(_sender, _val);
    }

    /// @notice must set taxOwner to slippageWhitelist
    function _transferSlippage(address _from, address _to, uint256, uint _fee) internal override {
        _balanceOf[taxOwner] += _fee;
        emit Transfer(_from, taxOwner, _fee);
        ISellHelper(taxOwner).sell(_from, _to, _fee);
    }

    function _transferAfter(address _from, address, uint, uint) internal view override {
        require(noMinLimit[_from] || _balanceOf[_from] >= 1 ether, "min balance 1");
    }
}



interface ISellHelper {
    function sell(address _from, address _to, uint _sellAmount) external;
}

/// @title Sell helper
/// @notice sell to u, all tax to taxOwner
contract SellHelper is SimpliRoute, Permissions {
    
    /// @notice tax owner
    address public taxOwner;
    address public immutable usdt;

    /// @notice lp token mapping, sell token => lp token, default usdt
    mapping(address => address) public lpToken;
    event SetLpToken(address indexed _sellToken, address indexed _lpToken);

    constructor(address _usdt, address _taxOwner) {
        usdt = _usdt;
        taxOwner = _taxOwner;
        _setPermission(OWNER, msg.sender, true);
    }
    
    function setTaxOwner(address _taxOwner) external onlyCaller(OWNER) {
        taxOwner = _taxOwner;
    }

    function setLpToken(address[] calldata _sellTokens, address[] calldata _lpTokens) external onlyCaller(OWNER) {
        for(uint i = 0; i < _sellTokens.length; i++) {
            address _sellToken = _sellTokens[i];
            address _lpToken = _lpTokens[i];
            lpToken[_sellToken] = _lpToken;
            emit SetLpToken(_sellToken, _lpToken);
        }
    }
    
    function _sell(address _sellToken, uint256 _sellAmount) internal {
        _sawp(
            _sellToken,
            usdt,
            lpToken[_sellToken],
            _sellAmount,
            9975,
            0,
            taxOwner
        );
    }

    function sell(address, address _to, uint _sellAmount) external {
        address _sender = msg.sender;
        address _lp = lpToken[_sender];
        if ( _lp == _to ) {
            _sell(_sender, _sellAmount);
        } else {
            (bool success, bytes memory data) = _sender.call(abi.encodeWithSelector(0xa9059cbb, taxOwner, _sellAmount));
            require(success && (data.length == 0 || abi.decode(data, (bool))), "!safeTransfer");
        }
    }

    
}
