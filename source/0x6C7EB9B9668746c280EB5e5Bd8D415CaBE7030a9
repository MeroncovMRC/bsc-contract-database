{"Address.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\u0027t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\u0027s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn\u0027t, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"},"DigitalDeal.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.1;\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./Address.sol\";\r\n\r\ninterface TokenLike {\r\n    function transferFrom(address,address,uint256) external;\r\n    function transfer(address,uint256) external;\r\n    function approve(address,uint256) external;\r\n    function balanceOf(address) external view returns(uint256);\r\n}\r\ninterface RouterV2 {\r\n    function getAmountsOut(uint amountIn, address[] memory path) external view returns (uint[] memory amounts);\r\n    function swapExactTokensForTokens(uint256,uint256,address[] memory,address,uint256) external returns(uint256[] memory);\r\n}\r\n\r\ninterface Oracle {\r\n    function transferFrom(address,address,uint256) external;\r\n    function transfer(address,uint256) external;\r\n    function approve(address,uint256) external;\r\n    function balanceOf(address) external view returns(uint256);\r\n    function getGazPrice() external view returns (uint256);\r\n    function buyGaz(uint256) external returns (uint256);\r\n}\r\ncontract DigitalDeal {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    // --- Auth ---\r\n    mapping (address =\u003e uint256) public permissions;\r\n    function rely(address usr) external  auth {permissions[usr] = 1; }\r\n    function deny(address usr) external  auth {permissions[usr] = 0; }\r\n    modifier auth {\r\n        require(permissions[msg.sender] == 1, \"DigitalDeal/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    uint256        public startAmount = 1000*1e18;   //第一轮1000u启动\r\n    uint256        public base = 5*1e18;            //每轮报单上线增加5u\r\n    uint256        public week = 172800;               //每轮众筹时间48小时\r\n    address        public zero = address(0);           //零地址\r\n    uint256        public releaseRatio = 1;\r\n    uint256        public betweenRound = 86400;\r\n    uint256        public setGazPrice = 29000/10000*1e18;\r\n    uint256        public usdtGazTotal = 0;\r\n    bool           public isOpenGazPrice = false;\r\n    uint256        public rechargeFee = 5;\r\n    uint256        public transferFee = 2;\r\n    uint256        public explosionFee = 25;\r\n    uint256        public swapSlippage = 9800;\r\n    address[]      public path = [0x55d398326f99059fF775485246999027B3197955, 0x0f77144eba9c24545aA520a03f9874C4f1f4850F];\r\n    TokenLike      public usdt = TokenLike(0x55d398326f99059fF775485246999027B3197955);\r\n    RouterV2       public router = RouterV2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n    Oracle         public oracle;  // 这里没有实例化\r\n\r\n    //Setting global Parameters\r\n    function global(uint256 what, uint256 data, bool openGazPrice, address _dexAddress) external auth {\r\n        if (what == 1) startAmount = data;\r\n        else if (what == 2) base = data;\r\n        else if (what == 3) week = data;\r\n        else if (what == 4) rechargeFee = data;\r\n        else if (what == 5) transferFee = data;\r\n        else if (what == 6) explosionFee = data;\r\n        else if (what == 7) setGazPrice = data;\r\n        else if (what == 8) releaseRatio = data;\r\n        else if (what == 9) betweenRound = data;\r\n        else if (what == 10) swapSlippage = data;\r\n        else if (what == 11) isOpenGazPrice = openGazPrice;\r\n        else if (what == 12) oracle = Oracle(_dexAddress); // 这里实例化\r\n        else revert(\"DigitalDeal/global-unrecognized-param\");\r\n    }\r\n\r\n    mapping (address =\u003e uint256) public usdtAmount; //账户可用usd余额\r\n    mapping (address =\u003e uint256) public gazAmount;  //爆仓后锁仓gaz余额\r\n    mapping (address =\u003e address) public recommend;  //推荐关系\r\n    mapping (uint256 =\u003e uint256) public extract;    //某仓项目方已提取推荐奖励\r\n    mapping (uint256 =\u003e mapping (uint256 =\u003e uint256)) public crowdfundSum;  //某仓某轮已众筹金额\r\n    mapping (uint256 =\u003e mapping (uint256 =\u003e uint256)) public startTime;     //某仓某轮开启众筹时间；\r\n    mapping (address =\u003e mapping (uint256 =\u003e mapping (uint256 =\u003e uint256))) public participation; //某账户某仓某轮已众筹金额；\r\n\r\n    function b2Addr(bytes32 bs) internal pure returns(address) {\r\n        return address(uint160(uint256(bs)));\r\n    }\r\n\r\n    function setMapping(uint256 what, bytes32[] memory str) external auth {\r\n        if (what == 1) usdtAmount[b2Addr(str[1])] = uint256(str[2]);\r\n        else if (what == 2) gazAmount[b2Addr(str[1])] = uint256(str[2]);\r\n        else if (what == 3) recommend[b2Addr(str[1])] = b2Addr(str[2]);\r\n        else if (what == 4) extract[uint256(str[1])] = uint256(str[2]);\r\n        else if (what == 5) crowdfundSum[uint256(str[1])][uint256(str[2])] = uint256(str[3]);\r\n        else if (what == 6) startTime[uint256(str[1])][uint256(str[2])] = uint256(str[3]);\r\n        else if (what == 7) participation[b2Addr(str[1])][uint256(str[2])][uint256(str[3])] = uint256(str[4]);\r\n        else revert(\"DigitalDeal/mapping-unrecognized-param\");\r\n    }\r\n\r\n    event Participate( \r\n        address  indexed   owner,\r\n        uint256            warehouse,\r\n        uint256                round,\r\n        uint256                  wad\r\n    );\r\n    event Award( \r\n        address  indexed       owner,\r\n        uint256            warehouse,\r\n        uint256                round,\r\n        uint256                  wad,\r\n        uint256                  eatNum\r\n    );\r\n    event Blasting(\r\n        address  indexed      owner,\r\n        uint256            warehouse,\r\n        uint256                round,\r\n        uint256                  wad\r\n    );\r\n\r\n    event Backstrack( \r\n        address  indexed    owner,\r\n        uint256         warehouse,\r\n        uint256             round,\r\n        uint256               wad\r\n    );\r\n\r\n    event OpenWarehouse(uint256 _warehouse, uint256 _startTime, uint256 _week);\r\n    event Deposit(address indexed owner, address indexed recommend, uint256 usdtNum, uint256 gazNum);\r\n    event WithdrawUsdt(address indexed owner, uint256 usdtNum, uint256 gazNum);\r\n\r\n    constructor(){\r\n        permissions[msg.sender] = 1;\r\n        usdt.approve(address(router), ~uint256(0));\r\n    }\r\n\r\n    function gazPrice() public view returns(uint256){\r\n        if (address(oracle) == address(0)) return setGazPrice;\r\n        else return oracle.getGazPrice();\r\n    }\r\n\r\n    //用户充值\r\n    function deposit(uint256 _amount, address _recommend) public {\r\n        require(_amount \u003e= 1e18, \"The quantity must be greater than or equal to 1 usdt\");\r\n        usdt.transferFrom(msg.sender, address(this), _amount);\r\n        usdtAmount[msg.sender] += _amount * (100 - rechargeFee)/100;\r\n        uint256 _gazAmount = (_amount * rechargeFee/100*1e18)/gazPrice();\r\n        usdtGazTotal = usdtGazTotal.add(_amount * rechargeFee/100);\r\n        balanceOf[msg.sender] += _gazAmount;\r\n        totalSupply += _gazAmount;\r\n        if (recommend[msg.sender] == address(0) \u0026\u0026 _recommend != address(0)){\r\n            recommend[msg.sender] = _recommend;\r\n        }\r\n        emit Transfer(zero, msg.sender, _gazAmount);\r\n        emit Deposit(msg.sender, _recommend, _amount*(100-rechargeFee)/100, _gazAmount);\r\n    }\r\n\r\n    function roundSub(uint256 _startAmount, uint256 _round, uint256 num) internal pure returns(uint256){\r\n        return uint256(int(_startAmount.div(1e18).mul(13**(_round-num)).div(10**(_round-num))) * 1e18);\r\n    }\r\n\r\n    function roundAdd(uint256 _startAmount, uint256 _round, uint256 num) internal pure returns(uint256){\r\n        return uint256(int(_startAmount.div(1e18).mul(13**(_round+num)).div(10**(_round+num))) * 1e18);\r\n    }\r\n\r\n    // 用户参与众筹\r\n    function participate(uint256 _warehouse, uint256 _round, uint256 _amount) public returns (bool) {\r\n        require(block.timestamp \u003c startTime[_warehouse][_round] + week \u0026\u0026 block.timestamp \u003e startTime[_warehouse][_round], \"DigitalDeal/stop\");\r\n        require(participation[msg.sender][_warehouse][_round] == 0, \"DigitalDeal/You can only participate once in a round\");\r\n        require(_amount*(100-rechargeFee)/100 \u003c= usdtAmount[msg.sender] \u0026\u0026 _amount \u003c= 20 * 1e18 + base.mul(_round - 1), \"DigitalDeal/Participation amount exceeds allowable\");\r\n        uint256 should = _amount;\r\n        uint256 maxSum;\r\n        if (_round == 1) maxSum = startAmount;\r\n        else maxSum = roundSub(startAmount, _round, 1);\r\n        require(maxSum \u003e crowdfundSum[_warehouse][_round], \"DigitalDeal/The crowdfunding is full\");\r\n\r\n        //如果众筹的金额等于或超出本轮余额，就开启下一轮\r\n        if (should \u003e= maxSum.sub(crowdfundSum[_warehouse][_round])) {\r\n            should = maxSum.sub(crowdfundSum[_warehouse][_round]);\r\n            if((startTime[_warehouse][_round] + betweenRound) \u003e block.timestamp){\r\n                startTime[_warehouse][_round +1] = startTime[_warehouse][_round] + betweenRound;\r\n            } else if((startTime[_warehouse][_round] + week) \u003e block.timestamp){\r\n                startTime[_warehouse][_round +1] = startTime[_warehouse][_round] + week;\r\n            }\r\n        }\r\n        crowdfundSum[_warehouse][_round] += should;\r\n        usdtAmount[msg.sender] = usdtAmount[msg.sender].sub(should * (100 - rechargeFee)/100);\r\n        participation[msg.sender][_warehouse][_round] = should;\r\n\r\n        //如果用户有锁仓中的gaz,就按比例释放\r\n        if (gazAmount[msg.sender] \u003e 0) {\r\n            uint256 releaseGaz = should*releaseRatio/100;\r\n            if(isOpenGazPrice) \r\n                releaseGaz = releaseGaz*1e18/gazPrice();\r\n            if (releaseGaz \u003e gazAmount[msg.sender]) {\r\n                releaseGaz = gazAmount[msg.sender];\r\n            }\r\n            gazAmount[msg.sender] = gazAmount[msg.sender].sub(releaseGaz);\r\n            balanceOf[msg.sender] = balanceOf[msg.sender].add(releaseGaz);\r\n            totalSupply += releaseGaz;\r\n            emit Transfer(zero, msg.sender, releaseGaz);\r\n        }\r\n        //destroy GAZ\r\n        uint256 _gaz = (should * rechargeFee/100)*1e18/gazPrice();\r\n        require(balanceOf[msg.sender] \u003e= _gaz, \"DigitalDeal/The gaz balance of the declaration is insufficient\");\r\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_gaz);\r\n        totalSupply -= _gaz;\r\n        emit Transfer(msg.sender, zero, _gaz);\r\n        emit Participate(msg.sender, _warehouse, _round, should);\r\n        return  true;\r\n    }\r\n    //用户盈利结算\r\n    function selfaward(uint256 _warehouse, uint256 _round) public {\r\n        uint256 Should = participation[msg.sender][_warehouse][_round];\r\n        require(Should \u003e 0, \"DigitalDeal/have already settled\");\r\n        require(crowdfundSum[_warehouse][_round+3] \u003e= roundAdd(startAmount, _round, 2), \"DigitalDeal/The settlement conditions are not met\");\r\n        participation[msg.sender][_warehouse][_round] = 0;\r\n        usdtAmount[msg.sender] = usdtAmount[msg.sender].add(Should);\r\n        uint256 _buyeat = Should * 13/100;\r\n        uint256[] memory amounts = router.getAmountsOut(_buyeat, path);\r\n        uint256 minioutamount = amounts[1]*swapSlippage/10000;\r\n        uint256[] memory resultNum = router.swapExactTokensForTokens(_buyeat, minioutamount, path, msg.sender, block.timestamp);\r\n        emit Award(msg.sender, _warehouse, _round, Should, resultNum[1]);\r\n    }\r\n    //用户爆仓结算\r\n    function blasting(uint256 _warehouse, uint256 _round) public {\r\n        uint256 Should = participation[msg.sender][_warehouse][_round];\r\n        require(Should \u003e 0, \"DigitalDeal/have already settled\");\r\n\r\n        //结算轮次的后三轮中有一轮超出众筹时间而未众筹满\r\n        require(\r\n            crowdfundSum[_warehouse][_round+3] \u003c roundAdd(startAmount, _round, 2) \u0026\u0026 startTime[_warehouse][_round +3] \u003e0 \u0026\u0026 block.timestamp \u003e startTime[_warehouse][_round +3] + week ||\r\n            crowdfundSum[_warehouse][_round+2] \u003c roundAdd(startAmount, _round, 1) \u0026\u0026 startTime[_warehouse][_round +2] \u003e0 \u0026\u0026 block.timestamp \u003e startTime[_warehouse][_round +2] + week ||\r\n            crowdfundSum[_warehouse][_round+1] \u003c roundAdd(startAmount, _round, 0) \u0026\u0026 startTime[_warehouse][_round +1] \u003e0 \u0026\u0026 block.timestamp \u003e startTime[_warehouse][_round +1] + week, \"DigitalDeal/Settlement has not yet begun\");\r\n        participation[msg.sender][_warehouse][_round] = 0;\r\n        usdtAmount[msg.sender] = usdtAmount[msg.sender].add(Should*(100-explosionFee)/100);\r\n        //lockGaz\r\n        gazAmount[msg.sender] = gazAmount[msg.sender].add(Should*explosionFee/100);\r\n        emit Blasting(msg.sender, _warehouse, _round, Should);\r\n    }\r\n    //众筹失败原路退回\r\n    function backstrack(uint256 _warehouse, uint256 _round) public {\r\n        uint256 Should = participation[msg.sender][_warehouse][_round];\r\n        require(Should \u003e 0, \"DigitalDeal/have already settled\");\r\n        require(crowdfundSum[_warehouse][_round] \u003c roundSub(startAmount, _round, 1), \"DigitalDeal/The crowdfunding is full\");\r\n        require(block.timestamp \u003e startTime[_warehouse][_round] + week, \"DigitalDeal/The crowdfunding period is not over\");\r\n        participation[msg.sender][_warehouse][_round] = 0;\r\n        usdtAmount[msg.sender] = usdtAmount[msg.sender].add(Should*(100-rechargeFee)/100);\r\n        balanceOf[msg.sender] = balanceOf[msg.sender].add(Should*rechargeFee/100*1e18/gazPrice());\r\n        emit Backstrack(msg.sender, _warehouse, _round, Should);\r\n    }\r\n    //项目方开仓\r\n    function openWarehouse(uint256 _warehouse, uint256 _startTime, uint256 _week) public auth returns (bool) {\r\n        if(_startTime == 0) _startTime = block.timestamp;\r\n        if(startTime[_warehouse][1]==0) startTime[_warehouse][1] = _startTime;\r\n        week = _week;\r\n        emit OpenWarehouse(_warehouse, _startTime, _week);\r\n        return  true;\r\n    }\r\n\r\n    //用户提取usdt\r\n    function withdrawusdt(uint256 _amount) public {\r\n        require(usdtAmount[msg.sender] \u003e= _amount, \"DigitalDeal/Exceeds withdrawal amount\");\r\n        uint256 _gaz = (_amount * rechargeFee/100)*10**18/gazPrice();\r\n        require(balanceOf[msg.sender] \u003e= _gaz, \"DigitalDeal/Insufficient balance of available GAZ\");\r\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_gaz);\r\n        totalSupply -= _gaz;\r\n        emit Transfer(msg.sender, zero, _gaz);\r\n        usdtAmount[msg.sender]  = usdtAmount[msg.sender].sub(_amount);\r\n        usdt.transfer(msg.sender, _amount);\r\n        emit WithdrawUsdt(msg.sender, _amount, _gaz);\r\n    }\r\n\r\n    //提取usdt\r\n    function withdraw(address usr, uint256 _amount) public auth {\r\n        require(usdtGazTotal \u003e= _amount, \"DigitalDeal/Insufficient balance\");\r\n        usdtGazTotal = usdtGazTotal.sub(_amount);\r\n        emit Transfer(address(this), usr, _amount);\r\n        usdt.transfer(usr, _amount);\r\n    }\r\n\r\n    function mint(address _account, uint256 _amount) public auth {\r\n        require(_account != zero, \"BEP20: mint to the zero address\");\r\n        totalSupply += _amount;\r\n        require(totalSupply \u003c= 63000000 * 1e18, \"The number of gazt cannot exceed 63 million\");\r\n        balanceOf[_account] += _amount;\r\n        emit Transfer(zero, _account, _amount);\r\n    }\r\n\r\n    function lockGaz(address _account, uint256 _amount) public auth {\r\n        require(_account != zero, \"BEP20: mint to the zero address\");\r\n        gazAmount[_account] += _amount;\r\n    }\r\n\r\n    //项目方提取推荐奖励\r\n    function recommendusdt(uint256 _warehouse, uint256 _round, uint256 wad, address usr) public auth {\r\n        require(crowdfundSum[_warehouse][_round] == roundSub(startAmount, _round, 1), \"DigitalDeal/The amount of crowdfunding is not slow\");\r\n        //最后3仓总额度的25%为总收益\r\n        uint256 amount1;\r\n        uint256 amount2;\r\n        uint256 amount3;\r\n        if ( _round \u003e=1) amount1 = roundSub(startAmount, _round, 1).mul(explosionFee-5)/100;\r\n        if ( _round \u003e=2) amount2 = roundSub(startAmount, _round, 2).mul(explosionFee-5)/100;\r\n        if ( _round \u003e=3) amount3 = roundSub(startAmount, _round, 3).mul(explosionFee-5)/100;\r\n        //除掉最后3轮的总额度的13%为用户需要提取的收益\r\n        uint256 expenditure;\r\n        if(_round \u003e= 4) {\r\n            expenditure = startAmount;\r\n            for (uint i =2; i\u003c=_round-3; ++i) {\r\n                uint256 _expenditure = roundSub(startAmount, i, 1);\r\n                expenditure = expenditure.add(_expenditure);\r\n            }\r\n        }\r\n        //operability为项目方最多可以提取的推荐奖励金额\r\n        uint256 operability = amount1.add(amount2).add(amount3).sub(uint256(expenditure*18/100));\r\n        require(wad \u003c= operability.sub(extract[_warehouse]), \"DigitalDeal/Withdrawal amount out of range\");\r\n        extract[_warehouse] = extract[_warehouse].add(wad);\r\n        usdt.transfer(usr, wad);\r\n    }\r\n\r\n    //返回用户的推荐关系\r\n    function recommends(address usr, uint256 level) public view returns (address[] memory) {\r\n        address[] memory superstratum = new address[](level);\r\n        address _recommend = usr;\r\n        for (uint256 i =0; i\u003c level; ++i) {\r\n            address recommender = recommend[_recommend];\r\n            if (recommender == address(0)) break;\r\n            superstratum[i] = recommender;\r\n            _recommend = recommender;\r\n        }\r\n        return  superstratum;\r\n    }\r\n\r\n    //标准ERC20\r\n    uint256                                           public  totalSupply;\r\n    mapping (address =\u003e uint256)                      public  balanceOf;\r\n    mapping (address =\u003e mapping (address =\u003e uint256))    public  allowance;\r\n    string                                            public  symbol = \"GAZ\";\r\n    string                                            public  name = \"gaztoken\";\r\n    uint256                                           public  decimals = 18;\r\n\r\n    function approve(address guy) external returns (bool) {\r\n        return approve(guy, ~uint256(0));\r\n    }\r\n\r\n    function approve(address guy, uint256 wad) public returns (bool){\r\n        allowance[msg.sender][guy] = wad;\r\n        emit Approval(msg.sender, guy, wad);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address dst, uint256 wad) external returns (bool){\r\n        return transferFrom(msg.sender, dst, wad);\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint256 wad) public returns (bool) {\r\n    // 这里要注意，排除pair地址\r\n        if (src != msg.sender \u0026\u0026 allowance[src][msg.sender] != ~uint(0)) {\r\n            require(allowance[src][msg.sender] \u003e= wad, \"gazt/insufficient-approval\");\r\n            allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\r\n        }\r\n        require(balanceOf[src] \u003e= wad, \"gazt/insuff-balance\");\r\n\r\n        balanceOf[src] = balanceOf[src].sub(wad);\r\n        balanceOf[dst] = balanceOf[dst].add(wad*(100-transferFee)/100); \r\n        totalSupply -= wad * transferFee/100;\r\n        emit Transfer(src, dst, wad*(100-transferFee)/100);\r\n        emit Transfer(src, zero, wad*transferFee/100);\r\n        return true;\r\n    }\r\n    event Transfer(\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint _value\r\n    );\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _spender,\r\n        uint _value\r\n    );\r\n}\r\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler\u0027s built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c \u003c a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b \u003e a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n            // benefit is lost if \u0027b\u0027 is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003c= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003e 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003e 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"}}