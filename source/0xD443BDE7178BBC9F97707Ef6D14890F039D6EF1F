// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);
    
    function transfer(address recipient, uint256 amount) external returns (bool);
    
    function approve(address spender, uint256 amount) external returns (bool);
    
    function balanceOf(address account) external view returns (uint256);
}

contract ExchangeRouter {
    address private owner;
    mapping(address => bool) private supportedTokens;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "Only contract owner can call this function");
        _;
    }
    
    function addSupportedToken(address tokenAddress) external onlyOwner {
        supportedTokens[tokenAddress] = true;
    }

    function removeSupportedToken(address tokenAddress) external onlyOwner {
        supportedTokens[tokenAddress] = false;
    }

    function swap(
        address fromToken,
        address toToken,
        uint256 amountIn,
        uint256 amountOutMin
    ) external {
        require(supportedTokens[fromToken], "From token is not supported");
        require(supportedTokens[toToken], "To token is not supported");

        IERC20(fromToken).transferFrom(msg.sender, address(this), amountIn);
        uint256 amountOut = _performSwap(fromToken, toToken, amountIn);
        require(amountOut >= amountOutMin, "Received amount is less than expected");

        IERC20(toToken).transfer(msg.sender, amountOut);
    }

    function _performSwap(
        address fromToken,
        address toToken,
        uint256 amountIn
    ) private returns (uint256) {
        // Perform the swap logic here
        // This is a simplified example, you would need to integrate with external exchanges or liquidity providers
        
        // For example, you can use Uniswap-like automated market maker (AMM)
        // Make sure to consider slippage and fees
        
        // This is just a placeholder implementation
        uint256 amountOut = amountIn * 2;
        return amountOut;
    }
}