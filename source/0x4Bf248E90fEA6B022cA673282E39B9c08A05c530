// SPDX-License-Identifier: MIT


// Указываем версию компилятора
pragma solidity ^0.8.0;

// Объявляем контракт
contract CoinFlip {
    
    // Объявляем переменную, которая будет хранить последний результат броска монеты
    uint256 public lastResult;

    // Объявляем событие, которое будет вызываться при броске монеты
    event CoinFlipped(uint256 result, address player, uint256 payout, uint256 chosenSide);

    // Объявляем переменную для хранения комиссии
    uint256 public commission = 4;
    // Объявляем переменную для хранения комиссии разработчика
    uint256 public commissionDev = 4;

    uint256 public bet = 10000000000000000; // 0.01 
    // Объявляем переменную для хранения адреса владельца контракта
    address payable public owner;

    // Конструктор контракта, устанавливаем адрес владельца
    constructor() {
        owner = payable(msg.sender);
    }

    // Функция для изменения комиссии
    function setCommission(uint256 newCommission) public {
        // Проверяем, что вызывающий пользователь является владельцем контракта
        require(msg.sender == owner, "Only the owner can set the commission.");
        commission = newCommission;
    }
    
    // Функция для изменения ставки
    function setBet(uint256 newBet) public {
        // Проверяем, что вызывающий пользователь является владельцем контракта
        require(msg.sender == owner, "Only the owner can set the bet.");
        bet = newBet;
    }

    // Функция для подбрасывания монеты
    function flipCoin(uint256 chosenSide) public payable returns(uint256) {
        // Проверяем, что пользователь отправил достаточное количество эфира для ставки
        require(msg.value == bet, "Please send correct bet.");

        // Вычисляем размер комиссии
        uint256 fee = (msg.value * commissionDev ) / 100;
        // Вычисляем размер выигрыша
        uint256 payout = msg.value * 2;

        // Генерируем случайное число от 0 до 1
        uint random = uint(keccak256(abi.encodePacked(block.timestamp, msg.sender, block.difficulty))) % 2;
        
        // Обновляем значение переменной lastResult
        lastResult = random;
        
        // Определяем результат броска монеты в соответствии с выбранной стороной
        if (chosenSide == lastResult) {
               payable(msg.sender).transfer(payout);
        } else {
          // Проигрыш
        }

        
        
        // Вызываем событие CoinFlipped
        emit CoinFlipped(random, msg.sender, payout, chosenSide);
        
        // Отправляем комиссию на адрес владельца контракта
        owner.transfer(fee);

        // Возвращаем результат броска монеты
        return lastResult;
    }

    // Объявляем функцию для вывода средств
    function withdraw(uint256 amount) public {
        // Проверяем, что вызывающий пользователь является владельцем контракта
        require(msg.sender == owner, "Only the owner can withdraw funds.");
        
    // Проверяем, что запрашиваемая сумма не превышает баланс контракта
        require(amount <= address(this).balance, "Insufficient funds.");

    // Отправляем запрашиваемую сумму на кошелек владельца контракта
        payable(msg.sender).transfer(amount);
    }

    function deposit() public payable {
    }
}