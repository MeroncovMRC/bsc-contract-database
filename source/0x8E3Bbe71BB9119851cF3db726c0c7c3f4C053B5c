{"Point.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\r\n\r\n/**\r\n * @Author Vron\r\n */\r\n\r\npragma solidity \u003e=0.7.0 \u003c0.9.0;\r\nimport \"./SafeMath.sol\";\r\n\r\ninterface Tokens {\r\n    function balanceOf(address _address) external returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function transfer(address _address, uint256 value) external returns (bool);\r\n    function transferFrom(address _sender,address recipient,uint256 value) external returns (bool);\r\n}\r\n\r\ninterface Context{\r\n    function onlyOwner(address _address) external view;\r\n    function onlyAdmin(address _address) external view;\r\n    function isPlatformActive(address _address) external view;\r\n    function isPointEarningPaused(address _address) external view;\r\n}\r\n\r\ncontract Point {\r\n    using SafeMath for uint256;\r\n\r\n    // map indicates if user locked funds for validation point\r\n    mapping(address =\u003e bool) private _lock_validator_address;\r\n    // map sets wallet lock time\r\n    mapping(address =\u003e uint256) private _validator_wallet_lock_time;\r\n    // maps amount user locked\r\n    mapping(address =\u003e uint256) private _validator_lock_amount;\r\n    // maps user wallet to points earned\r\n    mapping(address =\u003e uint256) private _wallet_validation_points;\r\n    // maps listed token name to address\r\n    mapping(string =\u003e address) private tokenAddress;\r\n    // maps listed token address to name\r\n    mapping(address =\u003e string) private tokenName;\r\n    // maps token address to its listed outcome\r\n    mapping(address =\u003e bool) private isListed;\r\n    // maps user address to probable token that was locked\r\n    mapping(address =\u003e mapping(address =\u003e bool)) private userTokenLocked;\r\n    // maps user to token they locked\r\n    mapping(address =\u003e address) private currentlyLockedToken;\r\n    // maps listed token array index to token name\r\n    mapping(string =\u003e uint256) private tokenIndex;\r\n\r\n    Context private context_address;\r\n    address private BETS = 0x1aBC15E7581e984F365d100E9B03eeDC5F4dffC0;\r\n    address private platform_address;\r\n    string[] private listedTokens;\r\n    uint256 decimal_eighteen_diff = 1000000000000000000;\r\n    uint256 decimal_nine_diff = 1000000000;\r\n    uint256 BETS_decimal = 10000000000000000;\r\n\r\n    constructor(address _context){\r\n\r\n        context_address = Context(address(_context));\r\n    }\r\n\r\n    /**\r\n     * @dev function changes BET contract address\r\n    */\r\n    function changeBETContractAsddress(address _address)\r\n        external\r\n        returns (bool)\r\n    {\r\n        context_address.onlyOwner(msg.sender);\r\n        BETS = address(_address);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev function calculates the difficulty\r\n    */\r\n    function getDifficulty(address userAddress)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        address token = currentlyLockedToken[userAddress];\r\n        uint256 difficulty = 0;\r\n        if(token == BETS){\r\n            difficulty = BETS_decimal;\r\n        }\r\n        else if(Tokens(address(token)).decimals() == 18){\r\n            difficulty = decimal_eighteen_diff;\r\n        } else if (Tokens(address(token)).decimals() == 9) {\r\n            difficulty =  decimal_nine_diff;\r\n        } else {\r\n            difficulty = decimal_eighteen_diff;\r\n        }\r\n\r\n        return difficulty;\r\n    }\r\n\r\n    /**\r\n     * @dev function calculates the users validation points\r\n     * and rewards him his validation point.\r\n     * function is triggered once user logs in\r\n     */\r\n    function _calculateValidationPoint(address userAddress) internal {\r\n        // check if wallet has any amount locked\r\n        require(\r\n            _lock_validator_address[userAddress] == true,\r\n            \"WDEP\"\r\n        );\r\n        _wallet_validation_points[userAddress] = _wallet_validation_points[\r\n            userAddress\r\n        ].add(\r\n              ((_validator_lock_amount[userAddress] / 100) *\r\n                    (currentTime() -\r\n                        _validator_wallet_lock_time[userAddress])) / getDifficulty(userAddress)); // calculate points earned\r\n        _validator_wallet_lock_time[userAddress] = currentTime(); // reset validation point timer\r\n    }\r\n\r\n    /**\r\n     *@dev function changes the address for the SBETS token contract\r\n    */\r\n    function changeTokenInfo(string memory _tokenName, address _tokenAddress)\r\n        external\r\n        returns (bool)\r\n    {\r\n        context_address.onlyAdmin(msg.sender);\r\n        require(isListed[_tokenAddress] == true, \"TNL\");\r\n        context_address.onlyOwner(msg.sender);\r\n        tokenAddress[_tokenName] = _tokenAddress;\r\n        tokenName[_tokenAddress] = _tokenName;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev function adds a new token\r\n    */\r\n    function _addToken(address _tokenAddress, string memory _tokenName)\r\n        external\r\n        returns (bool)\r\n    {\r\n        context_address.onlyOwner(msg.sender);\r\n        // check for TAL\r\n        if(isListed[_tokenAddress] == true){\r\n            revert(\"TAL\");\r\n        }\r\n\r\n        // add token\r\n        tokenName[_tokenAddress] = _tokenName;\r\n        tokenAddress[_tokenName] = _tokenAddress;\r\n        isListed[_tokenAddress] = true;\r\n        tokenIndex[_tokenName] = listedTokens.length;\r\n        listedTokens.push(_tokenName);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev function removes an already listed tokenm\r\n    */\r\n    function removeToken(address _tokenAddress, string memory _tokenName)\r\n        external\r\n        returns (bool)\r\n    {\r\n        context_address.onlyOwner(msg.sender);\r\n        if(isListed[_tokenAddress] == false){\r\n            revert(\"TNL\");\r\n        }\r\n        listedTokens[tokenIndex[_tokenName]] = listedTokens[listedTokens.length - 1];\r\n        listedTokens.pop();\r\n        delete tokenName[_tokenAddress];\r\n        delete tokenAddress[_tokenName];\r\n        isListed[_tokenAddress] = false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev function gets the user currently locked token\r\n    */\r\n    function getCurrentlyLockedToken(address _wallet_address)\r\n        external\r\n        view\r\n        returns (string memory)\r\n    {\r\n        return tokenName[currentlyLockedToken[_wallet_address]];\r\n    }\r\n\r\n    /**\r\n     *@dev functiion returns the addr of the SBETS token\r\n    */\r\n    function getListedTokens()\r\n        external view\r\n        returns (string[] memory)\r\n    {\r\n        return listedTokens;\r\n    }\r\n\r\n    /**\r\n    * @dev function returns the token address\r\n    * Requirement\r\n    * [token name]\r\n    */\r\n    function getTokenAddress(string memory _tokenName)\r\n        external\r\n        view\r\n        returns (address)\r\n    {\r\n        return tokenAddress[_tokenName];\r\n    }\r\n\r\n     /**\r\n    * @dev function returns the token name\r\n    * Requirement\r\n    * [token address]\r\n    */\r\n    function getTokenName(address _tokenAddress)\r\n        external\r\n        view\r\n        returns (string memory)\r\n    {\r\n        return tokenName[_tokenAddress];\r\n    }\r\n\r\n\r\n    /**\r\n     *@dev function changes the address for the Context contract\r\n    */\r\n    function changeContextContractAddress(address _contextAddress)\r\n        external\r\n        returns (bool)\r\n    {\r\n        context_address.onlyOwner(msg.sender);\r\n        context_address = Context(address(_contextAddress));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     *@dev function returns the addr of the Context contract\r\n    */\r\n    function getContextContractAddress()\r\n        external view\r\n        returns (address)\r\n    {\r\n        return address(context_address);\r\n    }\r\n\r\n    /**\r\n    * @dev function returns a user\u0027s yet to be claimed validation points\r\n    * Requirements\r\n    * [address] must be provided and must be the address of the user whose validation points is to be gotten\r\n    */\r\n    function getUserPendingPoints(address _address) external view returns (uint256) {\r\n        return (((_validator_lock_amount[_address] / 100) *\r\n                    (currentTime() -\r\n                        _validator_wallet_lock_time[_address])) / getDifficulty(_address));\r\n    }\r\n\r\n    /**\r\n     * @dev function displays user validation points\r\n     */\r\n    function showValidationPoints(address _address) external view returns (uint256) {\r\n        // return validationPoints\r\n        return _wallet_validation_points[_address];\r\n    }\r\n\r\n    function claimValidationPoint(address userAddress) external returns (bool) {\r\n        _calculateValidationPoint(userAddress);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev function rewards users validator rights through points.\r\n     *\r\n     * Requirement: user must have [amount] or more in wallet\r\n     */\r\n    function _earnValidationPoints(address token, address userAddress, uint256 amount)\r\n        private\r\n    {\r\n        context_address.isPlatformActive(userAddress);\r\n        context_address.isPointEarningPaused(userAddress);\r\n        // check if user balance greater or equal to amount\r\n        require(\r\n            Tokens(address(token)).balanceOf(userAddress) \u003e= amount,\r\n            \"IB.\"\r\n        );\r\n        // check if amount is zero =\u003e zero amount locking  not allowed\r\n        require(amount != 0, \"0ANA\");\r\n        // check if wallet locked tokens and new token to be locked is same as prev token\r\n        if (_lock_validator_address[userAddress] == true \u0026\u0026 userTokenLocked[userAddress][token] != true){\r\n            revert(\"Lock same token as previous\");\r\n        }\r\n        // check if user wallet is already earning points\r\n        if (\r\n            _lock_validator_address[userAddress] == true \u0026\u0026\r\n            _validator_lock_amount[userAddress] != 0\r\n        ) {\r\n            // wallect locked - check if amount specified matches balance after lock amount\r\n            require(\r\n                (Tokens(address(token)).balanceOf(userAddress) -\r\n                    _validator_lock_amount[userAddress]) \u003e= amount,\r\n                \"IB\"\r\n            );\r\n            Tokens(address(token)).transferFrom(userAddress, address(this), amount); // transfer funds to smart contract\r\n            _validator_lock_amount[userAddress] = _validator_lock_amount[\r\n                userAddress\r\n            ].add(amount);\r\n        } else {\r\n            // wallet not earning points - lock amount in wallet to earn points\r\n            Tokens(address(token)).transferFrom(userAddress, address(this), amount); // transfer funds to smart contract\r\n            userTokenLocked[userAddress][token] = true;\r\n            _validator_wallet_lock_time[userAddress] = currentTime(); // save user lock time\r\n            _lock_validator_address[userAddress] = true; // user wallet locked\r\n            _validator_lock_amount[userAddress] = amount; // user amount locked\r\n            currentlyLockedToken[userAddress] = token;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev function rewards users validator rights through points.\r\n     *\r\n     * Requirement: user must have [amount] or more in wallet\r\n     */\r\n    function earnValidationPoints(address token, uint256 amount) external returns (bool) {\r\n        _earnValidationPoints(token, msg.sender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev function renounces user point earning ability\r\n     */\r\n    function revokeValidationPointsEarning(address token) external {\r\n        _revokeValidationPointsEarning(token, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev function revokes user\u0027s ability to earn validation points\r\n     */\r\n    function _revokeValidationPointsEarning(address token, address userAddress) internal {\r\n        // claim user earned points and revoke user point earning\r\n        _calculateValidationPoint(userAddress);\r\n        // check if user is signed up for points earning\r\n        require(\r\n            _lock_validator_address[userAddress] == true \u0026\u0026\r\n                _validator_lock_amount[userAddress] != 0,\r\n            \"WDEP\"\r\n        );\r\n        // send locked amount back to user\r\n        uint256 refund_amount = _validator_lock_amount[userAddress];\r\n        _validator_wallet_lock_time[userAddress] = 0; // reset user lock time\r\n        _lock_validator_address[userAddress] = false; // user wallet unlocked\r\n        _validator_lock_amount[userAddress] = 0; // reset locked amount to zero\r\n        Tokens(address(token)).transfer(userAddress, refund_amount); // send user funds back to user\r\n        userTokenLocked[userAddress][token] = false;\r\n        delete currentlyLockedToken[userAddress];\r\n    }\r\n\r\n    /**\r\n     * @dev function gets the amount currently locked/staked by a user\r\n     * REQUIREMENTS\r\n     * [_address] must be provided and must be the address of the user whose stake amount want to be retrieved\r\n    */\r\n    function userCurrentlyLockedBETS(address _address) external view returns(uint256) {\r\n        return _validator_lock_amount[_address];\r\n    }\r\n\r\n    /**\r\n     * @dev function deducts 1000 points from the supplied address\r\n    */\r\n    function deductValidationPoint(address validator_address) external  {\r\n        require(platform_address == msg.sender, \"OPCA\");\r\n        _wallet_validation_points[validator_address] = _wallet_validation_points[validator_address].sub(1000);  // deduct event validation point from user point\r\n    }\r\n\r\n    function currentTime() internal view returns (uint256) {\r\n        return block.timestamp;\r\n    }\r\n\r\n    /**\r\n     *@dev function sets the address of the Betswamp platform\r\n    */\r\n    function setPlatformAddress(address _address)\r\n        external\r\n        returns (bool)\r\n    {\r\n        context_address.onlyOwner(msg.sender);\r\n        platform_address = _address;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     *@dev function returns the address of the Betswamp platform\r\n    */\r\n    function getPlatformAddress() external view returns (address){\r\n        return platform_address;\r\n    }\r\n\r\n}"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\r\n\r\n/**\r\n * @Author Vron\r\n */\r\n\r\npragma solidity \u003e=0.7.0 \u003c0.9.0;\r\n\r\n/**\r\n * SafeMath\r\n * Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b \u003c= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n}"}}