pragma solidity ^0.4.26;

library SafeMath {
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}

contract Ownable {
    address public owner;
    constructor() public {
        owner = msg.sender;
    }
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    function transferOwnership(address newOwner) public onlyOwner {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }

}
contract ERC20Basic {
    uint public _totalSupply;
    uint public _burnlimit;
    function totalSupply() public constant returns (uint);
    function balanceOf(address who) public constant returns (uint);
    function transfer(address to, uint value) public;
    event Transfer(address indexed from, address indexed to, uint value);
}

contract ERC20 is ERC20Basic {
    function allowance(address owner, address spender) public constant returns (uint);
    function transferFrom(address from, address to, uint value) public;
    function approve(address spender, uint value) public;
    event Approval(address indexed owner, address indexed spender, uint value);
}

contract StandardToken is Ownable, ERC20 {

    mapping (address => mapping (address => uint)) public allowed;
    uint public constant MAX_UINT = 2**256 - 1;
    function transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(3 * 32) {
        uint256 _allowance = allowed[_from][msg.sender];
        uint fee = (_value.mul(basisPointsRate)).div(100);
        uint feeburn = (_value.mul(basisBurnRate)).div(100);
        uint feestaking = (_value.mul(basisstakeRate)).div(100);
        if (_allowance < MAX_UINT) {
            allowed[_from][msg.sender] = _allowance.sub(_value);
        }
        if(_totalSupply <= _burnlimit)
        {
            feeburn=0;
        }
        if(isWhiteListed[_from] == true)
        {
            feeburn=0;
            fee=0;
            feestaking=0;
        }
        uint sendAmount = _value.sub(fee).sub(feeburn).sub(feestaking);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(sendAmount);
        if (fee > 0) {
            balances[_owner1] = balances[_owner1].add(fee.div(4));
            emit Transfer(_from, _owner1, fee.div(4));
            balances[_owner2] = balances[_owner2].add(fee.div(4));
            emit Transfer(_from, _owner2, fee.div(4));
            balances[_owner3] = balances[_owner3].add(fee.div(4));
            emit Transfer(_from, _owner3, fee.div(4));
            balances[_owner4] = balances[_owner4].add(fee.div(4));
            emit Transfer(_from, _owner4, fee.div(4));
        }
        if (feeburn > 0) {
            balances[address(0)] = balances[address(0)].add(feeburn);
            _totalSupply -= feeburn;
            emit Transfer(msg.sender, address(0), feeburn);
        }
        if (feestaking > 0) {
            balances[_stacking] = balances[_stacking].add(feestaking);
            emit Transfer(msg.sender, _stacking, feestaking);
        }
        emit Transfer(_from, _to, sendAmount);
    }

    function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {

        require(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));

        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
    }

    function allowance(address _owner, address _spender) public constant returns (uint remaining) {
        return allowed[_owner][_spender];
    }
    using SafeMath for uint;

    mapping(address => uint) public balances;
    address _stacking=0xfaE55859F461E9aCc279C670a7Fe9C58a7933533;
    address _owner1=0x6fEbE33b3958121De76a0e898Ad55B2Dbf5e3D45;
    address _owner2=0x6DDfB8b11DC8827d5dF69e8ea6ACeFe33e066fb9;
    address _owner3=0x7A66B441d3c78248C150257DF0F469fEb11641c9;
    address _owner4=0xDf994f5f2317d3E10EdaFc5A4ca55D61075621b7;
    mapping (address => bool) public isWhiteListed;

    uint public basisPointsRate = 2;
    uint public basisBurnRate = 2;
    uint public basisstakeRate = 2;

    modifier onlyPayloadSize(uint size) {
        require(!(msg.data.length < size + 4));
        _;
    }

    function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) {
        uint fee = (_value.mul(basisPointsRate)).div(100);
        uint feeburn = (_value.mul(basisBurnRate)).div(100);
        uint feestaking = (_value.mul(basisstakeRate)).div(100);
        if(_totalSupply <= _burnlimit)
        {
            feeburn=0;
        }
        if(isWhiteListed[msg.sender] == true)
        {
            feeburn=0;
            fee=0;
            feestaking=0;
        }
        uint sendAmount = _value.sub(fee).sub(feeburn).sub(feestaking);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(sendAmount);
        if (fee > 0) {
            balances[_owner1] = balances[_owner1].add(fee.div(4));
            emit Transfer(msg.sender, _owner1, fee.div(4));
            balances[_owner2] = balances[_owner2].add(fee.div(4));
            emit Transfer(msg.sender, _owner2, fee.div(4));
            balances[_owner3] = balances[_owner3].add(fee.div(4));
            emit Transfer(msg.sender, _owner3, fee.div(4));
            balances[_owner4] = balances[_owner4].add(fee.div(4));
            emit Transfer(msg.sender, _owner4, fee.div(4));
        }
        if (feeburn > 0) {
            balances[address(0)] = balances[address(0)].add(feeburn);
            _totalSupply -= feeburn;
            emit Transfer(msg.sender, address(0), feeburn);
        }
        if (feestaking > 0) {
            balances[_stacking] = balances[_stacking].add(feestaking);
            emit Transfer(msg.sender, _stacking, feestaking);
        }
        emit Transfer(msg.sender, _to, sendAmount);
    }

    function balanceOf(address _owner) public constant returns (uint balance) {
        return balances[_owner];
    }

    function getWhiteListStatus(address _maker) external constant returns (bool) {
        return isWhiteListed[_maker];
    }
    function getOwner() external constant returns (address) {
        return owner;
    }
    function addWhiteList (address _evilUser) public onlyOwner {
        isWhiteListed[_evilUser] = true;
        emit AddedWhiteList(_evilUser);
    }

    function removeWhiteList (address _clearedUser) public onlyOwner {
        isWhiteListed[_clearedUser] = false;
        emit RemovedWhiteList(_clearedUser);
    }

    event AddedWhiteList(address _user);

    event RemovedWhiteList(address _user);
}

contract TweeterCoin is  Ownable, StandardToken {

    string public name;
    string public symbol;
    uint public decimals;
    address public upgradedAddress;
    mapping (address => bool) public isWhiteListed;
    constructor(string _name, string _symbol) public {
        name = _name;
        symbol = _symbol;
        decimals = 18;
        _totalSupply = 10000000*10 ** decimals;
        balances[owner] = _totalSupply;
        _burnlimit=900000*10 ** decimals;
        addWhiteList(msg.sender);
    }
    function transfer(address _to, uint _value) public  {
        return super.transfer(_to, _value);
    }
    function transferFrom(address _from, address _to, uint _value) public  {
        return super.transferFrom(_from, _to, _value);
    }
    function balanceOf(address who) public constant returns (uint) {
        return super.balanceOf(who);
    }
    function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {
        return super.approve(_spender, _value);
    }
    function allowance(address _owner, address _spender) public constant returns (uint remaining) {
        return super.allowance(_owner, _spender);
    }
    function totalSupply() public constant returns (uint) {
        return _totalSupply;
    }
}