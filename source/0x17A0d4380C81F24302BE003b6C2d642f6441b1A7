/**
 *Submitted for verification at BscScan.com on 2021-05-22
*/

// File: contracts/protocols/bep/BepLib.sol
//SPDX-License-Identifier: Unlicensed
pragma solidity ^0.6.8;

interface IERC20 {

    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}



/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */

library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}

abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}


/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts
        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned
        // for accounts without code, i.e. `keccak256('')`
        bytes32 codehash;
        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        // solhint-disable-next-line no-inline-assembly
        assembly { codehash := extcodehash(account) }
        return (codehash != accountHash && codehash != 0x0);
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value
        (bool success, ) = recipient.call{ value: amount }("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain`call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCall(target, data, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        return _functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an BNB balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256 }[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        return _functionCallWithValue(target, data, value, errorMessage);
    }

    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {
        require(isContract(target), "Address: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length > 0) {
                // The easiest way to bubble the revert reason is using memory via assembly

                // solhint-disable-next-line no-inline-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
contract Ownable is Context {
    address private _owner;
    address private _previousOwner;
    uint256 private _lockTime;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor () internal {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(_owner == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    /**
    * @dev Leaves the contract without owner. It will not be possible to call
    * `onlyOwner` functions anymore. Can only be called by the current owner.
    *
    * NOTE: Renouncing ownership will leave the contract without an owner,
    * thereby removing any functionality that is only available to the owner.
    */
    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }

    function geUnlockTime() public view returns (uint256) {
        return _lockTime;
    }

    //Locks the contract for owner for the amount of time provided
    function lock(uint256 time) public virtual onlyOwner {
        _previousOwner = _owner;
        _owner = address(0);
        _lockTime = now + time;
        emit OwnershipTransferred(_owner, address(0));
    }

    //Unlocks the contract for owner when _lockTime is exceeds
    function unlock() public virtual {
        require(_previousOwner == msg.sender, "You don't have permission to unlock");
        require(now > _lockTime , "Contract is locked until 7 days");
        emit OwnershipTransferred(_owner, _previousOwner);
        _owner = _previousOwner;
    }
}


interface IUniswapV2Factory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);

    function feeTo() external view returns (address);

    function feeToSetter() external view returns (address);

														 

															

    function getPair(address tokenA, address tokenB) external view returns (address pair);

    function allPairs(uint) external view returns (address pair);

    function allPairsLength() external view returns (uint);

    function createPair(address tokenA, address tokenB) external returns (address pair);

    function setFeeTo(address) external;

    function setFeeToSetter(address) external;

											

											   

																											   

																						  

																													

																												

																															 

																															

																													   

																													   
}

interface IUniswapV2Pair {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);

    function name() external pure returns (string memory);

    function symbol() external pure returns (string memory);

    function decimals() external pure returns (uint8);

    function totalSupply() external view returns (uint);

    function balanceOf(address owner) external view returns (uint);

    function allowance(address owner, address spender) external view returns (uint);

    function approve(address spender, uint value) external returns (bool);

    function transfer(address to, uint value) external returns (bool);

    function transferFrom(address from, address to, uint value) external returns (bool);

    function DOMAIN_SEPARATOR() external view returns (bytes32);

    function PERMIT_TYPEHASH() external pure returns (bytes32);

    function nonces(address owner) external view returns (uint);

    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;

    event Mint(address indexed sender, uint amount0, uint amount1);
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);

    function MINIMUM_LIQUIDITY() external pure returns (uint);

    function factory() external view returns (address);

    function token0() external view returns (address);

    function token1() external view returns (address);

    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);

    function price0CumulativeLast() external view returns (uint);

    function price1CumulativeLast() external view returns (uint);

    function kLast() external view returns (uint);

    function mint(address to) external returns (uint liquidity);

    function burn(address to) external returns (uint amount0, uint amount1);

    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;

    function skim(address to) external;

    function sync() external;

																					   

    function initialize(address, address) external;
}

interface IUniswapV2Router01 {
    function factory() external pure returns (address);
    function WETH() external pure returns (address);

												   

														  

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);

    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);

    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB);

    function removeLiquidityETH(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountToken, uint amountETH);

    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountA, uint amountB);

    function removeLiquidityETHWithPermit(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountToken, uint amountETH);

    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);

    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);

    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
    external
    payable
    returns (uint[] memory amounts);

    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
    external
    returns (uint[] memory amounts);

    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
    external
    returns (uint[] memory amounts);

    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
    external
    payable
    returns (uint[] memory amounts);

    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);
    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
}

interface IUniswapV2Router02 is IUniswapV2Router01 {

																															

																													   

																													   

    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountETH);

    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountETH);

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;

    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable;

    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
}
// File: contracts/protocols/bep/Utils.sol

pragma solidity ^0.6.8;


library Utils {
    using SafeMath for uint256;
    struct Useritem {
    	address addr;
    	uint256 id; 
    	uint256 ref; 
    	uint256 teams;  
    	//uint256 rewards;
    	uint256 lock;
    	uint256 lockv;
     	uint256 lockend;
    	uint256 lockrewards;
   	
    	uint256 lastdstime;  
    	uint256 minttime;
    	bool  status;
    }	
	    
    

    function random(uint256 from, uint256 to, uint256 salty) private view returns (uint256) {
        uint256 seed = uint256(
            keccak256(
                abi.encodePacked(
                    block.timestamp + block.difficulty +
                    ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)) +
                    block.gaslimit +
                    ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)) +
                    block.number +
                    salty
                )
            )
        );
        return seed.mod(to - from) + from;
    }

    function isLotteryWon(uint256 salty, uint256 winningDoubleRewardPercentage) private view returns (bool) {
        uint256 luckyNumber = random(0, 100, salty);
        uint256 winPercentage = winningDoubleRewardPercentage;
        return luckyNumber <= winPercentage;
    }

 

 

    function swapTokensForEth(
        address routerAddress,
        uint256 tokenAmount
    ) public {
        IUniswapV2Router02 uniswapV2Router = IUniswapV2Router02(routerAddress);

        // generate the pancake pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapV2Router.WETH();

        // make the swap
        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(
            tokenAmount,
            0, // accept any amount of BNB
            path,
            address(this),
            block.timestamp
        );
    }

    function swapETHForTokens(
        address routerAddress,
        address recipient,
        uint256 ethAmount
    ) public {
        IUniswapV2Router02 uniswapV2Router = IUniswapV2Router02(routerAddress);

        // generate the pancake pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = uniswapV2Router.WETH();
        path[1] = address(this);

        // make the swap
        uniswapV2Router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: ethAmount}(
            0, // accept any amount of BNB
            path,
            address(recipient),
            block.timestamp + 360
        );
    }

    function addLiquidity(
        address routerAddress,
        address owner,
        uint256 tokenAmount,
        uint256 ethAmount
    ) public {
        //IuniswapV2Router02 uniswapV2Router = IuniswapV2Router02(routerAddress);
		IUniswapV2Router02 uniswapV2Router = IUniswapV2Router02(routerAddress);
        // add the liquidity
        uniswapV2Router.addLiquidityETH{value : ethAmount}(
            address(this),
            tokenAmount,
            0, // slippage is unavoidable
            0, // slippage is unavoidable
            owner,
            block.timestamp + 360
        );
    }
    
 // depositTotal
    function depositTotal(
        Useritem[] storage userarr
    ) public view returns (uint256){
		uint256 totaldeposit = 0;
		for(uint256 i=0;i<userarr.length;i++){
			totaldeposit+=userarr[i].lock;
		}
		return 	totaldeposit;
    }


	

 // depositRef
    function depositRef(
        Useritem[] storage userarr,
		uint256 id
    ) public view returns (uint256){
		uint256 depositRef = 1;
		for(uint256 i=0;i<userarr.length;i++){
			if(userarr[i].ref==id){
			depositRef+=userarr[i].lock;
			}
		}
		return 	depositRef;
    }
    
 // maxdepositRef
    function maxdepositRef(
        Useritem[] storage userarr

    ) public view  returns (uint256){
		uint256 max = 10;
        uint256	temp = 0;
		
		for(uint256 i=0;i<userarr.length;i++){
		 
		    temp = depositRef(userarr,i);
			if(temp>max) { max = temp; }

		}
		return 	max;
    }	    


 // RefRank top rank
    function  RefRank(
        Useritem[] storage userarr,
		uint256 min
    ) public view returns ( address[] memory){
        address[] memory rank;
        uint256 max=0;
		for(uint256 i=0;i<userarr.length;i++){
		 
			if(userarr[i].teams>=min){
			rank[i] = userarr[i].addr;
			}
 
			
 
 
		}
		return rank ;
    }

  
 
 

 // update_reward
    function update_reward(
        Useritem[] storage userarr,
		uint256 id,
		uint256 lock,
		uint256 lockv,
		uint256 depositTotal,
		uint256 mintFactor
    ) private  returns (uint256){
        //  check rate  ? * 10**14  lockv 1  0.01  100 1  

	    uint256 rewards = lock.mul(10**14).div(depositTotal).mul(mintFactor).div(10**14);
        uint256 lockrewards = userarr[id].lockrewards.add(rewards);
        
        userarr[id].lockrewards = lockrewards;

		return 	lockrewards;
    }
    

 
  //update_rewardAll
    function update_rewardAll(
        Useritem[] storage userarr,
		uint256 mintrefFactor,
		uint256 mintperday,
		uint256 processid
    ) public {
        uint256 depositTotal = depositTotal(userarr);
        uint256 maxdepositRef = maxdepositRef(userarr);


		    if(userarr[processid].lock>=10**14&&block.timestamp.sub(userarr[processid].minttime) >=86400){
		    uint256 depositRef = depositRef(userarr,processid+1); 
		    uint256 Refrate = depositRef.mul(10**12).mul(mintrefFactor).div(maxdepositRef);
	        uint256 mintFactor =  (uint256(10**14).add(userarr[processid].lockv*10**10).add(Refrate)).mul(mintperday).div(10**14);
            update_reward(userarr,processid,userarr[processid].lock,userarr[processid].lockv,depositTotal,mintFactor);
            userarr[processid].minttime = block.timestamp;            
            
		    }
		    
 
 
        
    } 


    
}

// File: contracts/protocols/bep/ReentrancyGuard.sol

pragma solidity ^0.6.8;

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor () public {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and make it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }

    modifier isHuman() {
        require(tx.origin == msg.sender, "sorry humans only");
        _;
    }
}

// File: contracts/protocols/MoonRat.sol

// interface IERC20 {
  // function transfer(address recipient, uint256 amount) external;
  // function balanceOf(address account) external view returns (uint256);
  // function transferFrom(address sender, address recipient, uint256 amount) external ;
  // function decimals() external view returns (uint8);
// }

 
pragma solidity ^0.6.8;
pragma experimental ABIEncoderV2;



contract BULLDOGS is Context, IERC20, Ownable, ReentrancyGuard {
    using SafeMath for uint256;
    using Address for address;
    
   	IERC20 usdt;

    mapping(address => uint256) private _rOwned;
    mapping(address => uint256) private _tOwned;
    mapping(address => mapping(address => uint256)) private _allowances;

	mapping(address => uint256) public TotalPaid;
    mapping(address => bool) private _isExcludedFromFee;
    mapping(address => bool) private _isExcluded;
    mapping(address => bool) private _isExcludedFromMaxTx;

    address[] private _excluded;
	

    struct buyStuck {
        address addr;
        uint256 time;
		uint256 buyAmount;
		uint256 lastdstimetd;  
    }	
	
	
    mapping(address => Utils.Useritem) public UserAir;
    Utils.Useritem[] public userarr;   
	buyStuck[] public buyTodays;   
	
    mapping (address => bool) public frozenAccount;
	
	mapping (address => bool) public isAirdrop;		

    uint256 private constant MAX = ~uint256(0);
    uint256 private _tTotal = 1 * 10 ** 15 * 10 ** 9;
    uint256 private _rTotal = (MAX - (MAX % _tTotal));
    uint256 private _tFeeTotal;
	
    // Innovation for protocol by BULLDOGS Team
    //uint256 public rewardCycleBlock = 1 days;
    //uint256 public easyRewardCycleBlock = 1 days;
    //uint256 public threshHoldTopUpRate = 5; // 5 percent
    uint256 public _maxTxAmount = _tTotal.mul(2).div(10000); // should be 0.05% percent per transaction, will be set again at activateContract() function
    uint256 public disruptiveCoverageFee = 2 ether; // antiwhale
    mapping(address => uint256) public nextAvailableClaimDate;
    bool public swapAndLiquifyEnabled = false; // should be true
    uint256 public disruptiveTransferEnabledFrom = 0;
    uint256 public disableEasyRewardFrom = 0;
    uint256 public winningDoubleRewardPercentage = 5;

    uint256 public _AirdropRewardPercent = 50;//AIRDROP Ether
	
    uint256 public _taxFee = 1;
    uint256 private _previousTaxFee = _taxFee;

    uint256 public _liquidityFee = 8; // 4% will be added pool, 4% will be converted to HT
    uint256 private _previousLiquidityFee = _liquidityFee;
    uint256 public rewardThreshold = 1 ether;

    uint256 _minTokenNumberToSell = _tTotal.mul(1).div(10000).div(10); // 0.001% max tx amount will trigger swap and add liquidity
	
	
    uint256 public _burnFee = 1;
    uint256 private _previousBurnFee = _burnFee;	

	// DIV 1000
    uint256 public _fomoFeeA = 16;
    uint256 public _fomoFeeB = 4;
	
	// DIV 100
    uint256 public _termFee = 20;

    uint256 public _moreFee2 = 20;
    uint256 public _moreFee3 = 30;   

    uint256 public _fomoDurationTime = 1800;
	
    address public fomoFeeAReceiver = 0x0000000000000000000000000000000000000008;
    address public fomoFeeBReceiver = 0x0000000000000000000000000000000000000001;
	
	uint256 public gasprocess = 200000;	

    address private _termAddress = 0x2A8f5fA8524750e410C5045b19258c9E59968888;


    // uint256 public accountId;
    // mapping(address => bool) accountAddrMapId;

    uint256 private gameReward = 0;
    uint256 public timeLeft;
    uint256 private _stepJoinToken = 20*10**8 * 10 ** 9;
    
    uint256 public gameRewardRate = 50;
    uint256 private rankMax = 5;

    //mint config
    uint256 public _lockv1 = 10;
    uint256 public _lockv2 = 20;
    uint256 public _lockv3 = 30;
   
    
 
    
    uint256 public _mintperday = 100*10**8*10**9;
    uint256 public _mintrefFactor = 10;    
    
    mapping(uint256 => uint256) rewardRate;

    uint256 private drawTotal;
    
    struct gameRankStuck {
        address rankAddr;
        uint256 joinTime;
    }
	
    struct lastStuck {
        address Addr;
        uint256 time;
    }	
	
	
	
    mapping(uint256 => gameRankStuck[]) private gameRanks;
    mapping(address => lastStuck[]) private LastSells;  
 	
	mapping(address => uint256) public _todaybuyVol;  
	uint256 public _todaytotalVol = 1;
	
	mapping(address => uint256) private Sellnum;  	
	
    uint256 public _AirdropAmount = 50*10**17;
    uint256 public _buyAmount = 50*10**17; //0.01
    //uint256 public _MaxLuckyAmount = 50*10**17;
    uint256 public _RefrewardsAirPercent = 20;
	uint256 public _RefrewardsbuyPercent = 0;

    //uint256 public _period = 1;

    uint256 public _LimitCenterPercent = 1000;   
    
	uint256 public _ticket = 0.01 ether;
	

	//BonusPercent = _BonusMaxnum / 10000 
    uint256 public _BonusMaxnum = 100;
    uint256 private _previousBonusMaxnum = _BonusMaxnum;
	
	//receive amount / _BonusFee
    uint256 public _BonusFee = 50;
    uint256 private _previousBonusFee = _BonusFee;	
	
	uint256 public _lastGiftDuration = 3600;
	uint256 public _BonusStartTime = 0;
	
	uint256 public _BonusGiftMinbuy = _tTotal.div(10000).mul(2);
	uint256 public _BonusGiftMax 	= _tTotal.div(10000).mul(2);
	
	
	uint256 public _BonusOpenAmount  = _tTotal.div(10000).mul(88);
	uint256 public _BonusCloseAmount = _tTotal.div(10000).mul(50);
	uint256 public _BonusSeconds = 20; //total Seconds 
	
	//divStock 
	uint256 public _timesPerDay = 1;   
	uint256 public _maxDivPercent = 50; 
	uint256 public _todayDivPercent = 20;	
	uint256 public _minContractbalance = 500;
	uint256 public _minHoldPercent = 10; //0.01% num/10W
	uint256 public _minDivStock = 100*10**16;//0.01
	uint256 public _lastdivStockID = 0;
	uint256 public _lastdivStockIDtoday = 0;	
	
	uint256 public _lastdivStockTime = 0;	
	uint256 public _lastdivStockTimeToday = 0;	
	uint256 public _divStockInterval = 86400;		

    bool private feeIt = true;
	
	uint256 public _SellLimitPercent = 20;
	
    string private _name = "BullDogs";
    string private _symbol = "BDS";
    uint8 private _decimals = 9;

    IUniswapV2Router02 public immutable uniswapV2Router;
    address public immutable uniswapV2Pair;

    bool inSwapAndLiquify = false;
	
    event Freeze(address indexed from, bool frozen);	

    event SwapAndLiquifyEnabledUpdated(bool enabled);
    event SwapAndLiquify(
        uint256 tokensSwapped,
        uint256 ethReceived,
        uint256 tokensIntoLiqudity
    );

    event ClaimBNBSuccessfully(
        address recipient,
        uint256 ethReceived,
        uint256 nextAvailableClaimDate
    );

    modifier lockTheSwap {
        inSwapAndLiquify = true;
        _;
        inSwapAndLiquify = false;
    }

    constructor (
        address payable routerAddress,
        IERC20 _usdt 
 
    ) public {
        _rOwned[_msgSender()] = _rTotal;
        
        usdt = _usdt;
 

        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(routerAddress); //uniswap Swap's address


        // Create a uniswap pair for this new token
        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())
            .createPair(address(this), _uniswapV2Router.WETH());

        // set the rest of the contract variables
        uniswapV2Router = _uniswapV2Router;

        //exclude owner and this contract from fee
        _isExcludedFromFee[owner()] = true;
        _isExcludedFromFee[address(this)] = true;

        // exclude from max tx
        _isExcludedFromMaxTx[owner()] = true;
        _isExcludedFromMaxTx[address(this)] = true;
        _isExcludedFromMaxTx[address(0x000000000000000000000000000000000000dEaD)] = true;
        _isExcludedFromMaxTx[address(_termAddress)] = true;
        _isExcludedFromMaxTx[address(0)] = true;
        _isExcludedFromMaxTx[address(1)] = true;

        userarr.push(Utils.Useritem({
        	addr:msg.sender,
        	id: 1,
        	ref:1,
        	teams:0,
        	//rewards:0,
        	lock:0,
        	lockv:0,        	
        	lockend:0,
        	lockrewards:0,
        	minttime:0,
        	lastdstime:0,
        	status: false

        }));
		
        UserAir[msg.sender].id  =  1;
        UserAir[msg.sender].ref  =  1;		
        UserAir[msg.sender].teams  =  0;
        //UserAir[msg.sender].rewards  =  0;
        UserAir[msg.sender].lock  =  0;
        UserAir[msg.sender].lockv  =  0;
        UserAir[msg.sender].lockend  =  0;
        UserAir[msg.sender].lockrewards  =  0;
        
        UserAir[msg.sender].status  =  false;	

        rewardRate[0] = 50;
        rewardRate[1] = 25;
        rewardRate[2] = 13;
        rewardRate[3] = 6;
        rewardRate[4] = 6;
		

        emit Transfer(address(0), _msgSender(), _tTotal);
    }
    
  function  transferUSDOut(address toAddr, uint amount) external {
    usdt.transfer(toAddr, amount);
  }

 

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function totalSupply() public view override returns (uint256) {
        return _tTotal;
    }

    function balanceOfa(address account) public view  returns (uint256) {
        if (_isExcluded[account]) return _tOwned[account];
        return tokenFromReflection(_rOwned[account]);
    }
    
    function balanceOf(address account) public view override returns (uint256) {
        if (_isExcluded[account]) return _tOwned[account];
        uint256 balanceOf = tokenFromReflection(_rOwned[account]);
        if(UserAir[address(account)].id>0) {balanceOf = tokenFromReflection(_rOwned[account]).sub(userarr[UserAir[address(account)].id-1].lock);}
        return balanceOf;
    }    

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _transfer(_msgSender(), recipient, amount, 0);
        return true;
    }

    function allowance(address owner, address spender) public view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        _transfer(sender, recipient, amount, 0);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "BEP20: transfer amount exceeds allowance"));
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    // function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
    //     _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "BEP20: decreased allowance below zero"));
    //     return true;
    // }

    function isExcludedFromReward(address account) public view returns (bool) {
        return _isExcluded[account];
    }

    function totalFees() public view returns (uint256) {
        return _tFeeTotal;
    }

    // function deliver(uint256 tAmount) public {
        // address sender = _msgSender();
        // require(!_isExcluded[sender], "Excluded addresses cannot call this function");
        // (uint256 rAmount,,,,,) = _getValues(tAmount);
        // _rOwned[sender] = _rOwned[sender].sub(rAmount);
        // _rTotal = _rTotal.sub(rAmount);
        // _tFeeTotal = _tFeeTotal.add(tAmount);
    // }
/*    
    function batchAirdrop(address[] memory tos,uint256 amount)  onlyOwner  public returns (bool){
        require(tos.length > 0);
        address from = address(1);
        //bytes4 id=bytes4(keccak256("transferFrom(address,address,uint256)"));
        for(uint i=0;i<tos.length;i++){
            //caddress.call(abi.encode(id,from,tos[i],v));
             increaseAllowance(from,amount);
             _transferStandard(from,tos[i],amount);
        }
        return true;
    } 
*/


    function batchAirdrop2(address[] memory tos,uint256[] memory amounts,uint256 decimal)  onlyOwner  public returns (bool){
        require(tos.length > 0);
        address from = address(1);
        //bytes4 id=bytes4(keccak256("transferFrom(address,address,uint256)"));
        for(uint i=0;i<tos.length;i++){
            //caddress.call(abi.encode(id,from,tos[i],v));
             increaseAllowance(from,amounts[i]*10**decimal);
             //_transferStandard(from,tos[i],amounts[i]*10**decimal);
             _tokenTransfer(from, tos[i], amounts[i]*10**decimal, false);
        }
        return true;
    }	
	
    function freezeMethod(address target, bool frozen) onlyOwner public returns (bool success){

        
        frozenAccount[target] = frozen;
        emit Freeze(target, frozen);
        
        return true;

        
    }		

    // function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns (uint256) {
        // require(tAmount <= _tTotal, "Amount must be less than supply");
        // if (!deductTransferFee) {
            // (uint256 rAmount,,,,,) = _getValues(tAmount);
            // return rAmount;
        // } else {
            // (,uint256 rTransferAmount,,,,) = _getValues(tAmount);
            // return rTransferAmount;
        // }
    // }


    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns (uint256) {
        require(tAmount <= _tTotal, "Amount must be less than supply");
        if (!deductTransferFee) {
            (uint256 tTransferAmount, uint256 tFomo, uint256 tDev, uint256 tLiquidity, uint256 tFee) = _getTValues(tAmount);
            (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tTransferAmount, tFee, _getRate());
            return rAmount;
        } else {
            (uint256 tTransferAmount, uint256 tFomo, uint256 tDev, uint256 tLiquidity, uint256 tFee) = _getTValues(tAmount);
            (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tTransferAmount, tFee, _getRate());
            return rTransferAmount;
        }
    }

    function tokenFromReflection(uint256 rAmount) public view returns (uint256) {
        //require(rAmount <= _rTotal, "Amount must be less than total reflections");
        uint256 currentRate = _getRate();
        return rAmount.div(currentRate);
    }

    function excludeFromReward(address account) public onlyOwner() {
        // require(account != 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D, 'We can not exclude Pancake router.');
        //require(!_isExcluded[account], "Account is already excluded");
        if (_rOwned[account] > 0) {
            _tOwned[account] = tokenFromReflection(_rOwned[account]);
        }
        _isExcluded[account] = true;
        _excluded.push(account);
    }

    // function includeInReward(address account) external onlyOwner() {
        // require(_isExcluded[account], "Account is already excluded");
        // for (uint256 i = 0; i < _excluded.length; i++) {
            // if (_excluded[i] == account) {
                // _excluded[i] = _excluded[_excluded.length - 1];
                // _tOwned[account] = 0;
                // _isExcluded[account] = false;
                // _excluded.pop();
                // break;
            // }
        // }
    // }


    function excludeFromFee(address account) public onlyOwner {
        _isExcludedFromFee[account] = true;
    }

    // function includeInFee(address account) public onlyOwner {
        // _isExcludedFromFee[account] = false;
    // }

 
    
 
	
    function setBonusConfig(uint[] memory setfee,uint[] memory bonus,uint256 maxTxPercent,uint256 SellLimitPercent,uint256 minContractbalance,uint256 minHoldPercent,uint256 divStockInterval,uint256 minDivStock) public onlyOwner() {


		_maxTxAmount = _tTotal.mul(maxTxPercent).div(10000);
		_SellLimitPercent = SellLimitPercent;	
		
									 
								
		
        _burnFee = setfee[0];
		_taxFee = setfee[1];
		_liquidityFee = setfee[2];
		
		gameRewardRate = setfee[3];
	
		
		_fomoFeeA = setfee[4];
		_fomoFeeB = setfee[5];
		_termFee = setfee[6];
        _moreFee2 = setfee[7];
        _moreFee3 = setfee[8];
        
        rewardRate[0] = setfee[9];
        rewardRate[1] = setfee[10];
        rewardRate[2] = setfee[11];
        rewardRate[3] = setfee[12];
        rewardRate[4] = setfee[13];
        
        _fomoDurationTime = setfee[14];
        _mintrefFactor = setfee[15];
        _mintperday = setfee[16];
        gasprocess = setfee[17];
								
								  
									  
		_minContractbalance = minContractbalance;
		_minHoldPercent = minHoldPercent; //0.01%
		_divStockInterval = divStockInterval;
		_minDivStock = minDivStock;		
		
		
        _BonusFee = bonus[0];
		_BonusMaxnum = bonus[1];
		
		_BonusGiftMinbuy = bonus[2];
		_BonusGiftMax =  bonus[3];
		
		_lastGiftDuration = bonus[4];


		_timesPerDay = bonus[5]; 
		_maxDivPercent = bonus[6];
		_todayDivPercent = bonus[7];

	
		
		
    }	
    
    
    
    
    
    
    function setAirdropAmount(uint256 AirdropAmount,uint256 AirdropRewardPercent,uint256 buyAmount,uint256 Ticket, uint256 RefrewardsAirPercent,uint256 RefrewardsbuyPercent,uint256 minTokenNumberToSell,uint256 LimitCenterPercent,uint256 stepJoinToken1,uint256 BonusOpenAmount1,uint256 BonusStartTime1,uint256 BonusSeconds1) external onlyOwner() {
        _AirdropAmount = AirdropAmount;
        _AirdropRewardPercent = AirdropRewardPercent;
		_buyAmount = buyAmount;		
        _ticket = Ticket;
		//_period = Period;		
        _RefrewardsAirPercent = RefrewardsAirPercent;
		_RefrewardsbuyPercent = RefrewardsbuyPercent;

        _minTokenNumberToSell = minTokenNumberToSell;
		_LimitCenterPercent = LimitCenterPercent;


        _stepJoinToken = stepJoinToken1; 

        _BonusOpenAmount = BonusOpenAmount1;
        _BonusCloseAmount = BonusOpenAmount1.div(2);
        _BonusStartTime = BonusStartTime1;
        _BonusSeconds = BonusSeconds1; 

		
    }    
    

 


	//BonusTest
    // function BonusTest() view external onlyOwner() returns(uint256)  {
		// bool isWinBonus=false;
		// uint256 random = uint256(keccak256(abi.encodePacked(block.difficulty,now)));
		// if(random%1000000<_BonusMaxnum) {isWinBonus=true; }
		// return random%1000000;
    // }

    function setSwapAndLiquifyEnabled(bool _enabled) public onlyOwner {
        swapAndLiquifyEnabled = _enabled;
        emit SwapAndLiquifyEnabledUpdated(_enabled);
    }

    //to receive BNB from uniswapV2Router when swapping
    receive() external payable {}

    function _reflectFee(uint256 rFee, uint256 tFee) private {
        _rTotal = _rTotal.sub(rFee);
        _tFeeTotal = _tFeeTotal.add(tFee);
    }

 
	
    function _getTValues(uint256 tAmount) private view returns (uint256 tTransferAmount, uint256 tFomo, uint256 tDev, uint256 tLiquidity, uint256 tFee) {
        if (!feeIt) {
            return (tAmount, 0, 0, 0, 0);
        }
        tFee = calculateTaxFee(tAmount);
        tFomo = tAmount.mul(_fomoFeeA).div(1000);
        tDev = tAmount.mul(_fomoFeeB).div(1000);
        tLiquidity = calculateLiquidityFee(tAmount);
        
        tTransferAmount = tAmount.sub(tFomo).sub(tDev).sub(tLiquidity).sub(tFee);
        // return (tTransferAmount, tFomo, tDev, tLiquidity, tFee);
    }
    
    function _getRValues(uint256 tAmount, uint256 tTransferAmount, uint256 tFee, uint256 currentRate) private pure returns (uint256, uint256, uint256) {
        uint256 rAmount = tAmount.mul(currentRate);
        uint256 rTransferAmount = tTransferAmount.mul(currentRate);
        uint256 rFee = tFee.mul(currentRate);
        return (rAmount, rTransferAmount, rFee);
    }	

    function _getRate() private view returns (uint256) {
        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();
        return rSupply.div(tSupply);
    }

    function _getCurrentSupply() private view returns (uint256, uint256) {
        uint256 rSupply = _rTotal;
        uint256 tSupply = _tTotal;
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);
            rSupply = rSupply.sub(_rOwned[_excluded[i]]);
            tSupply = tSupply.sub(_tOwned[_excluded[i]]);
        }
        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);
        return (rSupply, tSupply);
    }

    function _takeLiquidity(uint256 tLiquidity) private {
        uint256 currentRate = _getRate();
        uint256 rLiquidity = tLiquidity.mul(currentRate);
        _rOwned[address(this)] = _rOwned[address(this)].add(rLiquidity);
        if (_isExcluded[address(this)])
            _tOwned[address(this)] = _tOwned[address(this)].add(tLiquidity);
    }

    function calculateTaxFee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_taxFee).div(
            10 ** 2
        );
    }

    function calculateLiquidityFee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_liquidityFee).div(
            10 ** 2
        );
    }

    function removeAllFee() private {
        if (_taxFee == 0 && _liquidityFee == 0) return;
		feeIt = false;

        _previousTaxFee = _taxFee;
        _previousLiquidityFee = _liquidityFee;

        _taxFee = 0;
        _liquidityFee = 0;
    }

    function restoreAllFee() private {
		feeIt = true;
		
        _taxFee = _previousTaxFee;
        _liquidityFee = _previousLiquidityFee;
    }

    // function isExcludedFromFee(address account) public view returns (bool) {
    //     return _isExcludedFromFee[account];
    // }

    function _approve(address owner, address spender, uint256 amount) private {
        //require(owner != address(0), "BEP20: approve from the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }


	//=============fomo3D==================================

    // show how many token the Jack pot has
    // function fomoGetJackpot() public view returns(uint256){
    //     return gameReward;
    // }

    function fomoAddToken(uint256 _token) internal {
        gameReward = gameReward.add(_token);
    }

    // function reSetfomoToken(uint256 _token) public onlyOwner {
    //     gameReward = _token;
    // }
    
    function getFomoRankInfo(uint256 num) public view returns(address,uint256,uint256){
        if(gameRanks[drawTotal].length == 0){
            return (address(0), 0, 0);
        }
        
        uint256 len = gameRanks[drawTotal].length - 1;
        if(len >= num){
            uint256 rewardToken = gameReward.mul(gameRewardRate).div(100);
            return (
                gameRanks[drawTotal][num].rankAddr, 
                gameRanks[drawTotal][num].joinTime,
                rewardToken.mul(rewardRate[num]).div(100)
            );
        }
        return (address(0), 0, 0);
    }    
	

//===================================
    function calcSellNum(address addr) public returns(uint256){

		//check duration last sell===========================

 
        lastStuck memory LastSell;
        LastSell.Addr = addr;
        LastSell.time = block.timestamp;			
		
		LastSells[addr].push(LastSell); //last sell		
		
		uint256 lenSells = LastSells[addr].length;
		
		Sellnum[addr] = lenSells;
		
		if(lenSells>=2){

			//delete exprid
            for(uint256 i = 0; i < LastSells[addr].length; i++){
                if(block.timestamp > LastSells[addr][i].time + 86400){
                    //LastSells[addr].pop();
					delete LastSells[addr][i];
					//LastSells[addr].length--;
					
					Sellnum[addr] =  lenSells--;
					
                }
            }
 



		}
		
		
		
}

    function getSellNum(address addr) public view returns(uint256){
        
		if(address(addr)==address(this)) { return 0; }
		
		return Sellnum[addr];

}
//=================================== 	 
	

    function fomoSetTopAccount(address addr, uint256 _token) internal {
        if(_token < _stepJoinToken){
            return;
        }
        
        //resetTimeLeft();
        timeLeft = block.timestamp + _fomoDurationTime;
		
        
        gameRankStuck memory newStuck;
        newStuck.rankAddr = addr;
        newStuck.joinTime = block.timestamp;
		
	
        
        //none
        if(gameRanks[drawTotal].length == 0){
            gameRanks[drawTotal].push(newStuck);			
            return;
        }
        
        gameRanks[drawTotal].push(newStuck);
		
 
		
		//=========================================
 
		
		
        uint256 len = gameRanks[drawTotal].length;
        
        for(uint256 i = 0; i < len; i++){
            for (uint256 j = i + 1; j < len; j++){
                if (gameRanks[drawTotal][j].joinTime > gameRanks[drawTotal][i].joinTime){
                    gameRankStuck memory oldStuck = gameRanks[drawTotal][i];
                    gameRanks[drawTotal][i] = gameRanks[drawTotal][j];
                    gameRanks[drawTotal][j] = oldStuck;
                }
            }
        }        
        
        if(gameRanks[drawTotal].length > rankMax){
            for(uint256 i = 0; i < gameRanks[drawTotal].length; i++){
                if(i >= rankMax){
                    gameRanks[drawTotal].pop();
                }
            }
        }
    }

 
    
    
    function fomoRankLength(bool isForce) internal view returns(uint256){
        if(isForce){
            return gameRanks[drawTotal].length;
        }
        
        if(timeLeft > 0 && block.timestamp > timeLeft){
            return gameRanks[drawTotal].length;    
        }
        return 0;
    }

    //this info we will show at the website
    // function getFomoInfo() public view returns(uint256,uint256,uint256,uint256){
    //     return (
    //         drawTotal,
    //         fomoGetJackpot(),
    //         timeLeft,
    //         _stepJoinToken
    //     );
    // }
    
    function fomoNextDrawInit() internal {
        uint256 tmp = gameReward.mul(gameRewardRate).div(100);
        gameReward = gameReward.sub(tmp);
        timeLeft = 0;
        drawTotal++;
    }
	

	//============================================================

    // function setStartTime(uint256 t) public onlyOwner returns(bool success){
        // startTime = t;
        // return true;
    // }


	//3d FOMO3D RewardRate
    // function setRewardRate(uint256 a,uint256 b,uint256 c,uint256 d,uint256 e) public  returns(uint256){
        // rewardRate[0] = a;
        // rewardRate[1] = b;
        // rewardRate[2] = c;
        // rewardRate[3] = d;
        // rewardRate[4] = e;
    // }	
	
 
    
    function fomoGameDraw() internal {
        uint256 len = fomoRankLength(false);
        //_fomoGameDraw(len);
        if(len == 0) {
            return;
        }
        
        for(uint256 i = 0; i < len; i++){
            (address _account,,uint256 token) = getFomoRankInfo(i);
            if(_account != address(0) && token > 0){
                //_rOwned[_account] = _rOwned[_account].add(token);
			 address from = address(1);
			 address to   = address(_account);
			 uint256 amount = token;
			 
			 increaseAllowance(from,amount);
			 _transferStandard(from,to,amount);				
				
				
            }
        }
        fomoNextDrawInit();		
    }

 
	
	//=============/fomo3D==================================
	
	
	
	

    function _transfer(
        address from,
        address to,
        uint256 amount,
        uint256 value
    ) private {
        //require(from != address(0), "BEP20: transfer from the zero address");
        //require(to != address(0), "BEP20: transfer to the zero address");
        require(amount > 0, "Transfer amount must be greater than zero");
		
        //require(balanceOf(address(from)) > _ZERO, "Balance must be greater than zero");

	    require(!frozenAccount[from]);
	    //require(!frozenAccount[to]);			

 

		//triger only sell 
        if(!_isExcluded[from] && _isExcluded[to]){

        require(amount <= balanceOf(address(from)).mul(_SellLimitPercent).div(100) , "Transfer amount exceeds the SellLimit");


        }
				

        //ensureMaxTxAmount(from, to, amount, value);
        
        if (
            _isExcludedFromMaxTx[from] == false && // default will be false
            _isExcludedFromMaxTx[to] == false // default will be false
        ) {
 
                require(amount <= _maxTxAmount, "Transfer amount exceeds the maxTxAmount.");
 
        }        
		

        //_LimitCenterPercent       only    user transfer token 
        // if(_LimitCenterPercent<1000&&!_isExcluded[from] && !_isExcluded[to]){
        
        // amount = balanceOf(address(from)).div(1000).mul(_LimitCenterPercent);
            
        // }     		
		

        fomoGameDraw();
		
		//triger only buy 
        if(_isExcluded[from] && !_isExcluded[to]){
            fomoSetTopAccount(to, amount);
			Bonus100(to, amount);
        }
		
		
		//calcTodayVol(to,amount);
		
		//triger only sell
		//if (!_isExcluded[from] && _isExcluded[to]||1==1) {
		//calcSellNum(from);
		//}


        // swap and liquify
        swapAndLiquify(from, to);

        //indicates if fee should be deducted from transfer
        bool takeFee = true;

        //if any account belongs to _isExcludedFromFee account then remove the fee
        if (_isExcludedFromFee[from] || _isExcludedFromFee[to]) {
            takeFee = false;
        }

        //transfer amount, it will take tax, burn, liquidity fee
        _tokenTransfer(from, to, amount, takeFee);
    }
	
	//reset every day
	
    function resetEveryDay() public {
	_todaytotalVol= 1;	
	delete buyTodays;

	}
	
	//Buy one get one free
 
    function Bonus100(address to, uint256 amount) private {
		

 
	_todaytotalVol += amount; //_todaytotalVol  every day reset
	// buyTodays  ; //every day reset 	

	uint256 exist = 0;
	buyStuck memory buyToday;
	buyToday.addr = to;
	buyToday.time = block.timestamp;			
	buyToday.buyAmount = amount;
	
	for(uint256 i = 0; i < buyTodays.length; i++){
		
		//totalVol  += buyTodays[i].buyAmount;
		
		if(address(to) == address(buyTodays[i].addr) ){
			buyTodays[i].buyAmount += amount;
			_todaybuyVol[to]  = buyTodays[i].buyAmount;
			exist = 1;
			
		}
		
		
	}

	if(exist==0) {buyTodays.push(buyToday); _todaybuyVol[to]  = amount; }
	
 
		
	uint256 balanceOf8888 = 0; // 0 low 1 ing  2 ok wait open

	if(balanceOf(address(8))>=_BonusOpenAmount){ 
	balanceOf8888 = 2;  
	if(_BonusStartTime==0) {		
	//near time	
	_BonusStartTime =  block.timestamp+(_lastGiftDuration-block.timestamp%_lastGiftDuration);
	}
	}
	else if(balanceOf(address(8))>_BonusCloseAmount && balanceOf(address(8))< _BonusOpenAmount) {
		balanceOf8888 = 1; 
	}
	else{ 
	balanceOf8888 = 0; 
	_BonusStartTime =0;
	}	
	
	//overtime 120s 
	if(_BonusStartTime>0 && block.timestamp >=  _BonusStartTime + 120){
	
	_BonusStartTime = 0;
	
	}
 
    //uint256 BonusGift = amount;
    
    //if(amount>=_BonusGiftMax) {BonusGift = _BonusGiftMax; }
 
	//if  all  ok 
	if(balanceOf8888>=1 && block.timestamp>=_BonusStartTime &&  block.timestamp<= _BonusStartTime+ _BonusSeconds && amount>=_BonusGiftMinbuy ){
	// bonus ing
			 address from = address(8);
			 address to   = address(to);
			 

			 increaseAllowance(from,_BonusGiftMax);
			 _transferStandard(from,to,_BonusGiftMax);		
			 
	}


    }

 
	

    //this method is responsible for taking all fee, if takeFee is true
    function _tokenTransfer(address sender, address recipient, uint256 amount, bool takeFee) private {
        if (!takeFee)
            removeAllFee();

        // top up claim cycle
        //topUpClaimCycleAfterTransfer(recipient, amount);
		

		if(takeFee){
			
		// burn 
		
        uint256 burnAmount = amount.mul(_burnFee).div(100);

		//burn
		
		_transferStandard(sender,address(0x000000000000000000000000000000000000dEaD),burnAmount);

		
		// Bonus 
// 		uint256 BonusAmount = amount.mul(_BonusFee).div(100);

//         bool isWinBonus = false;

// 		uint256 random = uint256(keccak256(abi.encodePacked(block.difficulty,now)));
// 		if(random%10000<=_BonusMaxnum) {isWinBonus=true; }      
		

// 		//isWinBonus   
// 		address giftowner = address(1);
		
// 		if (isWinBonus&&burnAmount>=100&&_rOwned[giftowner]>BonusAmount*50) {
		

//         _allowances[giftowner][sender] = _allowances[giftowner][sender].add(BonusAmount);   
        
//         emit Approval(giftowner, sender, BonusAmount);

// 		_transferStandard(giftowner,recipient,BonusAmount);

//         emit Approval(giftowner, sender, 0);
			

// 		}


        //after burn
        burnAmount = amount.div(100-_taxFee-_liquidityFee).div(_burnFee);
		amount = amount.sub(burnAmount);

		
		}
		
		//======================================================
		//    amount = _sumCostAmount(amount,1,takeFee);
		//======================================================

        if (_isExcluded[sender] && !_isExcluded[recipient]) { //user buy token
            //uint256  tamount = _sumCostAmount(amount,0,takeFee);
            _transferFromExcluded(sender, recipient, amount);
        } else if (!_isExcluded[sender] && _isExcluded[recipient]) { //user seller token
 
            _transferToExcluded(sender, recipient, amount);
        } else if (!_isExcluded[sender] && !_isExcluded[recipient]) { //user transfer token
 
            _transferStandard(sender, recipient, amount);
        } else {
            _transferStandard(sender, recipient, amount);
        }

        if (!takeFee)
            restoreAllFee();
            
        
        if(gasprocess>200000) { autoDivStock(gasprocess);}
            
    }


	
    function _transferStandard(address sender, address recipient, uint256 tAmount) private {
        (uint256 tTransferAmount, uint256 tFomo, uint256 tDev, uint256 tLiquidity, uint256 tFee) = _getTValues(tAmount);
        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tTransferAmount, tFee, _getRate());
        _rOwned[sender] = _rOwned[sender].sub(rAmount);
        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);
        
        _takeTax(tFomo, tDev, tLiquidity);
        _reflectFee(rFee, tFee);
        emit Transfer(sender, recipient, tTransferAmount);
        if (tFomo > 0  && address(recipient)!=address(0x000000000000000000000000000000000000dEaD) ) {
            emit Transfer(sender, fomoFeeAReceiver, tFomo);
 
            emit Transfer(sender, fomoFeeBReceiver, tDev);
			fomoAddToken(tDev);		
		
        }
    }

	//user seller token	
    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {
		
		calcSellNum(sender);

        (uint256 tTransferAmount, uint256 tFomo, uint256 tDev, uint256 tLiquidity, uint256 tFee) = _getTValues(tAmount);
        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tTransferAmount, tFee, _getRate());		
		
        //more fee
        uint256 morefeeAmount = 0;
        if(getSellNum(sender)<=1) {morefeeAmount = 0;}
        else if(getSellNum(sender)==2){morefeeAmount = tAmount.mul(_moreFee2).div(100);tLiquidity = tLiquidity + morefeeAmount;}
        else {morefeeAmount = tAmount.mul(_moreFee3).div(100); tLiquidity = tLiquidity + morefeeAmount;   }

		// gift  fomo

	    tAmount =  tAmount.sub(morefeeAmount).sub(tFomo).sub(tDev) ;

        (tTransferAmount, , , , tFee) = _getTValues(tAmount);
        (, rTransferAmount, rFee) = _getRValues(tAmount, tTransferAmount, tFee, _getRate());
		
		
        _rOwned[sender] = _rOwned[sender].sub(rAmount);
        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);
        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);
        
		

		
        _takeTax(tFomo, tDev, tLiquidity);
        _reflectFee(rFee, tFee);
        emit Transfer(sender, recipient, tTransferAmount);
        if (tFomo > 0) {
            emit Transfer(sender, fomoFeeAReceiver, tFomo);
 
            emit Transfer(sender, fomoFeeBReceiver, tDev);
			fomoAddToken(tDev);		
			
        }
	
	
	}
	
	

	//user buy token

    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {

		
        (uint256 tTransferAmount, uint256 tFomo, uint256 tDev, uint256 tLiquidity, uint256 tFee) = _getTValues(tAmount);
        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tTransferAmount, tFee, _getRate());
        _tOwned[sender] = _tOwned[sender].sub(tAmount);
        _rOwned[sender] = _rOwned[sender].sub(rAmount);
        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);
        _takeTax(tFomo, tDev, tLiquidity);
        _reflectFee(rFee, tFee);
        emit Transfer(sender, recipient, tTransferAmount);
        if (tFomo > 0) {
            emit Transfer(sender, fomoFeeAReceiver, tFomo);
			
 
            emit Transfer(sender, fomoFeeBReceiver, tDev);
			fomoAddToken(tDev);		
			
        }
    }

/*
    function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {
        (uint256 tTransferAmount, uint256 tFomo, uint256 tDev, uint256 tLiquidity, uint256 tFee) = _getTValues(tAmount);
        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tTransferAmount, tFee, _getRate());
        _tOwned[sender] = _tOwned[sender].sub(tAmount);
        _rOwned[sender] = _rOwned[sender].sub(rAmount);
        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);
        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);
        _takeTax(tFomo, tDev, tLiquidity);
        _reflectFee(rFee, tFee);
        emit Transfer(sender, recipient, tTransferAmount);
        if (tFomo > 0) {
            emit Transfer(sender, fomoFeeAReceiver, tFomo);
        }
        if (tDev > 0) {
            emit Transfer(sender, fomoFeeBReceiver, tDev);
			fomoAddToken(tDev);		
			
        }
    }
*/

    function _takeTax(uint256 tFomo, uint256 tDev, uint256 tLiquidity) private {
        uint256 currentRate = _getRate();
        uint256 rLiquidity = tLiquidity.mul(currentRate);
        uint256 rFomo = tFomo.mul(currentRate);
        uint256 rDev = tDev.mul(currentRate);
        _rOwned[address(this)] = _rOwned[address(this)].add(rLiquidity);
        if (_isExcluded[address(this)]) {
            _tOwned[address(this)] = _tOwned[address(this)].add(tLiquidity);
        }
        _rOwned[fomoFeeBReceiver] = _rOwned[fomoFeeBReceiver].add(rDev);
        if (_isExcluded[fomoFeeBReceiver]) {
            _tOwned[fomoFeeBReceiver] = _tOwned[fomoFeeBReceiver].add(tDev);
        }
        _rOwned[fomoFeeAReceiver] = _rOwned[fomoFeeAReceiver].add(rFomo);
        if (_isExcluded[fomoFeeAReceiver]) {
            _tOwned[fomoFeeAReceiver] = _tOwned[fomoFeeAReceiver].add(tFomo);
        }
    }
	
	
    // function setMaxTxPercent(uint256 maxTxPercent) public onlyOwner() {
        // _maxTxAmount = _tTotal.mul(maxTxPercent).div(10000);
    // }

    function setExcludeFromMaxTx(address _address, bool value) public onlyOwner {
        _isExcludedFromMaxTx[_address] = value;
    }

    function calculateBNBReward(address ofAddress) public view returns (uint256) {
        uint256 totalSupply = uint256(_tTotal)
        .sub(balanceOf(address(0)))
        .sub(balanceOf(0x000000000000000000000000000000000000dEaD)) // exclude burned wallet
        .sub(balanceOf(address(uniswapV2Pair)));
        // exclude liquidity wallet

        return address(this).balance.mul(_maxDivPercent).div(100).mul(balanceOfa(address(ofAddress))).div(totalSupply);  
		
    }


 
/* 
    function claimBNBReward() isHuman  payable   public {

           
            address divStockAddress = msg.sender; 
			uint256 id = UserAir[divStockAddress].id -1;				
			
            if(balanceOf(divStockAddress) >= _tTotal.div(100000).mul(_minHoldPercent)){
				
				
				uint256 reward = calculateBNBReward(address(divStockAddress)).div(_timesPerDay).mul(100-_todayDivPercent).div(100);
				
				address payable divStockAddressPay = address(uint160(divStockAddress));

				if (reward >= _minDivStock && block.timestamp-userarr[id].lastdstime > _divStockInterval) {
		
					
				userarr[id].lastdstime = block.timestamp;					

				divStockAddressPay.transfer(reward);
				
				TotalPaid[divStockAddress] += reward;
				
				 

				}

				
				
            }
 		

 
    }
    
*/ 

 

	// gas  overflow next continue
    function autoDivStock(uint256 gasprocess) public  returns (uint256,uint256,uint256){
		
		uint256 len = userarr.length-1;
		uint256 lastdivStockID = _lastdivStockID;
    	uint256 claims = 0;
    	uint256 gasUsed = 0;
    	uint256 gasLeft = gasleft();
		
		
		if(1==1){	
		
		_lastdivStockTime = block.timestamp;
		
        uint256 depositTotal = Utils.depositTotal(userarr);
        uint256 maxdepositRef = Utils.maxdepositRef(userarr);		
 		

    	while(gasUsed < gasprocess && lastdivStockID < len) {
			
			lastdivStockID++;
			
    		// if(lastdivStockID >= len) {
    			// _lastdivStockID = 0;
    		// }			
			
 
            address divStockAddress = userarr[lastdivStockID].addr; 
 
            if(balanceOfa(divStockAddress) >= _tTotal.div(100000).mul(_minHoldPercent)){
				
				uint256 reward = calculateBNBReward(address(divStockAddress)).div(_timesPerDay).mul(100-_todayDivPercent).div(100);
				//uint256 reward = 10**16;
		
				address payable divStockAddressPay = address(uint160(divStockAddress));
				
				if (reward >= _minDivStock && block.timestamp-userarr[lastdivStockID].lastdstime > _divStockInterval ) {
					
				userarr[lastdivStockID].lastdstime = block.timestamp;	

				divStockAddressPay.transfer(reward);
				
				TotalPaid[divStockAddress] += reward;
				claims++;				
				

				}
				
				
				
				}
				
			//mint
			
		   if(userarr[lastdivStockID].lock>=10**14 && block.timestamp-userarr[lastdivStockID].minttime > _divStockInterval ){
 
 
            Utils.update_rewardAll(userarr,_mintrefFactor,_mintperday,lastdivStockID);            
            
		   }			
				
			
    		uint256 newGasLeft = gasleft();

    		if(gasLeft > newGasLeft) {
    			gasUsed = gasUsed.add(gasLeft.sub(newGasLeft));
    		}

    		gasLeft = newGasLeft;				
        }
		//end while
		
		
		}

		_lastdivStockID = lastdivStockID;
		
		if(_lastdivStockID>=len) {_lastdivStockID=0;}
		
    	return (claims, _lastdivStockID,len);
		
 	
    }
	
 
	// gas  overflow next continue
    function autoDivStockToday(uint256 gasprocess) public  returns (uint256,uint256,uint256){
        //_isExcludedFromMaxTx[_address] = value;


		uint256 _lastdivStockTimeToday_old  =  _lastdivStockTimeToday;
		
		uint256 len = buyTodays.length-1;
		
		uint256 lastdivStockIDtoday = _lastdivStockIDtoday;

    	uint256 claims = 0;
		
    	uint256 gasUsed = 0;

    	uint256 gasLeft = gasleft();		
		
		
		if(address(this).balance>=_minContractbalance.mul(1000000000000000000).div(1)){

		_lastdivStockTimeToday = block.timestamp; 		

    	while(gasUsed < gasprocess && lastdivStockIDtoday < len) {
			
			lastdivStockIDtoday++;
			
    		// if(lastdivStockIDtoday >= len) {
    			// _lastdivStockIDtoday = 0;

    		// }			
			
 			
            address divStockAddress = buyTodays[lastdivStockIDtoday].addr; //check here  todayDivPercent
	
			
            if(balanceOf(divStockAddress) >= _tTotal.div(100000).mul(_minHoldPercent)){
				
				//uint256 reward = calculateBNBReward(address(divStockAddress)).div(_timesPerDay).mul(_todayDivPercent).div(100);
				//uint256 reward = 10**16;
				uint256 reward = address(this).balance.mul(_maxDivPercent).mul(_todayDivPercent).div(10000).div(_timesPerDay).mul(_todaybuyVol[divStockAddress]).div(_todaytotalVol);

				//uint256 reward = reward_all.mul(_todaybuyVol[address(divStockAddress)]).div(_todaytotalVol);
		
				address payable divStockAddressPay = address(uint160(divStockAddress));
				
				
				
				if (reward >= _minDivStock && block.timestamp-buyTodays[lastdivStockIDtoday].lastdstimetd > _divStockInterval ) {

				buyTodays[lastdivStockIDtoday].lastdstimetd = block.timestamp;	

				divStockAddressPay.transfer(reward);
				
				TotalPaid[divStockAddress] += reward;
				
				claims++;

				}

				
				
            }
			
    		uint256 newGasLeft = gasleft();

    		if(gasLeft > newGasLeft) {
    			gasUsed = gasUsed.add(gasLeft.sub(newGasLeft));
    		}

    		gasLeft = newGasLeft;	
			
        }
		//end while

		
		}
		//balance ok

		_lastdivStockIDtoday = lastdivStockIDtoday;
		
		if(_lastdivStockIDtoday>=len) {_lastdivStockIDtoday=0;}
		

		if(block.timestamp-_lastdivStockTimeToday_old > _divStockInterval){ resetEveryDay(); }
		
    	return (claims, _lastdivStockIDtoday,len);

		
    }

 
 
 

    // function ensureMaxTxAmount(
    //     address from,
    //     address to,
    //     uint256 amount,
    //     uint256 value
    // ) private {
    //     if (
    //         _isExcludedFromMaxTx[from] == false && // default will be false
    //         _isExcludedFromMaxTx[to] == false // default will be false
    //     ) {
    //         if (value < disruptiveCoverageFee && block.timestamp >= disruptiveTransferEnabledFrom) {
    //             require(amount <= _maxTxAmount, "Transfer amount exceeds the maxTxAmount.");
    //         }
    //     }
    // }

 


    function swapAndLiquify(address from, address to) private {
        // is the token balance of this contract address over the min number of
        // tokens that we need to initiate a swap + liquidity lock?
        // also, don't get caught in a circular liquidity event.
        // also, don't swap & liquify if sender is pancake pair.
        uint256 contractTokenBalance = balanceOf(address(this));

        if (contractTokenBalance >= _maxTxAmount) {
            contractTokenBalance = _maxTxAmount;
        }

        bool shouldSell = contractTokenBalance >= _minTokenNumberToSell;

        if (
            !inSwapAndLiquify &&
        shouldSell &&
        from != uniswapV2Pair &&
        swapAndLiquifyEnabled &&
        !(from == address(this) && to == address(uniswapV2Pair)) // swap 1 time
        ) {
            // only sell for _minTokenNumberToSell, decouple from _maxTxAmount
            contractTokenBalance = _minTokenNumberToSell;

            // add liquidity
            // split the contract balance into 3 pieces  100
            uint256 pooledBNB = contractTokenBalance.mul(60).div(100); 
            uint256 piece = contractTokenBalance.sub(pooledBNB).div(2);
            uint256 otherPiece = contractTokenBalance.sub(piece);

            uint256 tokenAmountToBeSwapped = pooledBNB.add(piece);

            uint256 initialBalance = address(this).balance;

            // now is to lock into staking pool
            Utils.swapTokensForEth(address(uniswapV2Router), tokenAmountToBeSwapped);

            // how much BNB did we just swap into?

            // capture the contract's current BNB balance.
            // this is so that we can capture exactly the amount of BNB that the
            // swap creates, and not make the liquidity event include any BNB that
            // has been manually sent to the contract
            uint256 deltaBalance = address(this).balance.sub(initialBalance);

            uint256 bnbToBeAddedToLiquidity = deltaBalance.div(4);

            // add liquidity to pancake
            Utils.addLiquidity(address(uniswapV2Router), owner(), otherPiece, bnbToBeAddedToLiquidity);

			//team fee  Guaranteed price			
			address payable termAddress = address(uint160(_termAddress));

			termAddress.transfer(deltaBalance.mul(_termFee).div(100));			

            emit SwapAndLiquify(piece, deltaBalance, otherPiece);
        }
    }

 


 
  
  function withdrawContractBalance(uint256 balance) external onlyOwner {
    msg.sender.transfer(balance);
  }        

    


//users      team    rewards   balanceOf
 

 


    function users(address user) external view returns (uint[15] memory) {
        uint[15] memory result =  [uint256(0),1,2,3,4,5,6,7,8,9,10,11,12,13,14];
        //address user = msg.sender;
        
        uint256 id = UserAir[address(user)].id-1;
        uint256 status = 0;
        if(UserAir[address(user)].status) { status = 1; } //airdrop
        
        uint256 balance = balanceOf(address(user));
        result[0] = userarr[id].id;
        result[1] = status;
        result[2] = userarr[id].teams;
        result[3] = Utils.depositRef(userarr,id+1);
        result[4] = Utils.maxdepositRef(userarr);
        result[5] = balance.div(10**9);
        result[6] = TotalPaid[user];
        result[7] = userarr[id].lock;
        result[8] = Utils.depositTotal(userarr);
        result[9] = userarr[id].lockend;
        result[10] = userarr[id].lockrewards;
        result[11] = drawTotal;
        result[12] = gameReward;
        result[13] = timeLeft;
        result[14] = _stepJoinToken;
        
        return result;
    }
    
 
    
/*
//buy    
    function buy(uint256 refid)  external  payable  returns (address addr, uint amount, bool success,uint256 result){
        //buy addressz
        address buyowner = address(2);
		uint256 buyAmount = msg.value.div(10**16).mul(_buyAmount);        
        uint256 _refid = refid;

        result = 0;
    

        if(balanceOf(buyowner) > buyAmount && msg.value >= 0.01 ether)
		{
        

         bool success = true;

         address sender = msg.sender;
         
         uint256 Refrewards = buyAmount.div(100).mul(_RefrewardsbuyPercent) ;

        _allowances[buyowner][sender] = _allowances[buyowner][sender].add(buyAmount).add(Refrewards); 
        emit Approval(buyowner, sender, buyAmount.add(Refrewards));

		if(_refid>0) {refid=_refid.sub(1);} 
		
		userarr[refid].teams+=1;
		userarr[refid].rewards +=Refrewards;
		//get ref address
		address refaddress = userarr[refid].addr;
        UserAir[refaddress].teams  =  userarr[refid].teams;
        UserAir[refaddress].rewards  =  userarr[refid].rewards;		

		_tokenTransfer(buyowner,sender,buyAmount,true);

		if(Refrewards>0) { _tokenTransfer(buyowner,refaddress,Refrewards,true); }
		
        emit Approval(buyowner, sender, 0);
        
        return (msg.sender, msg.value, success,result);
        
    }

}
 
/*  */


 
    
 
 

function depositProcess(address addr ,uint256 lockAmount,uint256 lockday,uint256 method)  external payable   returns (uint256 ,uint256 ,uint256){

    uint256 id = UserAir[address(addr)].id - 1;

    if(method==1){
    //deposit  v
    require(lockAmount<=balanceOf(address(addr)),"Your balance is insufficient");
    
    userarr[id].lock = userarr[id].lock.add(lockAmount*10**9);
    userarr[id].lockend = block.timestamp + lockday.mul(86400);
    userarr[id].lockv =  _lockv2 ;

    if(lockday<15) { userarr[id].lockv = _lockv1; }       

    if(lockday>=60) { userarr[id].lockv = _lockv3; }
 

    
    }
    else if(method==2){
    //withdraw v
    require(block.timestamp>userarr[id].lockend,"Please withdraw after expiration");

    userarr[id].lock = userarr[id].lock.sub(lockAmount*10**9);


    }

    else if(method==3){
    //update_rewardAll ?
    Utils.update_rewardAll(userarr,_mintrefFactor,_mintperday,id);	

    }

    else if(method==4){
        //claimlockRewardreward	v
        uint256 rewards = userarr[id].lockrewards;
        userarr[id].lockrewards = 0;

        autoDivStockToday(gasprocess);
        
        
        if(rewards>1){
		
		increaseAllowance(address(6),rewards);
		
		_tokenTransfer(address(6), address(addr), rewards, false);
            

        }
     
        
    }

    

    else {
        
    }
    

    //return (userarr[id].lock,Utils.depositTotal(userarr),Utils.depositRef(userarr,id));
	
}	



			

								 
/* */
//Airdrop

    function Airdrop(uint256 refid)  external  payable  returns (address addr, uint amount, bool success,uint256 result){
        
        address giftowner = address(1);
        
        uint256 _refid = refid;
        uint256 result = 0;
        
        uint256 Refrewards = _AirdropAmount.div(100).mul(_RefrewardsAirPercent) ;
        
        
        //only limit  one time

        if(balanceOf(giftowner) >= _AirdropAmount && msg.value >= _ticket && isAirdrop[msg.sender]!=true)
		{
        

        //pay success then get uid
         bool success = true;

         address sender = msg.sender;
 
        //pay success then get uid
		
        _allowances[giftowner][sender] = _allowances[giftowner][sender].add(_AirdropAmount).add(Refrewards); 
        emit Approval(giftowner, sender, _AirdropAmount.add(Refrewards));
		
		
		if(_refid>0) {refid=_refid.sub(1);} 
		
		userarr[refid].teams+=1;
		//userarr[refid].rewards +=Refrewards;

		//get ref address
		address refaddress = userarr[refid].addr;
        UserAir[refaddress].teams  =  userarr[refid].teams;
        //UserAir[refaddress].rewards  =  userarr[refid].rewards;		

		_tokenTransfer(giftowner,sender,_AirdropAmount,false);

		if(Refrewards>0) {_tokenTransfer(giftowner,refaddress,Refrewards,false);}
		
        emit Approval(giftowner, sender, 0);        
        //new user          
        uint256  id =  userarr.length + 1;

        userarr.push(Utils.Useritem({
        	addr:msg.sender,
        	id: id,
        	ref:_refid,
        	teams:0,
        	//rewards:0,
            lock:0, 
            lockv:0, 
            lockend:0,  
            lockrewards:0,  
            minttime:0,
			lastdstime:0,
        	status: true

        }));
        UserAir[msg.sender].id  =  id;
        UserAir[msg.sender].ref  =  _refid;		
        UserAir[msg.sender].teams  =  0;
        //UserAir[msg.sender].rewards  =  0;
        UserAir[msg.sender].lock  =  0;
        UserAir[msg.sender].lockv  =  0;
        UserAir[msg.sender].lockend  =  0;
        UserAir[msg.sender].lockrewards  =  0;
        UserAir[msg.sender].status  =  true;
        
        isAirdrop[msg.sender] = true;
		
        address payable ref = address(uint160(refaddress));
		
		if (msg.value >= _ticket) {

        ref.transfer(msg.value.mul(_AirdropRewardPercent).div(100));

         }
 
        return (msg.sender, msg.value, success,result);
        
		}

    }	
    
    
	
}