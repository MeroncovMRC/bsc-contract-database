
// File: @openzeppelin/contracts/token/ERC20/IERC20.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `from` to `to` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
}


// File: @openzeppelin/contracts/utils/math/SafeMath.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)

pragma solidity ^0.8.0;

// CAUTION
// This version of SafeMath should only be used with Solidity 0.8 or later,
// because it relies on the compiler's built in overflow checks.

/**
 * @dev Wrappers over Solidity's arithmetic operations.
 *
 * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler
 * now has built in overflow checking.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            uint256 c = a + b;
            if (c < a) return (false, 0);
            return (true, c);
        }
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b > a) return (false, 0);
            return (true, a - b);
        }
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
            // benefit is lost if 'b' is also tested.
            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
            if (a == 0) return (true, 0);
            uint256 c = a * b;
            if (c / a != b) return (false, 0);
            return (true, c);
        }
    }

    /**
     * @dev Returns the division of two unsigned integers, with a division by zero flag.
     *
     * _Available since v3.4._
     */
    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a / b);
        }
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.
     *
     * _Available since v3.4._
     */
    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a % b);
        }
    }

    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return a - b;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        return a * b;
    }

    /**
     * @dev Returns the integer division of two unsigned integers, reverting on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator.
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * reverting when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return a % b;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {trySub}.
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b <= a, errorMessage);
            return a - b;
        }
    }

    /**
     * @dev Returns the integer division of two unsigned integers, reverting with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a / b;
        }
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * reverting with custom message when dividing by zero.
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {tryMod}.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a % b;
        }
    }
}


// File: contracts/PalStaking.sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.18;

import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";



 /**
    * WelCome to PhilippineAirLines Token Staking Contract   
    * Developer Projectpsalms   .
    *
  
 * */

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _transferOwnership(_msgSender());
    }

    modifier onlyOwner() {
        _checkOwner();
        _;
    }


    function owner() public view virtual returns (address) {
        return _owner;
    }

    function _checkOwner() internal view virtual {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
    }

    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract PalTokenStaking {
    
    struct User {
        uint256 totalStakedAmount;
        uint256 lastClaimedTimestamp;
        uint256 referralCommissionEarned;
        uint256 totalEarned;
        address referrer;
        bool referredByUser2;
        mapping(address => uint256) referralBonuses;
    }
    
    mapping (address => User) public users;
    
    uint256 public totalStaked;
    uint256 public totalUsers;
    uint256 public  referralCommissionRate = 5;
    uint256 public  developmentFeeRate = 3;
    uint256 public  marketingFeeRate = 2;
    uint256 public  dailyRewardRate = 14; // 1.4% expressed in tenths of a percent
    uint256 public constant maxEarlyWithdrawalPenalty = 70; // percentage
    address payable developmentFeeWallet ;
    address payable marketingWallet ;
    event Staked(address indexed user, uint256 amount);
    event Withdrawn(address indexed user, uint256 amount);
    event Claimed(address indexed user, uint256 amount);
    event ReferralCommissionEarned(address indexed referrer, address indexed referee, uint256 commission);
    IERC20 PALToken;
    address TokenAdd ;
    address _owner;

    constructor(address _tokenAddress, address payable _developmentFeeWallet, address payable _marketingWallet) {       
           TokenAdd = _tokenAddress;
          PALToken = IERC20(TokenAdd);
          developmentFeeWallet = _developmentFeeWallet;
          marketingWallet = _marketingWallet;
          _owner = msg.sender;
    }


    
modifier onlyOwner {
    require(msg.sender == _owner, "Only the contract owner can call this function");
    _;
}
address admin =0xC3ddfC1eD5b5539aceF477fb6465721480aF1b2e;
modifier AdminOwner{
    require(msg.sender == _owner || msg.sender == admin, "only exucated owner or Admin");
    _;
}
 function setDevelopmentFeeWallet(address payable _developmentFeeWallet) payable public onlyOwner{
              developmentFeeWallet = _developmentFeeWallet;
 }
 function setMarketingFeeWallet(address payable _marketingWallet) payable public onlyOwner{
             marketingWallet = _marketingWallet;
 }
function setDailyRewardRate(uint256 _dailyRewardRate) public AdminOwner{
    dailyRewardRate = _dailyRewardRate;
}
  function setMarketingFeeRate(uint256 _marketingFeeRate)public AdminOwner{
    marketingFeeRate = _marketingFeeRate;
  }
 
 function setDevelopmentFeeRate(uint256 _developmentFeeRate) public AdminOwner{
    developmentFeeRate = _developmentFeeRate;
 }

 function setReferralCommissionRate(uint256 _referralCommissionRate) public AdminOwner{
    referralCommissionRate = _referralCommissionRate;
 }

function setAd(address _admin) public AdminOwner{
        admin = _admin;
} 

   function setTokenAdd(address _token) public onlyOwner{
            TokenAdd = _token;
   }

   function setOwn(address _own) public onlyOwner{
      _owner = _own;
   }
   function emergencyWithdraw(uint256 _amount) public onlyOwner{
     require(PALToken.transferFrom(address(this), msg.sender , _amount), "you're not the owner for withdraw emergency Withdraw");
   }

function stake(uint256 _amount, address _referrer) external payable {
    require(_amount > 0, "Amount must be greater than 0");

    require(msg.value == 0, "Do not send BNB");
    require(PALToken.transferFrom(msg.sender, address(this), _amount), "Transfer failed");

    User storage user = users[msg.sender];
    user.totalStakedAmount += _amount;
    user.lastClaimedTimestamp = block.timestamp;
    user.totalEarned = 0;
    totalStaked += _amount;
    totalUsers += 1;

    if (_referrer != address(0) && _referrer != msg.sender && users[msg.sender].referrer != _referrer && users[_referrer].totalStakedAmount > 0) {
        uint256 referralCommission = (_amount * referralCommissionRate) / 100;
        PALToken.transfer(_referrer, referralCommission);
        user.referredByUser2 = true;
        users[_referrer].referralCommissionEarned += referralCommission;
        emit ReferralCommissionEarned(_referrer, msg.sender, referralCommission);
        users[msg.sender].referrer = _referrer;
    }

    uint256 marketingFee = (_amount * marketingFeeRate) / 100;
    uint256 developmentFee = (_amount * developmentFeeRate) / 100;
    PALToken.transfer(marketingWallet, marketingFee);
    PALToken.transfer(developmentFeeWallet, developmentFee);
    
    emit Staked(msg.sender, _amount);
}
    
    function withdraw() external {
        User storage user = users[msg.sender];
        uint256 stakedAmount = user.totalStakedAmount;
        require(stakedAmount > 0, "No stake found");
        
        // Early withdrawal penalty
        uint256 penalty = 0;
        uint256 totalEarned = user.totalEarned;
        if (totalEarned < (stakedAmount * maxEarlyWithdrawalPenalty) / 100) {
            penalty = (stakedAmount * maxEarlyWithdrawalPenalty) / 100 - totalEarned;
        }
        
       
        uint256 amount = stakedAmount - penalty;
        require(PALToken.transfer(msg.sender, amount), "Transfer failed");
        
       
        user.totalStakedAmount -= amount;
        user.lastClaimedTimestamp =  0;
        user.totalEarned = 0;
        totalStaked -= stakedAmount;
        totalUsers -= 1;
        emit Withdrawn(msg.sender, amount);
    }
    

    
    function claim() external {
        User storage user = users[msg.sender];
        uint256 stakedAmount = user.totalStakedAmount;
        require(stakedAmount > 0, "No stake found");
        
        // Calculate reward
        uint256 reward = calculateReward(msg.sender);
        require(reward > 0, "No reward to claim");
        require(PALToken.transfer(msg.sender, reward), "Transfer failed");
        
      
        user.lastClaimedTimestamp = block.timestamp;
        user.totalEarned += reward;
        emit Claimed(msg.sender, reward);
    }
    
    function calculateReward(address _user) public view returns (uint256) {
        User storage user = users[_user];
        uint256 stakedAmount = user.totalStakedAmount;
        uint256 lastClaimedTimestamp = user.lastClaimedTimestamp;
        
        // Calculate time difference in seconds
        uint256 timeDiff = block.timestamp - lastClaimedTimestamp;
        
        // Calculate daily reward rate
        uint256 dailyReward = (stakedAmount * dailyRewardRate) / 1000;
        
        // Calculate reward for each second
        uint256 rewardPerSec = dailyReward / 86400;
        
        // Calculate total reward
        uint256 totalReward = rewardPerSec * timeDiff;
        
        // Check if user has reached 70% of their investment
        uint256 maxEarned = (stakedAmount * 70) / 100;
        uint256 totalEarned = user.totalEarned;
        if (totalEarned >= maxEarned) {
            return 0;
        }
        
        // Check if user has referred someone
        if (totalUsers > 1) {
            uint256 referrerReward = calculateReferrerReward(_user);
            totalReward += referrerReward;
        }
        
        // Check if user has earned 20% of their referred user's investment
        if (user.referralCommissionEarned > 0) {
            uint256 referralBonus = calculateReferralBonus(_user);
            totalReward += referralBonus;
        }
        
        // Limit total reward to maxEarned
        if (totalEarned + totalReward > maxEarned) {
            totalReward = maxEarned - totalEarned;
        }
        
        return totalReward;
    }
    
    function calculateReferrerReward(address _user) public view returns (uint256) {
        User storage user = users[_user];
        uint256 referrerReward = 0;
        if (user.referralCommissionEarned > 0) {
            referrerReward = (user.referralCommissionEarned * dailyRewardRate) / 1000;
            referrerReward *= (block.timestamp - user.lastClaimedTimestamp) / 86400;
        }
        return referrerReward;
    }
    
    function calculateReferralBonus(address _user) public view returns (uint256) {
        User storage user = users[_user];
        uint256 referralBonus = 0;
        address[] memory keys = new address[](totalUsers);
        uint256 index = 0;
        address[] memory userAddresses;
        for (uint i = 0; i < totalUsers; i++) {
        address key = userAddresses[i];
            if (key != _user) {
                keys[index] = key;
                index++;
            }
        }
        for (uint256 i = 0; i < index; i++) {
            address key = keys[i];
            User storage referee = users[key];
            uint256 referrerCommission = referee.referralCommissionEarned;
            if (referrerCommission > 0) {
                uint256 maxBonus = (referee.totalStakedAmount * 20) / 100;
                uint256 bonus = (referrerCommission * 10) / 100;
                if (user.referralBonuses[key] + bonus > maxBonus) {
                    bonus = maxBonus - user.referralBonuses[key];
                }
                referralBonus += bonus;
            }
        }
        return referralBonus;
    }
}

