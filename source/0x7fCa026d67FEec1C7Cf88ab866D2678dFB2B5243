{"BEP20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"./IBEP20.sol\";\nimport \"./Ownable.sol\";\n\ncontract BEP20 is IBEP20, Ownable {\n  mapping (address =\u003e uint256) private _balances;\n  mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\n\n  string private constant NAME = \"DreamN\";\n  string private constant SYMBOL = \"$DreamN\";\n  uint8 private constant DECIMALS = 18;\n  uint256 private constant TOTAL_SUPPLY = 20 * 10**6 * 10**DECIMALS;\n\n  constructor(address owner, address recipient) Ownable(owner) {\n    require(owner != address(0) \u0026\u0026 recipient != address(0), \"Parameter can\u0027t be zero address\");\n    _balances[recipient] = TOTAL_SUPPLY;\n    emit Transfer(address(0), recipient, TOTAL_SUPPLY);\n  }\n\n  function getOwner() public view returns (address) {\n    return owner();\n  }\n\n  function decimals() public pure returns (uint8) {\n    return DECIMALS;\n  }\n\n  function symbol() external pure returns (string memory) {\n    return SYMBOL;\n  }\n\n  function name() external pure returns (string memory) {\n    return NAME;\n  }\n\n  function totalSupply() external pure returns (uint256) {\n    return TOTAL_SUPPLY;\n  }\n\n  function balanceOf(address account) public view returns (uint256) {\n    return _balances[account];\n  }\n\n  function transfer(address recipient, uint256 amount) external returns (bool) {\n    _transfer(msg.sender, recipient, amount);\n    return true;\n  }\n\n  function allowance(address owner, address spender) external view returns (uint256) {\n    return _allowances[owner][spender];\n  }\n\n  function approve(address spender, uint256 amount) external returns (bool) {\n    _approve(msg.sender, spender, amount);\n    return true;\n  }\n\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) {\n    _transfer(sender, recipient, amount);\n\n    uint256 currentAllowance = _allowances[sender][msg.sender];\n    require(currentAllowance \u003e= amount, \"BEP20: transfer amount exceeds allowance\");\n\n    _approve(sender, msg.sender, currentAllowance - amount);\n    return true;\n  }\n\n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n    _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\n    return true;\n  }\n\n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n    uint256 currentAllowance = _allowances[msg.sender][spender];\n    require(currentAllowance \u003e= subtractedValue, \"BEP20: decreased allowance below zero\");\n\n    _approve(msg.sender, spender, currentAllowance - subtractedValue);\n    return true;\n  }\n\n  function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n    require(sender != address(0), \"BEP20: transfer from the zero address\");\n    require(recipient != address(0), \"BEP20: transfer to the zero address\");\n\n    uint256 senderBalance = _balances[sender];\n    require(senderBalance \u003e= amount, \"BEP20: transfer amount exceeds balance\");\n    _balances[sender] = senderBalance - amount;\n    _balances[recipient] += amount;\n\n    emit Transfer(sender, recipient, amount);\n  }\n\n  function _approve(address owner, address spender, uint256 amount) internal {\n    require(owner != address(0), \"BEP20: approve from the zero address\");\n    require(spender != address(0), \"BEP20: approve to the zero address\");\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n}\n"},"DreamN.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"./BEP20.sol\";\nimport \"./IDEX.sol\";\n\ncontract DreamN is BEP20 {\n  IDexRouter public constant ROUTER = IDexRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n  address public immutable pair;\n\n  address public developmentWallet;\n  address public marketingWallet;\n  address public rewardWallet;\n\n  uint256 public swapThreshold;\n  bool public swapEnabled;\n\n  bool sniperTax = true;\n  bool tradingEnabled;\n  bool inSwap;\n\n  uint256 public buyTax = 500;\n  uint256 public sellTax = 1500;\n  uint256 public transferTax = 0;\n  uint256 public rewardShare = 600;\n  uint256 public marketingShare = 200;\n  uint256 public developmentShare = 200;\n  uint256 totalShares = 1000;\n  uint256 constant TAX_DENOMINATOR = 10000;\n\n  uint256 public transferGas = 25000;\n\n  mapping (address =\u003e bool) public isWhitelisted;\n  mapping (address =\u003e bool) public isCEX;\n  mapping (address =\u003e bool) public isMarketMaker;\n\n  event EnableTrading();\n  event TriggerSwapBack();\n  event Burn(uint256 amount);\n  event RecoverBNB(uint256 amount);\n  event RecoverBEP20(address indexed token, uint256 amount);\n  event SetWhitelisted(address indexed account, bool indexed status);\n  event SetCEX(address indexed account, bool indexed exempt);\n  event SetMarketMaker(address indexed account, bool indexed isMM);\n  event SetTaxes(uint256 reward, uint256 liquidity, uint256 marketing);\n  event SetShares(uint256 rewardShare, uint256 developmentShare, uint256 marketingShare);\n  event SetSwapBackSettings(bool enabled, uint256 amount);\n  event SetTransferGas(uint256 newGas, uint256 oldGas);\n  event SetDevelopmentWallet(address newWallet, address oldWallet);\n  event SetMarketingWallet(address newWallet, address oldWallet);\n  event SetRewardWallet(address newAddress, address oldAddress);\n  event DepositDevelopment(address indexed wallet, uint256 amount);\n  event DepositMarketing(address indexed wallet, uint256 amount);\n  event DepositRewards(address indexed wallet, uint256 amount);\n\n  modifier swapping() { \n    inSwap = true;\n    _;\n    inSwap = false;\n  }\n\n  constructor(\n    address owner,\n    address marketing,\n    address development,\n    address rewards\n  ) BEP20(owner, marketing) {\n    require(development != address(0) \u0026\u0026 rewards != address(0), \"Parameter can\u0027t be zero address\");\n\n    pair = IDexFactory(ROUTER.factory()).createPair(ROUTER.WETH(), address(this));\n    _approve(address(this), address(ROUTER), type(uint256).max);\n    isMarketMaker[pair] = true;\n\n    rewardWallet = rewards;\n    marketingWallet = marketing;\n    developmentWallet = development;\n    isWhitelisted[marketingWallet] = true;\n  }\n\n  // Override\n\n  function _transfer(address sender, address recipient, uint256 amount) internal override {\n    if (isWhitelisted[sender] || isWhitelisted[recipient] || inSwap) {\n      super._transfer(sender, recipient, amount);\n      return;\n    }\n    require(tradingEnabled, \"Trading is disabled\");\n\n    if (_shouldSwapBack(recipient)) { _swapBack(); }\n    uint256 amountAfterTaxes = _takeTax(sender, recipient, amount);\n\n    super._transfer(sender, recipient, amountAfterTaxes);\n  }\n\n  receive() external payable {}\n\n  // Private\n\n  function _takeTax(address sender, address recipient, uint256 amount) private returns (uint256) {\n    if (amount == 0) { return amount; }\n\n    uint256 taxAmount = amount * _getTotalTax(sender, recipient) / TAX_DENOMINATOR;\n    if (taxAmount \u003e 0) { super._transfer(sender, address(this), taxAmount); }\n\n    return amount - taxAmount;\n  }\n\n  function _getTotalTax(address sender, address recipient) private view returns (uint256) {\n    if (sniperTax) { return TAX_DENOMINATOR - 100; }\n    if (isCEX[recipient]) { return 0; }\n    if (isCEX[sender]) { return buyTax; }\n\n    if (isMarketMaker[sender]) {\n      return buyTax;\n    } else if (isMarketMaker[recipient]) {\n      return sellTax;\n    } else {\n      return transferTax;\n    }\n  }\n\n  function _shouldSwapBack(address recipient) private view returns (bool) {\n    return isMarketMaker[recipient] \u0026\u0026 swapEnabled \u0026\u0026 balanceOf(address(this)) \u003e= swapThreshold;\n  }\n\n  function _swapBack() private swapping {\n    address[] memory path = new address[](2);\n    path[0] = address(this);\n    path[1] = ROUTER.WETH();\n    uint256 balanceBefore = address(this).balance;\n\n    ROUTER.swapExactTokensForETH(\n      swapThreshold,\n      0,\n      path,\n      address(this),\n      block.timestamp\n    );\n\n    uint256 amountBNB = address(this).balance - balanceBefore;\n    uint256 amountBNBDevelopment = amountBNB * developmentShare / totalShares;\n    uint256 amountBNBMarketing = amountBNB * marketingShare / totalShares;\n    uint256 amountBNBRewards = amountBNB * rewardShare / totalShares;\n\n    (bool developmentSuccess,) = payable(developmentWallet).call{value: amountBNBDevelopment, gas: transferGas}(\"\");\n    if (developmentSuccess) { emit DepositDevelopment(developmentWallet, amountBNBDevelopment); }\n\n    (bool marketingSuccess,) = payable(marketingWallet).call{value: amountBNBMarketing, gas: transferGas}(\"\");\n    if (marketingSuccess) { emit DepositMarketing(marketingWallet, amountBNBMarketing); }\n\n    (bool rewardSuccess,) = payable(rewardWallet).call{value: amountBNBRewards, gas: transferGas}(\"\");\n    if (rewardSuccess) { emit DepositRewards(rewardWallet, amountBNBRewards); }\n  }\n\n  // Owner\n\n  function enableTrading() external onlyOwner {\n    tradingEnabled = true;\n    emit EnableTrading();\n  }\n\n  function removeSniperTax() external onlyOwner {\n    sniperTax = false;\n  }\n\n  function triggerSwapBack() external onlyOwner {\n    _swapBack();\n    emit TriggerSwapBack();\n  }\n\n  function burnFromStorage(uint256 amount) external onlyOwner {\n    uint256 tokenAmount = amount * 10**decimals();\n    super._transfer(address(this), address(0xdead), tokenAmount);\n    emit Burn(amount);\n  }\n\n  function recoverBNB() external onlyOwner {\n    uint256 amount = address(this).balance;\n    (bool sent,) = payable(marketingWallet).call{value: amount, gas: transferGas}(\"\");\n    require(sent, \"Tx failed\");\n    emit RecoverBNB(amount);\n  }\n\n  function recoverBEP20(IBEP20 token, address recipient) external onlyOwner {\n    require(address(token) != address(this), \"Can\u0027t withdraw DreamN\");\n    uint256 amount = token.balanceOf(address(this));\n    token.transfer(recipient, amount);\n    emit RecoverBEP20(address(token), amount);\n  }\n\n  function setIsWhitelisted(address account, bool value) external onlyOwner {\n    isWhitelisted[account] = value;\n    emit SetWhitelisted(account, value);\n  }\n\n  function setIsCEX(address account, bool value) external onlyOwner {\n    isCEX[account] = value;\n    emit SetCEX(account, value);\n  }\n\n  function setIsMarketMaker(address account, bool value) external onlyOwner {\n    require(account != pair, \"Can\u0027t modify pair\");\n    isMarketMaker[account] = value;\n    emit SetMarketMaker(account, value);\n  }\n\n  function setTaxes(uint256 newBuyTax, uint256 newSellTax, uint256 newTransferTax) external onlyOwner {\n    require(newBuyTax \u003c= 1000 \u0026\u0026 newSellTax \u003c= 2000, \"Too high taxes\");\n    buyTax = newBuyTax;\n    sellTax = newSellTax;\n    transferTax = newTransferTax;\n    emit SetTaxes(buyTax, sellTax, transferTax);\n  }\n\n  function setShares(\n    uint256 newRewardShare,\n    uint256 newDevelopmentShare,\n    uint256 newMarketingShare\n  ) external onlyOwner {\n    rewardShare = newRewardShare;\n    developmentShare = newDevelopmentShare;\n    marketingShare = newMarketingShare;\n    totalShares = rewardShare + developmentShare + marketingShare;\n    emit SetShares(rewardShare, developmentShare, marketingShare);\n  }\n\n  function setSwapBackSettings(bool enabled, uint256 amount) external onlyOwner {\n    uint256 tokenAmount = amount * 10**decimals();\n    swapEnabled = enabled;\n    swapThreshold = tokenAmount;\n    emit SetSwapBackSettings(enabled, amount);\n  }\n\n  function setTransferGas(uint256 newGas) external onlyOwner {\n    require(newGas \u003e= 21000 \u0026\u0026 newGas \u003c= 50000, \"Invalid gas parameter\");\n    emit SetTransferGas(newGas, transferGas);\n    transferGas = newGas;\n  }\n\n  function setDevelopmentWallet(address newWallet) external onlyOwner {\n    require(newWallet != address(0), \"New development wallet is the zero address\");\n    emit SetDevelopmentWallet(newWallet, developmentWallet);\n    developmentWallet = newWallet;\n  }\n\n  function setMarketingWallet(address newWallet) external onlyOwner {\n    require(newWallet != address(0), \"New marketing wallet is the zero address\");\n    emit SetMarketingWallet(newWallet, marketingWallet);\n    marketingWallet = newWallet;\n  }\n\n  function setRewardWallet(address newAddress) external onlyOwner {\n    require(newAddress != address(0), \"New reward pool is the zero address\");\n    emit SetRewardWallet(newAddress, rewardWallet);\n    rewardWallet = newAddress;\n  }\n}\n"},"IBEP20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\ninterface IBEP20 {\n  function totalSupply() external view returns (uint256);\n  function decimals() external view returns (uint8);\n  function symbol() external view returns (string memory);\n  function name() external view returns (string memory);\n  function getOwner() external view returns (address);\n  function balanceOf(address account) external view returns (uint256);\n  function transfer(address recipient, uint256 amount) external returns (bool);\n  function allowance(address _owner, address spender) external view returns (uint256);\n  function approve(address spender, uint256 amount) external returns (bool);\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"IDEX.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\ninterface IDexFactory {\n  function createPair(address tokenA, address tokenB) external returns (address pair);\n}\n\ninterface IDexRouter {\n  function factory() external pure returns (address);\n  function WETH() external pure returns (address);\n\n  function swapExactTokensForETH(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external returns (uint[] memory amounts);\n}\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nabstract contract Ownable {\n  address private _owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  modifier onlyOwner() {\n    require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  constructor(address newOwner) {\n    _owner = newOwner;\n    emit OwnershipTransferred(address(0), newOwner);\n  }\n\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n    emit OwnershipTransferred(_owner, newOwner);\n    _owner = newOwner;\n  }\n\n  function owner() internal view returns (address) {\n    return _owner;\n  }\n}\n"}}