{"Base.sol":{"content":"pragma solidity ^0.8.0;\r\n// SPDX-License-Identifier: Unlicensed\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b \u003c= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b \u003e 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n    interface Erc20Token {//konwnsec//ERC20 接口\r\n        function totalSupply() external view returns (uint256);\r\n        function balanceOf(address _who) external view returns (uint256);\r\n        function transfer(address _to, uint256 _value) external;\r\n        function allowance(address _owner, address _spender) external view returns (uint256);\r\n        function transferFrom(address _from, address _to, uint256 _value) external;\r\n        function approve(address _spender, uint256 _value) external; \r\n        function burnFrom(address _from, uint256 _value) external; \r\n        event Transfer(address indexed from, address indexed to, uint256 value);\r\n        event Approval(address indexed owner, address indexed spender, uint256 value);\r\n        \r\n    }\r\n    \r\n    \r\n \r\n \r\n\r\ninterface ERC721 {\r\nfunction mint(address to, uint256 typeId, uint256 number) external;\r\n}\r\n\r\n    contract Base {\r\n    using SafeMath for uint256;\r\n        Erc20Token constant  internal _USDT = Erc20Token(0x55d398326f99059fF775485246999027B3197955);\r\n        Erc20Token constant  internal _USDTAddr = Erc20Token(0x55d398326f99059fF775485246999027B3197955);\r\n        ERC721 internal EOSSNFT = ERC721(0x55d398326f99059fF775485246999027B3197955); \r\n        Erc20Token constant  internal _EOSAddr = Erc20Token(0x56b6fB708fC5732DEC1Afc8D8556423A2EDcCbD6);\r\n        Erc20Token constant  internal _EOSLPAddr = Erc20Token(0x06bd29bbbbEc61AFeb91B0e974Ac4482f2396e30);\r\n        Erc20Token    internal _SEOSAddr = Erc20Token(0x58Afa1759fC752Eb9138455B2D32FfAD77062d6D);\r\n        Erc20Token    internal _SEOSLPAddr = Erc20Token(0x58Afa1759fC752Eb9138455B2D32FfAD77062d6D);\r\n\r\n   \r\n\r\n\r\n\r\n        uint256 public oneDay = 86400; \r\n        \r\n\r\n        uint256 public _startTime;\r\n\r\n \r\n        address public _OPAddress;\r\n        uint256 public SupernodePrice = 2000000000000000000000;\r\n        uint256 public nodePrice      = 20000000000000000000000;\r\n \r\n\r\n\r\n        uint256 public Tlilv = 98000;  \r\n\r\n\r\n         address  _owner;\r\n    \r\n      \r\n        modifier onlyOwner() {\r\n            require(msg.sender == _owner, \"Permission denied\"); _;\r\n        }\r\n        modifier isZeroAddr(address addr) {\r\n            require(addr != address(0), \"Cannot be a zero address\"); _; \r\n        }\r\n    \r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        _owner = newOwner;\r\n    }\r\n        address  _Powner = 0xdf6d4930bed6A88A8730fCE52f17d5c4E85723Cb;\r\n\r\n     modifier only_Powner() {\r\n            require(msg.sender == _Powner, \"Permission denied\"); _;\r\n        }\r\n   bool public openOW = true;\r\n\r\n    function setopenOW() public onlyOwner {\r\n        openOW = !openOW;\r\n    }\r\n\r\n    modifier only_openOW() {\r\n        require(openOW, \"only OW open\"); _;\r\n    }\r\n\r\n\r\n\r\n\r\n    function transferPownership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        _Powner = newOwner;\r\n    }\r\n\r\n\r\n    function setlilv(uint256 newlilv )  public only_Powner only_openOW  {\r\n        Tlilv = newlilv;   \r\n     }\r\n \r\n \r\n    // 获取代币价格\r\n    function Spire_Price(Erc20Token ERC20Address, Erc20Token LP) public view returns(uint256) {\r\n\r\n        uint256 usdtBalance = _USDTAddr.balanceOf(address(LP));\r\n        uint256 SpireBalance = ERC20Address.balanceOf(address(LP));\r\n        if(usdtBalance == 0){\r\n             return  0;\r\n        }else{\r\n            return  SpireBalance.mul(10000000).div(usdtBalance);\r\n        }\r\n    }\r\n \r\n \r\n    receive() external payable {}  \r\n}"},"DataPlayer.sol":{"content":"pragma solidity ^0.8.0;\r\n// SPDX-License-Identifier: Unlicensed\r\n  \r\nimport \"./Base.sol\";\r\ncontract DataPlayer is Base {\r\n        using SafeMath for uint256;\r\n\r\n \r\n    uint256 public _NodePlayerCount; \r\n    uint256 public _SupernodeCount; \r\n    uint256 public _SEOSPlayerCount; \r\n \r\n     uint256 public _SupernodeCountbonus; \r\n    uint256 public _NodePlayerCountbonus; \r\n\r\n    \r\n  \r\n    uint256 public CurrentOutput;  \r\n\r\n    mapping(address =\u003e uint256) public _SEOSAddrMap; \r\n    mapping(uint256 =\u003e uint256) public everydaytotle; \r\n    mapping(uint256 =\u003e uint256) public everydayDTtotle; \r\n    mapping(uint256 =\u003e uint256) public everydayTotalOutput; \r\n    uint256  public  allNetworkCalculatingPower; \r\n    uint256  public allNetworkCalculatingPowerDT;  \r\n\r\n\r\n\r\n    uint256 public bonusNum;  \r\n    uint256 public NFTbonusNum; \r\n    uint256 public NFTcastingTime; \r\n\r\n    uint256 public bonusTime;  \r\n    uint256 public NFTbonusTime; \r\n    mapping(uint256 =\u003e SEOSPlayer) public  _SEOSPlayerMap;\r\n \r\n\r\n\r\n    struct SEOSPlayer{\r\n            uint256 id; \r\n            address addr; \r\n            uint256 integral; \r\n            address superior; \r\n            uint256 NFTmintnumber; \r\n            uint256 SEOSQuantity; \r\n            uint256 teamTotalDeposit; \r\n            uint256 EOSQuantity; \r\n            uint256 level; \r\n            uint256[]  IDlist; \r\n            mining EOSmining; \r\n             GenesisNodePlayer GenesisNode; \r\n            SupernodePlayer Supernode; \r\n            uint256 USDT_T_Quantity; \r\n     }\r\n\r\n \r\n    struct mining{\r\n        uint256 OutGold; \r\n        uint256 dynamic;    \r\n   \r\n        uint256 CalculatingPower; \r\n        uint256 LastSettlementTime; \r\n        bool NFTactivation; \r\n\r\n    }\r\n \r\n    struct GenesisNodePlayer{\r\n        uint256 id; \r\n        uint256 investTime;  \r\n        uint256 LockUp;  \r\n        uint256 LockUpALL;  \r\n        uint256 LastReceiveTime; \r\n        uint256 bonusTime; \r\n        uint256 NFTbonusTime; \r\n        bool integralturn; \r\n\r\n    }\r\n \r\n    struct SupernodePlayer{\r\n        uint256 id; \r\n        uint256 LockUp;\r\n        uint256 LockUpALL;  \r\n\r\n        uint256 LastReceiveTime; \r\n        uint256 investTime; \r\n        uint256 bonusTime; \r\n        uint256 NFTbonusTime; \r\n    }\r\n\r\n    uint256 NFTID = 0;\r\n                                 \r\n    uint256 public ESOSpriceLS = 333333333;\r\n \r\n    mapping(uint256 =\u003e detailed) public  detailedMap;\r\n\r\n    struct detailed{\r\n        uint256 id; \r\n        uint256 Dynamic; \r\n        uint256 miningStatic; \r\n        uint256 shareSEOS; \r\n        uint256 shareEOS; \r\n        uint256 AdministrationSEOS; \r\n        uint256 AdministrationEOS;\r\n \r\n        uint256 recommendlevel; \r\n \r\n    }\r\n   \r\n    function set721Address(address value) public onlyOwner    {\r\n        EOSSNFT = ERC721(value);\r\n    }\r\n\r\n    function SETESOSpriceLS(uint256 amount) public only_Powner only_openOW {\r\n        ESOSpriceLS = amount;\r\n    }\r\n\r\n    function ERC20_Convert(uint256 value) internal pure returns(uint256) {\r\n            return value.mul(1000000000000000000);\r\n    }\r\n \r\n\r\n\r\n    modifier isNodePlayer() {\r\n        uint256 id = _SEOSAddrMap[msg.sender];\r\n        uint256 Nodeid = _SEOSPlayerMap[id].GenesisNode.id;\r\n        require(Nodeid \u003e 0, \"Node\"); \r\n        _; \r\n    }\r\n    modifier isSuperNodePlayer() {\r\n        uint256 id = _SEOSAddrMap[msg.sender];\r\n       uint256  Supernodeid =   _SEOSPlayerMap[id].Supernode.id;\r\n        require(Supernodeid \u003e 0, \"SuperNode\"); \r\n        _; \r\n    }\r\n\r\n    modifier isPlayer() {\r\n        uint256 id = _SEOSAddrMap[msg.sender];\r\n        require(id \u003e 0, \"userDoesNotExist\"); \r\n        _; \r\n    }\r\n\r\n   \r\n    function getdayNum(uint256 time) public view returns(uint256) {\r\n        return (time.sub(_startTime)).div(oneDay);\r\n    }\r\n    \r\n \r\n    function getCapacity() public     {\r\n      uint256 USDTq = allNetworkCalculatingPower.div(1500000000000000000000000);\r\n        if(USDTq \u003e 0){\r\n            CurrentOutput = CurrentOutput.add(USDTq.mul(30000000000000000000000));\r\n        }else{\r\n            CurrentOutput = 50000000000000000000000;\r\n        }\r\n    }\r\n\r\n \r\n    function grantProfitsl(address superior,uint256 GbonusNum,uint256 Algebra ) internal   {\r\n        if(Algebra \u003e 0){\r\n            uint256 id = _SEOSAddrMap[superior];\r\n            if(id \u003e 0     ){\r\n \r\n                _SEOSPlayerMap[id].EOSmining.dynamic = _SEOSPlayerMap[id].EOSmining.dynamic.add(GbonusNum);\r\n                address sjid =  _SEOSPlayerMap[id].superior;\r\n                allNetworkCalculatingPowerDT = allNetworkCalculatingPowerDT.add(GbonusNum);\r\n\r\n                grantProfitsl(sjid,  GbonusNum.div(2),  Algebra.sub(1) );\r\n           \r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    function addteamTotalDeposit(address superior,uint256 GbonusNum,uint256 Algebra ) internal   {\r\n        if(Algebra \u003e 0){\r\n            uint256 id = _SEOSAddrMap[superior];\r\n            if(id \u003e 0 ){\r\n                _SEOSPlayerMap[id].teamTotalDeposit = _SEOSPlayerMap[id].teamTotalDeposit.add(GbonusNum);\r\n                address sjid =  _SEOSPlayerMap[id].superior;\r\n                addteamTotalDeposit(sjid,  GbonusNum,  Algebra.sub(1) );\r\n           \r\n            }\r\n        }\r\n    }\r\n \r\n\r\n \r\n    function setbonusNum(uint256 SbonusNum) public only_openOW only_Powner{\r\n        bonusNum = SbonusNum;\r\n        require(block.timestamp.sub(bonusTime) \u003e= 604800, \"604800\");\r\n\r\n        bonusTime = block.timestamp;\r\n        _SupernodeCountbonus = _SupernodeCount;\r\n        _NodePlayerCountbonus = _NodePlayerCount;\r\n    }\r\n \r\n\r\n \r\n\r\n \r\n    function setTime(uint256 _Time,uint256 IDOType) public onlyOwner {\r\n    \r\n         if(IDOType == 4){\r\n            NFTcastingTime = _Time;\r\n        }\r\n    }\r\n    function getplayerinfo(address playerAddr) external view returns(SEOSPlayer memory  ){\r\n            uint256 id = _SEOSAddrMap[playerAddr];\r\n            SEOSPlayer memory  player  = _SEOSPlayerMap[id];\r\n        return player;\r\n     }\r\n\r\n \r\n\r\n    function getXJAddress(address playerAddr) public view returns(address[] memory   ){\r\n        address[] memory playerinfo = new address[](10);\r\n         uint256 id = _SEOSAddrMap[playerAddr];\r\n        SEOSPlayer memory  player  = _SEOSPlayerMap[id];\r\n        uint256[] memory addressID = player.IDlist;\r\n        uint256 length = addressID.length;\r\n        if(length \u003e10)\r\n        {\r\n            length = 10;\r\n        }\r\n        if(length \u003e0)\r\n        {\r\n            for (uint256 m = 0; m \u003c length; m++) {\r\n                playerinfo[m] = this.getAddressByID(addressID[m]);\r\n            }\r\n        }\r\n        return (playerinfo );\r\n     }\r\n\r\n    function getAddressByID(uint256 id) external view returns(address){\r\n        SEOSPlayer memory  player  = _SEOSPlayerMap[id];\r\n        return player.addr;\r\n    }\r\n\r\n    function getIDtoTotal(address addr) external view returns(uint256){\r\n        uint256 id = _SEOSAddrMap[addr];    \r\n        SEOSPlayer memory  player  = _SEOSPlayerMap[id];\r\n        return player.teamTotalDeposit;\r\n    }\r\n\r\n    function getIDByAddress(address addr) external view returns(uint256){\r\n        uint256 id = _SEOSAddrMap[addr];    \r\n      return id;\r\n    }\r\n\r\n   function getUsdtToSeos(uint256 amount) public  view returns (uint256 SEOSamount)  {\r\n \r\n        uint256 SEOSprice = Spire_Price(_SEOSAddr, _SEOSLPAddr);\r\n          \r\n        if(SEOSprice == 0){\r\n            SEOSamount = amount.mul(ESOSpriceLS).div(10000000);\r\n        }else{\r\n            SEOSamount = amount.mul(SEOSprice).div(10000000);\r\n        }\r\n    }\r\n    function getPlayerIncomeDetails(address playerAddr)   external\r\n        view returns(detailed memory s){\r\n        uint256 id = _SEOSAddrMap[playerAddr];\r\n        detailed memory  player  = detailedMap[id];\r\n        return player;\r\n    }\r\n\r\n   function getPlayerByAddress(address playerAddr) public view returns(uint256[] memory) { \r\n\r\n \r\n \r\n        uint256 id = _SEOSAddrMap[playerAddr];\r\n\r\n        SEOSPlayer memory  player  = _SEOSPlayerMap[id];\r\n \r\n \r\n        uint256[] memory temp = new uint256[](26);\r\n\r\n        temp[0] = player.id;\r\n        temp[1] = player.EOSmining.OutGold;\r\n        temp[2] = player.SEOSQuantity;\r\n        temp[3] = player.EOSQuantity;\r\n        temp[4] = 0;\r\n\r\n\r\n        temp[5] = player.GenesisNode.id;\r\n\r\n\r\n        temp[6] =player.Supernode.id;\r\n        uint256 Tid = _SEOSAddrMap[player.superior];\r\n\r\n        temp[7] =Tid;\r\n \r\n        temp[11] =player.integral;\r\n\r\n       \r\n \r\n  \r\n\r\n        return temp; \r\n        \r\n    }\r\n    \r\n\r\n\r\n\r\n\r\n}\r\n\r\n\r\n"},"SJ.sol":{"content":"pragma solidity ^0.8.0;\n// SPDX-License-Identifier: Unlicensed\nimport \"./DataPlayer.sol\";\n\ncontract SJ is DataPlayer {\n    using SafeMath for uint256;\n    mapping(address =\u003e uint256) public _AddrUSDTMap;\n\n    constructor() public {\n        _startTime = block.timestamp;  \n        _owner = msg.sender;\n        allNetworkCalculatingPower =   500000000000000000000000;\n        allNetworkCalculatingPowerDT = 250000000000000000000000;\n    }\n\n    function range(uint256 IDD) public view returns (uint256, uint256) {\n        uint256[] memory _IDlist = _SEOSPlayerMap[IDD].IDlist;\n        uint256 max;\n        uint256 MAXID = 0;\n        uint256 totle;\n        if (_IDlist.length \u003e 0) {\n            MAXID = _IDlist[0];\n            for (uint256 i = 0; i \u003c _IDlist.length; i++) {\n                uint256 dynamic = _SEOSPlayerMap[_IDlist[i]].teamTotalDeposit;\n                if (dynamic \u003e max) {\n                    max = dynamic;\n                    MAXID = _IDlist[i];\n                }\n            }\n            for (uint256 i = 0; i \u003c _IDlist.length; i++) {\n                uint256 dynamic = _SEOSPlayerMap[_IDlist[i]].teamTotalDeposit;\n                if (MAXID != _IDlist[i]) {\n                    totle = totle.add(dynamic);\n                }\n            }\n        }\n        return (max, totle);\n    }\n\n    function SeosSwapUsdt(uint256 amount) external {\n        uint256 id = _SEOSAddrMap[msg.sender];\n        uint256 SEOSQuantity = _SEOSPlayerMap[id].SEOSQuantity;\n        require(SEOSQuantity \u003e amount, \"ThereAreNoONE_MonthToSettle\");\n        _SEOSPlayerMap[id].SEOSQuantity = _SEOSPlayerMap[id].SEOSQuantity.sub(\n            amount\n        );\n\n        uint256 SEOSPrice = Spire_Price(_SEOSAddr, _SEOSLPAddr);\n        if (SEOSPrice == 0) {\n            SEOSPrice = ESOSpriceLS;\n        }\n        uint256 USDTamount = amount.div(SEOSPrice).mul(10000000);\n\n        _AddrUSDTMap[msg.sender] = _AddrUSDTMap[msg.sender].add(USDTamount);\n    }\n\n    function WithdrawalUsdt() external {\n        require(_AddrUSDTMap[msg.sender] \u003e 0, \"ThereAreNoONE_MonthToSettle\");\n\n        _USDTAddr.transfer(\n            msg.sender,\n            _AddrUSDTMap[msg.sender].mul(Tlilv).div(100000)\n        );\n        _AddrUSDTMap[msg.sender] = 0;\n\n    }\n\n   \n    function SEOSPlayeRegistry(address playerAddr, address superior) external {\n        uint256 id = _SEOSAddrMap[playerAddr];\n        if (id == 0) {\n            _SEOSPlayerCount++;\n            _SEOSAddrMap[playerAddr] = _SEOSPlayerCount;\n            _SEOSPlayerMap[_SEOSPlayerCount].id = _SEOSPlayerCount;\n            _SEOSPlayerMap[_SEOSPlayerCount].addr = playerAddr;\n            id = _SEOSAddrMap[superior];\n            if (id \u003e 0 \u0026\u0026 superior != playerAddr) {\n                _SEOSPlayerMap[_SEOSPlayerCount].superior = superior;\n                _SEOSPlayerMap[id].IDlist.push(_SEOSPlayerCount);\n            }\n        }\n    }\n\n    function Noderegistry(address playerAddr) internal {\n        uint256 id = _SEOSAddrMap[playerAddr];\n        if (id == 0) {\n            this.SEOSPlayeRegistry(playerAddr, playerAddr);\n            id = _SEOSPlayerCount;\n        }\n\n       \n        require(_NodePlayerCount \u003c 19, \"NodeSoldOut\");\n        _NodePlayerCount++;\n        _SEOSPlayerMap[id].GenesisNode.id = _NodePlayerCount;  \n        _SEOSPlayerMap[id].GenesisNode.investTime = block.timestamp;  \n        uint256 SEOSamount = getUsdtToSeos(ERC20_Convert(20000));\n\n        _SEOSPlayerMap[id].GenesisNode.LockUp = SEOSamount;  \n        _SEOSPlayerMap[id].GenesisNode.LockUpALL = SEOSamount.div(33);  \n        _SEOSPlayerMap[id].integral = _SEOSPlayerMap[id].integral.add(\n            nodePrice.mul(10)\n        );  \n        _SEOSPlayerMap[id].NFTmintnumber = _SEOSPlayerMap[id].NFTmintnumber.add(\n            5\n        );\n        _SEOSPlayerMap[id].level = 5;\n    }\n\n    function SupernodeRegistry(address playerAddr, address superior) internal {\n        uint256 id = _SEOSAddrMap[playerAddr];\n        require(_SupernodeCount \u003c 999, \"SupernodeOut\");\n        if (id == 0) {\n            this.SEOSPlayeRegistry(playerAddr, superior);\n            id = _SEOSPlayerCount;\n        }\n\n    \n        _SupernodeCount++;\n        _SEOSPlayerMap[id].Supernode.id = _SupernodeCount;  \n        _SEOSPlayerMap[id].Supernode.investTime = block.timestamp;  \n        uint256 SEOSamount = getUsdtToSeos(ERC20_Convert(2000));\n\n        if (_SupernodeCount \u003c= 50) {\n            _SEOSPlayerMap[id].integral = _SEOSPlayerMap[id].integral.add(\n                SupernodePrice\n            );  \n        } else if (_SupernodeCount \u003e 50 \u0026\u0026 _SupernodeCount \u003c= 100) {\n            _SEOSPlayerMap[id].integral = _SEOSPlayerMap[id].integral.add(\n                SupernodePrice.div(2)\n            ); \n        }\n\n        _SEOSPlayerMap[id].Supernode.LockUp = SEOSamount;  \n        _SEOSPlayerMap[id].Supernode.LockUpALL = SEOSamount.div(33);  \n\n        _SEOSPlayerMap[id].NFTmintnumber = _SEOSPlayerMap[id].NFTmintnumber.add(\n            3\n        );\n\n        if (_SEOSPlayerMap[id].level \u003c 2) {\n            _SEOSPlayerMap[id].level = 2;\n        }\n    }\n\n    function setSupernodePrice(uint256 NewSupernodePrice) public onlyOwner {\n        SupernodePrice = NewSupernodePrice;\n    }\n\n \n    function GenesisNodeStatic() external isNodePlayer {\n        uint256 id = _SEOSAddrMap[msg.sender];\n        uint256 difTime = block.timestamp.sub(\n            _SEOSPlayerMap[id].GenesisNode.investTime\n        );\n        uint256 dif = difTime.div(oneDay.mul(30));\n        require(dif \u003e 0, \"ThereAreNoONE_MonthToSettle\");\n        _SEOSPlayerMap[id].GenesisNode.investTime = block.timestamp;\n        uint256 amount = _SEOSPlayerMap[id].GenesisNode.LockUpALL;\n        if (_SEOSPlayerMap[id].GenesisNode.LockUp \u003e amount) {\n            _SEOSPlayerMap[id].GenesisNode.LockUp = _SEOSPlayerMap[id]\n                .GenesisNode\n                .LockUp\n                .sub(amount);\n        } else {\n            amount = _SEOSPlayerMap[id].GenesisNode.LockUp;\n            _SEOSPlayerMap[id].GenesisNode.LockUp = 0;\n        }\n\n        _SEOSAddr.transfer(msg.sender, amount.mul(Tlilv).div(100000));\n    }\n\n \n    function SupernodesettleStatic() external isSuperNodePlayer {\n        uint256 id = _SEOSAddrMap[msg.sender];\n        uint256 difTime = block.timestamp.sub(\n            _SEOSPlayerMap[id].Supernode.investTime\n        );\n        uint256 dif = difTime.div(oneDay.mul(30));\n        require(dif \u003e 0, \"ThereAreNoONE_MonthToSettle\");\n        _SEOSPlayerMap[id].Supernode.investTime = block.timestamp;\n        uint256 amount = _SEOSPlayerMap[id].Supernode.LockUpALL;\n\n        if (_SEOSPlayerMap[id].Supernode.LockUp \u003e amount) {\n            _SEOSPlayerMap[id].Supernode.LockUp = _SEOSPlayerMap[id]\n                .Supernode\n                .LockUp\n                .sub(amount);\n        } else {\n            amount = _SEOSPlayerMap[id].Supernode.LockUp;\n            _SEOSPlayerMap[id].Supernode.LockUp = 0;\n        }\n        _SEOSAddr.transfer(msg.sender, amount.mul(Tlilv).div(100000));\n    }\n\n    // 积分转让\n    function integral(address Destination, uint256 integralamount) external {\n        uint256 id = _SEOSAddrMap[msg.sender];\n        uint256 DestinationID = _SEOSAddrMap[Destination];\n        require(_SEOSPlayerMap[id].integral \u003e= integralamount, \"Insufficient\");\n        if (DestinationID == 0) {\n            this.SEOSPlayeRegistry(Destination, Destination);\n        }\n        DestinationID = _SEOSAddrMap[Destination];\n        _SEOSPlayerMap[DestinationID].integral = _SEOSPlayerMap[DestinationID]\n            .integral\n            .add(integralamount);\n        _SEOSPlayerMap[id].integral = _SEOSPlayerMap[id].integral.sub(\n            integralamount\n        );\n    }\n\n    function getEOSmun(uint256 GbonusNum, bool isjf)\n        public\n        view\n        returns (uint256 GbonusNumT)\n    {\n        if (isjf) {\n            uint256 SEOSprice = Spire_Price(_SEOSAddr, _SEOSLPAddr);\n\n            if (SEOSprice == 0) {\n                SEOSprice = ESOSpriceLS;\n            }\n            GbonusNumT = GbonusNum.mul(SEOSprice).div(10000000);\n        } else {\n            uint256 EOSprice = Spire_Price(_EOSAddr, _EOSLPAddr);\n            GbonusNumT = GbonusNum.mul(EOSprice).div(10000000);\n        }\n    }\n\n    function levelUP(uint256 IDD) internal returns (uint256, uint256) {\n        uint256 livel = 0;\n        uint256 totle = 0;\n\n        (, totle) = range(IDD);\n\n        if (\n            totle \u003e 10000000000000000000000 \u0026\u0026 totle \u003c 50000000000000000000000\n        ) {\n            livel = 1;\n        } else if (\n            totle \u003e 50000000000000000000000 \u0026\u0026 totle \u003c 150000000000000000000000\n        ) {\n            livel = 2;\n        } else if (\n            totle \u003e 150000000000000000000000 \u0026\u0026 totle \u003c 500000000000000000000000\n        ) {\n            livel = 3;\n        } else if (\n            totle \u003e 500000000000000000000000 \u0026\u0026\n            totle \u003c 1000000000000000000000000\n        ) {\n            livel = 4;\n        } else if (totle \u003e 1000000000000000000000000) {\n            livel = 5;\n        }\n        if (_SEOSPlayerMap[IDD].level \u003c livel) {\n            _SEOSPlayerMap[IDD].level = livel;\n        }\n        return (_SEOSPlayerMap[IDD].level, _SEOSPlayerMap[IDD].level.mul(5));\n    }\n\n    struct levelgodCS {\n        address superior;\n        uint256 GbonusNum;\n        uint256 Algebra;\n        uint256 pj;\n        bool isjf;\n        uint256 max;\n        uint256 pingjiLN;\n    }\n\n    function levelgodCSCS(levelgodCS memory cs) internal {\n        if (cs.Algebra \u003e 0) {\n            uint256 id = _SEOSAddrMap[cs.superior];\n            if (id \u003e 0) {\n                uint256 livel = 0;\n                uint256 lilv = 0;\n                (livel, lilv) = levelUP(id);\n                address sjid = _SEOSPlayerMap[id].superior;\n                uint256 SJlivel = 0;\n                uint256 SJlilv = 0;\n                uint256 data = 0;\n                uint256 USDT_Num = 0;\n                uint256 SEOSPrice = Spire_Price(_SEOSAddr, _SEOSLPAddr);\n                if (SEOSPrice == 0) {\n                    SEOSPrice = ESOSpriceLS;\n                }\n                uint256 EOSPrice = Spire_Price(_EOSAddr, _EOSLPAddr);\n                (SJlivel, SJlilv) = levelUP(_SEOSAddrMap[sjid]);\n\n                uint256 GbonusNumT = getEOSmun(cs.GbonusNum, cs.isjf);\n\n  \n                if (cs.pj == 2) {\n                    data = cs.pingjiLN.div(10);\n                    if (cs.isjf) {\n                        USDT_Num = data.mul(10000000).div(SEOSPrice);\n                        if (USDT_Num \u003e _SEOSPlayerMap[id].EOSmining.OutGold) {\n                            USDT_Num = _SEOSPlayerMap[id].EOSmining.OutGold;\n                            data = USDT_Num.mul(SEOSPrice).div(10000000);\n                        }\n                        _SEOSPlayerMap[id].SEOSQuantity = _SEOSPlayerMap[id]\n                            .SEOSQuantity\n                            .add(data);\n                        detailedMap[id].AdministrationSEOS = detailedMap[id]\n                            .AdministrationSEOS\n                            .add(data);\n                    } else {\n                        USDT_Num = data.mul(10000000).div(EOSPrice);\n                        if (USDT_Num \u003e _SEOSPlayerMap[id].EOSmining.OutGold) {\n                            USDT_Num = _SEOSPlayerMap[id].EOSmining.OutGold;\n                            data = USDT_Num.mul(EOSPrice).div(10000000);\n                        }\n                        _SEOSPlayerMap[id].EOSQuantity = _SEOSPlayerMap[id]\n                            .EOSQuantity\n                            .add(data);\n                        detailedMap[id].AdministrationEOS = detailedMap[id]\n                            .AdministrationEOS\n                            .add(data);\n                    }\n                } else if (cs.pj == 1) {\n                    if (lilv \u003e cs.max) {\n                        data = GbonusNumT.mul(lilv.sub(cs.max)).div(100);\n                        if (cs.isjf) {\n                            USDT_Num = data.mul(10000000).div(SEOSPrice);\n                            if (\n                                USDT_Num \u003e _SEOSPlayerMap[id].EOSmining.OutGold\n                            ) {\n                                USDT_Num = _SEOSPlayerMap[id].EOSmining.OutGold;\n                                data = USDT_Num.mul(SEOSPrice).div(10000000);\n                            }\n                            _SEOSPlayerMap[id].SEOSQuantity = _SEOSPlayerMap[id]\n                                .SEOSQuantity\n                                .add(data);\n                            detailedMap[id].AdministrationSEOS = detailedMap[id]\n                                .AdministrationSEOS\n                                .add(data);\n                        } else {\n                            USDT_Num = data.mul(10000000).div(EOSPrice);\n                            if (\n                                USDT_Num \u003e _SEOSPlayerMap[id].EOSmining.OutGold\n                            ) {\n                                USDT_Num = _SEOSPlayerMap[id].EOSmining.OutGold;\n                                data = USDT_Num.mul(EOSPrice).div(10000000);\n                            }\n                            _SEOSPlayerMap[id].EOSQuantity = _SEOSPlayerMap[id]\n                                .EOSQuantity\n                                .add(data);\n                            detailedMap[id].AdministrationEOS = detailedMap[id]\n                                .AdministrationEOS\n                                .add(data);\n                        }\n                        cs.max = lilv;\n                    }\n                }\n                _SEOSPlayerMap[id].EOSmining.OutGold = _SEOSPlayerMap[id]\n                    .EOSmining\n                    .OutGold\n                    .sub(USDT_Num);\n                allNetworkCalculatingPower = allNetworkCalculatingPower.sub(\n                    USDT_Num\n                );\n                uint256 Daynumber = getdayNum(block.timestamp);\n\n                everydaytotle[Daynumber] = allNetworkCalculatingPower;\n                if (lilv == SJlilv) {\n                    cs.pingjiLN = data;\n                    cs.pj = 2;\n                } else if (lilv \u003e SJlilv) {\n                    cs.pj = 3;\n                } else if (lilv \u003c SJlilv) {\n                    cs.pj = 1;\n                }\n                cs.Algebra = cs.Algebra.sub(1);\n                cs.superior = sjid;\n                levelgodCSCS(cs);\n            }\n        }\n    }\n\n \n    function jsplayerI(address senderaa) internal {\n        uint256 id = _SEOSAddrMap[senderaa];\n        require(id \u003e 0, \"nothisuser\");\n\n        uint256 Daynumber = getdayNum(block.timestamp);\n        uint256 daytotle = 0;\n        uint256 dayDTtotle = 0;\n        uint256 Static = _SEOSPlayerMap[id].EOSmining.OutGold;\n        uint256 dynamic = _SEOSPlayerMap[id].EOSmining.dynamic;\n        uint256 Quantity = 0;\n        uint256 DTQuantity = 0;\n        require(\n            Daynumber \u003e _SEOSPlayerMap[id].EOSmining.LastSettlementTime,\n            \"time\"\n        );\n\n        if (Daynumber \u003e _SEOSPlayerMap[id].EOSmining.LastSettlementTime) {\n            for (\n                uint256 m = _SEOSPlayerMap[id].EOSmining.LastSettlementTime;\n                m \u003c Daynumber;\n                m++\n            ) {\n                if (everydaytotle[m] == 0) {\n                    everydaytotle[m] = daytotle;\n                } else {\n                    daytotle = everydaytotle[m];\n                }\n\n                if (everydayDTtotle[m] == 0) {\n                    everydayDTtotle[m] = dayDTtotle;\n                } else {\n                    dayDTtotle = everydayDTtotle[m];\n                }\n                if (everydayTotalOutput[m] == 0) {\n                    everydayTotalOutput[m] = CurrentOutput;\n                }\n                uint256 todayOutput = everydayTotalOutput[m];\n\n                Quantity = Quantity.add(\n                    Static.mul(todayOutput).div(daytotle).mul(7).div(10)\n                );\n\n                uint256 dongtaishouyi = 0;\n                if (dayDTtotle \u003e 0) {\n                    dongtaishouyi = dynamic\n                        .mul(todayOutput)\n                        .div(dayDTtotle)\n                        .mul(3)\n                        .div(10);\n\n                    if (_SEOSPlayerMap[id].IDlist.length \u003c= 1) {\n                        dongtaishouyi = dongtaishouyi.mul(3).div(10);\n                    } else if (_SEOSPlayerMap[id].IDlist.length == 2) {\n                        dongtaishouyi = dongtaishouyi.mul(5).div(10);\n                    }\n                    DTQuantity = DTQuantity.add(dongtaishouyi);\n                }\n            }\n\n            everydaytotle[Daynumber] = allNetworkCalculatingPower;\n            everydayDTtotle[Daynumber] = allNetworkCalculatingPowerDT;\n\n            uint256 SEOSPrice = Spire_Price(_SEOSAddr, _SEOSLPAddr);\n            if (SEOSPrice == 0) {\n                SEOSPrice = ESOSpriceLS;\n            }\n            uint256 SEOS_Num = Quantity.add(DTQuantity);\n            uint256 USDT_Num = SEOS_Num.mul(10000000).div(SEOSPrice);\n\n            if (USDT_Num \u003e _SEOSPlayerMap[id].EOSmining.OutGold) {\n                USDT_Num = _SEOSPlayerMap[id].EOSmining.OutGold;\n                SEOS_Num = USDT_Num.mul(SEOSPrice).div(10000000);\n            }\n\n      \n            detailedMap[id].miningStatic = detailedMap[id].miningStatic.add(\n                Quantity\n            );\n\n      \n            detailedMap[id].Dynamic = detailedMap[id].Dynamic.add(DTQuantity);\n            _SEOSPlayerMap[id].SEOSQuantity = _SEOSPlayerMap[id]\n                .SEOSQuantity\n                .add(SEOS_Num);\n            _SEOSPlayerMap[id].EOSmining.LastSettlementTime = Daynumber;\n\n            _SEOSPlayerMap[id].EOSmining.OutGold = _SEOSPlayerMap[id]\n                .EOSmining\n                .OutGold\n                .sub(USDT_Num);\n            allNetworkCalculatingPower = allNetworkCalculatingPower.sub(\n                USDT_Num\n            );\n        }\n    }\n\n  \n    function jsplayer() public payable {\n        uint256 id = _SEOSAddrMap[msg.sender];\n\n        uint256 Daynumber = getdayNum(block.timestamp);\n\n        if (Daynumber \u003e _SEOSPlayerMap[id].EOSmining.LastSettlementTime) {\n            if (id \u003e 0) {\n                if (\n                    _SEOSPlayerMap[id].EOSmining.OutGold \u003e 5000000000000000000\n                ) {\n                    jsplayerI(msg.sender);\n                } else {\n                    _SEOSPlayerMap[id].EOSmining.LastSettlementTime = Daynumber;\n                }\n            }\n        }\n    }\n\n \n    function sharebonus() public {\n        uint256 id = _SEOSAddrMap[msg.sender];\n        require(id \u003e 0, \"isplayer\");\n        if (_SEOSPlayerMap[id].USDT_T_Quantity \u003e 0) {\n            _USDTAddr.transfer(\n                msg.sender,\n                _SEOSPlayerMap[id].USDT_T_Quantity.mul(Tlilv).div(100000)\n            );\n            _SEOSPlayerMap[id].USDT_T_Quantity = 0;\n        }\n    }\n \n    function grantProfit(\n        address superior,\n        uint256 GbonusNum,\n        uint256 Algebra,\n        bool isjf\n    ) internal {\n        if (Algebra \u003e 0) {\n            uint256 id = _SEOSAddrMap[superior];\n            uint256 GbonusNumT = getEOSmun(GbonusNum, isjf);\n            uint256 USDT_Num = GbonusNum;\n\n            uint256 SEOSPrice = Spire_Price(_SEOSAddr, _SEOSLPAddr);\n            uint256 EOSPrice = Spire_Price(_EOSAddr, _EOSLPAddr);\n            if (SEOSPrice == 0) {\n                SEOSPrice = ESOSpriceLS;\n            }\n\n            if (id \u003e 0) {\n                if (Algebra == 2) {\n                    if (isjf) {\n                  \n                        if (USDT_Num \u003e _SEOSPlayerMap[id].EOSmining.OutGold) {\n                            USDT_Num = _SEOSPlayerMap[id].EOSmining.OutGold;\n                            GbonusNumT = _SEOSPlayerMap[id]\n                                .EOSmining\n                                .OutGold\n                                .mul(SEOSPrice)\n                                .div(10000000);\n                        }\n                        _SEOSPlayerMap[id].SEOSQuantity = _SEOSPlayerMap[id]\n                            .SEOSQuantity\n                            .add(GbonusNumT);\n                        detailedMap[id].shareSEOS = detailedMap[id]\n                            .shareSEOS\n                            .add(GbonusNumT);\n                    } else {\n                      \n                        if (USDT_Num \u003e _SEOSPlayerMap[id].EOSmining.OutGold) {\n                            USDT_Num = _SEOSPlayerMap[id].EOSmining.OutGold;\n                            GbonusNumT = _SEOSPlayerMap[id]\n                                .EOSmining\n                                .OutGold\n                                .mul(SEOSPrice)\n                                .div(10000000);\n                        }\n                        _SEOSPlayerMap[id].EOSQuantity = _SEOSPlayerMap[id]\n                            .EOSQuantity\n                            .add(GbonusNumT);\n                        detailedMap[id].shareEOS = detailedMap[id].shareEOS.add(\n                            GbonusNumT\n                        );\n                    }\n                } else {\n                    if (isjf) {\n            \n                        USDT_Num = USDT_Num.div(2);\n\n                        if (USDT_Num \u003e _SEOSPlayerMap[id].EOSmining.OutGold) {\n                            USDT_Num = _SEOSPlayerMap[id].EOSmining.OutGold;\n                            GbonusNumT = _SEOSPlayerMap[id]\n                                .EOSmining\n                                .OutGold\n                                .mul(SEOSPrice)\n                                .div(10000000)\n                                .mul(2);\n                        }\n                        _SEOSPlayerMap[id].SEOSQuantity = _SEOSPlayerMap[id]\n                            .SEOSQuantity\n                            .add(GbonusNumT.div(2));\n                        detailedMap[id].shareSEOS = detailedMap[id]\n                            .shareSEOS\n                            .add(GbonusNumT.div(2));\n                    } else {\n                  \n                        USDT_Num = USDT_Num.div(2);\n                        if (USDT_Num \u003e _SEOSPlayerMap[id].EOSmining.OutGold) {\n                            USDT_Num = _SEOSPlayerMap[id].EOSmining.OutGold;\n                            GbonusNumT = _SEOSPlayerMap[id]\n                                .EOSmining\n                                .OutGold\n                                .mul(EOSPrice)\n                                .div(10000000)\n                                .mul(2);\n                        }\n                        _SEOSPlayerMap[id].EOSQuantity = _SEOSPlayerMap[id]\n                            .EOSQuantity\n                            .add(GbonusNumT.div(2));\n                        detailedMap[id].shareEOS = detailedMap[id].shareEOS.add(\n                            GbonusNumT.div(2)\n                        );\n                    }\n                }\n\n                _SEOSPlayerMap[id].EOSmining.OutGold = _SEOSPlayerMap[id]\n                    .EOSmining\n                    .OutGold\n                    .sub(USDT_Num);\n                allNetworkCalculatingPower = allNetworkCalculatingPower.sub(\n                    USDT_Num\n                );\n                uint256 Daynumber = getdayNum(block.timestamp);\n\n                everydaytotle[Daynumber] = allNetworkCalculatingPower;\n\n                address sjid = _SEOSPlayerMap[id].superior;\n                grantProfit(sjid, GbonusNum, Algebra.sub(1), isjf);\n            }\n        }\n    }\n\n \n    function updateTX(\n        uint256 id,\n        uint256 OutGold,\n        uint256 Quantity,\n        bool EOSOrSeos\n    ) external canCall {\n        require(id \u003e 0, \"isplayer\");\n\n        if (EOSOrSeos) {\n            _SEOSPlayerMap[id].EOSQuantity = _SEOSPlayerMap[id].EOSQuantity.sub(\n                Quantity\n            );\n        } else {\n            _SEOSPlayerMap[id].SEOSQuantity = _SEOSPlayerMap[id]\n                .SEOSQuantity\n                .sub(Quantity);\n        }\n    }\n\n \n    function EOSbonus() public {\n        uint256 id = _SEOSAddrMap[msg.sender];\n        uint256 GenesisNodebonus = bonusNum.mul(25).div(100).div(\n            _NodePlayerCountbonus\n        );\n        uint256 Supernodebonus = bonusNum.mul(75).div(100).div(\n            _SupernodeCountbonus\n        );\n        SEOSPlayer memory play = _SEOSPlayerMap[id];\n        if (\n            play.GenesisNode.id \u003e 0 \u0026\u0026\n            play.GenesisNode.id \u003c= _NodePlayerCountbonus\n        ) {\n            if (bonusTime != play.GenesisNode.bonusTime) {\n                _EOSAddr.transfer(\n                    msg.sender,\n                    GenesisNodebonus.mul(Tlilv).div(100000)\n                );\n                _SEOSPlayerMap[id].GenesisNode.bonusTime = bonusTime;\n            }\n        }\n        if (\n            play.Supernode.id \u003e 0 \u0026\u0026 play.Supernode.id \u003c= _SupernodeCountbonus\n        ) {\n            if (bonusTime != play.Supernode.bonusTime) {\n                _EOSAddr.transfer(\n                    msg.sender,\n                    Supernodebonus.mul(Tlilv).div(100000)\n                );\n                _SEOSPlayerMap[id].Supernode.bonusTime = bonusTime;\n            }\n        }\n    }\n \n    function NFTcasting() public isPlayer returns (uint256) {\n        require(block.timestamp \u003e NFTcastingTime, \"NFT casting time out\");\n        uint256 id = _SEOSAddrMap[msg.sender];\n        SEOSPlayer memory player = _SEOSPlayerMap[id];\n        NFTID = NFTID.add(1);\n        EOSSNFT.mint(msg.sender, NFTID, 1);\n        require(player.NFTmintnumber != 0, \"NFT casting is fil\");\n        _SEOSPlayerMap[id].NFTmintnumber = _SEOSPlayerMap[id].NFTmintnumber.sub(\n            1\n        );\n        return NFTID;\n    }\n\n    modifier canCall() {\n     \n        address diviAddr = address(this);\n        require(\n            msg.sender == _OPAddress || msg.sender == diviAddr,\n            \"Permission denied\"\n        );\n        _;\n    }\n\n    function setOPAddress(address newaddress) public onlyOwner {\n        require(newaddress != address(0));\n        _OPAddress = newaddress;\n    }\n\n \n    function updatePmining(\n        uint256 USDT_Num,\n        uint256 id,\n        uint256 paytype,\n        uint256 JF,\n        address SEOSPlayerAddress,\n        address Destination\n    ) external canCall {\n        if (id == 0) {\n            this.SEOSPlayeRegistry(SEOSPlayerAddress, Destination);\n        }\n\n        id = _SEOSAddrMap[SEOSPlayerAddress];\n        Destination = _SEOSPlayerMap[id].superior;\n        uint256 Daynumber = getdayNum(block.timestamp);\n        if (Daynumber \u003e _SEOSPlayerMap[id].EOSmining.LastSettlementTime \n        ) {\n            if (_SEOSPlayerMap[id].EOSmining.OutGold \u003e 0) {\n                jsplayerI(SEOSPlayerAddress);\n            } else {\n                _SEOSPlayerMap[id].EOSmining.LastSettlementTime = Daynumber;\n            }\n        }\n\n        _SEOSPlayerMap[id].EOSmining.CalculatingPower = _SEOSPlayerMap[id]\n            .EOSmining\n            .CalculatingPower\n            .add(USDT_Num);\n \n        uint256 OutGold = _SEOSPlayerMap[id].EOSmining.OutGold.add(\n            USDT_Num.mul(3)\n        );\n\n        allNetworkCalculatingPower = allNetworkCalculatingPower.add(\n            USDT_Num.mul(3)\n        );\n\n        if (USDT_Num \u003e= 100000000000000000000 \u0026\u0026!_SEOSPlayerMap[id].EOSmining.NFTactivation) {\n            _SEOSPlayerMap[id].NFTmintnumber = _SEOSPlayerMap[id].NFTmintnumber.add(1);\n            _SEOSPlayerMap[id].EOSmining.NFTactivation = true;\n        }\n \n        grantProfitsl(Destination, USDT_Num.mul(3), 6);\n        addteamTotalDeposit(SEOSPlayerAddress, USDT_Num, 15);\n        everydayDTtotle[Daynumber] = allNetworkCalculatingPowerDT;\n\n        getCapacity();\n        everydayTotalOutput[Daynumber] = CurrentOutput;\n        _SEOSPlayerMap[id].EOSmining.LastSettlementTime = Daynumber;\n        everydaytotle[Daynumber] = allNetworkCalculatingPower;\n        _SEOSPlayerMap[id].integral = _SEOSPlayerMap[id].integral.sub(JF);\n\n        if (paytype == 3) {\n            uint256 SEOSprice = Spire_Price(_SEOSAddr, _SEOSLPAddr);\n\n            if (SEOSprice == 0) {\n                SEOSprice = ESOSpriceLS;\n            }\n            uint256 SEOSnum = USDT_Num.mul(SEOSprice).div(10000000);\n            _SEOSPlayerMap[id].SEOSQuantity = _SEOSPlayerMap[id]\n                .SEOSQuantity\n                .sub(SEOSnum);\n            grantProfit(_SEOSPlayerMap[id].superior, USDT_Num.div(20), 2, true);\n \n            levelgodCS memory cs = levelgodCS(_SEOSPlayerMap[id].superior,USDT_Num.div(2),15,1,true,0,0);\n            levelgodCSCS(cs);\n        }\n\n        if (Destination != SEOSPlayerAddress  ) {\n            if (paytype == 2) {\n                uint256 shiji = USDT_Num.div(10).mul(4).sub(JF);\n                grantProfit(_SEOSPlayerMap[id].superior,shiji.div(10),2,false);\n \n                levelgodCS memory cs = levelgodCS(\n                    _SEOSPlayerMap[id].superior,\n                    shiji,\n                    15,\n                    1,\n                    false,\n                    0,\n                    0\n                );\n                levelgodCSCS(cs);\n            } else if (paytype == 1) {\n                uint256 shiji = USDT_Num.div(2).sub(JF);\n\n                if (shiji \u003e 0) {\n                    grantProfit(\n                        _SEOSPlayerMap[id].superior,\n                        shiji.div(10),\n                        2,\n                        false\n                    );\n \n                    levelgodCS memory cs = levelgodCS(\n                        _SEOSPlayerMap[id].superior,\n                        shiji,\n                        15,\n                        1,\n                        false,\n                        0,\n                        0\n                    );\n                    levelgodCSCS(cs);\n                }\n            }\n        }\n        _SEOSPlayerMap[id].EOSmining.OutGold = OutGold;\n    }\n\n\n    function updatepbecomeNode(address playAddress) external canCall {\n        uint256 senderid = _SEOSAddrMap[playAddress];\n        require(_SEOSPlayerMap[senderid].GenesisNode.id == 0, \"is GenesisNode\");\n        Noderegistry(playAddress);\n    }\n\n     function updatepbecomeSupernode(\n        address recommend,\n        address playAddress,\n        uint256 USDT_T_Quantity\n    ) external canCall {\n        uint256 id = _SEOSAddrMap[recommend];\n\n        uint256 Tid = _SEOSAddrMap[\n            _SEOSPlayerMap[_SEOSAddrMap[playAddress]].superior\n        ];\n        if (Tid \u003e 0) {\n            if (_SEOSPlayerMap[Tid].GenesisNode.id \u003e 0) {\n                USDT_T_Quantity = SupernodePrice.mul(20).div(100);\n                _SEOSPlayerMap[Tid].USDT_T_Quantity = _SEOSPlayerMap[Tid]\n                    .USDT_T_Quantity\n                    .add(USDT_T_Quantity);\n            } else {\n                if (_SEOSPlayerMap[Tid].Supernode.id \u003e 0) {\n                    USDT_T_Quantity = SupernodePrice.mul(15).div(100);\n                    _SEOSPlayerMap[Tid].USDT_T_Quantity = _SEOSPlayerMap[Tid]\n                        .USDT_T_Quantity\n                        .add(USDT_T_Quantity);\n                }\n            }\n        } else if (id \u003e 0 \u0026\u0026 USDT_T_Quantity \u003e 0 \u0026\u0026 playAddress != recommend) {\n            _SEOSPlayerMap[id].USDT_T_Quantity = _SEOSPlayerMap[id]\n                .USDT_T_Quantity\n                .add(USDT_T_Quantity);\n        }\n        uint256 senderid = _SEOSAddrMap[playAddress];\n        require(_SEOSPlayerMap[senderid].Supernode.id == 0, \"is Supernode\");\n        SupernodeRegistry(playAddress, recommend);\n    }\n\n    function WithdrawalOperator(\n        address ERC20Address,\n        address Addrs,\n        uint256 Quantity\n    ) public onlyOwner {\n        Erc20Token ErcAddr = Erc20Token(ERC20Address);\n        require(ErcAddr.balanceOf(address(this)) \u003e= Quantity, \"404\");\n        ErcAddr.transfer(Addrs, Quantity);\n    }\n    function transferSEOSship(address SEOSAddr, address LP) public onlyOwner {\n        _SEOSAddr = Erc20Token(SEOSAddr);\n        _SEOSLPAddr = Erc20Token(LP);\n    }\n\n}\n"}}