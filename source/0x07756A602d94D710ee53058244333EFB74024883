{"Context.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity \u003e= 0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}"},"FinanceBase.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity \u003e= 0.8.5;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./IPancakeRouterV2.sol\";\r\nimport \"./Ownable.sol\";\r\nimport \"./ReentrancyGuard.sol\";\r\n\r\n// Base class that implements: BEP20 interface, fees \u0026 swaps\r\nabstract contract FinanceBase is Context, IERC20Metadata, Ownable, ReentrancyGuard {\r\n\t// MAIN TOKEN PROPERTIES\r\n\tstring private constant NAME = \"TRINITY\";\r\n\tstring private constant SYMBOL = \"TRIN\";\r\n\tuint8 private constant DECIMALS = 9;\r\n\tuint8 private _liquidityFee; //% of each transaction that will be added as liquidity\r\n\tuint8 private _rewardFee; //% of each transaction that will be used for BNB reward pool\r\n\tuint8 private _marketingFee; //% of each transaction that will be used for _marketingFee\r\n\tuint8 private _additionalSellFee; //Additional % fee to apply on sell transactions. Half of it will be split between liquidity, rewards and marketing\r\n\tuint8 private _poolFee; //The total fee to be taken and added to the pool, this includes the liquidity fee, marketing fee and the reward fee\r\n\t\r\n\t//Previous Fees\r\n\tuint8 private _previousLiquidityFee; \r\n\tuint8 private _previousRewardFee;\r\n\tuint8 private _previousMarketingFee;\r\n\tuint8 private _previousAdditionalSellFee;\r\n\tuint8 private _previousPoolFee; \r\n    \r\n\tuint256 private constant _totalTokens = 10000000 * 10**DECIMALS;\t//10 million total supply\r\n\tmapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\r\n\tmapping (address =\u003e uint256) private _balances; //The balance of each address.  This is before applying distribution rate.  To get the actual balance, see balanceOf() method\r\n\tmapping (address =\u003e bool) private _addressesExcludedFromFees; // The list of addresses that do not pay a fee for transactions\r\n\tmapping (address =\u003e bool) private _blacklistedAddresses; //blacklisted addresses\r\n\tmapping (address =\u003e uint256) private _sellsAllowance; //consecutive sells are not allowed within a 1min window\r\n\r\n\t// FEES \u0026 REWARDS\r\n\tbool private _isSwapEnabled; // True if the contract should swap for liquidity \u0026 reward pool, false otherwise\r\n\tbool private _isFeeEnabled; // True if fees should be applied on transactions, false otherwise\r\n\tbool private _isBuyingAllowed; // This is used to make sure that the contract is activated before anyone makes a purchase on PCS.  The contract will be activated once liquidity is added.\r\n    bool private _takeEcoSystem; // If this is enabled the extra sell fee goes towards the marketing wallet and will be used to fund the ecosystem rewards\r\n\r\n\tuint256 private _tokenSwapThreshold = _totalTokens / 10000000; //There should be at least of the total supply in the contract before triggering a swap\r\n\tuint256 private _totalFeesPooled; // The total fees pooled (in number of tokens)\r\n\tuint256 private _totalBNBLiquidityAddedFromFees; // The total number of BNB added to the pool through fees\r\n\tuint256 private _transactionLimit = _totalTokens; // The amount of tokens that can be sold at once\r\n\r\n\t// UNISWAP INTERFACES (For swaps)\r\n\taddress public constant BURN_WALLET = 0x000000000000000000000000000000000000dEaD; //The address that keeps track of all tokens burned\r\n\tIPancakeRouter02 internal _pancakeswapV2Router;\r\n\taddress private _pancakeswapV2Pair;\r\n\taddress private _autoLiquidityWallet; \r\n\taddress private _marketingWallet;\r\n\r\n\t// EVENTS\r\n\tevent Swapped(uint256 tokensSwapped, uint256 bnbReceived, uint256 tokensIntoLiqudity, uint256 bnbIntoLiquidity, bool successSentMarketing);\r\n    \r\n  \r\n\tconstructor (address routerAddress) {\r\n\t\t_balances[_msgSender()] = totalSupply();\r\n\t\t\r\n\t\t// Exclude contract from fees\r\n\t\t_addressesExcludedFromFees[address(this)] = true;\r\n\t\t_marketingWallet = msg.sender;\r\n\r\n\t\t// Initialize Pancakeswap V2 router and Future \u003c-\u003e BNB pair.\r\n\t\tsetPancakeswapRouter(routerAddress);\r\n        \r\n\t\t// 3% liquidity fee, 7% reward fee, 5% marketing, 3% additional sell fee\r\n\t\tsetFees(3, 7, 5, 3);\r\n        \r\n\t\temit Transfer(address(0), _msgSender(), totalSupply());\r\n\t}\r\n\r\n\tfunction presale() public onlyOwner {\r\n\t\tsetSwapEnabled(false);\r\n\t\tsetFeeEnabled(false);\r\n\t\tsetExcludedFromFees(owner(),true);\r\n\t\tsetTransactionLimit(_totalTokens); \r\n\t\tsetFees(0, 0, 0, 0);\r\n\t}\r\n\r\n\t// This function is used to enable all functions of the contract, after the setup of the token sale (e.g. Liquidity) is completed\r\n\tfunction activate() public onlyOwner {\r\n\r\n        toggleEcoSystem(true);\r\n\t\tsetSwapEnabled(true);\r\n\t\tsetFeeEnabled(true);\r\n\t\tsetAutoLiquidityWallet(owner());\r\n\t\tsetTransactionLimit(100000000000000); // only 1% of the total supply can be sold at once\r\n\t\tsetFees(3, 7, 5, 3);\r\n\t\tactivateBuying();\r\n\t\tonActivated();\r\n\t}\r\n\t\r\n\tfunction setMarketingWallet(address marketingWallet) public onlyOwner() {\r\n        _marketingWallet = marketingWallet;\r\n    }\r\n\r\n    // when disabled the additional fee goes towards rewards, lps and marketing\r\n\tfunction toggleEcoSystem(bool status) public onlyOwner() {\r\n        _takeEcoSystem = status;\r\n    }\r\n\r\n\t// returns the ecosystem status\r\n\tfunction getEcosytemStatus() public view returns (bool) {\r\n        return _takeEcoSystem;\r\n    }\r\n  \r\n    function getMarketingWallet() public view returns (address) {\r\n        return _marketingWallet;\r\n    }\r\n\r\n\tfunction onActivated() internal virtual { }\r\n    \r\n\tfunction balanceOf(address account) public view override returns (uint256) {\r\n\t\treturn _balances[account];\r\n\t}\r\n\t\r\n\r\n\tfunction transfer(address recipient, uint256 amount) public override returns (bool) {\r\n\t\tdoTransfer(_msgSender(), recipient, amount);\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\r\n\tfunction transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n\t\tdoTransfer(sender, recipient, amount);\r\n\t\tdoApprove(sender, _msgSender(), _allowances[sender][_msgSender()] - amount); // Will fail when there is not enough allowance\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\r\n\tfunction approve(address spender, uint256 amount) public override returns (bool) {\r\n\t\tdoApprove(_msgSender(), spender, amount);\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tfunction doTransfer(address sender, address recipient, uint256 amount) internal virtual {\r\n\t\trequire(sender != address(0), \"Transfer from the zero address is not allowed\");\r\n\t\trequire(recipient != address(0), \"Transfer to the zero address is not allowed\");\r\n\t\trequire(amount \u003e 0, \"Transfer amount must be greater than zero\");\r\n\t\trequire(!isPancakeswapPair(sender) || _isBuyingAllowed, \"Buying is not allowed before contract activation\");\r\n\t\t\r\n\t\t// Ensure that amount is within the limit in case we are selling\r\n\t\tif (isTransferLimited(sender, recipient)) {\r\n\t\t\trequire(amount \u003c= _transactionLimit, \"Transfer amount exceeds the maximum allowed\");\r\n\t\t}\r\n\r\n\r\n\t\t// Perform a swap if needed.  A swap in the context of this contract is the process of swapping the contract\u0027s token balance with BNBs in order to provide liquidity and increase the reward pool\r\n\t\texecuteSwapIfNeeded(sender, recipient);\r\n\r\n\t\tonBeforeTransfer(sender, recipient, amount);\r\n\r\n\t\t// Calculate fee rate\r\n\t\tuint256 feeRate = calculateFeeRate(sender, recipient);\r\n\t\t\r\n\t\tuint256 feeAmount = amount * feeRate / 100;\r\n\t\tuint256 transferAmount = amount - feeAmount;\r\n\r\n\t\t// Update balances\r\n\t\tupdateBalances(sender, recipient, amount, feeAmount);\r\n\r\n \t\t// Update total fees, this is just a counter provided for visibility\r\n\t\tuint256 feesPooled = _totalFeesPooled;\r\n\t\t_totalFeesPooled = feeAmount + feesPooled;\r\n\r\n\t\temit Transfer(sender, recipient, transferAmount); \r\n\t\tonTransfer(sender, recipient, amount);\r\n\r\n\t}\r\n\t\r\n\tfunction executeSwapIfNeeded(address sender, address recipient) private {\r\n\t\tif (!isMarketTransfer(sender, recipient)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Check if it\u0027s time to swap for liquidity \u0026 reward pool\r\n\t\tuint256 tokensAvailableForSwap = balanceOf(address(this));\r\n\t\tif (tokensAvailableForSwap \u003e= _tokenSwapThreshold) {\r\n\r\n\t\t\t//limit swap amount\r\n\t\t\ttokensAvailableForSwap = _tokenSwapThreshold;\r\n\r\n\t\t\t// Swap on sells and enable a 60 seconds cooldown\r\n\t\t\tbool isSelling = isPancakeswapPair(recipient);\r\n\t\t\tif (isSelling) {\r\n\t\t\t\texecuteSwap(tokensAvailableForSwap);\r\n\t\t\t    if (sender != address(this)) {\r\n    \t\t\t\trequire((block.timestamp \u003e= (_sellsAllowance[sender] + 60)), \"Your last sell was less than 1 minute ago, wait a bit.\");\r\n    \t\t\t\t_sellsAllowance[sender] = block.timestamp;\r\n\t\t\t    }\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction executeSwap(uint256 amount) private {\r\n\t\t// Allow pancakeswap to spend the tokens of the address\r\n\t\tdoApprove(address(this), address(_pancakeswapV2Router), amount);\r\n\r\n\t\t// The amount parameter includes liquidity, marketing and rewards, we need to find the correct portion for each one so that they are allocated accordingly\r\n\t\tuint8 poolFee = _poolFee ;\r\n\r\n\t\t// send the extra 3% on sells towards marketing\r\n\t\tif(_takeEcoSystem){\r\n\t\t\tpoolFee = poolFee + _additionalSellFee;\r\n\t\t}\r\n\r\n\t\tuint256 tokensReservedForLiquidity = amount * _liquidityFee / poolFee;\r\n\t\tuint256 tokensReservedForReward = amount * _rewardFee / poolFee;\r\n\t\tuint256 tokensReservedForMarketing = amount - tokensReservedForLiquidity - tokensReservedForReward;\r\n\r\n\t\t// For the liquidity portion, half of it will be swapped for BNB and the other half will be used to add the BNB into the liquidity\r\n\t\tuint256 tokensToSwapForLiquidity = tokensReservedForLiquidity / 2;\r\n\t\tuint256 tokensToAddAsLiquidity = tokensToSwapForLiquidity;\r\n\r\n\t\t// Swap both reward tokens, marketing and liquidity tokens for BNB\r\n\t\tuint256 tokensToSwap = tokensReservedForReward + tokensToSwapForLiquidity + tokensReservedForMarketing;\r\n\t\tuint256 bnbSwapped = swapTokensForBNB(tokensToSwap);\r\n\t\t\r\n \t\t// Calculate what portion of the swapped BNB is for liquidity and supply it using the other half of the token liquidity portion.  The remaining BNBs in the contract represent the reward pool\r\n\t\tuint256 bnbToBeAddedToLiquidity = bnbSwapped * tokensToSwapForLiquidity / tokensToSwap;\r\n\t\tuint256 bnbToBeSentToMarketing = bnbSwapped * tokensReservedForMarketing / tokensToSwap;\r\n\t\t\r\n\t\t(bool successSentMarketing,) = _marketingWallet.call{value:bnbToBeSentToMarketing}(\"\");\r\n\t\t(,uint bnbAddedToLiquidity,) = _pancakeswapV2Router.addLiquidityETH{value: bnbToBeAddedToLiquidity}(address(this), tokensToAddAsLiquidity, 0, 0, _autoLiquidityWallet, block.timestamp + 360);\r\n\r\n\t\t// Keep track of how many BNB were added to liquidity this way\r\n\t\tuint256 totalBnbAddedFromFees = _totalBNBLiquidityAddedFromFees + bnbAddedToLiquidity;\r\n\t\t_totalBNBLiquidityAddedFromFees = totalBnbAddedFromFees;\r\n\t\t\r\n\t\temit Swapped(tokensToSwap, bnbSwapped, tokensToAddAsLiquidity, bnbToBeAddedToLiquidity, successSentMarketing);\r\n\t}\r\n\r\n\tfunction onBeforeTransfer(address sender, address recipient, uint256 amount) internal virtual { }\r\n\r\n\tfunction onTransfer(address sender, address recipient, uint256 amount) internal virtual { }\r\n\r\n\r\n\tfunction updateBalances(address sender, address recipient, uint256 sentAmount, uint256 feeAmount) private {\r\n\t\t// Calculate amount to be received by recipient\r\n\t\tuint256 receivedAmount = sentAmount - feeAmount;\r\n\r\n\t\t// Update balances\r\n\t\t_balances[sender] -= sentAmount;\r\n\t\t_balances[recipient] += receivedAmount;\r\n\t\t\r\n\t\t// Add fees to contract\r\n\t\t_balances[address(this)] += feeAmount;\r\n\t}\r\n\r\n\r\n\tfunction doApprove(address owner, address spender, uint256 amount) private {\r\n\t\trequire(owner != address(0), \"Cannot approve from the zero address\");\r\n\t\trequire(spender != address(0), \"Cannot approve to the zero address\");\r\n\r\n\t\t_allowances[owner][spender] = amount;\r\n\t\temit Approval(owner, spender, amount);\r\n\t}\r\n\r\n\r\n\tfunction calculateFeeRate(address sender, address recipient) private view returns(uint256) {\r\n\t\tbool applyFees = _isFeeEnabled \u0026\u0026 !_addressesExcludedFromFees[sender] \u0026\u0026 !_addressesExcludedFromFees[recipient];\r\n\t\tif (applyFees) {\r\n\t\t\tif (isPancakeswapPair(recipient)) {\r\n\t\t\t\t// Additional fee when selling\r\n\t\t\t\tif (_blacklistedAddresses[sender]) {\r\n\t\t\t\t    return _poolFee + 36;\r\n\t\t\t\t} else {\r\n\t\t\t\t    return _poolFee + _additionalSellFee;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn _poolFee;\r\n\t\t}\r\n\r\n\t\treturn 0;\r\n\t}\r\n\r\n\r\n\t// This function swaps a {tokenAmount} of TRINITY tokens for BNB and returns the total amount of BNB received\r\n\tfunction swapTokensForBNB(uint256 tokenAmount) internal returns(uint256) {\r\n\t\tuint256 initialBalance = address(this).balance;\r\n\t\t\r\n\t\t// Generate pair for TRIN -\u003e WBNB\r\n\t\taddress[] memory path = new address[](2);\r\n\t\tpath[0] = address(this);\r\n\t\tpath[1] = _pancakeswapV2Router.WETH();\r\n\r\n\t\t// Swap\r\n\t\t_pancakeswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(tokenAmount, 0, path, address(this), block.timestamp + 360);\r\n\t\t\r\n\t\t// Return the amount received\r\n\t\treturn address(this).balance - initialBalance;\r\n\t}\r\n\r\n\r\n\tfunction swapBNBForTokens(address to, address token, uint256 bnbAmount) internal returns(bool) { \r\n\t\t// Generate pair for WBNB -\u003e Future\r\n\t\taddress[] memory path = new address[](2);\r\n\t\tpath[0] = _pancakeswapV2Router.WETH();\r\n\t\tpath[1] = token;\r\n        \r\n\t\t// Swap and send the tokens to the \u0027to\u0027 address\r\n\t\ttry _pancakeswapV2Router.swapExactETHForTokensSupportingFeeOnTransferTokens{ value: bnbAmount }(0, path, to, block.timestamp + 360) { \r\n\t\t\treturn true;\r\n\t\t} \r\n\t\tcatch { \r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\t\r\n\t// Returns true if the transfer between the two given addresses should be limited by the transaction limit and false otherwise\r\n\tfunction isTransferLimited(address sender, address recipient) private view returns(bool) {\r\n\t\tbool isSelling = isPancakeswapPair(recipient);\r\n\t\treturn isSelling \u0026\u0026 isMarketTransfer(sender, recipient);\r\n\t}\r\n\r\n\r\n\tfunction isSwapTransfer(address sender, address recipient) private view returns(bool) {\r\n\t\tbool isContractSelling = sender == address(this) \u0026\u0026 isPancakeswapPair(recipient);\r\n\t\treturn isContractSelling;\r\n\t}\r\n\r\n\r\n\t// Function that is used to determine whether a transfer occurred due to a user buying/selling/transfering and not due to the contract swapping tokens\r\n\tfunction isMarketTransfer(address sender, address recipient) internal virtual view returns(bool) {\r\n\t\treturn !isSwapTransfer(sender, recipient);\r\n\t}\r\n\r\n\r\n\t// Returns how many more $`TRIN tokens are needed in the contract before triggering a swap\r\n\tfunction amountUntilSwap() public view returns (uint256) {\r\n\t\tuint256 balance = balanceOf(address(this));\r\n\t\tif (balance \u003e _tokenSwapThreshold) {\r\n\t\t\t// Swap on next relevant transaction\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\treturn _tokenSwapThreshold - balance;\r\n\t}\r\n\r\n\r\n\tfunction increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n\t\tdoApprove(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n\t\treturn true;\r\n\t}\r\n\r\n\r\n\tfunction decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n\t\tdoApprove(_msgSender(), spender, _allowances[_msgSender()][spender] - subtractedValue);\r\n\t\treturn true;\r\n\t}\r\n\r\n\r\n\tfunction setPancakeswapRouter(address routerAddress) public onlyOwner {\r\n\t\trequire(routerAddress != address(0), \"Cannot use the zero address as router address\");\r\n\t\t\r\n\t\t_pancakeswapV2Router = IPancakeRouter02(routerAddress);\r\n\t\t_pancakeswapV2Pair = IPancakeFactory(_pancakeswapV2Router.factory()).createPair(address(this), _pancakeswapV2Router.WETH());\r\n     \r\n\t\tonPancakeswapRouterUpdated();\r\n\t}\r\n\r\n\r\n\tfunction onPancakeswapRouterUpdated() internal virtual { }\r\n\r\n\r\n\tfunction isPancakeswapPair(address addr) internal view returns(bool) {\r\n\t\treturn _pancakeswapV2Pair == addr;\r\n\t}\r\n\r\n\r\n\t// This function can also be used in case the fees of the contract need to be adjusted later on as the volume grows\r\n\tfunction setFees(uint8 liquidityFee, uint8 rewardFee, uint8 marketingFee, uint8 additionalSellFee) public onlyOwner {\r\n\t\trequire(liquidityFee \u003e= 0 \u0026\u0026 liquidityFee \u003c= 15, \"Liquidity fee must be between 0% and 15%\");\r\n\t\trequire(rewardFee \u003e= 0 \u0026\u0026 rewardFee \u003c= 15, \"Reward fee must be between 0% and 15%\");\r\n\t\trequire(rewardFee \u003e= 0 \u0026\u0026 marketingFee \u003c= 15, \"Reward fee must be between 0% and 15%\");\r\n\t\trequire(additionalSellFee \u003c= 5, \"Additional sell fee cannot exceed 5%\");\r\n\t\trequire(liquidityFee + rewardFee + additionalSellFee \u003c= 50, \"Total fees cannot exceed 50%\");\r\n\t\t\r\n\t\t_previousLiquidityFee = _liquidityFee;\r\n\t\t_previousRewardFee = _rewardFee;\r\n\t\t_previousMarketingFee = _marketingFee;\r\n\t\t_previousAdditionalSellFee = _additionalSellFee;\r\n\t\t_previousPoolFee = _poolFee;\r\n\t\t\r\n\t\t_liquidityFee = liquidityFee;\r\n\t\t_rewardFee = rewardFee;\r\n\t\t_marketingFee = marketingFee;\r\n\t\t_additionalSellFee = additionalSellFee;\r\n\t\t\r\n\t\t// Enforce invariant\r\n\t\t_poolFee = _rewardFee + _marketingFee + _liquidityFee;\r\n\t}\r\n\t\r\n\t//Bot attack mode\r\n\tfunction setBotFeeMode() public onlyOwner {\r\n        _previousLiquidityFee = _liquidityFee;\r\n\t\t_previousRewardFee = _rewardFee;\r\n\t\t_previousMarketingFee = _marketingFee;\r\n\t\t_previousAdditionalSellFee = _additionalSellFee;\r\n\t\t_previousPoolFee = _poolFee;\r\n\r\n\t\t_additionalSellFee = 36;\r\n    }\r\n    \r\n    function restoreAllFee() public onlyOwner {\r\n       \t_liquidityFee = _previousLiquidityFee;\r\n\t\t_rewardFee = _previousRewardFee;\r\n\t\t_marketingFee = _previousMarketingFee;\r\n\t\t_additionalSellFee = _previousAdditionalSellFee;\r\n\t\t_poolFee = _previousPoolFee;\r\n    }\r\n    \r\n\t// This function will be used to reduce the limit later on, according to the price of the token, 100 = 0.01%, 10 = 0.1%\r\n\tfunction setTransactionLimit(uint256 limit) public onlyOwner {\r\n\t\t_transactionLimit = limit;\r\n\t}\r\n\r\n\t\t\r\n\tfunction transactionLimit() public view returns (uint256) {\r\n\t\treturn _transactionLimit;\r\n\t}\r\n\r\n\r\n\tfunction setTokenSwapThreshold(uint256 threshold) public onlyOwner {\r\n\t\trequire(threshold \u003e 0, \"Threshold must be greater than 0\");\r\n\t\t_tokenSwapThreshold = threshold;\r\n\t}\r\n\r\n\r\n\tfunction tokenSwapThreshold() public view returns (uint256) {\r\n\t\treturn _tokenSwapThreshold;\r\n\t}\r\n\r\n\r\n\tfunction name() public override pure returns (string memory) {\r\n\t\treturn NAME;\r\n\t}\r\n\r\n\r\n\tfunction symbol() public override pure returns (string memory) {\r\n\t\treturn SYMBOL;\r\n\t}\r\n\r\n\r\n\tfunction totalSupply() public override pure returns (uint256) {\r\n\t\treturn _totalTokens;\r\n\t}\r\n\t\r\n\r\n\tfunction decimals() public override pure returns (uint8) {\r\n\t\treturn DECIMALS;\r\n\t}\r\n\t\r\n\r\n\tfunction allowance(address user, address spender) public view override returns (uint256) {\r\n\t\treturn _allowances[user][spender];\r\n\t}\r\n\r\n\tfunction pancakeswapPairAddress() public view returns (address) {\r\n\t\treturn _pancakeswapV2Pair;\r\n\t}\r\n\r\n\r\n\tfunction autoLiquidityWallet() public view returns (address) {\r\n\t\treturn _autoLiquidityWallet;\r\n\t}\r\n\r\n\r\n\tfunction setAutoLiquidityWallet(address liquidityWallet) public onlyOwner {\r\n\t\t_autoLiquidityWallet = liquidityWallet;\r\n\t}\r\n\r\n\r\n\tfunction totalFeesPooled() public view returns (uint256) {\r\n\t\treturn _totalFeesPooled;\r\n\t}\r\n\r\n\t\r\n\tfunction totalBNBLiquidityAddedFromFees() public view returns (uint256) {\r\n\t\treturn _totalBNBLiquidityAddedFromFees;\r\n\t}\r\n\r\n\r\n\tfunction isSwapEnabled() public view returns (bool) {\r\n\t\treturn _isSwapEnabled;\r\n\t}\r\n\r\n\r\n\tfunction setSwapEnabled(bool isEnabled) public onlyOwner {\r\n\t\t_isSwapEnabled = isEnabled;\r\n\t}\r\n\r\n\r\n\tfunction isFeeEnabled() public view returns (bool) {\r\n\t\treturn _isFeeEnabled;\r\n\t}\r\n\r\n\r\n\tfunction setFeeEnabled(bool isEnabled) public onlyOwner {\r\n\t\t_isFeeEnabled = isEnabled;\r\n\t}\r\n\r\n\r\n\tfunction isExcludedFromFees(address addr) public view returns(bool) {\r\n\t\treturn _addressesExcludedFromFees[addr];\r\n\t}\r\n\r\n\r\n\tfunction setExcludedFromFees(address addr, bool value) public onlyOwner {\r\n\t\t_addressesExcludedFromFees[addr] = value;\r\n\t}\r\n\r\n\r\n\tfunction activateBuying() internal onlyOwner {\r\n\t\t_isBuyingAllowed = true;\r\n\t}\r\n\t\r\n\tfunction getLiquidityFee() public view returns(uint256) {\r\n\t    return _liquidityFee;\r\n\t}\r\n\t\r\n\tfunction getRewardFee() public view returns(uint256) {\r\n\t    return _rewardFee;\r\n\t}\r\n\r\n    function getMarketingFee() public view returns(uint256) {\r\n\t    return _marketingFee;\r\n\t}\r\n\r\n    function getAdditionalSellFee() public view returns(uint256) {\r\n\t    return _additionalSellFee;\r\n\t}\r\n\t\r\n\tfunction getPoolFee() public view returns(uint256) {\r\n\t    return _poolFee;\r\n\t}\r\n\t\r\n\tfunction setBlacklistedWallet(address wallet) public onlyOwner {\r\n\t    _blacklistedAddresses[wallet] = true;\r\n\t}\r\n\t\r\n\tfunction removeBlacklistedWallet(address wallet) public onlyOwner {\r\n\t    _blacklistedAddresses[wallet] = false;\r\n\t}\r\n\t\r\n\tfunction isBlacklistedWallet(address wallet) public view onlyOwner returns(bool)  {\r\n\t    return _blacklistedAddresses[wallet];\r\n\t}\r\n\r\n\t// Ensures that the contract is able to receive BNB\r\n\treceive() external payable {}\r\n}"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity \u003e= 0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}"},"IPancakeRouterV2.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.5;\r\n\r\ninterface IPancakeRouter01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IPancakeRouter02 is IPancakeRouter01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface IPancakeFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity \u003e= 0.8.0;\r\n\r\nimport \"./Context.sol\";\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}"},"ReentrancyGuard.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity \u003e= 0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot\u0027s contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler\u0027s defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction\u0027s gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor () {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier isHuman() {\r\n        require(tx.origin == msg.sender, \"Humans only\");\r\n        _;\r\n    }\r\n}"},"TrinityToken.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\n/*\r\nTRINITY\r\nhttps://trinitydefi.com/\r\nCreated by Ganglyprism\r\n*/\r\n\r\npragma solidity \u003e= 0.8.5;\r\n\r\nimport \"./FinanceBase.sol\";\r\n\r\n// Implements rewards \u0026 burns\r\ncontract Trinity is FinanceBase {\r\n\t// REWARD CYCLE\r\n\tuint256 private _rewardCyclePeriod = 12 hours; // The duration of the reward cycle (e.g. can claim rewards once a day)\r\n\tuint256 private _rewardCycleExtensionThreshold; // If someone sends or receives more than a % of their balance in a transaction, their reward cycle date will increase accordingly\r\n\tmapping(address =\u003e uint256) private _nextAvailableClaimDate; // The next available reward claim date for each address\r\n\r\n\tuint256 private _totalBNBLiquidityAddedFromFees; // The total number of BNB added to the pool through fees\r\n\tuint256 private _totalBNBClaimed; // The total number of BNB claimed by all addresses\r\n\tmapping(address =\u003e uint256) private _totalTokenClaimed; // The amount of token T claimed by each address\r\n\tmapping(address =\u003e uint256) private _bnbRewardClaimed; // The amount of BNB claimed by each address\r\n\t\r\n\tmapping(address =\u003e uint8) private _claimDivision; //Allows users to optionally use a % of the reward pool to receive the second token option automatically\r\n\tmapping(address =\u003e mapping(address =\u003e uint256)) private _tokenRewardClaimed; // The amount of BNB claimed by each holder as tokens (holder -\u003e token address)\r\n\t\r\n\tmapping (address =\u003e address) private _firstRewardToken; //stores users first token option\r\n\tmapping (address =\u003e address) private _secondRewardToken; //stores users second token option\r\n\tmapping (string =\u003e address) private _tokensList; //hold the token addresses\r\n\tmapping (address =\u003e bool) private _tokensAllowance; //check if a token distribution is allowed or not\r\n\t\r\n\tmapping(address =\u003e bool) private _addressesExcludedFromRewards; // The list of addresses excluded from rewards\r\n\tmapping(address =\u003e mapping(address =\u003e bool)) private _rewardClaimApprovals; //Used to allow an address to claim rewards on behalf of someone else\r\n\t\r\n\tuint256 private _minRewardBalance; //The minimum balance required to be eligible for rewards\r\n\tuint256 private _maxClaimAllowed = 50 ether; // Can only claim up to 50 bnb at a time.\r\n\tuint256 private _globalRewardDampeningPercentage = 3; // Rewards are reduced by 3% at the start to fill the main BNB pool faster and ensure consistency in rewards\r\n\tuint256 private _mainBnbPoolSize = 100 ether; // Any excess BNB after the main pool will be used as reserves to ensure consistency in rewards\r\n\tuint256 private _gradualBurnMagnitude; // The contract can optionally burn tokens (By buying them from reward pool).  This is the magnitude of the burn (1 = 0.01%).\r\n\tuint256 private _gradualBurnTimespan = 1 days; //Burn every 1 day by default\r\n\tuint256 private _lastBurnDate; //The last burn date\r\n\tuint256 private _minBnbPoolSizeBeforeBurn = 20 ether; //The minimum amount of BNB that need to be in the pool before initiating gradual burns\r\n\r\n\t// AUTO-CLAIM\r\n\tbool private _autoClaimEnabled = true;\r\n\tuint256 private _maxGasForAutoClaim = 800000; // The maximum gas to consume for processing the auto-claim queue\r\n\taddress[] _rewardClaimQueue;\r\n\tmapping(address =\u003e uint) _rewardClaimQueueIndices;\r\n\tuint256 private _rewardClaimQueueIndex;\r\n\tmapping(address =\u003e bool) _addressesInRewardClaimQueue; // Mapping between addresses and false/true depending on whether they are queued up for auto-claim or not\r\n\tbool private _reimburseAfterTokenClaimFailure; // If true, and TRIN reward claim portion fails, the portion will be given as BNB instead\r\n\tbool private _processingQueue; //Flag that indicates whether the queue is currently being processed and sending out rewards\r\n\tmapping(address =\u003e bool) private _whitelistedExternalProcessors; //Contains a list of addresses that are whitelisted for low-gas queue processing \r\n\tuint256 private _sendWeiGasLimit;\r\n\tbool private _excludeNonHumansFromRewards = true;\r\n\r\n\tevent RewardClaimed(address recipient, uint256 amountFirst, uint256 amountSecond, uint256 amountBnb, uint256 nextAvailableClaimDate); \r\n\tevent Burned(uint256 bnbAmount);\r\n\r\n    //Router MAINNET: 0x10ED43C718714eb63d5aA57B78B54704E256024E TESTNET: 0xD99D1c33F9fC3444f8101754aBC46c52416550D1\r\n\tconstructor (address routerAddress) FinanceBase(routerAddress) {\r\n\r\n\t\t// Exclude addresses from rewards\r\n\t\t_addressesExcludedFromRewards[BURN_WALLET] = true;\r\n\t\t_addressesExcludedFromRewards[address(this)] = true;\r\n\t\t_addressesExcludedFromRewards[address(0)] = true;\r\n\t\t\r\n\t\t_tokensList[\"TRIN\"] = address(this);\r\n\t\t_tokensList[\"BNB\"] = _pancakeswapV2Router.WETH();\r\n\t\t\r\n\t\t_tokensList[\"MATIC\"] = 0xCC42724C6683B7E57334c4E856f4c9965ED682bD;  // mainnet 0xCC42724C6683B7E57334c4E856f4c9965ED682bD \r\n\t\t_tokensList[\"DOT\"] = 0x7083609fCE4d1d8Dc0C979AAb8c869Ea2C873402;   // mainnet 0x7083609fCE4d1d8Dc0C979AAb8c869Ea2C873402  \r\n\t\t_tokensList[\"AVAX\"] = 0x1CE0c2827e2eF14D5C4f29a091d735A204794041;  // mainnet 0x1CE0c2827e2eF14D5C4f29a091d735A204794041  \r\n\r\n\t\t// only the smart people can acces these \r\n\t\tenableToken(\"TRIN\");\r\n\t\tenableToken(\"BNB\");\r\n\r\n\t\t// main rewards\r\n\t\tenableToken(\"MATIC\");\r\n\t\tenableToken(\"DOT\");\r\n\t\tenableToken(\"AVAX\");\r\n\r\n        \r\n\t\t// If someone sends or receives more than 75% of their balance in a transaction, their reward cycle date will increase accordingly\r\n\t\tsetRewardCycleExtensionThreshold(75);\r\n\t}\r\n\r\n\r\n\t// This function is used to enable all functions of the contract, after the setup of the token sale (e.g. Liquidity) is completed\r\n\tfunction onActivated() internal override {\r\n\t\tsuper.onActivated();\r\n\t\tsetAutoClaimEnabled(true);\r\n\t\tsetReimburseAfterTokenClaimFailure(true);\r\n\t\tsetMinRewardBalance(3333 * 10**decimals());  //At least 3333 tokens are required to be eligible for rewards\r\n\t\tsetGradualBurnMagnitude(10); //Buy tokens using 0.01% of reward pool and burn them\r\n\t\t_lastBurnDate = block.timestamp;\r\n\t}\r\n\r\n\tfunction onBeforeTransfer(address sender, address recipient, uint256 amount) internal override {\r\n        super.onBeforeTransfer(sender, recipient, amount);\r\n\r\n\t\tif (!isMarketTransfer(sender, recipient)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n        // Extend the reward cycle according to the amount transferred.  This is done so that users do not abuse the cycle (buy before it ends \u0026 sell after they claim the reward)\r\n        uint256 recipientExtension = _nextAvailableClaimDate[recipient] + calculateRewardCycleExtension(balanceOf(recipient), amount);\r\n        uint256 senderExtension = _nextAvailableClaimDate[sender] + calculateRewardCycleExtension(balanceOf(sender), amount);\r\n        \r\n\t\t_nextAvailableClaimDate[recipient] = recipientExtension;\r\n\t\t_nextAvailableClaimDate[sender] = senderExtension;\r\n\t\t\r\n\t\tbool isSelling = isPancakeswapPair(recipient);\r\n\t\tif (!isSelling) {\r\n\t\t\t// Wait for a dip xd\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Process gradual burns\r\n\t\tbool burnTriggered = processGradualBurn();\r\n\r\n\t\t// Do not burn \u0026 process queue in the same transaction\r\n\t\tif (!burnTriggered \u0026\u0026 isAutoClaimEnabled()) {\r\n\t\t\t// Trigger auto-claim\r\n\t\t\ttry this.processRewardClaimQueue(_maxGasForAutoClaim) { } catch { }\r\n\t\t}\r\n    }\r\n\r\n\r\n\tfunction onTransfer(address sender, address recipient, uint256 amount) internal override {\r\n        super.onTransfer(sender, recipient, amount);\r\n\r\n\t\tif (!isMarketTransfer(sender, recipient)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Update auto-claim queue after balances have been updated\r\n\t\tupdateAutoClaimQueue(sender);\r\n\t\tupdateAutoClaimQueue(recipient);\r\n    }\r\n\t\r\n\t\r\n\tfunction processGradualBurn() private returns(bool) {\r\n\t\tif (!shouldBurn()) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tuint256 burnAmount = address(this).balance * _gradualBurnMagnitude / 10000;\r\n\t\tdoBuyAndBurn(burnAmount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\r\n\tfunction updateAutoClaimQueue(address user) private {\r\n\t\tbool isQueued = _addressesInRewardClaimQueue[user];\r\n\r\n\t\tif (!isIncludedInRewards(user)) {\r\n\t\t\tif (isQueued) {\r\n\t\t\t\t// Need to dequeue\r\n\t\t\t\tuint index = _rewardClaimQueueIndices[user];\r\n\t\t\t\taddress lastUser = _rewardClaimQueue[_rewardClaimQueue.length - 1];\r\n\r\n\t\t\t\t// Move the last one to this index, and pop it\r\n\t\t\t\t_rewardClaimQueueIndices[lastUser] = index;\r\n\t\t\t\t_rewardClaimQueue[index] = lastUser;\r\n\t\t\t\t_rewardClaimQueue.pop();\r\n\r\n\t\t\t\t// Clean-up\r\n\t\t\t\tdelete _rewardClaimQueueIndices[user];\r\n\t\t\t\tdelete _addressesInRewardClaimQueue[user];\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (!isQueued) {\r\n\t\t\t\t// Need to enqueue\r\n\t\t\t\t_rewardClaimQueue.push(user);\r\n\t\t\t\t_rewardClaimQueueIndices[user] = _rewardClaimQueue.length - 1;\r\n\t\t\t\t_addressesInRewardClaimQueue[user] = true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n    function claimReward() isHuman nonReentrant external {\r\n\t\tclaimReward(msg.sender);\r\n\t}\r\n        \r\n\tfunction claimReward(address user) private {\r\n\t\trequire(msg.sender == user || isClaimApproved(user, msg.sender), \"You are not allowed to claim rewards on behalf of this user\");\r\n\t\trequire(isRewardReady(user), \"Claim date for this address has not passed yet\");\r\n\t\trequire(isIncludedInRewards(user), \"Address is excluded from rewards, make sure there is enough TRIN balance\");\r\n        \r\n\t\tbool success = doClaimReward(user);\r\n\t\trequire(success, \"Reward claim failed\");\r\n\t}\r\n    \r\n\r\n\tfunction doClaimReward(address user) private returns (bool) {\r\n\t\t// Update the next claim date \u0026 the total amount claimed\r\n\t\t_nextAvailableClaimDate[user] = block.timestamp + rewardCyclePeriod();\r\n        \r\n\t\taddress firstTokenAddress = _firstRewardToken[user];\r\n\t\taddress secondTokenAddress = _secondRewardToken[user];\r\n\t\taddress bnbAddress = _pancakeswapV2Router.WETH();\r\n        uint8 divisionPercentage;\r\n\t\t\r\n        //user didn\u0027t set any token, give rewards in TRIN \r\n\t\tif (firstTokenAddress == address(0) \u0026\u0026 secondTokenAddress == address(0) || (!_tokensAllowance[firstTokenAddress] \u0026\u0026 !_tokensAllowance[secondTokenAddress])) { \r\n\t\t    firstTokenAddress = bnbAddress;\r\n\t\t    secondTokenAddress = address(this);\r\n\t\t    divisionPercentage = 50;\r\n\t\t} else {\r\n\t\t    divisionPercentage = _claimDivision[user];\r\n\t\t}\r\n\t\t\r\n\t\tuint256 reward = calculateBNBReward(user);\r\n        uint256 firstTokenRewards = (reward * divisionPercentage) / 100;\r\n\t\tuint256 secondTokenRewards = reward - firstTokenRewards;\r\n\t\tuint256 optionalBnbRewards = 0;\r\n\t\t\r\n\t\tbool firstTokenClaimSuccess = true;\r\n\t\tbool secondTokenClaimSuccess = true;\r\n\t\tbool optionalBnbClaim = true;\r\n\t\t\r\n        // Claim TRIN tokens\r\n        if (firstTokenAddress != address(0) \u0026\u0026 firstTokenRewards \u003e 0 || !_tokensAllowance[firstTokenAddress]) {\r\n            if (firstTokenAddress == bnbAddress) {\r\n                optionalBnbRewards += firstTokenRewards;\r\n            } else {\r\n                if (!claimTokens(user, firstTokenAddress, firstTokenRewards)) {\r\n        \t\t\t// If token claim fails for any reason, award whole portion as BNB\r\n        \t\t\tif (_reimburseAfterTokenClaimFailure) {\r\n        \t\t\t\toptionalBnbRewards += firstTokenRewards;\r\n        \t\t\t} else {\r\n        \t\t\t\tfirstTokenClaimSuccess = false;\r\n        \t\t\t}\r\n        \r\n        \t\t\tfirstTokenRewards = 0;\r\n    \t\t    }\r\n            }\r\n        } else {\r\n            optionalBnbRewards += firstTokenRewards;\r\n        }\r\n\t\t\r\n\t\tif (secondTokenAddress != address(0) \u0026\u0026 secondTokenRewards \u003e 0 || !_tokensAllowance[secondTokenAddress]) {\r\n    \t\tif (secondTokenAddress == bnbAddress) {\r\n    \t\t    optionalBnbRewards += secondTokenRewards;\r\n            } else {\r\n                if (!claimTokens(user, secondTokenAddress, secondTokenRewards)) {\r\n        \t\t\t// If token claim fails for any reason, award whole portion as BNB\r\n        \t\t\tif (_reimburseAfterTokenClaimFailure) {\r\n        \t\t\t\toptionalBnbRewards += secondTokenRewards;\r\n        \t\t\t} else {\r\n        \t\t\t\tsecondTokenClaimSuccess = false;\r\n        \t\t\t}\r\n        \r\n        \t\t\tsecondTokenRewards = 0;\r\n    \t\t    }\r\n            }\r\n\t\t} else {\r\n\t\t    optionalBnbRewards += secondTokenRewards;\r\n\t\t}\r\n\t\t\r\n\t\tif (optionalBnbRewards \u003e 0) {\r\n\t\t    optionalBnbClaim = claimBNB(user, optionalBnbRewards);\r\n\t\t}\r\n\t\t\r\n\t\t// Fire the event in case something was claimed\r\n\t\tif (firstTokenClaimSuccess || secondTokenClaimSuccess || optionalBnbClaim) {\r\n            uint256 nextDate = _nextAvailableClaimDate[user];\t\t    \r\n\t\t\temit RewardClaimed(user, firstTokenRewards, secondTokenRewards, optionalBnbRewards, nextDate);\r\n\t\t}\r\n\t\t\r\n\t\treturn firstTokenClaimSuccess \u0026\u0026 secondTokenClaimSuccess \u0026\u0026 optionalBnbClaim;\r\n\t}\r\n\r\n\r\n\tfunction claimBNB(address user, uint256 bnbAmount) private returns (bool) {\r\n\t\tif (bnbAmount == 0) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\r\n\t\t// Send the reward to the caller\r\n\t\tif (_sendWeiGasLimit \u003e 0) {\r\n\t\t\t(bool sent,) = user.call{value : bnbAmount, gas: _sendWeiGasLimit}(\"\");\r\n\t\t\tif (!sent) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t(bool sent,) = user.call{value : bnbAmount}(\"\");\r\n\t\t\tif (!sent) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n        \r\n\t    uint256 bnbRewardClaimedByUser = _bnbRewardClaimed[user];\r\n\t    uint256 totalBnbClaimedByAll = _totalBNBClaimed;\r\n\t    \r\n\t    bnbRewardClaimedByUser += bnbAmount;\r\n\t    totalBnbClaimedByAll += bnbAmount;\r\n\t    \r\n\t    _bnbRewardClaimed[user] = bnbRewardClaimedByUser;\r\n\t\t_totalBNBClaimed = totalBnbClaimedByAll;\r\n\t\treturn true;\r\n\t}\r\n\r\n\r\n\tfunction claimTokens(address user, address token, uint256 bnbAmount) private returns (bool) {\r\n\t\tif (bnbAmount == 0) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tbool success = swapBNBForTokens(user, token, bnbAmount);\r\n\t\tif (!success) {\r\n\t\t\treturn false;\r\n\t\t}\r\n        \r\n        uint256 bnbRewardClaimedAsTokenT = _tokenRewardClaimed[user][token];\r\n        uint256 bnbRewardClaimedByUser = _bnbRewardClaimed[user];\r\n    \tuint256 totalBnbClaimedByAll = _totalBNBClaimed;\r\n        uint256 totalTokenClaimedByAll = _totalTokenClaimed[token];\r\n\t    \r\n\t    bnbRewardClaimedAsTokenT += bnbAmount;\r\n\t    bnbRewardClaimedByUser += bnbAmount;\r\n\t    totalBnbClaimedByAll += bnbAmount;\r\n\t    totalTokenClaimedByAll += bnbAmount;\r\n\t    \r\n\t\t_tokenRewardClaimed[user][token] = bnbRewardClaimedAsTokenT;\r\n\t    _bnbRewardClaimed[user] = bnbRewardClaimedByUser;\r\n\t\t_totalBNBClaimed = totalBnbClaimedByAll;\r\n\t\t_totalTokenClaimed[token] = totalBnbClaimedByAll;\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n\r\n\r\n\t// Processes users in the claim queue and sends out rewards when applicable. The amount of users processed depends on the gas provided, up to 1 cycle through the whole queue. \r\n\t// Note: Any external processor can process the claim queue (e.g. even if auto claim is disabled from the contract, an external contract/user/service can process the queue for it \r\n\t// and pay the gas cost). \"gas\" parameter is the maximum amount of gas allowed to be consumed\r\n\tfunction processRewardClaimQueue(uint256 gas) public {\r\n\t\trequire(gas \u003e 0, \"Gas limit is required\");\r\n\r\n\t\tuint256 queueLength = _rewardClaimQueue.length;\r\n\t\tuint256 rewardQueueIndex = _rewardClaimQueueIndex;\r\n\t\t\r\n\t\tif (queueLength == 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tuint256 gasUsed = 0;\r\n\t\tuint256 gasLeft = gasleft();\r\n\t\tuint256 iteration = 0;\r\n\t\t_processingQueue = true;\r\n\r\n\t\t// Keep claiming rewards from the list until we either consume all available gas or we finish one cycle\r\n\t\twhile (gasUsed \u003c gas \u0026\u0026 iteration \u003c queueLength) {\r\n\t\t\tif (rewardQueueIndex \u003e= queueLength) {\r\n\t\t\t\trewardQueueIndex = 0;\r\n\t\t\t}\r\n\r\n\t\t\taddress user = _rewardClaimQueue[rewardQueueIndex];\r\n\t\t\tif (isRewardReady(user) \u0026\u0026 isIncludedInRewards(user)) {\r\n\t\t\t\tdoClaimReward(user);\r\n\t\t\t}\r\n\r\n\t\t\tuint256 newGasLeft = gasleft();\r\n\t\t\t\r\n\t\t\tif (gasLeft \u003e newGasLeft) {\r\n\t\t\t\tuint256 consumedGas = gasLeft - newGasLeft;\r\n\t\t\t\tgasUsed += consumedGas;\r\n\t\t\t\tgasLeft = newGasLeft;\r\n\t\t\t}\r\n\r\n\t\t\titeration++;\r\n\t\t\trewardQueueIndex++;\r\n\t\t}\r\n        \r\n        _rewardClaimQueueIndex = rewardQueueIndex;\r\n\t\t_processingQueue = false;\r\n\t}\r\n\r\n\t// Allows a whitelisted external contract/user/service to process the queue and have a portion of the gas costs refunded.\r\n\t// This can be used to help with transaction fees and payout response time when/if the queue grows too big for the contract.\r\n\t// \"gas\" parameter is the maximum amount of gas allowed to be used.\r\n\tfunction processRewardClaimQueueAndRefundGas(uint256 gas) external {\r\n\t\trequire(_whitelistedExternalProcessors[msg.sender], \"Not whitelisted - use processRewardClaimQueue instead\");\r\n\r\n\t\tuint256 startGas = gasleft();\r\n\t\tprocessRewardClaimQueue(gas);\r\n\t\tuint256 gasUsed = startGas - gasleft();\r\n\r\n\t\tpayable(msg.sender).transfer(gasUsed);\r\n\t}\r\n\r\n\r\n\tfunction isRewardReady(address user) public view returns(bool) {\r\n\t\treturn _nextAvailableClaimDate[user] \u003c= block.timestamp;\r\n\t}\r\n\r\n\r\n\tfunction isIncludedInRewards(address user) public view returns(bool) {\r\n\t\treturn balanceOf(user) \u003e= _minRewardBalance \u0026\u0026 !_addressesExcludedFromRewards[user];\r\n\t}\r\n\r\n\r\n\t// This function calculates how much (and if) the reward cycle of an address should increase based on its current balance and the amount transferred in a transaction\r\n\tfunction calculateRewardCycleExtension(uint256 balance, uint256 amount) public view returns (uint256) {\r\n\t\tuint256 basePeriod = rewardCyclePeriod();\r\n\r\n\t\tif (balance == 0) {\r\n\t\t\t// Receiving $TRIN on a zero balance address:\r\n\t\t\t// This means that either the address has never received tokens before (So its current reward date is 0) in which case we need to set its initial value\r\n\t\t\t// Or the address has transferred all of its tokens in the past and has now received some again, in which case we will set the reward date to a date very far in the future\r\n\t\t\treturn block.timestamp + basePeriod;\r\n\t\t}\r\n\r\n\t\tuint256 rate = amount * 100 / balance;\r\n\r\n\t\t// Depending on the % of $TRIN tokens transferred, relative to the balance, we might need to extend the period\r\n\t\tif (rate \u003e= _rewardCycleExtensionThreshold) {\r\n\r\n\t\t\t// If new balance is X percent higher, then we will extend the reward date by X percent\r\n\t\t\tuint256 extension = basePeriod * rate / 100;\r\n\r\n\t\t\t// Cap to the base period\r\n\t\t\tif (extension \u003e= basePeriod) {\r\n\t\t\t\textension = basePeriod;\r\n\t\t\t}\r\n\r\n\t\t\treturn extension;\r\n\t\t}\r\n\r\n\t\treturn 0;\r\n\t}\r\n\r\n\r\n\tfunction calculateBNBReward(address ofAddress) public view returns (uint256) {\r\n\t\tuint256 holdersAmount = totalAmountOfTokensHeld();\r\n\r\n\t\tuint256 balance = balanceOf(ofAddress);\r\n\t\tuint256 bnbPool =  address(this).balance * (100 - _globalRewardDampeningPercentage) / 100;\r\n\t\tuint256 bnbPoolSize = _mainBnbPoolSize;\r\n\t\tuint256 maxClaim = _maxClaimAllowed;\r\n\r\n\t\t// Limit to main pool size.  The rest of the pool is used as a reserve to improve consistency\r\n\t\tif (bnbPool \u003e bnbPoolSize) {\r\n\t\t\tbnbPool = bnbPoolSize;\r\n\t\t}\r\n\r\n\t\t// If an address is holding X percent of the supply, then it can claim up to X percent of the reward pool\r\n\t\tuint256 reward = bnbPool * balance / holdersAmount;\r\n\r\n\t\tif (reward \u003e maxClaim) {\r\n\t\t\treward = maxClaim;\r\n\t\t}\r\n\r\n\t\treturn reward;\r\n\t}\r\n\r\n\tfunction onPancakeswapRouterUpdated() internal override { \r\n\t\t_addressesExcludedFromRewards[address(_pancakeswapV2Router)] = true;\r\n\t\t_addressesExcludedFromRewards[pancakeswapPairAddress()] = true;\r\n\t}\r\n\t\r\n\t// sets all data\r\n\tfunction setBothTokensAndDivision(string memory firstToken,string memory secondToken,uint8 claimDivision) isHuman nonReentrant external {\r\n\t\tsetClaimDivision(claimDivision);\r\n\t\tsetFirstToken(msg.sender,firstToken);\r\n\t\tsetSecondToken(msg.sender,secondToken);\r\n\t}\r\n\t\t\r\n\tfunction setFirstToken(address user, string memory token) private {\r\n\t    require(msg.sender == user, \"You are not allowed first token on this user behalf\");\r\n\t    address selectedToken = _tokensList[token];\r\n    \trequire(selectedToken != address(0) \u0026\u0026 selectedToken != BURN_WALLET, \"The selected token does not exist.\");\r\n    \trequire(_tokensAllowance[selectedToken], \"The selected token is not allowed\");\r\n    \t\r\n    \t_firstRewardToken[user] = selectedToken;\r\n\t}\r\n\t\r\n\t\r\n\tfunction setSecondToken(address user, string memory token) private {\r\n\t    require(msg.sender == user, \"You are not allowed to set second token on this user behalf\");\r\n\t    address selectedToken = _tokensList[token];\r\n    \trequire(selectedToken != address(0) \u0026\u0026 selectedToken != BURN_WALLET, \"The selected token does not exist.\");\r\n    \trequire(_tokensAllowance[selectedToken], \"The selected token is not allowed\");\r\n    \t\r\n    \t_secondRewardToken[msg.sender] = selectedToken;\r\n\t}\r\n\t\r\n\tfunction getFirstToken(address user) public view returns (address) {\r\n\t    return _firstRewardToken[user];\r\n\t}\r\n\t\r\n\tfunction getSecondToken(address user) public view returns (address) {\r\n\t    return _secondRewardToken[user];\r\n\t}\r\n\t\r\n\tfunction addNewToken(string memory symbol, address tokenAddress) public onlyOwner {\r\n\t    require(tokenAddress != address(0) \u0026\u0026 tokenAddress != BURN_WALLET, \"Token address is invalid.\");\r\n\t    require(_tokensList[symbol] != tokenAddress, \"This token is already added.\");\r\n\t    \r\n\t    _tokensList[symbol] = tokenAddress;\r\n\t    _tokensAllowance[tokenAddress] = true;\r\n\t}\r\n\t\r\n\tfunction enableToken(string memory symbol) public onlyOwner {\r\n\t   address tokenAddress = _tokensList[symbol];\r\n\t   require(tokenAddress != address(0) \u0026\u0026 tokenAddress != BURN_WALLET, \"Token symbol is not added.\");\r\n\t    \r\n\t   _tokensAllowance[tokenAddress] = true;\r\n\t}\r\n\t\r\n\tfunction disableToken(string memory symbol) public onlyOwner {\r\n\t    address tokenAddress = _tokensList[symbol];\r\n\t    require(tokenAddress != address(0) \u0026\u0026 tokenAddress != BURN_WALLET, \"Token symbol is not added.\");\r\n\t    \r\n\t    _tokensAllowance[tokenAddress] = false;\r\n\t}\r\n\t\r\n\tfunction removeToken(string memory symbol) public onlyOwner {\r\n\t    address tokenAddress = _tokensList[symbol];\r\n\t    require(tokenAddress != address(0) \u0026\u0026 tokenAddress != BURN_WALLET, \"Token symbol is not added.\");\r\n\t    \r\n\t    _tokensList[symbol] = address(0);\r\n\t    _tokensAllowance[tokenAddress] = false;\r\n\t}\r\n\t\r\n\tfunction getTokenAddress(string memory symbol) public view returns (address) {\r\n\t    return _tokensList[symbol];\r\n\t}\r\n\t\r\n\tfunction isTokenAllowed(string memory symbol) public view returns (bool) {\r\n\t    return _tokensAllowance[_tokensList[symbol]];\r\n\t}\r\n\r\n\tfunction isMarketTransfer(address sender, address recipient) internal override view returns(bool) {\r\n\t\t// Not a market transfer when we are burning or sending out rewards\r\n\t\treturn super.isMarketTransfer(sender, recipient) \u0026\u0026 !isBurnTransfer(sender, recipient) \u0026\u0026 !_processingQueue;\r\n\t}\r\n\r\n\r\n\tfunction isBurnTransfer(address sender, address recipient) private view returns (bool) {\r\n\t\treturn isPancakeswapPair(sender) \u0026\u0026 recipient == BURN_WALLET;\r\n\t}\r\n\r\n\r\n\tfunction shouldBurn() public view returns(bool) {\r\n\t\treturn _gradualBurnMagnitude \u003e 0 \u0026\u0026 address(this).balance \u003e= _minBnbPoolSizeBeforeBurn \u0026\u0026 block.timestamp - _lastBurnDate \u003e _gradualBurnTimespan;\r\n\t}\r\n\r\n\r\n\t// Up to 1% manual buyback \u0026 burn\r\n\tfunction buyAndBurn(uint256 bnbAmount) external onlyOwner {\r\n\t\trequire(bnbAmount \u003c= address(this).balance / 100, \"Manual burn amount is too high!\");\r\n\t\trequire(bnbAmount \u003e 0, \"Amount must be greater than zero\");\r\n\r\n\t\tdoBuyAndBurn(bnbAmount);\r\n\t}\r\n\r\n\r\n\tfunction doBuyAndBurn(uint256 bnbAmount) private {\r\n\t\tif (bnbAmount \u003e address(this).balance) {\r\n\t\t\tbnbAmount = address(this).balance;\r\n\t\t}\r\n\r\n\t\tif (bnbAmount == 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (swapBNBForTokens(BURN_WALLET, address(this), bnbAmount)) {\r\n\t\t\temit Burned(bnbAmount);\r\n\t\t}\r\n\r\n\t\t_lastBurnDate = block.timestamp;\r\n\t}\r\n\r\n\r\n\tfunction isContract(address account) public view returns (bool) {\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size \u003e 0;\r\n\t}\r\n\r\n\r\n\tfunction totalAmountOfTokensHeld() public view returns (uint256) {\r\n\t\treturn totalSupply() - balanceOf(address(0)) - balanceOf(BURN_WALLET) - balanceOf(pancakeswapPairAddress());\r\n\t}\r\n\r\n\r\n    function bnbRewardClaimed(address byAddress) public view returns (uint256) {\r\n\t\treturn _bnbRewardClaimed[byAddress];\r\n\t}\r\n\r\n    function totalBNBClaimed() public view returns (uint256) {\r\n\t\treturn _totalBNBClaimed;\r\n\t}\r\n\r\n\t// returns total claimed amount from tokenaddress\r\n    function totalBNBClaimedAsToken(address tokenAddress) public view returns (uint256) {\r\n\t\treturn _totalTokenClaimed[tokenAddress];\r\n\t}\r\n\r\n\t// returns total rewards from user from specific token\r\n\tfunction totalBNBClaimedAsTokenFromUser(address user,address tokenAddress) public view returns (uint256) {\r\n\t\treturn _tokenRewardClaimed[user][tokenAddress];\r\n\t}\r\n\r\n    function rewardCyclePeriod() public view returns (uint256) {\r\n\t\treturn _rewardCyclePeriod;\r\n\t}\r\n\r\n\r\n\tfunction setRewardCyclePeriod(uint256 period) public onlyOwner {\r\n\t\trequire(period \u003e= 0 \u0026\u0026 period \u003c= 7 days, \"Value out of range\");\r\n\t\t_rewardCyclePeriod = period;\r\n\t}\r\n\r\n\r\n\tfunction setRewardCycleExtensionThreshold(uint256 threshold) public onlyOwner {\r\n\t\t_rewardCycleExtensionThreshold = threshold;\r\n\t}\r\n\r\n\r\n\tfunction nextAvailableClaimDate(address ofAddress) public view returns (uint256) {\r\n\t\treturn _nextAvailableClaimDate[ofAddress];\r\n\t}\r\n\r\n\r\n\tfunction maxClaimAllowed() public view returns (uint256) {\r\n\t\treturn _maxClaimAllowed;\r\n\t}\r\n\r\n\r\n\tfunction setMaxClaimAllowed(uint256 value) public onlyOwner {\r\n\t\trequire(value \u003e 0, \"Value must be greater than zero\");\r\n\t\t_maxClaimAllowed = value;\r\n\t}\r\n\r\n\r\n\tfunction minRewardBalance() public view returns (uint256) {\r\n\t\treturn _minRewardBalance;\r\n\t}\r\n\r\n\r\n\tfunction setMinRewardBalance(uint256 balance) public onlyOwner {\r\n\t\t_minRewardBalance = balance;\r\n\t}\r\n\r\n\r\n\tfunction maxGasForAutoClaim() public view returns (uint256) {\r\n\t\treturn _maxGasForAutoClaim;\r\n\t}\r\n\r\n\r\n\tfunction setMaxGasForAutoClaim(uint256 gas) public onlyOwner {\r\n\t\t_maxGasForAutoClaim = gas;\r\n\t}\r\n\r\n\r\n\tfunction isAutoClaimEnabled() public view returns (bool) {\r\n\t\treturn _autoClaimEnabled;\r\n\t}\r\n\r\n\r\n\tfunction setAutoClaimEnabled(bool isEnabled) public onlyOwner {\r\n\t\t_autoClaimEnabled = isEnabled;\r\n\t}\r\n\r\n\r\n\tfunction isExcludedFromRewards(address addr) public view returns (bool) {\r\n\t\treturn _addressesExcludedFromRewards[addr];\r\n\t}\r\n\r\n\r\n\t\r\n\tfunction setExcludedFromRewards(address addr, bool isExcluded) public onlyOwner {\r\n\t\t_addressesExcludedFromRewards[addr] = isExcluded;\r\n\t\tupdateAutoClaimQueue(addr);\r\n\t}\r\n\r\n\r\n\tfunction globalRewardDampeningPercentage() public view returns(uint256) {\r\n\t\treturn _globalRewardDampeningPercentage;\r\n\t}\r\n\r\n\r\n\tfunction setGlobalRewardDampeningPercentage(uint256 value) public onlyOwner {\r\n\t\trequire(value \u003c= 90, \"Cannot be greater than 90%\");\r\n\t\t_globalRewardDampeningPercentage = value;\r\n\t}\r\n\r\n\r\n\tfunction approveClaim(address byAddress, bool isApproved) public {\r\n\t\trequire(byAddress != address(0), \"Invalid address\");\r\n\t\t_rewardClaimApprovals[msg.sender][byAddress] = isApproved;\r\n\t}\r\n\r\n\r\n\tfunction isClaimApproved(address ofAddress, address byAddress) public view returns(bool) {\r\n\t\treturn _rewardClaimApprovals[ofAddress][byAddress];\r\n\t}\r\n\r\n\r\n\tfunction gradualBurnMagnitude() public view returns (uint256) {\r\n\t\treturn _gradualBurnMagnitude;\r\n\t}\r\n\r\n \t//This is the magnitude of the burn (1 = 0.01%).\r\n\tfunction setGradualBurnMagnitude(uint256 magnitude) public onlyOwner {\r\n\t\trequire(magnitude \u003c= 1000, \"Must be equal or less to 1000, a max of 10%\");\r\n\t\t_gradualBurnMagnitude = magnitude;\r\n\t}\r\n\r\n\r\n\tfunction gradualBurnTimespan() public view returns (uint256) {\r\n\t\treturn _gradualBurnTimespan;\r\n\t}\r\n\r\n\r\n\tfunction setGradualBurnTimespan(uint256 timespan) public onlyOwner {\r\n\t\trequire(timespan \u003e= 5 minutes, \"Cannot be less than 5 minutes\");\r\n\t\t_gradualBurnTimespan = timespan;\r\n\t}\r\n\r\n\r\n\tfunction minBnbPoolSizeBeforeBurn() public view returns(uint256) {\r\n\t\treturn _minBnbPoolSizeBeforeBurn;\r\n\t}\r\n\r\n\r\n\tfunction setMinBnbPoolSizeBeforeBurn(uint256 amount) public onlyOwner {\r\n\t\trequire(amount \u003e 0, \"Amount must be greater than zero\");\r\n\t\t_minBnbPoolSizeBeforeBurn = amount;\r\n\t}\r\n\t\r\n\tfunction getClaimDivision(address ofAddress) public view returns(uint256) {\r\n\t\treturn _claimDivision[ofAddress];\r\n\t}\r\n\r\n\r\n\tfunction setClaimDivision(uint8 claimDivision) public {\r\n\t\trequire(claimDivision \u003e= 0 \u0026\u0026 claimDivision \u003c= 100, \"Your claim division needs to be between 0 and 100\");\r\n\t\t_claimDivision[msg.sender] = claimDivision;\r\n\t}\r\n\r\n\r\n\tfunction mainBnbPoolSize() public view returns (uint256) {\r\n\t\treturn _mainBnbPoolSize;\r\n\t}\r\n\r\n\r\n\tfunction setMainBnbPoolSize(uint256 size) public onlyOwner {\r\n\t\trequire(size \u003e= 10 ether, \"Size is too small\");\r\n\t\t_mainBnbPoolSize = size;\r\n\t}\r\n\r\n\r\n\tfunction isInRewardClaimQueue(address addr) public view returns(bool) {\r\n\t\treturn _addressesInRewardClaimQueue[addr];\r\n\t}\r\n\r\n\t\r\n\tfunction reimburseAfterTokenClaimFailure() public view returns(bool) {\r\n\t\treturn _reimburseAfterTokenClaimFailure;\r\n\t}\r\n\r\n\r\n\tfunction setReimburseAfterTokenClaimFailure(bool value) public onlyOwner {\r\n\t\t_reimburseAfterTokenClaimFailure = value;\r\n\t}\r\n\r\n\r\n\tfunction lastBurnDate() public view returns(uint256) {\r\n\t\treturn _lastBurnDate;\r\n\t}\r\n\r\n\r\n\tfunction rewardClaimQueueLength() public view returns(uint256) {\r\n\t\treturn _rewardClaimQueue.length;\r\n\t}\r\n\r\n\r\n\tfunction rewardClaimQueueIndex() public view returns(uint256) {\r\n\t\treturn _rewardClaimQueueIndex;\r\n\t}\r\n\r\n\r\n\tfunction isWhitelistedExternalProcessor(address addr) public view returns(bool) {\r\n\t\treturn _whitelistedExternalProcessors[addr];\r\n\t}\r\n\r\n\r\n\tfunction setWhitelistedExternalProcessor(address addr, bool isWhitelisted) public onlyOwner {\r\n\t\t require(addr != address(0), \"Invalid address\");\r\n\t\t_whitelistedExternalProcessors[addr] = isWhitelisted;\r\n\t}\r\n\r\n\tfunction setSendWeiGasLimit(uint256 amount) public onlyOwner {\r\n\t\t_sendWeiGasLimit = amount;\r\n\t}\r\n\r\n\tfunction setExcludeNonHumansFromRewards(bool exclude) public onlyOwner {\r\n\t\t_excludeNonHumansFromRewards = exclude;\r\n\t}\r\n}"}}