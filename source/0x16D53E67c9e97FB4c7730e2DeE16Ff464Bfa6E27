// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;


// CAUTION
// This version of SafeMath should only be used with Solidity 0.8 or later,
// because it relies on the compiler's built in overflow checks.
library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return a - b;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        return a * b;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }
}


// safe cast
library SafeCast {
    function toUint248(uint256 value) internal pure returns (uint248) {
        require(value <= type(uint248).max, "SafeCast: value doesn't fit in 248 bits");
        return uint248(value);
    }

    function toUint240(uint256 value) internal pure returns (uint240) {
        require(value <= type(uint240).max, "SafeCast: value doesn't fit in 240 bits");
        return uint240(value);
    }

    function toUint232(uint256 value) internal pure returns (uint232) {
        require(value <= type(uint232).max, "SafeCast: value doesn't fit in 232 bits");
        return uint232(value);
    }

    function toUint224(uint256 value) internal pure returns (uint224) {
        require(value <= type(uint224).max, "SafeCast: value doesn't fit in 224 bits");
        return uint224(value);
    }

    function toUint216(uint256 value) internal pure returns (uint216) {
        require(value <= type(uint216).max, "SafeCast: value doesn't fit in 216 bits");
        return uint216(value);
    }

    function toUint208(uint256 value) internal pure returns (uint208) {
        require(value <= type(uint208).max, "SafeCast: value doesn't fit in 208 bits");
        return uint208(value);
    }

    function toUint200(uint256 value) internal pure returns (uint200) {
        require(value <= type(uint200).max, "SafeCast: value doesn't fit in 200 bits");
        return uint200(value);
    }

    function toUint192(uint256 value) internal pure returns (uint192) {
        require(value <= type(uint192).max, "SafeCast: value doesn't fit in 192 bits");
        return uint192(value);
    }

    function toUint184(uint256 value) internal pure returns (uint184) {
        require(value <= type(uint184).max, "SafeCast: value doesn't fit in 184 bits");
        return uint184(value);
    }

    function toUint176(uint256 value) internal pure returns (uint176) {
        require(value <= type(uint176).max, "SafeCast: value doesn't fit in 176 bits");
        return uint176(value);
    }

    function toUint168(uint256 value) internal pure returns (uint168) {
        require(value <= type(uint168).max, "SafeCast: value doesn't fit in 168 bits");
        return uint168(value);
    }

    function toUint160(uint256 value) internal pure returns (uint160) {
        require(value <= type(uint160).max, "SafeCast: value doesn't fit in 160 bits");
        return uint160(value);
    }

    function toUint152(uint256 value) internal pure returns (uint152) {
        require(value <= type(uint152).max, "SafeCast: value doesn't fit in 152 bits");
        return uint152(value);
    }

    function toUint144(uint256 value) internal pure returns (uint144) {
        require(value <= type(uint144).max, "SafeCast: value doesn't fit in 144 bits");
        return uint144(value);
    }

    function toUint136(uint256 value) internal pure returns (uint136) {
        require(value <= type(uint136).max, "SafeCast: value doesn't fit in 136 bits");
        return uint136(value);
    }

    function toUint128(uint256 value) internal pure returns (uint128) {
        require(value <= type(uint128).max, "SafeCast: value doesn't fit in 128 bits");
        return uint128(value);
    }

    function toUint120(uint256 value) internal pure returns (uint120) {
        require(value <= type(uint120).max, "SafeCast: value doesn't fit in 120 bits");
        return uint120(value);
    }

    function toUint112(uint256 value) internal pure returns (uint112) {
        require(value <= type(uint112).max, "SafeCast: value doesn't fit in 112 bits");
        return uint112(value);
    }

    function toUint104(uint256 value) internal pure returns (uint104) {
        require(value <= type(uint104).max, "SafeCast: value doesn't fit in 104 bits");
        return uint104(value);
    }

    function toUint96(uint256 value) internal pure returns (uint96) {
        require(value <= type(uint96).max, "SafeCast: value doesn't fit in 96 bits");
        return uint96(value);
    }

    function toUint88(uint256 value) internal pure returns (uint88) {
        require(value <= type(uint88).max, "SafeCast: value doesn't fit in 88 bits");
        return uint88(value);
    }

    function toUint80(uint256 value) internal pure returns (uint80) {
        require(value <= type(uint80).max, "SafeCast: value doesn't fit in 80 bits");
        return uint80(value);
    }

    function toUint72(uint256 value) internal pure returns (uint72) {
        require(value <= type(uint72).max, "SafeCast: value doesn't fit in 72 bits");
        return uint72(value);
    }

    function toUint64(uint256 value) internal pure returns (uint64) {
        require(value <= type(uint64).max, "SafeCast: value doesn't fit in 64 bits");
        return uint64(value);
    }

    function toUint56(uint256 value) internal pure returns (uint56) {
        require(value <= type(uint56).max, "SafeCast: value doesn't fit in 56 bits");
        return uint56(value);
    }

    function toUint48(uint256 value) internal pure returns (uint48) {
        require(value <= type(uint48).max, "SafeCast: value doesn't fit in 48 bits");
        return uint48(value);
    }

    function toUint40(uint256 value) internal pure returns (uint40) {
        require(value <= type(uint40).max, "SafeCast: value doesn't fit in 40 bits");
        return uint40(value);
    }

    function toUint32(uint256 value) internal pure returns (uint32) {
        require(value <= type(uint32).max, "SafeCast: value doesn't fit in 32 bits");
        return uint32(value);
    }

    function toUint24(uint256 value) internal pure returns (uint24) {
        require(value <= type(uint24).max, "SafeCast: value doesn't fit in 24 bits");
        return uint24(value);
    }

    function toUint16(uint256 value) internal pure returns (uint16) {
        require(value <= type(uint16).max, "SafeCast: value doesn't fit in 16 bits");
        return uint16(value);
    }

    function toUint8(uint256 value) internal pure returns (uint8) {
        require(value <= type(uint8).max, "SafeCast: value doesn't fit in 8 bits");
        return uint8(value);
    }
}


// Interface of the ERC20 standard as defined in the EIP.
interface IERC20 {
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint8);
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);
    function allowance(address from, address to) external view returns (uint256);
    function approve(address to, uint256 amount) external returns (bool);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
}


// safe transfer
library TransferHelper {
    function safeApprove(address token, address to, uint value) internal {
        // bytes4(keccak256(bytes('approve(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');
    }

    function safeTransfer(address token, address to, uint value) internal {
        // bytes4(keccak256(bytes('transfer(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');
    }

    function safeTransferFrom(address token, address from, address to, uint value) internal {
        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');
    }

    function safeTransferETH(address to, uint value) internal {
        (bool success,) = to.call{value:value}(new bytes(0));
        // (bool success,) = to.call.value(value)(new bytes(0));
        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');
    }
}


// crystal interface
interface ICrystal {
    function crystalPriceUSDT() external view returns (uint256);
    function mintCrystal(address account, uint256 amount) external returns (bool);
    function burnCrystal(address account, uint256 amount) external returns (bool);
}


abstract contract ReentrancyGuard {
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;
    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    modifier nonReentrant() {
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
        _status = _ENTERED;
        _;
        _status = _NOT_ENTERED;
    }
}


// owner
abstract contract Ownable {
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, 'owner error');
        _;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }
}


// crystal market
contract CrystalMarket is Ownable, ReentrancyGuard {
    address public usdt;
    address public crystal;
    bool public isOpen = true;
    uint256 public minNumber = 50e18;

    uint256 private _orderCount;
    mapping(uint256 => orderMsg) public orderMsgOf;
    struct orderMsg {
        address seller;
        address buyer;
        uint128 amount;
        uint56 ID;
        uint32 time;    // hit the shelf time.
        uint32 time2;   // buy time or cancel time.
        uint8 status;   // 1=pending, 2=cancel, 3=sale. not other
    }


    constructor(address usdt_, address crystal_) {
        usdt = usdt_;
        crystal = crystal_;
    }

    event PendingOrder(uint256 ID, address seller, uint256 amount, uint256 time);
    event CancelOrder(uint256 ID, address seller, uint256 time2);
    event BuylOrder(uint256 ID, address seller, address buyer, uint256 time2);


    function setUsdt(address newUsdt) public onlyOwner {
        usdt = newUsdt;
    }

    function setCrystal(address newCrystal) public onlyOwner {
        crystal = newCrystal;
    }

    function setIsOpen(bool _isOpen) public onlyOwner {
        isOpen = _isOpen;
    }

    function setMinNumber(uint256 _minNumber) public onlyOwner {
        minNumber = _minNumber;
    }

    // order count
    function orderCount() public view returns (uint256) {
        return _orderCount;
    }

    // get all order
    function getAllOrders() public view returns(orderMsg[] memory allOrderMsg) {
        uint256 _count = _orderCount; // save gas.   
        allOrderMsg = new orderMsg[](_count);
        for(uint256 i = 1; i <= _count; i++) {
            allOrderMsg[i-1] = orderMsgOf[i];
        }
    }

    // page get order
    // include startID and start endID
    function getPageOrders(uint256 startID, uint256 endID) public view returns(orderMsg[] memory pageOrderMsg) {
        require(endID >= startID, "start gt end error");
        require(endID <= _orderCount, "end number too big");
        uint256 _count = endID - startID + 1;

        pageOrderMsg = new orderMsg[](_count);
        uint256 _index = 0;
        for(uint256 i = startID; i <= endID; i++) {
            pageOrderMsg[_index] = orderMsgOf[i];
            _index++;
        }
    }


    // add order
    function pendingOrder(uint256 amount) public nonReentrant {
        require(isOpen, "not open");
        address seller = msg.sender;
        require(!isContract(seller), "not user1");
        require(tx.origin == seller, 'not user2');
        require(amount >= minNumber, 'not amount');

        TransferHelper.safeTransferFrom(crystal, seller, address(this), amount);
        _orderCount++;
        orderMsgOf[_orderCount] = orderMsg({
            seller: seller,
            buyer: address(0),
            amount: SafeCast.toUint128(amount),
            ID: SafeCast.toUint56(_orderCount),
            time: SafeCast.toUint32(block.timestamp),
            time2: 0,
            status: 1
        });

        emit PendingOrder(_orderCount, seller, amount, block.timestamp);
    }

    // cancel order
    function cancelOrder(uint256 ID) public nonReentrant {
        address seller = msg.sender;
        orderMsg storage _orderMsg = orderMsgOf[ID];
        require(_orderMsg.seller == seller, 'not your');
        require(_orderMsg.status == 1, 'not pending');

        _orderMsg.status = 2;
        _orderMsg.time2 = SafeCast.toUint32(block.timestamp);
        TransferHelper.safeTransfer(crystal, seller, _orderMsg.amount);

        emit CancelOrder(ID, seller, block.timestamp);
    }

    // buy order
    function buyOrder(uint256 ID) public nonReentrant {
        address buyer = msg.sender;
        orderMsg storage _orderMsg = orderMsgOf[ID];
        require(_orderMsg.seller != buyer, 'not buy myself');
        require(_orderMsg.status == 1, 'not pending');

        _orderMsg.buyer = buyer;
        _orderMsg.time2 = SafeCast.toUint32(block.timestamp);
        _orderMsg.status = 3;
        TransferHelper.safeTransferFrom(usdt, buyer, _orderMsg.seller, _orderMsg.amount);
        TransferHelper.safeTransfer(crystal, buyer, _orderMsg.amount);

        emit BuylOrder(ID, _orderMsg.seller, buyer, block.timestamp);
    }

    function isContract(address account) internal view returns (bool) {
        return account.code.length > 0;
    }

    // take token
    function takeToken(address token, address to, uint256 value) external onlyOwner {
        require(to != address(0), "zero address error");
        require(value > 0, "value zero error");
        TransferHelper.safeTransfer(token, to, value);
    }

}