{"escrow.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.16;\n\n// IMPORTS\nimport \"./iBEP20.sol\";   // BEP20 Interface\nimport \"./pancake.sol\";  // Pancakeswap Router Interfaces\n\ncontract CanWorkEscrowV2 {\n    \n    struct Job {\n        uint JOBID;\n        address client;\n        address provider;\n        uint amount;\n        bool released;\n        address assetIn;\n    }\n                                       \n    address public owner;\n    address constant WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;     // Canonical WBNB address used by Pancake\n    address constant BUSD = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;     // Settlement BUSD contract address\n    address constant ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E;   // Pancake V2 ROUTER\n    address[] _swapPath;\n    IPancakeRouter01 constant PANCAKESWAP = IPancakeRouter01(ROUTER);       // Define PancakeSwap Router  \n\n    uint[] jobList;\n    uint jobCounter;\n    uint DEFAULT_FEE_PERCENT;                            \n\n    mapping(uint =\u003e bool) public jobExists;                               \n    mapping(uint =\u003e bool) public jobReleased;\n    mapping(uint =\u003e uint) public mapJobToAmount;\n    mapping(uint =\u003e address) public mapJobToClient;\n    mapping(uint =\u003e address) public mapJobToProvider;\n    mapping(uint =\u003e address) public mapJobToAssetIn;\n\n    event Deposit(address indexed client, address indexed provider, uint value, uint JOBID);\n    event Release(address indexed client, address indexed provider, uint value, uint JOBID);\n    event SetOwner(address owner, address newOwner);\n    event ChangeFee(uint oldFee, uint newFee);\n\n    constructor() {\n        owner = msg.sender;\n        DEFAULT_FEE_PERCENT = uint(10**18 / 100);  // 1%\n    }\n\n        // Only Owner can execute\n        modifier onlyAdmin() {\n            require(msg.sender == owner, \"!Auth\");\n            _;\n        }\n\n    // DEPOST BNB\n    // Client to Deposit BNB with a JOBID\n    function depositBNB(address provider, uint JOBID) external payable {\n        require(msg.value \u003e 0, \"!Val\");\n        require(!jobExists[JOBID], \"!ID\");\n\n        jobExists[JOBID] = true;\n     \n        mapJobToClient[JOBID] = msg.sender;\n        mapJobToProvider[JOBID] = provider;\n        mapJobToAssetIn[JOBID] = address(0);\n        \n        // Call internal swap function\n        uint _finalBUSD = _pancakeSwapBNB(msg.value);\n        mapJobToAmount[JOBID] = _finalBUSD;\n        \n        jobList.push(JOBID);\n        jobCounter++;\n           \n        emit Deposit (msg.sender, provider, _finalBUSD, JOBID);\n    } \n\n    // DEPOSIT BEP20\n    // Client to Deposit BEP20 asset with a JOBID and PancakeSwap path\n    function depositBEP20(address asset, address provider, uint value, uint JOBID, address[] calldata swapPath) external {\n        require(value \u003e 0, \"!Val\");\n        require(!jobExists[JOBID], \"!ID\");\n        require(iBEP20(asset).transferFrom(msg.sender, address(this), value), \"!Tx\");\n        \n        \n        _swapPath = swapPath;\n        uint i = _swapPath.length - 1;       \n        address _pathEnd = _swapPath[i];\n        require(_pathEnd == BUSD, \"Hx\");     // Mandates that the Pancake swap path outputs BUSD only!\n\n        jobExists[JOBID] = true;\n      \n        mapJobToClient[JOBID] = msg.sender;\n        mapJobToProvider[JOBID] = provider;\n        mapJobToAssetIn[JOBID] = asset;\n       \n        uint _finalBUSD; \n        if (asset == BUSD) {\n            _finalBUSD = value;                                         // Skips the swap if BEP20 token is already = BUSD\n        } else {\n            require(iBEP20(asset).approve(ROUTER, value), \"!Aprv\");       // Approve Pancake Router to spend the deposited token\n            _finalBUSD = _pancakeSwapTokens(value, swapPath);          // Call internal swap function\n        }   \n        mapJobToAmount[JOBID] = _finalBUSD;\n        \n        jobList.push(JOBID);\n        jobCounter++;\n\n        emit Deposit(msg.sender, provider, _finalBUSD, JOBID);\n    }\n\n    // RELEASE BY CLIENT\n    // Client Releases to transfer to Provider\n    function releaseAsClient(uint JOBID) external {\n        require(jobExists[JOBID], \"!ID\");\n        require(mapJobToClient[JOBID] == msg.sender, \"!Auth\");\n        require(!jobReleased[JOBID], \"Rel\");\n\n        jobReleased[JOBID] = true;\n      \n        // Release Recipient = Provider\n        address _recipient = mapJobToProvider[JOBID];\n        uint _amount = mapJobToAmount[JOBID];\n        bool takeFee = true;\n\n        uint _finalRelease = _release(_recipient, _amount, takeFee);\n\n        emit Release(msg.sender, _recipient, _finalRelease, JOBID);\n    }\n\n    // RELEASE BY PROVIDER\n    function releaseByProvider (uint JOBID) external {\n        require(jobExists[JOBID], \"!ID\");\n        require(mapJobToProvider[JOBID] == msg.sender, \"!Auth\");\n        require(!jobReleased[JOBID], \"Rel\");\n        \n        jobReleased[JOBID] = true;\n\n        // Release Recipient = Client\n        address _recipient = mapJobToClient[JOBID];\n        uint _amount = mapJobToAmount[JOBID];\n        bool takeFee = false;\n        uint _finalRelease = _release(_recipient, _amount, takeFee);\n\n        emit Release (msg.sender, _recipient, _finalRelease, JOBID);\n    }\n\n    // RELEASE BY ADMIN\n    // Admin to call function specifying *payout amount* to Client and Provider\n     function releaseByAdmin(uint JOBID, uint clientSplit, uint providerSplit) external onlyAdmin {\n        address _client = mapJobToClient[JOBID];\n        address _provider = mapJobToProvider [JOBID];\n        uint _amount = mapJobToAmount[JOBID];\n        \n        require(jobExists[JOBID], \"!ID\");\n        require(!jobReleased[JOBID], \"Rel\");\n        require((clientSplit + providerSplit \u003c _amount), \"!Add\");      \n        \n        jobReleased[JOBID] = true;\n\n        bool takeFee = true;\n        uint _clientFinalRelease = _release(_client, clientSplit, takeFee);\n        uint _providerFinalRelease = _release(_provider, providerSplit, takeFee );\n\n        emit Release(msg.sender, _client, _clientFinalRelease, JOBID);\n        emit Release(msg.sender, _provider, _providerFinalRelease, JOBID);\n    }\n    \n    // PANCAKESWAP CALLS \n    // BEP20 liquidated to BUSD via PancakeSwap function call `swapExactTokensForTokens`\n    function _pancakeSwapTokens (uint amountIn, address[] memory path) internal returns(uint _finalBUSD){\n        uint amountOutMin = 1;\n        uint deadline = block.timestamp + 900; // 15 mins\n                                  \n        uint[] memory _amounts = PANCAKESWAP.swapExactTokensForTokens(\n            amountIn, \n            amountOutMin, \n            path, \n            address(this), \n            deadline\n        );\n        uint x = _amounts.length - 1;  //gets final position of the returned _amounts[] data   \n        _finalBUSD = _amounts[x];\n    }\n\n    // BNB liquidation to BUSD via PancakeSwap function call `swapExactETHForTokens`            \n    function _pancakeSwapBNB (uint amountIn) internal returns (uint _finalBUSD) { \n        uint amountOutMin = 1;\n        uint deadline = block.timestamp + 900; // 15 mins\n        address[] memory path = new address[](2);\n        path[0] = WBNB;\n        path[1] = BUSD;\n        \n        uint[] memory _amount = PANCAKESWAP.swapExactETHForTokens{value: amountIn}(\n            amountOutMin, \n            path, \n            address(this), \n            deadline\n        ); \n        _finalBUSD = _amount[1];\n    }\n\n    // Internal function to handle Release\n    // Calculates recipient \u0026 fee amounts and Transfers funds\n    function _release(address _recipient, uint _amount, bool takeFee) internal returns (uint) {\n        require (_amount \u003e 0, \"E1\");\n        \n        uint _finalRelease;\n        if (takeFee) {\n            uint _feeAmount = DEFAULT_FEE_PERCENT * _amount / (10**18) ;\n            uint _amountMinusFee = _amount - _feeAmount;     \n            require (_amountMinusFee \u003e 0 , \"E2\"); \n            require (_amount \u003e _amountMinusFee, \"E3\");\n\n            _finalRelease = _amountMinusFee;\n        } else {\n            _finalRelease = _amount;\n        }\n\n        require (iBEP20(BUSD).transfer(_recipient, _finalRelease)); \n        return _finalRelease;\n    }\n\n    //======= ADMIN =======//\n\n    // Changes Contract Owner\n    function setOwner(address newOwner) external onlyAdmin {\n        require(newOwner != address(0));\n        owner = newOwner;\n        emit SetOwner(owner, newOwner);\n    }\n\n    // Change Default Fee\n    function changeDefaultFee(uint newFee) external onlyAdmin {\n        require (newFee != DEFAULT_FEE_PERCENT);\n        require (newFee \u003e uint(10**16) \u0026\u0026 newFee \u003c uint(10**18));\n        uint oldFee = DEFAULT_FEE_PERCENT;\n        DEFAULT_FEE_PERCENT = newFee;\n        emit ChangeFee(oldFee, newFee);\n    }\n   \n    // Returns Job Details\n    function getJobs () external view onlyAdmin returns (uint jobCount, Job [] memory allJobs){\n        uint _jobCount = jobList.length;\n        Job [] memory jobArray = new Job [](_jobCount);\n        \n        for (uint i = 0; i \u003c _jobCount; i++) {\n            uint _ID = jobList[i];\n            Job memory j;\n\n            j.JOBID = _ID;\n            j.amount = mapJobToAmount[_ID];\n            j.client = mapJobToClient[_ID];\n            j.provider = mapJobToProvider[_ID]; \n            j.assetIn = mapJobToAssetIn[_ID]; \n            j.released = jobReleased[_ID]; \n            jobArray[i] = j;\n        }\n        jobCount = _jobCount;\n        allJobs = jobArray;\n    }\n\n    // View Default Fee\n    function viewDefaultFee () external view returns (uint defaultFee) {\n        defaultFee = DEFAULT_FEE_PERCENT;\n    }\n}"},"iBEP20.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.16;\n\n//iBEP20 Interface\ninterface iBEP20 {\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address, uint256) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address, uint256) external returns (bool);\n    function transferFrom(address, address, uint256) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"},"pancake.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.16;\n\n// PancekeSwap Interface\ninterface IPancakeRouter01 {\n    // Swaps BEP20 tokens for another BEP20 token via PancakeSwap pairs\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    // Swaps BNB for a BEP20 token via PancakeSwap pairs\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n}"}}