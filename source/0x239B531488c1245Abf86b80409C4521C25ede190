// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

interface ICompound {
    event Deposit(address user, uint256 amount);
    event WithdrawLP(address user, uint256 amount);

    struct UserInfo {
        uint256 depositedLPAmount;
        bool exist;
    }

    function deposit(uint256 amount) external;

    function withdrawLP(uint256 amount) external;

    function viewUserInfo(address user) external view returns (UserInfo memory);

    function getLPTopUsers(uint256 number) external view returns (address[] memory);

    function tops(uint256 number, address user) external view returns (address[] memory, uint256[] memory, uint256);
}

// File: src/IVault.sol

pragma solidity ^0.8.0;

interface IVault {
    function addWhitelist(address addr) external;

    function removeWhitelist(address addr) external;

    function withdraw(address tokenAddress, address to, uint256 amount) external;

    function isWhitelist(address addr) external view returns (bool);
}

// File: src/IRegister.sol

pragma solidity ^0.8.0;

interface IRegister {
    event Regist(address player, address inviter);

    function addDefaultInviter(address addr) external returns (bool);

    function regist(address _inviter) external returns (bool);

    function registed(address _player) external view returns (bool);

    function myInviter(address _player) external view returns (address);
}

// File: @openzeppelin/contracts/utils/Context.sol

// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)

pragma solidity ^0.8.0;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

// File: @openzeppelin/contracts/access/Ownable.sol

// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)

pragma solidity ^0.8.0;

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _transferOwnership(_msgSender());
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if the sender is not the owner.
     */
    function _checkOwner() internal view virtual {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby disabling any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Internal function without access restriction.
     */
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

// File: @openzeppelin/contracts/token/ERC20/IERC20.sol

// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `from` to `to` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
}

// File: src/Fomo.sol

pragma solidity ^0.8.7;

contract Fomo is Ownable {
    IERC20 public token;
    IRegister public register;
    IVault public inviterVault;
    ICompound public compound;
    uint256 public currentActiveGameId;
    uint256 public constant MAX_TIME = 6 hours;
    uint256 public joinAddTime = 180;
    uint256 public constant MAX_WINNER_NUMBER = 30;
    uint256 public constant LP_TOPS_COUNT = 30;
    uint256 public constant JOIN_AMOUNT = 100 * 1e18;
    uint256 public constant INIT_LAUNCH_AMOUNT = 10_000 * 1e18;
    uint256 public constant BURN_RATE = 1;
    uint256 public constant DEVELOPER_RATE = 4;
    uint256 public constant LAUNCH_RATE = 5;
    uint256 public constant LP_TOPS_RATE = 10;
    uint256 public constant INVITE_RATE = 30;
    uint256 public constant BONUS_RATE = 50;

    uint256 public constant ARWARD_RELEASE_DURATION = 30 days;
    address public burnAddress = address(0x000000000000000000000000000000000000dEaD);
    mapping(uint256 => GameInfo) gameInfoMap;
    mapping(uint256 => mapping(address => uint256)) public userWeightMap;
    mapping(uint256 => mapping(address => bool)) isValidInviterMap;
    mapping(uint256 => mapping(address => bool)) isOldUserMap;
    mapping(uint256 => address[]) joinRecordMap;
    mapping(uint256 => address[]) winnersMap;
    mapping(uint256 => mapping(address => bool)) isWinnerMap;
    mapping(uint256 => mapping(address => UserRewardInfo)) userBonusRewardInfoMap;
    mapping(address => uint256) public developerSubRateMap;
    mapping(uint256 => mapping(address => uint256)) public developerRewardVithdrewMap;
    mapping(uint256 => mapping(address => uint256)) public lpTopsRewardMap;

    struct GameInfo {
        uint256 id;
        uint256 startTime;
        uint256 endTime;
        uint256 totalJoinAmount;
        uint256 joinTimes;
        bool finished;
        bool exist;
    }

    struct UserRewardInfo {
        uint256 total;
        uint256 withdrew;
        uint256 locked;
        uint256 withdrawable;
        uint256 lastWithdrawTime;
        bool exist;
    }

    struct GameInfoView {
        uint256 id;
        uint256 endTime;
        uint256 joinTimes;
        uint256 totalBonus;
        bool finished;
    }

    struct BonusRewardInfoView {
        uint256 id;
        uint256 gameTotalReward;
        uint256 totalReward;
        uint256 lockedReward;
        uint256 withdrewReward;
        uint256 withdrawableReward;
        uint256 lastWithdrawRewardTime;
    }

    struct DeveloperRewardInfoView {
        uint256 id;
        uint256 withdrawableReward;
    }

    struct LPTposRewardInfoView {
        uint256 id;
        uint256 withdrawableReward;
    }

    event NewGame(uint256 id);
    event GameFinish(uint256 id, address[] winners);
    event Join(uint256 id, address user, uint256 time);
    event TakeInvite(uint256 id, address user, uint256 amount);
    event WithdrawBonusReward(uint256 id, address user, uint256 amount);
    event WithdrawDevelperReward(uint256 id, address user, uint256 amount);
    event WithdrawLPTopsReward(uint256 id, address user, uint256 amount);

    constructor(IERC20 token_, IRegister register_, IVault inviterVault_, ICompound compound_) {
        token = token_;
        register = register_;
        inviterVault = inviterVault_;
        compound = compound_;

        developerSubRateMap[0xD25581b5441BA28204A6FcbF63EBED7199bD59f0] = 30;
        developerSubRateMap[0x924533cd3B9e5B285Fc25246BE132ed5D79E3232] = 30;
        developerSubRateMap[0xFB07f882F560E47F8212289b6cEB632D29394A79] = 40;

        newGame(INIT_LAUNCH_AMOUNT);
    }

    modifier registed(address user) {
        require(register.registed(user), "Corsair: NOT_REGIST");
        _;
    }

    modifier gameExist(uint256 id) {
        require(gameInfoMap[id].exist, "Fomo: Game not found");
        _;
    }

    modifier gameFinished(uint256 id) {
        require(gameInfoMap[id].finished, "Fomo: Not finish");
        _;
    }

    function newGame(uint256 lanchAmount) private {
        uint256 _id = ++currentActiveGameId;
        GameInfo memory gameInfo = GameInfo({
            id: _id,
            startTime: block.timestamp,
            endTime: block.timestamp + MAX_TIME,
            totalJoinAmount: lanchAmount,
            joinTimes: 0,
            finished: false,
            exist: true
        });
        gameInfoMap[_id] = gameInfo;
        emit NewGame(_id);
    }

    function join() public registed(msg.sender) {
        address user = msg.sender;
        uint256 id = currentActiveGameId;
        GameInfo memory gameInfo = gameInfoMap[id];
        uint256 nowTime = block.timestamp;
        require(nowTime < gameInfo.endTime, "Fomo: Finished");
        require(token.transferFrom(user, address(this), JOIN_AMOUNT), "Fomo: Transfer token from user failed");
        uint256 lpTposFee = JOIN_AMOUNT * LP_TOPS_RATE / 100;
        address[] memory lpUsers = compound.getLPTopUsers(LP_TOPS_COUNT);
        uint256 userNumber;
        for (uint256 i = 0; i < lpUsers.length; i++) {
            if (lpUsers[i] != address(0)) {
                userNumber++;
            }
        }
        if (userNumber > 0) {
            uint256 reward = lpTposFee / lpUsers.length;
            for (uint256 i = 0; i < lpUsers.length; i++) {
                address lpUser = lpUsers[i];
                if (lpUser != address(0)) {
                    lpTopsRewardMap[id][lpUser] += reward;
                } else {
                    break;
                }
            }
        }

        uint256 inviterFee = JOIN_AMOUNT * INVITE_RATE / 100;
        require(token.transfer(address(inviterVault), inviterFee), "Fomo: Transfer token to developer failed");
        emit TakeInvite(id, user, JOIN_AMOUNT);
        gameInfo.endTime = gameInfo.endTime + joinAddTime;
        if (gameInfo.endTime > nowTime + MAX_TIME) {
            gameInfo.endTime = nowTime + MAX_TIME;
        }

        gameInfo.totalJoinAmount += JOIN_AMOUNT;
        gameInfo.joinTimes++;
        gameInfoMap[id] = gameInfo;
        joinRecordMap[id].push(user);
        emit Join(id, user, nowTime);
    }

    function finish() public {
        uint256 id = currentActiveGameId;
        GameInfo memory gameInfo = gameInfoMap[id];
        require(!gameInfo.finished && block.timestamp >= gameInfo.endTime, "Fomo: Finished or not time");
        gameInfo.finished = true;
        uint256 totalJoinAmount = gameInfo.totalJoinAmount;
        uint256 totalBurnAmount;
        uint256 totalDeveloperReward;
        uint256 lanchAmount;
        uint256 totalLPTopsReward;
        uint256 totalInviteReward;
        uint256 totalBonusReward;

        if (gameInfo.joinTimes > 0) {
            totalBurnAmount = totalJoinAmount * BURN_RATE / 100;
            totalDeveloperReward = totalJoinAmount * DEVELOPER_RATE / 100;
            lanchAmount = totalJoinAmount * LAUNCH_RATE / 100;
            totalLPTopsReward = totalJoinAmount * LP_TOPS_RATE / 100;
            totalInviteReward = totalJoinAmount * INVITE_RATE / 100;
            totalBonusReward = totalJoinAmount * BONUS_RATE / 100;
        } else {
            lanchAmount = gameInfo.totalJoinAmount;
        }

        if (totalBurnAmount > 0) {
            require(token.transfer(burnAddress, totalBurnAmount), "Fomo: burn token failed");
        }
        uint256 recordLenght = joinRecordMap[id].length;
        if (recordLenght > 0) {
            uint256 winnerNumber = recordLenght > MAX_WINNER_NUMBER ? MAX_WINNER_NUMBER : recordLenght;
            for (uint256 i = 0; i < winnerNumber; i++) {
                address winner = joinRecordMap[id][recordLenght - 1 - i];
                if (!isWinnerMap[id][winner]) {
                    isWinnerMap[id][winner] = true;
                    winnersMap[id].push(winner);
                }
            }
        }
        gameInfoMap[id] = gameInfo;
        newGame(lanchAmount);
        emit GameFinish(id, winnersMap[id]);
    }

    function withdrawBonusReward(uint256 id) public gameExist(id) gameFinished(id) {
        address user = msg.sender;
        UserRewardInfo memory rewardInfo = getUserBonusRewardInfo(id, user);
        uint256 amount = rewardInfo.withdrawable;
        require(amount > 0, "Fomo: Zero withdrawable");
        rewardInfo.withdrew += amount;
        rewardInfo.withdrawable = 0;
        rewardInfo.lastWithdrawTime = block.timestamp;
        userBonusRewardInfoMap[id][user] = rewardInfo;
        require(token.transfer(user, amount), "Fomo: Transfer token to user failed");
        emit WithdrawBonusReward(id, user, amount);
    }

    function withdrawDeveloperReward(uint256 id) public gameExist(id) gameFinished(id) {
        address user = msg.sender;
        uint256 amount = getUserDeveloperRewardInfo(id, user);
        require(amount > 0, "Fomo: Zero withdrawable");
        developerRewardVithdrewMap[id][user] += amount;
        require(token.transfer(user, amount), "Fomo: Transfer token to user failed");
        emit WithdrawDevelperReward(id, user, amount);
    }

    function withdrawLPTopsReward(uint256 id) public gameExist(id) gameFinished(id) {
        address user = msg.sender;
        uint256 amount = lpTopsRewardMap[id][user];
        require(amount > 0, "Fomo: Zero withdrawable");
        lpTopsRewardMap[id][user] = 0;
        require(token.transfer(user, amount), "Fomo: Transfer token to user failed");
        emit WithdrawLPTopsReward(id, user, amount);
    }

    function viewGameInfo() public view returns (GameInfoView memory) {
        return viewGameInfo(currentActiveGameId);
    }

    function viewGameInfo(uint256 id) public view returns (GameInfoView memory) {
        GameInfo memory gameInfo = gameInfoMap[id];
        uint256 totalBonus;
        if (id == 1) {
            totalBonus = gameInfo.totalJoinAmount;
        } else {
            totalBonus = gameInfo.totalJoinAmount * BONUS_RATE / 100;
        }
        return GameInfoView({
            id: id,
            endTime: gameInfo.endTime,
            joinTimes: gameInfo.joinTimes,
            totalBonus: totalBonus,
            finished: block.timestamp >= gameInfo.endTime
        });
    }

    function viewBonudsRewardInfo(uint256 startId, uint256 count, address user)
        public
        view
        returns (BonusRewardInfoView[] memory)
    {
        BonusRewardInfoView[] memory rewardInfoList = new BonusRewardInfoView[](count);
        GameInfo memory gameInfo;
        UserRewardInfo memory bonusRewardInfo;
        uint256 id;
        for (uint256 i = 0; i < count; i++) {
            id = startId + i;
            gameInfo = gameInfoMap[id];
            bonusRewardInfo = getUserBonusRewardInfo(id, user);
            rewardInfoList[i] = BonusRewardInfoView({
                id: id,
                gameTotalReward: gameInfo.totalJoinAmount * BONUS_RATE / 100,
                totalReward: bonusRewardInfo.total,
                lockedReward: bonusRewardInfo.locked,
                withdrewReward: bonusRewardInfo.withdrew,
                withdrawableReward: bonusRewardInfo.withdrawable,
                lastWithdrawRewardTime: bonusRewardInfo.lastWithdrawTime
            });
        }
        return rewardInfoList;
    }

    function viewDeveloperRewardInfo(uint256 startId, uint256 count, address user)
        public
        view
        returns (DeveloperRewardInfoView[] memory)
    {
        DeveloperRewardInfoView[] memory rewardInfoList = new DeveloperRewardInfoView[](count);
        GameInfo memory gameInfo;
        uint256 id;
        uint256 reward;
        for (uint256 i = 0; i < count; i++) {
            id = startId + i;
            gameInfo = gameInfoMap[id];
            uint256 recordLenght = joinRecordMap[id].length;
            if (recordLenght > 0) reward = getUserDeveloperRewardInfo(id, user);
            else reward = 0;

            rewardInfoList[i] = DeveloperRewardInfoView({id: id, withdrawableReward: reward});
        }
        return rewardInfoList;
    }

    function viewLPTopsRewardInfo(uint256 startId, uint256 count, address user)
        public
        view
        returns (LPTposRewardInfoView[] memory)
    {
        LPTposRewardInfoView[] memory rewardInfoList = new LPTposRewardInfoView[](count);
        GameInfo memory gameInfo;
        uint256 id;
        uint256 reward;
        for (uint256 i = 0; i < count; i++) {
            id = startId + i;
            gameInfo = gameInfoMap[id];
            reward = lpTopsRewardMap[id][user];
            rewardInfoList[i] = LPTposRewardInfoView({id: id, withdrawableReward: reward});
        }
        return rewardInfoList;
    }

    function getUserBonusRewardInfo(uint256 id, address user) private view returns (UserRewardInfo memory) {
        UserRewardInfo memory userRewardInfo = userBonusRewardInfoMap[id][user];
        if (isWinnerMap[id][user]) {
            GameInfo memory gameInfo = gameInfoMap[id];
            if (!userRewardInfo.exist) {
                userRewardInfo.total = gameInfo.totalJoinAmount * BONUS_RATE / 100 / winnersMap[id].length;
                userRewardInfo.locked = userRewardInfo.total;
                userRewardInfo.lastWithdrawTime = gameInfo.endTime;
                userRewardInfo.exist = true;
            }
            uint256 releaseAmountPerSecond = userRewardInfo.total / ARWARD_RELEASE_DURATION;
            uint256 currentReleaseAmount = (block.timestamp - userRewardInfo.lastWithdrawTime) * releaseAmountPerSecond;
            if (currentReleaseAmount > userRewardInfo.locked) {
                currentReleaseAmount = userRewardInfo.locked;
            }
            uint256 lockedAmount = userRewardInfo.total - userRewardInfo.withdrew - currentReleaseAmount;
            userRewardInfo.locked = lockedAmount;
            userRewardInfo.withdrawable = currentReleaseAmount;
        }
        return userRewardInfo;
    }

    function getUserDeveloperRewardInfo(uint256 id, address user) private view returns (uint256) {
        uint256 subRate = developerSubRateMap[user];
        if (subRate == 0) {
            return 0;
        }
        GameInfo memory gameInfo = gameInfoMap[id];
        uint256 allDevelopersTotalReward = gameInfo.totalJoinAmount * DEVELOPER_RATE / 100;
        uint256 totalReward = allDevelopersTotalReward * subRate / 100;
        return totalReward - developerRewardVithdrewMap[id][user];
    }

    function changeJoinAddTime(uint256 time) public onlyOwner {
        joinAddTime = time;
    }
}