// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface ERC20 {
    function transfer(address to, uint256 value) external returns (bool);
}

interface ERC721 {
    function transferFrom(address from, address to, uint256 tokenId) external;
}

interface ERC1155 {
    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes memory data) external;
}

contract BatchTransfer {
    function batchTransferETH(address[] calldata recipients, uint256[] calldata amounts) external payable {
        require(recipients.length == amounts.length, "Lengths do not match");

        for (uint256 i = 0; i < recipients.length; i++) {
            address payable recipient = payable(recipients[i]);
            recipient.transfer(amounts[i]);
        }
    }

    function batchTransferERC20(address tokenAddress, address[] calldata recipients, uint256[] calldata amounts) external {
        require(recipients.length == amounts.length, "Lengths do not match");

        ERC20 token = ERC20(tokenAddress);

        for (uint256 i = 0; i < recipients.length; i++) {
            token.transfer(recipients[i], amounts[i]);
        }
    }

    function batchTransferERC721(address tokenAddress, address[] calldata recipients, uint256[] calldata tokenIds) external {
        require(recipients.length == tokenIds.length, "Lengths do not match");

        ERC721 token = ERC721(tokenAddress);

        for (uint256 i = 0; i < recipients.length; i++) {
            token.transferFrom(address(this), recipients[i], tokenIds[i]);
        }
    }

    function batchTransferERC1155(address tokenAddress, address[] calldata recipients, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external {
        require(recipients.length == ids.length && recipients.length == amounts.length, "Lengths do not match");

        ERC1155 token = ERC1155(tokenAddress);

        for (uint256 i = 0; i < recipients.length; i++) {
            token.safeTransferFrom(address(this), recipients[i], ids[i], amounts[i], data);
        }
    }
}