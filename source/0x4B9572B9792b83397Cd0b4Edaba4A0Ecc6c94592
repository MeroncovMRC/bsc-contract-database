
// File: contracts/loan.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.8;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
}

interface ILoan {
    function flashLoan(uint256 baseAmount, uint256 quoteAmount, address _assetTo, bytes calldata data) external;
}

contract LoanTest {
    address private _owner;
    address private _loanAddr = 0xFeAFe253802b77456B4627F8c2306a9CeBb5d681;
    address private _usdtAddr = 0x55d398326f99059fF775485246999027B3197955;

    event Loan(address sender, uint256 baseAmount, uint256 quoteAmount, uint256 usdtBalance, bytes data);
    event Run(uint256 dataLength, bytes data);

    constructor() {
        _owner = msg.sender;
    }


    modifier onlyOwner() {
        require(_owner == msg.sender, "Ownable: caller is not the owner");
        _;
    }

    function run() public {
        uint256 quoteAmount = IERC20(_usdtAddr).balanceOf(address(_loanAddr));
        bytes memory data = new bytes(10);
        emit Run(data.length, data);
        ILoan(_loanAddr).flashLoan(0, quoteAmount, address(this), data);
    }

    function DPPFlashLoanCall(
        address sender,
        uint256 baseAmount,
        uint256 quoteAmount,
        bytes calldata data
    ) public {
        uint256 usdtBalance = IERC20(_usdtAddr).balanceOf(address(this));
        emit Loan(sender, baseAmount, quoteAmount, usdtBalance, data);
        IERC20(_usdtAddr).transfer(_loanAddr, quoteAmount);
    }
}

