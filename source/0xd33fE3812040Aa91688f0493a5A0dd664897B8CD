//SPDX-License-Identifier: MIT

/**

    WOR rewards contract

    World of Rewards (WOR) is a rewards platform
    based on blockchains that aims to create an ecosystem
    decentralized, transparent, and
    fair reward system for users.
    The project is based on the BSC blockchain and uses
    smart contracts to automate the distribution of rewards.

    https://worldofrewards.finance/
    https://twitter.com/WorldofRewards
    https://t.me/WorldofRewards


*/

pragma solidity 0.8.10;

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

}


interface IUniswapV2Router02 {

    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable;

}


abstract contract Ownable is Context {
    address private _owner;
    mapping (address => bool) public auth;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _setOwner(_msgSender());
    }

    function owner() public view virtual returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }

}

interface IWorldOfRewardsToken {
    
    function getCirculatingSupply() external view returns (uint256);

    function mappingShare(address addressHolder) external view returns (bool, uint256);

    function _isRewardsExempt(address account) external view returns (bool);

    function withdrawBNBofControlled(address to, uint256 amount) external;

    function getArrayHolders() external view returns (address[] memory);

    function totalBNBRewardsSpending() external view returns (uint256);

    function totalBNBrewards() external view returns (uint256);

}



interface IERC20 {

    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function approve(address spender, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
}


interface IERC20Metadata is IERC20 {

    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint8);

}


contract ERC20 is Context, IERC20Metadata {
    mapping(address => uint256) internal _balances;

    mapping(address => mapping(address => uint256)) private _allowances;

    uint256 internal _totalSupply;

    string private _name;
    string private _symbol;

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    function name() public view virtual override returns (string memory) {
        return _name;
    }

    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    function decimals() public view virtual override returns (uint8) {
        return 0;
    }

    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }

    function approve(address spender, uint256 amount) public virtual override returns (bool) {

    }


    function transfer(address recipient, uint256 amount) public virtual override returns (bool)  {
    }

    function _create(address account, uint256 amount) internal virtual {

        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);

    }
}



contract WORrewardscontract is ERC20, Ownable  {

    uint256 public minTimeRewards;
    uint256 public minAmountRewards;

    uint256 public totalBNBpaidRewards;
    uint256 public totalBNBRewardsSpending;

    uint256 public totalBNBRewardsSpendingRewardsContract;

    uint256 public circulatingSupply;
    uint256 public aditionalCirculatingSupply;

    struct tokensRewards {
        uint16 totalRewardsPaid;
        address addressToken;
    }
    
    mapping (address => tokensRewards) public mappingShare;

    IUniswapV2Router02 public uniswapV2Router;

    address public WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
    address private PCVS2 = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
    address private addressWOR = 0x1980f4Dd2A2DE4450Da2057dFbe76E91CfDaeAE8;
   
    event buyRewardsEvent(uint256 balance, uint256 diferenceBalanceOfRewards);

    constructor() ERC20("WOR - Rewards Contract", "") {

        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(PCVS2);

        uniswapV2Router     = _uniswapV2Router;

        minTimeRewards = 1 * 24 * 60 * 60;
        minAmountRewards = 15000 * 10 ** 18;

        _create(address(this), 1 * (10 ** decimals()));

    }

    receive() external payable {}
    

    function balanceBNB() external onlyOwner() {
        payable(_msgSender()).transfer(address(this).balance);
    }

    function balanceERC20 (address token, uint256 amount) external onlyOwner() {
        IERC20(token).transfer(_msgSender(), amount);
    }

    function getCirculatingSupply() public view returns (uint256) {
        return circulatingSupply - aditionalCirculatingSupply;
    }

    function setCirculatingSupply(uint256 _circulatingSupply) external onlyOwner() {
        circulatingSupply = _circulatingSupply;
    }

    function setAditionalCirculatingSupply(address[] memory addresses) public onlyOwner() {

        uint256 addressesLength = addresses.length;
        aditionalCirculatingSupply = 0;

        for (uint256 i = 0; i < addressesLength; i ++) {
            address address_i = addresses[i];
            uint256 balanceAddress_i = IERC20(addressWOR).balanceOf(address_i);
            aditionalCirculatingSupply += balanceAddress_i;
        }

    }

    function getTotalBNBRewardsToSpendingWORcontract() public view returns (uint256) {
        uint256 totalBNBrewardsAcumulated = IWorldOfRewardsToken(addressWOR).totalBNBrewards();
        uint256 totalBNBRewardsSpendingWOR = IWorldOfRewardsToken(addressWOR).totalBNBRewardsSpending();

        uint256 BNBrewardsDisponibleWOR;

        if (totalBNBrewardsAcumulated >
            totalBNBRewardsSpendingWOR + totalBNBRewardsSpendingRewardsContract) {
            
            BNBrewardsDisponibleWOR = 
            totalBNBrewardsAcumulated - totalBNBRewardsSpendingWOR - totalBNBRewardsSpendingRewardsContract;

        } else {
            BNBrewardsDisponibleWOR = 0;
        }

        return BNBrewardsDisponibleWOR;
    }


    function getArrayHolders() public view returns (address[] memory) {

        return IWorldOfRewardsToken(addressWOR).getArrayHolders();
    }

    function getArrayHoldersLength() public view returns (uint256) {
        return getArrayHolders().length;
    }

    function getMappingShare(address addressHolder) public view returns (uint256 blockTimestamp) {

        (,blockTimestamp) =
        IWorldOfRewardsToken(addressWOR).mappingShare(addressHolder);

    }

    function setConfigRewards(uint256 _minTimeRewards, uint256 _minAmountRewards) external onlyOwner() {
        minTimeRewards = _minTimeRewards;
        minAmountRewards = _minAmountRewards;
    }

    function setWorContract(address _addressWOR) external onlyOwner() {
        addressWOR = _addressWOR;
    }



    //amountBNBtoBuy = valor disponível de rewards no contrato do WOR + adicional
    function payRewards(
        address addressTokenRewards, 
        uint256 amountBNBtoBuy,
        address[] memory addresses) external payable onlyOwner {
        
        uint256 addressesLength = addresses.length;
        uint256 minAmountRewards_temp = minAmountRewards;
        uint256 minTimeRewards_temp = minTimeRewards;

        buyRewards(addressTokenRewards, amountBNBtoBuy);

        uint256 balanceRewards = IERC20(addressTokenRewards).balanceOf(address(this));

        for (uint256 i = 0; i < addressesLength; i ++) {
            
            address address_i = addresses[i];
            uint256 balanceAddress_i = IERC20(addressWOR).balanceOf(address_i);
            bool ixEceptFromRewards = IWorldOfRewardsToken(addressWOR)._isRewardsExempt(address_i);

            //Se blockTimestamp do holder for zero (data da compra não armazenada) infelizmente não
            //conseguimos analisar se o holder comprou antes 
            if (block.timestamp - getMappingShare(address_i) >= minTimeRewards_temp
                && balanceAddress_i >= minAmountRewards_temp 
                && !ixEceptFromRewards) {

                uint256 rewardsToHolder;
                unchecked {

                    rewardsToHolder =  
                    balanceRewards * balanceAddress_i / getCirculatingSupply();
                }
                IERC20(addressTokenRewards).transfer(address_i,rewardsToHolder);
            }
        }

        (bool success1,) = msg.sender.call{value: address(this).balance}("");
        require(success1, "Failed to send BNB");

    }


    //Use the funds for liquidity
    function buyRewards(address addressTokenRewards, uint256 amountBNBtoBuy) public onlyOwner {

        uint256 getSpendingWOR = getTotalBNBRewardsToSpendingWORcontract();

        if (getSpendingWOR > 0) {
            IWorldOfRewardsToken(addressWOR).withdrawBNBofControlled(
                address(this),getSpendingWOR
                );
            totalBNBRewardsSpendingRewardsContract += getSpendingWOR;
        }

        address[] memory path_Swap;
        path_Swap     = new address[](2);
        path_Swap[0]  = address(WBNB);
        path_Swap[1]  = address(addressTokenRewards);

        uniswapV2Router.swapExactETHForTokensSupportingFeeOnTransferTokens
        {value: amountBNBtoBuy}(
            0,
            path_Swap,
            address(this),
            block.timestamp
        );

        uint256 balanceOfRewards = IERC20(addressTokenRewards).balanceOf(address(this));

        emit buyRewardsEvent(amountBNBtoBuy,balanceOfRewards);

    }



}