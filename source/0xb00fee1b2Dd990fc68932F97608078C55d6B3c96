{"DickCoin.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\n/*\r\n Linktree: https://linktr.ee/CutYourDickoff_\r\n Twitter: https://twitter.com/cutyourdickoff\r\n Youtube: https://youtube.com/@DICK-Crypto\r\n Website: https://cutyourdickoff.men\r\n Email: support@cutyourdickoff.men\r\n Telegram:\r\n  - Group: https://t.me/cutyourdickoff\r\n  - Channel: https://t.me/cutmydickoff\r\n\r\n\r\n     ##### /    ##   ###            ###                                                     ##### ##                        /                                     \r\n  ######  /  #####    ###            ###                                                 /#####  /##      #               #/                                      \r\n /#   /  /     #####   ###            ##                                               //    /  / ###    ###              ##                                      \r\n/    /  ##     # ##      ##           ##                                              /     /  /   ###    #               ##                                      \r\n    /  ###     #         ##           ##                                                   /  /     ###                   ##                                      \r\n   ##   ##     #         ##    /##    ##      /###      /###   ### /### /###     /##      ## ##      ## ###       /###    ##  /##      /##  ###  /###     /###    \r\n   ##   ##     #         ##   / ###   ##     / ###  /  / ###  / ##/ ###/ /##  / / ###     ## ##      ##  ###     / ###  / ## / ###    / ###  ###/ #### / / #### / \r\n   ##   ##     #         ##  /   ###  ##    /   ###/  /   ###/   ##  ###/ ###/ /   ###    ## ##      ##   ##    /   ###/  ##/   /    /   ###  ##   ###/ ##  ###/  \r\n   ##   ##     #         ## ##    ### ##   ##        ##    ##    ##   ##   ## ##    ###   ## ##      ##   ##   ##         ##   /    ##    ### ##       ####       \r\n   ##   ##     #         ## ########  ##   ##        ##    ##    ##   ##   ## ########    ## ##      ##   ##   ##         ##  /     ########  ##         ###      \r\n    ##  ##     #         ## #######   ##   ##        ##    ##    ##   ##   ## #######     #  ##      ##   ##   ##         ## ##     #######   ##           ###    \r\n     ## #      #         /  ##        ##   ##        ##    ##    ##   ##   ## ##             /       /    ##   ##         ######    ##        ##             ###  \r\n      ###      /##      /   ####    / ##   ###     / ##    ##    ##   ##   ## ####    / /###/       /     ##   ###     /  ##  ###   ####    / ##        /###  ##  \r\n       #######/ #######/     ######/  ### / ######/   ######     ###  ###  ### ######/ /   ########/      ### / ######/   ##   ### / ######/  ###      / #### /   \r\n         ####     ####        #####    ##/   #####     ####       ###  ###  ### ##### /       ####         ##/   #####     ##   ##/   #####    ###        ###/    \r\n                                                                                      #                                                                           \r\n                                                                                       ##                                                                         \r\n*/\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./DickPoolReward.sol\";\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Router02 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n}\r\ninterface IUniswapV2Factory {\r\n    function createPair(address tokenA, address tokenB) external returns (address UNISWAP_V2_PAIR);\r\n    function getPair(address tokenA, address tokenB) external view returns (address UNISWAP_V2_PAIR);\r\n}\r\n\r\ncontract DickCoin is IERC20, Ownable {\r\n    event Reflect(uint256 _amount, uint256 _newTotalProportion);\r\n    address constant DEAD = 0x000000000000000000000000000000000000dEaD;\r\n    IUniswapV2Router02 public constant UNISWAP_V2_ROUTER =\r\n        IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n    address public UNISWAP_V2_PAIR;\r\n\r\n    struct Fee {\r\n        uint8 reflection;\r\n        uint8 marketing;\r\n        uint8 pool;\r\n        uint8 burn;\r\n        uint128 total;\r\n    }\r\n    string _name = \"Dick Coin\";\r\n    string _symbol = \"DICK\";\r\n    uint256 _totalSupply = 1_000_000_000_000_000 ether;\r\n    mapping(address =\u003e uint256) public _rOwned;\r\n    uint256 public _totalProportion = _totalSupply;\r\n    mapping(address =\u003e mapping(address =\u003e uint256)) _allowances;\r\n    mapping(address =\u003e bool) isFeeExempt;\r\n    mapping(address =\u003e bool) isReflectionExempt;\r\n\r\n    uint256 constant MAX_FEE = 15;\r\n\r\n    Fee public buyFee = Fee({reflection: 5, marketing: 3, pool: 0, burn: 2, total: 10});\r\n    Fee public sellFee = Fee({reflection: 5, marketing: 5, pool: 5, burn: 0, total: 15});\r\n\r\n    address private marketingFeeReceiver;\r\n    address private poolFeeReceiver;\r\n    address private reserveFeeReceiver;\r\n\r\n    bool public claimingFees = true;\r\n    uint256 public swapThreshold = (_totalSupply * 2) / 1000;\r\n    uint256 public maxFeeSwap = (_totalSupply * 5) / 1000;\r\n    bool inSwap;\r\n    mapping(address =\u003e bool) public blacklists;\r\n    modifier swapping() {\r\n        inSwap = true;\r\n        _;\r\n        inSwap = false;\r\n    }\r\n    constructor() {\r\n        _rOwned[_msgSender()] = _totalSupply;\r\n        isFeeExempt[_msgSender()] = true;\r\n        isFeeExempt[DEAD] = true;\r\n        isFeeExempt[address(this)] = true;\r\n        isReflectionExempt[_msgSender()] = true;\r\n        isReflectionExempt[DEAD] = true;\r\n        isReflectionExempt[address(this)] = true;\r\n        _allowances[address(this)][address(UNISWAP_V2_ROUTER)] = type(uint256).max;\r\n        _allowances[address(this)][tx.origin] = type(uint256).max;\r\n        marketingFeeReceiver = _msgSender();\r\n        poolFeeReceiver = address(0x2c4C54479fE0Fa805Da66C34DcdaDa77b9d541E3);\r\n        reserveFeeReceiver = _msgSender();\r\n        UNISWAP_V2_PAIR = IUniswapV2Factory(UNISWAP_V2_ROUTER.factory()).createPair(\r\n            address(this),\r\n            UNISWAP_V2_ROUTER.WETH()\r\n        );\r\n        emit Transfer(address(0), _msgSender(), _totalSupply);\r\n    }\r\n    receive() external payable {}\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function approveMax(address spender) external returns (bool) {\r\n        return approve(spender, type(uint256).max);\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        return _transferFrom(msg.sender, recipient, amount);\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        if (_allowances[sender][msg.sender] != type(uint256).max) {\r\n            require(_allowances[sender][msg.sender] \u003e= amount, \"ERC20: insufficient allowance\");\r\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender] - amount;\r\n        }\r\n\r\n        return _transferFrom(sender, recipient, amount);\r\n    }\r\n    function totalSupply() external view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function decimals() external pure returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    function name() external view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() external view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        if (isReflectionExempt[account]) return _rOwned[account];\r\n        return tokenFromReflection(_rOwned[account]);\r\n    }\r\n\r\n    function allowance(address holder, address spender) external view override returns (uint256) {\r\n        return _allowances[holder][spender];\r\n    }\r\n\r\n    function tokensToProportion(uint256 tokens) public view returns (uint256) {\r\n        return tokens * _totalProportion / _totalSupply;\r\n    }\r\n\r\n    function tokenFromReflection(uint256 proportion) public view returns (uint256) {\r\n        return proportion * _totalSupply / _totalProportion;\r\n    }\r\n\r\n    function getCirculatingSupply() public view returns (uint256) {\r\n        return _totalSupply - balanceOf(DEAD);\r\n    }\r\n    function clearStuckBalance() external onlyOwner {\r\n        (bool success,) = payable(msg.sender).call{value: address(this).balance}(\"\");\r\n        require(success);\r\n    }\r\n\r\n    function clearStuckToken() external onlyOwner {\r\n        _transferFrom(address(this), msg.sender, balanceOf(address(this)));\r\n    }\r\n\r\n    function setSwapBackSettings(bool _enabled, uint256 _amount) external onlyOwner {\r\n        claimingFees = _enabled;\r\n        swapThreshold = _amount;\r\n    }\r\n\r\n    function changeFees(\r\n        uint8 _buyReflection,\r\n        uint8 _buyMarketing,\r\n        uint8 _buyPool,\r\n        uint8 _buyBurn,\r\n        uint8 _sellReflection,\r\n        uint8 _sellMarketing,\r\n        uint8 _sellPool,\r\n        uint8 _sellBurn\r\n    ) external onlyOwner {\r\n        require(\r\n            _buyReflection + _buyMarketing + _buyPool + _buyBurn \u003c= MAX_FEE \u0026\u0026\r\n                _sellReflection + _sellMarketing + _sellPool + _sellBurn \u003c= MAX_FEE,\r\n            \"Fee is too high\"\r\n        );\r\n        buyFee = Fee({\r\n            reflection: _buyReflection,\r\n            marketing: _buyMarketing,\r\n            pool: _buyPool,\r\n            burn: _buyBurn,\r\n            total: _buyReflection + _buyMarketing + _buyPool + _buyBurn\r\n        });\r\n        sellFee = Fee({\r\n            reflection: _sellReflection,\r\n            marketing: _sellMarketing,\r\n            pool: _sellPool,\r\n            burn: _sellBurn,\r\n            total: _sellReflection + _sellMarketing + _sellPool + _sellBurn\r\n        });\r\n    }\r\n\r\n    function setIsFeeExempt(address holder, bool exempt) external onlyOwner {\r\n        isFeeExempt[holder] = exempt;\r\n    }\r\n\r\n    function setFeeReceivers(address m_, address p_) external onlyOwner {\r\n        marketingFeeReceiver = m_;\r\n        poolFeeReceiver = p_;\r\n    }\r\n\r\n    function blacklist(address _address, bool _isBlacklisting) external onlyOwner {\r\n        blacklists[_address] = _isBlacklisting;\r\n    }\r\n    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        require(!blacklists[recipient] \u0026\u0026 !blacklists[sender], \"Blacklisted\");\r\n\r\n        if (inSwap) {\r\n            return _basicTransfer(sender, recipient, amount);\r\n        }\r\n\r\n        if (_shouldSwapBack()) {\r\n            _swapBack();\r\n        }\r\n\r\n        uint256 proportionAmount = tokensToProportion(amount);\r\n        require(_rOwned[sender] \u003e= proportionAmount, \"Insufficient Balance\");\r\n        _rOwned[sender] = _rOwned[sender] - proportionAmount;\r\n\r\n        uint256 proportionReceived = _shouldTakeFee(sender, recipient)\r\n            ? _takeFeeInProportions(sender == UNISWAP_V2_PAIR ? true : false, sender, proportionAmount)\r\n            : proportionAmount;\r\n        _rOwned[recipient] = _rOwned[recipient] + proportionReceived;\r\n\r\n        emit Transfer(sender, recipient, tokenFromReflection(proportionReceived));\r\n        return true;\r\n    }\r\n\r\n    function _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        uint256 proportionAmount = tokensToProportion(amount);\r\n        require(_rOwned[sender] \u003e= proportionAmount, \"Insufficient Balance\");\r\n        _rOwned[sender] = _rOwned[sender] - proportionAmount;\r\n        _rOwned[recipient] = _rOwned[recipient] + proportionAmount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function _takeFeeInProportions(bool buying, address sender, uint256 proportionAmount) internal returns (uint256) {\r\n        Fee memory __buyFee = buyFee;\r\n        Fee memory __sellFee = sellFee;\r\n\r\n        uint256 proportionFeeAmount =\r\n            buying == true ? proportionAmount * __buyFee.total / 100 : proportionAmount * __sellFee.total / 100;\r\n\r\n        uint256 proportionReflected = buying == true\r\n            ? proportionFeeAmount * __buyFee.reflection / __buyFee.total\r\n            : proportionFeeAmount * __sellFee.reflection / __sellFee.total;\r\n\r\n        _totalProportion = _totalProportion - proportionReflected;\r\n\r\n        // take fees\r\n        uint256 _proportionToContract = proportionFeeAmount - proportionReflected;\r\n        if (_proportionToContract \u003e 0) {\r\n            _rOwned[address(this)] = _rOwned[address(this)] + _proportionToContract;\r\n\r\n            emit Transfer(sender, address(this), tokenFromReflection(_proportionToContract));\r\n        }\r\n        emit Reflect(proportionReflected, _totalProportion);\r\n        return proportionAmount - proportionFeeAmount;\r\n    }\r\n\r\n    function _shouldSwapBack() internal view returns (bool) {\r\n        return msg.sender != UNISWAP_V2_PAIR \u0026\u0026 !inSwap \u0026\u0026 claimingFees \u0026\u0026 balanceOf(address(this)) \u003e= swapThreshold;\r\n    }\r\n\r\n    function _swapBack() internal swapping {\r\n        Fee memory __sellFee = sellFee;\r\n        Fee memory __buyFee = buyFee;\r\n\r\n        uint256 amountToSwap = balanceOf(address(this));\r\n        uint256 amountToBurn = amountToSwap * (__sellFee.burn + __buyFee.burn) / (__sellFee.total + __buyFee.total);\r\n        uint256 amountToSwapBack = amountToSwap - amountToBurn;\r\n\r\n        approve(address(UNISWAP_V2_ROUTER), amountToSwap);\r\n\r\n        // burn\r\n        _transferFrom(address(this), DEAD, amountToBurn);\r\n\r\n        // swap\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = UNISWAP_V2_ROUTER.WETH();\r\n\r\n        UNISWAP_V2_ROUTER.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            amountToSwapBack, 0, path, address(this), block.timestamp\r\n        );\r\n\r\n        uint256 amountETH = address(this).balance;\r\n\r\n        uint256 totalSwapFee = (__sellFee.marketing + __sellFee.pool) + (__buyFee.marketing + __buyFee.pool);\r\n        uint256 amountETHMarketing = amountETH * (__sellFee.marketing + __buyFee.marketing) / totalSwapFee;\r\n        uint256 amountETHPool = amountETH - amountETHMarketing;\r\n        // send\r\n        (bool tmpSuccess,) = payable(marketingFeeReceiver).call{value: amountETHMarketing}(\"\");\r\n        require(tmpSuccess, \"Transfer failed\");\r\n        DickPoolReward(poolFeeReceiver).deposit{value: amountETHPool}();\r\n    }\r\n\r\n    function _shouldTakeFee(address sender, address recipient) internal view returns (bool) {\r\n        return !isFeeExempt[sender] \u0026\u0026 !isFeeExempt[recipient];\r\n    }\r\n}"},"DickPoolReward.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\n/*\r\n Linktree: https://linktr.ee/CutYourDickoff_\r\n Twitter: https://twitter.com/cutyourdickoff\r\n Youtube: https://youtube.com/@DICK-Crypto\r\n Website: https://cutyourdickoff.men\r\n Email: support@cutyourdickoff.men\r\n Telegram:\r\n  - Group: https://t.me/cutyourdickoff\r\n  - Channel: https://t.me/cutmydickoff\r\n\r\n\r\n     ##### /    ##   ###            ###                                                     ##### ##                        /                                     \r\n  ######  /  #####    ###            ###                                                 /#####  /##      #               #/                                      \r\n /#   /  /     #####   ###            ##                                               //    /  / ###    ###              ##                                      \r\n/    /  ##     # ##      ##           ##                                              /     /  /   ###    #               ##                                      \r\n    /  ###     #         ##           ##                                                   /  /     ###                   ##                                      \r\n   ##   ##     #         ##    /##    ##      /###      /###   ### /### /###     /##      ## ##      ## ###       /###    ##  /##      /##  ###  /###     /###    \r\n   ##   ##     #         ##   / ###   ##     / ###  /  / ###  / ##/ ###/ /##  / / ###     ## ##      ##  ###     / ###  / ## / ###    / ###  ###/ #### / / #### / \r\n   ##   ##     #         ##  /   ###  ##    /   ###/  /   ###/   ##  ###/ ###/ /   ###    ## ##      ##   ##    /   ###/  ##/   /    /   ###  ##   ###/ ##  ###/  \r\n   ##   ##     #         ## ##    ### ##   ##        ##    ##    ##   ##   ## ##    ###   ## ##      ##   ##   ##         ##   /    ##    ### ##       ####       \r\n   ##   ##     #         ## ########  ##   ##        ##    ##    ##   ##   ## ########    ## ##      ##   ##   ##         ##  /     ########  ##         ###      \r\n    ##  ##     #         ## #######   ##   ##        ##    ##    ##   ##   ## #######     #  ##      ##   ##   ##         ## ##     #######   ##           ###    \r\n     ## #      #         /  ##        ##   ##        ##    ##    ##   ##   ## ##             /       /    ##   ##         ######    ##        ##             ###  \r\n      ###      /##      /   ####    / ##   ###     / ##    ##    ##   ##   ## ####    / /###/       /     ##   ###     /  ##  ###   ####    / ##        /###  ##  \r\n       #######/ #######/     ######/  ### / ######/   ######     ###  ###  ### ######/ /   ########/      ### / ######/   ##   ### / ######/  ###      / #### /   \r\n         ####     ####        #####    ##/   #####     ####       ###  ###  ### ##### /       ####         ##/   #####     ##   ##/   #####    ###        ###/    \r\n                                                                                      #                                                                           \r\n                                                                                       ##                                                                         \r\n*/\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\ncontract DickPoolReward {\r\n    IERC20 public token;\r\n    address public owner;\r\n    struct StakeInfo {\r\n        uint256 amount;\r\n        uint256 time;\r\n    }\r\n    mapping(address =\u003e StakeInfo) public staker;\r\n    address[] public stakers;\r\n    mapping(address =\u003e uint256) public balanceOf;\r\n    uint256 amountStake = 600_000_000_000 * 10**18;\r\n    event Deposit(address indexed sender, uint256 amount);\r\n    event Withdraw(address indexed sender, address indexed receiver, uint256 amount);\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n    function deposit() public payable {\r\n        balanceOf[msg.sender] += msg.value;\r\n        emit Deposit(msg.sender, msg.value);\r\n    }\r\n    function stake() public {\r\n        require(token.balanceOf(msg.sender) \u003e= amountStake, \"not enough token\");\r\n        require(staker[msg.sender].amount == 0, \"already staked\");\r\n        token.transferFrom(msg.sender, address(this), amountStake);\r\n        staker[msg.sender].amount = amountStake;\r\n        staker[msg.sender].time = block.timestamp;\r\n        stakers.push(msg.sender);\r\n    }\r\n    function unstake() public {\r\n        require(staker[msg.sender].amount \u003e 0, \"not staked\");\r\n        uint256 reward = _calculateReward(msg.sender);\r\n        payable(msg.sender).transfer(reward);\r\n        emit Withdraw(address(this), msg.sender, reward);\r\n        token.transfer(msg.sender, staker[msg.sender].amount);\r\n        staker[msg.sender].amount = 0;\r\n        staker[msg.sender].time = 0;\r\n        for (uint256 i = 0; i \u003c stakers.length; i++) {\r\n            if (stakers[i] == msg.sender) {\r\n                stakers[i] = stakers[stakers.length - 1];\r\n                stakers.pop();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    function claimReward() public {\r\n        require(staker[msg.sender].amount \u003e 0, \"not staked\");\r\n        uint256 reward = _calculateReward(msg.sender);\r\n        payable(msg.sender).transfer(reward);\r\n        emit Withdraw(address(this), msg.sender, reward);\r\n        staker[msg.sender].time = block.timestamp;\r\n    }\r\n    function setToken(address _token) public {\r\n        require(msg.sender == owner, \"only owner\");\r\n        token = IERC20(_token);\r\n    }\r\n    function setAmountStake(uint256 _amount) public {\r\n        require(msg.sender == owner, \"only owner\");\r\n        amountStake = _amount;\r\n    }\r\n    function getRewardInfo(address _staker) public view returns(uint256) {\r\n        return _calculateReward(_staker);\r\n    }\r\n    function getTotalStaker() public view returns(uint256) {\r\n        return _getTotalStaker();\r\n    }\r\n    function _getTotalStaker() private view returns(uint256) {\r\n        return stakers.length;\r\n    }\r\n    function _calculateReward(address _staker) private view returns(uint256) {\r\n        if (staker[_staker].amount == 0) {\r\n            return 0;\r\n        }\r\n        uint256 time = block.timestamp - staker[_staker].time;\r\n        if (time == 0) {\r\n            return 0;\r\n        }\r\n        uint256 totalStakers = _getTotalStaker();\r\n        if (totalStakers == 0) {\r\n            return 0;\r\n        }\r\n        uint256 reward = address(this).balance / (31536000 / time) / totalStakers;\r\n        return reward;\r\n    }\r\n}"}}