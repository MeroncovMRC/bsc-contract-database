{"InsuranceDeclaration.sol":{"content":"// SPDX-License-Identifier: -- ? % ? --\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \u0027./InsuranceInterface.sol\u0027;\r\n\r\ncontract InsuranceDeclaration {\r\n\r\n    WiseTokenInterface public immutable WISE_CONTRACT;\r\n    PancakeRouterInterface public immutable PANCAKE_ROUTER;\r\n\r\n    address public constant WBNB =\r\n    0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\r\n\r\n    address public constant PANCAKE_ROUTER_ADDRESS =\r\n    0x10ED43C718714eb63d5aA57B78B54704E256024E;\r\n\r\n    address public immutable SBNB;\r\n    address public immutable WISE_TOKEN_ADDRESS;\r\n\r\n    // tracking state variables - cannot be changed by master\r\n    uint256 public totalStaked; // - just to track amount of total tokens staked\r\n    uint256 public totalCovers; // - amount of tokens we need to cover\r\n    uint256 public totalBufferStaked;  // - to track amount of tokens dedicated to buffer stakes\r\n    uint256 public totalPublicDebth;   // - amount of tokens we own to public contributors\r\n    uint256 public totalPublicRewards; // - amount of token we allocate to public payouts (to public contribs)\r\n    uint256 public totalMasterProfits; // - tracking profits for the master, to know how much can be taken\r\n\r\n    uint256 public teamContribution; // initial funding from the team\r\n\r\n    // threshold for opening new stakes - can be adjusted by master\r\n    uint256 public coverageThreshold;\r\n\r\n    // threshold for profit payouts - can be adjusted by master\r\n    uint256 public payoutThreshold;\r\n\r\n    // threshold for getting staked amount back - can be adjusted by master\r\n    uint256 public penaltyThresholdA;\r\n    uint256 public penaltyThresholdB;\r\n\r\n    // threshold for getting staked amount back - can be adjusted by master\r\n    uint256 public penaltyA;\r\n    uint256 public penaltyB;\r\n\r\n    // % amount to be staked when opening insurance stake - can be adjusted by master\r\n    uint256 public stakePercent;\r\n\r\n    // % amount to return from principal when closing stake - can be adjusted by master\r\n    uint256 public principalCut; // (0%-10%)\r\n\r\n    // % amount to return from interest when closing stake - can be adjusted by master\r\n    uint256 public interestCut; // (0%-10%)\r\n\r\n    // % amount to return for public investor - can be adjusted by master\r\n    uint256 public publicRewardPercent;\r\n\r\n    // cap for public contributions\r\n    uint256 public publicDebthCap;\r\n\r\n    // cap for buffer staking total amount - can be adjusted by master\r\n    uint256 public bufferStakeCap;\r\n\r\n    // ability to control maximum buffer stake duration - can be adjusted by master\r\n    uint256 public maximumBufferStakeDuration;\r\n\r\n    // ability to purchase insurancce - can be switched by master\r\n    bool public allowInsurance;\r\n\r\n    // ability to fund treasury from outside - can be switched by master\r\n    bool public allowPublicContributions;\r\n\r\n    // ability to reroute buffer stake interest as developer funds - can be switched by master\r\n    bool public getBufferStakeInterest;\r\n\r\n    // ability to allow users of using their existing stakes as collateral\r\n    bool public allowCollaterization;\r\n\r\n    // ability to redefine helper contract aka lending contract\r\n    bool public allowHelperChange;\r\n\r\n    uint256 constant MAX_STAKE_DAYS = 1095; // constant cannot be adjusted 3 years\r\n\r\n    address payable public insuranceMaster; // master is a MultiSigWallet\r\n    address payable public insuranceWorker; // worker can be defined by master\r\n    address payable public insuranceWallet; // where the funds are directed\r\n    address payable public insuranceHelper; // future contract for lending\r\n\r\n    struct InsuranceStake {\r\n        bytes16 stakeID;\r\n        uint256 bufferAmount;\r\n        uint256 stakedAmount;\r\n        uint256 matureAmount;\r\n        uint256 emergencyAmount;\r\n        address currentOwner;\r\n        bool isActive;\r\n    }\r\n\r\n    struct BufferStake {\r\n        uint256 stakedAmount;\r\n        bytes16 stakeID;\r\n        bool isActive;\r\n    }\r\n\r\n    struct OwnerlessStake {\r\n        uint256 stakeIndex;\r\n        address originalOwner;\r\n    }\r\n\r\n    struct PenaltyRules {\r\n        uint256 penaltyThresholdA;\r\n        uint256 penaltyThresholdB;\r\n        uint256 penaltyA;\r\n        uint256 penaltyB;\r\n    }\r\n\r\n    struct CollateralRules {\r\n        address originalOwner;\r\n        bool isLiquidated;\r\n    }\r\n\r\n    uint256 public bufferStakeCount;\r\n    uint256 public ownerlessStakeCount;\r\n    uint256 public insuranceStakeCount;\r\n    uint256 public collateralStakeCount;\r\n\r\n    uint256 public activeInsuranceStakeCount;\r\n    uint256 public activeOwnerlessStakeCount;\r\n    uint256 public activeBufferStakeCount;\r\n\r\n    mapping (bytes16 =\u003e PenaltyRules) public penaltyRules;\r\n    mapping (bytes16 =\u003e CollateralRules) public collateralRules;\r\n\r\n    mapping (address =\u003e uint256) public insuranceStakeCounts;\r\n    mapping (address =\u003e mapping(uint256 =\u003e InsuranceStake)) public insuranceStakes;\r\n\r\n    mapping (uint256 =\u003e BufferStake) public bufferStakes;\r\n    mapping (uint256 =\u003e OwnerlessStake) public ownerlessStakes;\r\n\r\n    // tracking individual public debth to contributor\r\n    mapping (address =\u003e uint256) public publicReward;\r\n\r\n    modifier onlyMaster() {\r\n        require(\r\n            msg.sender == insuranceMaster\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyHelper() {\r\n        require(\r\n            msg.sender == insuranceHelper\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyWorker() {\r\n        require(\r\n            msg.sender == insuranceWorker ||\r\n            msg.sender == insuranceMaster\r\n        );\r\n        _;\r\n    }\r\n\r\n    event TreasuryFunded(\r\n        uint256 amount,\r\n        address funder,\r\n        uint256 total\r\n    );\r\n\r\n    event InsurancStakeOpened(\r\n        bytes16 indexed stakeID,\r\n        uint256 stakedAmount,\r\n        uint256 returnAmount,\r\n        address indexed originalOwner,\r\n        uint256 indexed stakeIndex,\r\n        bytes16 referralID\r\n    );\r\n\r\n    event EmergencyExitStake(\r\n        address indexed stakeOwner,\r\n        uint256 indexed stakeIndex,\r\n        bytes16 indexed stakeID,\r\n        uint256 returnAfterFee,\r\n        uint256 returnAmount,\r\n        uint64 currentWiseDay\r\n    );\r\n\r\n    event NewOwnerlessStake(\r\n        uint256 indexed ownerlessIndex,\r\n        uint256 indexed stakeIndex,\r\n        address indexed stakeOwner\r\n    );\r\n\r\n    event InsuranceStakeClosed(\r\n        address indexed staker,\r\n        uint256 indexed stakeIndex,\r\n        bytes16 indexed stakeID,\r\n        uint256 returnAmount,\r\n        uint256 rewardAfterFee\r\n    );\r\n\r\n    event CollateralCreation(\r\n        address indexed staker,\r\n        uint256 indexed stakeIndex\r\n    );\r\n\r\n    event StakeLiquidation(\r\n        address indexed staker,\r\n        uint256 indexed stakeIndex\r\n    );\r\n\r\n    event StakeReturned(\r\n        address indexed staker,\r\n        uint256 indexed stakeIndex\r\n    );\r\n\r\n    event OwnerlessStakeClosed(\r\n        uint256 ownerlessIndex,\r\n        address indexed staker,\r\n        uint256 indexed stakeIndex,\r\n        bytes16 indexed stakeID,\r\n        uint256 stakedAmount,\r\n        uint256 rewardAmount\r\n    );\r\n\r\n    event BufferStakeOpened(\r\n        bytes16 indexed stakeID,\r\n        uint256 stakedAmount,\r\n        bytes16 indexed referralID\r\n    );\r\n\r\n    event BufferStakeClosed(\r\n        bytes16 indexed stakeID,\r\n        uint256 stakedAmount,\r\n        uint256 rewardAmount\r\n    );\r\n\r\n    event PublicContributionsOpened(\r\n        bool indexed status\r\n    );\r\n\r\n    event PublicProfit(\r\n        address indexed contributor,\r\n        uint256 amount,\r\n        uint256 publicDebth,\r\n        uint256 publicRewards\r\n    );\r\n\r\n    event ProfitsTaken(\r\n        uint256 profitAmount,\r\n        uint256 remainingBuffer\r\n    );\r\n\r\n    event publicRewardsGiven(\r\n        uint256 rewardAmount,\r\n        uint256 totalPublicDebth,\r\n        uint256 totalPublicRewards\r\n    );\r\n\r\n    event DeveloperFundsRouted(\r\n        uint256 fundsAmount\r\n    );\r\n\r\n    event checkStake(\r\n        uint256 startDay,\r\n        uint256 lockDays,\r\n        uint256 finalDay,\r\n        uint256 closeDay,\r\n        uint256 scrapeDay,\r\n        uint256 stakedAmount,\r\n        uint256 stakesShares,\r\n        uint256 rewardAmount,\r\n        uint256 penaltyAmount,\r\n        bool isActive,\r\n        bool isMature\r\n    );\r\n\r\n    event PenaltyRulesAdded(\r\n        bytes16 stakeID,\r\n        uint256 penaltyThresholdA,\r\n        uint256 penaltyThresholdB,\r\n        uint256 penaltyA,\r\n        uint256 penaltyB\r\n    );\r\n\r\n    constructor(\r\n        address _wiseToken,\r\n        address _sbnbToken\r\n    ) {\r\n        PANCAKE_ROUTER = PancakeRouterInterface(\r\n            PANCAKE_ROUTER_ADDRESS\r\n        );\r\n\r\n        WISE_CONTRACT = WiseTokenInterface(\r\n            _wiseToken\r\n        );\r\n\r\n        WISE_TOKEN_ADDRESS = _wiseToken;\r\n\r\n        SBNB = _sbnbToken;\r\n\r\n        stakePercent = 90;\r\n        payoutThreshold = 10;\r\n        coverageThreshold = 3;\r\n\r\n        penaltyThresholdA = 10;\r\n        penaltyThresholdB = 25;\r\n\r\n        penaltyA = 50;\r\n        penaltyB = 30;\r\n\r\n        allowInsurance = true;\r\n        allowHelperChange = true;\r\n    }\r\n\r\n    address ZERO_ADDRESS = address(0x0);\r\n\r\n    string TRANSFER_FAILED = \u0027WiseInsurance: transfer failed\u0027;\r\n\r\n    string NOT_YOUR_STAKE = \u0027WiseInsurance: stake ownership already renounced\u0027;\r\n    string NOT_MATURE_STAKE = \u0027WiseInsurance: stake is not mature\u0027;\r\n    string NOT_ACTIVE_STAKE = \u0027WiseInsurance: stake already closed\u0027;\r\n    string NOT_OWNERLESS_STAKE = \u0027WiseInsurance: stake is not ownerless\u0027;\r\n    string NOT_ALLOWED = \u0027WiseInsurance: not allowed\u0027;\r\n    string COLLATERIZATION_NOT_ALLOWED_YET = \u0027WiseInsurance: not allowed yet\u0027;\r\n\r\n    string MATURED_STAKE = \u0027WiseInsurance: stake already matured\u0027;\r\n    string BELOW_COVERAGE_THRESHOLD = \u0027WiseInsurance: below coverage threshold\u0027;\r\n    string BELOW_PAYOUT_THRESHOLD = \u0027WiseInsurance: below payout threshold\u0027;\r\n    string PUBLIC_CONTRIBUTIONS_DISABLED = \u0027WiseInsurance: public contributions closed\u0027;\r\n    string DECREASE_STAKE_DURATION = \u0027WiseInsurance: lockDays exceeded\u0027;\r\n    string INSURANCE_DISABLED = \u0027WiseInsurance: disabled\u0027;\r\n    string NO_REWARD_FOR_CONTRIBUTOR = \u0027WiseInsurance: no rewards for contributor\u0027;\r\n    string NO_PUBLIC_DEBTH = \u0027WiseInsurance: no public debth\u0027;\r\n    string NO_PUBLIC_REWARD_AVAILABLE = \u0027WiseInsurance: no rewards in public pot\u0027;\r\n    string EXCEEDING_PUBLIC_DEBTH_CAP = \u0027WiseInsurance: exceeding public debth cap\u0027;\r\n    string PUBLIC_DEBTH_NOT_PAID = \u0027WiseInsurance: public debth not paid\u0027;\r\n    string PUBLIC_CONTRIBUTION_MUST_BE_DISABLED = \u0027WiseInsurance: public contributions must be disabled\u0027;\r\n    string STAKE_ALREADY_LIQUIDATED = \u0027WiseInsurance: stake already liquidated\u0027;\r\n    string INVALID_ORIGINAL_OWNER = \u0027WiseInsurance: invalid original owner\u0027;\r\n\r\n    function changeMaster(\r\n        address payable _newMaster\r\n    )\r\n        external\r\n        onlyMaster\r\n    {\r\n        insuranceMaster = _newMaster;\r\n    }\r\n\r\n    function changeWallet(\r\n        address payable _newWallet\r\n    )\r\n        external\r\n        onlyMaster\r\n    {\r\n        insuranceWallet = _newWallet;\r\n    }\r\n\r\n    function changeHelper(\r\n        address payable _newHelper\r\n    )\r\n        external\r\n        onlyMaster\r\n    {\r\n        require(\r\n            allowHelperChange == true,\r\n            NOT_ALLOWED\r\n        );\r\n\r\n        insuranceHelper = _newHelper;\r\n    }\r\n\r\n    function renounceHelper()\r\n        external\r\n        onlyMaster\r\n    {\r\n        allowHelperChange = false;\r\n    }\r\n}\r\n"},"InsuranceHelper.sol":{"content":"// SPDX-License-Identifier: --?--\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \u0027./InsuranceDeclaration.sol\u0027;\r\n\r\nabstract contract InsuranceHelper is InsuranceDeclaration {\r\n\r\n    //  WISE INSURANCE (INTERNAL FUNCTIONS)  //\r\n    //  -------------------------------------\r\n\r\n\tfunction _increaseTotalStaked(\r\n\t    uint256 _amount\r\n\t)\r\n\t    internal\r\n\t{\r\n\t    totalStaked =\r\n\t    totalStaked + _amount;\r\n\t}\r\n\r\n\tfunction _decreaseTotalStaked(\r\n\t    uint256 _amount\r\n\t)\r\n\t    internal\r\n\t{\r\n\t    totalStaked =\r\n\t    totalStaked - _amount;\r\n\t}\r\n\r\n\tfunction _increaseTotalCovers(\r\n\t    uint256 _amount\r\n\t)\r\n\t    internal\r\n\t{\r\n\t    totalCovers =\r\n\t    totalCovers + _amount;\r\n\t}\r\n\r\n\tfunction _decreaseTotalCovers(\r\n\t    uint256 _amount\r\n\t)\r\n\t    internal\r\n\t{\r\n\t    totalCovers =\r\n\t    totalCovers - _amount;\r\n\t}\r\n\r\n\tfunction _increaseTotalBufferStaked(\r\n\t    uint256 _amount\r\n\t)\r\n\t    internal\r\n\t{\r\n\t    totalBufferStaked =\r\n\t    totalBufferStaked + _amount;\r\n\t}\r\n\r\n\tfunction _decreaseTotalBufferStaked(\r\n\t    uint256 _amount\r\n\t)\r\n\t    internal\r\n\t{\r\n\t    totalBufferStaked =\r\n\t    totalBufferStaked - _amount;\r\n\t}\r\n\r\n\tfunction _increaseTotalMasterProfits(\r\n\t    uint256 _amount\r\n\t)\r\n\t    internal\r\n\t{\r\n\t    totalMasterProfits =\r\n\t    totalMasterProfits + _amount;\r\n\t}\r\n\r\n\tfunction _decreaseTotalMasterProfits(\r\n\t    uint256 _amount\r\n\t)\r\n\t    internal\r\n\t{\r\n\t    totalMasterProfits =\r\n\t    totalMasterProfits \u003e _amount ?\r\n\t    totalMasterProfits - _amount : 0;\r\n\t}\r\n\r\n    function _increaseActiveInsuranceStakeCount()\r\n        internal\r\n    {\r\n        activeInsuranceStakeCount++;\r\n    }\r\n\r\n    function _decreaseActiveInsuranceStakeCount()\r\n        internal\r\n    {\r\n        activeInsuranceStakeCount--;\r\n    }\r\n\r\n    function _increaseActiveOwnerlessStakeCount()\r\n        internal\r\n    {\r\n        activeOwnerlessStakeCount++;\r\n    }\r\n\r\n    function _decreaseActiveOwnerlessStakeCount()\r\n        internal\r\n    {\r\n        activeOwnerlessStakeCount--;\r\n    }\r\n\r\n    function _increaseActiveBufferStakeCount()\r\n        internal\r\n    {\r\n        activeBufferStakeCount++;\r\n    }\r\n\r\n    function _decreaseActiveBufferStakeCount()\r\n        internal\r\n    {\r\n        activeBufferStakeCount--;\r\n    }\r\n\r\n    function _increaseOwnerlessStakeCount()\r\n        internal\r\n    {\r\n        ownerlessStakeCount++;\r\n    }\r\n\r\n    function _increaseBufferStakeCount()\r\n        internal\r\n    {\r\n        bufferStakeCount++;\r\n    }\r\n\r\n    function _increaseCollateralStakeCount()\r\n        internal\r\n    {\r\n        collateralStakeCount++;\r\n    }\r\n\r\n    function _decreaseCollateralStakeCount()\r\n        internal\r\n    {\r\n        collateralStakeCount--;\r\n    }\r\n\r\n    function _trackCollateralStake(\r\n        address _staker,\r\n        uint256 _stakeIndex\r\n    )\r\n        internal\r\n    {\r\n        bytes16 stakeID = insuranceStakes[_staker][_stakeIndex].stakeID;\r\n        collateralRules[stakeID].originalOwner = _staker;\r\n    }\r\n\r\n    function _liquidateStake(\r\n        bytes16 stakeID\r\n    )\r\n        internal\r\n    {\r\n        collateralRules[stakeID].isLiquidated = true;\r\n    }\r\n\r\n    function _returnOwnership(\r\n        address _staker,\r\n        uint256 _stakeIndex\r\n    )\r\n        internal\r\n    {\r\n        insuranceStakes[_staker][_stakeIndex].currentOwner = _staker;\r\n    }\r\n\r\n    function _trackOwnerlessStake(\r\n        address _originalOwner,\r\n        uint256 _stakeIndex\r\n    )\r\n        internal\r\n    {\r\n        ownerlessStakes[ownerlessStakeCount].stakeIndex = _stakeIndex;\r\n        ownerlessStakes[ownerlessStakeCount].originalOwner = _originalOwner;\r\n    }\r\n\r\n    function _increaseInsuranceStakeCounts(\r\n        address _staker\r\n    )\r\n        internal\r\n    {\r\n        insuranceStakeCount++;\r\n        insuranceStakeCounts[_staker]++;\r\n    }\r\n\r\n    function _increasePublicDebth(\r\n        uint256 _amount\r\n    )\r\n        internal\r\n    {\r\n        totalPublicDebth =\r\n        totalPublicDebth + _amount;\r\n    }\r\n\r\n    function _decreasePublicDebth(\r\n        uint256 _amount\r\n    )\r\n        internal\r\n    {\r\n        totalPublicDebth =\r\n        totalPublicDebth - _amount;\r\n    }\r\n\r\n    function _increasePublicReward(\r\n        address _contributor,\r\n        uint256 _amount\r\n    )\r\n        internal\r\n    {\r\n        publicReward[_contributor] =\r\n        publicReward[_contributor] + _amount;\r\n    }\r\n\r\n    function _decreasePublicReward(\r\n        address _contributor,\r\n        uint256 _amount\r\n    )\r\n        internal\r\n    {\r\n        publicReward[_contributor] =\r\n        publicReward[_contributor] - _amount;\r\n    }\r\n\r\n    function _increasePublicRewards(\r\n        uint256 _amount\r\n    )\r\n        internal\r\n    {\r\n        totalPublicRewards =\r\n        totalPublicRewards + _amount;\r\n    }\r\n\r\n    function _decreasePublicRewards(\r\n        uint256 _amount\r\n    )\r\n        internal\r\n    {\r\n        totalPublicRewards =\r\n        totalPublicRewards - _amount;\r\n    }\r\n\r\n    function _renounceStakeOwnership(\r\n        address _staker,\r\n        uint256 _stakeIndex\r\n    )\r\n        internal\r\n    {\r\n        insuranceStakes[_staker][_stakeIndex].currentOwner = ZERO_ADDRESS;\r\n    }\r\n\r\n    function _calculateEmergencyAmount(\r\n        uint256 _stakedAmount,\r\n        uint256 _principalCut\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 percent = 100 - _principalCut;\r\n        return _stakedAmount * percent / 100;\r\n    }\r\n\r\n    function _calculateMatureAmount(\r\n        uint256 _stakedAmount,\r\n        uint256 _bufferAmount,\r\n        uint256 _principalCut\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 percent = 100 - _principalCut;\r\n        return (_stakedAmount + _bufferAmount) * percent / 100;\r\n    }\r\n\r\n    function _deactivateStake(\r\n        address _staker,\r\n        uint256 _stakeIndex\r\n    )\r\n        internal\r\n    {\r\n        insuranceStakes[_staker][_stakeIndex].isActive = false;\r\n    }\r\n\r\n    function stakesPagination(\r\n        address _staker,\r\n        uint256 _offset,\r\n        uint256 _length\r\n    )\r\n        external\r\n        view\r\n        returns (bytes16[] memory _stakes)\r\n    {\r\n        uint256 start = _offset \u003e 0 \u0026\u0026\r\n            insuranceStakeCounts[_staker] \u003e _offset ?\r\n            insuranceStakeCounts[_staker] - _offset : insuranceStakeCounts[_staker];\r\n\r\n        uint256 finish = _length \u003e 0 \u0026\u0026\r\n            start \u003e _length ?\r\n            start - _length : 0;\r\n\r\n        uint256 i;\r\n\r\n        _stakes = new bytes16[](start - finish);\r\n\r\n        for (uint256 _stakeIndex = start; _stakeIndex \u003e finish; _stakeIndex--) {\r\n            bytes16 _stakeID = getStakeID(_staker, _stakeIndex - 1);\r\n            if (insuranceStakes[_staker][_stakeIndex - 1].stakedAmount \u003e 0) {\r\n                _stakes[i] = _stakeID; i++;\r\n            }\r\n        }\r\n    }\r\n\r\n    //  WISE INSURANCE (PUBLIC FUNCTIONS)  //\r\n    //  -------------------------------------\r\n\r\n    function getBufferAmount(\r\n        address _staker,\r\n        uint256 _stakeIndex\r\n\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return insuranceStakes[_staker][_stakeIndex].bufferAmount;\r\n    }\r\n\r\n    function getEmergencyAmount(\r\n        address _staker,\r\n        uint256 _stakeIndex\r\n\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return insuranceStakes[_staker][_stakeIndex].emergencyAmount;\r\n    }\r\n\r\n    function getMatureAmount(\r\n        address _staker,\r\n        uint256 _stakeIndex\r\n\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return insuranceStakes[_staker][_stakeIndex].matureAmount;\r\n    }\r\n\r\n    function getStakedAmount(\r\n        address _staker,\r\n        uint256 _stakeIndex\r\n\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return insuranceStakes[_staker][_stakeIndex].stakedAmount;\r\n    }\r\n\r\n    function getStakeData(\r\n        uint256 _ownerlessStakeIndex\r\n    )\r\n        public\r\n        view\r\n        returns (address, uint256)\r\n    {\r\n        return (\r\n            ownerlessStakes[_ownerlessStakeIndex].originalOwner,\r\n            ownerlessStakes[_ownerlessStakeIndex].stakeIndex\r\n        );\r\n    }\r\n\r\n    function checkActiveStake(\r\n        address _staker,\r\n        uint256 _stakeIndex\r\n    )\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return insuranceStakes[_staker][_stakeIndex].isActive;\r\n    }\r\n\r\n    function checkOwnership(\r\n        address _staker,\r\n        uint256 _stakeIndex\r\n    )\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return insuranceStakes[_staker][_stakeIndex].currentOwner == _staker;\r\n    }\r\n\r\n    function checkOwnerlessStake(\r\n        address _staker,\r\n        uint256 _stakeIndex\r\n    )\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return insuranceStakes[_staker][_stakeIndex].currentOwner == ZERO_ADDRESS;\r\n    }\r\n\r\n    function applyFee(\r\n        uint256 _totalReward,\r\n        uint256 _interestCut\r\n    )\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 percent = 100 - _interestCut;\r\n        return _totalReward * percent / 100;\r\n    }\r\n\r\n    function penaltyFee(\r\n        bytes16 stakeID,\r\n        uint256 _toReturn,\r\n        uint256 _matureLevel\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 penaltyPercent;\r\n\r\n        if (_matureLevel \u003c= penaltyRules[stakeID].penaltyThresholdB) {\r\n            penaltyPercent = penaltyRules[stakeID].penaltyB;\r\n        }\r\n\r\n        if (_matureLevel \u003c= penaltyRules[stakeID].penaltyThresholdA) {\r\n            penaltyPercent = penaltyRules[stakeID].penaltyA;\r\n        }\r\n\r\n        uint256 percent = 100 - penaltyPercent;\r\n        return _toReturn * percent / 100;\r\n    }\r\n\r\n    function checkMatureLevel(\r\n        address _staker,\r\n        bytes16 _stakeID\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n\r\n        (   uint256 startDay,\r\n            uint256 lockDays,\r\n            uint256 finalDay,\r\n            uint256 closeDay,\r\n            uint256 scrapeDay,\r\n            uint256 stakedAmount,\r\n            uint256 stakesShares,\r\n            uint256 rewardAmount,\r\n            uint256 penaltyAmount,\r\n            bool isActive,\r\n            bool isMature\r\n        ) = WISE_CONTRACT.checkStakeByID(\r\n            _staker,\r\n            _stakeID\r\n        );\r\n        if (isActive == isMature) {\r\n            startDay = closeDay + scrapeDay + stakedAmount + stakesShares + rewardAmount + rewardAmount + penaltyAmount;\r\n        }\r\n        return 100 - (_daysLeft(WISE_CONTRACT.currentWiseDay(), finalDay) * 100 / lockDays);\r\n    }\r\n\r\n    function _daysLeft(\r\n        uint256 _startDate,\r\n        uint256 _endDate\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return _startDate \u003e _endDate ? 0 : _endDate - _startDate;\r\n    }\r\n\r\n    function getStakeID(\r\n        address _staker,\r\n        uint256 _stakeIndex\r\n\r\n    )\r\n        public\r\n        view\r\n        returns (bytes16)\r\n    {\r\n        return insuranceStakes[_staker][_stakeIndex].stakeID;\r\n    }\r\n\r\n    //  WISE INSURANCE (EXTERNAL MASTER FUNCTIONS)  //\r\n    //  -------------------------------------\r\n\r\n    function enablePublicContribution()\r\n        external\r\n        onlyMaster\r\n    {\r\n        allowPublicContributions = true;\r\n        emit PublicContributionsOpened(true);\r\n    }\r\n\r\n    function disablePublicContribution()\r\n        external\r\n        onlyMaster\r\n    {\r\n        allowPublicContributions = false;\r\n        emit PublicContributionsOpened(false);\r\n    }\r\n\r\n    function enableCollateralization()\r\n        external\r\n        onlyMaster\r\n    {\r\n        allowCollaterization = true;\r\n    }\r\n\r\n    function disableCollateralization()\r\n        external\r\n        onlyMaster\r\n    {\r\n        allowCollaterization = false;\r\n    }\r\n\r\n    function switchBufferStakeInterest(\r\n        bool _asDeveloperFunds\r\n    )\r\n        external\r\n        onlyMaster\r\n    {\r\n        getBufferStakeInterest = _asDeveloperFunds;\r\n    }\r\n\r\n    bytes4 private constant TRANSFER = bytes4(\r\n        keccak256(\r\n            bytes(\r\n                \u0027transfer(address,uint256)\u0027\r\n            )\r\n        )\r\n    );\r\n\r\n    bytes4 private constant TRANSFER_FROM = bytes4(\r\n        keccak256(\r\n            bytes(\r\n                \u0027transferFrom(address,address,uint256)\u0027\r\n            )\r\n        )\r\n    );\r\n\r\n    function safeTransfer(\r\n        address _token,\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n        internal\r\n    {\r\n        (bool success, bytes memory data) = _token.call(\r\n            abi.encodeWithSelector(\r\n                TRANSFER,\r\n                _to,\r\n                _value\r\n            )\r\n        );\r\n\r\n        require(\r\n            success \u0026\u0026 (\r\n                data.length == 0 || abi.decode(\r\n                    data, (bool)\r\n                )\r\n            ),\r\n            TRANSFER_FAILED\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address _token,\r\n        address _from,\r\n        address _to,\r\n        uint _value\r\n    )\r\n        internal\r\n    {\r\n        (bool success, bytes memory data) = _token.call(\r\n            abi.encodeWithSelector(\r\n                TRANSFER_FROM,\r\n                _from,\r\n                _to,\r\n                _value\r\n            )\r\n        );\r\n\r\n        require(\r\n            success \u0026\u0026 (\r\n                data.length == 0 || abi.decode(\r\n                    data, (bool)\r\n                )\r\n            ),\r\n            TRANSFER_FAILED\r\n        );\r\n    }\r\n}\r\n"},"InsuranceInterface.sol":{"content":"// SPDX-License-Identifier: -- ? % ? --\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface WiseTokenInterface {\r\n\r\n    function currentWiseDay()\r\n        external view\r\n        returns (uint64);\r\n\r\n    function approve(\r\n        address _spender,\r\n        uint256 _value\r\n    )\r\n        external\r\n        returns (bool success);\r\n\r\n    function generateID(\r\n        address x,\r\n        uint256 y,\r\n        bytes1 z\r\n    )\r\n        external\r\n        pure\r\n        returns (bytes16 b);\r\n\r\n    function createStakeWithBNB(\r\n        uint64 _lockDays,\r\n        address _referrer\r\n    )\r\n        external\r\n        payable\r\n        returns (bytes16, uint256, bytes16 referralID);\r\n\r\n    function createStakeWithToken(\r\n        address _tokenAddress,\r\n        uint256 _tokenAmount,\r\n        uint64 _lockDays,\r\n        address _referrer\r\n    )\r\n        external\r\n        returns (bytes16, uint256, bytes16 referralID);\r\n\r\n    function createStake(\r\n        uint256 _stakedAmount,\r\n        uint64 _lockDays,\r\n        address _referrer\r\n    )\r\n        external\r\n        returns (bytes16, uint256, bytes16 referralID);\r\n\r\n    function endStake(\r\n        bytes16 _stakeID\r\n    )\r\n        external\r\n        returns (uint256);\r\n\r\n    function checkMatureStake(\r\n        address _staker,\r\n        bytes16 _stakeID\r\n    )\r\n        external\r\n        view\r\n        returns (bool isMature);\r\n\r\n    function balanceOf(\r\n        address account\r\n    ) external view returns (uint256);\r\n\r\n    function checkStakeByID(\r\n        address _staker,\r\n        bytes16 _stakeID\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint256 startDay,\r\n            uint256 lockDays,\r\n            uint256 finalDay,\r\n            uint256 closeDay,\r\n            uint256 scrapeDay,\r\n            uint256 stakedAmount,\r\n            uint256 stakesShares,\r\n            uint256 rewardAmount,\r\n            uint256 penaltyAmount,\r\n            bool isActive,\r\n            bool isMature\r\n        );\r\n}\r\n\r\ninterface PancakeRouterInterface {\r\n    function swapExactETHForTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (\r\n        uint[] memory amounts\r\n    );\r\n}\r\n"},"InsuranceWise.sol":{"content":"// SPDX-License-Identifier: -- ? % ? --\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \u0027./InsuranceHelper.sol\u0027;\r\n\r\ncontract InsuranceWise is InsuranceHelper {\r\n\r\n    constructor(\r\n        address _wiseToken,\r\n        address _sbnbToken,\r\n        address payable _masterAddress\r\n    ) InsuranceDeclaration(_wiseToken, _sbnbToken) {\r\n\r\n        // @co-author Vitally Marinchenko\r\n        // @co-author Christoph Krpoun\r\n        // @co-author René Hochmuth\r\n\r\n        insuranceMaster = _masterAddress;\r\n        insuranceWorker = _masterAddress;\r\n        insuranceWallet = _masterAddress;\r\n        insuranceHelper = _masterAddress;\r\n    }\r\n\r\n    function createStakeBulk(\r\n        uint256[] memory _stakedAmount,\r\n        uint64[] memory _lockDays,\r\n        address[] memory _referrer\r\n    )\r\n        external\r\n    {\r\n        for(uint256 i = 0; i \u003c _stakedAmount.length; i++) {\r\n            createStake(\r\n                _stakedAmount[i],\r\n                _lockDays[i],\r\n                _referrer[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    function createStakeWithBNB(\r\n        uint64 _lockDays,\r\n        address _referrer\r\n    )\r\n        external\r\n        payable\r\n    {\r\n        address[] memory path = new address[](3);\r\n            path[0] = WBNB;\r\n            path[1] = SBNB;\r\n            path[2] = WISE_TOKEN_ADDRESS;\r\n\r\n        uint256[] memory amounts =\r\n        PANCAKE_ROUTER.swapExactETHForTokens{\r\n            value: msg.value\r\n        }(\r\n            1,\r\n            path,\r\n            msg.sender,\r\n            block.timestamp + 2 hours\r\n        );\r\n\r\n        createStake(\r\n            amounts[2],\r\n            _lockDays,\r\n            _referrer\r\n        );\r\n    }\r\n\r\n    function createStake(\r\n        uint256 _stakedAmount,\r\n        uint64 _lockDays,\r\n        address _referrer\r\n    )\r\n        public\r\n    {\r\n        require(\r\n            _lockDays \u003c= MAX_STAKE_DAYS,\r\n            DECREASE_STAKE_DURATION\r\n        );\r\n\r\n        require(\r\n            allowInsurance == true,\r\n            INSURANCE_DISABLED\r\n        );\r\n\r\n        uint256 toStake =  _stakedAmount * stakePercent / 100;\r\n        uint256 toBuffer = _stakedAmount - toStake;\r\n\r\n        uint256 toReturn = _calculateEmergencyAmount(\r\n            toStake,\r\n            principalCut\r\n        );\r\n\r\n        uint256 matureReturn = _calculateMatureAmount(\r\n            toStake,\r\n            toBuffer,\r\n            principalCut\r\n        );\r\n\r\n        address staker = msg.sender;\r\n\r\n        safeTransferFrom(\r\n            WISE_TOKEN_ADDRESS,\r\n            staker,\r\n            address(this),\r\n            _stakedAmount\r\n        );\r\n\r\n        _increaseTotalStaked(\r\n            toStake\r\n        );\r\n\r\n        _increaseTotalCovers(\r\n            toReturn\r\n        );\r\n\r\n        require(\r\n            getCoveredPercent() \u003e= coverageThreshold,\r\n            BELOW_COVERAGE_THRESHOLD\r\n        );\r\n\r\n        (bytes16 stakeID, uint256 stakedAmount, bytes16 referralID) =\r\n\r\n        WISE_CONTRACT.createStake(\r\n            toStake,\r\n            _lockDays,\r\n            _referrer\r\n        );\r\n\r\n        uint256 stakeIndex = insuranceStakeCounts[staker];\r\n\r\n        insuranceStakes[staker][stakeIndex].stakeID = stakeID;\r\n        insuranceStakes[staker][stakeIndex].stakedAmount = toStake;\r\n        insuranceStakes[staker][stakeIndex].bufferAmount = toBuffer;\r\n        insuranceStakes[staker][stakeIndex].matureAmount = matureReturn;\r\n        insuranceStakes[staker][stakeIndex].emergencyAmount = toReturn;\r\n        insuranceStakes[staker][stakeIndex].currentOwner = staker;\r\n        insuranceStakes[staker][stakeIndex].isActive = true;\r\n\r\n        _increaseInsuranceStakeCounts(staker);\r\n        _increaseActiveInsuranceStakeCount();\r\n\r\n        emit InsurancStakeOpened(\r\n            stakeID,\r\n            stakedAmount,\r\n            toReturn,\r\n            staker,\r\n            stakeIndex,\r\n            referralID\r\n        );\r\n\r\n        penaltyRules[stakeID].penaltyThresholdA = penaltyThresholdA;\r\n        penaltyRules[stakeID].penaltyThresholdB = penaltyThresholdB;\r\n        penaltyRules[stakeID].penaltyA = penaltyA;\r\n        penaltyRules[stakeID].penaltyB = penaltyB;\r\n\r\n        emit PenaltyRulesAdded(\r\n            stakeID,\r\n            penaltyThresholdA,\r\n            penaltyThresholdB,\r\n            penaltyA,\r\n            penaltyB\r\n        );\r\n    }\r\n\r\n    function endStake(\r\n        uint256 _stakeIndex\r\n    )\r\n        external\r\n    {\r\n        address _staker = msg.sender;\r\n\r\n        if (checkMatureStake(\r\n            _staker,\r\n            _stakeIndex\r\n        ) == false) {\r\n\r\n            _emergencyExitStake(\r\n                _staker,\r\n                _stakeIndex\r\n            );\r\n\r\n        } else {\r\n\r\n            _endMatureStake(\r\n                _staker,\r\n                _stakeIndex\r\n            );\r\n        }\r\n    }\r\n\r\n    function _emergencyExitStake(\r\n        address _staker,\r\n        uint256 _stakeIndex\r\n    )\r\n        internal\r\n    {\r\n        require(\r\n            checkActiveStake(\r\n                _staker,\r\n                _stakeIndex\r\n            ) == true,\r\n            NOT_ACTIVE_STAKE\r\n        );\r\n\r\n        require(\r\n            checkOwnership(\r\n                _staker,\r\n                _stakeIndex\r\n            ) == true,\r\n            NOT_YOUR_STAKE\r\n        );\r\n\r\n        _renounceStakeOwnership(\r\n            _staker,\r\n            _stakeIndex\r\n        );\r\n\r\n        _trackOwnerlessStake(\r\n            _staker,\r\n            _stakeIndex\r\n        );\r\n\r\n        emit NewOwnerlessStake (\r\n            ownerlessStakeCount,\r\n            _stakeIndex,\r\n            _staker\r\n        );\r\n\r\n        _increaseOwnerlessStakeCount();\r\n        _increaseActiveOwnerlessStakeCount();\r\n\r\n        uint256 toReturn = getEmergencyAmount(\r\n            _staker,\r\n            _stakeIndex\r\n        );\r\n\r\n        bytes16 stakeID = getStakeID(\r\n            _staker,\r\n            _stakeIndex\r\n        );\r\n\r\n        uint256 matureLevel = checkMatureLevel(\r\n            address(this),\r\n            stakeID\r\n        );\r\n\r\n        uint256 amountAfterFee = penaltyFee(\r\n            stakeID,\r\n            toReturn,\r\n            matureLevel\r\n        );\r\n\r\n        safeTransfer(\r\n            WISE_TOKEN_ADDRESS,\r\n            _staker,\r\n            amountAfterFee\r\n        );\r\n\r\n        _increaseTotalMasterProfits(\r\n            toReturn - amountAfterFee\r\n        );\r\n\r\n        _decreaseTotalCovers(\r\n            toReturn\r\n        );\r\n\r\n        emit EmergencyExitStake(\r\n            _staker,\r\n            _stakeIndex,\r\n            stakeID,\r\n            amountAfterFee,\r\n            toReturn,\r\n            WISE_CONTRACT.currentWiseDay()\r\n        );\r\n    }\r\n\r\n    function endMatureStake(\r\n        address _staker,\r\n        uint256 _stakeIndex\r\n    )\r\n        external\r\n        onlyWorker\r\n    {\r\n        _endMatureStake(\r\n            _staker,\r\n            _stakeIndex\r\n        );\r\n    }\r\n\r\n    function _endMatureStake(\r\n        address _staker,\r\n        uint256 _stakeIndex\r\n    )\r\n        internal\r\n    {\r\n        require(\r\n            checkOwnership(\r\n                _staker,\r\n                _stakeIndex\r\n            ) == true,\r\n            NOT_YOUR_STAKE\r\n        );\r\n\r\n        require(\r\n            checkMatureStake(\r\n                _staker,\r\n                _stakeIndex\r\n            ) == true,\r\n            NOT_MATURE_STAKE\r\n        );\r\n\r\n        require(\r\n            checkActiveStake(\r\n                _staker,\r\n                _stakeIndex\r\n            ) == true,\r\n            NOT_ACTIVE_STAKE\r\n        );\r\n\r\n        _deactivateStake(\r\n            _staker,\r\n            _stakeIndex\r\n        );\r\n\r\n        _decreaseActiveInsuranceStakeCount();\r\n\r\n        bytes16 stakeID = getStakeID(\r\n            _staker,\r\n            _stakeIndex\r\n        );\r\n\r\n        uint256 totalReward = WISE_CONTRACT.endStake(\r\n            stakeID\r\n        );\r\n\r\n        uint256 stakedAmount = getStakedAmount(\r\n            _staker,\r\n            _stakeIndex\r\n        );\r\n\r\n        uint256 returnAmount = getMatureAmount(\r\n            _staker,\r\n            _stakeIndex\r\n        );\r\n\r\n        uint256 emergencyAmount = getEmergencyAmount(\r\n            _staker,\r\n            _stakeIndex\r\n        );\r\n\r\n        safeTransfer(\r\n            WISE_TOKEN_ADDRESS,\r\n            _staker,\r\n            returnAmount\r\n        );\r\n\r\n        uint256 rewardAfterFee = applyFee(\r\n            totalReward,\r\n            interestCut\r\n        );\r\n\r\n        safeTransfer(\r\n            WISE_TOKEN_ADDRESS,\r\n            _staker,\r\n            rewardAfterFee\r\n        );\r\n\r\n        _increaseTotalMasterProfits(\r\n            stakedAmount \u003e returnAmount ?\r\n            stakedAmount - returnAmount : 0\r\n        );\r\n\r\n        _increaseTotalMasterProfits(\r\n            totalReward - rewardAfterFee\r\n        );\r\n\r\n        _decreaseTotalStaked(\r\n            stakedAmount\r\n        );\r\n\r\n        _decreaseTotalCovers(\r\n            emergencyAmount\r\n        );\r\n\r\n        emit InsuranceStakeClosed(\r\n            _staker,\r\n            _stakeIndex,\r\n            stakeID,\r\n            returnAmount,\r\n            rewardAfterFee\r\n        );\r\n    }\r\n\r\n    function endOwnerlessStake(\r\n        uint256 _ownerlessStakeIndex\r\n    )\r\n        external\r\n        onlyWorker\r\n    {\r\n        (address staker, uint256 stakeIndex) =\r\n        getStakeData(_ownerlessStakeIndex);\r\n\r\n        require(\r\n            checkOwnerlessStake(\r\n                staker,\r\n                stakeIndex\r\n            ) == true,\r\n            NOT_OWNERLESS_STAKE\r\n        );\r\n\r\n        require(\r\n            checkMatureStake(\r\n                staker,\r\n                stakeIndex\r\n            ) == true,\r\n            NOT_MATURE_STAKE\r\n        );\r\n\r\n        require(\r\n            checkActiveStake(\r\n                staker,\r\n                stakeIndex\r\n            ) == true,\r\n            NOT_ACTIVE_STAKE\r\n        );\r\n\r\n        _deactivateStake(\r\n            staker,\r\n            stakeIndex\r\n        );\r\n\r\n        _decreaseActiveInsuranceStakeCount();\r\n        _decreaseActiveOwnerlessStakeCount();\r\n\r\n        bytes16 stakeID = getStakeID(\r\n            staker,\r\n            stakeIndex\r\n        );\r\n\r\n        uint256 totalReward = WISE_CONTRACT.endStake(\r\n            stakeID\r\n        );\r\n\r\n        uint256 stakedAmount = getStakedAmount(\r\n            staker,\r\n            stakeIndex\r\n        );\r\n\r\n        uint256 emergencyAmount = getEmergencyAmount(\r\n            staker,\r\n            stakeIndex\r\n        );\r\n\r\n        uint256 bufferAmount = getBufferAmount(\r\n            staker,\r\n            stakeIndex\r\n        );\r\n\r\n        _increaseTotalMasterProfits(\r\n            totalReward\r\n        );\r\n\r\n        _increaseTotalMasterProfits(\r\n            stakedAmount - emergencyAmount + bufferAmount\r\n        );\r\n\r\n        _decreaseTotalStaked(\r\n            stakedAmount\r\n        );\r\n\r\n        emit OwnerlessStakeClosed (\r\n            _ownerlessStakeIndex,\r\n            staker,\r\n            stakeIndex,\r\n            stakeID,\r\n            stakedAmount,\r\n            totalReward\r\n        );\r\n    }\r\n\r\n    function collaterizeStake(\r\n        uint256 _stakeIndex\r\n    )\r\n        external\r\n    {\r\n        require(\r\n            allowCollaterization == true,\r\n            COLLATERIZATION_NOT_ALLOWED_YET\r\n        );\r\n\r\n        address _staker = msg.sender;\r\n\r\n        require(\r\n            checkOwnership(\r\n                _staker,\r\n                _stakeIndex\r\n            ) == true,\r\n            NOT_YOUR_STAKE\r\n        );\r\n\r\n        _renounceStakeOwnership(\r\n            _staker,\r\n            _stakeIndex\r\n        );\r\n\r\n        _trackCollateralStake(\r\n            _staker,\r\n            _stakeIndex\r\n        );\r\n\r\n        _increaseCollateralStakeCount();\r\n\r\n        emit CollateralCreation(\r\n            _staker,\r\n            _stakeIndex\r\n        );\r\n    }\r\n\r\n    function liquidateStake(\r\n        address _staker,\r\n        uint256 _stakeIndex\r\n    )\r\n        external\r\n        onlyHelper\r\n    {\r\n        bytes16 stakeID = getStakeID(\r\n            _staker,\r\n            _stakeIndex\r\n        );\r\n\r\n        _liquidateStake(\r\n            stakeID\r\n        );\r\n\r\n        _decreaseCollateralStakeCount();\r\n\r\n        emit StakeLiquidation(\r\n            _staker,\r\n            _stakeIndex\r\n        );\r\n\r\n        _trackOwnerlessStake(\r\n            _staker,\r\n            _stakeIndex\r\n        );\r\n\r\n        _increaseOwnerlessStakeCount();\r\n        _increaseActiveOwnerlessStakeCount();\r\n\r\n        emit NewOwnerlessStake (\r\n            ownerlessStakeCount,\r\n            _stakeIndex,\r\n            _staker\r\n        );\r\n    }\r\n\r\n    function returnOwnership(\r\n        address _staker,\r\n        uint256 _stakeIndex\r\n    )\r\n        external\r\n        onlyHelper\r\n    {\r\n        require(\r\n            checkOwnerlessStake(\r\n                _staker,\r\n                _stakeIndex\r\n            ) == true,\r\n            NOT_OWNERLESS_STAKE\r\n        );\r\n\r\n        bytes16 stakeID = getStakeID(\r\n            _staker,\r\n            _stakeIndex\r\n        );\r\n\r\n        require(\r\n            collateralRules[stakeID].isLiquidated == false,\r\n            STAKE_ALREADY_LIQUIDATED\r\n        );\r\n\r\n        address originalOwner =\r\n        collateralRules[stakeID].originalOwner;\r\n\r\n        require(\r\n            _staker == originalOwner,\r\n            INVALID_ORIGINAL_OWNER\r\n        );\r\n\r\n        _returnOwnership(\r\n            _staker,\r\n            _stakeIndex\r\n        );\r\n\r\n        _decreaseCollateralStakeCount();\r\n\r\n        emit StakeReturned(\r\n            _staker,\r\n            _stakeIndex\r\n        );\r\n    }\r\n\r\n    function contributeAsPublic(\r\n        uint256 _amount\r\n    )\r\n        external\r\n    {\r\n        address contributor = msg.sender;\r\n\r\n        require(\r\n            allowPublicContributions == true,\r\n            PUBLIC_CONTRIBUTIONS_DISABLED\r\n        );\r\n\r\n        safeTransferFrom(\r\n            WISE_TOKEN_ADDRESS,\r\n            contributor,\r\n            address(this),\r\n            _amount\r\n        );\r\n\r\n        uint256 percent = 100 + publicRewardPercent;\r\n        uint256 toReturn = _amount * percent / 100;\r\n\r\n        _increasePublicReward(\r\n            contributor,\r\n            toReturn\r\n        );\r\n\r\n        _increasePublicDebth(\r\n            toReturn\r\n        );\r\n\r\n        require(\r\n            totalPublicDebth \u003c= publicDebthCap,\r\n            EXCEEDING_PUBLIC_DEBTH_CAP\r\n        );\r\n\r\n        emit TreasuryFunded(\r\n            _amount,\r\n            contributor,\r\n            getCurrentBuffer()\r\n        );\r\n    }\r\n\r\n    function takePublicProfits()\r\n        external\r\n    {\r\n        issuePublicProfits(\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    function issuePublicProfits(\r\n        address _contributor\r\n    )\r\n        public\r\n    {\r\n        require(\r\n            publicReward[_contributor] \u003e 0,\r\n            NO_REWARD_FOR_CONTRIBUTOR\r\n        );\r\n\r\n        require(\r\n            totalPublicDebth \u003e 0,\r\n            NO_PUBLIC_DEBTH\r\n        );\r\n\r\n        require(\r\n            totalPublicRewards \u003e 0,\r\n            NO_PUBLIC_REWARD_AVAILABLE\r\n        );\r\n\r\n        uint256 amount = publicReward[_contributor];\r\n\r\n        _decreasePublicDebth(\r\n            amount\r\n        );\r\n\r\n        _decreasePublicRewards(\r\n            amount\r\n        );\r\n\r\n        _decreasePublicReward(\r\n            _contributor,\r\n            amount\r\n        );\r\n\r\n        safeTransfer(\r\n            WISE_TOKEN_ADDRESS,\r\n            _contributor,\r\n            amount\r\n        );\r\n\r\n        emit PublicProfit(\r\n            _contributor,\r\n            amount,\r\n            totalPublicDebth,\r\n            totalPublicRewards\r\n        );\r\n    }\r\n\r\n    function givePublicRewards(\r\n        uint256 _amount\r\n    )\r\n        external\r\n        onlyMaster\r\n    {\r\n        _decreaseTotalMasterProfits(\r\n            _amount\r\n        );\r\n\r\n        _increasePublicRewards(\r\n            _amount\r\n        );\r\n\r\n        require(\r\n            totalPublicRewards \u003c= totalPublicDebth\r\n        );\r\n\r\n        require(\r\n            getCoveredPercent(totalPublicRewards) \u003e= payoutThreshold,\r\n            BELOW_PAYOUT_THRESHOLD\r\n        );\r\n\r\n        require(\r\n            allowPublicContributions == false,\r\n            PUBLIC_CONTRIBUTION_MUST_BE_DISABLED\r\n        );\r\n\r\n        emit publicRewardsGiven(\r\n            _amount,\r\n            totalPublicDebth,\r\n            totalPublicRewards\r\n        );\r\n    }\r\n\r\n    function takeMasterProfits(\r\n        uint256 _amount\r\n    )\r\n        external\r\n        onlyMaster\r\n    {\r\n        require(\r\n            totalPublicDebth == 0,\r\n            PUBLIC_DEBTH_NOT_PAID\r\n        );\r\n\r\n        safeTransfer(\r\n            WISE_TOKEN_ADDRESS,\r\n            insuranceWallet,\r\n            _amount\r\n        );\r\n\r\n        if (activeInsuranceStakeCount \u003e 0) {\r\n            require(\r\n                _amount \u003c= totalMasterProfits\r\n            );\r\n        }\r\n\r\n        _decreaseTotalMasterProfits(\r\n            _amount\r\n        );\r\n\r\n        require(\r\n            getCoveredPercent() \u003e= payoutThreshold,\r\n            BELOW_PAYOUT_THRESHOLD\r\n        );\r\n\r\n        emit ProfitsTaken(\r\n            _amount,\r\n            getCurrentBuffer()\r\n        );\r\n    }\r\n\r\n    function openBufferStake(\r\n        uint256 _amount,\r\n        uint64 _duration,\r\n        address _referrer\r\n    )\r\n        external\r\n        onlyWorker\r\n    {\r\n        require(\r\n            _duration \u003c= maximumBufferStakeDuration\r\n        );\r\n\r\n        (bytes16 stakeID, uint256 stakedAmount, bytes16 referralID) =\r\n\r\n        WISE_CONTRACT.createStake(\r\n            _amount,\r\n            _duration,\r\n            _referrer\r\n        );\r\n\r\n        bufferStakes[bufferStakeCount].stakedAmount = _amount;\r\n        bufferStakes[bufferStakeCount].stakeID = stakeID;\r\n        bufferStakes[bufferStakeCount].isActive = true;\r\n\r\n        _increaseTotalBufferStaked(\r\n            _amount\r\n        );\r\n\r\n        require(\r\n            totalBufferStaked \u003c= bufferStakeCap\r\n        );\r\n\r\n        require(\r\n            getCoveredPercent() \u003e= coverageThreshold\r\n        );\r\n\r\n        _increaseBufferStakeCount();\r\n        _increaseActiveBufferStakeCount();\r\n\r\n        emit BufferStakeOpened(\r\n            stakeID,\r\n            stakedAmount,\r\n            referralID\r\n        );\r\n    }\r\n\r\n    function closeBufferStake(\r\n        uint256 _stakeIndex\r\n    )\r\n        external\r\n        onlyWorker\r\n    {\r\n        require(\r\n            bufferStakes[_stakeIndex].isActive,\r\n            NOT_ACTIVE_STAKE\r\n        );\r\n\r\n        bufferStakes[_stakeIndex].isActive = false;\r\n\r\n        bytes16 stakeID = bufferStakes[_stakeIndex].stakeID;\r\n\r\n        require(\r\n            checkMatureStake(stakeID) == true,\r\n            NOT_MATURE_STAKE\r\n        );\r\n\r\n        uint256 reward = WISE_CONTRACT.endStake(\r\n            stakeID\r\n        );\r\n\r\n        uint256 staked = bufferStakes[_stakeIndex].stakedAmount;\r\n\r\n        if (getBufferStakeInterest) {\r\n            _withdrawDeveloperFunds(reward);\r\n        } else {\r\n            _increaseTotalMasterProfits(reward);\r\n        }\r\n\r\n        _decreaseTotalBufferStaked(\r\n            staked\r\n        );\r\n\r\n        _decreaseActiveBufferStakeCount();\r\n\r\n        emit BufferStakeClosed(\r\n            stakeID,\r\n            staked,\r\n            reward\r\n        );\r\n    }\r\n\r\n    function enableInsurance()\r\n        external\r\n        onlyMaster\r\n    {\r\n        allowInsurance = true;\r\n    }\r\n\r\n    function disableInsurance()\r\n        external\r\n        onlyMaster\r\n    {\r\n        allowInsurance = false;\r\n    }\r\n\r\n    /**\r\n     * @notice ability to change worker address\r\n     * @dev this address is used as helper\r\n     * @param _newInsuranceWorker address new worker\r\n     */\r\n    function changeInsuranceWorker(\r\n        address payable _newInsuranceWorker\r\n    )\r\n        external\r\n        onlyMaster\r\n    {\r\n        insuranceWorker = _newInsuranceWorker;\r\n    }\r\n\r\n    /**\r\n     * @notice ability for master to increase or decrease\r\n     * percentage of the principal that gets staked\r\n     * @param _newStakePercent in range between 85-100%\r\n     */\r\n    function changeStakePercent(\r\n        uint256 _newStakePercent\r\n    )\r\n        external\r\n        onlyMaster\r\n    {\r\n        require(\r\n            _newStakePercent \u003e= 85 \u0026\u0026\r\n            _newStakePercent \u003c= 100\r\n        );\r\n\r\n        stakePercent = _newStakePercent;\r\n    }\r\n\r\n    /**\r\n     * @notice ability for master to increase or decrease\r\n     * percentage of the interest that gets as fee\r\n     * @param _newInterestCut in range between 0-10%\r\n     */\r\n    function changeInterestCut(\r\n        uint256 _newInterestCut\r\n    )\r\n        external\r\n        onlyMaster\r\n    {\r\n        require(\r\n            _newInterestCut \u003e= 0 \u0026\u0026\r\n            _newInterestCut \u003c= 10\r\n        );\r\n\r\n        interestCut = _newInterestCut;\r\n    }\r\n\r\n    /**\r\n     * @notice ability for master to increase or decrease\r\n     * percentage of the interest that gets as fee\r\n     * @param _newPrincipalCut in range between 0-10%\r\n     */\r\n    function changePrincipalCut(\r\n        uint256 _newPrincipalCut\r\n    )\r\n        external\r\n        onlyMaster\r\n    {\r\n        require(\r\n            _newPrincipalCut \u003e= 0 \u0026\u0026\r\n            _newPrincipalCut \u003c= 10\r\n        );\r\n\r\n        principalCut = _newPrincipalCut;\r\n    }\r\n\r\n    /**\r\n     * @notice ability for master to increase or decrease\r\n     * percentage of the interest that gets as fee\r\n     * @param _newPublicRewardPercent in range between 0-50%\r\n     */\r\n    function changePublicRewardPercent(\r\n        uint256 _newPublicRewardPercent\r\n    )\r\n        external\r\n        onlyMaster\r\n    {\r\n        require(\r\n            _newPublicRewardPercent \u003e= 0 \u0026\u0026\r\n            _newPublicRewardPercent \u003c= 50\r\n        );\r\n\r\n        publicRewardPercent = _newPublicRewardPercent;\r\n    }\r\n\r\n    function changePublicDebthCap(\r\n        uint256 _newPublicDebthCap\r\n    )\r\n        external\r\n        onlyMaster\r\n    {\r\n        publicDebthCap = _newPublicDebthCap;\r\n    }\r\n\r\n    function changeMaximumBufferStakeDuration(\r\n        uint256 _newMaximumBufferStakeDuration\r\n    )\r\n        external\r\n        onlyMaster\r\n    {\r\n        maximumBufferStakeDuration = _newMaximumBufferStakeDuration;\r\n    }\r\n\r\n    function changeBufferStakeCap(\r\n        uint256 _newBufferStakeCap\r\n    )\r\n        external\r\n        onlyMaster\r\n    {\r\n        bufferStakeCap = _newBufferStakeCap;\r\n    }\r\n\r\n    function changePenaltyThresholds(\r\n        uint256 _newPenaltyThresholdA,\r\n        uint256 _newPenaltyThresholdB,\r\n        uint256 _newPenaltyA,\r\n        uint256 _newPenaltyB\r\n    )\r\n        external\r\n        onlyMaster\r\n    {\r\n        require(\r\n            _newPenaltyB \u003c= _newPenaltyA \u0026\u0026\r\n            _newPenaltyThresholdA \u003c= _newPenaltyThresholdB\r\n        );\r\n\r\n        require(\r\n            _newPenaltyA \u003c= 100 \u0026\u0026\r\n            _newPenaltyThresholdB \u003c= 100\r\n        );\r\n\r\n        penaltyThresholdA = _newPenaltyThresholdA;\r\n        penaltyThresholdB = _newPenaltyThresholdB;\r\n\r\n        penaltyA = _newPenaltyA;\r\n        penaltyB = _newPenaltyB;\r\n    }\r\n\r\n    /**\r\n     * @notice ability for master to increase or decrease\r\n     * coverage percent for taking profits from the contract\r\n     * @param _newPayoutThreshold percent that needs to be covered\r\n     */\r\n    function changePayoutThreshold(\r\n        uint256 _newPayoutThreshold\r\n    )\r\n        external\r\n        onlyMaster\r\n    {\r\n        require(\r\n            _newPayoutThreshold \u003e= coverageThreshold \u0026\u0026\r\n            _newPayoutThreshold \u003c= 100\r\n        );\r\n\r\n        payoutThreshold = _newPayoutThreshold;\r\n    }\r\n\r\n    function changeCoverageThreshold(\r\n        uint256 _newCoverageThreshold\r\n    )\r\n        external\r\n        onlyMaster\r\n    {\r\n        coverageThreshold = _newCoverageThreshold;\r\n    }\r\n\r\n    function getCurrentBuffer()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return WISE_CONTRACT.balanceOf(\r\n            address(this)\r\n        );\r\n    }\r\n\r\n    function getCoveredPercent()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n\t\treturn totalCovers == 0 ? 100 : getCurrentBuffer() * 100 / totalCovers;\r\n\t}\r\n\r\n    function getCoveredPercent(uint256 _amount)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n\t\treturn totalCovers == 0 ? 100 : (getCurrentBuffer() - _amount) * 100 / totalCovers;\r\n\t}\r\n\r\n    /**\r\n     * @notice ability to check if stake opened\r\n     * as insurance stake from contracts perspective\r\n     * has now matured or not inside base layer\r\n     * @param _stakeID percent regular stakeID\r\n     */\r\n    function checkMatureStake(\r\n        bytes16 _stakeID\r\n    )\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return WISE_CONTRACT.checkMatureStake(\r\n            address(this),\r\n            _stakeID\r\n        );\r\n    }\r\n\r\n    function canStake()\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        return getCoveredPercent() \u003e= coverageThreshold;\r\n    }\r\n\r\n    /**\r\n     * @notice ability to check if stake opened\r\n     * as insurance stake from contracts perspective\r\n     * has now matured or not inside base layer\r\n     * @param _stakeOwner original owner\r\n     * @param _stakeIndex index of the stake\r\n     */\r\n    function checkMatureStake(\r\n        address _stakeOwner,\r\n        uint256 _stakeIndex\r\n    )\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return WISE_CONTRACT.checkMatureStake(\r\n            address(this),\r\n            insuranceStakes[_stakeOwner][_stakeIndex].stakeID\r\n        );\r\n    }\r\n\r\n    function _withdrawDeveloperFunds(\r\n        uint256 _amount\r\n    )\r\n        internal\r\n    {\r\n        safeTransfer(\r\n            WISE_TOKEN_ADDRESS,\r\n            insuranceMaster,\r\n            _amount\r\n        );\r\n\r\n        emit DeveloperFundsRouted(\r\n            _amount\r\n        );\r\n    }\r\n\r\n    function withdrawOriginalFunds()\r\n        external\r\n        onlyMaster\r\n    {\r\n        uint256 amount = teamContribution;\r\n        teamContribution = 0;\r\n        safeTransfer(\r\n            WISE_TOKEN_ADDRESS,\r\n            insuranceMaster,\r\n            amount\r\n        );\r\n    }\r\n\r\n    function fundTreasury(\r\n        uint256 _amount\r\n    )\r\n        external\r\n        onlyMaster\r\n    {\r\n        teamContribution =\r\n        teamContribution + _amount;\r\n\r\n        safeTransferFrom(\r\n            WISE_TOKEN_ADDRESS,\r\n            insuranceWallet,\r\n            address(this),\r\n            _amount\r\n        );\r\n    }\r\n\r\n    function saveTokens(\r\n        address _tokenAddress,\r\n        uint256 _tokenAmount\r\n    )\r\n        external\r\n    {\r\n        require(\r\n            _tokenAddress != WISE_TOKEN_ADDRESS\r\n        );\r\n\r\n        safeTransfer(\r\n            _tokenAddress,\r\n            insuranceMaster,\r\n            _tokenAmount\r\n        );\r\n    }\r\n}\r\n"}}