{"invite.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.8;\n\nimport \"./SafeMath.sol\";\nimport \u0027./Ownable.sol\u0027;\n\n\ncontract Invitation is Ownable {\n    using SafeMath for uint256;\n    struct user {\n        uint256 id;\n        uint256 level;\n        uint256 burn;\n        address referrer;\n    }\n\n    uint256 public userCount;\n    address public primaryAddr = 0x3B642FcEf89E3E8552A5Cd89f61d400Af30642DF;\n\n    mapping(address =\u003e uint256) public overrewards;\n\n    address public factory;\n    address public dead = 0x000000000000000000000000000000000000dEaD;\n\n    mapping(address =\u003e user) public Users;\n    mapping(uint256 =\u003e address) public index2User;\n    mapping (address =\u003e bool) public buyAddress;\n\n    event Register(address indexed _userAddr, address indexed _referrer);\n  \n    constructor() public {\n        userCount = userCount.add(1);\n        Users[primaryAddr].id = userCount;\n        index2User[userCount] = primaryAddr;\n\n\n        emit Register(primaryAddr, address(0));\n    }\n\n\n\n    function register(address _referrer) public {\n        require(!isExists(msg.sender), \"user exists\");\n        require(isExists(_referrer), \"referrer not exists\");\n        user storage regUser = Users[msg.sender];\n        userCount = userCount.add(1);\n        regUser.id = userCount;\n        index2User[userCount] = msg.sender;\n        regUser.referrer = _referrer;\n\n        emit Register(msg.sender, _referrer);\n    }\n\n\n    function isExists(address _userAddr) view public returns (bool) {\n        return Users[_userAddr].id != 0;\n    }\n\n\n    function getUserLevel(address _userAddr) public view returns (uint256 level)\n    {\n        return Users[_userAddr].level;\n    }\n\n    function setUserlevel(address _userAddr, uint256 _level) public onlyRewards{\n        Users[_userAddr].level = _level;\n    }\n\n    function setBuyAddress(address _userAddr) public onlyRewards{\n        buyAddress[_userAddr] = true ;\n    }\n\n    function getBuyAddress(address _userAddr) public view returns (bool b)\n    {\n        return buyAddress[_userAddr];\n    }\n\n    function getUserRefer(address _userAddr) public view returns (address refer){\n        return Users[_userAddr].referrer;\n    }\n\n    function setOverRewards(address _userAddr, uint256 _rewards) public onlyRewards{\n        overrewards[_userAddr] = _rewards; \n    }\n\n    function getOverRewards(address _userAddr) public view returns(uint256) {\n        return overrewards[_userAddr]; \n    }\n\n    mapping (address =\u003e bool) public rewardAddress;\n\n    function addRewardAddress (address _user) public onlyOwner {\n        rewardAddress[_user] = true;\n    }\n\n    function removeRewardAddress (address _clearedUser) public onlyOwner {\n        rewardAddress[_clearedUser] = false;\n    }\n\n    function isRewardAddress (address _user) public view returns(bool) {\n        return rewardAddress[_user];\n    }\n\n    modifier onlyRewards() {\n        require(isRewardAddress(msg.sender), \"caller is not the allowed\");\n        _;\n    }\n\n\n    \n}\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.8;\n\n\ncontract OwnableData {\n    address public owner;\n    address public pendingOwner;\n}\n\n\ncontract Ownable is OwnableData {\n   \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor () public {\n        owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n  \n    function transferOwnership(address newOwner, bool direct, bool renounce) public onlyOwner {\n        if (direct) {\n            // Checks\n            require(newOwner != address(0) || renounce, \"Ownable: zero address\");\n\n            // Effects\n            emit OwnershipTransferred(owner, newOwner);\n            owner = newOwner;\n            pendingOwner = address(0);\n        } else {\n            // Effects\n            pendingOwner = newOwner;\n        }\n    }\n\n\n    function claimOwnership() public {\n        address _pendingOwner = pendingOwner;\n        require(msg.sender == _pendingOwner, \"Ownable: caller != pending owner\");\n        emit OwnershipTransferred(owner, _pendingOwner);\n        owner = _pendingOwner;\n        pendingOwner = address(0);\n    }\n\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\n        _;\n    }\n}"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.8;\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"}}