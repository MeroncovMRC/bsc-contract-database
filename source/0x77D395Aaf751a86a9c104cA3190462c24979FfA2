{"DateTime.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.12;\n\nimport \"./SLDCommon.sol\";\n\nlibrary DateTime {\n    using SafeMath for uint256;\n\n    uint256 constant DAY_IN_SECONDS = 86400;\n    uint256 constant HOUR_IN_SECONDS = 3600;\n    uint256 constant HOUR_IN_DAY = 24;\n    uint256 constant DAYS_OF_YEAR = 365;\n\n    function getInPeriodHours(uint256 _period) internal pure returns (uint256) {\n        return HOUR_IN_DAY.div(_period);\n    }\n\n    function getInPeriodDayIndex(uint256 _hours)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (_hours \u003e= HOUR_IN_DAY * DAYS_OF_YEAR) {\n            return 364;\n        }\n\n        return _hours.div(HOUR_IN_DAY);\n    }\n\n    function regulateTime(uint256 _timestamp, uint256 _period)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 period = DAY_IN_SECONDS.div(_period);\n        uint256 remainder = _timestamp.mod(period);\n\n        return _timestamp.sub(remainder);\n    }\n\n    function regulateTimeAfter(uint256 _timestamp, uint256 _period)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 period = DAY_IN_SECONDS.div(_period);\n        uint256 remainder = _timestamp.mod(period);\n\n        return _timestamp.sub(remainder).add(period);\n    }\n\n    function getIntervalPeriods(\n        uint256 _startTime,\n        uint256 _endTime,\n        uint256 _period\n    )\n        internal\n        pure\n        returns (uint256 _intervalPeriods, uint256 _intervalPeriodsInHours)\n    {\n        uint256 period = DAY_IN_SECONDS.div(_period);\n        if (_endTime.add(period) \u003e= regulateTime(_startTime, _period)) {\n            _intervalPeriods = _endTime\n                .add(period)\n                .sub(regulateTime(_startTime, _period))\n                .div(period);\n            _intervalPeriodsInHours = regulateTimeAfter(_endTime, _period)\n                .sub(_startTime)\n                .div(HOUR_IN_SECONDS);\n        }\n    }\n}\n"},"SLDCommon.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IBEP20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    //function decimals() external returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            size := extcodesize(account)\n        }\n        return size \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\u0027s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(\n            address(this).balance \u003e= amount,\n            \"Address: insufficient balance\"\n        );\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(\n            success,\n            \"Address: unable to send value, recipient may have reverted\"\n        );\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                \"Address: low-level call with value failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(\n            address(this).balance \u003e= value,\n            \"Address: insufficient balance for call\"\n        );\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 weiValue,\n        string memory errorMessage\n    ) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(\n            data\n        );\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\nlibrary SafeBEP20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(\n        IBEP20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transfer.selector, to, value)\n        );\n    }\n\n    function safeTransferFrom(\n        IBEP20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n        );\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IBEP20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \u0027safeIncreaseAllowance\u0027 and \u0027safeDecreaseAllowance\u0027\n        // solhint-disable-next-line max-line-length\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.approve.selector, spender, value)\n        );\n    }\n\n    function _callOptionalReturn(IBEP20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\u0027s return data size checking mechanism, since\n        // we\u0027re implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(\n            data,\n            \"SafeERC20: low-level call failed\"\n        );\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(\n                abi.decode(returndata, (bool)),\n                \"SafeERC20: ERC20 operation did not succeed\"\n            );\n        }\n    }\n}\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn\u0027t required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract BEP20 is Context, IBEP20 {\n    using SafeMath for uint256;\n\n    mapping(address =\u003e uint256) private _balances;\n\n    mapping(address =\u003e mapping(address =\u003e uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``\u0027s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(\n            sender,\n            _msgSender(),\n            _allowances[sender][_msgSender()].sub(\n                amount,\n                \"ERC20: transfer amount exceeds allowance\"\n            )\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender].add(addedValue)\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender].sub(\n                subtractedValue,\n                \"ERC20: decreased allowance below zero\"\n            )\n        );\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(\n            amount,\n            \"ERC20: transfer amount exceeds balance\"\n        );\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(\n            amount,\n            \"ERC20: burn amount exceeds balance\"\n        );\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\u0027s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\u0027s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"},"SLDInterfaces.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\nimport \"./SLDCommon.sol\";\n\ninterface ISLDCommon {\n    enum ContractType {\n        INVALID,\n        LONG,\n        SHORT\n    }\n    enum StableCoinType {\n        INVALID,\n        DAI,\n        USDT,\n        USDC\n    }\n    enum PoolFlag {\n        INVALID,\n        PUBLIC,\n        PRIVATE\n    }\n}\n\ninterface ISLDContract is ISLDCommon {\n    event SLDDeposit(\n        address indexed sender,\n        address indexed toAddr,\n        uint256 motageAmount\n    );\n    event SLDWithdraw(\n        address indexed sender,\n        address indexed toAddr,\n        uint256 motageAmount\n    );\n\n    event SetFormula(address indexed addr);\n\n    event BalanceOfTaker(\n        address indexed taker,\n        uint256 depositAmount,\n        uint256 availableAmount,\n        uint256 liquidationFee\n    );\n\n    event SLDOpenContract(\n        address indexed holder,\n        uint256 orderID,\n        ContractType contractType,\n        State state,\n        string exchangeType,\n        uint256 number,\n        uint256 tradingFee,\n        uint256 liquidationFee,\n        uint256 firstMgFee,\n        uint256 lockFee,\n        uint256 newLockFee,\n        uint256 openPrice\n    );\n\n    event SLDCloseContract(\n        uint256 orderID,\n        State state,\n        uint256 lockFee,\n        uint256 newLockFee,\n        uint256 closePrice\n    );\n\n    event SLDMigration(\n        uint256 orderID,\n        State state,\n        uint256 lockFee,\n        uint256 newLockFee,\n        uint256 closePrice\n    );\n\n    event SLDRiskHandle(\n        uint256 orderID,\n        State state,\n        uint256 lockFee,\n        uint256 newLockFee,\n        uint256 closePrice\n    );\n\n    enum State {\n        PENDING,\n        ACTIVE,\n        CLOSED,\n        FORCE_CLOSED,\n        AGREEMENT\n    }\n\n    struct Order {\n        address payable holder;\n        ContractType contractType;\n        State state;\n        string exchangeType;\n        uint256 number;\n        uint256 tradingFee;\n        uint256 liquidationFee;\n        uint256 firstMgFee;\n        uint256 lockFee;\n        uint256 newLockFee;\n        uint256 openPrice;\n        uint256 startTime;\n        uint256 closePrice;\n    }\n\n    struct AccountInfo {\n        uint256 depositAmount;\n        uint256 availableAmount;\n        uint256 liquidationFee;\n    }\n\n    struct Fees {\n        uint256 total;\n        uint256 tradingFee;\n        uint256 fundingFee;\n        uint256 liquidationFee;\n        uint256 currentPrice;\n    }\n\n    struct MigrationDetail {\n        uint256 migrationTime;\n        uint256 regulatedTime;\n        uint256 inPeriodHours;\n    }\n}\n\ninterface IPublicPool {\n    function lock(\n        uint256 id,\n        uint256 marginAmount,\n        uint256 marginFee\n    ) external returns (bool);\n\n    function close(\n        uint256 id,\n        uint256 profit,\n        uint256 fundingFee\n    ) external returns (uint256 userProfit, bool isAgreement);\n\n    function riskClose(\n        uint256 id,\n        uint256 profit,\n        uint256 fundingFee\n    )\n        external\n        returns (\n            bool flag,\n            uint256 userProfit,\n            bool isAgreement\n        );\n\n    function matchIds(uint256 orderId) external view returns (uint256);\n\n    function getMarginAmount(uint256 orderID)\n        external\n        view\n        returns (uint256 marginAmount, uint256 marginFee);\n\n    function getLP2ToLp1MovePrice(uint256 takerOrderId)\n        external\n        view\n        returns (bool, uint256);\n}\n\ninterface IPrivatePool {\n    function lock(\n        uint256 id,\n        uint256 marginAmount,\n        uint256 marginFee,\n        uint256 exchgFee\n    ) external returns (bool);\n\n    function close(\n        uint256 id,\n        uint256 profit,\n        uint256 fundingFee\n    ) external returns (uint256 userProfit, bool isAgreement);\n\n    function riskClose(\n        uint256 orderID,\n        uint256 number,\n        uint256 fundingFee,\n        uint256 profit,\n        uint256 openPrice,\n        uint256 currPrice\n    )\n        external\n        returns (\n            bool flag,\n            uint256 userProfit,\n            bool isAgreement\n        );\n\n    function matchIds(uint256 orderId) external view returns (uint256);\n\n    function getMarginAmount(uint256 orderID)\n        external\n        view\n        returns (uint256 marginAmount, uint256 marginFee);\n}\n\ninterface ISLDLiquidityPool is ISLDCommon {\n    event LockInPrivatePool(\n        uint256 orderID,\n        address maker,\n        uint256 makerID,\n        uint256 marginAmount,\n        uint256 marginFee\n    );\n\n    event LockInPublicPool(\n        uint256 orderID,\n        uint256 makerID,\n        uint256 marginAmount,\n        uint256 marginFee\n    );\n\n    event CloseInPrivatePool(\n        address maker,\n        uint256 makerID,\n        uint256 orderID,\n        uint256 userProfit\n    );\n\n    event CloseInPublicPool(\n        uint256 makerID,\n        uint256 orderID,\n        uint256 userProfit\n    );\n\n    event RiskInPrivatePool(\n        address maker,\n        uint256 makerID,\n        uint256 orderID,\n        uint256 userProfit\n    );\n\n    event RiskInPubicPool(uint256 makerID, uint256 orderID, uint256 userProfit);\n\n    event MoveToPublic(\n        uint256 id,\n        uint256 profit,\n        uint256 moveProfit,\n        uint256 openPrice,\n        uint256 movePrice\n    );\n\n    event BalanceofMaker(\n        address maker,\n        uint256 amount,\n        uint256 availableAmount,\n        uint256 lockedAmount,\n        uint256 marginFee\n    );\n\n    event BalanceofPublic(\n        uint256 depositTotal,\n        uint256 lockedAmount,\n        uint256 availAmount\n    );\n\n    struct LiquidityMarket {\n        uint256 takerId;\n        uint256 marginAmount;\n        uint256 marginFee;\n        uint256 pubPriFlag; //1 - public pool, 2 - private pool\n        uint256 changePrice;\n        address makerAddr;\n        bool locked;\n    }\n\n    struct LP1Account {\n        address payable holder;\n        uint256 reTokenAmount;\n    }\n\n    struct LP2Account {\n        address payable holder;\n        uint256 amount;\n        uint256 availableAmount;\n        uint256 lockedAmount;\n        uint256 marginFee;\n        bool isRejectOrder;\n    }\n\n    struct P1AmountInfo {\n        uint256 plDepositTotal;\n        uint256 pl1lockedAmount;\n        uint256 pl1AvailAmount;\n    }\n\n    struct CloseOrder {\n        uint256 number;\n        uint256 orderID;\n        uint256 matchID;\n        uint256 profit;\n        uint256 openPrice;\n        uint256 currPrice;\n        uint256 fundingFee;\n        uint256 totalMarginAmount;\n    }\n\n    event Provide(address indexed account, uint256 amount, uint256 writeAmount);\n    event ProvideLP2(address indexed account, uint256 amount);\n    event Withdraw(address indexed account, uint256 amount);\n    event AddMargin(\n        address indexed account,\n        uint256 orderID,\n        uint256 amount,\n        uint256 margin\n    );\n\n    function totalBalance() external view returns (uint256 amount);\n}\n\ninterface IFormulaContracts is ISLDCommon {\n    using SafeMath for uint256;\n    struct Settings {\n        uint256 realVolatility;\n        uint256 historyVolatility;\n        uint256 delta;\n    }\n}\n\ninterface ISLDBroker {\n    function addInviteRelationAndCalc(\n        address inviter,\n        address invitee,\n        uint256 tokenType,\n        uint256 amount\n    ) external returns (address);\n}\n\ninterface ISLDLiquidator {\n    function calcLiquidatorAmount(\n        address liquidor,\n        uint256 tokenType,\n        uint256 gasUsed\n    ) external returns (bool);\n}\n\ninterface ISLDRewards {\n    function stakeRewardsForLP1(\n        address lp,\n        uint256 tokenType,\n        uint256 oriTokenAmount,\n        uint256 reTokenAmount\n    ) external returns (bool);\n\n    function calcAndSendRewardsForLP1(\n        address lp,\n        uint256 tokenType,\n        uint256 reTokenAmount\n    ) external returns (bool);\n\n    function calcAndSendRewardsForLP2(address lp, uint256 orderFee)\n        external\n        returns (bool);\n\n    function calcAndSendRewardsForLiquidator(address liquidor, uint256 gasUsed)\n        external\n        returns (bool);\n\n    function calcAndSendRewardsForLiquidatorWeekly(\n        address liquidor,\n        uint256 rank\n    ) external returns (bool);\n}\n\ninterface IFormula {\n    function getMargin(\n        uint256 amount,\n        uint256 openPrice,\n        uint256 poolType\n    ) external view returns (uint256 marginFee, uint256 liquidateFee);\n\n    function getPriceByAggregator() external view returns (uint256, uint8);\n\n    function getFundingFee(\n        uint256 amount,\n        uint256 openPrice,\n        uint256 latestPrice,\n        uint256 contractPeriod,\n        ISLDCommon.ContractType contractType\n    ) external view returns (uint256 fundingFee);\n}\n"},"SLDOption.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n//pragma experimental ABIEncoderV2;\nimport \"./SLDInterfaces.sol\";\nimport \"./DateTime.sol\";\nimport \"./UnderlyingAsset.sol\";\n\n/**\n * @notice Option contract DAI token.\n */\ncontract SLDOption is ISLDContract, Ownable {\n    using SafeMath for uint256;\n    using DateTime for uint256;\n\n    uint256 internal constant PRICE_DECIMALS = 1e18;\n    uint256 internal constant DAYS_OF_YEAR = 365;\n\n    address private tokenAddr; // Base fiat token address\n    StableCoinType private tokenType; // Base fiat token type. 1-DAI, 2-USDT, 3-USDC\n    address private buybackAddr; // contract address for buyback\n    address private brokerAddr; // contract address for broker\n    address private liquidatorAddr; // contract address for liquidator\n\n    address public riskFundAddr; // risk fund address\n\n    // Function selectors for BEP20\n    bytes4 internal constant SELECTOR_TRANSFER_FROM =\n        bytes4(keccak256(bytes(\"transferFrom(address,address,uint256)\")));\n    bytes4 internal constant SELECTOR_TRANSFER =\n        bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n    bytes4 internal constant SELECTOR_APPROVE =\n        bytes4(keccak256(bytes(\"approve(address,uint256)\")));\n\n    // address =\u003e AccountInfo:\n    //              + depositAmount: total fiat token amount user deposited\n    //              + availableAmount: DAI amount could be withdrawn\n    //              + liquidationFee: reserved amount for liquidation\n    mapping(address =\u003e AccountInfo) public userAccount;\n    mapping(address =\u003e uint256[]) public userOrders;\n    mapping(uint256 =\u003e uint256) public userOrderIDMapping;\n\n    uint256 public migrationPeriod = 1; // It indicates how many times migration happens in 24hours.\n    mapping(uint256 =\u003e MigrationDetail) public migrationInfo; // store all migration period of all orders\n\n    Order[] public orders; // Order list\n\n    uint256[] public fundingFeeRateMatrix;\n\n    uint256 public brokerPortion = 40; // means 40% of trading fee will transfer to broker, if the trader has a broker\n    uint256 public buybackPortion = 50; // means 50% of trading fee will transfer to buyback pool\n\n    uint256 public minDepositAmount = 1e18; // minimum deposit amount\n\n    IPublicPool public pubPool; // Public pool contract address\n    IPrivatePool public privPool; // Public pool contract address\n\n    mapping(string =\u003e UnderlyingAsset) private assetsNameMapping;\n\n    uint256 private unlocked = 1;\n\n    modifier lock() {\n        require(unlocked == 1, \"LOCKED\");\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    modifier ensure(uint256 _deadline) {\n        require(_deadline \u003e= block.timestamp, \"EXPIRED\");\n        _;\n    }\n\n    /**\n     * @dev Contract constructor.\n     * @param _pubPool Public pool address.\n     * @param _priPool Private pool address.\n     * @param _riskFundAddr Risk fund address.\n     * @param _tokenAddr Fiat token address(DAI/USDT/USDC).\n     * @param _type Fiat token type(1-DAI, 2-USDT, 3-USDC).\n     */\n    constructor(\n        address _pubPool,\n        address _priPool,\n        address _riskFundAddr,\n        address _tokenAddr,\n        StableCoinType _type\n    ) public {\n        privPool = IPrivatePool(_priPool);\n        pubPool = IPublicPool(_pubPool);\n\n        riskFundAddr = _riskFundAddr;\n\n        tokenAddr = _tokenAddr;\n        tokenType = _type;\n\n        // Approve unlimited allowance to private pool and public pool\n        _safeApprove(tokenAddr, address(privPool), uint256(-1));\n        _safeApprove(tokenAddr, address(pubPool), uint256(-1));\n\n        // initialize funding fee rate\n        fundingFeeRateMatrix.push(1e18); // means 100%\n        for (uint256 i = 1; i \u003c DAYS_OF_YEAR; i++) {\n            fundingFeeRateMatrix.push((10 * 1e18) / 100); // means 10%, indicates the following funding fee rate\n        }\n    }\n\n    /**\n     * @dev Deposit underlying assets to call/put options.\n     * @param _amount Amount of fiat token to deposit.\n     */\n    function deposit(uint256 _amount) public {\n        require(_amount \u003e= minDepositAmount, \"too small\");\n\n        _safeTransferFrom(tokenAddr, msg.sender, address(this), _amount);\n\n        AccountInfo storage userAcc = userAccount[msg.sender];\n        userAcc.depositAmount = userAcc.depositAmount.add(_amount);\n        userAcc.availableAmount = userAcc.availableAmount.add(_amount);\n\n        emit SLDDeposit(msg.sender, address(this), _amount);\n\n        emit BalanceOfTaker(\n            msg.sender,\n            userAcc.depositAmount,\n            userAcc.availableAmount,\n            userAcc.liquidationFee\n        );\n    }\n\n    /**\n     * @dev Withdraw underlying assets from smart contract.\n     * @param _amount Amount of fiat token to withdraw.\n     */\n    function withdraw(uint256 _amount) public lock {\n        AccountInfo storage userAcc = userAccount[msg.sender];\n\n        require(userAcc.availableAmount \u003e= _amount, \"exceed\");\n\n        userAcc.depositAmount = userAcc.depositAmount.sub(_amount);\n        userAcc.availableAmount = userAcc.availableAmount.sub(_amount);\n\n        emit BalanceOfTaker(\n            msg.sender,\n            userAcc.depositAmount,\n            userAcc.availableAmount,\n            userAcc.liquidationFee\n        );\n\n        _safeTransfer(tokenAddr, msg.sender, _amount);\n\n        emit SLDWithdraw(address(this), msg.sender, _amount);\n    }\n\n    /**\n     * @dev Make a call or put transation on an option.\n     * @param _exchangeType Exchange type of a transaction (i.e. ETHDAI, BTCDAI).\n     * @param _number Amount of underlying asset to call or put.\n     * @param _contractType Option type, call or put.\n     * @param _inviter Broker address.\n     * @param _slideDownPrice Used to calculate price slippage.\n     * @param _slideUpPrice Used to calculate price slippage.\n     * @param _deadline Transaction expired timestamp.\n     */\n    function creatContract(\n        string memory _exchangeType,\n        uint256 _number,\n        ContractType _contractType,\n        address _inviter,\n        uint256 _slideDownPrice,\n        uint256 _slideUpPrice,\n        uint256 _deadline\n    ) public lock ensure(_deadline) {\n        require(\n            _contractType == ContractType.LONG ||\n                _contractType == ContractType.SHORT,\n            \"wrong type\"\n        );\n\n        require(\n            address(assetsNameMapping[_exchangeType]) != address(0x0),\n            \"unsupport\"\n        );\n\n        UnderlyingAsset asset = assetsNameMapping[_exchangeType];\n\n        require(_number \u003e= asset.minAmount(), \"to small\");\n\n        // calculate fees\n        Fees memory fee;\n        {\n            (\n                fee.total, // total fee\n                fee.tradingFee, // trading fee\n                fee.fundingFee, // funding fee\n                fee.liquidationFee, // liquidation fee\n                fee.currentPrice // price when the transaction executed\n            ) = asset.fees(_number, _contractType, migrationPeriod);\n        }\n        require(\n            (_contractType == ContractType.LONG \u0026\u0026\n                fee.currentPrice \u003c= _slideUpPrice) ||\n                (_contractType == ContractType.SHORT \u0026\u0026\n                    fee.currentPrice \u003e= _slideDownPrice),\n            \"slippage\"\n        );\n\n        {\n            uint256 total = fee.total;\n            uint256 tradingFee = fee.tradingFee;\n            uint256 fundingFee = fee.fundingFee;\n            uint256 liquidationFee = fee.liquidationFee;\n\n            AccountInfo storage userAcc = userAccount[msg.sender];\n            require(userAcc.availableAmount \u003e= total, \"exceed\");\n            userAcc.availableAmount = userAcc.availableAmount.sub(\n                tradingFee.add(fundingFee.div(migrationPeriod)).add(\n                    liquidationFee\n                )\n            );\n            userAcc.depositAmount = userAcc.depositAmount.sub(tradingFee);\n            userAcc.liquidationFee = userAcc.liquidationFee.add(liquidationFee);\n\n            emit BalanceOfTaker(\n                msg.sender,\n                userAcc.depositAmount,\n                userAcc.availableAmount,\n                userAcc.liquidationFee\n            );\n        }\n\n        {\n            emit SLDOpenContract(\n                msg.sender,\n                orders.length,\n                _contractType,\n                State.ACTIVE,\n                _exchangeType,\n                _number,\n                fee.tradingFee,\n                fee.liquidationFee,\n                fee.fundingFee,\n                0,\n                fee.fundingFee.div(migrationPeriod),\n                fee.currentPrice\n            );\n        }\n\n        {\n            // get pools to match\n            (uint256 marginAmount, uint256 marginFee) = UnderlyingAsset(\n                assetsNameMapping[_exchangeType]\n            ).getLockedAmount(_number, fee.currentPrice, 2); // Use formula\n            if (\n                // order matched with private pool\n                !privPool.lock(\n                    orders.length,\n                    marginAmount,\n                    marginFee,\n                    fee.tradingFee\n                )\n            ) {\n                (marginAmount, marginFee) = UnderlyingAsset(\n                    assetsNameMapping[_exchangeType]\n                ).getLockedAmount(_number, fee.currentPrice, 1); // Use formula\n                pubPool.lock(orders.length, marginAmount, marginFee); // order matched with public pool\n            }\n\n            // Initialize migration Time\n            MigrationDetail storage detail = migrationInfo[orders.length];\n            detail.migrationTime = block.timestamp;\n            detail.regulatedTime = DateTime.regulateTimeAfter(\n                block.timestamp,\n                migrationPeriod\n            );\n            detail.inPeriodHours = DateTime.getInPeriodHours(migrationPeriod);\n\n            userOrderIDMapping[orders.length] = userOrders[msg.sender].length;\n            userOrders[msg.sender].push(orders.length);\n\n            orders.push(\n                Order(\n                    msg.sender, // option holder\n                    _contractType, // CALL or PUT\n                    State.ACTIVE, // order status\n                    _exchangeType, // i.e. ETHDAI, BTCDAI\n                    _number, // option amount\n                    fee.tradingFee, // trading fee\n                    fee.liquidationFee, // liquidation fee\n                    fee.fundingFee, // initial funding fee\n                    0, // funding fee which already deducted\n                    fee.fundingFee.div(migrationPeriod), // pre-deducted funding fee\n                    fee.currentPrice, // price when the transaction executed\n                    block.timestamp, // order created time\n                    0 // price when the option is closed\n                )\n            );\n        }\n\n        {\n            // calculate broker rewards\n            uint256 tradingFee = fee.tradingFee;\n            uint256 brokerFee = (fee.tradingFee * brokerPortion) / 100;\n            uint256 buybackFee = (fee.tradingFee * buybackPortion) / 100;\n            address brokerAddress = ISLDBroker(brokerAddr)\n                .addInviteRelationAndCalc(\n                    _inviter,\n                    msg.sender,\n                    uint256(tokenType),\n                    brokerFee\n                );\n            if (brokerAddress == address(0)) {\n                // if there is no broker, broker fee and buyback fee will both transfer to buyback pool\n                _safeTransfer(\n                    tokenAddr,\n                    buybackAddr,\n                    brokerFee.add(buybackFee)\n                );\n            } else {\n                // transfer buyback fee to buyback pool\n                _safeTransfer(tokenAddr, buybackAddr, buybackFee);\n                // transfer broker fee to broker\n                _safeTransfer(tokenAddr, brokerAddr, brokerFee);\n            }\n\n            // remaining trading fee transfer to risk fund\n            _safeTransfer(\n                tokenAddr,\n                riskFundAddr,\n                tradingFee.sub(brokerFee).sub(buybackFee)\n            );\n        }\n    }\n\n    /**\n     * @dev Close an option order.\n     * @param _orderID Order id.\n     * @param _slideDownPrice Used to calculate price slippage.\n     * @param _slideUpPrice Used to calculate price slippage.\n     */\n    function closecontract(\n        uint256 _orderID,\n        uint256 _slideDownPrice,\n        uint256 _slideUpPrice\n    ) public lock {\n        // Just for testing\n        // function closecontract(uint256 _orderID, uint256 currentPrice) public lock {\n\n        Order memory order = orders[_orderID];\n        require(order.holder == msg.sender, \"wrong holder\");\n        require(order.state == State.ACTIVE, \"wrong state\");\n        uint256 contractType = uint256(order.contractType);\n\n        require(\n            address(assetsNameMapping[order.exchangeType]) != address(0x0),\n            \"wrong asset\"\n        );\n        UnderlyingAsset asset = assetsNameMapping[order.exchangeType];\n\n        uint256 currentPrice = asset.getPrice(); // use latest price feeding by ChainLink\n\n        require(\n            (order.contractType == ContractType.LONG \u0026\u0026\n                currentPrice \u003e= _slideDownPrice) ||\n                (order.contractType == ContractType.SHORT \u0026\u0026\n                    currentPrice \u003c= _slideUpPrice),\n            \"slippage\"\n        );\n\n        uint256 profit = payProfit(currentPrice, _orderID); // calculate user profit\n        {\n            uint256 inPeriondFee = orders[_orderID].newLockFee;\n            order.lockFee = order.lockFee.add(inPeriondFee);\n            order.newLockFee = 0;\n        }\n\n        require(checkOrder(_orderID) \u003e 0, \"mismatched\");\n\n        uint256 userProfit;\n        bool isAgreement;\n        if (checkOrder(_orderID) == 2) {\n            (userProfit, isAgreement) = privPool.close(\n                _orderID,\n                profit,\n                order.lockFee\n            );\n        } else {\n            (userProfit, isAgreement) = pubPool.close(\n                _orderID,\n                profit,\n                order.lockFee\n            );\n        }\n\n        if (!isAgreement) {\n            order.state = State.CLOSED;\n        } else {\n            order.state = State.AGREEMENT;\n        }\n\n        if (userProfit \u003e 0) {\n            if (contractType == uint256(ContractType.LONG)) {\n                order.closePrice =\n                    order.openPrice +\n                    userProfit.mul(PRICE_DECIMALS) /\n                    order.number;\n            } else {\n                order.closePrice =\n                    order.openPrice -\n                    userProfit.mul(PRICE_DECIMALS) /\n                    order.number;\n            }\n        } else {\n            order.closePrice = currentPrice;\n        }\n\n        userOrders[msg.sender][userOrderIDMapping[_orderID]] = uint256(-1);\n\n        emit SLDCloseContract(\n            _orderID,\n            order.state,\n            order.lockFee,\n            order.newLockFee,\n            order.closePrice\n        );\n\n        {\n            AccountInfo storage userAcc = userAccount[msg.sender];\n            uint256 reserveAmount = order.liquidationFee;\n            userAcc.availableAmount = userAcc\n                .availableAmount\n                .add(userProfit)\n                .add(reserveAmount);\n            userAcc.liquidationFee = userAcc.liquidationFee.sub(reserveAmount);\n            userAcc.depositAmount = userAcc.depositAmount.add(userProfit).sub(\n                order.lockFee\n            );\n\n            orders[_orderID] = order;\n\n            emit BalanceOfTaker(\n                msg.sender,\n                userAcc.depositAmount,\n                userAcc.availableAmount,\n                userAcc.liquidationFee\n            );\n        }\n    }\n\n    /**\n     * @dev Order migration used to accumulated funding fee.\n     * @param orderIDs The array of order ids need to be migrated.\n     */\n    function migrationContract(uint256[] memory orderIDs) public lock {\n        uint256 totalGas;\n        bool flag = false;\n\n        for (uint256 i = 0; i \u003c orderIDs.length; i++) {\n            uint256 orderID = orderIDs[i];\n            Order memory order = orders[orderID];\n            MigrationDetail memory detail = migrationInfo[orderID];\n            if (order.state != State.ACTIVE) continue;\n\n            if (block.timestamp \u003c= detail.migrationTime) continue;\n\n            uint256 beforeGas = gasleft();\n\n            (uint256 intervalPeriods, uint256 intervalPeriodsInHours) = DateTime\n                .getIntervalPeriods(\n                    detail.regulatedTime,\n                    block.timestamp,\n                    migrationPeriod\n                );\n\n            if (intervalPeriods \u003e 0) {\n                migration(orderID, intervalPeriodsInHours);\n\n                detail.migrationTime = block.timestamp;\n                detail.regulatedTime = DateTime.regulateTimeAfter(\n                    block.timestamp,\n                    migrationPeriod\n                );\n                detail.inPeriodHours = detail.inPeriodHours.add(\n                    intervalPeriodsInHours\n                );\n                migrationInfo[orderID] = detail;\n                flag = true;\n            }\n            totalGas += beforeGas - gasleft();\n        }\n        if (flag) {\n            ISLDLiquidator(liquidatorAddr).calcLiquidatorAmount(\n                msg.sender,\n                uint256(tokenType),\n                totalGas\n            );\n        }\n    }\n\n    /**\n     * @dev Internal function use to migrate order.\n     * @param _orderID The order id need to be migrated.\n     * @param _intervalPeriodsInHours Interval migration hours from the last migration time to regulated current time.\n     */\n    function migration(uint256 _orderID, uint256 _intervalPeriodsInHours)\n        internal\n    {\n        Order memory order = orders[_orderID];\n\n        require(\n            address(assetsNameMapping[order.exchangeType]) != address(0x0),\n            \"unsupport\"\n        );\n        UnderlyingAsset asset = assetsNameMapping[order.exchangeType];\n        uint256 currentPrice = asset.getPrice(); //real\n\n        order.lockFee = order.lockFee.add(order.newLockFee);\n        (bool succ, uint256 newHoldFee) = addFeesForUser(\n            _orderID,\n            order.firstMgFee,\n            _intervalPeriodsInHours\n        );\n        address holder = orders[_orderID].holder;\n        AccountInfo storage userAcc = userAccount[holder];\n        if (!succ) {\n            uint256 profit = payProfit(currentPrice, _orderID); // calculate profit\n\n            order.newLockFee = 0;\n\n            uint256 puborPriPool = checkOrder(_orderID);\n            require(puborPriPool \u003e 0, \"mismatched\");\n            bool isAgreement;\n\n            if (puborPriPool == 2) {\n                (profit, isAgreement) = privPool.close(\n                    _orderID,\n                    profit,\n                    order.lockFee\n                );\n            } else {\n                (profit, isAgreement) = pubPool.close(\n                    _orderID,\n                    profit,\n                    order.lockFee\n                );\n            }\n\n            if (!isAgreement) {\n                order.state = State.FORCE_CLOSED;\n            } else {\n                order.state = State.AGREEMENT;\n            }\n            userOrders[order.holder][userOrderIDMapping[_orderID]] = uint256(\n                -1\n            );\n\n            // update user account info\n            uint256 reserveAmount = order.liquidationFee;\n            userAcc.availableAmount = userAcc.availableAmount.add(profit);\n            userAcc.liquidationFee = userAcc.liquidationFee.sub(reserveAmount);\n            userAcc.depositAmount = userAcc.depositAmount.add(profit).sub(\n                order.lockFee.add(reserveAmount)\n            );\n\n            if (profit \u003e 0) {\n                if (order.contractType == ContractType.LONG) {\n                    order.closePrice =\n                        order.openPrice +\n                        profit.mul(PRICE_DECIMALS) /\n                        order.number;\n                } else {\n                    order.closePrice =\n                        order.openPrice -\n                        profit.mul(PRICE_DECIMALS) /\n                        order.number;\n                }\n            } else {\n                order.closePrice = currentPrice;\n            }\n            // transfer liquidor fee to risk fund\n            _safeTransfer(tokenAddr, riskFundAddr, reserveAmount);\n        } else {\n            order.newLockFee = newHoldFee;\n            userAcc.availableAmount = userAcc.availableAmount.sub(newHoldFee);\n        }\n\n        orders[_orderID] = order;\n\n        emit SLDMigration(\n            _orderID,\n            order.state,\n            order.lockFee,\n            order.newLockFee,\n            order.closePrice\n        );\n        // Need to be removed on Mainnet launch\n        emit BalanceOfTaker(\n            order.holder,\n            userAcc.depositAmount,\n            userAcc.availableAmount,\n            userAcc.liquidationFee\n        );\n    }\n\n    /**\n     * @dev Use to trigger risk control by liquidator.\n     * @param _orderIDs The array of order ids need to be risk control.\n     */\n    function riskControl(uint256[] calldata _orderIDs) public lock {\n        // Just for testing\n        // function riskControl(uint256[] calldata _orderIDs, uint256 currentPrice) public lock {\n        uint256 totalGas;\n\n        bool flag = false;\n        for (uint256 i = 0; i \u003c _orderIDs.length; i++) {\n            if (orders[_orderIDs[i]].state == State.ACTIVE) {\n                uint256 beforeGas = gasleft();\n                require(\n                    address(\n                        assetsNameMapping[orders[_orderIDs[i]].exchangeType]\n                    ) != address(0x0),\n                    \"unsupport\"\n                );\n                UnderlyingAsset asset = assetsNameMapping[\n                    orders[_orderIDs[i]].exchangeType\n                ];\n                uint256 currentPrice = asset.getPrice();\n                uint256 calProfit = payProfit(currentPrice, _orderIDs[i]);\n\n                riskHandle(_orderIDs[i], calProfit, currentPrice);\n                flag = true;\n                totalGas += beforeGas - gasleft();\n            }\n        }\n        if (flag) {\n            ISLDLiquidator(liquidatorAddr).calcLiquidatorAmount(\n                msg.sender,\n                uint256(tokenType),\n                totalGas\n            );\n        }\n    }\n\n    /**\n     * @dev Internal function use to trigger risk control.\n     * @param _orderID The order id need to be risk controlled.\n     * @param _profit Order profit.\n     * @param _currentPrice Price when trigger the risk control.\n     */\n    function riskHandle(\n        uint256 _orderID,\n        uint256 _profit,\n        uint256 _currentPrice\n    ) internal {\n        Order memory order = orders[_orderID];\n        uint256 puborPriPool = checkOrder(_orderID);\n        require(puborPriPool \u003e 0, \"mismatched\");\n        uint256 inPeriondFee = orders[_orderID].newLockFee;\n\n        uint256 holdFee = order.lockFee.add(inPeriondFee);\n        bool flag;\n        bool isAgreement;\n        uint256 realProfit;\n        if (puborPriPool == 2) {\n            require(_profit \u003e getLpMarginAmount(_orderID), \"fail\");\n            (flag, realProfit, isAgreement) = privPool.riskClose(\n                _orderID,\n                order.number,\n                holdFee,\n                _profit,\n                order.openPrice,\n                _currentPrice\n            );\n        } else {\n            //riskClose(uint256 id, uint256 number,uint256 profit,uint256 currPrice)\n            require(\n                _profit \u003e getLpMarginAmount(_orderID).mul(50).div(100),\n                \"fail\"\n            );\n            (flag, realProfit, isAgreement) = pubPool.riskClose(\n                _orderID,\n                _profit,\n                holdFee\n            );\n        }\n\n        if (flag) {\n            // force close\n            if (!isAgreement) {\n                order.state = State.FORCE_CLOSED;\n            } else {\n                order.state = State.AGREEMENT;\n            }\n\n            order.lockFee = holdFee;\n            order.newLockFee = 0;\n\n            userOrders[order.holder][userOrderIDMapping[_orderID]] = uint256(\n                -1\n            );\n\n            if (realProfit \u003e 0) {\n                if (order.contractType == ContractType.LONG) {\n                    order.closePrice =\n                        order.openPrice +\n                        realProfit.mul(PRICE_DECIMALS) /\n                        order.number;\n                } else {\n                    order.closePrice =\n                        order.openPrice -\n                        realProfit.mul(PRICE_DECIMALS) /\n                        order.number;\n                }\n            } else {\n                order.closePrice = _currentPrice;\n            }\n\n            uint256 reserveAmount = order.liquidationFee;\n\n            AccountInfo storage userAcc = userAccount[order.holder];\n            userAcc.availableAmount = userAcc.availableAmount.add(realProfit);\n            userAcc.liquidationFee = userAcc.liquidationFee.sub(reserveAmount);\n            userAcc.depositAmount = userAcc\n                .depositAmount\n                .add(realProfit)\n                .sub(holdFee)\n                .sub(reserveAmount);\n            orders[_orderID] = order;\n\n            emit BalanceOfTaker(\n                order.holder,\n                userAcc.depositAmount,\n                userAcc.availableAmount,\n                userAcc.liquidationFee\n            );\n            emit SLDRiskHandle(\n                _orderID,\n                order.state,\n                order.lockFee,\n                order.newLockFee,\n                order.closePrice\n            );\n\n            _safeTransfer(tokenAddr, riskFundAddr, reserveAmount);\n        }\n    }\n\n    /**\n     * @dev Get Margin amount locked in private market maker\u0027s fund.\n     * @param _orderID Order id.\n     */\n    function getLpMarginAmount(uint256 _orderID)\n        internal\n        view\n        returns (uint256 marginAmount)\n    {\n        uint256 puborPriPool = checkOrder(_orderID);\n        if (puborPriPool == 0) return 0;\n        if (puborPriPool == 2) {\n            //lp2RiskControl\n            (marginAmount, ) = privPool.getMarginAmount(_orderID);\n        } else {\n            (marginAmount, ) = pubPool.getMarginAmount(_orderID);\n        }\n    }\n\n    /**\n     * @dev Get Margin amount locked in private market maker\u0027s fund.\n     * @param _orderID Order id.\n     */\n    function getLpMarginAmountAndMarginFee(uint256 _orderID)\n        public\n        view\n        returns (uint256 marginAmount, uint256 marginFee)\n    {\n        uint256 puborPriPool = checkOrder(_orderID);\n        if (puborPriPool == 0) return (0, 0);\n        if (puborPriPool == 2) {\n            //lp2RiskControl\n            (marginAmount, marginFee) = privPool.getMarginAmount(_orderID);\n        } else {\n            (marginAmount, marginFee) = pubPool.getMarginAmount(_orderID);\n        }\n    }\n\n    /**\n     * @dev Check whether the order is as risk.\n     * @param _orderID Order id.\n     */\n    function checkOrderIsAtRisk(uint256 _orderID) public view returns (bool) {\n        Order memory order = orders[_orderID];\n        require(order.state == State.ACTIVE, \"wrong state\");\n        uint256 puborPriPool = checkOrder(_orderID);\n        require(puborPriPool \u003e 0, \"mismatched\");\n\n        require(\n            address(assetsNameMapping[order.exchangeType]) != address(0x0),\n            \"unsupport\"\n        );\n        UnderlyingAsset asset = assetsNameMapping[order.exchangeType];\n        uint256 currentPrice = asset.getPrice(); //real\n        uint256 calProfit = payProfit(currentPrice, _orderID);\n        uint256 marginAmount;\n        if (puborPriPool == 2) {\n            //lp2RiskControl\n            (marginAmount, ) = privPool.getMarginAmount(_orderID);\n            if (calProfit \u003e marginAmount) return true;\n        } else {\n            (marginAmount, ) = pubPool.getMarginAmount(_orderID);\n            if (calProfit \u003e marginAmount.mul(50).div(100)) return true;\n        }\n    }\n\n    /**\n     * @dev Get the length of the order array.\n     */\n    function getOrdersLen() public view returns (uint256 _ordersLen) {\n        _ordersLen = orders.length;\n    }\n\n    function getFundingFeeInfo(uint256 _orderID)\n        public\n        view\n        returns (\n            uint256 _paidFundingFee,\n            uint256 _initalFundingfee,\n            uint256 _pendingFundingfee,\n            uint256 _periods,\n            uint256 _periodsInHours\n        )\n    {\n        Order memory order = orders[_orderID];\n        _paidFundingFee = order.lockFee + order.newLockFee;\n        _initalFundingfee = order.firstMgFee;\n\n        (_periods, _periodsInHours) = DateTime.getIntervalPeriods(\n            migrationInfo[_orderID].regulatedTime,\n            block.timestamp,\n            migrationPeriod\n        );\n\n        _pendingFundingfee = getFundingFee(\n            _initalFundingfee,\n            _periodsInHours,\n            migrationInfo[_orderID].inPeriodHours\n        );\n    }\n\n    /**\n     * @dev Calculate funding fee.\n     * @param _initialFundingFee Initial funnding fee charged at the first place.\n     * @param _intervalPeriodsInHours Interval migration hours from the last migration time to regulated current time.\n     * @param _inPeriodHours Hours which funding fees paid.\n     */\n    function getFundingFee(\n        uint256 _initialFundingFee,\n        uint256 _intervalPeriodsInHours,\n        uint256 _inPeriodHours\n    ) internal view returns (uint256 _fundingFee) {\n        uint256 nextMgFeeRate = fundingFeeRateMatrix[\n            DateTime.getInPeriodDayIndex(_inPeriodHours)\n        ];\n        if (_inPeriodHours \u003e= 24) {\n            _fundingFee = _initialFundingFee\n                .mul(_intervalPeriodsInHours)\n                .mul(nextMgFeeRate)\n                .div(24)\n                .div(PRICE_DECIMALS);\n        } else if (_intervalPeriodsInHours + _inPeriodHours \u003c= 24) {\n            _fundingFee = _initialFundingFee.mul(_intervalPeriodsInHours).div(\n                24\n            );\n        } else if (_intervalPeriodsInHours + _inPeriodHours \u003e 24) {\n            _fundingFee = (uint256(24).sub(_inPeriodHours))\n                .mul(_initialFundingFee)\n                .div(24);\n            _fundingFee += _intervalPeriodsInHours\n                .add(_inPeriodHours)\n                .sub(24)\n                .mul(_initialFundingFee)\n                .mul(nextMgFeeRate)\n                .div(24)\n                .div(PRICE_DECIMALS);\n        } else {\n            // never should happen\n            _fundingFee = _initialFundingFee\n                .mul(_inPeriodHours)\n                .mul(nextMgFeeRate)\n                .div(24)\n                .div(PRICE_DECIMALS);\n        }\n    }\n\n    /**\n     * @dev Calculate funding fee.\n     * @param _orderID Order ID.\n     * @param _initialFundingFee Initial funnding fee charged at the first place.\n     * @param _intervalPeriodsInHours Interval migration hours from the last migration time to regulated current time.\n     */\n    function addFeesForUser(\n        uint256 _orderID,\n        uint256 _initialFundingFee,\n        uint256 _intervalPeriodsInHours\n    ) internal view returns (bool _succ, uint256 _newFundingFee) {\n        uint256 fundingFee = getFundingFee(\n            _initialFundingFee,\n            _intervalPeriodsInHours,\n            migrationInfo[_orderID].inPeriodHours\n        );\n        address holder = orders[_orderID].holder;\n        if (userAccount[holder].availableAmount \u003e= fundingFee) {\n            _newFundingFee = fundingFee;\n            _succ = true;\n        }\n    }\n\n    /**\n     * @dev Check pool type the order matched(public pool or private pool)\n     * @param _orderID Order ID.\n     */\n    function checkOrder(uint256 _orderID)\n        public\n        view\n        returns (uint256 _lpFlag)\n    {\n        if (privPool.matchIds(_orderID) \u003e 0) {\n            return 2;\n        } else if (pubPool.matchIds(_orderID) \u003e 0) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n\n    function getUserOrders(address _addr)\n        public\n        view\n        returns (uint256[] memory _orders)\n    {\n        _orders = userOrders[_addr];\n    }\n\n    /**\n     * @dev Calculte taker profit of an order.\n     * @param _currentPrice Current price of the according underlying asset.\n     * @param _orderID Order id.\n     */\n    function payProfit(uint256 _currentPrice, uint256 _orderID)\n        internal\n        view\n        returns (uint256 profit)\n    {\n        Order memory order = orders[_orderID];\n        if (order.contractType == ContractType.LONG) {\n            // CALL\n            if (order.openPrice \u003c _currentPrice)\n                profit = order.number.mul(_currentPrice - order.openPrice).div(\n                    PRICE_DECIMALS\n                );\n        } else {\n            // PUT\n            if (order.openPrice \u003e _currentPrice)\n                // calculate profit\n                profit = order.number.mul(order.openPrice - _currentPrice).div(\n                    PRICE_DECIMALS\n                );\n        }\n    }\n\n    /**\n     * @dev Add a new underlying asset or update exisiting underlying asset.\n     * @param _exchangeType  Exchange type name.\n     * @param _underlyingAsset Underlying asset contract address.\n     */\n    function addOrUpdateUnderlyingAsset(\n        string memory _exchangeType,\n        address _underlyingAsset\n    ) public onlyOwner {\n        require(_underlyingAsset != address(0x0), \"ZERO\");\n\n        assetsNameMapping[_exchangeType] = UnderlyingAsset(_underlyingAsset);\n    }\n\n    /**\n     * @dev Remove inactive orders to recover storage space\n     * @param _orderIDs Order ids.\n     */\n    function removeOrders(uint256[] memory _orderIDs) public onlyOwner {\n        for (uint256 i = 0; i \u003c _orderIDs.length; i++) {\n            if (orders[_orderIDs[i]].state != State.ACTIVE) {\n                delete orders[_orderIDs[i]];\n            }\n        }\n    }\n\n    /**\n     * @dev Set private \u0026 public pool address\n     * @param _priPool Private pool address.\n     * @param _pubPool Public pool address.\n     */\n    function setPriAndPubPool(address _priPool, address _pubPool)\n        public\n        onlyOwner\n    {\n        require(\n            address(_priPool) != address(0x0) \u0026\u0026\n                address(_pubPool) != address(0x0),\n            \"ZERO\"\n        );\n        privPool = IPrivatePool(_priPool);\n        pubPool = IPublicPool(_pubPool);\n    }\n\n    /**\n     * @dev Set risk fund address\n     * @param _riskFundAddr Risk fund address.\n     */\n    function setRiskFundAddr(address _riskFundAddr) public onlyOwner {\n        require(address(_riskFundAddr) != address(0x0), \"ZERO\");\n        riskFundAddr = _riskFundAddr;\n    }\n\n    /**\n     * @dev Set broker contract address\n     * @param _brokerAddr Broker contract address.\n     */\n    function setBrokerAddr(address _brokerAddr) public onlyOwner {\n        require(address(_brokerAddr) != address(0x0), \"ZERO\");\n        brokerAddr = _brokerAddr;\n    }\n\n    /**\n     * @dev Set liquidation contract address\n     * @param _liquidatorAddr Liquidation contract address.\n     */\n    function setLiquidatorAddr(address _liquidatorAddr) public onlyOwner {\n        require(address(_liquidatorAddr) != address(0x0), \"ZERO\");\n        liquidatorAddr = _liquidatorAddr;\n    }\n\n    /**\n     * @dev Set buyback contract address\n     * @param _buybackAddr Buyback contract address.\n     */\n    function setBuybackAddr(address _buybackAddr) public onlyOwner {\n        require(address(_buybackAddr) != address(0x0), \"ZERO\");\n        buybackAddr = _buybackAddr;\n    }\n\n    /**\n     * @dev Set funding fee rate matrix\n     * @param _rates Funding fee rate.\n     */\n    function setFundingFeeRateMatrix(uint256[] memory _rates) public onlyOwner {\n        require(\n            _rates.length == fundingFeeRateMatrix.length \u0026\u0026\n                _rates.length == DAYS_OF_YEAR,\n            \"length should be 365\"\n        );\n        for (uint256 i = 0; i \u003c DAYS_OF_YEAR; i++) {\n            fundingFeeRateMatrix[i] = _rates[i];\n        }\n    }\n\n    /**\n     * @dev Set migration period\n     * @param _migrationPeriod Migration period.\n     */\n    function setMigrationPeriod(uint256 _migrationPeriod) public onlyOwner {\n        require(_migrationPeriod \u003c 24 \u0026\u0026 24 % _migrationPeriod == 0, \"INVALID\");\n        migrationPeriod = _migrationPeriod;\n    }\n\n    /**\n     * @dev Set minimum deposit amount\n     * @param _minDepositAmount Minimum deposit amount.\n     */\n    function setMinDepositAmount(uint256 _minDepositAmount) public onlyOwner {\n        minDepositAmount = _minDepositAmount;\n    }\n\n    /**\n     * @dev Set allocation rate of trading fee\n     * @param _brokerPortion Portion allocate to broker.\n     * @param _buybackPortion Portion allocate to buyback pool.\n     */\n    function setTradingFeeAllocation(\n        uint256 _brokerPortion,\n        uint256 _buybackPortion\n    ) public onlyOwner {\n        require(brokerPortion + buybackPortion \u003c= 100, \"Exceed\");\n        brokerPortion = _brokerPortion;\n        buybackPortion = _buybackPortion;\n    }\n\n    function _safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(SELECTOR_TRANSFER_FROM, from, to, value)\n        );\n        require(success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))));\n    }\n\n    function _safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(SELECTOR_TRANSFER, to, value)\n        );\n        require(success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))));\n    }\n\n    function _safeApprove(\n        address token,\n        address spender,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(SELECTOR_APPROVE, spender, value)\n        );\n        require(success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))));\n    }\n}\n"},"UnderlyingAsset.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.12;\nimport \"./SLDInterfaces.sol\";\nimport \"./DateTime.sol\";\n\ncontract UnderlyingAsset is ISLDContract, Ownable {\n    using SafeMath for uint256;\n    using DateTime for uint256;\n\n    string public name;\n\n    uint256 public tradingFeeRate = (1 * 1e18) / 1000; // means 0.1%\n    uint256 public liquidationFeeRate = (1 * 1e18) / 1000; // means 0.1%\n    uint256 public minAmount = 1e16;\n\n    uint256 public constant TOKEN_DECIMALS = 1e18;\n    uint256 private constant PRICE_DECIMALS = 1e18;\n    uint256 private constant ROUND_DECIMALS = 1e6;\n\n    bool private priceThirdFlag;\n    uint256 private thirdProxyPrice;\n\n    IFormula public formula;\n\n    constructor(string memory _name, address _formula) public {\n        name = _name;\n        formula = IFormula(_formula);\n    }\n\n    function getPrice() public view returns (uint256) {\n        if (priceThirdFlag) {\n            return thirdProxyPrice;\n        }\n\n        (uint256 price, uint8 decimals) = formula.getPriceByAggregator();\n\n        uint256 latestPrice = (price * TOKEN_DECIMALS) /\n            (10**uint256(decimals));\n\n        return latestPrice;\n    }\n\n    function getFundingFee(\n        uint256 _amount,\n        uint256 _openPrice,\n        ContractType _contractType\n    ) public view returns (uint256 _fee) {\n        _fee = formula.getFundingFee(\n            _amount,\n            _openPrice,\n            _openPrice,\n            1,\n            _contractType\n        );\n    }\n\n    /**\n     * @dev Get funding fee rate within this period.\n     * @param _contractType LONG or SHORT\n     * @return _fundingFeeRate\n     */\n    function getFundingFeeRate(ContractType _contractType)\n        public\n        view\n        returns (uint256 _fundingFeeRate)\n    {\n        uint256 currentPrice = getPrice();\n        uint256 number = 1e18;\n\n        uint256 amount = number.mul(currentPrice).div(PRICE_DECIMALS);\n        uint256 fundingFee = getFundingFee(number, currentPrice, _contractType);\n\n        _fundingFeeRate = fundingFee.mul(1e8).div(amount);\n    }\n\n    function fees(\n        uint256 _number,\n        ContractType _contractType,\n        uint256 _period\n    )\n        public\n        view\n        returns (\n            uint256 total,\n            uint256 tradingFee,\n            uint256 fundingFee,\n            uint256 liquidationFee,\n            uint256 currentPrice\n        )\n    {\n        currentPrice = getPrice();\n\n        uint256 amount = _number.mul(currentPrice).div(PRICE_DECIMALS);\n        tradingFee = amount.mul(tradingFeeRate).div(PRICE_DECIMALS);\n        fundingFee = getFundingFee(_number, currentPrice, _contractType);\n        liquidationFee = amount.mul(liquidationFeeRate).div(PRICE_DECIMALS);\n        total = tradingFee.add(fundingFee.div(_period)).add(liquidationFee);\n    }\n\n    function getLockedAmount(\n        uint256 _amount,\n        uint256 _currentPrice,\n        uint256 _poolType\n    ) public view returns (uint256 marginFee, uint256 forceFee) {\n        (marginFee, forceFee) = formula.getMargin(\n            _amount,\n            _currentPrice,\n            _poolType\n        );\n    }\n\n    function getMaxOpenAmount(\n        uint256 _amount,\n        ContractType _contractType,\n        uint256 _period\n    ) public view returns (uint256) {\n        require(_amount \u003e 0, \"param is invalid\");\n\n        (\n            ,\n            uint256 tradingFee,\n            uint256 fundingFee,\n            uint256 liquidationFee,\n\n        ) = fees(TOKEN_DECIMALS, _contractType, _period);\n\n        uint256 totalFee = tradingFee.add(fundingFee.div(_period)).add(\n            liquidationFee\n        );\n\n        return\n            _amount.mul(TOKEN_DECIMALS).div(totalFee).div(ROUND_DECIMALS).mul(\n                ROUND_DECIMALS\n            );\n    }\n\n    function setFormula(address _formula) public onlyOwner {\n        require(address(_formula) != address(0x0), \"ADDRESS_ZERO\");\n        formula = IFormula(_formula);\n        emit SetFormula(address(_formula));\n    }\n\n    function setMinAmount(uint256 _minAmount) public onlyOwner {\n        require(_minAmount \u003e 0, \"INVALID\");\n        minAmount = _minAmount;\n    }\n\n    function setTradingFeeRate(uint256 _tradingFeeRate) public onlyOwner {\n        require(_tradingFeeRate \u003e 0, \"WRONG FEE RATE\");\n        tradingFeeRate = _tradingFeeRate;\n    }\n\n    function setliquidationFeeRate(uint256 _liquidationFeeRate)\n        public\n        onlyOwner\n    {\n        require(_liquidationFeeRate \u003e 0, \"ZERO\");\n        liquidationFeeRate = _liquidationFeeRate;\n    }\n\n    function setPriceThirdProxy(bool _priceThirdFlag, uint256 _thirdProxyPrice)\n        public\n        onlyOwner\n    {\n        require(_thirdProxyPrice \u003e 0, \"thirdProxyPrice zero\");\n        priceThirdFlag = _priceThirdFlag;\n        thirdProxyPrice = _thirdProxyPrice;\n    }\n\n    function getThirdPriceAndFlag() public view returns (bool, uint256) {\n        return (priceThirdFlag, thirdProxyPrice);\n    }\n}\n"}}