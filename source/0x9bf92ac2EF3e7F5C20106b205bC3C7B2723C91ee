
// File: contracts/interfaces/INotifyGate.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import "oz-custom/contracts/oz/token/ERC20/IERC20.sol";
import {
    IERC20Permit
} from "oz-custom/contracts/oz/token/ERC20/extensions/draft-IERC20Permit.sol";
import {
    IERC721,
    ERC721TokenReceiver
} from "oz-custom/contracts/oz/token/ERC721/ERC721.sol";

interface INotifyGate {
    error NofifyGate__ExecutionFailed();

    event Notified(
        address indexed sender,
        bytes indexed message,
        address indexed token,
        uint256 value
    );

    function notifyWithNative(bytes calldata message_) external payable;

    function notifyWithERC20(
        IERC20 token_,
        uint256 value_,
        uint256 deadline_,
        uint8 v,
        bytes32 r,
        bytes32 s,
        bytes calldata message_
    ) external;
}


// File: contracts/internal/BKFundForwarder.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import {FundForwarder} from "oz-custom/contracts/internal/FundForwarder.sol";

import {ITreasury} from "oz-custom/contracts/presets/interfaces/ITreasury.sol";

import {
    ERC165Checker
} from "oz-custom/contracts/oz/utils/introspection/ERC165Checker.sol";

abstract contract BKFundForwarder is FundForwarder {
    using ERC165Checker for address;

    function safeRecoverHeader() public pure override returns (bytes memory) {
        /// @dev value is equal keccak256("SAFE_RECOVER_HEADER")
        return
            bytes.concat(
                bytes32(
                    0x556d79614195ebefcc31ab1ee514b9953934b87d25857902370689cbd29b49de
                )
            );
    }

    function safeTransferHeader() public pure override returns (bytes memory) {
        /// @dev value is equal keccak256("SAFE_TRANSFER")
        return
            bytes.concat(
                bytes32(
                    0xc9627ddb76e5ee80829319617b557cc79498bbbc5553d8c632749a7511825f5d
                )
            );
    }

    function _checkValidAddress(address vault_) internal view override {
        super._checkValidAddress(vault_);
        if (!vault_.supportsInterface(type(ITreasury).interfaceId))
            revert FundForwarder__InvalidArgument();
    }
}


// File: contracts/NotifyGate.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import {FundForwarder, BKFundForwarder} from "./internal/BKFundForwarder.sol";

import {
    Roles,
    Manager,
    IAuthority
} from "oz-custom/contracts/presets/base/Manager.sol";
import {
    ReentrancyGuard
} from "oz-custom/contracts/oz/security/ReentrancyGuard.sol";

import {INotifyGate} from "./interfaces/INotifyGate.sol";
import {
    IWithdrawable
} from "oz-custom/contracts/internal/interfaces/IWithdrawable.sol";

import {
    IFundForwarder
} from "oz-custom/contracts/internal/interfaces/IFundForwarder.sol";

import {
    IERC20,
    IERC20Permit
} from "oz-custom/contracts/oz/token/ERC20/extensions/IERC20Permit.sol";

import {
    IERC721,
    ERC721TokenReceiver
} from "oz-custom/contracts/oz/token/ERC721/ERC721.sol";

contract NotifyGate is
    Manager,
    INotifyGate,
    ReentrancyGuard,
    BKFundForwarder,
    ERC721TokenReceiver
{
    constructor(
        IAuthority authority_
    ) payable ReentrancyGuard() Manager(authority_, 0) {
        _changeVault(IFundForwarder(address(authority_)).vault());
    }

    function changeVault(
        address vault_
    ) external override onlyRole(Roles.TREASURER_ROLE) {
        _changeVault(vault_);
    }

    function notifyWithNative(bytes calldata message_) external payable {
        _safeNativeTransfer(vault(), msg.value, "");
        emit Notified(_msgSender(), message_, address(0), msg.value);
    }

    function onERC721Received(
        address from_,
        address,
        uint256 tokenId_,
        bytes calldata message_
    ) external override returns (bytes4) {
        address nft = _msgSender();
        IERC721(nft).safeTransferFrom(
            address(this),
            vault(),
            tokenId_,
            safeTransferHeader()
        );

        emit Notified(from_, message_, nft, tokenId_);

        return this.onERC721Received.selector;
    }

    function notifyWithERC20(
        IERC20 token_,
        uint256 value_,
        uint256 deadline_,
        uint8 v,
        bytes32 r,
        bytes32 s,
        bytes calldata message_
    ) external nonReentrant {
        address user = _msgSender();
        if (token_.allowance(user, address(this)) < value_) {
            IERC20Permit(address(token_)).permit(
                user,
                address(this),
                value_,
                deadline_,
                v,
                r,
                s
            );
        }

        address _vault = vault();

        _safeERC20TransferFrom(token_, user, _vault, value_);

        if (
            IWithdrawable(_vault).notifyERC20Transfer(
                address(token_),
                value_,
                safeTransferHeader()
            ) != IWithdrawable.notifyERC20Transfer.selector
        ) revert NofifyGate__ExecutionFailed();

        emit Notified(user, message_, address(token_), value_);
    }

    function _beforeRecover(
        bytes memory
    ) internal override whenPaused onlyRole(Roles.OPERATOR_ROLE) {}

    function _afterRecover(
        address,
        address,
        uint256,
        bytes memory
    ) internal override {}
}


// File: oz-custom/contracts/internal/FundForwarder.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import {Context} from "../oz/utils/Context.sol";

import {Transferable} from "./Transferable.sol";
import {ProxyChecker} from "./ProxyChecker.sol";

import {IFundForwarder} from "./interfaces/IFundForwarder.sol";

import {ErrorHandler} from "../libraries/ErrorHandler.sol";

/**
 * @title FundForwarder
 * @dev Abstract contract for forwarding funds to a specified address.
 */
abstract contract FundForwarder is
    Context,
    ProxyChecker,
    Transferable,
    IFundForwarder
{
    using ErrorHandler for bool;
    /**
     * @dev Address to forward funds to
     */
    bytes32 private __vault;

    /**
     * @dev Receives funds and forwards them to the vault address
     */
    receive() external payable virtual onlyEOA {
        _beforeRecover("");
        address _vault = vault();

        _safeNativeTransfer(_vault, msg.value, safeRecoverHeader());

        emit Forwarded(_msgSender(), msg.value);

        _afterRecover(_vault, address(0), msg.value, "");
    }

    function recover(RecoveryCallData[] calldata calldata_) external virtual {
        _beforeRecover("");

        address _vault = vault();
        address sender = _msgSender();
        uint256 length = calldata_.length;
        bytes[] memory results = new bytes[](length);

        bool ok;
        bytes memory result;
        for (uint256 i; i < length; ) {
            (ok, result) = calldata_[i].token.call{value: calldata_[i].value}(
                abi.encodePacked(calldata_[i].fnSelector, calldata_[i].params)
            );

            ok.handleRevertIfNotSuccess(result);

            results[i] = result;

            _afterRecover(
                _vault,
                calldata_[i].token,
                calldata_[i].value,
                calldata_[i].params
            );

            emit Recovered(
                sender,
                calldata_[i].token,
                calldata_[i].value,
                calldata_[i].params
            );

            unchecked {
                ++i;
            }
        }
    }

    /// @inheritdoc IFundForwarder
    function recoverNative() external virtual {
        _beforeRecover("");
        address sender = _msgSender();
        _onlyEOA(sender);

        address _vault = vault();
        uint256 balance = address(this).balance;
        _safeNativeTransfer(_vault, balance, safeRecoverHeader());

        emit Recovered(sender, address(0), balance, "");

        _afterRecover(_vault, address(0), balance, "");
    }

    function vault() public view virtual returns (address vault_) {
        assembly {
            vault_ := sload(__vault.slot)
        }

        _checkValidAddress(vault_);
    }

    function safeRecoverHeader() public pure virtual returns (bytes memory);

    function safeTransferHeader() public pure virtual returns (bytes memory);

    /**
     * @dev Changes the vault address
     * @param vault_ New vault address
     */
    function _changeVault(address vault_) internal virtual {
        _checkValidAddress(vault_);

        assembly {
            log4(
                0x00,
                0x00,
                /// @dev value is equal to keccak256("VaultUpdated(address,address,address)")
                0x2afec66505e0ceed692012e3833f6609d4933ded34732135bc05f28423744065,
                caller(),
                sload(__vault.slot),
                vault_
            )

            sstore(__vault.slot, vault_)
        }
    }

    function _beforeRecover(bytes memory data_) internal virtual;

    function _afterRecover(
        address vault_,
        address token_,
        uint256 value_,
        bytes memory params_
    ) internal virtual;

    /**
     *@dev Asserts that the given address is not the zero address
     *@param addr_ The address to check
     *@custom:throws FundForwarder__InvalidArgument if the address is the zero address
     */
    function _checkValidAddress(address addr_) internal view virtual {
        if (addr_ == address(0) || addr_ == address(this))
            revert FundForwarder__InvalidArgument();
    }
}


// File: oz-custom/contracts/internal/interfaces/IBlacklistable.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

interface IBlacklistable {
    event UserStatusSet(
        address indexed operator,
        address indexed account,
        bool indexed isBlacklisted
    );

    /**
     * @dev Set the status of an account to either blacklisted or not blacklisted.
     * @param account_ The address to change the status of.
     * @param status The new status for the address. True for blacklisted, false for not blacklisted.
     */
    function setUserStatus(address account_, bool status) external;

    /**
     * @dev Check if an address is blacklisted.
     * @param account_ The address to check.
     * @return True if the address is blacklisted, false otherwise.
     */
    function isBlacklisted(address account_) external view returns (bool);

    function areBlacklisted(
        address[] calldata accounts_
    ) external view returns (bool);
}


// File: oz-custom/contracts/internal/interfaces/IFundForwarder.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import {IERC20} from "../../oz/token/ERC20/IERC20.sol";

import {
    IERC721,
    IERC721Enumerable
} from "../../oz/token/ERC721/extensions/IERC721Enumerable.sol";

interface IFundForwarder {
    error FundForwarder__InvalidArgument();

    struct RecoveryCallData {
        address token;
        uint256 value;
        bytes4 fnSelector;
        bytes params;
    }

    /**
     * @dev Emits when the vault address is updated
     * @param from Old vault address
     * @param to New vault address
     */
    event VaultUpdated(address indexed from, address indexed to);

    /**
     *@dev Emits when a single ERC721 token is recovered
     *@param operator Address of the contract calling this function
     *@param token Address of the token contract
     *@param value Token ID of the recovered token
     */
    event Recovered(
        address indexed operator,
        address indexed token,
        uint256 indexed value,
        bytes params
    );

    /**
     * @dev Emits when funds are forwarded
     * @param from Address of the sender
     * @param amount Amount of funds forwarded
     */
    event Forwarded(address indexed from, uint256 indexed amount);

    function safeRecoverHeader() external pure returns (bytes memory);

    function safeTransferHeader() external pure returns (bytes memory);

    function changeVault(address vault_) external;

    function vault() external view returns (address);

    /**
     * @dev Recovers native currency to the vault address
     */
    function recoverNative() external;

    function recover(RecoveryCallData[] calldata calldata_) external;
}


// File: oz-custom/contracts/internal/interfaces/IWithdrawable.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

interface IWithdrawable {
    event Withdrawn(
        address indexed token,
        address indexed to,
        uint256 indexed value
    );

    /**
     * @dev Event emitted when funds are received by the contract
     */
    event Received(
        address indexed sender,
        address indexed token,
        bytes value,
        bytes data
    );

    function notifyERC20Transfer(
        address token_,
        uint256 value_,
        bytes calldata data_
    ) external returns (bytes4);

    /**
     * @dev Withdraws the given amount of tokens or Ether from the contract
     * @param token_ Address of the token contract to withdraw. If zero address, withdraw Ether.
     * @param to_ Address to send the tokens or Ether to
     * @param amount_ Amount of tokens or Ether to withdraw
     */
    function withdraw(
        address token_,
        address to_,
        uint256 amount_,
        bytes calldata data_
    ) external;
}


// File: oz-custom/contracts/internal/ProxyChecker.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

/**
 * @dev Revert error if call is made from a proxy contract
 */
error ProxyChecker__EOAUnallowed();
/**
 * @dev Revert error if call is made from an externally owned account
 */
error ProxyChecker__ProxyUnallowed();

/**
 * @title ProxyChecker
 * @dev Abstract contract for checking if a call was made by a proxy contract or an externally owned account.
 */
abstract contract ProxyChecker {
    modifier onlyProxy() {
        _onlyProxy(msg.sender);
        _;
    }

    /**
     * @dev Modifier to allow a function to be called only by an externally owned account
     */
    modifier onlyEOA() {
        _onlyEOA(msg.sender);
        _;
    }

    /**
     * @dev Check if the sender is an externally owned account
     * @param sender_ Address of the sender
     */
    function _onlyEOA(address sender_) internal view {
        _onlyEOA(sender_, _txOrigin());
    }

    /**
     * @dev Check if the sender is an externally owned account
     * @param msgSender_ Address of the sender
     * @param txOrigin_ Origin of the transaction
     */
    function _onlyEOA(address msgSender_, address txOrigin_) internal pure {
        if (_isProxyCall(msgSender_, txOrigin_))
            revert ProxyChecker__ProxyUnallowed();
    }

    /**
     * @dev Check if the sender is a proxy contract
     * @param sender_ Address of the sender
     */
    function _onlyProxy(address sender_) internal view {
        if (!(_isProxyCall(sender_, _txOrigin()) || _isProxy(sender_)))
            revert ProxyChecker__EOAUnallowed();
    }

    /**
     * @dev Check if the sender is a proxy contract
     * @param msgSender_ Address of the sender
     * @param txOrigin_ Origin of the transaction
     */
    function _onlyProxy(address msgSender_, address txOrigin_) internal view {
        if (!(_isProxyCall(msgSender_, txOrigin_) || _isProxy(msgSender_)))
            revert ProxyChecker__EOAUnallowed();
    }

    /**
     * @dev Check if the call was made by a proxy contract
     * @param msgSender_ Address of the sender
     * @param txOrigin_ Origin of the transaction
     * @return True if the call was made by a proxy contract, false otherwise
     */
    function _isProxyCall(
        address msgSender_,
        address txOrigin_
    ) internal pure returns (bool) {
        return msgSender_ != txOrigin_;
    }

    /**
     * @dev Check if the caller is a proxy contract
     * @param caller_ Address of the caller
     * @return True if the caller is a proxy contract, false otherwise
     */
    function _isProxy(address caller_) internal view returns (bool) {
        return caller_.code.length != 0;
    }

    /**
     * @dev Returns the origin of the transaction
     * @return Origin of the transaction
     */
    function _txOrigin() internal view returns (address) {
        return tx.origin;
    }
}


// File: oz-custom/contracts/internal/Transferable.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import {IERC20} from "../oz/token/ERC20/IERC20.sol";

error Transferable__TransferFailed();
error Transferable__InvalidArguments();

/**
 * @dev Library for transferring Ether and tokens between accounts
 */
abstract contract Transferable {
    /**
     * @dev Reverts the transaction if the transfer fails
     * @param token_ Address of the token contract to transfer. If zero address, transfer Ether.
     * @param from_ Address to transfer from
     * @param to_ Address to transfer to
     * @param value_ Amount of tokens or Ether to transfer
     */
    function _safeTransferFrom(
        address token_,
        address from_,
        address to_,
        uint256 value_,
        bytes memory data_
    ) internal virtual {
        __checkValidTransfer(to_, value_);

        if (
            token_ == address(0)
                ? _nativeTransfer(to_, value_, data_)
                : _ERC20TransferFrom(IERC20(token_), from_, to_, value_)
        ) return;

        revert Transferable__TransferFailed();
    }

    /**
     * @dev Reverts the transaction if the transfer fails
     * @param token_ Address of the token contract to transfer. If zero address, transfer Ether.
     * @param to_ Address to transfer to
     * @param value_ Amount of tokens or Ether to transfer
     */
    function _safeTransfer(
        address token_,
        address to_,
        uint256 value_,
        bytes memory data_
    ) internal virtual {
        __checkValidTransfer(to_, value_);

        if (
            token_ == address(0)
                ? _nativeTransfer(to_, value_, data_)
                : _ERC20Transfer(IERC20(token_), to_, value_)
        ) return;

        revert Transferable__TransferFailed();
    }

    /**
     * @dev Reverts the transaction if the Ether transfer fails
     * @param to_ Address to transfer to
     * @param amount_ Amount of Ether to transfer
     */
    function _safeNativeTransfer(
        address to_,
        uint256 amount_,
        bytes memory data_
    ) internal virtual {
        __checkValidTransfer(to_, amount_);
        if (!_nativeTransfer(to_, amount_, data_))
            revert Transferable__TransferFailed();
    }

    function _safeERC20Transfer(
        IERC20 token_,
        address to_,
        uint256 amount_
    ) internal virtual {
        __checkValidTransfer(to_, amount_);
        if (!_ERC20Transfer(token_, to_, amount_))
            revert Transferable__TransferFailed();
    }

    function _safeERC20TransferFrom(
        IERC20 token_,
        address from_,
        address to_,
        uint256 amount_
    ) internal virtual {
        __checkValidTransfer(to_, amount_);

        if (!_ERC20TransferFrom(token_, from_, to_, amount_))
            revert Transferable__TransferFailed();
    }

    function _nativeTransfer(
        address to_,
        uint256 amount_,
        bytes memory data_
    ) internal virtual returns (bool success) {
        /// @solidity memory-safe-assembly
        assembly {
            // Transfer the ETH and store if it succeeded or not.
            success := call(
                gas(),
                to_,
                amount_,
                add(data_, 32),
                mload(data_),
                0,
                0
            )
        }
    }

    function _ERC20Transfer(
        IERC20 token_,
        address to_,
        uint256 value_
    ) internal virtual returns (bool success) {
        assembly {
            // Get a pointer to some free memory.
            let freeMemoryPointer := mload(0x40)

            // Write the abi-encoded calldata into memory, beginning with the function selector.
            mstore(
                freeMemoryPointer,
                0xa9059cbb00000000000000000000000000000000000000000000000000000000
            )
            mstore(add(freeMemoryPointer, 4), to_) // Append the "to" argument.
            mstore(add(freeMemoryPointer, 36), value_) // Append the "amount" argument.

            success := and(
                or(
                    and(eq(mload(0), 1), gt(returndatasize(), 31)),
                    iszero(returndatasize())
                ),
                call(gas(), token_, 0, freeMemoryPointer, 68, 0, 32)
            )
        }
    }

    function _ERC20TransferFrom(
        IERC20 token_,
        address from_,
        address to_,
        uint256 value_
    ) internal virtual returns (bool success) {
        assembly {
            let freeMemoryPointer := mload(0x40)

            mstore(
                freeMemoryPointer,
                0x23b872dd00000000000000000000000000000000000000000000000000000000
            )
            mstore(add(freeMemoryPointer, 4), from_)
            mstore(add(freeMemoryPointer, 36), to_)
            mstore(add(freeMemoryPointer, 68), value_)

            success := and(
                or(
                    and(eq(mload(0), 1), gt(returndatasize(), 31)),
                    iszero(returndatasize())
                ),
                call(gas(), token_, 0, freeMemoryPointer, 100, 0, 32)
            )
        }
    }

    function __checkValidTransfer(address to_, uint256 value_) private pure {
        if (value_ == 0 || to_ == address(0))
            revert Transferable__InvalidArguments();
    }
}


// File: oz-custom/contracts/libraries/ErrorHandler.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

error ErrorHandler__ExecutionFailed();

library ErrorHandler {
    function handleRevertIfNotSuccess(
        bool ok_,
        bytes memory revertData_
    ) internal pure {
        assembly {
            if iszero(ok_) {
                let revertLength := mload(revertData_)
                if iszero(iszero(revertLength)) {
                    // Start of revert data bytes. The 0x20 offset is always the same.
                    revert(add(revertData_, 0x20), revertLength)
                }

                //  revert ErrorHandler__ExecutionFailed()
                mstore(0x00, 0xa94eec76)
                revert(0x1c, 0x04)
            }
        }
    }
}


// File: oz-custom/contracts/libraries/Roles.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

library Roles {
    bytes32 public constant PROXY_ROLE =
        0x77d72916e966418e6dc58a19999ae9934bef3f749f1547cde0a86e809f19c89b;
    bytes32 public constant SIGNER_ROLE =
        0xe2f4eaae4a9751e85a3e4a7b9587827a877f29914755229b07a7b2da98285f70;
    bytes32 public constant PAUSER_ROLE =
        0x65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a;
    bytes32 public constant MINTER_ROLE =
        0x9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6;
    bytes32 public constant OPERATOR_ROLE =
        0x97667070c54ef182b0f5858b034beac1b6f3089aa2d3188bb1e8929f4fa9b929;
    bytes32 public constant UPGRADER_ROLE =
        0x189ab7a9244df0848122154315af71fe140f3db0fe014031783b0946b8c9d2e3;
    bytes32 public constant TREASURER_ROLE =
        0x3496e2e73c4d42b75d702e60d9e48102720b8691234415963a5a857b86425d07;
    bytes32 public constant FACTORY_ROLE =
        0xdfbefbf47cfe66b701d8cfdbce1de81c821590819cb07e71cb01b6602fb0ee27;
}


// File: oz-custom/contracts/oz/access/IAccessControl.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)

pragma solidity ^0.8.17;

/**
 * @dev External interface of AccessControl declared to support ERC165 detection.
 */
interface IAccessControl {
    error AccessControl__Unauthorized();
    error AccessControl__RoleMissing(bytes32 role, address account);
    /**
     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`
     *
     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
     * {RoleAdminChanged} not being emitted signaling this.
     *
     * _Available since v3.1._
     */
    event RoleAdminChanged(
        bytes32 indexed role,
        bytes32 indexed previousAdminRole,
        bytes32 indexed newAdminRole
    );

    /**
     * @dev Emitted when `account` is granted `role`.
     *
     * `sender` is the account that originated the contract call, an admin role
     * bearer except when using {AccessControl-_setupRole}.
     */
    event RoleGranted(
        bytes32 indexed role,
        address indexed account,
        address indexed sender
    );

    /**
     * @dev Emitted when `account` is revoked `role`.
     *
     * `sender` is the account that originated the contract call:
     *   - if using `revokeRole`, it is the admin role bearer
     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
     */
    event RoleRevoked(
        bytes32 indexed role,
        address indexed account,
        address indexed sender
    );

    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(
        bytes32 role,
        address account
    ) external view returns (bool);

    /**
     * @dev Returns the admin role that controls `role`. See {grantRole} and
     * {revokeRole}.
     *
     * To change a role's admin, use {AccessControl-_setRoleAdmin}.
     */
    function getRoleAdmin(bytes32 role) external view returns (bytes32);

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function grantRole(bytes32 role, address account) external;

    /**
     * @dev Revokes `role` from `account`.
     *
     * If `account` had been granted `role`, emits a {RoleRevoked} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function revokeRole(bytes32 role, address account) external;

    /**
     * @dev Revokes `role` from the calling account.
     *
     * Roles are often managed via {grantRole} and {revokeRole}: this function's
     * purpose is to provide a mechanism for accounts to lose their privileges
     * if they are compromised (such as when a trusted device is misplaced).
     *
     * If the calling account had been granted `role`, emits a {RoleRevoked}
     * event.
     *
     * Requirements:
     *
     * - the caller must be `account`.
     */
    function renounceRole(bytes32 role, address account) external;

    function DEFAULT_ADMIN_ROLE() external pure returns (bytes32);
}


// File: oz-custom/contracts/oz/security/Pausable.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)

pragma solidity ^0.8.17;

import {Context} from "../utils/Context.sol";

interface IPausable {
    error Pausable__Paused();
    error Pausable__NotPaused();

    /**
     * @dev Emitted when the pause is triggered by `account`.
     */
    event Paused(address indexed account);

    /**
     * @dev Emitted when the pause is lifted by `account`.
     */
    event Unpaused(address indexed account);

    /**
     * @dev Pauses all functions in the contract. Only callable by accounts with the PAUSER_ROLE.
     */
    function pause() external;

    /**
     * @dev Unpauses all functions in the contract. Only callable by accounts with the PAUSER_ROLE.
     */
    function unpause() external;

    function paused() external view returns (bool isPaused);
}

/**
 * @dev Contract module which allows children to implement an emergency stop
 * mechanism that can be triggered by an authorized account.
 *
 * This module is used through inheritance. It will make available the
 * modifiers `whenNotPaused` and `whenPaused`, which can be applied to
 * the functions of your contract. Note that they will not be pausable by
 * simply including this module, only once the modifiers are put in place.
 */
abstract contract Pausable is Context, IPausable {
    uint256 private __paused;

    /**
     * @dev Initializes the contract in unpaused state.
     */
    constructor() payable {
        assembly {
            sstore(__paused.slot, 1)
        }
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     *
     * Requirements:
     *
     * - The contract must not be paused.
     */
    modifier whenNotPaused() {
        _requireNotPaused();
        _;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is paused.
     *
     * Requirements:
     *
     * - The contract must be paused.
     */
    modifier whenPaused() {
        _requirePaused();
        _;
    }

    /**
     * @dev Returns true if the contract is paused, and false otherwise.
     */
    function paused() public view virtual returns (bool isPaused) {
        assembly {
            isPaused := eq(2, sload(__paused.slot))
        }
    }

    /**
     * @dev Throws if the contract is paused.
     */
    function _requireNotPaused() internal view virtual {
        assembly {
            if eq(2, sload(__paused.slot)) {
                mstore(0x00, 0x059519da)
                revert(0x1c, 0x04)
            }
        }
    }

    /**
     * @dev Throws if the contract is not paused.
     */
    function _requirePaused() internal view virtual {
        assembly {
            if eq(1, sload(__paused.slot)) {
                mstore(0x00, 0x59488a5a)
                revert(0x1c, 0x04)
            }
        }
    }

    /**
     * @dev Triggers stopped state.
     *
     * Requirements:
     *
     * - The contract must not be paused.
     */
    function _pause() internal virtual whenNotPaused {
        address sender = _msgSender();
        assembly {
            sstore(__paused.slot, 2)
            log2(
                0,
                0,
                /// @dev value is equal to keccak256("Paused(address)")
                0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258,
                sender
            )
        }
    }

    /**
     * @dev Returns to normal state.
     *
     * Requirements:
     *
     * - The contract must be paused.
     */
    function _unpause() internal virtual whenPaused {
        address sender = _msgSender();
        assembly {
            sstore(__paused.slot, 1)
            log2(
                0,
                0,
                /// @dev value is equal to keccak256("Unpaused(address)")
                0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa,
                sender
            )
        }
    }
}


// File: oz-custom/contracts/oz/security/ReentrancyGuard.sol
// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity >=0.8.10;

error ReentrancyGuard__Locked();

abstract contract ReentrancyGuard {
    uint256 private __locked;

    modifier nonReentrant() {
        __nonReentrantBefore();
        _;
        __nonReentrantAfter();
    }

    constructor() payable {
        assembly {
            sstore(__locked.slot, 1)
        }
    }

    function __nonReentrantBefore() private {
        assembly {
            if eq(sload(__locked.slot), 2) {
                mstore(0x00, 0xc0d27a97)
                revert(0x1c, 0x04)
            }
            sstore(__locked.slot, 2)
        }
    }

    function __nonReentrantAfter() private {
        assembly {
            sstore(__locked.slot, 1)
        }
    }
}


// File: oz-custom/contracts/oz/token/ERC20/extensions/draft-IERC20Permit.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)

pragma solidity ^0.8.17;

import {IERC20Permit} from "./IERC20Permit.sol";


// File: oz-custom/contracts/oz/token/ERC20/extensions/IERC20Permit.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)

pragma solidity ^0.8.17;

import {IERC20} from "../IERC20.sol";

/**
 * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
 * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
 *
 * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
 * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't
 * need to send a transaction, and thus is not required to hold Ether at all.
 */
interface IERC20Permit is IERC20 {
    error ERC20Permit__Expired();

    /**
     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,
     * given ``owner``'s signed approval.
     *
     * IMPORTANT: The same issues {IERC20-approve} has related to transaction
     * ordering also apply here.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `deadline` must be a timestamp in the future.
     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
     * over the EIP712-formatted function arguments.
     * - the signature must use ``owner``'s current nonce (see {nonces}).
     *
     * For more information on the signature format, see the
     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
     * section].
     */
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    /**
     * @dev Returns the current nonce for `owner`. This value must be
     * included whenever a signature is generated for {permit}.
     *
     * Every successful call to {permit} increases ``owner``'s nonce by one. This
     * prevents a signature from being used multiple times.
     */
    function nonces(address owner) external view returns (uint256);

    /**
     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.
     */
    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32);
}


// File: oz-custom/contracts/oz/token/ERC20/IERC20.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    error ERC20__StringTooLong();
    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(
        address owner,
        address spender
    ) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `from` to `to` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
}


// File: oz-custom/contracts/oz/token/ERC721/ERC721.sol
// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity >=0.8.10;

import {Context} from "../../utils/Context.sol";
import {ERC165, IERC165} from "../../utils/introspection/ERC165.sol";
import {BitMaps} from "../../utils/structs/BitMaps.sol";
import {IERC721} from "./IERC721.sol";
import {IERC721Metadata} from "./extensions/IERC721Metadata.sol";

/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.
/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)
abstract contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {
    /*//////////////////////////////////////////////////////////////
                         METADATA STORAGE/LOGIC
    //////////////////////////////////////////////////////////////*/

    string public name;
    string public symbol;

    function _baseURI() internal view virtual returns (string memory);

    function tokenURI(uint256 id) public view virtual returns (string memory);

    /*//////////////////////////////////////////////////////////////
                      ERC721 BALANCE/OWNER STORAGE
    //////////////////////////////////////////////////////////////*/

    mapping(uint256 => bytes32) internal _ownerOf;
    mapping(address => uint256) internal _balanceOf;

    function ownerOf(
        uint256 id
    ) public view virtual override returns (address owner) {
        assembly {
            mstore(0x00, id)
            mstore(0x20, _ownerOf.slot)
            owner := sload(keccak256(0x00, 0x40))

            if iszero(owner) {
                // Store the function selector of `ERC721__NotMinted()`.
                // Revert with (offset, size).
                mstore(0x00, 0xf2c8ced6)
                revert(0x1c, 0x04)
            }
        }
    }

    function balanceOf(
        address owner
    ) public view virtual override returns (uint256 balance_) {
        assembly {
            if iszero(owner) {
                // Store the function selector of `ERC721__NonZeroAddress()`.
                // Revert with (offset, size).
                mstore(0x00, 0xf8a06d80)
                revert(0x1c, 0x04)
            }

            // balance_ = _balanceOf[owner]
            mstore(0x00, owner)
            mstore(0x20, _balanceOf.slot)
            balance_ := sload(keccak256(0x00, 0x40))
        }
    }

    /*//////////////////////////////////////////////////////////////
                         ERC721 APPROVAL STORAGE
    //////////////////////////////////////////////////////////////*/

    mapping(uint256 => bytes32) internal _getApproved;
    mapping(address => BitMaps.BitMap) internal _isApprovedForAll;

    /*//////////////////////////////////////////////////////////////
                               CONSTRUCTOR
    //////////////////////////////////////////////////////////////*/

    constructor(string memory _name, string memory _symbol) payable {
        if (bytes(_name).length > 32 || bytes(_symbol).length > 32)
            revert ERC721__StringTooLong();

        name = _name;
        symbol = _symbol;
    }

    /*//////////////////////////////////////////////////////////////
                              ERC721 LOGIC
    //////////////////////////////////////////////////////////////*/

    function approve(address spender, uint256 id) public virtual {
        address sender = _msgSender();
        assembly {
            /// @dev owner = _ownerOf[id]
            mstore(0x00, id)
            mstore(0x20, _ownerOf.slot)
            let owner := sload(keccak256(0x00, 0x40))

            /// @dev if (sender != owner)
            if iszero(eq(sender, owner)) {
                // check whether sender has approval for all id of owner
                mstore(0x00, owner)
                mstore(0x20, _isApprovedForAll.slot)
                // store _isApprovedForAll[owner] key at 0x20
                mstore(0x20, keccak256(0x00, 0x40))
                // override last 248 bit of sender as index to 0x00 for hashing
                mstore(0x00, shr(0x08, sender))

                // revert if the approved bit is not set
                if iszero(
                    and(
                        sload(keccak256(0x00, 0x40)),
                        shl(and(sender, 0xff), 0x01)
                    )
                ) {
                    // Store the function selector of `ERC721__Unauthorized()`.
                    // Revert with (offset, size).
                    mstore(0x00, 0x1fad8706)
                    revert(0x1c, 0x04)
                }
            }

            //  _getApproved[id] = spender
            mstore(0x00, id)
            mstore(0x20, _getApproved.slot)
            sstore(keccak256(0x00, 0x40), spender)

            // emit Approval(owner, spender, id)
            log4(
                0x00,
                0x00,
                /// @dev value is equal to keccak256("Approval(address,address,uint256)")
                0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925,
                owner,
                spender,
                id
            )
        }
    }

    function setApprovalForAll(
        address operator,
        bool approved
    ) public virtual {
        address sender = _msgSender();
        assembly {
            //  _isApprovedForAll[sender].setTo(operator, approved)
            mstore(0, sender)
            mstore(32, _isApprovedForAll.slot)
            mstore(32, keccak256(0, 64))
            mstore(0, shr(8, operator))

            let mapKey := keccak256(0, 64)
            let value := sload(mapKey)

            // The following sets the bit at `shift` without branching.
            let shift := and(operator, 0xff)
            // Isolate the bit at `shift`.
            let x := and(shr(shift, value), 1)
            // Xor it with `shouldSet`. Results in 1 if both are different, else 0.
            x := xor(x, approved)
            // Shifts the bit back. Then, xor with value.
            // Only the bit at `shift` will be flipped if they differ.
            // Every other bit will stay the same, as they are xor'ed with zeroes.
            value := xor(value, shl(shift, x))

            sstore(mapKey, value)

            //  emit ApprovalForAll(sender, operator, approved)
            mstore(0x00, approved)

            log3(
                0x00,
                0x20,
                /// @dev value is equal to keccak256("ApprovalForAll(address,address,bool)")
                0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31,
                sender,
                operator
            )
        }
    }

    function getApproved(
        uint256 tokenId
    ) external view returns (address approval) {
        assembly {
            mstore(0x00, tokenId)
            mstore(0x20, _getApproved.slot)
            approval := sload(keccak256(0x00, 0x40))
        }
    }

    function isApprovedForAll(
        address owner,
        address operator
    ) external view returns (bool approved) {
        assembly {
            mstore(0x00, owner)
            mstore(0x20, _isApprovedForAll.slot)
            mstore(0x20, keccak256(0x00, 0x40))
            mstore(0x00, shr(0x08, operator))
            approved := and(
                sload(keccak256(0x00, 0x40)),
                shl(and(operator, 0xff), 1)
            )
        }
    }

    function _isApprovedOrOwner(
        address spender,
        uint256 tokenId
    ) internal view virtual returns (bool isApprovedOrOwner_) {
        address owner = ownerOf(tokenId);
        assembly {
            // if spender is owner
            if eq(spender, owner) {
                isApprovedOrOwner_ := true
            }

            if iszero(isApprovedOrOwner_) {
                // if _getApproved[tokenId] == spender
                mstore(0x00, tokenId)
                mstore(0x20, _getApproved.slot)
                let approved := sload(keccak256(0x00, 0x40))
                if eq(approved, spender) {
                    isApprovedOrOwner_ := true
                }

                if iszero(isApprovedOrOwner_) {
                    // if _isApprovedForAll[owner][spender] == true
                    mstore(0x00, owner)
                    mstore(0x20, _isApprovedForAll.slot)
                    // store _isApprovedForAll[owner] key at 0x20
                    mstore(0x20, keccak256(0x00, 0x40))

                    // store last 248 bit of spender as index
                    mstore(0x00, shr(0x08, spender))

                    // check if the bit is turned in the bitmap
                    approved := and(
                        sload(keccak256(0x00, 0x40)),
                        shl(and(spender, 0xff), 1)
                    )

                    if approved {
                        isApprovedOrOwner_ := true
                    }
                }
            }
        }
    }

    /**
     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is
     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.
     *
     * Calling conditions:
     *
     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.
     * - When `from` is zero, the tokens will be minted for `to`.
     * - When `to` is zero, ``from``'s tokens will be burned.
     * - `from` and `to` are never both zero.
     * - `batchSize` is non-zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 /* firstTokenId */,
        uint256 batchSize
    ) internal virtual {
        assembly {
            if gt(batchSize, 1) {
                mstore(0x20, _balanceOf.slot)
                let key
                let balanceBefore
                if iszero(iszero(from)) {
                    mstore(0x00, from)
                    key := keccak256(0x00, 0x40)
                    balanceBefore := sload(key)
                    //  underflow check
                    if gt(balanceBefore, batchSize) {
                        revert(0, 0)
                    }
                    sstore(key, sub(balanceBefore, batchSize))
                }
                if iszero(iszero(to)) {
                    mstore(0x00, to)
                    key := keccak256(0x00, 0x40)
                    balanceBefore := sload(key)
                    //  overflow check
                    balanceBefore := add(balanceBefore, batchSize)
                    if lt(balanceBefore, batchSize) {
                        revert(0, 0)
                    }
                    sstore(key, balanceBefore)
                }
            }
        }
    }

    /**
     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is
     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.
     *
     * Calling conditions:
     *
     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.
     * - When `from` is zero, the tokens were minted for `to`.
     * - When `to` is zero, ``from``'s tokens were burned.
     * - `from` and `to` are never both zero.
     * - `batchSize` is non-zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _afterTokenTransfer(
        address from,
        address to,
        uint256 firstTokenId,
        uint256 batchSize
    ) internal virtual {}

    function transferFrom(
        address from,
        address to,
        uint256 id
    ) public virtual {
        _beforeTokenTransfer(from, to, id, 1);

        address sender = _msgSender();
        assembly {
            if iszero(to) {
                // Store the function selector of `ERC721__InvalidRecipient()`.
                // Revert with (offset, size).
                mstore(0x00, 0x28ede692)
                revert(0x1c, 0x04)
            }

            mstore(0x00, id)
            mstore(32, _ownerOf.slot)
            let ownerOfKey := keccak256(0, 64)

            if iszero(eq(from, sload(ownerOfKey))) {
                // Store the function selector of `ERC721__WrongFrom()`.
                // Revert with (offset, size).
                mstore(0x00, 0x0ef14eef)
                revert(0x1c, 0x04)
            }

            mstore(0x20, _getApproved.slot)
            let approvedKey := keccak256(0x00, 0x40)

            if iszero(eq(sender, from)) {
                if iszero(eq(sender, sload(approvedKey))) {
                    mstore(0x00, from)
                    mstore(0x20, _isApprovedForAll.slot)

                    mstore(0x20, keccak256(0x00, 0x40))
                    mstore(0x00, shr(0x08, sender))

                    if iszero(
                        and(sload(keccak256(0, 64)), shl(and(sender, 0xff), 1))
                    ) {
                        // Store the function selector of `ERC721__Unauthorized()`.
                        // Revert with (offset, size).
                        mstore(0x00, 0x1fad8706)
                        revert(0x1c, 0x04)
                    }
                }
            }

            // Underflow of the sender's balance is impossible because we check for
            // ownership above and the recipient's balance can't realistically

            //  ++_balanceOf[to];
            mstore(0x00, to)
            mstore(0x20, _balanceOf.slot)
            let key := keccak256(0x00, 0x40)
            let balanceBefore := add(1, sload(key))
            sstore(key, balanceBefore)

            //  --_balanceOf[from];
            mstore(0x00, from)
            key := keccak256(0x00, 0x40)
            balanceBefore := sub(sload(key), 1)
            sstore(key, balanceBefore)

            //  _ownerOf[id] = to
            sstore(ownerOfKey, to)
            //  delete _getApproved[id];
            sstore(approvedKey, 0)

            // emit Transfer(from, to, id);
            log4(
                0x00,
                0x00,
                /// @dev value is equal to keccak256("Transfer(address,address,uint256)")
                0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef,
                from,
                to,
                id
            )
        }

        _afterTokenTransfer(from, to, id, 1);
    }

    function safeTransferFrom(
        address from,
        address to,
        uint256 id
    ) public virtual {
        transferFrom(from, to, id);

        if (
            !(to.code.length == 0 ||
                ERC721TokenReceiver(to).onERC721Received(
                    _msgSender(),
                    from,
                    id,
                    ""
                ) ==
                ERC721TokenReceiver.onERC721Received.selector)
        ) revert ERC721__UnsafeRecipient();
    }

    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        bytes calldata data
    ) public virtual {
        transferFrom(from, to, id);

        if (
            !(to.code.length == 0 ||
                ERC721TokenReceiver(to).onERC721Received(
                    _msgSender(),
                    from,
                    id,
                    data
                ) ==
                ERC721TokenReceiver.onERC721Received.selector)
        ) revert ERC721__UnsafeRecipient();
    }

    function _transfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual {
        _beforeTokenTransfer(from, to, tokenId, 1);

        assembly {
            // if to == address(0) revert
            if iszero(to) {
                // Store the function selector of `ERC721__InvalidRecipient()`.
                // Revert with (offset, size).
                mstore(0x00, 0x28ede692)
                revert(0x1c, 0x04)
            }

            // cache tokenId at 0x00 for later use
            mstore(0x00, tokenId)
            mstore(0x20, _ownerOf.slot)
            let key := keccak256(0x00, 0x40)

            if iszero(eq(from, sload(key))) {
                // Store the function selector of `ERC721__WrongFrom()`.
                // Revert with (offset, size).
                mstore(0x00, 0x0ef14eef)
                revert(0x1c, 0x04)
            }

            //  _ownerOf[tokenId] = to
            sstore(key, to)

            //  emit Transfer(from, to, tokenId);
            log4(
                0x00,
                0x00,
                /// @dev value is equal to keccak256("Transfer(address,address,uint256)")
                0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef,
                from,
                to,
                tokenId
            )

            // delete _getApproved[tokenId];
            mstore(0x20, _getApproved.slot)
            mstore(keccak256(0x00, 0x40), 0)

            // ++_balanceOf[to]
            // cached _balanceOf slot for later use
            mstore(0x20, _balanceOf.slot)
            mstore(0x00, to)
            key := keccak256(0x00, 0x40)
            sstore(key, add(1, sload(key)))

            // --_balanceOf[from]
            mstore(0x00, from)
            key := keccak256(0x00, 0x40)
            sstore(key, sub(sload(key), 1))
        }

        _afterTokenTransfer(from, to, tokenId, 1);
    }

    /*//////////////////////////////////////////////////////////////
                              ERC165 LOGIC
    //////////////////////////////////////////////////////////////*/

    function supportsInterface(
        bytes4 interfaceId
    ) public view virtual override(ERC165, IERC165) returns (bool) {
        return
            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165
            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721
            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata
    }

    /*//////////////////////////////////////////////////////////////
                        INTERNAL MINT/BURN LOGIC
    //////////////////////////////////////////////////////////////*/

    function _mint(address to, uint256 id) internal virtual {
        _beforeTokenTransfer(address(0), to, id, 1);

        assembly {
            if iszero(to) {
                // Store the function selector of `ERC721__InvalidRecipient()`.
                // Revert with (offset, size).
                mstore(0x00, 0x28ede692)
                revert(0x1c, 0x04)
            }
            mstore(0, id)
            mstore(32, _ownerOf.slot)
            let key := keccak256(0, 64)
            /// @dev cachedVal = _ownerOf[id]
            let cachedVal := sload(key)

            /// @dev if (owner != 0) revert
            if iszero(iszero(cachedVal)) {
                mstore(0x00, 0xec125a85)
                revert(0x1c, 0x04)
            }

            /// @dev emit Transfer(address(0), to, id)
            log4(
                0x00,
                0x00,
                /// @dev value is equal to keccak256("Transfer(address,address,uint256)")
                0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef,
                0,
                to,
                id
            )

            /// @dev _ownerOf[id] = to
            sstore(key, to)

            mstore(0, to)
            mstore(32, _balanceOf.slot)
            key := keccak256(0, 64)
            /// @dev cachedVal = _balanceOf[to] + 1
            cachedVal := add(sload(key), 1)
            sstore(key, cachedVal)
        }

        _afterTokenTransfer(address(0), to, id, 1);
    }

    function _burn(uint256 id) internal virtual {
        bytes32 key;
        address owner;
        assembly {
            mstore(0x00, id)
            mstore(0x20, _ownerOf.slot)
            key := keccak256(0x00, 0x40)
            owner := sload(key)
            if iszero(owner) {
                // Store the function selector of `ERC721__NotMinted()`.
                // Revert with (offset, size).
                mstore(0x00, 0xf2c8ced6)
                revert(0x1c, 0x04)
            }
        }

        _beforeTokenTransfer(owner, address(0), id, 1);

        assembly {
            // delete _ownerOf[id]
            sstore(key, 0)

            //  delete _getApproved[id];
            mstore(0x00, id)
            mstore(0x20, _getApproved.slot)
            sstore(keccak256(0x00, 0x40), 0)

            //  emit Transfer(owner, address(0), id);
            log4(
                0x00,
                0x00,
                /// @dev value is equal to keccak256("Transfer(address,address,uint256)")
                0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef,
                owner,
                0,
                id
            )

            // Ownership check above ensures no underflow.
            //  --_balanceOf[owner]
            mstore(0x00, owner)
            mstore(0x20, _balanceOf.slot)
            key := keccak256(0x00, 0x40)
            sstore(key, sub(sload(key), 1))
        }

        _afterTokenTransfer(owner, address(0), id, 1);
    }

    /*//////////////////////////////////////////////////////////////
                        INTERNAL SAFE MINT LOGIC
    //////////////////////////////////////////////////////////////*/

    function _safeMint(address to, uint256 id) internal virtual {
        _mint(to, id);

        if (
            !(to.code.length == 0 ||
                ERC721TokenReceiver(to).onERC721Received(
                    _msgSender(),
                    address(0),
                    id,
                    ""
                ) ==
                ERC721TokenReceiver.onERC721Received.selector)
        ) revert ERC721__UnsafeRecipient();
    }

    function _safeMint(
        address to,
        uint256 id,
        bytes memory data
    ) internal virtual {
        _mint(to, id);

        if (
            !(to.code.length == 0 ||
                ERC721TokenReceiver(to).onERC721Received(
                    _msgSender(),
                    address(0),
                    id,
                    data
                ) ==
                ERC721TokenReceiver.onERC721Received.selector)
        ) revert ERC721__UnsafeRecipient();
    }
}

/// @notice A generic interface for a contract which properly accepts ERC721 tokens.
/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)
abstract contract ERC721TokenReceiver {
    function onERC721Received(
        address,
        address,
        uint256,
        bytes calldata
    ) external virtual returns (bytes4) {
        return ERC721TokenReceiver.onERC721Received.selector;
    }
}


// File: oz-custom/contracts/oz/token/ERC721/extensions/IERC721Enumerable.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)

pragma solidity ^0.8.17;

import {IERC721} from "../IERC721.sol";

/**
 * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension
 * @dev See https://eips.ethereum.org/EIPS/eip-721
 */
interface IERC721Enumerable is IERC721 {
    error ERC721Enumerable__OutOfBounds();
    error ERC721Enumerable__GlobalIndexOutOfBounds();
    error ERC721Enumerable__ConsecutiveTransferNotSupported();

    /**
     * @dev Returns the total amount of tokens stored by the contract.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.
     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.
     */
    function tokenOfOwnerByIndex(
        address owner,
        uint256 index
    ) external view returns (uint256);

    /**
     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.
     * Use along with {totalSupply} to enumerate all tokens.
     */
    function tokenByIndex(uint256 index) external view returns (uint256);
}


// File: oz-custom/contracts/oz/token/ERC721/extensions/IERC721Metadata.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)

pragma solidity ^0.8.17;

import {IERC721} from "../IERC721.sol";

/**
 * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
 * @dev See https://eips.ethereum.org/EIPS/eip-721
 */
interface IERC721Metadata is IERC721 {
    /**
     * @dev Returns the token collection name.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the token collection symbol.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
     */
    function tokenURI(uint256 tokenId) external view returns (string memory);
}


// File: oz-custom/contracts/oz/token/ERC721/IERC721.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)

pragma solidity ^0.8.17;

import {IERC165} from "../../utils/introspection/IERC165.sol";

/**
 * @dev Required interface of an ERC721 compliant contract.
 */
interface IERC721 is IERC165 {
    error ERC721__NotMinted();
    error ERC721__WrongFrom();
    error ERC721__Unauthorized();
    error ERC721__StringTooLong();
    error ERC721__AlreadyMinted();
    error ERC721__NonZeroAddress();
    error ERC721__UnsafeRecipient();
    error ERC721__InvalidRecipient();

    /**
     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
     */
    event Transfer(
        address indexed from,
        address indexed to,
        uint256 indexed tokenId
    );

    /**
     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
     */
    event Approval(
        address indexed owner,
        address indexed approved,
        uint256 indexed tokenId
    );

    /**
     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
     */
    event ApprovalForAll(
        address indexed owner,
        address indexed operator,
        bool approved
    );

    /**
     * @dev Returns the number of tokens in ``owner``'s account.
     */
    function balanceOf(address owner) external view returns (uint256 balance);

    /**
     * @dev Returns the owner of the `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function ownerOf(uint256 tokenId) external view returns (address owner);

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes calldata data
    ) external;

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
     * are aware of the ERC721 protocol to prevent tokens from being forever locked.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    /**
     * @dev Transfers `tokenId` token from `from` to `to`.
     *
     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address from, address to, uint256 tokenId) external;

    /**
     * @dev Gives permission to `to` to transfer `tokenId` token to another account.
     * The approval is cleared when the token is transferred.
     *
     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
     *
     * Requirements:
     *
     * - The caller must own the token or be an approved operator.
     * - `tokenId` must exist.
     *
     * Emits an {Approval} event.
     */
    function approve(address to, uint256 tokenId) external;

    /**
     * @dev Approve or remove `operator` as an operator for the caller.
     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
     *
     * Requirements:
     *
     * - The `operator` cannot be the caller.
     *
     * Emits an {ApprovalForAll} event.
     */
    function setApprovalForAll(address operator, bool _approved) external;

    /**
     * @dev Returns the account approved for `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function getApproved(
        uint256 tokenId
    ) external view returns (address operator);

    /**
     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
     *
     * See {setApprovalForAll}
     */
    function isApprovedForAll(
        address owner,
        address operator
    ) external view returns (bool);
}


// File: oz-custom/contracts/oz/utils/Context.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)

pragma solidity ^0.8.17;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address sender) {
        assembly {
            sender := caller()
        }
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}


// File: oz-custom/contracts/oz/utils/introspection/ERC165.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)

pragma solidity ^0.8.17;

import {IERC165} from "./IERC165.sol";

/**
 * @dev Implementation of the {IERC165} interface.
 *
 * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
 * for the additional interface id that will be supported. For example:
 *
 * ```solidity
 * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 * }
 * ```
 *
 * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
 */
abstract contract ERC165 is IERC165 {
    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(
        bytes4 interfaceId
    ) public view virtual override returns (bool) {
        return interfaceId == type(IERC165).interfaceId;
    }
}


// File: oz-custom/contracts/oz/utils/introspection/ERC165Checker.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165Checker.sol)

pragma solidity ^0.8.17;

import {IERC165} from "./IERC165.sol";

/**
 * @dev Library used to query support of an interface declared via {IERC165}.
 *
 * Note that these functions return the actual result of the query: they do not
 * `revert` if an interface is not supported. It is up to the caller to decide
 * what to do in these cases.
 */
library ERC165Checker {
    // As per the EIP-165 spec, no interface should ever match 0xffffffff
    bytes4 private constant __INTERFACE_ID_INVALID = 0xffffffff;

    /**
     * @dev Returns true if `account` supports the {IERC165} interface,
     */
    function supportsERC165(address account) internal view returns (bool) {
        // Any contract that implements ERC165 must explicitly indicate support of
        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid
        return
            supportsERC165InterfaceUnchecked(
                account,
                type(IERC165).interfaceId
            ) &&
            !supportsERC165InterfaceUnchecked(account, __INTERFACE_ID_INVALID);
    }

    /**
     * @dev Returns true if `account` supports the interface defined by
     * `interfaceId`. Support for {IERC165} itself is queried automatically.
     *
     * See {IERC165-supportsInterface}.
     */
    function supportsInterface(
        address account,
        bytes4 interfaceId
    ) internal view returns (bool) {
        // query support of both ERC165 as per the spec and support of _interfaceId
        return
            supportsERC165(account) &&
            supportsERC165InterfaceUnchecked(account, interfaceId);
    }

    /**
     * @dev Returns a boolean array where each value corresponds to the
     * interfaces passed in and whether they're supported or not. This allows
     * you to batch check interfaces for a contract where your expectation
     * is that some interfaces may not be supported.
     *
     * See {IERC165-supportsInterface}.
     *
     * _Available since v3.4._
     */
    function getSupportedInterfaces(
        address account,
        bytes4[] calldata interfaceIds
    ) internal view returns (bool[] memory interfaceIdsSupported) {
        uint256 length = interfaceIds.length;

        // an array of booleans corresponding to interfaceIds and whether they're supported or not
        interfaceIdsSupported = new bool[](length);

        // query support of ERC165 itself
        if (supportsERC165(account)) {
            // query support of each interface in interfaceIds
            for (uint256 i; i < length; ) {
                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(
                    account,
                    interfaceIds[i]
                );
                unchecked {
                    ++i;
                }
            }
        }
    }

    /**
     * @dev Returns true if `account` supports all the interfaces defined in
     * `interfaceIds`. Support for {IERC165} itself is queried automatically.
     *
     * Batch-querying can lead to gas savings by skipping repeated checks for
     * {IERC165} support.
     *
     * See {IERC165-supportsInterface}.
     */
    function supportsAllInterfaces(
        address account,
        bytes4[] calldata interfaceIds
    ) internal view returns (bool) {
        // query support of ERC165 itself
        if (!supportsERC165(account)) return false;

        uint256 length = interfaceIds.length;
        // query support of each interface in _interfaceIds
        for (uint256 i; i < length; ) {
            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i]))
                return false;

            unchecked {
                ++i;
            }
        }

        // all interfaces supported
        return true;
    }

    /**
     * @notice Query if a contract implements an interface, does not check ERC165 support
     * @param account The address of the contract to query for support of an interface
     * @param interfaceId The interface identifier, as specified in ERC-165
     * @return true if the contract at account indicates support of the interface with
     * identifier interfaceId, false otherwise
     * @dev Assumes that account contains a contract that supports ERC165, otherwise
     * the behavior of this method is undefined. This precondition can be checked
     * with {supportsERC165}.
     * Interface identification is specified in ERC-165.
     */
    function supportsERC165InterfaceUnchecked(
        address account,
        bytes4 interfaceId
    ) internal view returns (bool) {
        (bool success, bytes memory result) = account.staticcall{gas: 30000}(
            abi.encodeCall(IERC165.supportsInterface, (interfaceId))
        );
        if (result.length < 32) return false;
        return success && abi.decode(result, (bool));
    }
}


// File: oz-custom/contracts/oz/utils/introspection/IERC165.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)

pragma solidity ^0.8.17;

/**
 * @dev Interface of the ERC165 standard, as defined in the
 * https://eips.ethereum.org/EIPS/eip-165[EIP].
 *
 * Implementers can declare support of contract interfaces, which can then be
 * queried by others ({ERC165Checker}).
 *
 * For an implementation, see {ERC165}.
 */
interface IERC165 {
    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30 000 gas.
     */
    function supportsInterface(
        bytes4 interfaceId
    ) external view returns (bool);
}


// File: oz-custom/contracts/oz/utils/structs/BitMaps.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/structs/BitMaps.sol)
pragma solidity ^0.8.17;

/**
 * @dev Library for managing uint256 to bool mapping in a compact and efficient way, providing the keys are sequential.
 * Largelly inspired by Uniswap's https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol[merkle-distributor].
 */
library BitMaps {
    struct BitMap {
        mapping(uint256 => uint256) map;
    }

    /**
     * @dev Returns whether the bit at `index` is set.
     */
    function get(
        BitMap storage bitmap,
        uint256 index
    ) internal view returns (bool isSet) {
        assembly {
            mstore(0, shr(8, index))
            mstore(32, bitmap.slot)
            // Assign isSet to whether the value is non zero.
            isSet := and(sload(keccak256(0, 64)), shl(and(index, 0xff), 1))
        }
    }

    /**
     * @dev Sets the bit at `index` to the boolean `value`.
     */
    function setTo(
        BitMap storage bitmap,
        uint256 index,
        bool shouldSet
    ) internal {
        assembly {
            mstore(0, shr(8, index))
            mstore(32, bitmap.slot)
            let mapKey := keccak256(0, 64)
            let value := sload(mapKey)

            // The following sets the bit at `shift` without branching.
            let shift := and(index, 0xff)
            // Isolate the bit at `shift`.
            let x := and(shr(shift, value), 1)
            // Xor it with `shouldSet`. Results in 1 if both are different, else 0.
            x := xor(x, shouldSet)
            // Shifts the bit back. Then, xor with value.
            // Only the bit at `shift` will be flipped if they differ.
            // Every other bit will stay the same, as they are xor'ed with zeroes.
            value := xor(value, shl(shift, x))

            sstore(mapKey, value)
        }
    }

    /**
     * @dev Sets the bit at `index`.
     */
    function set(BitMap storage bitmap, uint256 index) internal {
        assembly {
            mstore(0, shr(8, index))
            mstore(32, bitmap.slot)
            let key := keccak256(0, 64)
            let value := sload(key)
            value := or(value, shl(and(index, 0xff), 1))
            sstore(key, value)
        }
    }

    function setBatch(
        BitMap storage bitmap_,
        uint256[] calldata values_
    ) internal {
        assembly {
            let length := values_.length
            let i := add(calldataload(values_.offset), 0x20)
            mstore(0x20, bitmap_.slot)
            for {
                let end := add(i, shl(5, length))
            } lt(i, end) {
                i := add(i, 0x20)
            } {
                mstore(0x00, shr(8, mload(i)))
                let key := keccak256(0x00, 0x40)
                sstore(key, or(sload(key), shl(and(mload(i), 0xff), 1)))
            }
        }
    }

    /**
     * @dev Unsets the bit at `index`.
     */
    function unset(BitMap storage bitmap, uint256 index) internal {
        bitmap.map[index >> 8] &= ~(1 << (index & 0xff));
    }
}


// File: oz-custom/contracts/presets/base/interfaces/IManager.sol
//SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import {IAuthority} from "../../interfaces/IAuthority.sol";

interface IManager {
    error Manager__Paused();
    error Manager__NotPaused();
    error Manager__AlreadySet();
    error Manager__Blacklisted();
    error Manager__Unauthorized();
    error Manager__RequestFailed();
    error Manager__InvalidArgument();
    error Manager__ExecutionFailed();

    event AuthorityUpdated(
        address indexed operator,
        IAuthority indexed from,
        IAuthority indexed to
    );
    event RequestRoleCached(address indexed operator, bytes32 indexed role);

    /**
     * @notice Updates the authority of this contract. This can only be done by an operator.
     * @param authority_ The new authority contract.
     * @dev The authority contract must allow this contract to have the role specified in the constructor.
     * @custom:throws Manager__AlreadySet if the new authority is the same as the current authority.
     * @custom:throws Manager__RequestFailed if the request to the new authority contract fails.
     */
    function updateAuthority(IAuthority authority_) external;

    /**
     * @notice Returns the authority contract of this contract.
     * @return authority_ is The address of the authority contract.
     */
    function authority() external view returns (IAuthority authority_);
}


// File: oz-custom/contracts/presets/base/Manager.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import {Context} from "../../oz/utils/Context.sol";

import {ProxyChecker} from "../../internal/ProxyChecker.sol";

import {IManager, IAuthority} from "./interfaces/IManager.sol";
import {IPausable} from "../../oz/security/Pausable.sol";
import {IAccessControl} from "../../oz/access/IAccessControl.sol";
import {IBlacklistable} from "../../internal/interfaces/IBlacklistable.sol";

import {Roles} from "../../libraries/Roles.sol";
import {ErrorHandler} from "../../libraries/ErrorHandler.sol";

import {ERC165Checker} from "../../oz/utils/introspection/ERC165Checker.sol";

abstract contract Manager is Context, IManager, ProxyChecker {
    using ErrorHandler for bool;
    using ERC165Checker for address;

    bytes32 private __authority;
    bytes32 private __requestedRole;

    modifier onlyRole(bytes32 role) {
        _checkRole(role, _msgSender());
        _;
    }

    modifier onlyWhitelisted() {
        _checkBlacklist(_msgSender());
        _;
    }

    modifier whenNotPaused() {
        _requireNotPaused();
        _;
    }

    modifier whenPaused() {
        _requirePaused();
        _;
    }

    constructor(IAuthority authority_, bytes32 role_) payable {
        __checkAuthority(address(authority_));

        assembly {
            sstore(__requestedRole.slot, role_)
        }
        address sender = _msgSender();
        emit RequestRoleCached(sender, role_);

        (bool ok, bytes memory revertData) = address(authority_).call(
            abi.encodeCall(IAuthority.requestAccess, (role_))
        );

        ok.handleRevertIfNotSuccess(revertData);

        __updateAuthority(authority_);
        emit AuthorityUpdated(sender, IAuthority(address(0)), authority_);
    }

    /// @inheritdoc IManager
    function updateAuthority(
        IAuthority authority_
    ) external onlyRole(Roles.OPERATOR_ROLE) {
        __checkAuthority(address(authority_));

        IAuthority old = authority();
        if (old == authority_) revert Manager__AlreadySet();
        (bool ok, bytes memory revertData) = address(authority_).call(
            abi.encodeCall(IAuthority.requestAccess, (__requestedRole))
        );

        ok.handleRevertIfNotSuccess(revertData);

        __updateAuthority(authority_);

        emit AuthorityUpdated(_msgSender(), old, authority_);
    }

    /// @inheritdoc IManager
    function authority() public view returns (IAuthority) {
        return IAuthority(_authority());
    }

    /**
     * @notice Returns the address of the authority contract, for internal use.
     * @dev This function is for internal use only and should not be called by external contracts.
     * @return authority_ is the address of the authority contract.
     */
    function _authority() internal view returns (address authority_) {
        /// @solidity memory-safe-assembly
        assembly {
            authority_ := sload(__authority.slot)
        }
    }

    /**
     * @notice Checks if the given account is blacklisted by the authority contract.
     * @param account_ The address to check for blacklisting.
     * @dev This function should be called before allowing the given account to perform certain actions.
     * @custom:throws Manager__Blacklisted if the given account is blacklisted.
     */
    function _checkBlacklist(address account_) internal view {
        (bool ok, bytes memory returnOrRevertData) = _authority().staticcall(
            abi.encodeCall(IBlacklistable.isBlacklisted, (account_))
        );

        ok.handleRevertIfNotSuccess(returnOrRevertData);

        if (abi.decode(returnOrRevertData, (bool)))
            revert Manager__Blacklisted();
    }

    function _checkBlacklistMulti(address[] memory accounts_) internal view {
        (bool ok, bytes memory returnOrRevertData) = _authority().staticcall(
            abi.encodeCall(IBlacklistable.areBlacklisted, (accounts_))
        );

        ok.handleRevertIfNotSuccess(returnOrRevertData);

        if (abi.decode(returnOrRevertData, (bool)))
            revert Manager__Blacklisted();
    }

    /**
     * @notice Checks if the given account has the given role.
     * @param role_ The role to check for.
     * @param account_ The address to check for the role.
     * @dev This function should be called before allowing the given account to perform certain actions.
     * @custom:throws Manager__Unauthorized if the given account does not have the given role.
     */
    function _checkRole(bytes32 role_, address account_) internal view {
        if (!_hasRole(role_, account_)) revert Manager__Unauthorized();
    }

    function __updateAuthority(IAuthority authority_) internal {
        /// @solidity memory-safe-assembly
        assembly {
            sstore(__authority.slot, authority_)
        }
    }

    function _requirePaused() internal view {
        (bool ok, bytes memory returnOrRevertData) = _authority().staticcall(
            abi.encodeCall(IPausable.paused, ())
        );

        ok.handleRevertIfNotSuccess(returnOrRevertData);

        if (!abi.decode(returnOrRevertData, (bool)))
            revert Manager__NotPaused();
    }

    function _requireNotPaused() internal view {
        (bool ok, bytes memory returnOrRevertData) = _authority().staticcall(
            abi.encodeCall(IPausable.paused, ())
        );
        ok.handleRevertIfNotSuccess(returnOrRevertData);

        if (abi.decode(returnOrRevertData, (bool))) revert Manager__Paused();
    }

    function _hasRole(
        bytes32 role_,
        address account_
    ) internal view returns (bool) {
        (bool ok, bytes memory returnOrRevertData) = _authority().staticcall(
            abi.encodeCall(IAccessControl.hasRole, (role_, account_))
        );

        ok.handleRevertIfNotSuccess(returnOrRevertData);

        return abi.decode(returnOrRevertData, (bool));
    }

    function __checkAuthority(address authority_) private view {
        if (
            authority_ == address(0) ||
            !_isProxy(authority_) ||
            !authority_.supportsInterface(type(IAuthority).interfaceId)
        ) revert Manager__InvalidArgument();
    }
}


// File: oz-custom/contracts/presets/interfaces/IAuthority.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

interface IAuthority {
    error Authority__InvalidRole();
    error Authority__LengthMismatch();

    event VaultMultiUpdated(
        address indexed operator,
        address indexed vault,
        bool[] success
    );

    event ProxyAccessGranted(address indexed operator, address indexed proxy);

    /**
     * @dev Sets the admin of the specified role to the specified admin role.
     * @param role bytes32 representing the role to set the admin of
     * @param adminRole bytes32 representing the role to set as the admin of the role
     */
    function setRoleAdmin(bytes32 role, bytes32 adminRole) external;

    /**
     * @dev Allows a user to request access to the contract as a proxy.
     * Only callable by accounts with the OPERATOR_ROLE and only if the sender is a proxy of the caller.
     * Grants the PROXY_ROLE and the specified role to the sender.
     * @param role bytes32 representing the role to grant to the sender in addition to the PROXY_ROLE
     */
    function requestAccess(bytes32 role) external;
}


// File: oz-custom/contracts/presets/interfaces/ITreasury.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

interface ITreasury {
    error Treasury__Expired();
    error Treasury__LengthMismatch();
    error Treasury__InvalidBalance();
    error Treasury__InvalidArgument();
    error Treasury__InvalidSignature();
    error Treasury__MistakenTransfer();
    error Treasury__InvalidTokenAddress();
    error Treasury__InvalidFunctionCall();
    error Treasury__UnauthorizedWithdrawal();

    event BalanceInitiated(address indexed operator, uint256 indexed balance);

    function withdraw(
        address token_,
        address to_,
        uint256 value_,
        uint256 amount_, // if withdraw ERC1155
        uint256 deadline_,
        bytes calldata signature_
    ) external;

    function nonces(address account_) external view returns (uint256);
}

