{"IERC20.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\ninterface IERC20 {\n\n    function totalSupply() external view returns (uint256);\n    \n    function symbol() external view returns(string memory);\n    \n    function name() external view returns(string memory);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n    \n    /**\n     * @dev Returns the number of decimal places\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"},"PhoenixReinvest.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\nimport \"./IERC20.sol\";\n\ninterface IMDBP is IERC20 {\n    function sell(uint256 tokenAmount) external returns (uint256);\n    function burn(uint256 amount) external;\n}\n\ninterface IPhoenix is IERC20 {\n    function mintWithBacking(uint256 numTokens, address recipient) external returns (uint256);\n}\n\ncontract PhoenixReinvest {\n\n    // Phoenix+ Contract Address\n    IPhoenix private constant phoenix = IPhoenix(0xfc62b18CAC1343bd839CcbEDB9FC3382a84219B9);\n\n    // MDB+ Contract Address\n    IMDBP private constant mdbp = IMDBP(0x9f8BB16f49393eeA4331A39B69071759e54e16ea);\n\n    // BUSD Contract Address\n    IERC20 public constant BUSD = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n\n    // User Info Structure\n    struct UserInfo {\n        uint256 minAmountToHold; // minimum amount of MDB+ that must be preserved in a users wallet\n        uint256 index; // index in the user array\n        bool isUser; // true if user wants to be reinvested, false otherwise\n    }\n\n    // User =\u003e User Info\n    mapping ( address =\u003e UserInfo ) public userInfo;\n\n    // List Of All Users\n    address[] public allUsers;\n\n    // Current index in users list\n    uint256 public currentSearchIndex;\n\n    // Loop through all users, triggering their reinvestment if applicable\n    function trigger(uint256 iterations) external {\n\n        for (uint i = 0; i \u003c iterations;) {\n\n            if (currentSearchIndex \u003e= allUsers.length) {\n                currentSearchIndex = 0;\n            }\n\n            if (canTriggerForUser(allUsers[currentSearchIndex])) {\n                _reinvest(allUsers[currentSearchIndex]);\n            } else {\n                if (!hasGivenAllowance(allUsers[currentSearchIndex], amountToRevinest(allUsers[currentSearchIndex]))) {\n                    _removeUser(allUsers[currentSearchIndex]);\n                }\n            }\n            unchecked { ++i; currentSearchIndex++; }\n        }\n    }\n\n    // Loop through user array passed in, triggering their reinvestment if applicable\n    function triggerForUsers(address[] calldata users) external {\n        uint length = users.length;\n\n        for (uint i = 0; i \u003c length;) {\n            if (canTriggerForUser(users[i])) {\n                _reinvest(users[i]);\n            } else {\n                if (!hasGivenAllowance(users[i], amountToRevinest(users[i]))) {\n                    _removeUser(users[i]);\n                }\n            }\n            unchecked { ++i; }\n        }\n    }\n\n    // opts into the system\n    function optIn(uint256 minAmountToHold) external {\n\n        // set minimum amount to hold\n        userInfo[msg.sender].minAmountToHold = minAmountToHold;\n\n        // add user to list if they have not been added before\n        if (userInfo[msg.sender].isUser == false) {\n            userInfo[msg.sender].isUser = true;\n            userInfo[msg.sender].index = allUsers.length;\n            allUsers.push(msg.sender);\n        }\n    }\n\n    function optOut() external {\n        _removeUser(msg.sender);\n    }\n\n\n\n    function _reinvest(address user) internal {\n\n        // amount to reinvest for user\n        uint256 amount = amountToRevinest(user);\n        if (amount == 0) {\n            return;\n        }\n\n        // transfer tokens from user into this contract\n        mdbp.transferFrom(user, address(this), amount);\n\n        // fetch new balance of tokens after transfer\n        uint256 balance = mdbp.balanceOf(address(this));\n        if (balance == 0) {\n            return;\n        }\n\n        // Burn 0.25%\n        uint256 toBurn = ( balance * 25 ) / 10**4;\n\n        // burn mdbp\n        mdbp.burn(toBurn);\n\n        // subtract to burn from balance\n        balance -= toBurn;\n        \n        // sell MDBP for BUSD\n        mdbp.sell(balance);\n\n        // Fetch Amount Of BUSD Received\n        uint256 busdBalance = BUSD.balanceOf(address(this));\n        if (busdBalance == 0) {\n            return;\n        }        \n\n        // Approve BUSD For Phoenix\n        BUSD.approve(address(phoenix), busdBalance);\n\n        // Mint Phoenix+ With BUSD For User\n        phoenix.mintWithBacking(busdBalance, user);\n    }\n    \n    function _removeUser(address user) internal {\n\n        if (userInfo[user].isUser == false) {\n            return;\n        }\n\n        // set users index to be last element\n        allUsers[\n            userInfo[user].index\n        ] = allUsers[allUsers.length - 1];\n\n        // set last elements index to be users\n        userInfo[\n            allUsers[allUsers.length - 1]\n        ].index = userInfo[user].index;\n\n        // pop last element off the end of the array\n        allUsers.pop();\n\n        // clear user data\n        delete userInfo[user];\n    }\n\n\n\n    function canTriggerForUser(address user) public view returns (bool) {\n        return userInfo[user].isUser \u0026\u0026 hasOverMinimumBalance(user) \u0026\u0026 hasGivenAllowance(user, amountToRevinest(user));\n    }\n\n    function amountToRevinest(address user) public view returns (uint256) {\n\n        uint balanceOfUser = mdbp.balanceOf(user);\n        uint minAmount = userInfo[user].minAmountToHold;\n\n        return ( balanceOfUser \u003e minAmount \u0026\u0026 userInfo[user].isUser ) ? balanceOfUser - minAmount : 0;\n    }\n\n    function hasOverMinimumBalance(address user) public view returns (bool) {\n        return mdbp.balanceOf(user) \u003e userInfo[user].minAmountToHold;\n    }\n\n    function hasGivenAllowance(address user, uint256 amount) public view returns (bool) {\n        return mdbp.allowance(user, address(this)) \u003e= amount;\n    }\n\n    function nUsers() external view returns (uint256) {\n        return allUsers.length;\n    }\n\n}"}}