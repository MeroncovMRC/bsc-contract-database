
// File: contracts/DoKENLocker.sol
// SPDX-License-Identifier: UNLICENSED

// This contract locks PancakeSwap liquidity tokens. Locked liquidity cannot be removed from PancakeSwap
// until the specified unlock date has been reached.

pragma solidity 0.8.6;

import "./libraries/SafeMath.sol";
import "./libraries/EnumerableSet.sol";
import "./libraries/IERC20.sol";
import "./libraries/SafeERC20.sol";
import "./libraries/Ownable.sol";
import "./libraries/ReentrancyGuard.sol";
import "./libraries/SafeMath.sol";
import "./libraries/IPancakeFactory.sol";
import "./libraries/IPancakePair.sol";
import "./IFeesCalculator.sol";
import "./libraries/IDoKENPadInfo.sol";
import "./libraries/IUniswapRouter.sol";
import "./libraries/IUniswapV2Factory.sol";

contract DoKENLocker is Ownable, ReentrancyGuard {
  using SafeMath for uint256;
  using SafeERC20 for IERC20;
  using EnumerableSet for EnumerableSet.UintSet;

  //IPancakeFactory public pancakeFactory;
  IFeesCalculator public feesCalculator;

  IERC20 public feeToken;
  address payable public feeReceiver;
  address private DoKENPadInfoAddress;

  struct TokenLock {
    address lpToken;
    address owner;
    uint256 tokenAmount;
    uint256 unlockTime;
    uint256 lockTime;
    address factoryPairAddress;
    uint256 lockId;
  }
  struct PairInfo {
    string tokenZeroName;
    string tokenZeroSymbol;
    address tokenZeroAddress;
    string tokenOneName;
    string tokenOneSymbol;
    address tokenOneAddress;
    uint256 amountInWei;
    address factoryPairAddress;
    address pairAddress;
    uint256[] lockIds;
  }

  uint256 public lockNonce = 0;

  mapping(uint256 => TokenLock) public tokenLocks;
  mapping(address => EnumerableSet.UintSet) private tokenLocksByPairAddress; // this use for keeping the ids of tokenlock by using its pair address
  mapping(address => EnumerableSet.UintSet) private userLocks; // this use for keeping the ids of tokenlock by using its user address
  address[] public pairAddresses; // use for collecting addresses of pair address
  mapping(address => bool) public supportedDex;

  event OnTokenLock(
    uint256 indexed lockId,
    address indexed tokenAddress,
    address indexed owner,
    uint256 amount,
    uint256 unlockTime
  );
  event OnTokenUnlock(uint256 indexed lockId);
  event OnLockWithdrawal(uint256 indexed lockId, uint256 amount);
  event OnLockAmountIncreased(uint256 indexed lockId, uint256 amount);
  event OnLockDurationIncreased(uint256 indexed lockId, uint256 newUnlockTime);
  event OnLockOwnershipTransferred(
    uint256 indexed lockId,
    address indexed newOwner
  );

  modifier onlyLockOwner(uint256 lockId) {
    TokenLock storage lock = tokenLocks[lockId];
    require(lock.owner == address(msg.sender), "NO ACTIVE LOCK OR NOT OWNER");
    _;
  }

  constructor(
    //IPancakeFactory _pancakeFactory,
    address _feesCalculator,
    address payable _feesReceiver,
    address _feeToken
  ) {
    //pancakeFactory = _pancakeFactory;
    feesCalculator = IFeesCalculator(_feesCalculator);
    feeReceiver = _feesReceiver;
    feeToken = IERC20(_feeToken);
  }

  /**
   * @notice locks pancake liquidity token until specified time
   * @param lpToken token address to lock
   * @param amount amount of tokens to lock
   * @param unlockTime unix time in seconds after that tokens can be withdrawn
   * @param withdrawer account that can withdraw tokens to it's balance
   * @param feePaymentMode 0 - pay fees in BNB + LP token,
   *                       1 - pay fees in DOKEN + LP token,
   *                       2 - pay fees fully in BNB,
   *                       3 - pay fees fully in DOKEN
   */
  function lockTokens(
    address _routerAddress,
    address lpToken,
    uint256 amount,
    uint256 unlockTime,
    address payable withdrawer,
    uint8 feePaymentMode
  ) external payable nonReentrant returns (uint256 _lockId) {
    require(amount > 0, "ZERO AMOUNT");
    require(lpToken != address(0), "ZERO TOKEN");
    require(unlockTime > block.timestamp, "UNLOCK TIME IN THE PAST");
    require(
      unlockTime < 10000000000,
      "INVALID UNLOCK TIME, MUST BE UNIX TIME IN SECONDS"
    );
    require(checkLpTokenIsPancake(lpToken, _routerAddress), "NOT PAIR ADDRESS");

    //pay fees, only if not from launchpad
    uint256 amountToLock;
    if (!IDoKENPadInfo(DoKENPadInfoAddress).isRegisteredLaunchpad(msg.sender)) {
      (uint256 ethFee, uint256 tokenFee, uint256 lpTokenFee) = feesCalculator
        .calculateFees(lpToken, amount, unlockTime, feePaymentMode);
      transferFees(lpToken, ethFee, tokenFee, lpTokenFee);
      if (msg.value > ethFee) {
        // transfer excess back
        transferBnb(msg.sender, msg.value.sub(ethFee));
      }
      amountToLock = amount.sub(lpTokenFee);
    } else {
      amountToLock = amount;
    }
    _lockId = lockNonce++;
    IUniswapV2Router02 router = IUniswapV2Router02(_routerAddress);

    TokenLock memory lock = TokenLock({
      lpToken: lpToken,
      owner: withdrawer,
      tokenAmount: amountToLock,
      unlockTime: unlockTime,
      lockTime: block.timestamp,
      factoryPairAddress: router.factory(),
      lockId: _lockId
    });

    tokenLocks[_lockId] = lock;

    userLocks[withdrawer].add(_lockId);
    if (tokenLocksByPairAddress[lpToken].length() < 1) {
      pairAddresses.push(lpToken);
    }
    tokenLocksByPairAddress[lpToken].add(_lockId);

    IERC20(lpToken).safeTransferFrom(msg.sender, address(this), amountToLock);
    emit OnTokenLock(_lockId, lpToken, withdrawer, amountToLock, unlockTime);
    return _lockId;
  }

  function checkLpTokenIsPancake(address lpToken, address _routerAddress)
    public
    view
    returns (bool)
  {
    require(supportedDex[_routerAddress], "Dex not supported");
    IUniswapV2Router02 router = IUniswapV2Router02(_routerAddress);
    IPancakePair pair = IPancakePair(lpToken);
    address factoryPair = IPancakeFactory(router.factory()).getPair(
      pair.token0(),
      pair.token1()
    );
    return factoryPair == lpToken;
  }

  /**
   * @notice increase unlock time of already locked tokens
   * @param newUnlockTime new unlock time (unix time in seconds)
   */
  function extendLockTime(uint256 lockId, uint256 newUnlockTime)
    external
    nonReentrant
    onlyLockOwner(lockId)
  {
    require(newUnlockTime > block.timestamp, "UNLOCK TIME IN THE PAST");
    require(
      newUnlockTime < 10000000000,
      "INVALID UNLOCK TIME, MUST BE UNIX TIME IN SECONDS"
    );
    TokenLock storage lock = tokenLocks[lockId];
    require(lock.unlockTime < newUnlockTime, "NOT INCREASING UNLOCK TIME");
    lock.unlockTime = newUnlockTime;
    emit OnLockDurationIncreased(lockId, newUnlockTime);
  }

  /**
   * @notice add tokens to an existing lock
   * @param amountToIncrement tokens amount to add
   * @param feePaymentMode fee payment mode
   */
  function increaseLockAmount(
    uint256 lockId,
    uint256 amountToIncrement,
    uint8 feePaymentMode
  ) external payable nonReentrant onlyLockOwner(lockId) {
    require(amountToIncrement > 0, "ZERO AMOUNT");
    TokenLock storage lock = tokenLocks[lockId];

    (uint256 ethFee, uint256 tokenFee, uint256 lpTokenFee) = feesCalculator
      .calculateIncreaseAmountFees(
        lock.lpToken,
        amountToIncrement,
        lock.unlockTime,
        feePaymentMode
      );
    transferFees(lock.lpToken, ethFee, tokenFee, lpTokenFee);
    if (msg.value > ethFee) {
      // transfer excess back
      transferBnb(msg.sender, msg.value.sub(ethFee));
    }

    uint256 actualIncrementAmount = amountToIncrement.sub(lpTokenFee);
    lock.tokenAmount = lock.tokenAmount.add(actualIncrementAmount);
    IERC20(lock.lpToken).safeTransferFrom(
      msg.sender,
      address(this),
      actualIncrementAmount
    );
    emit OnLockAmountIncreased(lockId, amountToIncrement);
  }

  /**
   * @notice withdraw all tokens from lock. Current time must be greater than unlock time
   * @param lockId lock id to withdraw
   */
  function withdraw(uint256 lockId) external {
    TokenLock storage lock = tokenLocks[lockId];
    withdrawPartially(lockId, lock.tokenAmount);
  }

  /**
   * @notice withdraw specified amount of tokens from lock. Current time must be greater than unlock time
   * @param lockId lock id to withdraw tokens from
   * @param amount amount of tokens to withdraw
   */
  function withdrawPartially(uint256 lockId, uint256 amount)
    public
    nonReentrant
    onlyLockOwner(lockId)
  {
    TokenLock storage lock = tokenLocks[lockId];
    require(lock.tokenAmount >= amount, "AMOUNT EXCEEDS LOCKED");
    require(block.timestamp >= lock.unlockTime, "NOT YET UNLOCKED");
    IERC20(lock.lpToken).safeTransfer(lock.owner, amount);

    lock.tokenAmount = lock.tokenAmount.sub(amount);
    if (lock.tokenAmount == 0) {
      //clean up storage to save gas
      userLocks[lock.owner].remove(lockId);
      delete tokenLocks[lockId];
      emit OnTokenUnlock(lockId);
    }
    emit OnLockWithdrawal(lockId, amount);
  }

  /**
   * @notice transfer lock ownership to another account
   * @param lockId lock id to transfer
   * @param newOwner account to transfer lock
   */
  function transferLock(uint256 lockId, address newOwner)
    external
    onlyLockOwner(lockId)
  {
    require(newOwner != address(0), "ZERO NEW OWNER");
    TokenLock storage lock = tokenLocks[lockId];
    userLocks[lock.owner].remove(lockId);
    userLocks[newOwner].add(lockId);
    lock.owner = newOwner;
    emit OnLockOwnershipTransferred(lockId, newOwner);
  }

  /**
   * @notice sets new contract to calculate fees
   * @param newFeesCalculator address of new fees calculator contract
   */
  function setFeesCalculator(address newFeesCalculator) external onlyOwner {
    require(newFeesCalculator != address(0), "ZERO ADDRESS");
    feesCalculator = IFeesCalculator(newFeesCalculator);
  }

  function setPadInfoAddress(address _newAddress) external onlyOwner {
    require(_newAddress != address(0), "ZERO ADDRESS");
    DoKENPadInfoAddress = _newAddress;
  }

  function transferFees(
    address lpToken,
    uint256 ethFee,
    uint256 tokenFee,
    uint256 lpTokenFee
  ) private {
    if (ethFee > 0) {
      require(msg.value >= ethFee, "ETH FEES NOT MET");
      transferBnb(feeReceiver, ethFee);
    }
    if (tokenFee > 0) {
      require(
        feeToken.allowance(msg.sender, address(this)) >= tokenFee,
        "TOKEN FEE NOT MET"
      );
      feeToken.safeTransferFrom(msg.sender, feeReceiver, tokenFee);
    }
    if (lpTokenFee > 0) {
      require(
        IERC20(lpToken).allowance(msg.sender, address(this)) >= lpTokenFee,
        "LP TOKEN FEE NOT MET"
      );
      IERC20(lpToken).safeTransferFrom(msg.sender, feeReceiver, lpTokenFee);
    }
  }

  function getPairInfoByPairAddress(address _address)
    public
    view
    returns (PairInfo memory)
  {
    IPancakePair _pair = IPancakePair(_address);
    IERC20 token0 = IERC20(_pair.token0());
    IERC20 token1 = IERC20(_pair.token1());
    // now lets build the PairInfo
    return
      PairInfo({
        tokenZeroName: token0.name(),
        tokenZeroSymbol: token0.symbol(),
        tokenZeroAddress: address(token0),
        tokenOneName: token1.name(),
        tokenOneSymbol: token1.symbol(),
        tokenOneAddress: address(token1),
        amountInWei: _pair.balanceOf(address(this)),
        factoryPairAddress: _pair.factory(),
        pairAddress: _address,
        lockIds: getLockIdsByPairAddress(_address)
      });
  }

  function getPairRecords(uint256 offset, uint256 limit)
    external
    view
    returns (
      PairInfo[] memory,
      uint256 nextOffset,
      uint256 total
    )
  {
    uint256 totalPairs = pairAddresses.length;
    if (limit == 0) limit = 1;
    if (limit > totalPairs - offset) limit = totalPairs - offset;
    PairInfo[] memory ldatas = new PairInfo[](limit);

    for (uint256 i = 0; i < limit; i++) {
      ldatas[i] = getPairInfoByPairAddress(pairAddresses[offset + i]);
    }

    return (ldatas, offset + limit, totalPairs);
  }

  function getUserLockLists(
    address user,
    uint256 offset,
    uint256 limit
  )
    external
    view
    returns (
      TokenLock[] memory,
      PairInfo[] memory,
      uint256 nextOffset,
      uint256 total
    )
  {
    uint256[] memory _userLocks = userLocks[user].values();
    uint256 totalUserLocks = _userLocks.length;
    if (limit == 0) limit = 1;
    if (limit > totalUserLocks - offset) limit = totalUserLocks - offset;
    TokenLock[] memory ldatas = new TokenLock[](limit);
    PairInfo[] memory pinfos = new PairInfo[](limit);

    for (uint256 i = 0; i < limit; i++) {
      TokenLock memory _tokenLock = getLock(_userLocks[offset + i]);
      ldatas[i] = _tokenLock;
      pinfos[i] = getPairInfoByPairAddress(_tokenLock.lpToken);
    }

    return (ldatas, pinfos, offset + limit, totalUserLocks);
  }

  function getPairLockLists(
    address pairAddress,
    uint256 offset,
    uint256 limit
  )
    external
    view
    returns (
      TokenLock[] memory,
      uint256 nextOffset,
      uint256 total
    )
  {
    uint256[] memory _pairLocks = getLockIdsByPairAddress(pairAddress);
    uint256 totalPairLocks = _pairLocks.length;
    if (limit == 0) limit = 1;
    if (limit > totalPairLocks - offset) limit = totalPairLocks - offset;
    TokenLock[] memory ldatas = new TokenLock[](limit);

    for (uint256 i = 0; i < limit; i++) {
      ldatas[i] = getLock(_pairLocks[offset + i]);
    }

    return (ldatas, offset + limit, totalPairLocks);
  }

  function getLock(uint256 _id) public view returns (TokenLock memory) {
    return tokenLocks[_id];
  }

  function getLockIdsByPairAddress(address _pairAddress)
    public
    view
    returns (uint256[] memory)
  {
    return tokenLocksByPairAddress[_pairAddress].values();
  }

  /**
   * @notice get user's locks number
   * @param user user's address
   */
  function userLocksLength(address user) external view returns (uint256) {
    return userLocks[user].length();
  }

  /**
   * @notice get user lock id at specified index
   * @param user user's address
   * @param index index of lock id
   */
  function userLockAt(address user, uint256 index)
    external
    view
    returns (uint256)
  {
    return userLocks[user].at(index);
  }

  function transferBnb(address recipient, uint256 amount) private {
    payable(recipient).transfer(amount);
  }

  function setFeeReceiver(address payable newFeeReceiver) external onlyOwner {
    require(newFeeReceiver != address(0), "ZERO ADDRESS");
    feeReceiver = newFeeReceiver;
  }

  function addDexSupport(address _routerAddress) external onlyOwner {
    supportedDex[_routerAddress] = true;
  }
}


// File: contracts/libraries/SafeMath.sol
// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.7;

/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */
library SafeMath {
  /**
   * @dev Returns the addition of two unsigned integers, reverting on
   * overflow.
   *
   * Counterpart to Solidity's `+` operator.
   *
   * Requirements:
   *
   * - Addition cannot overflow.
   */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a, "SafeMath: addition overflow");

    return c;
  }

  /**
   * @dev Returns the subtraction of two unsigned integers, reverting on
   * overflow (when the result is negative).
   *
   * Counterpart to Solidity's `-` operator.
   *
   * Requirements:
   *
   * - Subtraction cannot overflow.
   */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    return sub(a, b, "SafeMath: subtraction overflow");
  }

  /**
   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
   * overflow (when the result is negative).
   *
   * Counterpart to Solidity's `-` operator.
   *
   * Requirements:
   *
   * - Subtraction cannot overflow.
   */
  function sub(
    uint256 a,
    uint256 b,
    string memory errorMessage
  ) internal pure returns (uint256) {
    require(b <= a, errorMessage);
    uint256 c = a - b;

    return c;
  }

  /**
   * @dev Returns the multiplication of two unsigned integers, reverting on
   * overflow.
   *
   * Counterpart to Solidity's `*` operator.
   *
   * Requirements:
   *
   * - Multiplication cannot overflow.
   */
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
    if (a == 0) {
      return 0;
    }

    uint256 c = a * b;
    require(c / a == b, "SafeMath: multiplication overflow");

    return c;
  }

  /**
   * @dev Returns the integer division of two unsigned integers. Reverts on
   * division by zero. The result is rounded towards zero.
   *
   * Counterpart to Solidity's `/` operator. Note: this function uses a
   * `revert` opcode (which leaves remaining gas untouched) while Solidity
   * uses an invalid opcode to revert (consuming all remaining gas).
   *
   * Requirements:
   *
   * - The divisor cannot be zero.
   */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    return div(a, b, "SafeMath: division by zero");
  }

  /**
   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
   * division by zero. The result is rounded towards zero.
   *
   * Counterpart to Solidity's `/` operator. Note: this function uses a
   * `revert` opcode (which leaves remaining gas untouched) while Solidity
   * uses an invalid opcode to revert (consuming all remaining gas).
   *
   * Requirements:
   *
   * - The divisor cannot be zero.
   */
  function div(
    uint256 a,
    uint256 b,
    string memory errorMessage
  ) internal pure returns (uint256) {
    require(b > 0, errorMessage);
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold

    return c;
  }

  /**
   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
   * Reverts when dividing by zero.
   *
   * Counterpart to Solidity's `%` operator. This function uses a `revert`
   * opcode (which leaves remaining gas untouched) while Solidity uses an
   * invalid opcode to revert (consuming all remaining gas).
   *
   * Requirements:
   *
   * - The divisor cannot be zero.
   */
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
    return mod(a, b, "SafeMath: modulo by zero");
  }

  /**
   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
   * Reverts with custom message when dividing by zero.
   *
   * Counterpart to Solidity's `%` operator. This function uses a `revert`
   * opcode (which leaves remaining gas untouched) while Solidity uses an
   * invalid opcode to revert (consuming all remaining gas).
   *
   * Requirements:
   *
   * - The divisor cannot be zero.
   */
  function mod(
    uint256 a,
    uint256 b,
    string memory errorMessage
  ) internal pure returns (uint256) {
    require(b != 0, errorMessage);
    return a % b;
  }
}


// File: contracts/libraries/EnumerableSet.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)

pragma solidity ^0.8.6;

/**
 * @dev Library for managing
 * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive
 * types.
 *
 * Sets have the following properties:
 *
 * - Elements are added, removed, and checked for existence in constant time
 * (O(1)).
 * - Elements are enumerated in O(n). No guarantees are made on the ordering.
 *
 * ```
 * contract Example {
 *     // Add the library methods
 *     using EnumerableSet for EnumerableSet.AddressSet;
 *
 *     // Declare a set state variable
 *     EnumerableSet.AddressSet private mySet;
 * }
 * ```
 *
 * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)
 * and `uint256` (`UintSet`) are supported.
 */
library EnumerableSet {
  // To implement this library for multiple types with as little code
  // repetition as possible, we write it in terms of a generic Set type with
  // bytes32 values.
  // The Set implementation uses private functions, and user-facing
  // implementations (such as AddressSet) are just wrappers around the
  // underlying Set.
  // This means that we can only create new EnumerableSets for types that fit
  // in bytes32.

  struct Set {
    // Storage of set values
    bytes32[] _values;
    // Position of the value in the `values` array, plus 1 because index 0
    // means a value is not in the set.
    mapping(bytes32 => uint256) _indexes;
  }

  /**
   * @dev Add a value to a set. O(1).
   *
   * Returns true if the value was added to the set, that is if it was not
   * already present.
   */
  function _add(Set storage set, bytes32 value) private returns (bool) {
    if (!_contains(set, value)) {
      set._values.push(value);
      // The value is stored at length-1, but we add 1 to all indexes
      // and use 0 as a sentinel value
      set._indexes[value] = set._values.length;
      return true;
    } else {
      return false;
    }
  }

  /**
   * @dev Removes a value from a set. O(1).
   *
   * Returns true if the value was removed from the set, that is if it was
   * present.
   */
  function _remove(Set storage set, bytes32 value) private returns (bool) {
    // We read and store the value's index to prevent multiple reads from the same storage slot
    uint256 valueIndex = set._indexes[value];

    if (valueIndex != 0) {
      // Equivalent to contains(set, value)
      // To delete an element from the _values array in O(1), we swap the element to delete with the last one in
      // the array, and then remove the last element (sometimes called as 'swap and pop').
      // This modifies the order of the array, as noted in {at}.

      uint256 toDeleteIndex = valueIndex - 1;
      uint256 lastIndex = set._values.length - 1;

      if (lastIndex != toDeleteIndex) {
        bytes32 lastvalue = set._values[lastIndex];

        // Move the last value to the index where the value to delete is
        set._values[toDeleteIndex] = lastvalue;
        // Update the index for the moved value
        set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex
      }

      // Delete the slot where the moved value was stored
      set._values.pop();

      // Delete the index for the deleted slot
      delete set._indexes[value];

      return true;
    } else {
      return false;
    }
  }

  /**
   * @dev Returns true if the value is in the set. O(1).
   */
  function _contains(Set storage set, bytes32 value)
    private
    view
    returns (bool)
  {
    return set._indexes[value] != 0;
  }

  /**
   * @dev Returns the number of values on the set. O(1).
   */
  function _length(Set storage set) private view returns (uint256) {
    return set._values.length;
  }

  /**
   * @dev Returns the value stored at position `index` in the set. O(1).
   *
   * Note that there are no guarantees on the ordering of values inside the
   * array, and it may change when more values are added or removed.
   *
   * Requirements:
   *
   * - `index` must be strictly less than {length}.
   */
  function _at(Set storage set, uint256 index) private view returns (bytes32) {
    return set._values[index];
  }

  /**
   * @dev Return the entire set in an array
   *
   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
   * this function has an unbounded cost, and using it as part of a state-changing function may render the function
   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
   */
  function _values(Set storage set) private view returns (bytes32[] memory) {
    return set._values;
  }

  // Bytes32Set

  struct Bytes32Set {
    Set _inner;
  }

  /**
   * @dev Add a value to a set. O(1).
   *
   * Returns true if the value was added to the set, that is if it was not
   * already present.
   */
  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {
    return _add(set._inner, value);
  }

  /**
   * @dev Removes a value from a set. O(1).
   *
   * Returns true if the value was removed from the set, that is if it was
   * present.
   */
  function remove(Bytes32Set storage set, bytes32 value)
    internal
    returns (bool)
  {
    return _remove(set._inner, value);
  }

  /**
   * @dev Returns true if the value is in the set. O(1).
   */
  function contains(Bytes32Set storage set, bytes32 value)
    internal
    view
    returns (bool)
  {
    return _contains(set._inner, value);
  }

  /**
   * @dev Returns the number of values in the set. O(1).
   */
  function length(Bytes32Set storage set) internal view returns (uint256) {
    return _length(set._inner);
  }

  /**
   * @dev Returns the value stored at position `index` in the set. O(1).
   *
   * Note that there are no guarantees on the ordering of values inside the
   * array, and it may change when more values are added or removed.
   *
   * Requirements:
   *
   * - `index` must be strictly less than {length}.
   */
  function at(Bytes32Set storage set, uint256 index)
    internal
    view
    returns (bytes32)
  {
    return _at(set._inner, index);
  }

  /**
   * @dev Return the entire set in an array
   *
   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
   * this function has an unbounded cost, and using it as part of a state-changing function may render the function
   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
   */
  function values(Bytes32Set storage set)
    internal
    view
    returns (bytes32[] memory)
  {
    return _values(set._inner);
  }

  // AddressSet

  struct AddressSet {
    Set _inner;
  }

  /**
   * @dev Add a value to a set. O(1).
   *
   * Returns true if the value was added to the set, that is if it was not
   * already present.
   */
  function add(AddressSet storage set, address value) internal returns (bool) {
    return _add(set._inner, bytes32(uint256(uint160(value))));
  }

  /**
   * @dev Removes a value from a set. O(1).
   *
   * Returns true if the value was removed from the set, that is if it was
   * present.
   */
  function remove(AddressSet storage set, address value)
    internal
    returns (bool)
  {
    return _remove(set._inner, bytes32(uint256(uint160(value))));
  }

  /**
   * @dev Returns true if the value is in the set. O(1).
   */
  function contains(AddressSet storage set, address value)
    internal
    view
    returns (bool)
  {
    return _contains(set._inner, bytes32(uint256(uint160(value))));
  }

  /**
   * @dev Returns the number of values in the set. O(1).
   */
  function length(AddressSet storage set) internal view returns (uint256) {
    return _length(set._inner);
  }

  /**
   * @dev Returns the value stored at position `index` in the set. O(1).
   *
   * Note that there are no guarantees on the ordering of values inside the
   * array, and it may change when more values are added or removed.
   *
   * Requirements:
   *
   * - `index` must be strictly less than {length}.
   */
  function at(AddressSet storage set, uint256 index)
    internal
    view
    returns (address)
  {
    return address(uint160(uint256(_at(set._inner, index))));
  }

  /**
   * @dev Return the entire set in an array
   *
   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
   * this function has an unbounded cost, and using it as part of a state-changing function may render the function
   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
   */
  function values(AddressSet storage set)
    internal
    view
    returns (address[] memory)
  {
    bytes32[] memory store = _values(set._inner);
    address[] memory result;

    assembly {
      result := store
    }

    return result;
  }

  // UintSet

  struct UintSet {
    Set _inner;
  }

  /**
   * @dev Add a value to a set. O(1).
   *
   * Returns true if the value was added to the set, that is if it was not
   * already present.
   */
  function add(UintSet storage set, uint256 value) internal returns (bool) {
    return _add(set._inner, bytes32(value));
  }

  /**
   * @dev Removes a value from a set. O(1).
   *
   * Returns true if the value was removed from the set, that is if it was
   * present.
   */
  function remove(UintSet storage set, uint256 value) internal returns (bool) {
    return _remove(set._inner, bytes32(value));
  }

  /**
   * @dev Returns true if the value is in the set. O(1).
   */
  function contains(UintSet storage set, uint256 value)
    internal
    view
    returns (bool)
  {
    return _contains(set._inner, bytes32(value));
  }

  /**
   * @dev Returns the number of values on the set. O(1).
   */
  function length(UintSet storage set) internal view returns (uint256) {
    return _length(set._inner);
  }

  /**
   * @dev Returns the value stored at position `index` in the set. O(1).
   *
   * Note that there are no guarantees on the ordering of values inside the
   * array, and it may change when more values are added or removed.
   *
   * Requirements:
   *
   * - `index` must be strictly less than {length}.
   */
  function at(UintSet storage set, uint256 index)
    internal
    view
    returns (uint256)
  {
    return uint256(_at(set._inner, index));
  }

  /**
   * @dev Return the entire set in an array
   *
   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
   * this function has an unbounded cost, and using it as part of a state-changing function may render the function
   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
   */
  function values(UintSet storage set)
    internal
    view
    returns (uint256[] memory)
  {
    bytes32[] memory store = _values(set._inner);
    uint256[] memory result;

    assembly {
      result := store
    }

    return result;
  }
}


// File: contracts/libraries/IERC20.sol
// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.7;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
  /**
   * @dev Returns the amount of tokens in existence.
   */
  function totalSupply() external view returns (uint256);

  function decimals() external pure returns (uint8);

  function symbol() external pure returns (string memory);

  function name() external pure returns (string memory);

  /**
   * @dev Returns the amount of tokens owned by `account`.
   */
  function balanceOf(address account) external view returns (uint256);

  /**
   * @dev Moves `amount` tokens from the caller's account to `recipient`.
   *
   * Returns a boolean value indicating whether the operation succeeded.
   *
   * Emits a {Transfer} event.
   */
  function transfer(address recipient, uint256 amount) external returns (bool);

  /**
   * @dev Returns the remaining number of tokens that `spender` will be
   * allowed to spend on behalf of `owner` through {transferFrom}. This is
   * zero by default.
   *
   * This value changes when {approve} or {transferFrom} are called.
   */
  function allowance(address owner, address spender)
    external
    view
    returns (uint256);

  /**
   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
   *
   * Returns a boolean value indicating whether the operation succeeded.
   *
   * IMPORTANT: Beware that changing an allowance with this method brings the risk
   * that someone may use both the old and the new allowance by unfortunate
   * transaction ordering. One possible solution to mitigate this race
   * condition is to first reduce the spender's allowance to 0 and set the
   * desired value afterwards:
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   *
   * Emits an {Approval} event.
   */
  function approve(address spender, uint256 amount) external returns (bool);

  /**
   * @dev Moves `amount` tokens from `sender` to `recipient` using the
   * allowance mechanism. `amount` is then deducted from the caller's
   * allowance.
   *
   * Returns a boolean value indicating whether the operation succeeded.
   *
   * Emits a {Transfer} event.
   */
  function transferFrom(
    address sender,
    address recipient,
    uint256 amount
  ) external returns (bool);

  /**
   * @dev Emitted when `value` tokens are moved from one account (`from`) to
   * another (`to`).
   *
   * Note that `value` may be zero.
   */
  event Transfer(address indexed from, address indexed to, uint256 value);

  /**
   * @dev Emitted when the allowance of a `spender` for an `owner` is set by
   * a call to {approve}. `value` is the new allowance.
   */
  event Approval(address indexed owner, address indexed spender, uint256 value);
}


// File: contracts/libraries/SafeERC20.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)

pragma solidity ^0.8.6;

import "./IERC20.sol";
import "./Address.sol";

/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
  using Address for address;

  function safeTransfer(
    IERC20 token,
    address to,
    uint256 value
  ) internal {
    _callOptionalReturn(
      token,
      abi.encodeWithSelector(token.transfer.selector, to, value)
    );
  }

  function safeTransferFrom(
    IERC20 token,
    address from,
    address to,
    uint256 value
  ) internal {
    _callOptionalReturn(
      token,
      abi.encodeWithSelector(token.transferFrom.selector, from, to, value)
    );
  }

  /**
   * @dev Deprecated. This function has issues similar to the ones found in
   * {IERC20-approve}, and its usage is discouraged.
   *
   * Whenever possible, use {safeIncreaseAllowance} and
   * {safeDecreaseAllowance} instead.
   */
  function safeApprove(
    IERC20 token,
    address spender,
    uint256 value
  ) internal {
    // safeApprove should only be called when setting an initial allowance,
    // or when resetting it to zero. To increase and decrease it, use
    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
    require(
      (value == 0) || (token.allowance(address(this), spender) == 0),
      "SafeERC20: approve from non-zero to non-zero allowance"
    );
    _callOptionalReturn(
      token,
      abi.encodeWithSelector(token.approve.selector, spender, value)
    );
  }

  function safeIncreaseAllowance(
    IERC20 token,
    address spender,
    uint256 value
  ) internal {
    uint256 newAllowance = token.allowance(address(this), spender) + value;
    _callOptionalReturn(
      token,
      abi.encodeWithSelector(token.approve.selector, spender, newAllowance)
    );
  }

  function safeDecreaseAllowance(
    IERC20 token,
    address spender,
    uint256 value
  ) internal {
    unchecked {
      uint256 oldAllowance = token.allowance(address(this), spender);
      require(
        oldAllowance >= value,
        "SafeERC20: decreased allowance below zero"
      );
      uint256 newAllowance = oldAllowance - value;
      _callOptionalReturn(
        token,
        abi.encodeWithSelector(token.approve.selector, spender, newAllowance)
      );
    }
  }

  /**
   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
   * on the return value: the return value is optional (but if data is returned, it must not be false).
   * @param token The token targeted by the call.
   * @param data The call data (encoded using abi.encode or one of its variants).
   */
  function _callOptionalReturn(IERC20 token, bytes memory data) private {
    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
    // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that
    // the target address contains contract code and also asserts for success in the low-level call.

    bytes memory returndata = address(token).functionCall(
      data,
      "SafeERC20: low-level call failed"
    );
    if (returndata.length > 0) {
      // Return data is optional
      require(
        abi.decode(returndata, (bool)),
        "SafeERC20: ERC20 operation did not succeed"
      );
    }
  }
}


// File: contracts/libraries/Ownable.sol
// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.7;

import "./Context.sol";

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
  address private _owner;

  event OwnershipTransferred(
    address indexed previousOwner,
    address indexed newOwner
  );

  /**
   * @dev Initializes the contract setting the deployer as the initial owner.
   */
  constructor() {
    address msgSender = _msgSender();
    _owner = msgSender;
    emit OwnershipTransferred(address(0), msgSender);
  }

  /**
   * @dev Returns the address of the current owner.
   */
  function owner() public view returns (address) {
    return _owner;
  }

  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(_owner == _msgSender(), "Ownable: caller is not the owner");
    _;
  }

  /**
   * @dev Leaves the contract without owner. It will not be possible to call
   * `onlyOwner` functions anymore. Can only be called by the current owner.
   *
   * NOTE: Renouncing ownership will leave the contract without an owner,
   * thereby removing any functionality that is only available to the owner.
   */
  function renounceOwnership() public virtual onlyOwner {
    emit OwnershipTransferred(_owner, address(0));
    _owner = address(0);
  }

  /**
   * @dev Transfers ownership of the contract to a new account (`newOwner`).
   * Can only be called by the current owner.
   */
  function transferOwnership(address newOwner) public virtual onlyOwner {
    require(newOwner != address(0), "Ownable: new owner is the zero address");
    emit OwnershipTransferred(_owner, newOwner);
    _owner = newOwner;
  }
}


// File: contracts/libraries/ReentrancyGuard.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)

pragma solidity ^0.8.6;

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
  // Booleans are more expensive than uint256 or any type that takes up a full
  // word because each write operation emits an extra SLOAD to first read the
  // slot's contents, replace the bits taken up by the boolean, and then write
  // back. This is the compiler's defense against contract upgrades and
  // pointer aliasing, and it cannot be disabled.

  // The values being non-zero value makes deployment a bit more expensive,
  // but in exchange the refund on every call to nonReentrant will be lower in
  // amount. Since refunds are capped to a percentage of the total
  // transaction's gas, it is best to keep them low in cases like this one, to
  // increase the likelihood of the full refund coming into effect.
  uint256 private constant _NOT_ENTERED = 1;
  uint256 private constant _ENTERED = 2;

  uint256 private _status;

  constructor() {
    _status = _NOT_ENTERED;
  }

  /**
   * @dev Prevents a contract from calling itself, directly or indirectly.
   * Calling a `nonReentrant` function from another `nonReentrant`
   * function is not supported. It is possible to prevent this from happening
   * by making the `nonReentrant` function external, and making it call a
   * `private` function that does the actual work.
   */
  modifier nonReentrant() {
    // On the first call to nonReentrant, _notEntered will be true
    require(_status != _ENTERED, "ReentrancyGuard: reentrant call");

    // Any calls to nonReentrant after this point will fail
    _status = _ENTERED;

    _;

    // By storing the original value once again, a refund is triggered (see
    // https://eips.ethereum.org/EIPS/eip-2200)
    _status = _NOT_ENTERED;
  }
}


// File: contracts/libraries/IPancakeFactory.sol
//SPDX-License-Identifier: UNLICENSED
pragma solidity >=0.5.0;

interface IPancakeFactory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);

    function feeTo() external view returns (address);
    function feeToSetter() external view returns (address);

    function getPair(address tokenA, address tokenB) external view returns (address pair);
    function allPairs(uint) external view returns (address pair);
    function allPairsLength() external view returns (uint);

    function createPair(address tokenA, address tokenB) external returns (address pair);

    function setFeeTo(address) external;
    function setFeeToSetter(address) external;
}


// File: contracts/libraries/IPancakePair.sol
//SPDX-License-Identifier: UNLICENSED
pragma solidity >=0.5.0;

interface IPancakePair {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);

    function name() external pure returns (string memory);
    function symbol() external pure returns (string memory);
    function decimals() external pure returns (uint8);
    function totalSupply() external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);

    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);

    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function PERMIT_TYPEHASH() external pure returns (bytes32);
    function nonces(address owner) external view returns (uint);

    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;

    event Mint(address indexed sender, uint amount0, uint amount1);
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);

    function MINIMUM_LIQUIDITY() external pure returns (uint);
    function factory() external view returns (address);
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function price0CumulativeLast() external view returns (uint);
    function price1CumulativeLast() external view returns (uint);
    function kLast() external view returns (uint);

    function mint(address to) external returns (uint liquidity);
    function burn(address to) external returns (uint amount0, uint amount1);
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
    function skim(address to) external;
    function sync() external;

    function initialize(address, address) external;
}


// File: contracts/IFeesCalculator.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.6;

interface IFeesCalculator {
  function calculateFees(
    address lpToken,
    uint256 amount,
    uint256 unlockTime,
    uint8 paymentMode
  )
    external
    view
    returns (
      uint256 ethFee,
      uint256 tokenFee,
      uint256 lpTokenFee
    );

  function calculateIncreaseAmountFees(
    address lpToken,
    uint256 amount,
    uint256 unlockTime,
    uint8 paymentMode
  )
    external
    view
    returns (
      uint256 ethFee,
      uint256 tokenFee,
      uint256 lpTokenFee
    );
}


// File: contracts/libraries/IDoKENPadInfo.sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.6;

interface IDoKENPadInfo {
  struct LaunchpadData {
    address lAddress;
    uint256 lVotes;
    uint8 lTypes;
    // bool lKyc;
  }

  function isRegisteredLaunchpad(address _address) external view returns (bool);

  function addLaunchpadAddress(
    address _launchapd,
    address _tokenAddress,
    uint8 _launchpadType,
    address _user
  ) external returns (uint256);

  function addUserContribution(uint256 _padId, address _user) external;

  function getLaunchpadCount() external view returns (uint256);

  function getLaunchpadAddress(uint256 launchId)
    external
    view
    returns (address);

  function getDevFeePercentage() external view returns (uint256);

  function getMinDevFeeInWei() external view returns (uint256);

  function setMinDevFeeInWei(uint256 _minDevFeeInWei) external;

  function setFinalizationFeesPercentage(
    uint256 _forDevPc,
    uint256 _forMktPc,
    uint256 _forSwapPc
  ) external;

  function getFinalizationFeesPc()
    external
    view
    returns (
      uint256,
      uint256,
      uint256
    );

  function setAddresses(
    address _regTokenaddress,
    address _regTokenTwoAddress,
    address _newDevWallet,
    address _newMktWallet,
    address _newDeployerWallet
  ) external;

  function setRegistrationFee(uint256 _newRegistrationFee) external;

  function setRegistrationFeeDegen(uint256 _newRegistrationFee) external;

  function setDegenModeCapLimit(uint256 _newLimit) external;

  function setAuditData(address _presaleAddress, bytes32 _auditUrl) external;

  function getAuditData(address _presaleAddress)
    external
    view
    returns (bytes32);

  function addAuthorized(address _admin, bool _allowed) external;

  function getRegistrationFee() external view returns (uint256);

  function getRegistrationFeeDegen() external view returns (uint256);

  function getTokenFeeAddress() external view returns (address);

  function getTokenFeeDegenAddress() external view returns (address);

  function getDegenModeCapLimit() external view returns (uint256);

  function getLockerAddress() external view returns (address);

  function getDevWallet() external view returns (address);

  function getDeployerWallet() external view returns (address);

  function getMktWallet() external view returns (address);

  function isExemptFromFee(address _address) external view returns (bool);

  function exemptAddress(address _address) external;

  function cancelLaunchpadByToken(address _tokenAddress) external;

  function getLaunchpadAddressByToken(address _tokenAddress)
    external
    view
    returns (address);

  function getLaunchpadVote(address _address) external view returns (uint256);

  // function getLaunchpadKycStatus(address _address) public view returns (bool) {
  //   return launchpadKycStatus[_address];
  // }

  function voteLaunchpad(address _address) external payable;

  function fixedDecimals(uint256 _amount, uint8 _decimals)
    external
    pure
    returns (uint256);

  function quote(
    uint256 _hardCapInWei,
    uint256 _tokenPriceInWei,
    uint256 _listingPriceInWei,
    uint256 _liquidityAllocationPc
  ) external pure returns (uint256, uint256);

  function validPair(address _tokenAddress, address _routerAddress)
    external
    view
    returns (bool);
}


// File: contracts/libraries/IUniswapRouter.sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.6;

interface IUniswapV2Router01 {
  function factory() external pure returns (address);

  function WETH() external pure returns (address);

  function addLiquidity(
    address tokenA,
    address tokenB,
    uint256 amountADesired,
    uint256 amountBDesired,
    uint256 amountAMin,
    uint256 amountBMin,
    address to,
    uint256 deadline
  )
    external
    returns (
      uint256 amountA,
      uint256 amountB,
      uint256 liquidity
    );

  function addLiquidityETH(
    address token,
    uint256 amountTokenDesired,
    uint256 amountTokenMin,
    uint256 amountETHMin,
    address to,
    uint256 deadline
  )
    external
    payable
    returns (
      uint256 amountToken,
      uint256 amountETH,
      uint256 liquidity
    );

  function removeLiquidity(
    address tokenA,
    address tokenB,
    uint256 liquidity,
    uint256 amountAMin,
    uint256 amountBMin,
    address to,
    uint256 deadline
  ) external returns (uint256 amountA, uint256 amountB);

  function removeLiquidityETH(
    address token,
    uint256 liquidity,
    uint256 amountTokenMin,
    uint256 amountETHMin,
    address to,
    uint256 deadline
  ) external returns (uint256 amountToken, uint256 amountETH);

  function removeLiquidityWithPermit(
    address tokenA,
    address tokenB,
    uint256 liquidity,
    uint256 amountAMin,
    uint256 amountBMin,
    address to,
    uint256 deadline,
    bool approveMax,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external returns (uint256 amountA, uint256 amountB);

  function removeLiquidityETHWithPermit(
    address token,
    uint256 liquidity,
    uint256 amountTokenMin,
    uint256 amountETHMin,
    address to,
    uint256 deadline,
    bool approveMax,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external returns (uint256 amountToken, uint256 amountETH);

  function swapExactTokensForTokens(
    uint256 amountIn,
    uint256 amountOutMin,
    address[] calldata path,
    address to,
    uint256 deadline
  ) external returns (uint256[] memory amounts);

  function swapTokensForExactTokens(
    uint256 amountOut,
    uint256 amountInMax,
    address[] calldata path,
    address to,
    uint256 deadline
  ) external returns (uint256[] memory amounts);

  function swapExactETHForTokens(
    uint256 amountOutMin,
    address[] calldata path,
    address to,
    uint256 deadline
  ) external payable returns (uint256[] memory amounts);

  function swapTokensForExactETH(
    uint256 amountOut,
    uint256 amountInMax,
    address[] calldata path,
    address to,
    uint256 deadline
  ) external returns (uint256[] memory amounts);

  function swapExactTokensForETH(
    uint256 amountIn,
    uint256 amountOutMin,
    address[] calldata path,
    address to,
    uint256 deadline
  ) external returns (uint256[] memory amounts);

  function swapETHForExactTokens(
    uint256 amountOut,
    address[] calldata path,
    address to,
    uint256 deadline
  ) external payable returns (uint256[] memory amounts);

  function quote(
    uint256 amountA,
    uint256 reserveA,
    uint256 reserveB
  ) external pure returns (uint256 amountB);

  function getAmountOut(
    uint256 amountIn,
    uint256 reserveIn,
    uint256 reserveOut
  ) external pure returns (uint256 amountOut);

  function getAmountIn(
    uint256 amountOut,
    uint256 reserveIn,
    uint256 reserveOut
  ) external pure returns (uint256 amountIn);

  function getAmountsOut(uint256 amountIn, address[] calldata path)
    external
    view
    returns (uint256[] memory amounts);

  function getAmountsIn(uint256 amountOut, address[] calldata path)
    external
    view
    returns (uint256[] memory amounts);
}

// pragma solidity >=0.6.2;

interface IUniswapV2Router02 is IUniswapV2Router01 {
  function removeLiquidityETHSupportingFeeOnTransferTokens(
    address token,
    uint256 liquidity,
    uint256 amountTokenMin,
    uint256 amountETHMin,
    address to,
    uint256 deadline
  ) external returns (uint256 amountETH);

  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
    address token,
    uint256 liquidity,
    uint256 amountTokenMin,
    uint256 amountETHMin,
    address to,
    uint256 deadline,
    bool approveMax,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external returns (uint256 amountETH);

  function swapExactTokensForTokensSupportingFeeOnTransferTokens(
    uint256 amountIn,
    uint256 amountOutMin,
    address[] calldata path,
    address to,
    uint256 deadline
  ) external;

  function swapExactETHForTokensSupportingFeeOnTransferTokens(
    uint256 amountOutMin,
    address[] calldata path,
    address to,
    uint256 deadline
  ) external payable;

  function swapExactTokensForETHSupportingFeeOnTransferTokens(
    uint256 amountIn,
    uint256 amountOutMin,
    address[] calldata path,
    address to,
    uint256 deadline
  ) external;
}


// File: contracts/libraries/IUniswapV2Factory.sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.6;

interface IUniswapV2Factory {
  event PairCreated(
    address indexed token0,
    address indexed token1,
    address pair,
    uint256
  );

  function feeTo() external view returns (address);

  function feeToSetter() external view returns (address);

  function getPair(address tokenA, address tokenB)
    external
    view
    returns (address pair);

  function allPairs(uint256) external view returns (address pair);

  function allPairsLength() external view returns (uint256);

  function createPair(address tokenA, address tokenB)
    external
    returns (address pair);

  function setFeeTo(address) external;

  function setFeeToSetter(address) external;
}


// File: contracts/libraries/Address.sol
// SPDX-License-Identifier: MIT

pragma solidity >=0.6.2 <0.8.7;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
  /**
   * @dev Returns true if `account` is a contract.
   *
   * [IMPORTANT]
   * ====
   * It is unsafe to assume that an address for which this function returns
   * false is an externally-owned account (EOA) and not a contract.
   *
   * Among others, `isContract` will return false for the following
   * types of addresses:
   *
   *  - an externally-owned account
   *  - a contract in construction
   *  - an address where a contract will be created
   *  - an address where a contract lived, but was destroyed
   * ====
   */
  function isContract(address account) internal view returns (bool) {
    // This method relies on extcodesize, which returns 0 for contracts in
    // construction, since the code is only stored at the end of the
    // constructor execution.

    uint256 size;
    // solhint-disable-next-line no-inline-assembly
    assembly {
      size := extcodesize(account)
    }
    return size > 0;
  }

  /**
   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
   * `recipient`, forwarding all available gas and reverting on errors.
   *
   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
   * of certain opcodes, possibly making contracts go over the 2300 gas limit
   * imposed by `transfer`, making them unable to receive funds via
   * `transfer`. {sendValue} removes this limitation.
   *
   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
   *
   * IMPORTANT: because control is transferred to `recipient`, care must be
   * taken to not create reentrancy vulnerabilities. Consider using
   * {ReentrancyGuard} or the
   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
   */
  function sendValue(address payable recipient, uint256 amount) internal {
    require(address(this).balance >= amount, "Address: insufficient balance");

    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value
    (bool success, ) = recipient.call{ value: amount }("");
    require(
      success,
      "Address: unable to send value, recipient may have reverted"
    );
  }

  /**
   * @dev Performs a Solidity function call using a low level `call`. A
   * plain`call` is an unsafe replacement for a function call: use this
   * function instead.
   *
   * If `target` reverts with a revert reason, it is bubbled up by this
   * function (like regular Solidity function calls).
   *
   * Returns the raw returned data. To convert to the expected return value,
   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
   *
   * Requirements:
   *
   * - `target` must be a contract.
   * - calling `target` with `data` must not revert.
   *
   * _Available since v3.1._
   */
  function functionCall(address target, bytes memory data)
    internal
    returns (bytes memory)
  {
    return functionCall(target, data, "Address: low-level call failed");
  }

  /**
   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
   * `errorMessage` as a fallback revert reason when `target` reverts.
   *
   * _Available since v3.1._
   */
  function functionCall(
    address target,
    bytes memory data,
    string memory errorMessage
  ) internal returns (bytes memory) {
    return functionCallWithValue(target, data, 0, errorMessage);
  }

  /**
   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
   * but also transferring `value` wei to `target`.
   *
   * Requirements:
   *
   * - the calling contract must have an ETH balance of at least `value`.
   * - the called Solidity function must be `payable`.
   *
   * _Available since v3.1._
   */
  function functionCallWithValue(
    address target,
    bytes memory data,
    uint256 value
  ) internal returns (bytes memory) {
    return
      functionCallWithValue(
        target,
        data,
        value,
        "Address: low-level call with value failed"
      );
  }

  /**
   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
   * with `errorMessage` as a fallback revert reason when `target` reverts.
   *
   * _Available since v3.1._
   */
  function functionCallWithValue(
    address target,
    bytes memory data,
    uint256 value,
    string memory errorMessage
  ) internal returns (bytes memory) {
    require(
      address(this).balance >= value,
      "Address: insufficient balance for call"
    );
    require(isContract(target), "Address: call to non-contract");

    // solhint-disable-next-line avoid-low-level-calls
    (bool success, bytes memory returndata) = target.call{ value: value }(data);
    return _verifyCallResult(success, returndata, errorMessage);
  }

  /**
   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
   * but performing a static call.
   *
   * _Available since v3.3._
   */
  function functionStaticCall(address target, bytes memory data)
    internal
    view
    returns (bytes memory)
  {
    return
      functionStaticCall(target, data, "Address: low-level static call failed");
  }

  /**
   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
   * but performing a static call.
   *
   * _Available since v3.3._
   */
  function functionStaticCall(
    address target,
    bytes memory data,
    string memory errorMessage
  ) internal view returns (bytes memory) {
    require(isContract(target), "Address: static call to non-contract");

    // solhint-disable-next-line avoid-low-level-calls
    (bool success, bytes memory returndata) = target.staticcall(data);
    return _verifyCallResult(success, returndata, errorMessage);
  }

  function _verifyCallResult(
    bool success,
    bytes memory returndata,
    string memory errorMessage
  ) private pure returns (bytes memory) {
    if (success) {
      return returndata;
    } else {
      // Look for revert reason and bubble it up if present
      if (returndata.length > 0) {
        // The easiest way to bubble the revert reason is using memory via assembly

        // solhint-disable-next-line no-inline-assembly
        assembly {
          let returndata_size := mload(returndata)
          revert(add(32, returndata), returndata_size)
        }
      } else {
        revert(errorMessage);
      }
    }
  }
}


// File: contracts/libraries/Context.sol
// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.7;

/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with GSN meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
  function _msgSender() internal view virtual returns (address) {
    return msg.sender;
  }

  function _msgData() internal view virtual returns (bytes calldata) {
    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
    return msg.data;
  }
}

