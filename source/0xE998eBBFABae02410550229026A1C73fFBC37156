pragma solidity ^0.8.4;

// SPDX-License-Identifier: MIT

abstract contract ReentrancyGuard {
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    modifier nonReentrant() {
        _nonReentrantBefore();
        _;
        _nonReentrantAfter();
    }

    function _nonReentrantBefore() private {
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
        _status = _ENTERED;
    }

    function _nonReentrantAfter() private {
        _status = _NOT_ENTERED;
    }

    function _reentrancyGuardEntered() internal view returns (bool) {
        return _status == _ENTERED;
    }
}

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

interface LinkTokenInterface {
  function allowance(address owner, address spender) external view returns (uint256 remaining);

  function approve(address spender, uint256 value) external returns (bool success);

  function balanceOf(address owner) external view returns (uint256 balance);

  function decimals() external view returns (uint8 decimalPlaces);

  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);

  function increaseApproval(address spender, uint256 subtractedValue) external;

  function name() external view returns (string memory tokenName);

  function symbol() external view returns (string memory tokenSymbol);

  function totalSupply() external view returns (uint256 totalTokensIssued);

  function transfer(address to, uint256 value) external returns (bool success);

  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);

  function transferFrom(address from, address to, uint256 value) external returns (bool success);
}

interface VRFV2WrapperInterface {

  function lastRequestId() external view returns (uint256);

  function calculateRequestPrice(uint32 _callbackGasLimit) external view returns (uint256);

  function estimateRequestPrice(uint32 _callbackGasLimit, uint256 _requestGasPriceWei) external view returns (uint256);
}


abstract contract VRFV2WrapperConsumerBase {
  LinkTokenInterface internal immutable LINK;
  VRFV2WrapperInterface internal immutable VRF_V2_WRAPPER;

  constructor(address _link, address _vrfV2Wrapper) {
    LINK = LinkTokenInterface(_link);
    VRF_V2_WRAPPER = VRFV2WrapperInterface(_vrfV2Wrapper);
  }

  function requestRandomness(
    uint32 _callbackGasLimit,
    uint16 _requestConfirmations,
    uint32 _numWords
  ) internal returns (uint256 requestId) {
    LINK.transferAndCall(
      address(VRF_V2_WRAPPER),
      VRF_V2_WRAPPER.calculateRequestPrice(_callbackGasLimit),
      abi.encode(_callbackGasLimit, _requestConfirmations, _numWords)
    );
    return VRF_V2_WRAPPER.lastRequestId();
  }

  function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) internal virtual {
  }
}


contract flipperv3 is ReentrancyGuard, VRFV2WrapperConsumerBase {
    address payable public owner;
    uint256 public betAmount = 0.05 ether;
    uint256 public payoutAmount = 0.09 ether;
    uint256 public treasuryTax = 0.01 ether;
    uint256 public housePercentage = 55;
    address payable public treasuryWallet;

    uint256 public totalGamesPlayed;
    uint256 public totalWins;
    uint256 public totalLosses;
    uint256 public totalBNBCollected;
    uint256 public totalBNBDistributed;

    uint256 internal fee;
    uint256 public randomResult;

    mapping (uint256 => address) requestToPlayer;

    event GamePlayed(address indexed player, bool indexed win);
    event EmergencyWithdrawal(address indexed owner, uint256 amount);
    event RequestedRandomness(uint256 requestId);

    constructor(address _link, address _vrfV2Wrapper, uint256 _fee, address payable _treasuryWallet)
        VRFV2WrapperConsumerBase(_link, _vrfV2Wrapper)
    {
        owner = payable(msg.sender);
        fee = _fee;
        treasuryWallet = _treasuryWallet; // Initialize the house edge wallet address
    }

    function flipCoin() public payable nonReentrant returns (uint256) {
        require(msg.value == betAmount, "Incorrect bet amount");
        require(LINK.balanceOf(address(this)) >= fee, "Not enough LINK to pay fee");

        totalGamesPlayed++;
        totalBNBCollected += msg.value;

        uint256 requestId = requestRandomness(100000, 3, 1);
        requestToPlayer[requestId] = msg.sender;
        emit RequestedRandomness(requestId);
        return requestId;
    }

    function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) internal override {
        address player = requestToPlayer[_requestId];
        randomResult = _randomWords[0] % 100;
        bool win = (randomResult < 100 - housePercentage);
        if (win) {
            totalWins++;
            totalBNBDistributed += payoutAmount;
            payable(player).transfer(payoutAmount);
            treasuryWallet.transfer(treasuryTax);
        } else {
            totalLosses++;
        }
        emit GamePlayed(msg.sender, win);
    }

    function fundContract() public payable nonReentrant {
        require(msg.sender == owner, "Only owner can execute an emergency withdrawal");
    }

    function updatetreasuryWallet(address payable newtreasuryWallet) public {
        require(msg.sender == owner, "Only the owner can update the house edge wallet");
        treasuryWallet = newtreasuryWallet;
    }

    function setHousePercentage(uint256 newPercentage) public {
        require(msg.sender == owner, "Only the owner can change the house edge percentage");
        require(newPercentage >= 50 && newPercentage <= 60, "House edge percentage must be between 50 and 60");
        housePercentage = newPercentage;
    }


    function emergencyWithdraw() public nonReentrant {
        require(msg.sender == owner, "Only owner can execute an emergency withdrawal");
        uint256 balance = address(this).balance;
        owner.transfer(balance);
        emit EmergencyWithdrawal(owner, balance);
    }

    function withdrawLink(uint256 _amount) public {
        require(msg.sender == owner, "Only the owner can withdraw LINK");
        require(LINK.balanceOf(address(this)) >= _amount, "Not enough LINK in contract to withdraw");
        require(LINK.transfer(msg.sender, _amount), "LINK transfer failed");
    }
}