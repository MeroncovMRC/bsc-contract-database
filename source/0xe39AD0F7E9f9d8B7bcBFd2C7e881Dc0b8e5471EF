{"Booster.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\nimport \"./IERC20.sol\";\nimport \"./IDealeable.sol\";\nimport \"./Roles.sol\";\n\ncontract Booster is Roles {\n\tevent NewBooster(\n\t\tuint256 id,\n\t\taddress[] sources,\n\t\tuint8[] amounts,\n\t\tuint256 price,\n\t\tuint256 rarityModifier,\n\t\tuint256 amount\n\t);\n\tevent SetActive(uint256 id, bool active);\n\tevent SetAmount(uint256 id, uint256 amount);\n\tevent SetPrice(uint256 id, uint256 price);\n\tevent BoosterSold(address account, uint256 id, uint256 amount);\n\n\tbytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n\n\t// STORAGE\n\n\tstruct sSource {\n\t\taddress source;\n\t\tuint8 amount;\n\t}\n\n\tstruct sBooster {\n\t\tsSource[] content;\n\t\tuint256 amount;\n\t\tuint256 price; // Price expressed in USD\n\t\tuint256 rarityModifier;\n\t\tbool active;\n\t}\n\tmapping(uint256 =\u003e sBooster) private _boosters;\n\tuint256 _boostersCount;\n\tIERC20 private _token;\n\tuint256 private _tokenPrice;\n\n\tfunction booster(uint256 id) external view returns (sBooster memory) {\n\t\treturn _boosters[id];\n\t}\n\n\tfunction boosters() external view returns (sBooster[] memory) {\n\t\tsBooster[] memory b = new sBooster[](_boostersCount);\n\t\tfor (uint256 i; i \u003c _boostersCount; i++) {\n\t\t\tb[i] = _boosters[i];\n\t\t}\n\t\treturn b;\n\t}\n\n\t// BOOSTER\n\n\tfunction newBooster(\n\t\taddress[] calldata _sources,\n\t\tuint8[] calldata _amounts,\n\t\tuint256 _price,\n\t\tuint256 _rarityModifier,\n\t\tuint256 _amount\n\t) external onlyRole(ADMIN_ROLE) returns (uint256) {\n\t\trequire(\n\t\t\t_sources.length == _amounts.length \u0026\u0026 _sources.length \u003e 0,\n\t\t\t\"Invalid data\"\n\t\t);\n\n\t\t_boostersCount++;\n\t\tsBooster storage b = _boosters[_boostersCount];\n\t\tb.amount = _amount;\n\t\tb.price = _price;\n\t\tb.rarityModifier = _rarityModifier;\n\t\tb.active = false;\n\n\t\tfor (uint256 i = 0; i \u003c _amounts.length; i++) {\n\t\t\trequire(_sources[i].code.length \u003e 0, \"source is not a contract\");\n\t\t\tb.content.push(sSource(_sources[i], _amounts[i]));\n\t\t}\n\t\temit NewBooster(\n\t\t\t_boostersCount,\n\t\t\t_sources,\n\t\t\t_amounts,\n\t\t\t_price,\n\t\t\t_rarityModifier,\n\t\t\t_amount\n\t\t);\n\t\treturn _boostersCount;\n\t}\n\n\tfunction setAmount(uint256 _id, uint256 _amount)\n\t\texternal\n\t\tonlyRole(ADMIN_ROLE)\n\t{\n\t\trequire(_boosters[_id].content.length \u003e 0, \"booster doesnt exist\");\n\t\trequire(_amount \u003e 0, \"amount cant be 0\");\n\t\t_boosters[_id].amount = _amount;\n\t\temit SetAmount(_id, _amount);\n\t}\n\n\tfunction setPrice(uint256 _id, uint256 _price)\n\t\texternal\n\t\tonlyRole(ADMIN_ROLE)\n\t{\n\t\trequire(_boosters[_id].content.length \u003e 0, \"booster doesnt exist\");\n\t\trequire(_price \u003e 0, \"price cant be 0\");\n\t\t_boosters[_id].price = _price;\n\t\temit SetPrice(_id, _price);\n\t}\n\n\tfunction setTokenPrice(uint256 _price) external onlyRole(ADMIN_ROLE) {\n\t\trequire(_price \u003e 0, \"price cant be 0\");\n\t\t_tokenPrice = _price;\n\t\temit SetPrice(0, _price);\n\t}\n\n\tfunction setTokenAddress(address vulc) external onlyRole(ADMIN_ROLE) {\n\t\t_token = IERC20(vulc);\n\t}\n\n\tfunction setActive(uint256 _id, bool _active)\n\t\texternal\n\t\tonlyRole(ADMIN_ROLE)\n\t{\n\t\trequire(_boosters[_id].content.length \u003e 0, \"booster doesnt exist\");\n\t\t_boosters[_id].active = _active;\n\t\temit SetActive(_id, _active);\n\t}\n\n\tfunction buy(uint256 _id, uint8 _amount) public payable virtual {\n\t\tsBooster storage b = _boosters[_id];\n\t\trequire(b.content.length \u003e 0, \"booster doesnt exist\");\n\t\trequire(b.active, \"booster not active\");\n\t\trequire(b.amount \u003e= _amount, \"no stock enough\");\n\t\tuint256 balance = _token.balanceOf(msg.sender);\n\t\tuint256 totalPrice = (b.price * _amount) / _tokenPrice;\n\t\ttotalPrice = totalPrice * 10**18;\n\t\trequire(totalPrice \u003c= balance, \"no money enough\");\n\t\tbool ok = _token.transferFrom(msg.sender, address(this), totalPrice);\n\t\trequire(ok, \"no money enough\");\n\n\t\tb.amount -= _amount;\n\n\t\tfor (uint256 i = 0; i \u003c b.content.length; i++) {\n\t\t\tassert(\n\t\t\t\tIDealeable(b.content[i].source).deal(\n\t\t\t\t\tmsg.sender,\n\t\t\t\t\tb.content[i].amount * _amount,\n\t\t\t\t\tb.rarityModifier\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t\temit BoosterSold(msg.sender, _id, _amount);\n\t}\n\n\t// INTERNAL\n\n\tfunction setAdmin(address _to, bool _enabled)\n\t\texternal\n\t\tonlyRole(ADMIN_ROLE)\n\t{\n\t\t_setRole(_to, ADMIN_ROLE, _enabled);\n\t}\n\n\tfunction withdraw(address payable _to) external onlyRole(ADMIN_ROLE) {\n\t\t_to.transfer(address(this).balance);\n\t}\n\n\tfunction withdrawToken(address payable _to) external onlyRole(ADMIN_ROLE) {\n\t\tuint256 balance = _token.balanceOf(address(this));\n\t\t_token.transfer(_to, balance);\n\t}\n\n\treceive() external payable {}\n\n\tconstructor() {\n\t\t_setRole(msg.sender, ADMIN_ROLE, true);\n\t}\n}\n"},"IDealeable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\ninterface IDealeable {\n    function deal(address _to, uint8 _amount, uint256 _rarityModifier) external returns(bool);\n}\n"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"Roles.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\ncontract Roles {\n    event Role(bytes32 role, address account, address sender, bool grant);\n\n    mapping(bytes32 =\u003e mapping(address =\u003e bool)) internal _roles;\n\n    function hasRole(bytes32 _role, address _address) view public returns(bool) {\n        return _roles[_role][_address];\n    }\n\n    function _setRole(address _address, bytes32 _role, bool status) internal {\n        require(!(_address == msg.sender \u0026\u0026 !status), \"cant revoke self roles\");\n        _roles[_role][_address] = status;\n        emit Role(_role, _address, msg.sender, status);\n    }\n\n    modifier onlyRole(bytes32 _role) {\n        require(hasRole(_role, msg.sender), \"AccessControl: Forbidden\");\n        _;\n    }\n}\n"}}