// SPDX-License-Identifier: Unlicense

pragma solidity 0.8.17;

interface IBEP20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the token decimals.
     */
    function decimals() external view returns (uint8);

    /**
     * @dev Returns the token symbol.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the token name.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the bep token owner.
     */
    function getOwner() external view returns (address);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(
        address recipient,
        uint256 amount
    ) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(
        address _owner,
        address spender
    ) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
}

/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with GSN meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
contract Context {
    // Empty internal constructor, to prevent people from mistakenly deploying
    // an instance of this contract, which should be used via inheritance.
    // constructor() internal {}

    function _msgSender() internal view returns (address payable) {
        return payable(msg.sender);
    }

    function _msgData() internal view returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}

/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(_owner == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     */
    function _transferOwnership(address newOwner) internal {
        require(
            newOwner != address(0),
            "Ownable: new owner is the zero address"
        );
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

contract BEP20USDT is Context, IBEP20, Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    uint256 private _totalSupply;
    uint8 public _decimals;
    string public _symbol;
    string public _name;

    constructor() {
        _name = "Tether USD";
        _symbol = "USDT";
        _decimals = 18;
        _totalSupply = 30000000000000000000000000;
        _balances[msg.sender] = _totalSupply;

        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    /**
     * @dev Returns the bep token owner.
     */
    function getOwner() external view returns (address) {
        return owner();
    }

    /**
     * @dev Returns the token decimals.
     */
    function decimals() external view returns (uint8) {
        return _decimals;
    }

    /**
     * @dev Returns the token symbol.
     */
    function symbol() external view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the token name.
     */
    function name() external view returns (string memory) {
        return _name;
    }

    /**
     * @dev See {BEP20-totalSupply}.
     */
    function totalSupply() external view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {BEP20-balanceOf}.
     */
    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {BEP20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(
        address recipient,
        uint256 amount
    ) external returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    /**
     * @dev See {BEP20-allowance}.
     */
    function allowance(
        address owner,
        address spender
    ) external view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {BEP20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 amount) external returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    /**
     * @dev See {BEP20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {BEP20};
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(
            sender,
            _msgSender(),
            _allowances[sender][_msgSender()].sub(
                amount,
                "BEP20: transfer amount exceeds allowance"
            )
        );
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {BEP20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(
        address spender,
        uint256 addedValue
    ) public returns (bool) {
        _approve(
            _msgSender(),
            spender,
            _allowances[_msgSender()][spender].add(addedValue)
        );
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {BEP20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(
        address spender,
        uint256 subtractedValue
    ) public returns (bool) {
        _approve(
            _msgSender(),
            spender,
            _allowances[_msgSender()][spender].sub(
                subtractedValue,
                "BEP20: decreased allowance below zero"
            )
        );
        return true;
    }

    /**
     * @dev Creates `amount` tokens and assigns them to `msg.sender`, increasing
     * the total supply.
     *
     * Requirements
     *
     * - `msg.sender` must be the token owner
     */
    function mint(uint256 amount) public onlyOwner returns (bool) {
        _mint(_msgSender(), amount);
        return true;
    }

    /**
     * @dev Burn `amount` tokens and decreasing the total supply.
     */
    function burn(uint256 amount) public returns (bool) {
        _burn(_msgSender(), amount);
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(
        address sender,
        address recipient,
        uint256 amount
    ) internal {
        require(sender != address(0), "BEP20: transfer from the zero address");
        require(recipient != address(0), "BEP20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(
            amount,
            "BEP20: transfer amount exceeds balance"
        );
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "BEP20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 amount) internal {
        require(account != address(0), "BEP20: burn from the zero address");

        _balances[account] = _balances[account].sub(
            amount,
            "BEP20: burn amount exceeds balance"
        );
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), "BEP20: approve from the zero address");
        require(spender != address(0), "BEP20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See {_burn} and {_approve}.
     */
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(
            account,
            _msgSender(),
            _allowances[account][_msgSender()].sub(
                amount,
                "BEP20: burn amount exceeds allowance"
            )
        );
    }
}



interface myNFT {
    function balanceOf(address) external view returns (uint256);

    function ownerOf(uint256 tokenId) external view returns (address owner);
}

contract Staking is Ownable {
    address public feeWallet;
    address public Emergencyfund;
    uint256 public depositFeeBP = 1000; //10%
    uint256 public compoundFeeBP = 500; //5%
    uint256 public withdrawFeeBP = 500; //5%
    uint256 public withdrawLimit = 10000;
    uint256 public startBlock; // The block number when USDT rewards starts.
    uint256 public DROP_RATE = 60; //0.6 % per day
    uint256 public immutable seconds_per_day = 86400;
    uint256 public immutable Friday = 1679025600; // this is the 1st Friday
    uint256 public ActionDay = 1679025600; // this is a specific day (starts with Friday)
    address public NFTaddress; // this is the OG NFT contract address
    address public NFTaddress2; // this is the Whitelist NFT contract address

    IBEP20 public USDT;
    myNFT public NFTContract;
    myNFT public NFTContract2;
    mapping(address => UserInfo) public userInfo;

    struct Depo {
        uint256 amount; //deposit amount
        uint256 time; //deposit time
        uint256 lastActionTime; // last time this deposit was claimed/compounded/withdrawn
        uint256 unlocked; // after 60 days users decides to re-lock or not a deposit, 0 means locked, 1 relocked, 2 to withdraw
        uint256 isCompound; // 0 if deposit, 1 if compounded amount
    }

    struct UserInfo {
        Depo[] deposits;
        address WithdrawAddress; //by default msg.sender, can change with changeWithdrawalAddress()
        uint256 TotalDeposits; // Total USDT the user has provided
        uint256 TotalWithdrawn; // Total USDT the user has withdrawn
        uint256 NoOfDeposits; // No. of deposits
        uint256 TotalReinvested; // Total USDT compounded
        uint256 initialDeposit; // Initial deposit, separate cause locked forever
        uint256 lastRewardTimeStamp; // last time user did claim/compound/withdraw
        uint256 WithdrawDate; // The day user is able to withdraw funds
        uint256 WithdrawInitiated; // indicates withdraw intiated
        uint256 ClaimInitiated; // indicates claim intiated
        uint256 CompoundInitiated; // indicates compound intiated
        uint256 NFTId; // the tokenID
    }

    address[] public UsersInfo;

    event AdminTokenRecovery(address tokenRecovered, uint256 amount);
    event Deposit(address indexed user, uint256 amount);
    event UserClaim(address indexed user, uint256 amount);
    event UserCompound(address indexed user, uint256 amount);
    event UserWithdraw(address indexed user, uint256 amount);
    event SetFees(
        uint256 depositFeeBP,
        uint256 withdrawFeeBP,
        uint256 compoundFeeBP
    );

    event ClaimIsInitiated(address indexed user, uint256 unlockDay);
    event CompoundIsInitiated(address indexed user, uint256 unlockDay);
    event WithdrawIsInitiated(address indexed user, uint256 unlockDay);

    constructor(
        address _NFTaddress,
        address _NFTaddress2,
        address _USDTaddress
    ) {
        feeWallet = msg.sender;
        Emergencyfund = msg.sender;
        USDT = IBEP20(_USDTaddress);

        NFTaddress = _NFTaddress;
        NFTaddress2 = _NFTaddress2;
    }

    modifier hasNFT(address user) {
        require(
            NFTContract.balanceOf(user) != 0 ||
                NFTContract2.balanceOf(user) != 0,
            "User doesn't own NFT"
        );
        _;
    }

    modifier onlyActionDay() {
        require(getDifferenceFromActionDay() == 7, "wrong Action day");
        _;
    }
    modifier onlyInitiateActionDay() {
        require(
            getDifferenceFromActionDay() == 0 ||
                getDifferenceFromActionDay() == 13,
            "wrong Initiate day"
        );
        _;
    }

    modifier hasStarted() {
        require(startBlock != 0, "Not started yet");
        _;
    }

    /**
     * @notice function to initialise Staking.
     */
    function initialize() external onlyOwner {
        require(startBlock == 0, "already initialised");
        startBlock = block.timestamp;
    }

    /**
     * @notice function to change NFT contract addresses.
     */
    function changeNFTcontract(address _NFT, address _NFT2) external onlyOwner {
        require(_NFT != address(0) && _NFT2 != address(0));
        NFTContract = myNFT(_NFT);
        NFTContract2 = myNFT(_NFT2);
    }

    /**
     * @notice function to change USDT address.
     */
    function changeToken(address _USDTaddress) external onlyOwner {
        require(_USDTaddress != address(0));
        USDT = IBEP20(_USDTaddress);
    }

    /**
     * @notice function to intiate a deposit.
     * @param _amount: amount of USDT to deposit
     */
    function deposit(uint256 _amount) external hasStarted hasNFT(msg.sender) {
        UserInfo storage user = userInfo[msg.sender];
        require(user.WithdrawInitiated == 0, "Withdraw already initialised");

        uint256 depositFee = (_amount * depositFeeBP) / 10000;

        // only for 1st deposit
        if (user.TotalDeposits == 0) {
            require(_amount >= 1000 * 10 ** 18, "Minimum deposit is 1000$");
            UsersInfo.push(msg.sender);
            user.initialDeposit += _amount - depositFee;
            user.WithdrawAddress = msg.sender;
            address myId;
            address UserNFTaddress = NFTContract.balanceOf(msg.sender) != 0
                ? NFTaddress
                : NFTaddress2;

            user.NFTId = 111;
            for (uint256 i; i < 5000; ) {
                myId = myNFT(UserNFTaddress).ownerOf(i);

                if (myId == msg.sender) {
                    user.NFTId = i;
                    i = 5000;
                }
                unchecked {
                    ++i;
                }
            }
        }

        require(
            myNFT(NFTaddress).ownerOf(user.NFTId) == msg.sender ||
                myNFT(NFTaddress2).ownerOf(user.NFTId) == msg.sender,
            "wrong NFT"
        );

        user.deposits.push(
            Depo({
                amount: _amount - depositFee,
                time: block.timestamp,
                lastActionTime: 0,
                unlocked: 0,
                isCompound: 0
            })
        );

        USDT.transferFrom(
            address(msg.sender),
            address(this),
            _amount - depositFee
        );

        USDT.transferFrom(address(msg.sender), Emergencyfund, depositFee);
        user.TotalDeposits += _amount - depositFee;
        user.NoOfDeposits += 1;

        emit Deposit(msg.sender, _amount);
    }

    /**
     * @notice function to initiate a compound of all eligible deposits.
     * @param _action : 0 is Compound, 1 is Claim, 2 is Withdraw
     */
    function InitiateAction(uint256 _action) external onlyInitiateActionDay {
        UserInfo storage user = userInfo[msg.sender];
        require(
            user.WithdrawInitiated == 0 &&
                user.ClaimInitiated == 0 &&
                user.CompoundInitiated == 0 &&
                _action < 3,
            "Action already initialised"
        );
        require(
            block.timestamp > user.lastRewardTimeStamp + 6 days,
            "already interacted last 2 week"
        );
        if (_action == 0) {
            user.CompoundInitiated = 1;
            emit CompoundIsInitiated(msg.sender, block.timestamp);
        }
        if (_action == 1) {
            user.ClaimInitiated = 1;
            emit ClaimIsInitiated(msg.sender, block.timestamp);
        }
        if (_action == 2) {
            user.WithdrawDate = block.timestamp + 60 days;
            user.WithdrawInitiated = 1;
            emit WithdrawIsInitiated(msg.sender, block.timestamp + 60 days);
        }
        user.lastRewardTimeStamp = block.timestamp;
    }

    /**
     * @notice function to claim yield from deposits.
     */
    function Claim() external onlyActionDay returns (uint256 claimed) {
        UserInfo storage user = userInfo[msg.sender];
        require(user.ClaimInitiated == 1, "Claim Not initialised");
        require(
            block.timestamp > user.lastRewardTimeStamp + 6 days,
            "already interacted last 2 week"
        );

        uint256 NoOfDeposits = user.NoOfDeposits;
        for (uint256 i; i < NoOfDeposits; ) {
            Depo storage dep = user.deposits[i];

            if (
                checkReq(dep.amount, dep.time, dep.unlocked, dep.lastActionTime)
            ) {
                uint256 period = 7 days;
                uint256 rewardperblock = (dep.amount * DROP_RATE) /
                    seconds_per_day /
                    10000;
                claimed += (period * rewardperblock);
                dep.lastActionTime = block.timestamp;
            }
            unchecked {
                ++i;
            }
        }

        uint256 withdrawFee = (claimed * withdrawFeeBP) / 10000;

        USDT.transfer(feeWallet, withdrawFee);
        USDT.transfer(user.WithdrawAddress, claimed - withdrawFee);
        user.lastRewardTimeStamp = block.timestamp;
        user.ClaimInitiated = 0;

        emit UserClaim(msg.sender, claimed - withdrawFee);
        return claimed - withdrawFee;
    }

    /**
     * @notice function to compound yield from deposits.
     */
    function Compound()
        external
        onlyActionDay
        returns (uint256 compoundedAmount)
    {
        UserInfo storage user = userInfo[msg.sender];
        require(
            user.CompoundInitiated == 1,
            "Withdraw/Claim/Compound already initialised"
        );

        require(
            block.timestamp > user.lastRewardTimeStamp + 6 days,
            "already interacted last 2 week"
        );

        uint256 pending;
        uint256 compoundFee;
        uint256 NoOfDeposits = user.NoOfDeposits;

        for (uint256 i; i < NoOfDeposits; ) {
            Depo storage dep = user.deposits[i];

            if (
                checkReq(dep.amount, dep.time, dep.unlocked, dep.lastActionTime)
            ) {
                // user.lastRewardTimeStamp is last time user compounded/claimed

                uint256 period = 7 days; //because min and max are 7

                uint256 rewardperblock = (dep.amount * DROP_RATE) /
                    seconds_per_day /
                    10000;

                pending += (period * rewardperblock);
                dep.lastActionTime = block.timestamp;
            }

            unchecked {
                ++i;
            }
        }

        compoundFee = (pending * compoundFeeBP) / 10000;
        compoundedAmount = pending - compoundFee;
        //all compounds create a new compound
        user.deposits.push(
            Depo({
                amount: compoundedAmount,
                time: block.timestamp,
                lastActionTime: 0,
                unlocked: 0,
                isCompound: 1
            })
        );
        USDT.transfer(feeWallet, compoundFee);
        user.lastRewardTimeStamp = block.timestamp;
        user.NoOfDeposits += 1;
        user.CompoundInitiated = 0;
        user.TotalReinvested += compoundedAmount;

        emit UserCompound(msg.sender, compoundedAmount);
        return compoundedAmount;
    }

    /**
     * @notice function to withdraw deposits.
     */
    function Withdraw()
        external
        onlyActionDay
        returns (uint256 finalAmount, uint256 fee)
    {
        UserInfo storage user = userInfo[msg.sender];
        require(user.WithdrawInitiated == 1, "Withdraw not intiated");
        require(
            user.WithdrawDate != 0 && user.WithdrawDate < block.timestamp,
            "Withdraw not yet"
        );

        uint256 NoOfDeposits = user.NoOfDeposits;
        for (uint256 i; i < NoOfDeposits; ) {
            Depo storage dep = user.deposits[i];
            if (
                checkReq(dep.amount, dep.time, dep.unlocked, dep.lastActionTime)
            ) {
                // user.lastRewardTimeStamp is last time user compounded/claimed

                uint256 period = block.timestamp - dep.lastActionTime > 7 days
                    ? 7 days // because min and max are 7
                    : block.timestamp - dep.lastActionTime;

                uint256 rewardperblock = (dep.amount * DROP_RATE) /
                    seconds_per_day /
                    10000;

                dep.lastActionTime = block.timestamp;
                finalAmount += (period * rewardperblock) + dep.amount;
                //initial deposit is non-withdrawable
                if (i == 0) {
                    finalAmount -= dep.amount;
                } else {
                    dep.amount = 0;
                }
            }

            unchecked {
                ++i;
            }
        }

        // max withdraw is initially 10k USDT, if excess then create new Compounded Deposit
        if (finalAmount > withdrawLimit * 10 ** 18) {
            user.deposits.push(
                Depo({
                    amount: finalAmount - withdrawLimit * 10 ** 18,
                    time: block.timestamp,
                    lastActionTime: block.timestamp,
                    unlocked: 0,
                    isCompound: 1
                })
            );

            user.NoOfDeposits += 1;
            finalAmount = withdrawLimit * 10 ** 18;
        }

        fee = (finalAmount * withdrawFeeBP) / 10000;

        USDT.transfer(feeWallet, fee);
        USDT.transfer(user.WithdrawAddress, finalAmount - fee);
        user.TotalWithdrawn += finalAmount - fee;
        user.WithdrawInitiated = 0;
        user.WithdrawDate = 0;

        emit UserWithdraw(msg.sender, finalAmount - fee);
        return (finalAmount, fee);
    }

    /**
     * @notice function to change drop rate per day.
     * @param _newRate: rate 6 is 0.6% per day
     */
    function changeDROP_RATE(uint256 _newRate) external onlyOwner {
        DROP_RATE = _newRate;
    }

    function checkReq(
        uint256 amount,
        uint256 time,
        uint256 unlocked,
        uint256 lastActiontime
    ) internal view returns (bool accepted) {
        // any deposit with deposit.amount > 0 and deposit.time between 28 and  60 days or above 60 days and unlocked
        accepted = (amount > 0 &&
            ((block.timestamp > time + 28 days &&
                block.timestamp < time + 60 days) ||
                (block.timestamp > time + 60 days && unlocked == 1)) &&
            // can only do once per 2 weeks
            block.timestamp - lastActiontime > 7 days);
    }

    /**
     * @notice function to change withdraw limit
     * @param _withdrawLimit: 10000 is 10k USDT
     */
    function changeWithdraw_Limit(uint256 _withdrawLimit) external onlyOwner {
        withdrawLimit = _withdrawLimit;
    }

    /**
     * @notice function to change fees.
     * @param _depositFeeBP,  100 is 1%, 200 is 2% etc
     * * @param _withdrawFeeBP,  100 is 1%, 200 is 2% etc
     * * @param _compoundFeeBP,  100 is 1%, 200 is 2% etc
     */
    function changeFees(
        uint256 _depositFeeBP,
        uint256 _withdrawFeeBP,
        uint256 _compoundFeeBP
    ) external onlyOwner {
        require(
            _depositFeeBP != 0 && _withdrawFeeBP != 0 && _compoundFeeBP != 0,
            "Fees cannot be zero"
        );
        depositFeeBP = _depositFeeBP;
        withdrawFeeBP = _withdrawFeeBP;
        compoundFeeBP = _compoundFeeBP;
        emit SetFees(_depositFeeBP, _withdrawFeeBP, _compoundFeeBP);
    }

    /**
     * @notice function to change withdrawal address.
     * @param _newaddy: address to use as withdarw
     */
    function changeWithdrawalAddress(address _newaddy) external {
        require(_newaddy != address(0), "!nonzero");
        UserInfo storage user = userInfo[msg.sender];
        user.WithdrawAddress = _newaddy;
    }

    /**
     * @notice function to withdraw USDT.
     * @param _amount: amount to withdraw
     */
    function getAmount(uint256 _amount) external onlyOwner {
        USDT.transfer(msg.sender, _amount);
    }

    /**
     * @notice It allows the admin to recover wrong tokens sent to the contract
     * @param _tokenAddress: the address of the token to withdraw
     * @param _tokenAmount: the number of tokens to withdraw
     */
    function recoverTokens(
        address _tokenAddress,
        uint256 _tokenAmount
    ) external onlyOwner {
        IBEP20(_tokenAddress).transfer(address(msg.sender), _tokenAmount);
        emit AdminTokenRecovery(_tokenAddress, _tokenAmount);
    }

    /**
     * @notice function to change fee wallet
     */
    function ChangefeeAddress(address _feeWallet) external onlyOwner {
        require(_feeWallet != address(0), "!nonzero");
        feeWallet = _feeWallet;
    }

    /**
     * @notice function to change Emergency fee wallet
     */
    function ChangeEmergencyfeeAddress(
        address _Emergencyfund
    ) external onlyOwner {
        require(_Emergencyfund != address(0), "!nonzero");
        Emergencyfund = _Emergencyfund;
    }

    /**
     * @notice View function to see week.
     * @return totalweeks : no. of week since start
     */
    function getWeek() public view returns (uint256 totalweeks) {
        return (block.timestamp - Friday) / seconds_per_day / 14;
    }

    /**
     * @notice View function to see day difference between now and ActionDay.
     * @return 0 means you are on ActionDay, 1 means +1 from ActionDay, 2 means +2 etc
     */
    function getDifferenceFromActionDay() public view returns (uint256) {
        uint256 totalsec = (block.timestamp - ActionDay); //total sec from friday
        return totalsec / seconds_per_day - getWeek() * 14; //7 days in a week
    }

    /**
     * @notice function to decide if user will keep deposit or withdraw
     * @param _depo ; deposit number
     * @param _decision ; 1 = re-lock deposit for yield, 2 = withdraw deposit
     */
    function UnlockDeposit(uint256 _depo, uint256 _decision) external {
        UserInfo storage user = userInfo[msg.sender];
        Depo storage dep = user.deposits[_depo];
        require(dep.unlocked == 0, "already decided");
        require(block.timestamp > dep.time + 60 days, "only after 60 days");
        require(_decision == 1 || _decision == 2, "bad decision");
        dep.unlocked = _decision;
    }

    /**
     * @notice View function to see pending reward on frontend.
     * @return USDTReward Pending reward for a given user
     */
    function pendingRewards() public view returns (uint256 USDTReward) {
        UserInfo storage user = userInfo[msg.sender];
        uint256 NoOfDeposits = user.NoOfDeposits;
        for (uint256 i; i < NoOfDeposits; ) {
            USDTReward += pendingReward(i);

            unchecked {
                ++i;
            }
        }
    }

    /**
     * @notice View function to see pending reward for specific deposit on frontend.
     * @return USDTReward Pending reward for a given user/deposit
     */
    function pendingReward(
        uint256 _deposit
    ) public view returns (uint256 USDTReward) {
        UserInfo storage user = userInfo[msg.sender];
        Depo storage dep = user.deposits[_deposit];
        if (checkReq(dep.amount, dep.time, dep.unlocked, dep.lastActionTime)) {
            // user.lastRewardTimeStamp is last time user compounded/claimed

            uint256 period = block.timestamp - dep.lastActionTime > 7 days
                ? 7 days // because min and max are 7
                : block.timestamp - dep.lastActionTime;

            uint256 rewardperblock = (dep.amount * DROP_RATE) /
                seconds_per_day /
                10000;

            USDTReward += (period * rewardperblock);
        }
    }

    /**
     * @notice View function to see Final Withdras amount once its initiated.
     * @return finalAmount
     */
    function returnFinalAmount() public view returns (uint256 finalAmount) {
        UserInfo storage user = userInfo[msg.sender];

        if (user.WithdrawInitiated == 1) {
            uint256 NoOfDeposits = user.NoOfDeposits;
            for (uint256 i; i < NoOfDeposits; ) {
                Depo storage dep = user.deposits[i];
                if (
                    checkReq(
                        dep.amount,
                        dep.time,
                        dep.unlocked,
                        dep.lastActionTime
                    )
                ) {
                    uint256 period = block.timestamp - dep.lastActionTime >
                        7 days
                        ? 7 days
                        : block.timestamp - dep.lastActionTime;

                    uint256 rewardperblock = (dep.amount * DROP_RATE) /
                        seconds_per_day /
                        10000;
                    finalAmount += (period * rewardperblock) + dep.amount;
                    //initial deposit is non-withdrawable
                    if (i == 0) {
                        finalAmount -= dep.amount;
                    }
                }
                unchecked {
                    ++i;
                }
            }
            if (finalAmount > withdrawLimit * 10 ** 18) {
                finalAmount = withdrawLimit * 10 ** 18;
            }

            return (finalAmount - (finalAmount * withdrawFeeBP) / 10000);
        }
        return 0;
    }

    /**
     * @notice View function to see timer to deposit of user deposits.
     * @return time
     */
    function depositCounter(
        address _addr,
        uint256 index,
        uint256 _days
    ) external view returns (uint256 time) {
        UserInfo storage user = userInfo[_addr];
        Depo storage dep = user.deposits[index];

        if (dep.time + _days * 86400 > block.timestamp) {
            return dep.time + _days * 86400 - block.timestamp;
        }
        return 0;
    }

    /**
     * @notice View function to details of user deposits.
     * @return dep : struct Depo
     */
    function memberDeposit(
        address _addr,
        uint256 index
    ) external view returns (Depo memory dep) {
        UserInfo storage user = userInfo[_addr];
        dep = user.deposits[index];
        return (dep);
    }

    /**
     * @notice View function to get Total amount of all user deposit
     * @return amount : Total amount of all user deposit
     */
    function TotalmemberDeposits() external view returns (uint256 amount) {
        UserInfo storage user = userInfo[msg.sender];
        uint256 NoOfDeposits = user.NoOfDeposits;
        for (uint256 i; i < NoOfDeposits; ) {
            Depo storage dep = user.deposits[i];
            amount += dep.amount;
            unchecked {
                ++i;
            }
        }

        return (amount);
    }

    /**
     * @notice function for depositing rewards
     * @param _amount : Total USDT transferred in contract
     */
    function InjectRewards(uint256 _amount) external onlyOwner {
        USDT.transferFrom(address(msg.sender), address(this), _amount);
    }
}