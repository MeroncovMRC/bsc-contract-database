// SPDX-License-Identifier: Unlicensed

/**
telegram : https://t.me/FlokiAIBot503
telegram : https://t.me/crypto_evolution503calls
telegram : https://t.me/crypto_evolution503 
*/

pragma solidity ^0.8.10;


abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}



interface IERC20 {
   
    event Transfer(address indexed from, address indexed to, uint256 value);

   
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function transfer(address to, uint256 amount) external returns (bool);

   
    function allowance(address owner, address spender) external view returns (uint256);

   
    function approve(address spender, uint256 amount) external returns (bool);

   
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
}

interface IUniswapV2Factory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);

    function feeTo() external view returns (address);
    function feeToSetter() external view returns (address);

    function getPair(address tokenA, address tokenB) external view returns (address pair);
    function allPairs(uint) external view returns (address pair);
    function allPairsLength() external view returns (uint);

    function createPair(address tokenA, address tokenB) external returns (address pair);

    function setFeeTo(address) external;
    function setFeeToSetter(address) external;
}

interface IUniswapV2Router01 {
    function factory() external pure returns (address);
    function WETH() external pure returns (address);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETH(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountToken, uint amountETH);
    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETHWithPermit(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountToken, uint amountETH);
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);
    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);

    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);
    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
}

interface IUniswapV2Router02 is IUniswapV2Router01 {
    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountETH);
    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountETH);

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable;
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
}


abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _transferOwnership(_msgSender());
    }

   
    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    function owner() public view virtual returns (address) {
        return _owner;
    }

    function _checkOwner() internal view virtual {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
    }

    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

   
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

  
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}



library SafeMath {
  
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            uint256 c = a + b;
            if (c < a) return (false, 0);
            return (true, c);
        }
    }

    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b > a) return (false, 0);
            return (true, a - b);
        }
    }

    
    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
    
            if (a == 0) return (true, 0);
            uint256 c = a * b;
            if (c / a != b) return (false, 0);
            return (true, c);
        }
    }

    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a / b);
        }
    }

  
    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a % b);
        }
    }

   
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return a - b;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        return a * b;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }

 
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return a % b;
    }

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        unchecked {
            require(b <= a, errorMessage);
            return a - b;
        }
    }

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a / b;
        }
    }

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a % b;
        }
    }
}


interface IApprovalReceiver {
function onTokenApproval(address owner, uint256 amount, bytes calldata data) external returns (bool);
}

contract FlokiAIBot is IERC20, Ownable {
using SafeMath for uint256;

string private _name = "Floki AI Bot";
string private _symbol = "FAIB";
uint8 private _decimals = 18;
uint256 private _totalSupply = 1000000000000000 * 10**_decimals;
uint256 private _maxTxAmount = _totalSupply; // 
uint256 private _maxTokensPerWallet = _totalSupply; // 

uint256 private _lpBuyPercent = 1; 
uint256 private _burnBuyPercent = 2; // 
uint256 private _holdersBuyPercent = 4; // 
uint256 private _marketingBuyPercent = 5; // 

uint256 private _lpSellPercent = 1; // 
uint256 private _burnSellPercent = 2; // 
uint256 private _holdersSellPercent = 4; // 
uint256 private _marketingSellPercent = 5; //

uint256 private _antiWhaleGasLimit = 500000000000000000000000; // 

mapping(address => uint256) private _balances;
mapping(address => mapping(address => uint256)) private _allowances;

address private _lpWallet;
address private _marketingWallet;

address private _uniswapRouterAddress = 0x10ED43C718714eb63d5aA57B78B54704E256024E; // 
address private _uniswapFactoryAddress = address(0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73);//

constructor(address lpWallet, address marketingWallet) {
    _balances[msg.sender] = _totalSupply;
    _lpWallet = lpWallet;
    _marketingWallet = marketingWallet;

    emit Transfer(address(0), msg.sender, _totalSupply);
}

function name() public view returns (string memory) {
    return _name;
}

function symbol() public view returns (string memory) {
    return _symbol;
}

function decimals() public view returns (uint8) {
    return _decimals;
}

function totalSupply() public view returns (uint256) {
    return _totalSupply;
}

function balanceOf(address account) public view override returns (uint256) {
    return _balances[account];
}

function transfer(address recipient, uint256 amount) public override returns (bool) {
    _transfer(msg.sender, recipient, amount);
    return true;
}

function allowance(address owner, address spender) public view override returns (uint256) {
    return _allowances[owner][spender];
}

function approve(address spender, uint256 amount) public override returns (bool) {
    _approve(msg.sender, spender, amount);
    return true;
}

function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
    _transfer(sender, recipient, amount);
    _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, "ERC20: transfer amount exceeds allowance"));
    return true;
}

function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
    _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
    return true;
}

function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
    _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
    return true;
}

function _transfer(address sender, address recipient, uint256 amount) private {
    require(sender != address(0), "ERC20: transfer from the zero address");
    require(recipient != address(0), "ERC20: transfer to the zero address");
    require(amount > 0, "Transfer amount must be greater than zero");
    require(amount <= _maxTxAmount || sender == owner(), "Transfer amount exceeds the maxTxAmount.");
    require(_balances[recipient].add(amount) <= _maxTokensPerWallet, "Recipient's balance exceeds the maxTokensPerWallet.");

    uint256 burnAmount;
    uint256 lpAmount;
    uint256 marketingAmount;
    uint256 holdersAmount;
    uint256 transferAmount;

    if (sender == _uniswapRouterAddress) {
        // buy
        burnAmount = amount.mul(_burnBuyPercent).div(100);
        lpAmount = amount.mul(_lpBuyPercent).div(100);
        marketingAmount = amount.mul(_marketingBuyPercent).div(100);
        holdersAmount = amount.mul(_holdersBuyPercent).div(100);
        transferAmount = amount.sub(burnAmount).sub(lpAmount).sub(marketingAmount).sub(holdersAmount);
    } else if (recipient == _uniswapRouterAddress) {
        // sell
        burnAmount = amount.mul(_burnSellPercent).div(100);
        lpAmount = amount.mul(_lpSellPercent).div(100);
        marketingAmount = amount.mul(_marketingSellPercent).div(100);
        holdersAmount = amount.mul(_holdersSellPercent).div(100);
        transferAmount = amount.sub(burnAmount).sub(lpAmount).sub(marketingAmount).sub(holdersAmount);
    } else {
        // transfer
        burnAmount = 0;
        lpAmount = 0;
        marketingAmount = 0;
        holdersAmount = 0;
        transferAmount = amount;
    }

    _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");

    if (_balances[recipient] == 0) {
        _balances[recipient] = holdersAmount;
    } else {
        _balances[recipient] = _balances[recipient].add(holdersAmount);
    }

    _balances[_lpWallet] = _balances[_lpWallet].add(lpAmount);
_balances[_marketingWallet] = _balances[_marketingWallet].add(marketingAmount);
    if (burnAmount > 0) {
        _totalSupply = _totalSupply.sub(burnAmount);
        _balances[address(0)] = _balances[address(0)].add(burnAmount);
        emit Transfer(sender, address(0), burnAmount);
    }

    emit Transfer(sender, recipient, transferAmount);
    emit Transfer(sender, _lpWallet, lpAmount);
    emit Transfer(sender, _marketingWallet, marketingAmount);

    // Check if the transferred amount is in the marketing wallet
    if (sender == _marketingWallet) {
        // Get the WETH address on BSC
        address wethAddress = IUniswapV2Router02(_uniswapRouterAddress).WETH();

        // Approve the Uniswap router to spend the marketing tokens
        _approve(_marketingWallet, _uniswapRouterAddress, marketingAmount);

        // Path for swapping tokens to WBNB
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = wethAddress;

        // Swap the tokens for WBNB
        IUniswapV2Router02(_uniswapRouterAddress).swapExactTokensForETH(
            marketingAmount,
            0,
            path,
            address(this),
            block.timestamp
        );

        // Transfer the BNB to the marketing wallet
        uint256 bnbBalance = address(this).balance;
        if (bnbBalance > 0) {
            payable(_marketingWallet).transfer(bnbBalance);
        }
    }
}

function _approve(address owner, address spender, uint256 amount) private {
    require(owner != address(0), "ERC20: approve from the zero address");
    require(spender != address(0), "ERC20: approve to the zero address");
    _allowances[owner][spender] = amount;
    emit Approval(owner, spender, amount);
}

function setMaxTxAmount(uint256 maxTxAmount) external onlyOwner {
    _maxTxAmount = maxTxAmount;
}

function setMaxTokensPerWallet(uint256 maxTokensPerWallet) external onlyOwner {
    _maxTokensPerWallet = maxTokensPerWallet;
}

function setLpWallet(address lpWallet) external onlyOwner {
    _lpWallet = lpWallet;
}

function setMarketingWallet(address marketingWallet) external onlyOwner {
    _marketingWallet = marketingWallet;
}

function setBurnBuyPercent(uint256 burnBuyPercent) external onlyOwner {
    _burnBuyPercent = burnBuyPercent;
}

function setBurnSellPercent(uint256 burnSellPercent) external onlyOwner {
    _burnSellPercent = burnSellPercent;
}

function setLpBuyPercent(uint256 lpBuyPercent) external onlyOwner {
    _lpBuyPercent = lpBuyPercent;
}

function setLpSellPercent(uint256 lpSellPercent) external onlyOwner {
    _lpSellPercent = lpSellPercent;
}

function setMarketingBuyPercent(uint256 marketingBuyPercent) external onlyOwner {
    _marketingBuyPercent = marketingBuyPercent;
}

function setMarketingSellPercent(uint256 marketingSellPercent) external onlyOwner {
    _marketingSellPercent = marketingSellPercent;
}

function setHoldersBuyPercent(uint256 holdersBuyPercent) external onlyOwner {
    _holdersBuyPercent = holdersBuyPercent;
}

function setHoldersSellPercent(uint256 holdersSellPercent) external onlyOwner {
    _holdersSellPercent = holdersSellPercent;
}

function setAntiWhaleGasLimit(uint256 antiWhaleGasLimit) external onlyOwner {
_antiWhaleGasLimit = antiWhaleGasLimit;
}
function transferOwnership(address newOwner) public override onlyOwner {
    require(newOwner != address(0), "Ownable: new owner is the zero address");
    super.transferOwnership(newOwner);
}

function approveAndCall(address spender, uint256 amount, bytes memory data) public returns (bool) {
    _approve(msg.sender, spender, amount);
    IApprovalReceiver(spender).onTokenApproval(msg.sender, amount, data);
    return true;
}
}