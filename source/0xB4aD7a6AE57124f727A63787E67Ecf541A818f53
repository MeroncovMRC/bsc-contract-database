// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;


contract AiMeme {
    string public name = "AI MEME";
    string public symbol = "AIM";
    uint8 public decimals = 18;
    uint256 private constant MAX_SUPPLY = 1000000000000000 * 10 ** uint256(18);
    uint256 public totalSupply = 0;
    uint256 public burned = 0;

    mapping(address => uint256) private balances;
    mapping(address => mapping(address => uint256)) private allowed;

// wallets of the team

    address private constant WALLET_A = 0x48aEB1f3a4d8b078B5fa92C7A3b8901462043ff8; // replace with your address
    address private constant WALLET_B = 0x939A52621e9021e6999D4912fA382D922A1dcD46; // replace with your address
    address private constant WALLET_C = 0x6eE7De008C9C3B03E0A79B97B78Ae5B04b0b32EF; // replace with your address
    address private constant WALLET_D = 0x3604C014770182f2Df56bF8BA740381f79467d6D; // replace with your address
    address private constant WALLET_E = 0xFA6fE2Bb0da66f0A21e38450083Ac51Da064B81a; // replace with your address
    address private constant WALLET_F = 0xf6B660faBeADD5C103c779Fc9655983873e476f8; // replace with your address
    address private constant WALLET_G = 0xfEAB238aD80e065ad91A74464DF2E6e947F7da8D; // replace with your address
    address private constant WALLET_H = 0x1a8bb9179CfC71f01fbF459ea973e887a557627e; // replace with your address
    address private constant WALLET_I = 0x4A88F309587BaB4F6D3fAe45Acec4c5dFa43D28e; // replace with your address
    address private constant WALLET_J = 0x8FD608C7e72A479C2936Ca8Ab8dB7a010b043a1B; // replace with your address

    address private PERMANENT_OWNER = 0x48aEB1f3a4d8b078B5fa92C7A3b8901462043ff8; // replace with your address

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        balances[msg.sender] = MAX_SUPPLY;
        totalSupply = MAX_SUPPLY;

        // Transfer 2% of maximum supply to each of the 10 wallets of the team
        uint256 amount = MAX_SUPPLY / 50; // 2% of maximum supply
        transfer(WALLET_A, amount);
        transfer(WALLET_B, amount);
        transfer(WALLET_C, amount);
        transfer(WALLET_D, amount);
        transfer(WALLET_E, amount);
        transfer(WALLET_F, amount);
        transfer(WALLET_G, amount);
        transfer(WALLET_H, amount);
        transfer(WALLET_I, amount);
        transfer(WALLET_J, amount);
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0), "Invalid recipient address");
        require(_value <= balances[msg.sender], "Insufficient balance");

        // Apply sell tax
        uint256 sellTax = 0;
        if (msg.sender != PERMANENT_OWNER) {
            sellTax = _value * 5 / 100;
            burned += sellTax;
            _value -= sellTax;
            balances[address(this)] += sellTax;
        }

        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value);

        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0), "Invalid recipient address");
        require(_value <= balances[_from], "Insufficient balance");
        require(_value <= allowed[_from][msg.sender], "Insufficient allowance");

        // Apply sell tax
        uint256 sellTax = 0;
    if (_from != PERMANENT_OWNER) {
        sellTax = _value * 5 / 100;
        burned += sellTax;
        _value -= sellTax;
        balances[address(this)] += sellTax;
    }

    balances[_from] -= _value;
    allowed[_from][msg.sender] -= _value;
    balances[_to] += _value;
    emit Transfer(_from, _to, _value);

    return true;
}

function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
}

function approve(address _spender, uint256 _value) public returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
}

function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
    return allowed[_owner][_spender];
}

function calculateBurned() public view returns (uint256) {
    return burned;
}

function calculateTotalSupply() public view returns (uint256) {
    return totalSupply;
}

function calculateAvailableSupply() public view returns (uint256) {
    return totalSupply - burned;
}

function renounceOwnership() public {
    require(msg.sender == PERMANENT_OWNER, "Only permanent owner can renounce ownership");
    emit OwnershipRenounced(PERMANENT_OWNER);
    PERMANENT_OWNER = address(0);
}

event OwnershipRenounced(address indexed previousOwner);

modifier onlyPermanentOwner() {
    require(msg.sender == PERMANENT_OWNER, "Only permanent owner can perform this action");
    _;
}

function setPermanentOwnership(address newOwner) public onlyPermanentOwner {
    require(newOwner != address(0), "Invalid new owner address");
    emit OwnershipTransferred(PERMANENT_OWNER, newOwner);
    PERMANENT_OWNER = newOwner;
}

event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
}