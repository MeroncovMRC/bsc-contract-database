{"Address.sol":{"content":"/**\n * @title Address\n * @dev Address.sol contract\n *\n * @author - \u003cUSDFI TRUST\u003e\n * for the USDFI Trust\n *\n * SPDX-License-Identifier: MIT\n *\n **/\n\npragma solidity =0.8.17;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\u0027t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\u0027s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(\n            address(this).balance \u003e= amount,\n            \"Address: insufficient balance\"\n        );\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(\n            success,\n            \"Address: unable to send value, recipient may have reverted\"\n        );\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                0,\n                \"Address: low-level call failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                \"Address: low-level call with value failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(\n            address(this).balance \u003e= value,\n            \"Address: insufficient balance for call\"\n        );\n        (bool success, bytes memory returndata) = target.call{value: value}(\n            data\n        );\n        return\n            verifyCallResultFromTarget(\n                target,\n                success,\n                returndata,\n                errorMessage\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data)\n        internal\n        view\n        returns (bytes memory)\n    {\n        return\n            functionStaticCall(\n                target,\n                data,\n                \"Address: low-level static call failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return\n            verifyCallResultFromTarget(\n                target,\n                success,\n                returndata,\n                errorMessage\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return\n            functionDelegateCall(\n                target,\n                data,\n                \"Address: low-level delegate call failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return\n            verifyCallResultFromTarget(\n                target,\n                success,\n                returndata,\n                errorMessage\n            );\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\u0027t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage)\n        private\n        pure\n    {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"},"Gauge.sol":{"content":"/**\n * @title Gauge\n * @dev Gauge.sol contract\n *\n * @author - \u003cUSDFI TRUST\u003e\n * for the USDFI Trust\n *\n * SPDX-License-Identifier: Business Source License 1.1\n *\n **/\n\npragma solidity =0.8.17;\n\nimport \"./SafeERC20.sol\";\nimport \"./Math.sol\";\nimport \"./ReentrancyGuard.sol\";\nimport \"./IBasePair.sol\";\nimport \"./IBaseFactory.sol\";\nimport \"./IBribe.sol\";\nimport \"./IGaugeFactory.sol\";\nimport \"./ProtocolGovernance.sol\";\nimport \"./IReferrals.sol\";\nimport \"./IGauge.sol\";\n\ncontract Gauge is IGauge, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable STABLE;\n    IERC20 public immutable TOKEN;\n    address private immutable token;\n\n    uint256 public constant DURATION = 1 weeks;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n\n    uint256 public fees0;\n    uint256 public fees1;\n\n    address public immutable gaugeFactory;\n    address public referralContract;\n\n    mapping(address =\u003e mapping(address =\u003e bool)) public whitelisted;\n    mapping(address =\u003e uint256) public earnedRefs;\n\n    /**\n     * @dev Outputs the fee variables.\n     */\n    uint256 public referralFee;\n    uint256[] public refLevelPercent = [60000, 30000, 10000];\n\n    uint256 internal divisor = 100000;\n\n    modifier onlyDistribution() {\n        require(\n            msg.sender == gaugeFactory,\n            \"Caller is not RewardsDistribution contract\"\n        );\n        _;\n    }\n\n    mapping(address =\u003e uint256) public userRewardPerTokenPaid;\n    mapping(address =\u003e uint256) public rewards;\n\n    uint256 private _totalSupply;\n    uint256 public derivedSupply;\n    mapping(address =\u003e uint256) private _balances;\n    mapping(address =\u003e uint256) public derivedBalances;\n    mapping(address =\u003e uint256) private _base;\n\n    constructor(\n        address _stable,\n        address _token,\n        address _gaugeFactory\n    ) public {\n        STABLE = IERC20(_stable);\n        TOKEN = IERC20(_token);\n        token = _token;\n        gaugeFactory = _gaugeFactory;\n        referralContract = IProtocolGovernance(gaugeFactory)\n            .baseReferralsContract();\n        referralFee = IProtocolGovernance(gaugeFactory).baseReferralFee();\n    }\n\n    // Claim the fees from the LP token and Bribe to the voter\n    function claimVotingFees()\n        external\n        nonReentrant\n        returns (uint256 claimed0, uint256 claimed1)\n    {\n        return _claimVotingFees();\n    }\n\n    function _claimVotingFees()\n        internal\n        returns (uint256 claimed0, uint256 claimed1)\n    {\n        (claimed0, claimed1) = IBasePair(address(TOKEN)).claimFees();\n        if (claimed0 \u003e 0 || claimed1 \u003e 0) {\n            address bribe = IGaugeFactory(gaugeFactory).bribes(address(this));\n            uint256 _fees0 = fees0 + claimed0;\n            uint256 _fees1 = fees1 + claimed1;\n            (address _token0, address _token1) = IBasePair(address(TOKEN))\n                .tokens();\n            if (_fees0 \u003e DURATION) {\n                fees0 = 0;\n                IERC20(_token0).safeApprove(bribe, _fees0);\n                IBribe(bribe).notifyRewardAmount(_token0, _fees0);\n            } else {\n                fees0 = _fees0;\n            }\n            if (_fees1 \u003e DURATION) {\n                fees1 = 0;\n                IERC20(_token1).safeApprove(bribe, _fees1);\n                IBribe(bribe).notifyRewardAmount(_token1, _fees1);\n            } else {\n                fees1 = _fees1;\n            }\n\n            emit ClaimVotingFees(msg.sender, claimed0, claimed1);\n        }\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (derivedSupply == 0) {\n            return 0;\n        }\n\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored +\n            (((lastTimeRewardApplicable() - lastUpdateTime) *\n                rewardRate *\n                1e18) / derivedSupply);\n    }\n\n    // The derivedBalance function calculates the derived balance of an account, which is used to determine the amount of rewards earned by the account.\n    function derivedBalance(address account) public view returns (uint256) {\n        if (IGaugeFactory(gaugeFactory).weights(token) == 0) return 0;\n        uint256 _balance = _balances[account];\n        uint256 _derived = (_balance * 40) / 100;\n        uint256 _adjusted = ((((_totalSupply *\n            IGaugeFactory(gaugeFactory).votes(account, token)) /\n            IGaugeFactory(gaugeFactory).weights(token)) * 60) / 100);\n        return Math.min(_derived + _adjusted, _balance);\n    }\n\n    // The kick function updates the derived balance of an account and the total derived supply of the contract\n    function kick(address account) public {\n        uint256 _derivedBalance = derivedBalances[account];\n        derivedSupply = derivedSupply - _derivedBalance;\n        _derivedBalance = derivedBalance(account);\n        derivedBalances[account] = _derivedBalance;\n        derivedSupply = derivedSupply + _derivedBalance;\n        emit Kick(account);\n    }\n\n    // Your earned rewards (without referrals deduction)\n    function earned(address account) public view returns (uint256) {\n        if (derivedSupply == 0) {\n            return rewards[account];\n        }\n        return\n            ((derivedBalances[account] *\n                (rewardPerToken() - userRewardPerTokenPaid[account])) / 1e18) +\n            rewards[account];\n    }\n\n    // How many rewards will be distributed this epoch\n    function getRewardForDuration() external view returns (uint256) {\n        return rewardRate * DURATION;\n    }\n\n    // Deposit LP token\n    function deposit(uint256 amount) external {\n        _deposit(amount, msg.sender);\n    }\n\n    function depositFor(uint256 amount, address account) external {\n        _deposit(amount, account);\n    }\n\n    function _deposit(uint256 amount, address account)\n        internal\n        nonReentrant\n        updateReward(account)\n    {\n        require(account != address(0), \"cannot deposit to address 0\");\n        require(amount \u003e 0, \"deposit(Gauge): cannot stake 0\");\n\n        _balances[account] = _balances[account] + amount;\n        _totalSupply = _totalSupply + amount;\n\n        TOKEN.safeTransferFrom(msg.sender, address(this), amount);\n\n        emit Staked(account, amount);\n    }\n\n    // Withdraw LP token\n    function withdraw(uint256 amount) external {\n        _withdraw(amount);\n    }\n\n    function _withdraw(uint256 amount)\n        internal\n        nonReentrant\n        updateReward(msg.sender)\n    {\n        require(amount \u003e 0, \"Cannot withdraw 0\");\n        _totalSupply = _totalSupply - amount;\n        _balances[msg.sender] = _balances[msg.sender] - amount;\n        TOKEN.safeTransfer(msg.sender, amount);\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    // Claim your rewards\n    function getReward() external {\n        getRewardForOwnerToOtherOwner(msg.sender, msg.sender);\n    }\n\n    // Give the owner the earned rewards\n    function getRewardForOwner(address _owner) external {\n        getRewardForOwnerToOtherOwner(_owner, _owner);\n    }\n\n    // Get the reward from a owner to a whistlistet address or self\n    function getRewardForOwnerToOtherOwner(address _owner, address _receiver)\n        public\n        nonReentrant\n        updateReward(_owner)\n    {\n        uint256 reward = rewards[_owner];\n        if (reward \u003e 0) {\n            if (_owner != _receiver) {\n                require(\n                    _owner == msg.sender ||\n                        whitelisted[_owner][_receiver] == true,\n                    \"not owner or whitelisted\"\n                );\n            }\n            uint256 _divisor = divisor;\n            rewards[_owner] = 0;\n\n            uint256 refReward = (reward * referralFee) / _divisor;\n            uint256 remainingRefReward = refReward;\n\n            STABLE.safeTransfer(_receiver, reward - refReward);\n            emit RewardPaid(_owner, _receiver, reward - refReward);\n\n            address ref = IReferrals(referralContract).getSponsor(_owner);\n\n            uint256 i = 0;\n            while (i \u003c refLevelPercent.length \u0026\u0026 refLevelPercent[i] \u003e 0) {\n                if (ref != IReferrals(referralContract).membersList(0)) {\n                    uint256 refFeeAmount = (refReward * refLevelPercent[i]) /\n                        _divisor;\n                    remainingRefReward = remainingRefReward - refFeeAmount;\n                    STABLE.safeTransfer(ref, refFeeAmount);\n                    earnedRefs[ref] = earnedRefs[ref] + refFeeAmount;\n                    emit RefRewardPaid(ref, reward);\n                    ref = IReferrals(referralContract).getSponsor(ref);\n                    i++;\n                } else {\n                    break;\n                }\n            }\n            if (remainingRefReward \u003e 0) {\n                address _mainRefFeeReceiver = IProtocolGovernance(gaugeFactory)\n                    .mainRefFeeReceiver();\n                STABLE.safeTransfer(_mainRefFeeReceiver, remainingRefReward);\n                earnedRefs[_mainRefFeeReceiver] =\n                    earnedRefs[_mainRefFeeReceiver] +\n                    remainingRefReward;\n                emit RefRewardPaid(_mainRefFeeReceiver, remainingRefReward);\n            }\n        }\n    }\n\n    // Notify rewards for the LP depositer\n    function notifyRewardAmount(uint256 reward)\n        external\n        onlyDistribution\n        updateReward(address(0))\n    {\n        if (derivedSupply != 0) {\n            STABLE.safeTransferFrom(gaugeFactory, address(this), reward);\n            if (block.timestamp \u003e= periodFinish) {\n                rewardRate = reward / DURATION;\n            } else {\n                uint256 remaining = periodFinish - block.timestamp;\n                uint256 leftover = remaining * rewardRate;\n                rewardRate = (reward + leftover) / DURATION;\n            }\n        }\n        // Ensure the provided reward amount is not more than the balance in the contract.\n        // This keeps the reward rate in the right range, preventing overflows due to\n        // very high values of rewardRate in the earned and rewardsPerToken functions;\n        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n        uint256 balance = STABLE.balanceOf(address(this));\n        require(rewardRate \u003c= balance / DURATION, \"Provided reward too high\");\n\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp + DURATION;\n        emit RewardAdded(reward);\n    }\n\n    // Update the rewards\n    modifier updateReward(address account) {\n        if (block.timestamp \u003e IGaugeFactory(gaugeFactory).nextPoke(account)) {\n            IGaugeFactory(gaugeFactory).poke(account);\n        }\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n        if (account != address(0)) {\n            kick(account);\n        }\n    }\n\n    // Update the referral variables\n    function updateReferral(\n        address _referralsContract,\n        uint256 _referralFee,\n        uint256[] memory _refLevelPercent\n    ) public {\n        require(\n            msg.sender == IProtocolGovernance(gaugeFactory).governance() ||\n                msg.sender == IProtocolGovernance(gaugeFactory).admin(),\n            \"Pair: only factory\u0027s feeAmountOwner or admin\"\n        );\n        referralContract = _referralsContract;\n        referralFee = _referralFee;\n        refLevelPercent = _refLevelPercent;\n        emit UpdateReferral(referralContract, referralFee, refLevelPercent);\n    }\n\n    // Set whitelist for other receiver\n    function setWhitelisted(address _receiver, bool _whitelist) public {\n        whitelisted[msg.sender][_receiver] = _whitelist;\n        emit Whitelisted(msg.sender, _receiver);\n    }\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(\n        address indexed user,\n        address indexed receiver,\n        uint256 reward\n    );\n    event RefRewardPaid(address indexed user, uint256 reward);\n    event ClaimVotingFees(\n        address indexed from,\n        uint256 claimed0,\n        uint256 claimed1\n    );\n    event Whitelisted(address user, address whitelistedUser);\n    event UpdateReferral(\n        address referralContract,\n        uint256 referralFee,\n        uint256[] refLevelPercent\n    );\n    event Kick(address account);\n}\n"},"GaugeFactory.sol":{"content":"/**\n * @title Gauge Factory\n * @dev GaugeFactory.sol contract\n *\n * @author - \u003cUSDFI TRUST\u003e\n * for the USDFI Trust\n *\n * SPDX-License-Identifier: Business Source License 1.1\n *\n **/\n\npragma solidity =0.8.17;\n\nimport \"./Gauge.sol\";\nimport \"./IBaseBribeFactory.sol\";\nimport \"./ProtocolGovernance.sol\";\nimport \"./IStableMiner.sol\";\nimport \"./IGaugeFactory.sol\";\n\ncontract GaugeFactory is IGaugeFactory, ProtocolGovernance, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    IERC20 public veProxy;\n    IERC20 public immutable STABLE;\n\n    address public immutable bribeFactory; // Address for bribeFactory\n    uint256 public totalWeight;\n\n    // Time delays\n    uint256 public constant delay = 1 weeks;\n    uint256 public lastDistribute;\n    mapping(address =\u003e uint256) public lastVote; // msg.sender =\u003e time of users last vote\n    mapping(address =\u003e uint256) public nextPoke; // msg.sender =\u003e time of users next poke\n\n    // V2 added variables for pre-distribute\n    uint256 public lockedTotalWeight;\n    uint256 public lockedBalance;\n    uint256 public locktime;\n    uint256 public epoch;\n    mapping(address =\u003e uint256) public lockedWeights; // token =\u003e weight\n    mapping(address =\u003e uint256) public maxVotesToken; // token =\u003e max weight\n    mapping(address =\u003e bool) public hasDistributed; // LPtoken =\u003e bool\n\n    address[] public _tokens;\n    mapping(address =\u003e address) public gauges; // token =\u003e gauge\n    mapping(address =\u003e bool) public gaugeStatus; // token =\u003e bool : false = deprecated\n    mapping(address =\u003e bool) public gaugeExists; // token =\u003e bool : ture = exists\n    uint256 public pokeDelay = 4 weeks; // next auto poke in 30 days if you dont vote only farm\n\n    // Add Gauge to Bribe Mapping\n    mapping(address =\u003e address) public bribes; // gauge =\u003e bribes\n    mapping(address =\u003e uint256) public weights; // token =\u003e weight\n    mapping(address =\u003e mapping(address =\u003e uint256)) public votes; // msg.sender =\u003e votes\n    mapping(address =\u003e address[]) public tokenVote; // msg.sender =\u003e token\n    mapping(address =\u003e uint256) public usedWeights; // msg.sender =\u003e total voting weight of user\n\n    uint256 internal immutable divisor = 100000;\n\n    // Modifiers\n    modifier hasVoted(address voter) {\n        uint256 time = epoch - lastVote[voter];\n        require(time \u003e 0, \"You voted this epoch\");\n        _;\n    }\n\n    modifier hasDistribute() {\n        uint256 time = block.timestamp - lastDistribute;\n\n        require(time \u003e delay, \"this has been distributed in the last 7 days\");\n        _;\n    }\n\n    constructor(\n        address _stable,\n        address _veProxy,\n        address _bribeFactory,\n        address _stableMiner,\n        uint256 _startTimestamp,\n        address _baseReferralsContract,\n        address _mainRefFeeReceiver\n    ) public {\n        STABLE = IERC20(_stable);\n        veProxy = IERC20(_veProxy);\n        bribeFactory = _bribeFactory;\n        stableMiner = _stableMiner;\n        lastDistribute = _startTimestamp;\n        baseReferralsContract = _baseReferralsContract;\n        mainRefFeeReceiver = _mainRefFeeReceiver;\n        governance = msg.sender;\n        admin = msg.sender;\n    }\n\n    function tokens() external view returns (address[] memory) {\n        return _tokens;\n    }\n\n    function getGauge(address _token) external view returns (address) {\n        return gauges[_token];\n    }\n\n    function getBribes(address _gauge) external view returns (address) {\n        return bribes[_gauge];\n    }\n\n    // Reset votes to 0\n    function reset(address _user) external {\n        require(\n            (msg.sender == governance ||\n                msg.sender == admin ||\n                msg.sender == voter),\n            \"!gov or !admin\"\n        );\n        _reset(_user);\n    }\n\n    function _reset(address _owner) internal {\n        address[] storage _tokenVote = tokenVote[_owner];\n        uint256 _tokenVoteCnt = _tokenVote.length;\n\n        for (uint256 i = 0; i \u003c _tokenVoteCnt; i++) {\n            address _token = _tokenVote[i];\n            uint256 _votes = votes[_owner][_token];\n\n            if (_votes \u003e 0) {\n                totalWeight = totalWeight - _votes;\n                weights[_token] = weights[_token] - _votes;\n                // Bribe vote withdrawal\n                IBribe(bribes[gauges[_token]])._withdraw(\n                    uint256(_votes),\n                    _owner\n                );\n                votes[_owner][_token] = 0;\n                usedWeights[_owner] = 0;\n            }\n        }\n\n        delete tokenVote[_owner];\n    }\n\n    // Adjusts _owner\u0027s votes according to latest _owner\u0027s veSTABLE balance\n    function poke(address _owner) public {\n        require(\n            (gaugeExists[msg.sender] == true ||\n                msg.sender == governance ||\n                msg.sender == admin ||\n                msg.sender == voter),\n            \"!gov or !admin\"\n        );\n\n        address[] memory _tokenVote = tokenVote[_owner];\n        uint256 _tokenCnt = _tokenVote.length;\n        uint256[] memory _weights = new uint256[](_tokenCnt);\n        uint256 _prevUsedWeight = usedWeights[_owner];\n        uint256 _weight = veProxy.balanceOf(_owner);\n\n        for (uint256 i = 0; i \u003c _tokenCnt; i++) {\n            // Need to make this reflect the value deposited into bribes, anyone should be able to call this on\n            // other addresses to stop them from gaming the system with outdated votes that dont lose voting power\n            uint256 _prevWeight = votes[_owner][_tokenVote[i]];\n            _weights[i] = (_prevWeight * _weight) / _prevUsedWeight;\n        }\n        nextPoke[_owner] = block.timestamp + pokeDelay;\n        _vote(_owner, _tokenVote, _weights);\n    }\n\n    function _vote(\n        address _owner,\n        address[] memory _tokenVote,\n        uint256[] memory _weights\n    ) internal {\n        _reset(_owner);\n        uint256 _tokenCnt = _tokenVote.length;\n        uint256 _weight = veProxy.balanceOf(_owner);\n        uint256 _totalVoteWeight = 0;\n        uint256 _usedWeight = 0;\n        uint256 _totalWeight = totalWeight;\n\n        for (uint256 i = 0; i \u003c _tokenCnt; i++) {\n            _totalVoteWeight = _totalVoteWeight + _weights[i];\n        }\n\n        for (uint256 i = 0; i \u003c _tokenCnt; i++) {\n            address _token = _tokenVote[i];\n            address _gauge = gauges[_token];\n            uint256 _tokenWeight = (_weights[i] * _weight) / _totalVoteWeight;\n\n            if (_gauge != address(0x0) \u0026\u0026 gaugeStatus[_token]) {\n                _usedWeight = _usedWeight + _tokenWeight;\n                _totalWeight = _totalWeight + _tokenWeight;\n                weights[_token] = weights[_token] + _tokenWeight;\n                tokenVote[_owner].push(_token);\n                votes[_owner][_token] = _tokenWeight;\n                // Bribe vote deposit\n                IBribe(bribes[_gauge])._deposit(_tokenWeight, _owner);\n            }\n        }\n\n        totalWeight = _totalWeight;\n        usedWeights[_owner] = _usedWeight;\n    }\n\n    // Vote with veSTABLE on a gauge\n    function vote(\n        address _user,\n        address[] calldata _tokenVote,\n        uint256[] calldata _weights\n    ) external hasVoted(_user) {\n        require(\n            (msg.sender == governance ||\n                msg.sender == admin ||\n                msg.sender == voter),\n            \"!gov or !admin\"\n        );\n        require(_tokenVote.length == _weights.length);\n        lastVote[_user] = epoch;\n        nextPoke[_user] = block.timestamp + pokeDelay;\n        _vote(_user, _tokenVote, _weights);\n    }\n\n    // Add new token gauge\n    function addGauge(address _tokenLP, uint256 _maxVotesToken)\n        external\n        returns (address)\n    {\n        require(gauges[_tokenLP] == address(0x0), \"exists\");\n        require(_maxVotesToken \u003c= divisor, \"more then 100%\");\n        require(\n            msg.sender == governance || msg.sender == admin,\n            \"!gov or !admin\"\n        );\n        (address _token0, address _token1) = IBasePair(_tokenLP).tokens();\n\n        // Deploy Gauge\n        gauges[_tokenLP] = address(\n            new Gauge(address(STABLE), _tokenLP, address(this))\n        );\n        _tokens.push(_tokenLP);\n        maxVotesToken[_tokens[_tokens.length - 1]] = _maxVotesToken;\n        gaugeStatus[_tokenLP] = true; // set gauge to active\n        gaugeExists[gauges[_tokenLP]] = true; // Check if the gauge ever existed\n\n        // Deploy Bribe\n        address _bribe = IBribeFactory(bribeFactory).createBribe(\n            _token0,\n            _token1\n        );\n        bribes[gauges[_tokenLP]] = _bribe;\n        emit GaugeAdded(_tokenLP);\n        return gauges[_tokenLP];\n    }\n\n    // Deprecate existing gauge\n    function deprecateGauge(address _token) external {\n        require(\n            (msg.sender == governance || msg.sender == admin),\n            \"!gov or !admin\"\n        );\n        require(gauges[_token] != address(0x0), \"does not exist\");\n        require(gaugeStatus[_token], \"gauge is not active\");\n        gaugeStatus[_token] = false;\n        emit GaugeDeprecated(_token);\n    }\n\n    // Bring Deprecated gauge back into use\n    function resurrectGauge(address _token) external {\n        require(\n            (msg.sender == governance || msg.sender == admin),\n            \"!gov or !admin\"\n        );\n        require(gauges[_token] != address(0x0), \"does not exist\");\n        require(!gaugeStatus[_token], \"gauge is active\");\n        gaugeStatus[_token] = true;\n        emit GaugeResurrected(_token);\n    }\n\n    function length() external view returns (uint256) {\n        return _tokens.length;\n    }\n\n    // Used to pre-distribute tokens according to their weights for a new Epoch\n    // It calculates the maximum votes for each token, sets the locked weights of the tokens, and creates a new STABLE token\n    // It also updates the locked balance and last distribution time. The function emits an event with the updated values.\n    function preDistribute() external nonReentrant hasDistribute {\n        uint256 _lockedTotalWeight = totalWeight;\n        uint256 _divisor = divisor;\n\n        uint256[] memory _updatedLockedWeights = new uint256[](_tokens.length); // Create an array to store updated lockedWeights\n\n        for (uint256 i = 0; i \u003c _tokens.length; i++) {\n            address _token = _tokens[i];\n            uint256 _currentWeight = weights[_token];\n            _updatedLockedWeights[i] = _currentWeight; // Store the updated weight in memory\n\n            uint256 maxVotes = (_lockedTotalWeight * maxVotesToken[_token]) /\n                _divisor;\n\n            if (_updatedLockedWeights[i] \u003e= maxVotes) {\n                uint256 divOldNewVotes = _updatedLockedWeights[i] - maxVotes;\n\n                _updatedLockedWeights[i] = maxVotes;\n\n                _lockedTotalWeight = _lockedTotalWeight - divOldNewVotes;\n            }\n            lockedWeights[_token] = _updatedLockedWeights[i];\n            hasDistributed[_token] = false;\n        }\n\n        lockedTotalWeight = _lockedTotalWeight;\n        IStableMiner(stableMiner).createNewSTABLE();\n        lockedBalance = STABLE.balanceOf(address(this));\n        lastDistribute = lastDistribute + delay; // compensates for slight delays by the trigger\n        epoch++;\n\n        emit PreDistribute(\n            epoch,\n            lockedTotalWeight,\n            lockedBalance,\n            lastDistribute\n        );\n    }\n\n    // distributes rewards to token gauges based on their weight.\n    // It takes in two parameters, a start and an end index, which determine the range of tokens to be distributed\n    function distribute(uint256 _start, uint256 _end) public nonReentrant {\n        require(_start \u003c _end, \"bad _start\");\n        require(_end \u003c= _tokens.length, \"bad _end\");\n\n        if (lockedBalance \u003e 0 \u0026\u0026 lockedTotalWeight \u003e 0) {\n            for (uint256 i = _start; i \u003c _end; i++) {\n                address _token = _tokens[i];\n                if (!hasDistributed[_token] \u0026\u0026 gaugeStatus[_token]) {\n                    address _gauge = gauges[_token];\n                    uint256 _reward = (lockedBalance * lockedWeights[_token]) /\n                        lockedTotalWeight;\n                    if (_reward \u003e 0) {\n                        STABLE.safeApprove(_gauge, 0);\n                        STABLE.safeApprove(_gauge, _reward);\n                        Gauge(_gauge).notifyRewardAmount(_reward);\n                    }\n                    hasDistributed[_token] = true;\n                }\n            }\n        }\n    }\n\n    // Update the veProxy contract\n    function updateVeProxy(address _veProxy) public {\n        require(\n            (msg.sender == governance || msg.sender == admin),\n            \"!gov or !admin\"\n        );\n        veProxy = IERC20(_veProxy);\n\n        emit UpdateVeProxy(_veProxy);\n    }\n\n    // Update the poke delay for auto poke\n    function updatePokeDelay(uint256 _pokeDelay) public {\n        require(\n            (msg.sender == governance ||\n                msg.sender == admin ||\n                msg.sender == voter),\n            \"!gov or !admin\"\n        );\n        pokeDelay = _pokeDelay;\n\n        emit UpdatePokeDelay(pokeDelay);\n    }\n\n    // Update the max votes peer token\n    function updateMaxVotesToken(uint256 ID, uint256 _maxVotesToken) public {\n        require(\n            (msg.sender == governance ||\n                msg.sender == admin ||\n                msg.sender == voter),\n            \"!gov or !admin\"\n        );\n        require(_maxVotesToken \u003c= divisor, \"more then 100%\");\n        maxVotesToken[_tokens[ID]] = _maxVotesToken;\n\n        emit UpdateMaxVotesToken(ID, _maxVotesToken);\n    }\n\n    event GaugeAdded(address tokenLP);\n    event GaugeDeprecated(address tokenLP);\n    event GaugeResurrected(address tokenLP);\n    event UpdateMaxVotesToken(uint256 TokenID, uint256 maxVotesToken);\n    event UpdatePokeDelay(uint256 pokeDelay);\n    event UpdateVeProxy(address newProxy);\n    event PreDistribute(\n        uint256 indexed epoch,\n        uint256 lockedTotalWeight,\n        uint256 lockedBalance,\n        uint256 lastDistribute\n    );\n}\n"},"IBaseBribeFactory.sol":{"content":"/**\n * @title Interface Bribe Factory\n * @dev IBribeFactory.sol contract\n *\n * @author - \u003cUSDFI TRUST\u003e\n * for the USDFI Trust\n *\n * SPDX-License-Identifier: GNU GPLv2\n *\n **/\n\npragma solidity =0.8.17;\n\ninterface IBribeFactory {\n    function createBribe(address token0, address token1)\n        external\n        returns (address);\n}\n"},"IBaseFactory.sol":{"content":"/**\n * @title Interface Base V1 Factory\n * @dev IBaseV1Factory.sol contract\n *\n * @author - \u003cUSDFI TRUST\u003e\n * for the USDFI Trust\n *\n * SPDX-License-Identifier: Business Source License 1.1\n *\n **/\n\npragma solidity =0.8.17;\n\ninterface IBaseFactory {\n    function isPaused() external view returns (bool);\n\n    function owner() external view returns (address);\n\n    function pendingOwner() external view returns (address);\n\n    function admin() external view returns (address);\n\n    function feeAmountOwner() external view returns (address);\n\n    function baseStableFee() external view returns (uint256);\n\n    function baseVariableFee() external view returns (uint256);\n\n    function getPair(\n        address token0,\n        address token1,\n        bool stable\n    ) external view returns (address);\n\n    function allPairs(uint256 id) external view returns (address);\n\n    function isPair(address pair) external view returns (bool);\n\n    function protocolAddresses(address pair) external view returns (address);\n\n    function usdfiMaker() external view returns (address);\n\n    function maxGasPrice() external view returns (uint256);\n\n    function setBaseVariableFee(uint256 fee) external;\n\n    function setMaxGasPrice(uint256 gas) external;\n\n    function allPairsLength() external view returns (uint256);\n\n    function setOwner(address owner) external;\n\n    function acceptOwner() external;\n\n    function setPause(bool state) external;\n\n    function setProtocolAddress(address pair, address protocolAddress) external;\n\n    function setAdmins(\n        address usdfiMaker,\n        address feeAmountOwner,\n        address admin\n    ) external;\n\n    function pairCodeHash() external pure returns (bytes32);\n\n    function getInitializable()\n        external\n        view\n        returns (\n            address,\n            address,\n            bool\n        );\n\n    function createPair(\n        address tokenA,\n        address tokenB,\n        bool stable\n    ) external returns (address pair);\n}\n"},"IBaseFees.sol":{"content":"/**\n * @title Interface Base Fees\n * @dev IBaseFees.sol contract\n *\n * @author - \u003cUSDFI TRUST\u003e\n * for the USDFI Trust\n *\n * SPDX-License-Identifier: Business Source License 1.1\n *\n **/\n\npragma solidity =0.8.17;\n\ninterface IBaseFees {\n    function protocolFee() external view returns (uint256);\n\n    function usdfiMakerFee() external view returns (uint256);\n\n    function lpOwnerFee() external view returns (uint256);\n\n    function claimFeesFor(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1\n    ) external returns (uint256 claimed0, uint256 claimed1);\n\n    function setFeeAmount(\n        uint256 protocolFee,\n        uint256 usdfiMakerFee,\n        uint256 lpOwnerFee\n    ) external;\n}\n"},"IBasePair.sol":{"content":"/**\n * @title Interface Base Pair\n * @dev IBasePair.sol contract\n *\n * @author - \u003cUSDFI TRUST\u003e\n * for the USDFI Trust\n *\n * SPDX-License-Identifier: Business Source License 1.1\n *\n **/\n\npragma solidity =0.8.17;\n\ninterface IBasePair {\n    function name() external view returns (string calldata);\n\n    function symbol() external view returns (string calldata);\n\n    function decimals() external view returns (uint8);\n\n    function stable() external view returns (bool);\n\n    function fee() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external view returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function fees() external view returns (address);\n\n    function reserve0() external view returns (uint256);\n\n    function reserve1() external view returns (uint256);\n\n    function blockTimestampLast() external view returns (uint256);\n\n    function reserve0CumulativeLast() external view returns (uint256);\n\n    function reserve1CumulativeLast() external view returns (uint256);\n\n    function index0() external view returns (uint256);\n\n    function index1() external view returns (uint256);\n\n    function supplyIndex0(address owner) external view returns (uint256);\n\n    function supplyIndex1(address owner) external view returns (uint256);\n\n    function claimable0(address owner) external view returns (uint256);\n\n    function claimable1(address owner) external view returns (uint256);\n\n    function observationLength() external view returns (uint256);\n\n    function metadata()\n        external\n        view\n        returns (\n            uint256 decimals0,\n            uint256 decimals1,\n            uint256 reserve0,\n            uint256 reserve1,\n            bool stable,\n            address token0,\n            address token1\n        );\n\n    function tokens() external view returns (address, address);\n\n    function usdfiMaker() external view returns (address);\n\n    function protocol() external view returns (address);\n\n    function claimFees() external returns (uint256 claimed0, uint256 claimed1);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint256 reserve0,\n            uint256 reserve1,\n            uint256 blockTimestampLast\n        );\n\n    function currentCumulativePrices()\n        external\n        view\n        returns (\n            uint256 reserve0Cumulative,\n            uint256 reserve1Cumulative,\n            uint256 blockTimestamp\n        );\n\n    function current(address tokenIn, uint256 amountIn)\n        external\n        view\n        returns (uint256 amountOut);\n\n    function quote(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 granularity\n    ) external view returns (uint256 amountOut);\n\n    function prices(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 points\n    ) external view returns (uint256[] memory);\n\n    function sample(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 points,\n        uint256 window\n    ) external view returns (uint256[] memory);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(address to)\n        external\n        returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function getAmountOut(uint256 amountIn, address tokenIn)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function transfer(address dst, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amount\n    ) external returns (bool);\n\n    function setFee(uint256 fee) external;\n}\n"},"IBribe.sol":{"content":"/**\n * @title Interface Bribe\n * @dev IBribe.sol contract\n *\n * @author - \u003cUSDFI TRUST\u003e\n * for the USDFI Trust\n *\n * SPDX-License-Identifier: Business Source License 1.1\n *\n **/\n\npragma solidity =0.8.17;\n\ninterface IBribe {\n    function WEEK() external view returns (uint256);\n\n    function firstBribeTimestamp() external view returns (uint256);\n\n    function isRewardToken(address token) external view returns (bool);\n\n    function rewardTokens(uint256 ID) external view returns (address);\n\n    function gaugeFactory() external view returns (address);\n\n    function bribeFactory() external view returns (address);\n\n    function userTimestamp(address owner, address token)\n        external\n        view\n        returns (uint256);\n\n    function _totalSupply(uint256 timestamp) external view returns (uint256);\n\n    function _balances(address owner, uint256 timestamp)\n        external\n        view\n        returns (uint256);\n\n    function referralFee() external view returns (uint256);\n\n    function referralContract() external view returns (address);\n\n    function refLevelPercent(uint256 level) external view returns (uint256);\n\n    function earnedRefs(address owner, address token)\n        external\n        view\n        returns (uint256);\n\n    function whitelisted(address owner, address receiver)\n        external\n        view\n        returns (bool);\n\n    function userFirstDeposit(address owner) external view returns (uint256);\n\n    function getEpoch() external view returns (uint256);\n\n    function rewardsListLength() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function totalSupplyNextEpoch() external view returns (uint256);\n\n    function totalSupplyAt(uint256 timestamp) external view returns (uint256);\n\n    function balanceOfAt(address voter, uint256 timestamp)\n        external\n        view\n        returns (uint256);\n\n    function balanceOf(address voter) external view returns (uint256);\n\n    function earned(address voter, address rewardToken)\n        external\n        view\n        returns (uint256);\n\n    function _earned(\n        address voter,\n        address rewardToken,\n        uint256 timestamp\n    ) external view returns (uint256);\n\n    function rewardPerToken(address rewardsToken, uint256 timestmap)\n        external\n        view\n        returns (uint256);\n\n    function _deposit(uint256 amount, address voter) external;\n\n    function _withdraw(uint256 amount, address voter) external;\n\n    function notifyRewardAmount(address rewardsToken, uint256 reward) external;\n\n    function getReward() external;\n\n    function getRewardForOwner(address voter) external;\n\n    function getRewardForOwnerToOtherOwner(address voter, address receiver)\n        external;\n\n    function getRewardForOwnerToOtherOwnerSingleToken(\n        address voter,\n        address receiver,\n        address[] memory tokens\n    ) external;\n\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external;\n\n    function addRewardtoken(address rewardsToken) external;\n\n    function setWhitelisted(address receiver, bool whitlist) external;\n\n    function updateReferral(\n        address referralsContract,\n        uint256 referralFee,\n        uint256[] memory refLevelPercent\n    ) external;\n}\n"},"IERC20.sol":{"content":"/**\n * @title Interface ERC20\n * @dev IERC20.sol contract\n *\n * @author - \u003cUSDFI TRUST\u003e\n * for the USDFI Trust\n *\n * SPDX-License-Identifier: MIT\n *\n **/\n\npragma solidity =0.8.17;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n}\n"},"IGauge.sol":{"content":"/**\n * @title Interface Gauge\n * @dev IGauge.sol contract\n *\n * @author - \u003cUSDFI TRUST\u003e\n * for the USDFI Trust\n *\n * SPDX-License-Identifier: Business Source License 1.1\n *\n **/\n\npragma solidity =0.8.17;\n\ninterface IGauge {\n    function DURATION() external returns (uint256);\n\n    function periodFinish() external returns (uint256);\n\n    function rewardRate() external returns (uint256);\n\n    function lastUpdateTime() external returns (uint256);\n\n    function rewardPerTokenStored() external returns (uint256);\n\n    function fees0() external returns (uint256);\n\n    function fees1() external returns (uint256);\n\n    function gaugeFactory() external returns (address);\n\n    function referralContract() external returns (address);\n\n    function whitelisted(address owner, address receiver)\n        external\n        returns (bool);\n\n    function earnedRefs(address owner) external returns (uint256);\n\n    function referralFee() external returns (uint256);\n\n    function refLevelPercent(uint256 level) external returns (uint256);\n\n    function userRewardPerTokenPaid(address owner) external returns (uint256);\n\n    function rewards(address owner) external returns (uint256);\n\n    function derivedSupply() external returns (uint256);\n\n    function derivedBalances(address owner) external returns (uint256);\n\n    function claimVotingFees()\n        external\n        returns (uint256 claimed0, uint256 claimed1);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function lastTimeRewardApplicable() external view returns (uint256);\n\n    function rewardPerToken() external view returns (uint256);\n\n    function derivedBalance(address account) external view returns (uint256);\n\n    function kick(address account) external;\n\n    function earned(address account) external view returns (uint256);\n\n    function getRewardForDuration() external view returns (uint256);\n\n    function deposit(uint256 amount) external;\n\n    function depositFor(uint256 amount, address account) external;\n\n    function withdraw(uint256 amount) external;\n\n    function getReward() external;\n\n    function getRewardForOwner(address owner) external;\n\n    function getRewardForOwnerToOtherOwner(address owner, address receiver)\n        external;\n\n    function notifyRewardAmount(uint256 reward) external;\n\n    function updateReferral(\n        address referralsContract,\n        uint256 referralFee,\n        uint256[] memory refLevelPercent\n    ) external;\n\n    function setWhitelisted(address receiver, bool whitelist) external;\n}\n"},"IGaugeFactory.sol":{"content":"/**\n * @title Interface Gauge Factory\n * @dev IGaugeFactory.sol contract\n *\n * @author - \u003cUSDFI TRUST\u003e\n * for the USDFI Trust\n *\n * SPDX-License-Identifier: Business Source License 1.1\n *\n **/\n\npragma solidity =0.8.17;\n\ninterface IGaugeFactory {\n    function tokens() external view returns (address[] memory);\n\n    function getGauge(address token) external view returns (address);\n\n    function getBribes(address gauge) external view returns (address);\n\n    function reset(address user) external;\n\n    function poke(address owner) external;\n\n    function vote(\n        address user,\n        address[] calldata tokenVote,\n        uint256[] calldata weights\n    ) external;\n\n    function addGauge(address tokenLP, uint256 maxVotesToken)\n        external\n        returns (address);\n\n    function deprecateGauge(address token) external;\n\n    function resurrectGauge(address token) external;\n\n    function length() external view returns (uint256);\n\n    function distribute(uint256 start, uint256 end) external;\n\n    function updateVeProxy(address veProxy) external;\n\n    function updatePokeDelay(uint256 pokeDelay) external;\n\n    function updateMaxVotesToken(uint256 ID, uint256 maxVotesToken) external;\n\n    function bribeFactory() external view returns (address);\n\n    function totalWeight() external view returns (uint256);\n\n    function delay() external view returns (uint256);\n\n    function lastDistribute() external view returns (uint256);\n\n    function lastVote(address user) external view returns (uint256);\n\n    function nextPoke(address user) external view returns (uint256);\n\n    function lockedTotalWeight() external view returns (uint256);\n\n    function lockedBalance() external view returns (uint256);\n\n    function locktime() external view returns (uint256);\n\n    function epoch() external view returns (uint256);\n\n    function lockedWeights(address user) external view returns (uint256);\n\n    function maxVotesToken(address user) external view returns (uint256);\n\n    function hasDistributed(address user) external view returns (bool);\n\n    function _tokens(uint256 tokenID) external view returns (address);\n\n    function gauges(address token) external view returns (address);\n\n    function gaugeStatus(address token) external view returns (bool);\n\n    function gaugeExists(address token) external view returns (bool);\n\n    function pokeDelay() external view returns (uint256);\n\n    function bribes(address gauge) external view returns (address);\n\n    function weights(address token) external view returns (uint256);\n\n    function votes(address user, address token) external view returns (uint256);\n\n    function tokenVote(address user, uint256 tokenID)\n        external\n        view\n        returns (address);\n\n    function usedWeights(address user) external view returns (uint256);\n}\n"},"IProtocolGovernance.sol":{"content":"/**\n * @title Interface Protocol Governance\n * @dev IProtocolGovernance.sol contract\n *\n * @author - \u003cUSDFI TRUST\u003e\n * for the USDFI Trust\n *\n * SPDX-License-Identifier: Business Source License 1.1\n *\n **/\n\npragma solidity =0.8.17;\n\ninterface IProtocolGovernance {\n    function setGovernance(address governance) external;\n\n    function acceptGovernance() external;\n\n    function setAdminAndVoter(address admin, address voter) external;\n\n    function setStableMiner(address stableMiner) external;\n\n    function updateBaseReferrals(\n        address referralsContract,\n        uint256 baseReferralFee,\n        address mainRefFeeReceiver\n    ) external;\n\n    function governance() external view returns (address);\n\n    function pendingGovernance() external view returns (address);\n\n    function admin() external view returns (address);\n\n    function voter() external view returns (address);\n\n    function stableMiner() external view returns (address);\n\n    function baseReferralsContract() external view returns (address);\n\n    function baseReferralFee() external view returns (uint256);\n\n    function mainRefFeeReceiver() external view returns (address);\n}\n"},"IReferrals.sol":{"content":"/**\n * @title Interface Referrals\n * @dev IReferrals contract\n *\n * @author - \u003cUSDFI TRUST\u003e\n * for the USDFI Trust\n *\n * SPDX-License-Identifier: Business Source License 1.1\n *\n **/\n\npragma solidity =0.8.17;\n\ninterface IReferrals {\n    function getSponsor(address _account) external view returns (address);\n\n    function isMember(address _user) external view returns (bool);\n\n    function addMember(address _member, address _parent) external;\n\n    function membersList(uint256 _id) external view returns (address);\n\n    function getListReferrals(address _member)\n        external\n        view\n        returns (address[] memory);\n}\n"},"IStableMiner.sol":{"content":"/**\n * @title Interface Stable Miner\n * @dev IStableMiner.sol contract\n *\n * @author - \u003cUSDFI TRUST\u003e\n * for the USDFI Trust\n *\n * SPDX-License-Identifier: Business Source License 1.1\n *\n **/\n\npragma solidity =0.8.17;\n\ninterface IStableMiner {\n    function createNewSTABLE() external;\n}\n"},"Math.sol":{"content":"/**\n * @title Math\n * @dev Math.sol contract\n *\n * @author - \u003cUSDFI TRUST\u003e\n * for the USDFI Trust\n *\n * SPDX-License-Identifier: MIT\n *\n **/\n\npragma solidity =0.8.17;\n\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003e= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\n    }\n}\n"},"ProtocolGovernance.sol":{"content":"/**\n * @title Protocol Governance\n * @dev ProtocolGovernance.sol contract\n *\n * @author - \u003cUSDFI TRUST\u003e\n * for the USDFI Trust\n *\n * SPDX-License-Identifier: Business Source License 1.1\n *\n **/\n\npragma solidity =0.8.17;\n\nimport \"./IProtocolGovernance.sol\";\n\ncontract ProtocolGovernance is IProtocolGovernance {\n    /// @notice governance address for the governance contract\n    address public governance;\n    address public pendingGovernance;\n    address public admin; //Admin address to manage gauges like add/deprecate/resurrect\n    address public voter; //Admin address to manage voting\n    address public stableMiner; // Address for stable miner\n\n    // Base fee variables\n    address public baseReferralsContract;\n    uint256 public baseReferralFee = 2000;\n    address public mainRefFeeReceiver;\n\n    /**\n     * @notice Allows governance to change governance (for future upgradability)\n     * @param _governance new governance address to set\n     */\n    function setGovernance(address _governance) external {\n        require(msg.sender == governance, \"setGovernance: !gov\");\n        pendingGovernance = _governance;\n\n        emit SetGovernance(pendingGovernance);\n    }\n\n    /**\n     * @notice Allows pendingGovernance to accept their role as governance (protection pattern)\n     */\n    function acceptGovernance() external {\n        require(\n            msg.sender == pendingGovernance,\n            \"acceptGovernance: !pendingGov\"\n        );\n        governance = pendingGovernance;\n\n        emit AcceptGovernance(governance);\n    }\n\n    /**\n     * @notice Allows governance to change governance (for future upgradability)\n     * @param _admin new admin address to set\n     * @param _voter new voter address to set\n     */\n    function setAdminAndVoter(address _admin, address _voter) external {\n        require(msg.sender == governance, \"!gov\");\n        admin = _admin;\n        voter = _voter;\n        emit SetAdminAndVoter(admin, voter);\n    }\n\n    // Set Stable-miner\n    function setStableMiner(address _stableMiner) external {\n        require(msg.sender == governance || msg.sender == admin, \"!gov\");\n        stableMiner = _stableMiner;\n        emit SetStableMiner(stableMiner);\n    }\n\n    // Update the base referral contract and base referral fee and the main referral fee receiver\n    function updateBaseReferrals(\n        address _referralsContract,\n        uint256 _baseReferralFee,\n        address _mainRefFeeReceiver\n    ) public {\n        require(\n            (msg.sender == governance || msg.sender == admin),\n            \"!gov or !admin\"\n        );\n        require((_baseReferralFee \u003c= 10000), \"must be lower 10%\");\n        baseReferralsContract = _referralsContract;\n        baseReferralFee = _baseReferralFee;\n        mainRefFeeReceiver = _mainRefFeeReceiver;\n        emit UpdateBaseReferrals(\n            baseReferralsContract,\n            baseReferralFee,\n            mainRefFeeReceiver\n        );\n    }\n\n    event UpdateBaseReferrals(\n        address referralContract,\n        uint256 referralFee,\n        address refLevelPercent\n    );\n    event SetStableMiner(address stableMiner);\n    event SetAdminAndVoter(address admin, address voter);\n    event SetGovernance(address pendingGovernance);\n    event AcceptGovernance(address governance);\n}\n"},"ReentrancyGuard.sol":{"content":"/**\n * @title Reentrancy Guard\n * @dev ReentrancyGuard.sol contract\n *\n * @author - \u003cUSDFI TRUST\u003e\n * for the USDFI Trust\n *\n * SPDX-License-Identifier: MIT\n *\n **/\n\npragma solidity =0.8.17;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\u0027s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\u0027s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\u0027s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"},"SafeERC20.sol":{"content":"/**\n * @title Safe ERC20\n * @dev SafeERC20.sol contract\n *\n * @author - \u003cUSDFI TRUST\u003e\n * for the USDFI Trust\n *\n * SPDX-License-Identifier: MIT\n *\n **/\n\npragma solidity =0.8.17;\n\nimport \"./Address.sol\";\nimport \"./IERC20.sol\";\n\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transfer.selector, to, value)\n        );\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n        );\n    }\n\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.approve.selector, spender, value)\n        );\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) - value;\n        callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    }\n\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(\n                abi.decode(returndata, (bool)),\n                \"SafeERC20: ERC20 operation did not succeed\"\n            );\n        }\n    }\n}\n"}}