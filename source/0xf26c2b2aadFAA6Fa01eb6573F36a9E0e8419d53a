{"Context.sol":{"content":"\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.7;\r\ncontract Context {\r\n  // Empty internal constructor, to prevent people from mistakenly deploying\r\n  // an instance of this contract, which should be used via inheritance.\r\n  constructor () { }\r\n\r\n  function _msgSender() internal view returns (address payable) {\r\n    return payable(msg.sender);\r\n  }\r\n\r\n  function _msgData() internal view returns (bytes memory) {\r\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n    return msg.data;\r\n  }\r\n}"},"DividendDistributor.sol":{"content":"//SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.7;\r\n\r\nimport \"./IBEP20.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport \"./uniswapV02.sol\";\r\n\r\ninterface IDividendDistributor {\r\n    function setDistributionCriteria(\r\n        uint256 _minPeriod,\r\n        uint256 _minDistribution\r\n        \r\n    ) external;\r\n\r\n    function setShare(address shareholder, uint256 amount) external;\r\n\r\n    function deposit(uint256 amount) external;\r\n\r\n    function process(uint256 gas) external;\r\n\r\n    function purge(address receiver) external;\r\n}\r\n\r\ncontract DividendDistributor is IDividendDistributor {\r\n    using SafeMath for uint256;\r\n\r\n    address public _token;\r\n\r\n    struct Share {\r\n        uint256 amount;\r\n        uint256 totalExcluded;\r\n        uint256 totalRealised;\r\n    }\r\n\r\n    IBEP20 public REWARD;\r\n    address public WBNB = 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd;\r\n    IUniswapV2Router02 public router;\r\n\r\n    address[] shareholders;\r\n    mapping(address =\u003e uint256) shareholderIndexes;\r\n    mapping(address =\u003e uint256) shareholderClaims;\r\n\r\n    mapping(address =\u003e Share) public shares;\r\n\r\n    uint256 public totalShares;\r\n    uint256 public totalDividends;\r\n    uint256 public totalDistributed;\r\n    uint256 public dividendsPerShare;\r\n    uint256 public dividendsPerShareAccuracyFactor = 10**36;\r\n\r\n    uint256 public minPeriod = 30 * 60;\r\n    uint256 public minDistribution = 1 * (10**9);\r\n\r\n    uint256 currentIndex;\r\n\r\n    bool initialized;\r\n    modifier initialization() {\r\n        require(!initialized);\r\n        _;\r\n        initialized = true;\r\n    }\r\n\r\n    modifier onlyToken() {\r\n        require(msg.sender == _token);\r\n        _;\r\n    }\r\n\r\n    constructor(address _router, address rewardToken) {\r\n        router = _router != address(0)\r\n            ? IUniswapV2Router02(_router)\r\n            : IUniswapV2Router02(0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3);\r\n        _token = msg.sender;\r\n        REWARD = IBEP20(rewardToken);\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function setDistributionCriteria(\r\n        uint256 _minPeriod,\r\n        uint256 _minDistribution\r\n    ) external override onlyToken {\r\n        minPeriod = _minPeriod;\r\n        minDistribution = _minDistribution;\r\n    }\r\n\r\n    function purge(address receiver) external override onlyToken {\r\n        uint256 balance = REWARD.balanceOf(address(this));\r\n        REWARD.transfer(receiver, balance);\r\n    }\r\n\r\n    function setShare(address shareholder, uint256 amount)\r\n        external\r\n        override\r\n        onlyToken\r\n    {\r\n        if (shares[shareholder].amount \u003e 0) {\r\n            distributeDividend(shareholder);\r\n        }\r\n\r\n        if (amount \u003e 0 \u0026\u0026 shares[shareholder].amount == 0) {\r\n            addShareholder(shareholder);\r\n        } else if (amount == 0 \u0026\u0026 shares[shareholder].amount \u003e 0) {\r\n            removeShareholder(shareholder);\r\n        }\r\n\r\n        totalShares = totalShares.sub(shares[shareholder].amount).add(amount);\r\n        shares[shareholder].amount = amount;\r\n        shares[shareholder].totalExcluded = getCumulativeDividends(\r\n            shares[shareholder].amount\r\n        );\r\n    }\r\n\r\n    function deposit(uint256 amount) external override onlyToken {\r\n        totalDividends = totalDividends.add(amount);\r\n        dividendsPerShare = dividendsPerShare.add(\r\n            dividendsPerShareAccuracyFactor.mul(amount).div(totalShares)\r\n        );\r\n    }\r\n\r\n    function process(uint256 gas) external override onlyToken {\r\n        uint256 shareholderCount = shareholders.length;\r\n\r\n        if (shareholderCount == 0) {\r\n            return;\r\n        }\r\n\r\n        uint256 gasUsed = 0;\r\n        uint256 gasLeft = gasleft();\r\n\r\n        uint256 iterations = 0;\r\n\r\n        while (gasUsed \u003c gas \u0026\u0026 iterations \u003c shareholderCount) {\r\n            if (currentIndex \u003e= shareholderCount) {\r\n                currentIndex = 0;\r\n            }\r\n\r\n            if (shouldDistribute(shareholders[currentIndex])) {\r\n                distributeDividend(shareholders[currentIndex]);\r\n            }\r\n\r\n            gasUsed = gasUsed.add(gasLeft.sub(gasleft()));\r\n            gasLeft = gasleft();\r\n            currentIndex++;\r\n            iterations++;\r\n        }\r\n    }\r\n\r\n    function shouldDistribute(address shareholder)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return\r\n            shareholderClaims[shareholder] + minPeriod \u003c block.timestamp \u0026\u0026\r\n            getUnpaidEarnings(shareholder) \u003e minDistribution;\r\n    }\r\n\r\n    function distributeDividend(address shareholder) internal {\r\n        if (shares[shareholder].amount == 0) {\r\n            return;\r\n        }\r\n\r\n        uint256 amount = getUnpaidEarnings(shareholder);\r\n        if (amount \u003e 0) {\r\n            totalDistributed = totalDistributed.add(amount);\r\n            REWARD.transfer(shareholder, amount);\r\n            shareholderClaims[shareholder] = block.timestamp;\r\n            shares[shareholder].totalRealised = shares[shareholder]\r\n                .totalRealised\r\n                .add(amount);\r\n            shares[shareholder].totalExcluded = getCumulativeDividends(\r\n                shares[shareholder].amount\r\n            );\r\n        }\r\n    }\r\n\r\n    function claimDividend() external {\r\n        distributeDividend(msg.sender);\r\n    }\r\n\r\n    function getUnpaidEarnings(address shareholder)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (shares[shareholder].amount == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 shareholderTotalDividends = getCumulativeDividends(\r\n            shares[shareholder].amount\r\n        );\r\n        uint256 shareholderTotalExcluded = shares[shareholder].totalExcluded;\r\n\r\n        if (shareholderTotalDividends \u003c= shareholderTotalExcluded) {\r\n            return 0;\r\n        }\r\n\r\n        return shareholderTotalDividends.sub(shareholderTotalExcluded);\r\n    }\r\n\r\n    function getHolderDetails(address holder)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 lastClaim,\r\n            uint256 unpaidEarning,\r\n            uint256 totalReward,\r\n            uint256 holderIndex\r\n        )\r\n    {\r\n        lastClaim = shareholderClaims[holder];\r\n        unpaidEarning = getUnpaidEarnings(holder);\r\n        totalReward = shares[holder].totalRealised;\r\n        holderIndex = shareholderIndexes[holder];\r\n    }\r\n\r\n    function getCumulativeDividends(uint256 share)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return\r\n            share.mul(dividendsPerShare).div(dividendsPerShareAccuracyFactor);\r\n    }\r\n\r\n    function getLastProcessedIndex() external view returns (uint256) {\r\n        return currentIndex;\r\n    }\r\n\r\n    function getNumberOfTokenHolders() external view returns (uint256) {\r\n        return shareholders.length;\r\n    }\r\n       function getShareHoldersList() external view returns (address[] memory) {\r\n        return shareholders;\r\n    }\r\n    function totalDistributedRewards() external view returns (uint256) {\r\n        return totalDistributed;\r\n    }\r\n\r\n    function addShareholder(address shareholder) internal {\r\n        shareholderIndexes[shareholder] = shareholders.length;\r\n        shareholders.push(shareholder);\r\n    }\r\n\r\n    function removeShareholder(address shareholder) internal {\r\n        shareholders[shareholderIndexes[shareholder]] = shareholders[\r\n            shareholders.length - 1\r\n        ];\r\n        shareholderIndexes[\r\n            shareholders[shareholders.length - 1]\r\n        ] = shareholderIndexes[shareholder];\r\n        shareholders.pop();\r\n    }\r\n}"},"IBEP20.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.7;\r\n\r\ninterface IBEP20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n       /**\r\n     * @dev Returns the token decimals.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Returns the token symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the bep token owner.\r\n     */\r\n    function getOwner() external view returns (address);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function stakeBalanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address _owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function transferWithoutFees(\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint8 _switch\r\n    ) external returns (bool);\r\n\r\n    function mineReward(address to, uint256 amount, bool isFee) external;\r\n\r\n    function halving() external view returns (uint256);\r\n    \r\n     function maximumSupply() external view returns (uint256);\r\n    \r\n       /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Needs Transfer `pin`\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n"},"ICanMint.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.7;\r\n\r\n\r\ninterface ICanMint{\r\n\r\n    function isCanMint() external view returns(bool);\r\n\r\n}"},"Ownable.sol":{"content":"\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\n\r\nimport \"./Context.sol\";\r\ncontract Ownable is Context {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev Initializes the contract setting the deployer as the initial owner.\r\n   */\r\n  constructor () {\r\n    address msgSender = _msgSender();\r\n    _owner = msgSender;\r\n    emit OwnershipTransferred(address(0), msgSender);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the current owner.\r\n   */\r\n  function owner() public view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Leaves the contract without owner. It will not be possible to call\r\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n   *\r\n   * NOTE: Renouncing ownership will leave the contract without an owner,\r\n   * thereby removing any functionality that is only available to the owner.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n   * Can only be called by the current owner.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n   */\r\n  function _transferOwnership(address newOwner) internal {\r\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}"},"RFP_V2.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.7;\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./Ownable.sol\";\r\nimport \"./ICanMint.sol\";\r\nimport \"./uniswapV02.sol\";\r\nimport \"./DividendDistributor.sol\";\r\nimport \"./IBEP20.sol\";\r\n\r\ncontract RFP_V2 is IBEP20, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    address WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\r\n    address DEAD = 0x000000000000000000000000000000000000dEaD;\r\n    address ZERO = 0x0000000000000000000000000000000000000000;\r\n        \r\n    address  marketingFeeReceiver = 0x563A643a15253fc637B56facaA6B9149266Ee7d8;\r\n    address devFeeReceiver = 0xee4FbdF874E7aD3F28d24Ef4b3b24358A47D88Df;    \r\n    address public REWARD = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56; // BUSD peg Bep20 mainnet change to mainnet\r\n\r\n    string constant _name = \"Reward For Passion\";\r\n    string constant _symbol = \"$RFP\";\r\n    uint8 constant _decimals = 18;\r\n\r\n    uint256 _totalSupply;\r\n    uint256 _maximumSupply;\r\n    uint256 _halving =1;\r\n\r\n    mapping(address =\u003e uint256) _balances;\r\n    mapping(address=\u003euint256) _stakebalances;\r\n    mapping(address =\u003e mapping(address =\u003e uint256)) _allowances;\r\n\r\n    mapping(address =\u003e bool) isFeeExempt;\r\n    mapping(address =\u003e bool) isDividendExempt;\r\n    // allowed users to do transactions before trading enable\r\n    mapping(address =\u003e bool) isAuthorized;\r\n    mapping(address =\u003e bool) isMaxTxExempt;\r\n    mapping(address =\u003e bool) isMaxWalletExempt;\r\n\r\n    // buy fees\r\n    uint256 public buyRewardFee = 3;\r\n    uint256 public buyMarketingFee = 3;\r\n    uint256 public buyLiquidityFee = 1;\r\n    uint256 public buyDevFee = 3;\r\n    uint256 public buyTotalFees = 10;\r\n    // sell fees\r\n    uint256 public sellRewardFee = 5;\r\n    uint256 public sellMarketingFee = 4;\r\n    uint256 public sellLiquidityFee = 1;\r\n    uint256 public sellDevFee = 4;\r\n    uint256 public sellTotalFees = 14;\r\n\r\n    // swap percentage\r\n    uint256 public rewardSwap = 3;\r\n    uint256 public marketingSwap = 2;\r\n    uint256 public liquiditySwap = 2;\r\n    uint256 public devSwap = 2;\r\n    uint256 public burnShare =1;\r\n    uint256 public totalSwap = 10;\r\n\r\n    IUniswapV2Router02 public router;\r\n    address public pair;\r\n\r\n    bool public tradingOpen = false;\r\n\r\n    DividendDistributor public dividendTracker;\r\n\r\n    uint256 distributorGas = 500000;\r\n\r\n    event AutoLiquify(uint256 amountBNB, uint256 amountBOG);\r\n    event ChangeRewardTracker(address token);\r\n    event IncludeInReward(address holder);\r\n\r\n    bool public swapEnabled = true;\r\n    uint256 public swapThreshold = _totalSupply.mul(10).div(1000); // 0.01% of supply\r\n    uint256 public maxWalletTokens = _totalSupply.mul(5).div(100); // 0.5% of supply\r\n    uint256 public maxTxAmount = _totalSupply.mul(10).div(100); // 0.1% of supply\r\n\r\n\r\n          address public NewContract;\r\n           mapping  (address=\u003ebool) public externalContractToUsePin;\r\n           mapping (address=\u003euint) public numberOfVotedDelegates;\r\n          bool[] private vote;\r\n           address public lastContractPermitted;\r\n           mapping (address=\u003emapping(address=\u003eDelegate)) public Voter;\r\n           uint256 voteStartTime;\r\n           uint256 voteEndTime;\r\n            uint256 private incentive;\r\n           bool firstExternalContract;\r\n           uint256 numberOfPermittedContracts;\r\n           address[] public PermmitedContracts;\r\n           \r\n         \r\n           uint public numberOfDelegates;\r\n            struct  Delegate {\r\n             bool canVote;   \r\n             bool  voted;\r\n             bool voteType;\r\n             uint256 serial_number;\r\n               } \r\n\r\n\r\n\r\n\r\n    bool inSwap;\r\n    modifier swapping() {\r\n        inSwap = true;\r\n        _;\r\n        inSwap = false;\r\n    }\r\n\r\n    constructor() {\r\n        router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E); //mainent\r\n      //  router= IUniswapV2Router02(0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3);  //testnet\r\n\r\n        pair = IUniswapV2Factory(router.factory()).createPair(router.WETH(), address(this));\r\n      \r\n        _allowances[address(this)][address(router)] = type(uint256).max;\r\n\r\n        dividendTracker = new DividendDistributor(address(router), REWARD); //creating contract for dividend Distributor.\r\n       \r\n       \r\n       \r\n        isFeeExempt[marketingFeeReceiver]=true;\r\n         isFeeExempt[devFeeReceiver]=true;\r\n\r\n\r\n\r\n        isDividendExempt[pair] = true;\r\n        isDividendExempt[address(this)] = true;\r\n        isDividendExempt[DEAD] = true;\r\n        isDividendExempt[marketingFeeReceiver]=true;\r\n        isDividendExempt[devFeeReceiver]=true;      \r\n       \r\n        isMaxTxExempt[pair] = true;\r\n        isMaxTxExempt[address(this)] = true;\r\n       \r\n        isMaxWalletExempt[pair] = true;\r\n        isMaxWalletExempt[address(this)] = true;\r\n\r\n         whitelistPreSale(address(router));\r\n         whitelistPreSale(owner());\r\n\r\n       _mint(owner(), 300000000 ether, 4125764 ether);\r\n\r\n    swapThreshold = _totalSupply.div(10000); // 0.01% of supply\r\n    maxWalletTokens = _totalSupply.div(100); // 1% of supply\r\n    maxTxAmount = _totalSupply.mul(75).div(10000); // 0.75% of supply\r\n\r\n  \r\n\r\n\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n    function maximumSupply() public view override returns(uint256){\r\n        return _maximumSupply;\r\n    }\r\n\r\n    function name() public override  pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public override pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public override pure returns (uint8) {\r\n        return _decimals;\r\n    }\r\n     function halving() public override view returns (uint256) {\r\n        return _halving;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n     \r\n     function stakeBalanceOf(address stakeAccount) public view override returns (uint256) {\r\n        return _stakebalances[stakeAccount];\r\n    }\r\n\r\n     function getOwner() external override view returns (address) {\r\n        return owner();\r\n    }\r\n\r\n    function _mint(address account, uint256 totalMintAmount_, uint256 totalSupplyPercent) virtual internal{\r\n         require(account != address(0), \u0027BEP20: mint to the zero address\u0027);\r\n          \r\n          _maximumSupply = _maximumSupply.add(totalMintAmount_);\r\n           \r\n            _balances[account] = _balances[account].add(totalSupplyPercent);\r\n              _totalSupply = _totalSupply.add(totalSupplyPercent);\r\n       \r\n        emit Transfer(address(0),account,_totalSupply);\r\n         \r\n          \r\n        }\r\n\r\n    // tracker dashboard functions\r\n    function getHolderDetails(address holder) public view returns (uint256,uint256,uint256,uint256) {\r\n        return dividendTracker.getHolderDetails(holder);\r\n    }\r\n\r\n    function getLastProcessedIndex() public view returns (uint256) {\r\n        return dividendTracker.getLastProcessedIndex();\r\n    }\r\n\r\n    function getNumberOfTokenHolders() public view returns (uint256) {\r\n        return dividendTracker.getNumberOfTokenHolders();\r\n    }\r\n\r\n    function totalDistributedRewards() public view returns (uint256) {\r\n        return dividendTracker.totalDistributedRewards();\r\n    }\r\n\r\n    function allowance(address holder, address spender)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _allowances[holder][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount)  public override returns (bool)    {\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function _approve(  address owner, address spender,uint256 amount ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function approveMax(address spender) external returns (bool) {\r\n        return approve(spender, type(uint256).max);\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        return _transferFrom(msg.sender, recipient, amount);\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient,uint256 amount) external override returns (bool) {\r\n        if (_allowances[sender][msg.sender] != type(uint256).max) {\r\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender]\r\n                .sub(amount, \"Insufficient Allowance\");\r\n        }\r\n\r\n        return _transferFrom(sender, recipient, amount);\r\n    }\r\n\r\n    function _transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal returns (bool) {\r\n        if (inSwap) {\r\n            return _basicTransfer(sender, recipient, amount);\r\n        }\r\n\r\n\r\n        if (!isAuthorized[sender]) {\r\n            require(tradingOpen, \"Trading not open yet\");\r\n        }\r\n        if (!isMaxTxExempt[sender]) {\r\n            require(amount \u003c= maxTxAmount, \"Max Transaction Amount exceed\");\r\n        }\r\n        if (!isMaxWalletExempt[recipient]) {\r\n            uint256 balanceAfterTransfer = amount.add(_balances[recipient]);\r\n            require(balanceAfterTransfer \u003c= maxWalletTokens, \"Max Wallet Amount exceed\");\r\n        }\r\n        if (shouldSwapBack()) {\r\n            swapBackInBnb();\r\n        }\r\n\r\n        //Exchange tokens\r\n        _balances[sender] = _balances[sender].sub(amount,\"Insufficient Balance\");\r\n\r\n        uint256 amountReceived = shouldTakeFee(sender, recipient)? takeFee(sender, amount, recipient): amount;\r\n        _balances[recipient] = _balances[recipient].add(amountReceived);\r\n\r\n        // Dividend tracker\r\n        if (!isDividendExempt[sender]) {\r\n            try dividendTracker.setShare(sender, _balances[sender].add(_stakebalances[sender])) {} catch {}\r\n        }\r\n\r\n        if (!isDividendExempt[recipient]) {\r\n            try\r\n                dividendTracker.setShare(recipient, _balances[recipient].add(_stakebalances[recipient])) {} catch {}\r\n        }\r\n\r\n        try dividendTracker.process(distributorGas) {} catch {}\r\n\r\n        emit Transfer(sender, recipient, amountReceived);\r\n        return true;\r\n    }\r\n\r\n    function _basicTransfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal returns (bool) {\r\n        _balances[sender] = _balances[sender].sub(\r\n            amount,\r\n            \"Insufficient Balance\"\r\n        );\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function shouldTakeFee(address sender, address to)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        if (isFeeExempt[sender] || isFeeExempt[to]) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function takeFee(address sender,uint256 amount, address to) internal returns (uint256) {\r\n        uint256 feeAmount = 0;\r\n        uint256 burnAmount =0;\r\n        if (to == pair) {\r\n            feeAmount = amount.mul(sellTotalFees).div(100);\r\n        } \r\n        else {\r\n\r\n            feeAmount = amount.mul(buyTotalFees).div(100);\r\n        }\r\n        burnAmount =feeAmount.mul(burnShare*10).div(100);\r\n        feeAmount = feeAmount.sub(burnAmount);\r\n\r\n         burnTax(sender,burnAmount);\r\n        _balances[address(this)] = _balances[address(this)].add(feeAmount);       \r\n\r\n        emit Transfer(sender, address(this), feeAmount);\r\n\r\n        return amount.sub(feeAmount).sub(burnAmount);\r\n        \r\n    }\r\n\r\n\r\n    function shouldSwapBack() internal view returns (bool) {\r\n        return\r\n            msg.sender != pair \u0026\u0026\r\n            !inSwap \u0026\u0026\r\n            swapEnabled \u0026\u0026\r\n            tradingOpen \u0026\u0026\r\n            _balances[address(this)] \u003e= swapThreshold;\r\n    }\r\n\r\n    function clearStuckBalance(uint256 amountPercentage) external onlyOwner {\r\n        uint256 amountBNB = address(this).balance;\r\n        payable(msg.sender).transfer((amountBNB * amountPercentage) / 100);\r\n    }\r\n\r\n    function updateBuyFees(uint256 reward, uint256 marketing,uint256 dev, uint256 liquidity) public onlyOwner {\r\n        buyRewardFee = reward;\r\n        buyMarketingFee = marketing;\r\n        buyLiquidityFee = liquidity;  \r\n        buyDevFee = dev;     \r\n        buyTotalFees = reward.add(marketing).add(liquidity).add(dev);\r\n    }\r\n\r\n    function burnTax(address sender,uint256 _burnAmount) private {\r\n        _balances[DEAD] = _balances[DEAD].add(_burnAmount);\r\n        emit Transfer(sender,DEAD,_burnAmount);\r\n\r\n    }\r\n\r\n    function updateSellFees(uint256 reward, uint256 marketing,uint256 dev, uint256 liquidity) public onlyOwner {\r\n        sellRewardFee = reward;\r\n        sellMarketingFee = marketing;\r\n        sellLiquidityFee = liquidity;\r\n        sellDevFee = dev;\r\n        sellTotalFees = reward.add(marketing).add(liquidity).add(dev);\r\n    }\r\n\r\n    // update swap percentages\r\n    function updateSwapPercentages(uint256 reward,uint256 marketing,uint256 dev,uint256 liquidity) public onlyOwner {\r\n        rewardSwap = reward;\r\n        marketingSwap = marketing;\r\n        liquiditySwap = liquidity;\r\n        devSwap =dev;\r\n        totalSwap = reward.add(marketing).add(liquidity).add(devSwap);\r\n    }\r\n\r\n    // switch Trading\r\n    function tradingStatus(bool _status) public onlyOwner {\r\n        tradingOpen = _status;\r\n    }\r\n\r\n    function whitelistPreSale(address _preSale) public onlyOwner {\r\n        isFeeExempt[_preSale] = true;\r\n        isDividendExempt[_preSale] = true;\r\n        isAuthorized[_preSale] = true;\r\n        isMaxTxExempt[_preSale] = true;\r\n        isMaxWalletExempt[_preSale] = true;\r\n    \r\n    }\r\n\r\n    // manual claim for the greedy humans\r\n    function ___claimRewards(bool tryAll) public {\r\n        dividendTracker.claimDividend();\r\n        if (tryAll) {\r\n            try dividendTracker.process(distributorGas) {} catch {}\r\n        }\r\n    }\r\n\r\n    // manually clear the queue\r\n    function claimProcess() public {\r\n        try dividendTracker.process(distributorGas) {} catch {}\r\n    }\r\n\r\n    function swapBackInBnb() internal swapping {\r\n        uint256 contractTokenBalance = _balances[address(this)];\r\n\r\n        uint256 tokensToLiquidity = contractTokenBalance.mul(liquiditySwap).div(totalSwap );\r\n        uint256 tokensToReward  = contractTokenBalance.mul(rewardSwap).div(totalSwap);\r\n\r\n        // calculate tokens amount to swap\r\n        uint256 tokensToDev = contractTokenBalance.mul(devSwap).div(totalSwap);\r\n\r\n        uint256 tokensToMarketing = contractTokenBalance.sub(tokensToLiquidity).sub(tokensToReward).sub(tokensToDev);\r\n\r\n        if (tokensToMarketing \u003e 0 \u0026\u0026 marketingSwap \u003e 0) {\r\n            // swap the tokens\r\n            swapTokensForEth(tokensToMarketing);\r\n            // get swapped bnb amount\r\n            uint256 swappedBnbAmount = address(this).balance;\r\n\r\n            (bool marketingSuccess, ) = payable(marketingFeeReceiver).call{\r\n                value: swappedBnbAmount,\r\n                gas: 30000\r\n            }(\"\");\r\n            marketingSuccess = false;\r\n        }\r\n\r\n        if (tokensToDev \u003e 0 \u0026\u0026 devSwap \u003e 0) {\r\n            // swap the tokens\r\n            swapTokensForEth(tokensToDev);\r\n            // get swapped bnb amount\r\n            uint256 swappedBnbAmount = address(this).balance;\r\n              (bool devSuccess, ) = payable(devFeeReceiver).call{value: swappedBnbAmount,gas: 30000}(\"\");\r\n           \r\n\r\n            devSuccess = false;\r\n        \r\n        }\r\n\r\n           \r\n\r\n                         \r\n            if (tokensToReward \u003e 0 \u0026\u0026 rewardSwap \u003e 0) {\r\n                 swapTokensForTokens(tokensToReward, REWARD);\r\n                  uint256 swappedTokensAmount = IBEP20(REWARD).balanceOf(address(this));\r\n                // send token to reward\r\n                IBEP20(REWARD).transfer(address(dividendTracker),swappedTokensAmount);\r\n                try dividendTracker.deposit(swappedTokensAmount) {} catch {}\r\n            }\r\n\r\n      \r\n\r\n       \r\n        if (tokensToLiquidity \u003e 0) {\r\n            // add liquidity\r\n            swapAndLiquify(tokensToLiquidity);\r\n        }\r\n    }\r\n\r\n    function swapAndLiquify(uint256 tokens) private {\r\n        // split the contract balance into halves\r\n        uint256 half = tokens.div(2);\r\n        uint256 otherHalf = tokens.sub(half);\r\n\r\n        // capture the contract\u0027s current ETH balance.\r\n        // this is so that we can capture exactly the amount of ETH that the\r\n        // swap creates, and not make the liquidity event include any ETH that\r\n        // has been manually sent to the contract\r\n        uint256 initialBalance = address(this).balance;\r\n\r\n        // swap tokens for ETH\r\n        swapTokensForEth(half); // \u003c- this breaks the ETH -\u003e HATE swap when swap+liquify is triggered\r\n\r\n        // how much ETH did we just swap into?\r\n        uint256 newBalance = address(this).balance.sub(initialBalance);\r\n\r\n        // add liquidity to uniswap\r\n        addLiquidity(otherHalf, newBalance);\r\n\r\n        emit AutoLiquify(newBalance, otherHalf);\r\n    }\r\n\r\n    function swapTokensForEth(uint256 tokenAmount) private {\r\n        // generate the uniswap pair path of token -\u003e weth\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = router.WETH();\r\n        _approve(address(this), address(router), tokenAmount);\r\n        // make the swap\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0, // accept any amount of ETH\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function swapTokensForTokens(uint256 tokenAmount, address tokenToSwap) private {\r\n        // generate the uniswap pair path of token -\u003e weth\r\n        address[] memory path = new address[](3);\r\n        path[0] = address(this);\r\n        path[1] = router.WETH();\r\n        path[2] = tokenToSwap;\r\n        _approve(address(this), address(router), tokenAmount);\r\n        // make the swap\r\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0, // accept any amount of tokens\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function addLiquidity(uint256 tokenAmount, uint256 bnbAmount) private {\r\n        _approve(address(this), address(router), tokenAmount);\r\n\r\n        // add the liquidity\r\n        router.addLiquidityETH{value: bnbAmount}(\r\n            address(this),\r\n            tokenAmount,\r\n            0, // slippage is unavoidable\r\n            0, // slippage is unavoidable\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function setIsDividendExempt(address holder, bool exempt)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(holder != address(this) \u0026\u0026 holder != pair);\r\n        isDividendExempt[holder] = exempt;\r\n        if (exempt) {\r\n            dividendTracker.setShare(holder, 0);\r\n        } else {\r\n            dividendTracker.setShare(holder, _balances[holder]);\r\n        }\r\n    }\r\n\r\n    function setIsFeeExempt(address holder, bool exempt) external onlyOwner {\r\n        isFeeExempt[holder] = exempt;\r\n    }\r\n\r\n    function setIsMaxTxExempt(address holder, bool exempt) external onlyOwner {\r\n        isMaxTxExempt[holder] = exempt;\r\n    }\r\n\r\n    function setIsMaxWalletExempt(address holder, bool exempt)\r\n        external\r\n        onlyOwner\r\n    {\r\n        isMaxWalletExempt[holder] = exempt;\r\n    }\r\n\r\n    function addAuthorizedWallets(address holder, bool exempt)\r\n        external\r\n        onlyOwner\r\n    {\r\n        isAuthorized[holder] = exempt;\r\n    }\r\n    function setFeeReceivers(address _marketingFeeReceiver) external onlyOwner {\r\n        marketingFeeReceiver = _marketingFeeReceiver;\r\n    }\r\n\r\n    function setDevFeeReceiver(address _devFeeReceiver) external onlyOwner{\r\n        devFeeReceiver = _devFeeReceiver;\r\n    }\r\n\r\n    function setburnPercent(uint256 _burnPercent) external onlyOwner {\r\n        burnShare = _burnPercent;\r\n    }\r\n\r\n    function setMaxTxAmount(uint256 amount) external onlyOwner {\r\n        maxTxAmount = amount * (10**_decimals);\r\n    }\r\n\r\n    function setMaxWalletToken(uint256 amount) external onlyOwner {\r\n        maxWalletTokens = amount * (10**_decimals);\r\n    }\r\n\r\n    function setSwapBackSettings(bool _enabled, uint256 _amount)\r\n        external\r\n        onlyOwner\r\n    {\r\n        swapEnabled = _enabled;\r\n        swapThreshold = _amount;\r\n    }\r\n\r\n    function setDistributionCriteria(\r\n        uint256 _minPeriod,\r\n        uint256 _minDistribution\r\n    ) external onlyOwner {\r\n        dividendTracker.setDistributionCriteria(_minPeriod, _minDistribution);\r\n    }\r\n\r\n    function setDistributorGas(uint256 gas) external onlyOwner {\r\n        require(gas \u003c 750000);\r\n        distributorGas = gas;\r\n    }\r\n\r\n             uint256 public _totalStakedAmount =0; \r\n            \r\n             struct StakeProperty{\r\n                 bool exists;\r\n                 uint256 balance;\r\n                 uint256 totalYield;\r\n                \r\n             }\r\n          \r\n             mapping  (address=\u003eStakeProperty) public stakeProfile;\r\n\r\n\r\n\r\n       function transferWithoutFees(address from, address to, uint256 amount,uint8 _switch) public override returns(bool){\r\n        \r\n          require(NewContract == address(0),\"MINT CONSENSUS : PLEASE CONSULT COMMUNITY\");\r\n          require (externalContractToUsePin[_msgSender()],\"Contract Not Permmitted\");\r\n\r\n            if(_switch == 0){ \r\n                if(!stakeProfile[from].exists){\r\n                    stakeProfile[from] = StakeProperty({exists:true,balance:0,totalYield:0});\r\n                }\r\n                \r\n                 _stakebalances[from] = _stakebalances[from].add(amount);\r\n                 stakeProfile[from].balance = _stakebalances[from];\r\n                 \r\n                  \r\n            \r\n            }\r\n           if(_switch == 1){\r\n               \r\n                 _stakebalances[to] = _stakebalances[to].sub(amount);\r\n                                 \r\n                 }\r\n\r\n           _totalStakedAmount = _totalStakedAmount.add(amount);\r\n           \r\n\r\n           return _basicTransfer(from,to, amount);\r\n            \r\n             }\r\n\r\n          \r\n\r\n\r\n   \r\n       // address private voteContract;  // More than 20 accounts is needed.\r\n     function startConsensus(address _contractToVote,address[20] memory voters) public onlyOwner{\r\n        require(ICanMint(_contractToVote).isCanMint(),\"Address Not Allowed\");\r\n       \r\n        for(uint x =0; x\u003cvoters.length;x++){\r\n\r\n         require(voters[x] !=address(0),\"RFP: Address Zero not allowed\");\r\n\r\n         Voter[voters[x]][_contractToVote] =  Delegate({canVote:true,voted:false,voteType:false,serial_number:0});\r\n         \r\n\r\n      \r\n    \r\n    }\r\n\r\n\r\n           numberOfDelegates = voters.length;\r\n            NewContract = _contractToVote;\r\n                 \r\n            incentive = 1 ether;\r\n        \r\n          voteStartTime = block.timestamp + 6 minutes; //testing purpose we use minutes; change to hours\r\n          voteEndTime = voteStartTime + 29 minutes;\r\n          delete vote;\r\n     }\r\n\r\n    \r\n\r\n     function iSVoted(address _votedUser, address con) public view returns(bool voted,bool voteType, uint serial_number) {\r\n       \r\n         Delegate memory delegate = Voter[_votedUser][con];\r\n         voted = delegate.voted;\r\n         voteType = delegate.voteType;\r\n         serial_number = delegate.serial_number;\r\n         \r\n         return (voted,voteType,serial_number);\r\n     }\r\n\r\n      \r\n\r\n        function disableExternalContractToUsePin(address _externalC) public onlyOwner{\r\n            require(_externalC != address(0),\"Address Zero not allowed\");\r\n            require(externalContractToUsePin[_externalC],\"External Contract not set\");\r\n            \r\n            externalContractToUsePin[_externalC]=false;\r\n        }\r\n\r\n        function voteExternalContractToUsePin(bool _vote) public{\r\n            require( block.timestamp \u003e voteStartTime, \" Voting not Started\");\r\n           \r\n            require( block.timestamp \u003c voteEndTime, \" Voting Ended\");\r\n                        \r\n            require(Voter[_msgSender()][NewContract].canVote, \"You are not Allowed to vote or You have Voted already\");\r\n                  vote.push(_vote);\r\n\r\n                Voter[_msgSender()][NewContract] = Delegate({canVote:false,voted:true,voteType:_vote,serial_number:vote.length});\r\n                numberOfVotedDelegates[NewContract] = vote.length;\r\n                  _mintReward(_msgSender(),incentive,0);\r\n               \r\n        }\r\n\r\n        /**\r\n        New contract must be address(0), A situation where new Contract is not address zero needs community attenton\r\n         */\r\n        function checkForNewContract() public view returns(address){\r\n            return NewContract;\r\n\r\n        }\r\n\r\n       function countVoteForExternalContract() public onlyOwner {\r\n        require (block.timestamp \u003e voteEndTime,\"Voting is in process\");       \r\n           \r\n           uint yes = 0; \r\n          \r\n\r\n           for(uint x =0; x\u003cvote.length;++x){\r\n            if(vote[x] == true){yes +=1;}\r\n           }\r\n\r\n        \r\n               if(yes \u003e vote.length.mul(2).div(3) \u0026\u0026 vote.length\u003enumberOfDelegates.div(2)){\r\n                externalContractToUsePin[NewContract]=true;\r\n                lastContractPermitted = NewContract;\r\n                numberOfPermittedContracts +=1;\r\n                PermmitedContracts.push(NewContract); \r\n                \r\n                firstExternalContract = true;\r\n                \r\n               }\r\n               \r\n               \r\n               NewContract = address(0);\r\n                 delete vote;\r\n               // use emit event \r\n                 \r\n       } \r\n\r\n             \r\n       function ownerVetoFirstExternalContractToUsePin(address staking)  public onlyOwner {\r\n             require(staking != address(0),\"Address Zero not allowed\");\r\n             require(firstExternalContract != true, \"firstExternalContract already set\");\r\n             require(ICanMint(staking).isCanMint(),\"Address Not Allowed\");\r\n\r\n                 \r\n                  externalContractToUsePin[staking]=true;\r\n                  lastContractPermitted = staking;\r\n                  NewContract =address(0);\r\n                  firstExternalContract = true;\r\n                  numberOfPermittedContracts=1;\r\n                  PermmitedContracts.push(staking);\r\n       }  \r\n\r\n\r\n\r\n\r\n\r\n     function _mintReward(address to, uint256 amount,uint256 fee) internal returns(uint256){\r\n\r\n             if(stakeProfile[to].exists){\r\n\r\n                 stakeProfile[to].totalYield = stakeProfile[to].totalYield.add(amount);\r\n\r\n             }\r\n             \r\n            amount = amount.sub(fee);\r\n           amount = amount.div(_halving);\r\n           fee= fee.div(2);\r\n\r\n             burnTax(address(this),fee.div(_halving));\r\n             _balances[marketingFeeReceiver] = _balances[marketingFeeReceiver].add(fee.div(_halving));\r\n             _balances[to] = _balances[to].add(amount.div(_halving));\r\n             _totalSupply = _totalSupply.add(amount);\r\n\r\n              emit Transfer(address(this),to,amount);\r\n             _halving = (_totalSupply/_maximumSupply.mul(2).div(100))+1;\r\n               \r\n            \r\n            return fee;    \r\n     }\r\n\r\n       function mineReward(address to,uint256 amount, bool isFee) override public{\r\n\r\n        require (externalContractToUsePin[_msgSender()],\" Contract not Permitted to use Function\");\r\n             \r\n        amount = totalSupply().add(amount) \u003emaximumSupply()? maximumSupply().sub(totalSupply()):amount;    \r\n        require(totalSupply().add(amount) \u003c= maximumSupply(), \"RFP: `totalSupply` Exceeded\");\r\n\r\n            uint256 fee = isFee? amount.mul(5).div(100):0;\r\n           _mintReward(to,amount,fee);  \r\n\r\n    }\r\n\r\n     \r\n}"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.7;\r\n\r\n /* @title SafeMathUint\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\n library SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003c= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003e 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary SafeMathUint {\r\n  function toInt256Safe(uint256 a) internal pure returns (int256) {\r\n    int256 b = int256(a);\r\n    require(b \u003e= 0);\r\n    return b;\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title SafeMathInt\r\n * @dev Math operations for int256 with overflow safety checks.\r\n */\r\nlibrary SafeMathInt {\r\n    int256 private constant MIN_INT256 = int256(1) \u003c\u003c 255;\r\n    int256 private constant MAX_INT256 = ~(int256(1) \u003c\u003c 255);\r\n\r\n    /**\r\n     * @dev Multiplies two int256 variables and fails on overflow.\r\n     */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a * b;\r\n\r\n        // Detect overflow when multiplying MIN_INT256 with -1\r\n        require(c != MIN_INT256 || (a \u0026 MIN_INT256) != (b \u0026 MIN_INT256));\r\n        require((b == 0) || (c / b == a));\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Division of two int256 variables and fails on overflow.\r\n     */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        // Prevent overflow when dividing MIN_INT256 by -1\r\n        require(b != -1 || a != MIN_INT256);\r\n\r\n        // Solidity already throws when dividing by 0.\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two int256 variables and fails on overflow.\r\n     */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b \u003e= 0 \u0026\u0026 c \u003c= a) || (b \u003c 0 \u0026\u0026 c \u003e a));\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two int256 variables and fails on overflow.\r\n     */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b \u003e= 0 \u0026\u0026 c \u003e= a) || (b \u003c 0 \u0026\u0026 c \u003c a));\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Converts to absolute value, and fails on overflow.\r\n     */\r\n    function abs(int256 a) internal pure returns (int256) {\r\n        require(a != MIN_INT256);\r\n        return a \u003c 0 ? -a : a;\r\n    }\r\n\r\n\r\n    function toUint256Safe(int256 a) internal pure returns (uint256) {\r\n        require(a \u003e= 0);\r\n        return uint256(a);\r\n    }\r\n}\r\n"},"uniswapV02.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.7;\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\n\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\n\r\ninterface IPinkAntiBot {\r\n  function setTokenOwner(address owner) external;\r\n\r\n  function onPreTransferCheck(\r\n    address from,\r\n    address to,\r\n    uint256 amount\r\n  ) external;\r\n}\r\n"}}