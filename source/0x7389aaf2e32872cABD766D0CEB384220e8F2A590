
// File: node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/SafeCast.sol)

pragma solidity ^0.8.0;

/**
 * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow
 * checks.
 *
 * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can
 * easily result in undesired exploitation or bugs, since developers usually
 * assume that overflows raise errors. `SafeCast` restores this intuition by
 * reverting the transaction when such an operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 *
 * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing
 * all math on `uint256` and `int256` and then downcasting.
 */
library SafeCast {
    /**
     * @dev Returns the downcasted uint248 from uint256, reverting on
     * overflow (when the input is greater than largest uint248).
     *
     * Counterpart to Solidity's `uint248` operator.
     *
     * Requirements:
     *
     * - input must fit into 248 bits
     *
     * _Available since v4.7._
     */
    function toUint248(uint256 value) internal pure returns (uint248) {
        require(value <= type(uint248).max, "SafeCast: value doesn't fit in 248 bits");
        return uint248(value);
    }

    /**
     * @dev Returns the downcasted uint240 from uint256, reverting on
     * overflow (when the input is greater than largest uint240).
     *
     * Counterpart to Solidity's `uint240` operator.
     *
     * Requirements:
     *
     * - input must fit into 240 bits
     *
     * _Available since v4.7._
     */
    function toUint240(uint256 value) internal pure returns (uint240) {
        require(value <= type(uint240).max, "SafeCast: value doesn't fit in 240 bits");
        return uint240(value);
    }

    /**
     * @dev Returns the downcasted uint232 from uint256, reverting on
     * overflow (when the input is greater than largest uint232).
     *
     * Counterpart to Solidity's `uint232` operator.
     *
     * Requirements:
     *
     * - input must fit into 232 bits
     *
     * _Available since v4.7._
     */
    function toUint232(uint256 value) internal pure returns (uint232) {
        require(value <= type(uint232).max, "SafeCast: value doesn't fit in 232 bits");
        return uint232(value);
    }

    /**
     * @dev Returns the downcasted uint224 from uint256, reverting on
     * overflow (when the input is greater than largest uint224).
     *
     * Counterpart to Solidity's `uint224` operator.
     *
     * Requirements:
     *
     * - input must fit into 224 bits
     *
     * _Available since v4.2._
     */
    function toUint224(uint256 value) internal pure returns (uint224) {
        require(value <= type(uint224).max, "SafeCast: value doesn't fit in 224 bits");
        return uint224(value);
    }

    /**
     * @dev Returns the downcasted uint216 from uint256, reverting on
     * overflow (when the input is greater than largest uint216).
     *
     * Counterpart to Solidity's `uint216` operator.
     *
     * Requirements:
     *
     * - input must fit into 216 bits
     *
     * _Available since v4.7._
     */
    function toUint216(uint256 value) internal pure returns (uint216) {
        require(value <= type(uint216).max, "SafeCast: value doesn't fit in 216 bits");
        return uint216(value);
    }

    /**
     * @dev Returns the downcasted uint208 from uint256, reverting on
     * overflow (when the input is greater than largest uint208).
     *
     * Counterpart to Solidity's `uint208` operator.
     *
     * Requirements:
     *
     * - input must fit into 208 bits
     *
     * _Available since v4.7._
     */
    function toUint208(uint256 value) internal pure returns (uint208) {
        require(value <= type(uint208).max, "SafeCast: value doesn't fit in 208 bits");
        return uint208(value);
    }

    /**
     * @dev Returns the downcasted uint200 from uint256, reverting on
     * overflow (when the input is greater than largest uint200).
     *
     * Counterpart to Solidity's `uint200` operator.
     *
     * Requirements:
     *
     * - input must fit into 200 bits
     *
     * _Available since v4.7._
     */
    function toUint200(uint256 value) internal pure returns (uint200) {
        require(value <= type(uint200).max, "SafeCast: value doesn't fit in 200 bits");
        return uint200(value);
    }

    /**
     * @dev Returns the downcasted uint192 from uint256, reverting on
     * overflow (when the input is greater than largest uint192).
     *
     * Counterpart to Solidity's `uint192` operator.
     *
     * Requirements:
     *
     * - input must fit into 192 bits
     *
     * _Available since v4.7._
     */
    function toUint192(uint256 value) internal pure returns (uint192) {
        require(value <= type(uint192).max, "SafeCast: value doesn't fit in 192 bits");
        return uint192(value);
    }

    /**
     * @dev Returns the downcasted uint184 from uint256, reverting on
     * overflow (when the input is greater than largest uint184).
     *
     * Counterpart to Solidity's `uint184` operator.
     *
     * Requirements:
     *
     * - input must fit into 184 bits
     *
     * _Available since v4.7._
     */
    function toUint184(uint256 value) internal pure returns (uint184) {
        require(value <= type(uint184).max, "SafeCast: value doesn't fit in 184 bits");
        return uint184(value);
    }

    /**
     * @dev Returns the downcasted uint176 from uint256, reverting on
     * overflow (when the input is greater than largest uint176).
     *
     * Counterpart to Solidity's `uint176` operator.
     *
     * Requirements:
     *
     * - input must fit into 176 bits
     *
     * _Available since v4.7._
     */
    function toUint176(uint256 value) internal pure returns (uint176) {
        require(value <= type(uint176).max, "SafeCast: value doesn't fit in 176 bits");
        return uint176(value);
    }

    /**
     * @dev Returns the downcasted uint168 from uint256, reverting on
     * overflow (when the input is greater than largest uint168).
     *
     * Counterpart to Solidity's `uint168` operator.
     *
     * Requirements:
     *
     * - input must fit into 168 bits
     *
     * _Available since v4.7._
     */
    function toUint168(uint256 value) internal pure returns (uint168) {
        require(value <= type(uint168).max, "SafeCast: value doesn't fit in 168 bits");
        return uint168(value);
    }

    /**
     * @dev Returns the downcasted uint160 from uint256, reverting on
     * overflow (when the input is greater than largest uint160).
     *
     * Counterpart to Solidity's `uint160` operator.
     *
     * Requirements:
     *
     * - input must fit into 160 bits
     *
     * _Available since v4.7._
     */
    function toUint160(uint256 value) internal pure returns (uint160) {
        require(value <= type(uint160).max, "SafeCast: value doesn't fit in 160 bits");
        return uint160(value);
    }

    /**
     * @dev Returns the downcasted uint152 from uint256, reverting on
     * overflow (when the input is greater than largest uint152).
     *
     * Counterpart to Solidity's `uint152` operator.
     *
     * Requirements:
     *
     * - input must fit into 152 bits
     *
     * _Available since v4.7._
     */
    function toUint152(uint256 value) internal pure returns (uint152) {
        require(value <= type(uint152).max, "SafeCast: value doesn't fit in 152 bits");
        return uint152(value);
    }

    /**
     * @dev Returns the downcasted uint144 from uint256, reverting on
     * overflow (when the input is greater than largest uint144).
     *
     * Counterpart to Solidity's `uint144` operator.
     *
     * Requirements:
     *
     * - input must fit into 144 bits
     *
     * _Available since v4.7._
     */
    function toUint144(uint256 value) internal pure returns (uint144) {
        require(value <= type(uint144).max, "SafeCast: value doesn't fit in 144 bits");
        return uint144(value);
    }

    /**
     * @dev Returns the downcasted uint136 from uint256, reverting on
     * overflow (when the input is greater than largest uint136).
     *
     * Counterpart to Solidity's `uint136` operator.
     *
     * Requirements:
     *
     * - input must fit into 136 bits
     *
     * _Available since v4.7._
     */
    function toUint136(uint256 value) internal pure returns (uint136) {
        require(value <= type(uint136).max, "SafeCast: value doesn't fit in 136 bits");
        return uint136(value);
    }

    /**
     * @dev Returns the downcasted uint128 from uint256, reverting on
     * overflow (when the input is greater than largest uint128).
     *
     * Counterpart to Solidity's `uint128` operator.
     *
     * Requirements:
     *
     * - input must fit into 128 bits
     *
     * _Available since v2.5._
     */
    function toUint128(uint256 value) internal pure returns (uint128) {
        require(value <= type(uint128).max, "SafeCast: value doesn't fit in 128 bits");
        return uint128(value);
    }

    /**
     * @dev Returns the downcasted uint120 from uint256, reverting on
     * overflow (when the input is greater than largest uint120).
     *
     * Counterpart to Solidity's `uint120` operator.
     *
     * Requirements:
     *
     * - input must fit into 120 bits
     *
     * _Available since v4.7._
     */
    function toUint120(uint256 value) internal pure returns (uint120) {
        require(value <= type(uint120).max, "SafeCast: value doesn't fit in 120 bits");
        return uint120(value);
    }

    /**
     * @dev Returns the downcasted uint112 from uint256, reverting on
     * overflow (when the input is greater than largest uint112).
     *
     * Counterpart to Solidity's `uint112` operator.
     *
     * Requirements:
     *
     * - input must fit into 112 bits
     *
     * _Available since v4.7._
     */
    function toUint112(uint256 value) internal pure returns (uint112) {
        require(value <= type(uint112).max, "SafeCast: value doesn't fit in 112 bits");
        return uint112(value);
    }

    /**
     * @dev Returns the downcasted uint104 from uint256, reverting on
     * overflow (when the input is greater than largest uint104).
     *
     * Counterpart to Solidity's `uint104` operator.
     *
     * Requirements:
     *
     * - input must fit into 104 bits
     *
     * _Available since v4.7._
     */
    function toUint104(uint256 value) internal pure returns (uint104) {
        require(value <= type(uint104).max, "SafeCast: value doesn't fit in 104 bits");
        return uint104(value);
    }

    /**
     * @dev Returns the downcasted uint96 from uint256, reverting on
     * overflow (when the input is greater than largest uint96).
     *
     * Counterpart to Solidity's `uint96` operator.
     *
     * Requirements:
     *
     * - input must fit into 96 bits
     *
     * _Available since v4.2._
     */
    function toUint96(uint256 value) internal pure returns (uint96) {
        require(value <= type(uint96).max, "SafeCast: value doesn't fit in 96 bits");
        return uint96(value);
    }

    /**
     * @dev Returns the downcasted uint88 from uint256, reverting on
     * overflow (when the input is greater than largest uint88).
     *
     * Counterpart to Solidity's `uint88` operator.
     *
     * Requirements:
     *
     * - input must fit into 88 bits
     *
     * _Available since v4.7._
     */
    function toUint88(uint256 value) internal pure returns (uint88) {
        require(value <= type(uint88).max, "SafeCast: value doesn't fit in 88 bits");
        return uint88(value);
    }

    /**
     * @dev Returns the downcasted uint80 from uint256, reverting on
     * overflow (when the input is greater than largest uint80).
     *
     * Counterpart to Solidity's `uint80` operator.
     *
     * Requirements:
     *
     * - input must fit into 80 bits
     *
     * _Available since v4.7._
     */
    function toUint80(uint256 value) internal pure returns (uint80) {
        require(value <= type(uint80).max, "SafeCast: value doesn't fit in 80 bits");
        return uint80(value);
    }

    /**
     * @dev Returns the downcasted uint72 from uint256, reverting on
     * overflow (when the input is greater than largest uint72).
     *
     * Counterpart to Solidity's `uint72` operator.
     *
     * Requirements:
     *
     * - input must fit into 72 bits
     *
     * _Available since v4.7._
     */
    function toUint72(uint256 value) internal pure returns (uint72) {
        require(value <= type(uint72).max, "SafeCast: value doesn't fit in 72 bits");
        return uint72(value);
    }

    /**
     * @dev Returns the downcasted uint64 from uint256, reverting on
     * overflow (when the input is greater than largest uint64).
     *
     * Counterpart to Solidity's `uint64` operator.
     *
     * Requirements:
     *
     * - input must fit into 64 bits
     *
     * _Available since v2.5._
     */
    function toUint64(uint256 value) internal pure returns (uint64) {
        require(value <= type(uint64).max, "SafeCast: value doesn't fit in 64 bits");
        return uint64(value);
    }

    /**
     * @dev Returns the downcasted uint56 from uint256, reverting on
     * overflow (when the input is greater than largest uint56).
     *
     * Counterpart to Solidity's `uint56` operator.
     *
     * Requirements:
     *
     * - input must fit into 56 bits
     *
     * _Available since v4.7._
     */
    function toUint56(uint256 value) internal pure returns (uint56) {
        require(value <= type(uint56).max, "SafeCast: value doesn't fit in 56 bits");
        return uint56(value);
    }

    /**
     * @dev Returns the downcasted uint48 from uint256, reverting on
     * overflow (when the input is greater than largest uint48).
     *
     * Counterpart to Solidity's `uint48` operator.
     *
     * Requirements:
     *
     * - input must fit into 48 bits
     *
     * _Available since v4.7._
     */
    function toUint48(uint256 value) internal pure returns (uint48) {
        require(value <= type(uint48).max, "SafeCast: value doesn't fit in 48 bits");
        return uint48(value);
    }

    /**
     * @dev Returns the downcasted uint40 from uint256, reverting on
     * overflow (when the input is greater than largest uint40).
     *
     * Counterpart to Solidity's `uint40` operator.
     *
     * Requirements:
     *
     * - input must fit into 40 bits
     *
     * _Available since v4.7._
     */
    function toUint40(uint256 value) internal pure returns (uint40) {
        require(value <= type(uint40).max, "SafeCast: value doesn't fit in 40 bits");
        return uint40(value);
    }

    /**
     * @dev Returns the downcasted uint32 from uint256, reverting on
     * overflow (when the input is greater than largest uint32).
     *
     * Counterpart to Solidity's `uint32` operator.
     *
     * Requirements:
     *
     * - input must fit into 32 bits
     *
     * _Available since v2.5._
     */
    function toUint32(uint256 value) internal pure returns (uint32) {
        require(value <= type(uint32).max, "SafeCast: value doesn't fit in 32 bits");
        return uint32(value);
    }

    /**
     * @dev Returns the downcasted uint24 from uint256, reverting on
     * overflow (when the input is greater than largest uint24).
     *
     * Counterpart to Solidity's `uint24` operator.
     *
     * Requirements:
     *
     * - input must fit into 24 bits
     *
     * _Available since v4.7._
     */
    function toUint24(uint256 value) internal pure returns (uint24) {
        require(value <= type(uint24).max, "SafeCast: value doesn't fit in 24 bits");
        return uint24(value);
    }

    /**
     * @dev Returns the downcasted uint16 from uint256, reverting on
     * overflow (when the input is greater than largest uint16).
     *
     * Counterpart to Solidity's `uint16` operator.
     *
     * Requirements:
     *
     * - input must fit into 16 bits
     *
     * _Available since v2.5._
     */
    function toUint16(uint256 value) internal pure returns (uint16) {
        require(value <= type(uint16).max, "SafeCast: value doesn't fit in 16 bits");
        return uint16(value);
    }

    /**
     * @dev Returns the downcasted uint8 from uint256, reverting on
     * overflow (when the input is greater than largest uint8).
     *
     * Counterpart to Solidity's `uint8` operator.
     *
     * Requirements:
     *
     * - input must fit into 8 bits
     *
     * _Available since v2.5._
     */
    function toUint8(uint256 value) internal pure returns (uint8) {
        require(value <= type(uint8).max, "SafeCast: value doesn't fit in 8 bits");
        return uint8(value);
    }

    /**
     * @dev Converts a signed int256 into an unsigned uint256.
     *
     * Requirements:
     *
     * - input must be greater than or equal to 0.
     *
     * _Available since v3.0._
     */
    function toUint256(int256 value) internal pure returns (uint256) {
        require(value >= 0, "SafeCast: value must be positive");
        return uint256(value);
    }

    /**
     * @dev Returns the downcasted int248 from int256, reverting on
     * overflow (when the input is less than smallest int248 or
     * greater than largest int248).
     *
     * Counterpart to Solidity's `int248` operator.
     *
     * Requirements:
     *
     * - input must fit into 248 bits
     *
     * _Available since v4.7._
     */
    function toInt248(int256 value) internal pure returns (int248) {
        require(value >= type(int248).min && value <= type(int248).max, "SafeCast: value doesn't fit in 248 bits");
        return int248(value);
    }

    /**
     * @dev Returns the downcasted int240 from int256, reverting on
     * overflow (when the input is less than smallest int240 or
     * greater than largest int240).
     *
     * Counterpart to Solidity's `int240` operator.
     *
     * Requirements:
     *
     * - input must fit into 240 bits
     *
     * _Available since v4.7._
     */
    function toInt240(int256 value) internal pure returns (int240) {
        require(value >= type(int240).min && value <= type(int240).max, "SafeCast: value doesn't fit in 240 bits");
        return int240(value);
    }

    /**
     * @dev Returns the downcasted int232 from int256, reverting on
     * overflow (when the input is less than smallest int232 or
     * greater than largest int232).
     *
     * Counterpart to Solidity's `int232` operator.
     *
     * Requirements:
     *
     * - input must fit into 232 bits
     *
     * _Available since v4.7._
     */
    function toInt232(int256 value) internal pure returns (int232) {
        require(value >= type(int232).min && value <= type(int232).max, "SafeCast: value doesn't fit in 232 bits");
        return int232(value);
    }

    /**
     * @dev Returns the downcasted int224 from int256, reverting on
     * overflow (when the input is less than smallest int224 or
     * greater than largest int224).
     *
     * Counterpart to Solidity's `int224` operator.
     *
     * Requirements:
     *
     * - input must fit into 224 bits
     *
     * _Available since v4.7._
     */
    function toInt224(int256 value) internal pure returns (int224) {
        require(value >= type(int224).min && value <= type(int224).max, "SafeCast: value doesn't fit in 224 bits");
        return int224(value);
    }

    /**
     * @dev Returns the downcasted int216 from int256, reverting on
     * overflow (when the input is less than smallest int216 or
     * greater than largest int216).
     *
     * Counterpart to Solidity's `int216` operator.
     *
     * Requirements:
     *
     * - input must fit into 216 bits
     *
     * _Available since v4.7._
     */
    function toInt216(int256 value) internal pure returns (int216) {
        require(value >= type(int216).min && value <= type(int216).max, "SafeCast: value doesn't fit in 216 bits");
        return int216(value);
    }

    /**
     * @dev Returns the downcasted int208 from int256, reverting on
     * overflow (when the input is less than smallest int208 or
     * greater than largest int208).
     *
     * Counterpart to Solidity's `int208` operator.
     *
     * Requirements:
     *
     * - input must fit into 208 bits
     *
     * _Available since v4.7._
     */
    function toInt208(int256 value) internal pure returns (int208) {
        require(value >= type(int208).min && value <= type(int208).max, "SafeCast: value doesn't fit in 208 bits");
        return int208(value);
    }

    /**
     * @dev Returns the downcasted int200 from int256, reverting on
     * overflow (when the input is less than smallest int200 or
     * greater than largest int200).
     *
     * Counterpart to Solidity's `int200` operator.
     *
     * Requirements:
     *
     * - input must fit into 200 bits
     *
     * _Available since v4.7._
     */
    function toInt200(int256 value) internal pure returns (int200) {
        require(value >= type(int200).min && value <= type(int200).max, "SafeCast: value doesn't fit in 200 bits");
        return int200(value);
    }

    /**
     * @dev Returns the downcasted int192 from int256, reverting on
     * overflow (when the input is less than smallest int192 or
     * greater than largest int192).
     *
     * Counterpart to Solidity's `int192` operator.
     *
     * Requirements:
     *
     * - input must fit into 192 bits
     *
     * _Available since v4.7._
     */
    function toInt192(int256 value) internal pure returns (int192) {
        require(value >= type(int192).min && value <= type(int192).max, "SafeCast: value doesn't fit in 192 bits");
        return int192(value);
    }

    /**
     * @dev Returns the downcasted int184 from int256, reverting on
     * overflow (when the input is less than smallest int184 or
     * greater than largest int184).
     *
     * Counterpart to Solidity's `int184` operator.
     *
     * Requirements:
     *
     * - input must fit into 184 bits
     *
     * _Available since v4.7._
     */
    function toInt184(int256 value) internal pure returns (int184) {
        require(value >= type(int184).min && value <= type(int184).max, "SafeCast: value doesn't fit in 184 bits");
        return int184(value);
    }

    /**
     * @dev Returns the downcasted int176 from int256, reverting on
     * overflow (when the input is less than smallest int176 or
     * greater than largest int176).
     *
     * Counterpart to Solidity's `int176` operator.
     *
     * Requirements:
     *
     * - input must fit into 176 bits
     *
     * _Available since v4.7._
     */
    function toInt176(int256 value) internal pure returns (int176) {
        require(value >= type(int176).min && value <= type(int176).max, "SafeCast: value doesn't fit in 176 bits");
        return int176(value);
    }

    /**
     * @dev Returns the downcasted int168 from int256, reverting on
     * overflow (when the input is less than smallest int168 or
     * greater than largest int168).
     *
     * Counterpart to Solidity's `int168` operator.
     *
     * Requirements:
     *
     * - input must fit into 168 bits
     *
     * _Available since v4.7._
     */
    function toInt168(int256 value) internal pure returns (int168) {
        require(value >= type(int168).min && value <= type(int168).max, "SafeCast: value doesn't fit in 168 bits");
        return int168(value);
    }

    /**
     * @dev Returns the downcasted int160 from int256, reverting on
     * overflow (when the input is less than smallest int160 or
     * greater than largest int160).
     *
     * Counterpart to Solidity's `int160` operator.
     *
     * Requirements:
     *
     * - input must fit into 160 bits
     *
     * _Available since v4.7._
     */
    function toInt160(int256 value) internal pure returns (int160) {
        require(value >= type(int160).min && value <= type(int160).max, "SafeCast: value doesn't fit in 160 bits");
        return int160(value);
    }

    /**
     * @dev Returns the downcasted int152 from int256, reverting on
     * overflow (when the input is less than smallest int152 or
     * greater than largest int152).
     *
     * Counterpart to Solidity's `int152` operator.
     *
     * Requirements:
     *
     * - input must fit into 152 bits
     *
     * _Available since v4.7._
     */
    function toInt152(int256 value) internal pure returns (int152) {
        require(value >= type(int152).min && value <= type(int152).max, "SafeCast: value doesn't fit in 152 bits");
        return int152(value);
    }

    /**
     * @dev Returns the downcasted int144 from int256, reverting on
     * overflow (when the input is less than smallest int144 or
     * greater than largest int144).
     *
     * Counterpart to Solidity's `int144` operator.
     *
     * Requirements:
     *
     * - input must fit into 144 bits
     *
     * _Available since v4.7._
     */
    function toInt144(int256 value) internal pure returns (int144) {
        require(value >= type(int144).min && value <= type(int144).max, "SafeCast: value doesn't fit in 144 bits");
        return int144(value);
    }

    /**
     * @dev Returns the downcasted int136 from int256, reverting on
     * overflow (when the input is less than smallest int136 or
     * greater than largest int136).
     *
     * Counterpart to Solidity's `int136` operator.
     *
     * Requirements:
     *
     * - input must fit into 136 bits
     *
     * _Available since v4.7._
     */
    function toInt136(int256 value) internal pure returns (int136) {
        require(value >= type(int136).min && value <= type(int136).max, "SafeCast: value doesn't fit in 136 bits");
        return int136(value);
    }

    /**
     * @dev Returns the downcasted int128 from int256, reverting on
     * overflow (when the input is less than smallest int128 or
     * greater than largest int128).
     *
     * Counterpart to Solidity's `int128` operator.
     *
     * Requirements:
     *
     * - input must fit into 128 bits
     *
     * _Available since v3.1._
     */
    function toInt128(int256 value) internal pure returns (int128) {
        require(value >= type(int128).min && value <= type(int128).max, "SafeCast: value doesn't fit in 128 bits");
        return int128(value);
    }

    /**
     * @dev Returns the downcasted int120 from int256, reverting on
     * overflow (when the input is less than smallest int120 or
     * greater than largest int120).
     *
     * Counterpart to Solidity's `int120` operator.
     *
     * Requirements:
     *
     * - input must fit into 120 bits
     *
     * _Available since v4.7._
     */
    function toInt120(int256 value) internal pure returns (int120) {
        require(value >= type(int120).min && value <= type(int120).max, "SafeCast: value doesn't fit in 120 bits");
        return int120(value);
    }

    /**
     * @dev Returns the downcasted int112 from int256, reverting on
     * overflow (when the input is less than smallest int112 or
     * greater than largest int112).
     *
     * Counterpart to Solidity's `int112` operator.
     *
     * Requirements:
     *
     * - input must fit into 112 bits
     *
     * _Available since v4.7._
     */
    function toInt112(int256 value) internal pure returns (int112) {
        require(value >= type(int112).min && value <= type(int112).max, "SafeCast: value doesn't fit in 112 bits");
        return int112(value);
    }

    /**
     * @dev Returns the downcasted int104 from int256, reverting on
     * overflow (when the input is less than smallest int104 or
     * greater than largest int104).
     *
     * Counterpart to Solidity's `int104` operator.
     *
     * Requirements:
     *
     * - input must fit into 104 bits
     *
     * _Available since v4.7._
     */
    function toInt104(int256 value) internal pure returns (int104) {
        require(value >= type(int104).min && value <= type(int104).max, "SafeCast: value doesn't fit in 104 bits");
        return int104(value);
    }

    /**
     * @dev Returns the downcasted int96 from int256, reverting on
     * overflow (when the input is less than smallest int96 or
     * greater than largest int96).
     *
     * Counterpart to Solidity's `int96` operator.
     *
     * Requirements:
     *
     * - input must fit into 96 bits
     *
     * _Available since v4.7._
     */
    function toInt96(int256 value) internal pure returns (int96) {
        require(value >= type(int96).min && value <= type(int96).max, "SafeCast: value doesn't fit in 96 bits");
        return int96(value);
    }

    /**
     * @dev Returns the downcasted int88 from int256, reverting on
     * overflow (when the input is less than smallest int88 or
     * greater than largest int88).
     *
     * Counterpart to Solidity's `int88` operator.
     *
     * Requirements:
     *
     * - input must fit into 88 bits
     *
     * _Available since v4.7._
     */
    function toInt88(int256 value) internal pure returns (int88) {
        require(value >= type(int88).min && value <= type(int88).max, "SafeCast: value doesn't fit in 88 bits");
        return int88(value);
    }

    /**
     * @dev Returns the downcasted int80 from int256, reverting on
     * overflow (when the input is less than smallest int80 or
     * greater than largest int80).
     *
     * Counterpart to Solidity's `int80` operator.
     *
     * Requirements:
     *
     * - input must fit into 80 bits
     *
     * _Available since v4.7._
     */
    function toInt80(int256 value) internal pure returns (int80) {
        require(value >= type(int80).min && value <= type(int80).max, "SafeCast: value doesn't fit in 80 bits");
        return int80(value);
    }

    /**
     * @dev Returns the downcasted int72 from int256, reverting on
     * overflow (when the input is less than smallest int72 or
     * greater than largest int72).
     *
     * Counterpart to Solidity's `int72` operator.
     *
     * Requirements:
     *
     * - input must fit into 72 bits
     *
     * _Available since v4.7._
     */
    function toInt72(int256 value) internal pure returns (int72) {
        require(value >= type(int72).min && value <= type(int72).max, "SafeCast: value doesn't fit in 72 bits");
        return int72(value);
    }

    /**
     * @dev Returns the downcasted int64 from int256, reverting on
     * overflow (when the input is less than smallest int64 or
     * greater than largest int64).
     *
     * Counterpart to Solidity's `int64` operator.
     *
     * Requirements:
     *
     * - input must fit into 64 bits
     *
     * _Available since v3.1._
     */
    function toInt64(int256 value) internal pure returns (int64) {
        require(value >= type(int64).min && value <= type(int64).max, "SafeCast: value doesn't fit in 64 bits");
        return int64(value);
    }

    /**
     * @dev Returns the downcasted int56 from int256, reverting on
     * overflow (when the input is less than smallest int56 or
     * greater than largest int56).
     *
     * Counterpart to Solidity's `int56` operator.
     *
     * Requirements:
     *
     * - input must fit into 56 bits
     *
     * _Available since v4.7._
     */
    function toInt56(int256 value) internal pure returns (int56) {
        require(value >= type(int56).min && value <= type(int56).max, "SafeCast: value doesn't fit in 56 bits");
        return int56(value);
    }

    /**
     * @dev Returns the downcasted int48 from int256, reverting on
     * overflow (when the input is less than smallest int48 or
     * greater than largest int48).
     *
     * Counterpart to Solidity's `int48` operator.
     *
     * Requirements:
     *
     * - input must fit into 48 bits
     *
     * _Available since v4.7._
     */
    function toInt48(int256 value) internal pure returns (int48) {
        require(value >= type(int48).min && value <= type(int48).max, "SafeCast: value doesn't fit in 48 bits");
        return int48(value);
    }

    /**
     * @dev Returns the downcasted int40 from int256, reverting on
     * overflow (when the input is less than smallest int40 or
     * greater than largest int40).
     *
     * Counterpart to Solidity's `int40` operator.
     *
     * Requirements:
     *
     * - input must fit into 40 bits
     *
     * _Available since v4.7._
     */
    function toInt40(int256 value) internal pure returns (int40) {
        require(value >= type(int40).min && value <= type(int40).max, "SafeCast: value doesn't fit in 40 bits");
        return int40(value);
    }

    /**
     * @dev Returns the downcasted int32 from int256, reverting on
     * overflow (when the input is less than smallest int32 or
     * greater than largest int32).
     *
     * Counterpart to Solidity's `int32` operator.
     *
     * Requirements:
     *
     * - input must fit into 32 bits
     *
     * _Available since v3.1._
     */
    function toInt32(int256 value) internal pure returns (int32) {
        require(value >= type(int32).min && value <= type(int32).max, "SafeCast: value doesn't fit in 32 bits");
        return int32(value);
    }

    /**
     * @dev Returns the downcasted int24 from int256, reverting on
     * overflow (when the input is less than smallest int24 or
     * greater than largest int24).
     *
     * Counterpart to Solidity's `int24` operator.
     *
     * Requirements:
     *
     * - input must fit into 24 bits
     *
     * _Available since v4.7._
     */
    function toInt24(int256 value) internal pure returns (int24) {
        require(value >= type(int24).min && value <= type(int24).max, "SafeCast: value doesn't fit in 24 bits");
        return int24(value);
    }

    /**
     * @dev Returns the downcasted int16 from int256, reverting on
     * overflow (when the input is less than smallest int16 or
     * greater than largest int16).
     *
     * Counterpart to Solidity's `int16` operator.
     *
     * Requirements:
     *
     * - input must fit into 16 bits
     *
     * _Available since v3.1._
     */
    function toInt16(int256 value) internal pure returns (int16) {
        require(value >= type(int16).min && value <= type(int16).max, "SafeCast: value doesn't fit in 16 bits");
        return int16(value);
    }

    /**
     * @dev Returns the downcasted int8 from int256, reverting on
     * overflow (when the input is less than smallest int8 or
     * greater than largest int8).
     *
     * Counterpart to Solidity's `int8` operator.
     *
     * Requirements:
     *
     * - input must fit into 8 bits
     *
     * _Available since v3.1._
     */
    function toInt8(int256 value) internal pure returns (int8) {
        require(value >= type(int8).min && value <= type(int8).max, "SafeCast: value doesn't fit in 8 bits");
        return int8(value);
    }

    /**
     * @dev Converts an unsigned uint256 into a signed int256.
     *
     * Requirements:
     *
     * - input must be less than or equal to maxInt256.
     *
     * _Available since v3.0._
     */
    function toInt256(uint256 value) internal pure returns (int256) {
        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive
        require(value <= uint256(type(int256).max), "SafeCast: value doesn't fit in an int256");
        return int256(value);
    }
}


// File: solidity/contracts/money-market/MoneyMarketDiamond.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

// interfaces
import { IMMDiamondLoupe } from "./interfaces/IMMDiamondLoupe.sol";
import { IMMDiamondCut } from "./interfaces/IMMDiamondCut.sol";
import { IMiniFL } from "./interfaces/IMiniFL.sol";
import { IERC173 } from "./interfaces/IERC173.sol";
import { IERC165 } from "./interfaces/IERC165.sol";

// libraries
import { LibDiamond } from "./libraries/LibDiamond.sol";
import { LibMoneyMarket01 } from "./libraries/LibMoneyMarket01.sol";

contract MoneyMarketDiamond {
  error MoneyMarketDiamond_InvalidAddress();

  constructor(address _diamondCutFacet, address _miniFL) {
    // set contract owner
    LibDiamond.setContractOwner(msg.sender);

    // register DiamondCut facet
    IMMDiamondCut.FacetCut[] memory cut = new IMMDiamondCut.FacetCut[](1);
    bytes4[] memory functionSelectors = new bytes4[](1);
    functionSelectors[0] = IMMDiamondCut.diamondCut.selector;
    cut[0] = IMMDiamondCut.FacetCut({
      facetAddress: _diamondCutFacet,
      action: IMMDiamondCut.FacetCutAction.Add,
      functionSelectors: functionSelectors
    });
    LibDiamond.diamondCut(cut, address(0), "");

    // adding ERC165 data
    LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();
    ds.supportedInterfaces[type(IERC165).interfaceId] = true;
    ds.supportedInterfaces[type(IMMDiamondCut).interfaceId] = true;
    ds.supportedInterfaces[type(IMMDiamondLoupe).interfaceId] = true;
    ds.supportedInterfaces[type(IERC173).interfaceId] = true;

    // initialize money market states
    LibMoneyMarket01.MoneyMarketDiamondStorage storage moneyMarketDs = LibMoneyMarket01.moneyMarketDiamondStorage();
    moneyMarketDs.miniFL = IMiniFL(_miniFL);
  }

  // Find facet for function that is called and execute the
  // function if a facet is found and return any value.
  fallback() external payable {
    LibDiamond.DiamondStorage storage ds;
    bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;
    // get diamond storage
    assembly {
      ds.slot := position
    }
    // get facet from function selector
    address facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;
    require(facet != address(0), "Diamond: Function does not exist");
    // Execute external function from facet using delegatecall and return any value.
    assembly {
      // copy function selector and any arguments
      calldatacopy(0, 0, calldatasize())
      // execute function call using the facet
      let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)
      // get any return value
      returndatacopy(0, 0, returndatasize())
      // return any return value or error back to the caller
      switch result
      case 0 {
        revert(0, returndatasize())
      }
      default {
        return(0, returndatasize())
      }
    }
  }

  receive() external payable {}
}


// File: solidity/contracts/money-market/interfaces/IAlpacaV2Oracle.sol
// SPDX-License-Identifier: BUSL
pragma solidity 0.8.19;

interface IAlpacaV2Oracle {
  /// @dev Errors
  error AlpacaV2Oracle_InvalidLPAddress();
  error AlpacaV2Oracle_InvalidOracleAddress();

  /// @dev Return value in USD for the given lpAmount.
  function lpToDollar(uint256 _lpAmount, address _lpToken) external view returns (uint256, uint256);

  /// @dev Return amount of LP for the given USD.
  function dollarToLp(uint256 _dollarAmount, address _lpToken) external view returns (uint256, uint256);

  /// @dev Return value of given token in USD.
  function getTokenPrice(address _token) external view returns (uint256, uint256);
}


// File: solidity/contracts/money-market/interfaces/IDebtToken.sol
// SPDX-License-Identifier: BUSL
pragma solidity 0.8.19;

interface IDebtToken {
  error DebtToken_UnApprovedHolder();
  error DebtToken_NoSelfTransfer();

  function initialize(address asset_, address moneyMarket_) external;

  function setOkHolders(address[] calldata _okHolders, bool _isOk) external;

  function mint(address to, uint256 amount) external;

  function burn(address from, uint256 amount) external;

  function decimals() external view returns (uint8);
}


// File: solidity/contracts/money-market/interfaces/IERC165.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

interface IERC165 {
  /// @notice Query if a contract implements an interface
  /// @param interfaceId The interface identifier, as specified in ERC-165
  /// @dev Interface identification is specified in ERC-165. This function
  ///  uses less than 30,000 gas.
  /// @return `true` if the contract implements `interfaceID` and
  ///  `interfaceID` is not 0xffffffff, `false` otherwise
  function supportsInterface(bytes4 interfaceId) external view returns (bool);
}


// File: solidity/contracts/money-market/interfaces/IERC173.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

/// @title ERC-173 Contract Ownership Standard
///  Note: the ERC-165 identifier for this interface is 0x7f5828d0
/* is ERC165 */
interface IERC173 {
  /// @dev This emits when ownership of a contract changes.
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

  /// @notice Get the address of the owner
  /// @return owner_ The address of the owner.
  function owner() external view returns (address owner_);

  /// @notice Set the address of the new owner of the contract
  /// @dev Set _newOwner to address(0) to renounce any ownership.
  /// @param _newOwner The address of the new owner of the contract
  function transferOwnership(address _newOwner) external;
}


// File: solidity/contracts/money-market/interfaces/IERC20.sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.19;

interface IERC20 {
  event Transfer(address indexed from, address indexed to, uint256 value);
  event Approval(address indexed owner, address indexed spender, uint256 value);

  function name() external pure returns (string memory);

  function symbol() external pure returns (string memory);

  function decimals() external view returns (uint8);

  function totalSupply() external view returns (uint256);

  function balanceOf(address account) external view returns (uint256);

  function allowance(address owner, address spender) external view returns (uint256);

  function approve(address spender, uint256 amount) external returns (bool);

  function transfer(address recipient, uint256 amount) external returns (bool);

  function transferFrom(
    address sender,
    address recipient,
    uint256 amount
  ) external returns (bool);
}


// File: solidity/contracts/money-market/interfaces/IFeeModel.sol
// SPDX-License-Identifier: BUSL
pragma solidity 0.8.19;

interface IFeeModel {
  function getFeeBps(uint256 _total, uint256 _used) external pure returns (uint256);
}


// File: solidity/contracts/money-market/interfaces/IInterestBearingToken.sol
// SPDX-License-Identifier: BUSL
pragma solidity 0.8.19;

import { IERC20 } from "./IERC20.sol";

interface IInterestBearingToken is IERC20 {
  function initialize(address underlying_, address owner_) external;

  function onDeposit(
    address receiver,
    uint256 assets,
    uint256 shares
  ) external;

  function onWithdraw(
    address owner,
    address receiver,
    uint256 assets,
    uint256 shares
  ) external;

  function decimals() external view returns (uint8);

  function convertToShares(uint256 assets) external view returns (uint256 shares);

  function convertToAssets(uint256 shares) external view returns (uint256 assets);

  function totalAssets() external view returns (uint256);

  function totalSupply() external view returns (uint256);

  function mint(uint256 shares, address receiver) external returns (uint256 assets);
}


// File: solidity/contracts/money-market/interfaces/IInterestRateModel.sol
// SPDX-License-Identifier: BUSL
pragma solidity 0.8.19;

interface IInterestRateModel {
  function getInterestRate(uint256 debt, uint256 floating) external view returns (uint256);

  function CEIL_SLOPE_1() external view returns (uint256);

  function CEIL_SLOPE_2() external view returns (uint256);

  function CEIL_SLOPE_3() external view returns (uint256);

  function MAX_INTEREST_SLOPE_1() external view returns (uint256);

  function MAX_INTEREST_SLOPE_2() external view returns (uint256);

  function MAX_INTEREST_SLOPE_3() external view returns (uint256);
}


// File: solidity/contracts/money-market/interfaces/IMMDiamondCut.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

/******************************************************************************\
* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)
* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535
/******************************************************************************/

interface IMMDiamondCut {
  enum FacetCutAction {
    Add,
    Replace,
    Remove
  }
  // Add=0, Replace=1, Remove=2

  struct FacetCut {
    address facetAddress;
    FacetCutAction action;
    bytes4[] functionSelectors;
  }

  /// @notice Add/replace/remove any number of functions and optionally execute
  ///         a function with delegatecall
  /// @param _diamondCut Contains the facet addresses and function selectors
  /// @param _init The address of the contract or facet to execute _calldata
  /// @param _calldata A function call, including function selector and arguments
  ///                  _calldata is executed with delegatecall on _init
  function diamondCut(
    FacetCut[] calldata _diamondCut,
    address _init,
    bytes calldata _calldata
  ) external;

  event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);
}


// File: solidity/contracts/money-market/interfaces/IMMDiamondLoupe.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

/******************************************************************************\
* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)
* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535
/******************************************************************************/

// A loupe is a small magnifying glass used to look at diamonds.
// These functions look at diamonds
interface IMMDiamondLoupe {
  /// These functions are expected to be called frequently
  /// by tools.

  struct Facet {
    address facetAddress;
    bytes4[] functionSelectors;
  }

  /// @notice Gets all facet addresses and their four byte function selectors.
  /// @return facets_ Facet
  function facets() external view returns (Facet[] memory facets_);

  /// @notice Gets all the function selectors supported by a specific facet.
  /// @param _facet The facet address.
  /// @return facetFunctionSelectors_
  function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);

  /// @notice Get all the facet addresses used by a diamond.
  /// @return facetAddresses_
  function facetAddresses() external view returns (address[] memory facetAddresses_);

  /// @notice Gets the facet that supports the given selector.
  /// @dev If facet is not found return address(0).
  /// @param _functionSelector The function selector.
  /// @return facetAddress_ The facet address.
  function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);
}


// File: solidity/contracts/money-market/interfaces/IMiniFL.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

interface IMiniFL {
  function poolLength() external view returns (uint256);

  function totalAllocPoint() external view returns (uint256);

  function alpacaPerSecond() external view returns (uint256);

  function getUserTotalAmountOf(uint256 _pid, address _user) external view returns (uint256 _totalAmount);

  function getPoolAllocPoint(uint256 _pid) external view returns (uint256 _allocPoint);

  function getStakingReserves(uint256 _pid) external view returns (uint256 _reserveAmount);

  function pendingAlpaca(uint256 _pid, address _user) external view returns (uint256);

  function getUserAmountFundedBy(
    address _funder,
    address _for,
    uint256 _pid
  ) external view returns (uint256 _stakingAmount);

  function addPool(
    uint256 _allocPoint,
    address _stakingToken,
    bool _withUpdate
  ) external returns (uint256 _pid);

  function deposit(
    address _for,
    uint256 _pid,
    uint256 _amountToDeposit
  ) external;

  function withdraw(
    address _from,
    uint256 _pid,
    uint256 _amountToWithdraw
  ) external;

  function harvest(uint256 _pid) external;

  function harvestMany(uint256[] calldata _pids) external;
}


// File: solidity/contracts/money-market/libraries/LibConstant.sol
// SPDX-License-Identifier: BUSL
pragma solidity 0.8.19;

library LibConstant {
  enum AssetTier {
    UNLISTED,
    ISOLATE,
    CROSS,
    COLLATERAL
  }

  struct TokenConfig {
    AssetTier tier;
    uint16 collateralFactor;
    uint16 borrowingFactor;
    uint64 to18ConversionFactor;
    uint256 maxCollateral;
    uint256 maxBorrow; // shared global limit
  }

  uint256 internal constant MAX_BPS = 10000;
}


// File: solidity/contracts/money-market/libraries/LibDiamond.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

/******************************************************************************\
* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)
* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535
/******************************************************************************/
import { IMMDiamondCut } from "../interfaces/IMMDiamondCut.sol";

// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.
// The loupe functions are required by the EIP2535 Diamonds standard

error InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);

library LibDiamond {
  bytes32 constant DIAMOND_STORAGE_POSITION = keccak256("diamond.standard.diamond.storage");

  struct FacetAddressAndPosition {
    address facetAddress;
    uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array
  }

  struct FacetFunctionSelectors {
    bytes4[] functionSelectors;
    uint256 facetAddressPosition; // position of facetAddress in facetAddresses array
  }

  struct DiamondStorage {
    // maps function selector to the facet address and
    // the position of the selector in the facetFunctionSelectors.selectors array
    mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;
    // maps facet addresses to function selectors
    mapping(address => FacetFunctionSelectors) facetFunctionSelectors;
    // facet addresses
    address[] facetAddresses;
    // Used to query if a contract implements an interface.
    // Used to implement ERC-165.
    mapping(bytes4 => bool) supportedInterfaces;
    // owner of the contract
    address contractOwner;
    address pendingOwner;
  }

  function diamondStorage() internal pure returns (DiamondStorage storage ds) {
    bytes32 position = DIAMOND_STORAGE_POSITION;
    assembly {
      ds.slot := position
    }
  }

  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

  function setContractOwner(address _newOwner) internal {
    DiamondStorage storage ds = diamondStorage();
    address previousOwner = ds.contractOwner;
    ds.contractOwner = _newOwner;
    emit OwnershipTransferred(previousOwner, _newOwner);
  }

  function setPendingOwner(address _newPendingOwner) internal {
    DiamondStorage storage ds = diamondStorage();
    ds.pendingOwner = _newPendingOwner;
  }

  function contractOwner() internal view returns (address contractOwner_) {
    contractOwner_ = diamondStorage().contractOwner;
  }

  function pendingOwner() internal view returns (address pendingOwner_) {
    pendingOwner_ = diamondStorage().pendingOwner;
  }

  function enforceIsContractOwner() internal view {
    require(msg.sender == diamondStorage().contractOwner, "LibDiamond: Must be contract owner");
  }

  event DiamondCut(IMMDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);

  // Internal function version of diamondCut
  function diamondCut(
    IMMDiamondCut.FacetCut[] memory _diamondCut,
    address _init,
    bytes memory _calldata
  ) internal {
    for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {
      IMMDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;
      if (action == IMMDiamondCut.FacetCutAction.Add) {
        addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);
      } else if (action == IMMDiamondCut.FacetCutAction.Replace) {
        replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);
      } else if (action == IMMDiamondCut.FacetCutAction.Remove) {
        removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);
      } else {
        revert("LibDiamondCut: Incorrect FacetCutAction");
      }
    }
    emit DiamondCut(_diamondCut, _init, _calldata);
    initializeDiamondCut(_init, _calldata);
  }

  function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {
    require(_functionSelectors.length > 0, "LibDiamondCut: No selectors in facet to cut");
    DiamondStorage storage ds = diamondStorage();
    require(_facetAddress != address(0), "LibDiamondCut: Add facet can't be address(0)");
    uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);
    // add new facet address if it does not exist
    if (selectorPosition == 0) {
      addFacet(ds, _facetAddress);
    }
    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {
      bytes4 selector = _functionSelectors[selectorIndex];
      address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;
      require(oldFacetAddress == address(0), "LibDiamondCut: Can't add function that already exists");
      addFunction(ds, selector, selectorPosition, _facetAddress);
      selectorPosition++;
    }
  }

  function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {
    require(_functionSelectors.length > 0, "LibDiamondCut: No selectors in facet to cut");
    DiamondStorage storage ds = diamondStorage();
    require(_facetAddress != address(0), "LibDiamondCut: Add facet can't be address(0)");
    uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);
    // add new facet address if it does not exist
    if (selectorPosition == 0) {
      addFacet(ds, _facetAddress);
    }
    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {
      bytes4 selector = _functionSelectors[selectorIndex];
      address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;
      require(oldFacetAddress != _facetAddress, "LibDiamondCut: Can't replace function with same function");
      removeFunction(ds, oldFacetAddress, selector);
      addFunction(ds, selector, selectorPosition, _facetAddress);
      selectorPosition++;
    }
  }

  function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {
    require(_functionSelectors.length > 0, "LibDiamondCut: No selectors in facet to cut");
    DiamondStorage storage ds = diamondStorage();
    // if function does not exist then do nothing and return
    require(_facetAddress == address(0), "LibDiamondCut: Remove facet address must be address(0)");
    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {
      bytes4 selector = _functionSelectors[selectorIndex];
      address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;
      removeFunction(ds, oldFacetAddress, selector);
    }
  }

  function addFacet(DiamondStorage storage ds, address _facetAddress) internal {
    enforceHasContractCode(_facetAddress, "LibDiamondCut: New facet has no code");
    ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;
    ds.facetAddresses.push(_facetAddress);
  }

  function addFunction(
    DiamondStorage storage ds,
    bytes4 _selector,
    uint96 _selectorPosition,
    address _facetAddress
  ) internal {
    ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;
    ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);
    ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;
  }

  function removeFunction(
    DiamondStorage storage ds,
    address _facetAddress,
    bytes4 _selector
  ) internal {
    require(_facetAddress != address(0), "LibDiamondCut: Can't remove function that doesn't exist");
    // an immutable function is a function defined directly in a diamond
    require(_facetAddress != address(this), "LibDiamondCut: Can't remove immutable function");
    // replace selector with last selector, then delete last selector
    uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;
    uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;
    // if not the same then replace _selector with lastSelector
    if (selectorPosition != lastSelectorPosition) {
      bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];
      ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;
      ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);
    }
    // delete the last selector
    ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();
    delete ds.selectorToFacetAndPosition[_selector];

    // if no more selectors for facet address then delete the facet address
    if (lastSelectorPosition == 0) {
      // replace facet address with last facet address and delete last facet address
      uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;
      uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;
      if (facetAddressPosition != lastFacetAddressPosition) {
        address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];
        ds.facetAddresses[facetAddressPosition] = lastFacetAddress;
        ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;
      }
      ds.facetAddresses.pop();
      delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;
    }
  }

  function initializeDiamondCut(address _init, bytes memory _calldata) internal {
    if (_init == address(0)) {
      return;
    }
    enforceHasContractCode(_init, "LibDiamondCut: _init address has no code");
    (bool success, bytes memory error) = _init.delegatecall(_calldata);
    if (!success) {
      if (error.length > 0) {
        // bubble up error
        /// @solidity memory-safe-assembly
        assembly {
          let returndata_size := mload(error)
          revert(add(32, error), returndata_size)
        }
      } else {
        revert InitializationFunctionReverted(_init, _calldata);
      }
    }
  }

  function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {
    uint256 contractSize;
    assembly {
      contractSize := extcodesize(_contract)
    }
    require(contractSize > 0, _errorMessage);
  }
}


// File: solidity/contracts/money-market/libraries/LibDoublyLinkedList.sol
// SPDX-License-Identifier: BUSL
pragma solidity 0.8.19;

library LibDoublyLinkedList {
  error LibDoublyLinkedList_Existed();
  error LibDoublyLinkedList_NotExisted();
  error LibDoublyLinkedList_NotInitialized();

  address internal constant START = address(1);
  address internal constant END = address(1);
  address internal constant EMPTY = address(0);

  struct List {
    uint256 size;
    mapping(address => address) next;
    mapping(address => uint256) amount;
    mapping(address => address) prev;
  }

  struct Node {
    address token;
    uint256 amount;
  }

  function initIfNotExist(List storage list) internal {
    // 1(START) <> 0(EMPTY)
    // 1(START).next = 1(END)
    // 1(END).prev = 1(START)
    // 1(START) <> 1(END)
    if (list.next[START] == EMPTY) {
      list.next[START] = END;
      list.prev[END] = START;
    }
  }

  function has(List storage list, address addr) internal view returns (bool) {
    return list.next[addr] != EMPTY;
  }

  /// @dev removing will cut `addr` from the link
  /// ex. `addr` is BTC
  ///     START <> ETH <> BTC <> END => START <> ETH <> END
  function updateOrRemove(
    List storage list,
    address addr,
    uint256 amount
  ) internal {
    address nextOfAddr = list.next[addr];

    // Check
    if (nextOfAddr == EMPTY) {
      revert LibDoublyLinkedList_NotExisted();
    }

    // Effect
    // skip removing if `amount` still remain
    //
    // ex. remove BTC:
    //  START   = 1
    //  BTC     = 2 (assume)
    //  ETH     = 3 (assume)
    //  END     = 1
    //  [Current link]: 1 <> 3 <> 2 <> 1
    //
    //  `addr` = 2, since removing BTC
    //  prevOfAddr = 3
    //  nextOfAddr = 1
    //
    //  Step 1: 3(prevOfAddr).next  = 1   -->   1 <- 3 -> 1
    //  Step 2: 1(nextOfAddr).prev  = 3   -->   3 <- 1 -> 0
    //  [Current link]: 1 <> 3 <> 1
    //
    //  Step 3: 2.prev = 0    -->   0 <- 2 -> 1
    //  Step 4: 2.next = 0    -->   0 <- 2 -> 0
    //  [Current link]: 1 <> 3 <> 1
    if (amount == 0) {
      address prevOfAddr = list.prev[addr];

      // cut the node from current link
      // step 1: set next of (prev of `addr`) to be next of `addr`
      list.next[prevOfAddr] = nextOfAddr;
      // step 2: set prev of (next of `addr`) to be prev of `addr`
      list.prev[nextOfAddr] = prevOfAddr;

      // cut current link from the node
      // step 3: set next of `addr` to be EMPTY
      list.next[addr] = EMPTY;
      // step 4: set prev of `addr` to be EMPTY
      list.prev[addr] = EMPTY;

      --list.size;
    }

    list.amount[addr] = amount;
  }

  /// @dev adding will put `addr` after `START`
  /// ex. START <> BTC <> END => START <> addr <> BTC <> END
  function addOrUpdate(
    List storage list,
    address addr,
    uint256 amount
  ) internal {
    // Check
    // prevent create empty node
    if (amount == 0) {
      return;
    }

    // Effect
    // skip adding if `addr` already existed
    //
    // ex. add `addr`:
    //  START   = 1
    //  BTC     = 2 (assume)
    //  END     = 1
    //  [Current link]: 1 <> 2 <> 1
    //
    //  `addr`  = 3 (assume)
    //  Initial of 3  -->  0 <- 3 -> 0
    //
    //  Step 1: 3.next  = 2   -->   0 <- 3 -> 2
    //  Step 2: 2.prev  = 3   -->   3 <- 2 -> 1
    //  [Current link]: 0 <> 3 <> 2 <> 1
    //
    //  Step 3: 3.prev = 1    -->   1 <- 3 -> 2
    //  Step 4: 1.next = 3    -->   0 <- 1 -> 3
    //  [Current link]: 1 <> 3 <> 2 <> 1
    if (!has(list, addr)) {
      // add `addr` to the link after `START`
      address nextOfStart = list.next[START];
      // step 1: set next of `addr` to be next of `START`
      list.next[addr] = nextOfStart;
      // step 2: set prev of next of `START` to be `addr`
      list.prev[nextOfStart] = addr;

      // step 3: set prev of `addr` to be `START`
      list.prev[addr] = START;
      // step 4: set next of `START` to be `addr`
      list.next[START] = addr;

      unchecked {
        ++list.size;
      }
    }

    list.amount[addr] = amount;
  }

  function getAmount(List storage list, address addr) internal view returns (uint256) {
    return list.amount[addr];
  }

  function getAll(List storage list) internal view returns (Node[] memory) {
    Node[] memory nodes = new Node[](list.size);
    if (list.size == 0) {
      return nodes;
    }
    address curr = list.next[START];
    for (uint256 i; curr != END; ) {
      nodes[i] = Node({ token: curr, amount: list.amount[curr] });
      curr = list.next[curr];
      unchecked {
        ++i;
      }
    }
    return nodes;
  }

  function getPreviousOf(List storage list, address addr) internal view returns (address) {
    return list.prev[addr];
  }

  function getNextOf(List storage list, address addr) internal view returns (address) {
    return list.next[addr];
  }

  function length(List storage list) internal view returns (uint256) {
    return list.size;
  }
}


// File: solidity/contracts/money-market/libraries/LibFullMath.sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.19;

/// @title Contains 512-bit math functions
/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision
/// @dev Handles "phantom overflow" i.e., allows multiplication and division where an intermediate value overflows 256 bits
library LibFullMath {
  /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
  /// @param a The multiplicand
  /// @param b The multiplier
  /// @param denominator The divisor
  /// @return result The 256-bit result
  /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv
  function mulDiv(
    uint256 a,
    uint256 b,
    uint256 denominator
  ) internal pure returns (uint256 result) {
    unchecked {
      // 512-bit multiply [prod1 prod0] = a * b
      // Compute the product mod 2**256 and mod 2**256 - 1
      // then use the Chinese Remainder Theorem to reconstruct
      // the 512 bit result. The result is stored in two 256
      // variables such that product = prod1 * 2**256 + prod0
      uint256 prod0; // Least significant 256 bits of the product
      uint256 prod1; // Most significant 256 bits of the product
      assembly {
        let mm := mulmod(a, b, not(0))
        prod0 := mul(a, b)
        prod1 := sub(sub(mm, prod0), lt(mm, prod0))
      }

      // Handle non-overflow cases, 256 by 256 division
      if (prod1 == 0) {
        require(denominator > 0);
        assembly {
          result := div(prod0, denominator)
        }
        return result;
      }

      // Make sure the result is less than 2**256.
      // Also prevents denominator == 0
      require(denominator > prod1);

      ///////////////////////////////////////////////
      // 512 by 256 division.
      ///////////////////////////////////////////////

      // Make division exact by subtracting the remainder from [prod1 prod0]
      // Compute remainder using mulmod
      uint256 remainder;
      assembly {
        remainder := mulmod(a, b, denominator)
      }
      // Subtract 256 bit number from 512 bit number
      assembly {
        prod1 := sub(prod1, gt(remainder, prod0))
        prod0 := sub(prod0, remainder)
      }

      // Factor powers of two out of denominator
      // Compute largest power of two divisor of denominator.
      // Always >= 1.
      uint256 twos = (type(uint256).max - denominator + 1) & denominator;
      // Divide denominator by power of two
      assembly {
        denominator := div(denominator, twos)
      }

      // Divide [prod1 prod0] by the factors of two
      assembly {
        prod0 := div(prod0, twos)
      }
      // Shift in bits from prod1 into prod0. For this we need
      // to flip `twos` such that it is 2**256 / twos.
      // If twos is zero, then it becomes one
      assembly {
        twos := add(div(sub(0, twos), twos), 1)
      }
      prod0 |= prod1 * twos;

      // Invert denominator mod 2**256
      // Now that denominator is an odd number, it has an inverse
      // modulo 2**256 such that denominator * inv = 1 mod 2**256.
      // Compute the inverse by starting with a seed that is correct
      // correct for four bits. That is, denominator * inv = 1 mod 2**4
      uint256 inv = (3 * denominator) ^ 2;
      // Now use Newton-Raphson iteration to improve the precision.
      // Thanks to Hensel's lifting lemma, this also works in modular
      // arithmetic, doubling the correct bits in each step.
      inv *= 2 - denominator * inv; // inverse mod 2**8
      inv *= 2 - denominator * inv; // inverse mod 2**16
      inv *= 2 - denominator * inv; // inverse mod 2**32
      inv *= 2 - denominator * inv; // inverse mod 2**64
      inv *= 2 - denominator * inv; // inverse mod 2**128
      inv *= 2 - denominator * inv; // inverse mod 2**256

      // Because the division is now exact we can divide by multiplying
      // with the modular inverse of denominator. This will give us the
      // correct result modulo 2**256. Since the precoditions guarantee
      // that the outcome is less than 2**256, this is the final result.
      // We don't need to compute the high bits of the result and prod1
      // is no longer required.
      result = prod0 * inv;
      return result;
    }
  }

  /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
  /// @param a The multiplicand
  /// @param b The multiplier
  /// @param denominator The divisor
  /// @return result The 256-bit result
  function mulDivRoundingUp(
    uint256 a,
    uint256 b,
    uint256 denominator
  ) internal pure returns (uint256 result) {
    result = mulDiv(a, b, denominator);
    unchecked {
      if (mulmod(a, b, denominator) > 0) {
        require(result < type(uint256).max);
        result++;
      }
    }
  }

  /**
   * @dev Returns the largest of two numbers.
   */
  function max(uint256 a, uint256 b) internal pure returns (uint256) {
    return a >= b ? a : b;
  }

  /**
   * @dev Returns the smallest of two numbers.
   */
  function min(uint256 a, uint256 b) internal pure returns (uint256) {
    return a < b ? a : b;
  }
}


// File: solidity/contracts/money-market/libraries/LibMoneyMarket01.sol
// SPDX-License-Identifier: BUSL
pragma solidity 0.8.19;

import { SafeCast } from "@openzeppelin/contracts/utils/math/SafeCast.sol";

// libs
import { LibDoublyLinkedList } from "./LibDoublyLinkedList.sol";
import { LibFullMath } from "./LibFullMath.sol";
import { LibShareUtil } from "./LibShareUtil.sol";
import { LibConstant } from "./LibConstant.sol";
import { LibSafeToken } from "../libraries/LibSafeToken.sol";

// interfaces
import { IERC20 } from "../interfaces/IERC20.sol";
import { IInterestBearingToken } from "../interfaces/IInterestBearingToken.sol";
import { IAlpacaV2Oracle } from "../interfaces/IAlpacaV2Oracle.sol";
import { IInterestRateModel } from "../interfaces/IInterestRateModel.sol";
import { IFeeModel } from "../interfaces/IFeeModel.sol";
import { IMiniFL } from "../interfaces/IMiniFL.sol";
import { IDebtToken } from "../interfaces/IDebtToken.sol";

library LibMoneyMarket01 {
  using LibDoublyLinkedList for LibDoublyLinkedList.List;
  using SafeCast for uint256;
  using LibSafeToken for IERC20;

  // keccak256("moneymarket.diamond.storage");
  bytes32 internal constant MONEY_MARKET_STORAGE_POSITION =
    0x2758c6926500ec9dc8ab8cea4053d172d4f50d9b78a6c2ee56aa5dd18d2c800b;

  uint256 internal constant MAX_REPURCHASE_FEE_BPS = 1000;

  error LibMoneyMarket01_BadSubAccountId();
  error LibMoneyMarket01_InvalidToken(address _token);
  error LibMoneyMarket01_UnsupportedDecimals();
  error LibMoneyMarket01_InvalidAssetTier();
  error LibMoneyMarket01_ExceedCollateralLimit();
  error LibMoneyMarket01_TooManyCollateralRemoved();
  error LibMoneyMarket01_BorrowingPowerTooLow();
  error LibMoneyMarket01_NotEnoughToken();
  error LibMoneyMarket01_NumberOfTokenExceedLimit();
  error LibMoneyMarket01_FeeOnTransferTokensNotSupported();
  error LibMoneyMarket01_EmergencyPaused();
  error LibMoneyMarket01_UnAuthorized();
  error LibMoneyMarket01_SubAccountHealthy();

  event LogWithdraw(address indexed _user, address _token, address _ibToken, uint256 _amountIn, uint256 _amountOut);
  event LogAccrueInterest(address indexed _token, uint256 _totalInterest, uint256 _totalToProtocolReserve);
  event LogRemoveDebt(
    address indexed _account,
    address indexed _subAccount,
    address indexed _token,
    uint256 _removedDebtShare,
    uint256 _removedDebtAmount,
    uint256 _numOfDebt
  );

  event LogRemoveCollateral(
    address indexed _account,
    address indexed _subAccount,
    address indexed _token,
    uint256 _amount
  );

  event LogAddCollateral(
    address indexed _account,
    address indexed _subAccount,
    address indexed _token,
    address _caller,
    uint256 _amount
  );

  event LogOverCollatBorrow(
    address indexed _account,
    address indexed _subAccount,
    address indexed _token,
    uint256 _borrowedAmount,
    uint256 _debtShare,
    uint256 _numOfDebt
  );

  event LogWriteOffSubAccountDebt(
    address indexed subAccount,
    address indexed token,
    uint256 debtShareWrittenOff,
    uint256 debtValueWrittenOff
  );

  struct ProtocolConfig {
    mapping(address => uint256) maxTokenBorrow; // token limit per account
    uint256 borrowingPowerLimit;
  }

  // Storage
  struct MoneyMarketDiamondStorage {
    // ---- addresses ---- //
    address liquidationTreasury;
    address ibTokenImplementation;
    address debtTokenImplementation;
    IAlpacaV2Oracle oracle;
    IFeeModel repurchaseRewardModel;
    IMiniFL miniFL;
    bool emergencyPaused; // flag for pausing deposit and borrow on the money market
    // ---- ib tokens ---- //
    mapping(address => address) tokenToIbTokens; // token address => ibToken address
    mapping(address => address) ibTokenToTokens; // ibToken address => token address
    // ---- debt tokens ---- //
    mapping(address => address) tokenToDebtTokens; // token address => debtToken address
    // ---- miniFL pools ---- //
    mapping(address => uint256) miniFLPoolIds; // token address => pool id
    // ---- lending ---- //
    mapping(address => uint256) globalDebts; // token address => over + non collat debt
    // ---- over-collateralized lending ---- //
    mapping(address => uint256) overCollatDebtValues; // borrower address => debt amount in borrowed token
    mapping(address => uint256) overCollatDebtShares; // borrower address => debt shares
    mapping(address => uint256) collats; // token address => total collateral of a token
    mapping(address => IInterestRateModel) interestModels; // token address => over-collat interest model
    // ---- non-collateralized lending ---- //
    mapping(address => LibDoublyLinkedList.List) nonCollatAccountDebtValues; // account => list token debt
    mapping(address => LibDoublyLinkedList.List) nonCollatTokenDebtValues; // token => debt of each account
    mapping(address => ProtocolConfig) protocolConfigs; // account => ProtocolConfig
    mapping(address => mapping(address => IInterestRateModel)) nonCollatInterestModels; // [account][token] => non-collat interest model
    mapping(address => bool) nonCollatBorrowerOk; // can this address do non collat borrow
    // ---- subAccounts ---- //
    mapping(address => LibDoublyLinkedList.List) subAccountCollats; // subAccount => list of subAccount's all collateral
    mapping(address => LibDoublyLinkedList.List) subAccountDebtShares; // subAccount => list of subAccount's all debt
    // ---- tokens ---- //
    mapping(address => LibConstant.TokenConfig) tokenConfigs; // token address => config
    mapping(address => uint256) debtLastAccruedAt; // token address => last interest accrual timestamp, shared between over and non collat
    // ---- whitelists ---- //
    mapping(address => bool) liquidationStratOk; // liquidation strategies that can be used during liquidation process
    mapping(address => bool) liquidatorsOk; // allowed to initiate liquidation process
    mapping(address => bool) accountManagersOk; // allowed to manipulate account/subaccount on behalf of end users
    mapping(address => bool) riskManagersOk; // allowed to set risk control parameters
    // ---- reserves ---- //
    mapping(address => uint256) protocolReserves; // token address => amount that is reserved for protocol
    mapping(address => uint256) reserves; // token address => amount that is available in protocol
    // ---- protocol params ---- //
    uint256 minDebtSize; // minimum debt that borrower must maintain
    // maximum number of token in the linked list
    uint8 maxNumOfCollatPerSubAccount;
    uint8 maxNumOfDebtPerSubAccount;
    uint8 maxNumOfDebtPerNonCollatAccount;
    // counting of non collat borrowers
    uint8 countNonCollatBorrowers;
    // liquidation params
    uint16 maxLiquidateBps; // maximum portion of debt that is allowed to be repurchased / liquidated per transaction
    uint16 liquidationThresholdBps; // threshold that allow subAccount to be liquidated if borrowing power goes below threshold
    // fees
    uint16 lendingFeeBps; // fee that is charged from lending interest by protocol, goes to protocolReserve
    uint16 repurchaseFeeBps; // fee that is charged during repurchase by protocol, goes to liquidationTreasury
    uint16 liquidationFeeBps; // fee that is charged during liquidation by protocol, goes to liquidationTreasury
  }

  /// @dev Get money market storage
  /// @return moneyMarketStorage The storage of money market
  function moneyMarketDiamondStorage() internal pure returns (MoneyMarketDiamondStorage storage moneyMarketStorage) {
    assembly {
      moneyMarketStorage.slot := MONEY_MARKET_STORAGE_POSITION
    }
  }

  /// @dev Calculate sub account address
  /// @param primary The account address
  /// @param subAccountId A sub account id
  /// @return The sub account address
  function getSubAccount(address primary, uint256 subAccountId) internal pure returns (address) {
    // revert if subAccountId is greater than 255
    if (subAccountId > 255) {
      revert LibMoneyMarket01_BadSubAccountId();
    }
    // sub account address is the XOR of primary address and subAccountId
    // primary address is 20 bytes long, so it is (20 * 8) = 160 bits long
    //
    // calculation:
    // sub account address = primary XOR subAccountId
    //
    // example:
    //  - primary           = 0x0...88
    //  - subAccountId      = 2
    //
    //  sub account address = 0x0...88 XOR 2
    //                      = 0x0...8a
    return address(uint160(primary) ^ uint160(subAccountId));
  }

  /// @dev Calculate total borrowing power of a sub account
  /// @param _subAccount The sub account address
  /// @param moneyMarketDs The storage of money market
  /// @return _totalBorrowingPower The total borrowing power of a sub account
  function getTotalBorrowingPower(address _subAccount, MoneyMarketDiamondStorage storage moneyMarketDs)
    internal
    view
    returns (uint256 _totalBorrowingPower)
  {
    // get all collats of a sub account
    LibDoublyLinkedList.Node[] memory _collats = moneyMarketDs.subAccountCollats[_subAccount].getAll();

    address _collatToken;
    uint256 _tokenPrice;
    LibConstant.TokenConfig memory _tokenConfig;

    uint256 _collatsLength = _collats.length;

    // sum up total borrowing power
    for (uint256 _i; _i < _collatsLength; ) {
      _collatToken = _collats[_i].token;

      // get collat token price in USD
      _tokenPrice = getPriceUSD(_collatToken, moneyMarketDs);
      _tokenConfig = moneyMarketDs.tokenConfigs[_collatToken];

      // calulation:
      // _totalBorrowingPower += amount * tokenPrice * collateralFactor
      //
      // example:
      //  - amount                = 100
      //  - tokenPrice            = 1
      //  - collateralFactor      = 9000 (need to divide by LibConstant.MAX_BPS)
      //
      //  _totalBorrowingPower   += 100 * 1 * (9000/10000)
      //                         += 90
      _totalBorrowingPower += LibFullMath.mulDiv(
        _collats[_i].amount * _tokenConfig.to18ConversionFactor * _tokenConfig.collateralFactor,
        _tokenPrice,
        1e22
      );

      unchecked {
        ++_i;
      }
    }
  }

  /// @dev Calculate total non collat token debt of a token
  /// @param _token The token address
  /// @param moneyMarketDs The storage of money market
  /// @return _totalNonCollatDebt The total non collat token debt
  function getNonCollatTokenDebt(address _token, MoneyMarketDiamondStorage storage moneyMarketDs)
    internal
    view
    returns (uint256 _totalNonCollatDebt)
  {
    // get all non collat token debt values of _token
    LibDoublyLinkedList.Node[] memory _nonCollatDebts = moneyMarketDs.nonCollatTokenDebtValues[_token].getAll();

    uint256 _length = _nonCollatDebts.length;

    // sum up total non collat token debt of _token
    for (uint256 _i; _i < _length; ) {
      _totalNonCollatDebt += _nonCollatDebts[_i].amount;

      unchecked {
        ++_i;
      }
    }
  }

  /// @dev Calculate total used borrowing power of a sub account
  /// @param _subAccount The sub account address
  /// @param moneyMarketDs The storage of money market
  /// @return _totalUsedBorrowingPower The total used borrowing power of a sub account
  /// @return _hasIsolateAsset True if sub account has isolate asset
  function getTotalUsedBorrowingPower(address _subAccount, MoneyMarketDiamondStorage storage moneyMarketDs)
    internal
    view
    returns (uint256 _totalUsedBorrowingPower, bool _hasIsolateAsset)
  {
    // get all borrowed positions of a sub account
    LibDoublyLinkedList.Node[] memory _borrowed = moneyMarketDs.subAccountDebtShares[_subAccount].getAll();

    uint256 _borrowedLength = _borrowed.length;

    address _borrowedToken;
    LibConstant.TokenConfig memory _tokenConfig;

    // sum up total used borrowing power from each borrowed token
    for (uint256 _i; _i < _borrowedLength; ) {
      _borrowedToken = _borrowed[_i].token;
      _tokenConfig = moneyMarketDs.tokenConfigs[_borrowedToken];

      if (_tokenConfig.tier == LibConstant.AssetTier.ISOLATE) {
        _hasIsolateAsset = true;
      }

      _totalUsedBorrowingPower += usedBorrowingPower(
        LibShareUtil.shareToValue(
          _borrowed[_i].amount,
          moneyMarketDs.overCollatDebtValues[_borrowedToken],
          moneyMarketDs.overCollatDebtShares[_borrowedToken]
        ),
        getPriceUSD(_borrowedToken, moneyMarketDs),
        _tokenConfig.borrowingFactor,
        _tokenConfig.to18ConversionFactor
      );

      unchecked {
        ++_i;
      }
    }
  }

  /// @dev Calculate total used borrowing power of a non collat borrower
  /// @param _account The non collat borrower address
  /// @param moneyMarketDs The storage of money market
  /// @return _totalUsedBorrowingPower The total used borrowing power of a non collat borrower
  function getTotalNonCollatUsedBorrowingPower(address _account, MoneyMarketDiamondStorage storage moneyMarketDs)
    internal
    view
    returns (uint256 _totalUsedBorrowingPower)
  {
    // get all borrowed positions of a non collat borrower
    LibDoublyLinkedList.Node[] memory _borrowed = moneyMarketDs.nonCollatAccountDebtValues[_account].getAll();

    uint256 _borrowedLength = _borrowed.length;

    LibConstant.TokenConfig memory _tokenConfig;
    address _borrowedToken;

    // sum up total used borrowing power from each borrowed token
    for (uint256 _i; _i < _borrowedLength; ) {
      _borrowedToken = _borrowed[_i].token;
      _tokenConfig = moneyMarketDs.tokenConfigs[_borrowedToken];

      _totalUsedBorrowingPower += usedBorrowingPower(
        _borrowed[_i].amount,
        getPriceUSD(_borrowedToken, moneyMarketDs),
        _tokenConfig.borrowingFactor,
        _tokenConfig.to18ConversionFactor
      );

      unchecked {
        ++_i;
      }
    }
  }

  /// @dev Calculate used borrowing power of a token
  /// @param _subAccount The sub account address
  /// @param moneyMarketDs The storage of money market
  /// @return _totalBorrowedUSDValue The total borrowed USD value of a sub account
  function getTotalBorrowedUSDValue(address _subAccount, MoneyMarketDiamondStorage storage moneyMarketDs)
    internal
    view
    returns (uint256 _totalBorrowedUSDValue)
  {
    // get all borrowed positions of a sub account
    LibDoublyLinkedList.Node[] memory _borrowed = moneyMarketDs.subAccountDebtShares[_subAccount].getAll();

    uint256 _borrowedLength = _borrowed.length;

    address _borrowedToken;
    uint256 _borrowedAmount;

    // sum up total borrowed USD value from each borrowed token
    for (uint256 _i; _i < _borrowedLength; ) {
      _borrowedToken = _borrowed[_i].token;

      _borrowedAmount = LibShareUtil.shareToValue(
        _borrowed[_i].amount,
        moneyMarketDs.overCollatDebtValues[_borrowedToken],
        moneyMarketDs.overCollatDebtShares[_borrowedToken]
      );

      // calulation:
      // _totalBorrowedUSDValue += _borrowedAmount * tokenPrice
      //
      // example:
      //  - _borrowedAmount       = 100
      //  - tokenPrice            = 1.5
      //
      //  _totalBorrowingPower   += 100 * 1.5
      //                         += 150
      _totalBorrowedUSDValue += LibFullMath.mulDiv(
        _borrowedAmount * moneyMarketDs.tokenConfigs[_borrowedToken].to18ConversionFactor,
        getPriceUSD(_borrowedToken, moneyMarketDs),
        1e18
      );

      unchecked {
        ++_i;
      }
    }
  }

  /// @dev Calculate used borrowing power of a token
  /// @param _borrowedAmount The borrowed amount
  /// @param _tokenPrice The token price
  /// @param _borrowingFactor The borrowing factor
  /// @param _to18ConversionFactor The conversion factor to 18 decimals
  function usedBorrowingPower(
    uint256 _borrowedAmount,
    uint256 _tokenPrice,
    uint256 _borrowingFactor,
    uint256 _to18ConversionFactor
  ) internal pure returns (uint256 _usedBorrowingPower) {
    // calulation:
    // usedBorrowingPower = borrowedAmountE18 * tokenPrice * (LibConstant.MAX_BPS / borrowingFactor)
    //
    // example:
    //  - borrowedAmountE18   = 100 (omit 1e18)
    //  - tokenPrice          = 1.5
    //  - LibConstant.MAX_BPS             = 10000
    //  - borrowingFactor     = 9000
    //
    //  usedBorrowingPower    = 100 * 1.5 * (10000 / 9000)
    //                        = 100 * 1.5 * 1.11111
    //                        = 166.67
    _usedBorrowingPower = LibFullMath.mulDiv(
      _borrowedAmount * _to18ConversionFactor,
      _tokenPrice,
      1e14 * _borrowingFactor // gas savings: 1e14 = 1e18 / LibConstant.MAX_BPS
    );
  }

  /// @dev Calculate global pending interest of a token
  /// @param _token The token address
  /// @param moneyMarketDs The storage of money market
  /// @return _globalPendingInterest The global pending interest of a token
  function getGlobalPendingInterest(address _token, MoneyMarketDiamondStorage storage moneyMarketDs)
    internal
    view
    returns (uint256 _globalPendingInterest)
  {
    uint256 _lastAccrualTimestamp = moneyMarketDs.debtLastAccruedAt[_token];

    // skip if interest has already been accrued within this block
    if (block.timestamp > _lastAccrualTimestamp) {
      // get a period of time since last accrual in seconds
      uint256 _secondsSinceLastAccrual;
      // safe to use unchecked
      //    because at this statement, block.timestamp is always greater than _lastAccrualTimestamp
      unchecked {
        _secondsSinceLastAccrual = block.timestamp - _lastAccrualTimestamp;
      }
      // get all non collat borrowers
      LibDoublyLinkedList.Node[] memory _borrowedAccounts = moneyMarketDs.nonCollatTokenDebtValues[_token].getAll();
      uint256 _accountLength = _borrowedAccounts.length;
      uint256 _nonCollatInterestPerSec;

      // sum up total non collat interest per second from each non collat borrower
      // calulation:
      // _nonCollatInterestPerSec += (nonCollatInterestRate * borrowedAmount)
      //
      // example:
      //  - nonCollatInterestRate   = 0.1
      //  - borrowedAmount          = 100
      //
      //  _nonCollatInterestPerSec += 0.1 * 100
      //                           += 10
      for (uint256 _i; _i < _accountLength; ) {
        _nonCollatInterestPerSec += (getNonCollatInterestRate(_borrowedAccounts[_i].token, _token, moneyMarketDs) *
          _borrowedAccounts[_i].amount);

        unchecked {
          ++_i;
        }
      }

      // calulations:
      // _globalPendingInterest = (nonCollatInterestAmountPerSec + overCollatInterestAmountPerSec) * _secondsSinceLastAccrual
      // overCollatInterestAmountPerSec = overCollatInterestRate * overCollatDebtValue
      //
      // example:
      //  - nonCollatInterestAmountPerSec   = 20
      //  - overCollatInterestAmountPerSec  = 0.1 * 50
      //  - _secondsSinceLastAccrual        = 3200
      //
      //  _globalPendingInterest            = (20 + (0.1 * 50)) * 3200
      //                                    = 25 * 3200
      //                                    = 80000
      _globalPendingInterest =
        ((_nonCollatInterestPerSec +
          (getOverCollatInterestRate(_token, moneyMarketDs) * moneyMarketDs.overCollatDebtValues[_token])) *
          _secondsSinceLastAccrual) /
        1e18;
    }
  }

  /// @dev Get over collat interest rate of a token
  /// @param _token The token address
  /// @param moneyMarketDs The storage of money market
  /// @return _interestRate The interest rate of a token
  function getOverCollatInterestRate(address _token, MoneyMarketDiamondStorage storage moneyMarketDs)
    internal
    view
    returns (uint256 _interestRate)
  {
    // get interest model of a token
    IInterestRateModel _interestModel = moneyMarketDs.interestModels[_token];
    // return 0 if interest model does not exist
    // otherwise, return interest rate from interest model
    if (address(_interestModel) == address(0)) {
      return 0;
    }
    _interestRate = _interestModel.getInterestRate(moneyMarketDs.globalDebts[_token], moneyMarketDs.reserves[_token]);
  }

  /// @dev Get non collat interest rate
  /// @param _account The account address
  /// @param _token The token address
  /// @param moneyMarketDs The storage of money market
  /// @return _interestRate The non collat interest rate
  function getNonCollatInterestRate(
    address _account,
    address _token,
    MoneyMarketDiamondStorage storage moneyMarketDs
  ) internal view returns (uint256 _interestRate) {
    // get interest model of a token in a non collat account
    IInterestRateModel _interestModel = moneyMarketDs.nonCollatInterestModels[_account][_token];
    // return 0 if interest model does not exist
    // otherwise, return interest rate from interest model
    if (address(_interestModel) == address(0)) {
      return 0;
    }
    _interestRate = _interestModel.getInterestRate(moneyMarketDs.globalDebts[_token], moneyMarketDs.reserves[_token]);
  }

  /// @dev Accrue over collat interest of a token
  /// @param _token The token address
  /// @param _timePast The time past since last accrual
  /// @param moneyMarketDs The storage of money market
  /// @return _overCollatInterest The over collat interest of a token
  function accrueOverCollatInterest(
    address _token,
    uint256 _timePast,
    MoneyMarketDiamondStorage storage moneyMarketDs
  ) internal returns (uint256 _overCollatInterest) {
    // cache to save gas
    uint256 _totalDebtValue = moneyMarketDs.overCollatDebtValues[_token];
    _overCollatInterest = (getOverCollatInterestRate(_token, moneyMarketDs) * _timePast * _totalDebtValue) / 1e18;

    // update overcollat debt
    moneyMarketDs.overCollatDebtValues[_token] = _totalDebtValue + _overCollatInterest;
  }

  /// @dev Accrue over collat and non collat interest of a token
  /// @param _token The token address
  /// @param moneyMarketDs The storage of money market
  function accrueInterest(address _token, MoneyMarketDiamondStorage storage moneyMarketDs) internal {
    uint256 _lastAccrualTimestamp = moneyMarketDs.debtLastAccruedAt[_token];
    // skip if interest has already been accrued within this block
    if (block.timestamp > _lastAccrualTimestamp) {
      // get a period of time since last accrual in seconds
      uint256 _secondsSinceLastAccrual;
      // safe to use unchecked
      //    because at this statement, block.timestamp is always greater than _lastAccrualTimestamp
      unchecked {
        _secondsSinceLastAccrual = block.timestamp - _lastAccrualTimestamp;
      }
      // accrue interest
      uint256 _overCollatInterest = accrueOverCollatInterest(_token, _secondsSinceLastAccrual, moneyMarketDs);
      uint256 _nonCollatInterest = accrueNonCollatInterest(_token, _secondsSinceLastAccrual, moneyMarketDs);

      // update global debt
      uint256 _totalInterest = _overCollatInterest + _nonCollatInterest;
      moneyMarketDs.globalDebts[_token] += _totalInterest;

      // update timestamp
      moneyMarketDs.debtLastAccruedAt[_token] = block.timestamp;

      // book protocol's revenue
      // calculation:
      // _protocolFee = (_totalInterest * lendingFeeBps) / LibConstant.MAX_BPS
      //
      // example:
      //  - _totalInterest = 1
      //  - lendingFeeBps  = 1900
      //  - LibConstant.MAX_BPS        = 10000
      //
      //  _protocolFee     = (1 * 1900) / 10000
      //                   = 0.19
      uint256 _protocolFee = (_totalInterest * moneyMarketDs.lendingFeeBps) / LibConstant.MAX_BPS;
      moneyMarketDs.protocolReserves[_token] += _protocolFee;

      emit LogAccrueInterest(_token, _totalInterest, _protocolFee);
    }
  }

  /// @dev Accrue non collat interest of a token
  /// @param _token The token address
  /// @param _timePast The time past since last accrual
  /// @param moneyMarketDs The storage of money market
  /// @return _totalNonCollatInterest The total non collat interest of a token
  function accrueNonCollatInterest(
    address _token,
    uint256 _timePast,
    MoneyMarketDiamondStorage storage moneyMarketDs
  ) internal returns (uint256 _totalNonCollatInterest) {
    // get all non collat borrowers
    LibDoublyLinkedList.Node[] memory _borrowedAccounts = moneyMarketDs.nonCollatTokenDebtValues[_token].getAll();
    uint256 _accountLength = _borrowedAccounts.length;
    address _account;
    uint256 _currentAccountDebt;
    uint256 _accountInterest;
    uint256 _newNonCollatDebtValue;

    // sum up all non collat interest of a token
    for (uint256 _i; _i < _accountLength; ) {
      _account = _borrowedAccounts[_i].token;
      _currentAccountDebt = _borrowedAccounts[_i].amount;

      // calculate interest
      // calculation:
      // _accountInterest = nonCollatInterestRate * _timePast * _currentAccountDebt
      //
      // example:
      //  - nonCollatInterestRate = 0.1
      //  - _timePast             = 3200
      //  - _currentAccountDebt   = 100
      //
      //  _accountInterest        = 0.1 * 3200 * 100
      //                          = 32000
      _accountInterest =
        (getNonCollatInterestRate(_account, _token, moneyMarketDs) * _timePast * _currentAccountDebt) /
        1e18;

      // update non collat debt states
      _newNonCollatDebtValue = _currentAccountDebt + _accountInterest;
      // 1. account debt
      moneyMarketDs.nonCollatAccountDebtValues[_account].addOrUpdate(_token, _newNonCollatDebtValue);
      // 2. token debt
      moneyMarketDs.nonCollatTokenDebtValues[_token].addOrUpdate(_account, _newNonCollatDebtValue);

      // accumulate total non collat interest
      _totalNonCollatInterest += _accountInterest;
      unchecked {
        ++_i;
      }
    }
  }

  /// @dev Accrue interest of all borrowed positions of a sub account
  /// @param _subAccount The sub account address
  /// @param moneyMarketDs The storage of money market
  function accrueBorrowedPositionsOf(address _subAccount, MoneyMarketDiamondStorage storage moneyMarketDs) internal {
    // get all borrowed positions of a sub account
    LibDoublyLinkedList.Node[] memory _borrowed = moneyMarketDs.subAccountDebtShares[_subAccount].getAll();

    uint256 _borrowedLength = _borrowed.length;

    // accrue interest of all borrowed positions
    for (uint256 _i; _i < _borrowedLength; ) {
      accrueInterest(_borrowed[_i].token, moneyMarketDs);
      unchecked {
        ++_i;
      }
    }
  }

  /// @dev Accrue interest of all non collat borrowed positions of a non collat borrower
  /// @param _account The non collat borrower address
  /// @param moneyMarketDs The storage of money market
  function accrueNonCollatBorrowedPositionsOf(address _account, MoneyMarketDiamondStorage storage moneyMarketDs)
    internal
  {
    // get all borrowed positions of a non collat borrower
    LibDoublyLinkedList.Node[] memory _borrowed = moneyMarketDs.nonCollatAccountDebtValues[_account].getAll();

    uint256 _borrowedLength = _borrowed.length;

    // accrue interest of all borrowed positions
    for (uint256 _i; _i < _borrowedLength; ) {
      accrueInterest(_borrowed[_i].token, moneyMarketDs);
      unchecked {
        ++_i;
      }
    }
  }

  /// @dev Get total amount of a token in money market
  /// @param _token The token address
  /// @param moneyMarketDs The storage of money market
  /// @return The total amount of a token in money market
  function getTotalToken(address _token, MoneyMarketDiamondStorage storage moneyMarketDs)
    internal
    view
    returns (uint256)
  {
    // calculation:
    // totalToken   = amount of token remains in money market + debt - protocol reserve
    // debt         = over collat debt + non collat debt
    //
    // example:
    //  - amount of token remains in money markey = 100
    //  - over collat debt                        = 200
    //  - non collat debt                         = 300
    //  - protocol reserve                        = 50
    //
    //  totalToken                                = 100 + (200 + 300) - 50
    //                                            = 100 + (500) - 50
    //                                            = 550
    return
      (moneyMarketDs.reserves[_token] + moneyMarketDs.globalDebts[_token]) - (moneyMarketDs.protocolReserves[_token]);
  }

  /// @dev Get total amount of a token in money market with pending interest
  /// @param _token The token address
  /// @param moneyMarketDs The storage of money market
  /// @return The total amount of a token in money market with pending interest
  function getTotalTokenWithPendingInterest(address _token, MoneyMarketDiamondStorage storage moneyMarketDs)
    internal
    view
    returns (uint256)
  {
    // calculation:
    // totalTokenWithPendingInterest = totalToken + ((pendingInterest * (LibConstant.MAX_BPS - lendingFeeBps)) / LibConstant.MAX_BPS)
    //
    // example:
    //  - totalToken                  = 550
    //  - pendingInterest             = 100
    //  - lendingFeeBps               = 1900
    //  - LibConstant.MAX_BPS                     = 10000
    //
    //  totalTokenWithPendingInterest = 550 + ((100 * (10000 - 1900)) / 10000)
    //                                = 550 + ((100 * 8100) / 10000)
    //                                = 550 + (810000 / 10000)
    //                                = 550 + 81
    //                                = 631
    return
      getTotalToken(_token, moneyMarketDs) +
      ((getGlobalPendingInterest(_token, moneyMarketDs) * (LibConstant.MAX_BPS - moneyMarketDs.lendingFeeBps)) /
        LibConstant.MAX_BPS);
  }

  /// @dev Get price of a token in USD
  /// @param _token The token address
  /// @param moneyMarketDs The storage of money market
  /// @return _price The price of a token in USD
  function getPriceUSD(address _token, MoneyMarketDiamondStorage storage moneyMarketDs)
    internal
    view
    returns (uint256 _price)
  {
    address _underlyingToken = moneyMarketDs.ibTokenToTokens[_token];
    // If the token is ibToken, do an additional shareToValue before pricing
    // otherwise, just get the price from oracle
    if (_underlyingToken != address(0)) {
      uint256 _underlyingTokenPrice;
      (_underlyingTokenPrice, ) = moneyMarketDs.oracle.getTokenPrice(_underlyingToken);
      // TODO: optimize this
      uint256 _totalSupply = IERC20(_token).totalSupply();
      uint256 _totalToken = getTotalTokenWithPendingInterest(_underlyingToken, moneyMarketDs);

      _price = LibShareUtil.shareToValue(_underlyingTokenPrice, _totalToken, _totalSupply);
    } else {
      (_price, ) = moneyMarketDs.oracle.getTokenPrice(_token);
    }
  }

  /// @dev Get to18ConversionFactor of a token
  /// @param _token The token address
  /// @return The to18ConversionFactor of a token
  function to18ConversionFactor(address _token) internal view returns (uint64) {
    // get decimals of a token
    uint256 _decimals = IERC20(_token).decimals();
    // revert if decimals > 18
    if (_decimals > 18) {
      revert LibMoneyMarket01_UnsupportedDecimals();
    }
    // in case the decimal is in 18 digits, the factor is 1
    // and can skip the below calculation
    if (_decimals == 18) {
      return 1;
    }
    // calculate conversion factor
    // calculation:
    // conversionFactor = 10^(18 - decimals)
    //
    // example:
    //  - decimals        = 6
    //
    //  conversionFactor  = 10^(18 - 6)
    //                    = 10^(12)
    //                    = 1e12
    uint256 _conversionFactor = 10**(18 - _decimals);
    return uint64(_conversionFactor);
  }

  /// @dev Add collat to sub account
  /// @param _account The account address
  /// @param _subAccount The sub account address
  /// @param _token The token address
  /// @param _addAmount The amount to add
  /// @param moneyMarketDs The storage of money market
  function addCollatToSubAccount(
    address _account,
    address _subAccount,
    address _token,
    uint256 _addAmount,
    bool _skipMiniFL,
    MoneyMarketDiamondStorage storage moneyMarketDs
  ) internal {
    // validation
    //  1. revert if token is not collateral
    if (moneyMarketDs.tokenConfigs[_token].tier != LibConstant.AssetTier.COLLATERAL) {
      revert LibMoneyMarket01_InvalidAssetTier();
    }
    //  2. revert if _addAmount + currentCollatAmount exceed max collateral amount of a token
    if (_addAmount + moneyMarketDs.collats[_token] > moneyMarketDs.tokenConfigs[_token].maxCollateral) {
      revert LibMoneyMarket01_ExceedCollateralLimit();
    }

    // init list
    LibDoublyLinkedList.List storage subAccountCollateralList = moneyMarketDs.subAccountCollats[_subAccount];
    subAccountCollateralList.initIfNotExist();

    // TODO: optimize this
    uint256 _currentCollatAmount = subAccountCollateralList.getAmount(_token);
    // update states
    //  1. update sub account collateral amount
    subAccountCollateralList.addOrUpdate(_token, _currentCollatAmount + _addAmount);
    // revert if number of collateral tokens exceed limit per sub account
    if (subAccountCollateralList.length() > moneyMarketDs.maxNumOfCollatPerSubAccount) {
      revert LibMoneyMarket01_NumberOfTokenExceedLimit();
    }
    //  2. update total collateral amount of a token in money market
    moneyMarketDs.collats[_token] += _addAmount;

    // if called by transferCollateral, does not need to deposit to miniFL
    // as during removeCollateral in transfer, token wasn't withdrawn from miniFL
    if (!_skipMiniFL) {
      // stake token to miniFL, when user add collateral by ibToken
      uint256 _poolId = moneyMarketDs.miniFLPoolIds[_token];

      // If the collateral token has no miniFL's poolID associated with it
      // skip the deposit to miniFL process
      // This generally applies to non-ibToken collateral
      if (_poolId != 0) {
        IMiniFL _miniFL = moneyMarketDs.miniFL;
        IERC20(_token).safeApprove(address(_miniFL), _addAmount);
        _miniFL.deposit(_account, _poolId, _addAmount);
      }
    }

    emit LogAddCollateral(_account, _subAccount, _token, msg.sender, _addAmount);
  }

  /// @dev Remove collat from sub account
  /// @param _account The account address
  /// @param _subAccount The sub account address
  /// @param _token The token address
  /// @param _removeAmount The amount to remove
  /// @param moneyMarketDs The storage of money market
  function removeCollatFromSubAccount(
    address _account,
    address _subAccount,
    address _token,
    uint256 _removeAmount,
    bool _skipMiniFl,
    MoneyMarketDiamondStorage storage moneyMarketDs
  ) internal {
    // get current collateral amount of a token
    LibDoublyLinkedList.List storage _subAccountCollatList = moneyMarketDs.subAccountCollats[_subAccount];
    uint256 _currentCollatAmount = _subAccountCollatList.getAmount(_token);

    // revert if insufficient collateral amount to remove
    if (_removeAmount > _currentCollatAmount) {
      revert LibMoneyMarket01_TooManyCollateralRemoved();
    }
    // update states
    //  1. update sub account collateral amount
    _subAccountCollatList.updateOrRemove(_token, _currentCollatAmount - _removeAmount);
    //  2. update total collateral amount of a token in money market
    moneyMarketDs.collats[_token] -= _removeAmount;

    // if called by transferCollateral, does not need to withdraw from miniFL
    if (!_skipMiniFl) {
      // In the subsequent call, money market should get hold of physical token to proceed
      // Thus, we need to withdraw the physical token from miniFL first
      uint256 _poolId = moneyMarketDs.miniFLPoolIds[_token];

      // If the collateral token has no miniFL's poolID associated with it
      // skip the withdrawal from miniFL process
      // This generally applies to non-ibToken collateral
      if (_poolId != 0) {
        moneyMarketDs.miniFL.withdraw(_account, _poolId, _removeAmount);
      }
    }

    emit LogRemoveCollateral(_account, _subAccount, _token, _removeAmount);
  }

  /// @dev Validate if sub account is healthy
  /// @param _subAccount The sub account address
  /// @param moneyMarketDs The storage of money market
  function validateSubaccountIsHealthy(address _subAccount, MoneyMarketDiamondStorage storage moneyMarketDs)
    internal
    view
  {
    uint256 _totalBorrowingPower = getTotalBorrowingPower(_subAccount, moneyMarketDs);
    (uint256 _totalUsedBorrowingPower, ) = getTotalUsedBorrowingPower(_subAccount, moneyMarketDs);
    // revert if total borrowing power is less than total used borrowing power
    // in case of price change, this can happen
    if (_totalBorrowingPower < _totalUsedBorrowingPower) {
      revert LibMoneyMarket01_BorrowingPowerTooLow();
    }
  }

  /// @dev Remove over collat debt from sub account
  /// @param _account The account address
  /// @param _subAccount The sub account address
  /// @param _repayToken The token address
  /// @param _debtShareToRemove The debt share to remove
  /// @param _debtValueToRemove The debt value to remove
  /// @param moneyMarketDs The storage of money market
  function removeOverCollatDebtFromSubAccount(
    address _account,
    address _subAccount,
    address _repayToken,
    uint256 _debtShareToRemove,
    uint256 _debtValueToRemove,
    LibMoneyMarket01.MoneyMarketDiamondStorage storage moneyMarketDs
  ) internal {
    LibDoublyLinkedList.List storage userDebtShare = moneyMarketDs.subAccountDebtShares[_subAccount];
    // get current debt share of a token
    uint256 _currentDebtShare = userDebtShare.getAmount(_repayToken);

    // update states
    //  1. update sub account debt share
    userDebtShare.updateOrRemove(_repayToken, _currentDebtShare - _debtShareToRemove);
    //  2. update total over collat debt share of a token in money market
    moneyMarketDs.overCollatDebtShares[_repayToken] -= _debtShareToRemove;
    //  3. update total over collat debt value of a token in money market
    moneyMarketDs.overCollatDebtValues[_repayToken] -= _debtValueToRemove;
    //  4. update total debt value of a token in money market
    moneyMarketDs.globalDebts[_repayToken] -= _debtValueToRemove;

    // withdraw debt token from miniFL
    IMiniFL _miniFL = moneyMarketDs.miniFL;
    address _debtToken = moneyMarketDs.tokenToDebtTokens[_repayToken];
    _miniFL.withdraw(_account, moneyMarketDs.miniFLPoolIds[_debtToken], _debtShareToRemove);

    // burn debt token
    IDebtToken(_debtToken).burn(address(this), _debtShareToRemove);

    emit LogRemoveDebt(
      _account,
      _subAccount,
      _repayToken,
      _debtShareToRemove,
      _debtValueToRemove,
      userDebtShare.length()
    );
  }

  /// @dev Transfer collat from one sub account to another
  /// @param _toSubAccount The sub account address to transfer to
  /// @param _token The token address
  /// @param _transferAmount The amount to transfer
  /// @param moneyMarketDs The storage of money market
  function transferCollat(
    address _toSubAccount,
    address _token,
    uint256 _transferAmount,
    MoneyMarketDiamondStorage storage moneyMarketDs
  ) internal {
    // init list
    LibDoublyLinkedList.List storage toSubAccountCollateralList = moneyMarketDs.subAccountCollats[_toSubAccount];
    toSubAccountCollateralList.initIfNotExist();

    uint256 _currentCollatAmount = toSubAccountCollateralList.getAmount(_token);
    // update toSubAccount collateral amount
    toSubAccountCollateralList.addOrUpdate(_token, _currentCollatAmount + _transferAmount);
    // revert if number of collateral tokens exceed limit per sub account
    if (toSubAccountCollateralList.length() > moneyMarketDs.maxNumOfCollatPerSubAccount) {
      revert LibMoneyMarket01_NumberOfTokenExceedLimit();
    }
  }

  /// @dev Get over collat debt share and amount
  /// @param _subAccount The sub account address
  /// @param _token The token address
  /// @param moneyMarketDs The storage of money market
  /// @return _debtShare The debt share
  /// @return _debtAmount The debt amount
  function getOverCollatDebtShareAndAmountOf(
    address _subAccount,
    address _token,
    LibMoneyMarket01.MoneyMarketDiamondStorage storage moneyMarketDs
  ) internal view returns (uint256 _debtShare, uint256 _debtAmount) {
    _debtShare = moneyMarketDs.subAccountDebtShares[_subAccount].getAmount(_token);

    // Note: precision loss 1 wei when convert share back to value
    _debtAmount = LibShareUtil.shareToValue(
      _debtShare,
      moneyMarketDs.overCollatDebtValues[_token],
      moneyMarketDs.overCollatDebtShares[_token]
    );
  }

  /// @dev Get non collat debt amount
  /// @param _account The non collat borrower address
  /// @param _token The token address
  /// @param moneyMarketDs The storage of money market
  /// @return _debtAmount The debt amount
  function getNonCollatDebt(
    address _account,
    address _token,
    LibMoneyMarket01.MoneyMarketDiamondStorage storage moneyMarketDs
  ) internal view returns (uint256 _debtAmount) {
    _debtAmount = moneyMarketDs.nonCollatAccountDebtValues[_account].getAmount(_token);
  }

  /// @dev Do over collat borrow
  /// @param _account The account address
  /// @param _subAccount The sub account address
  /// @param _token The token address
  /// @param _amount The amount to borrow
  /// @param moneyMarketDs The storage of money market
  /// @return _shareToAdd The share value to add
  function overCollatBorrow(
    address _account,
    address _subAccount,
    address _token,
    uint256 _amount,
    MoneyMarketDiamondStorage storage moneyMarketDs
  ) internal returns (uint256 _shareToAdd) {
    LibDoublyLinkedList.List storage userDebtShare = moneyMarketDs.subAccountDebtShares[_subAccount];
    IMiniFL _miniFL = moneyMarketDs.miniFL;

    userDebtShare.initIfNotExist();

    // get share value to update states
    _shareToAdd = LibShareUtil.valueToShareRoundingUp(
      _amount,
      moneyMarketDs.overCollatDebtShares[_token],
      moneyMarketDs.overCollatDebtValues[_token]
    );

    // update over collat debt
    moneyMarketDs.overCollatDebtShares[_token] += _shareToAdd;
    moneyMarketDs.overCollatDebtValues[_token] += _amount;

    // update global debt
    moneyMarketDs.globalDebts[_token] += _amount;

    // update user's debtshare
    userDebtShare.addOrUpdate(_token, userDebtShare.getAmount(_token) + _shareToAdd);
    // revert if number of debt tokens exceed limit per sub account
    uint256 _userDebtShareLen = userDebtShare.length();
    if (_userDebtShareLen > moneyMarketDs.maxNumOfDebtPerSubAccount) {
      revert LibMoneyMarket01_NumberOfTokenExceedLimit();
    }

    // mint debt token to money market and stake to miniFL
    address _debtToken = moneyMarketDs.tokenToDebtTokens[_token];

    // pool for debt token always exist
    // since pool is created during AdminFacet.openMarket()
    IDebtToken(_debtToken).mint(address(this), _shareToAdd);
    IERC20(_debtToken).safeApprove(address(_miniFL), _shareToAdd);
    _miniFL.deposit(_account, moneyMarketDs.miniFLPoolIds[_debtToken], _shareToAdd);

    emit LogOverCollatBorrow(_account, _subAccount, _token, _amount, _shareToAdd, _userDebtShareLen);
  }

  /// @dev Do non collat borrow
  /// @param _account The non collat borrower address
  /// @param _token The token address
  /// @param _amount The amount to borrow
  /// @param moneyMarketDs The storage of money market
  function nonCollatBorrow(
    address _account,
    address _token,
    uint256 _amount,
    MoneyMarketDiamondStorage storage moneyMarketDs
  ) internal {
    // init lists
    //  1. debtValue
    LibDoublyLinkedList.List storage debtValue = moneyMarketDs.nonCollatAccountDebtValues[_account];
    debtValue.initIfNotExist();

    //  2. tokenDebts
    LibDoublyLinkedList.List storage tokenDebts = moneyMarketDs.nonCollatTokenDebtValues[_token];
    tokenDebts.initIfNotExist();

    // update account debt
    uint256 _newAccountDebt = debtValue.getAmount(_token) + _amount;
    uint256 _newTokenDebt = tokenDebts.getAmount(msg.sender) + _amount;

    debtValue.addOrUpdate(_token, _newAccountDebt);

    // revert if number of debt value exceed limit per non collat account
    if (debtValue.length() > moneyMarketDs.maxNumOfDebtPerNonCollatAccount) {
      revert LibMoneyMarket01_NumberOfTokenExceedLimit();
    }

    tokenDebts.addOrUpdate(msg.sender, _newTokenDebt);

    // update global debt
    moneyMarketDs.globalDebts[_token] += _amount;
  }

  /// @dev SafeTransferFrom that revert when not receiving full amount (have fee on transfer)
  /// @param _token The token address
  /// @param _from The address to pull token from
  /// @param _amount The amount to pull
  function pullExactTokens(
    address _token,
    address _from,
    uint256 _amount
  ) internal {
    // get the token balance of money market before transfer
    uint256 _balanceBefore = IERC20(_token).balanceOf(address(this));
    // transfer token from _from to money market
    IERC20(_token).safeTransferFrom(_from, address(this), _amount);
    // check if the token balance of money market is increased by _amount
    // if fee on transer tokens is not supported this will revert
    if (IERC20(_token).balanceOf(address(this)) - _balanceBefore != _amount) {
      revert LibMoneyMarket01_FeeOnTransferTokensNotSupported();
    }
  }

  /// @dev SafeTransferFrom that return actual amount received
  /// @param _token The token address
  /// @param _from The address to pull token from
  /// @param _amount The amount to pull
  /// @return _actualAmountReceived The actual amount received
  function unsafePullTokens(
    address _token,
    address _from,
    uint256 _amount
  ) internal returns (uint256 _actualAmountReceived) {
    // get the token balance of money market before transfer
    uint256 _balanceBefore = IERC20(_token).balanceOf(address(this));
    // transfer token from _from to money market
    IERC20(_token).safeTransferFrom(_from, address(this), _amount);
    // return actual amount received = balance after transfer - balance before transfer
    _actualAmountReceived = IERC20(_token).balanceOf(address(this)) - _balanceBefore;
  }

  /// @dev Check if the money market is live, revert when not live
  /// @param moneyMarketDs The storage of money market
  function onlyLive(MoneyMarketDiamondStorage storage moneyMarketDs) internal view {
    if (moneyMarketDs.emergencyPaused) {
      revert LibMoneyMarket01_EmergencyPaused();
    }
  }

  /// @dev Check if caller is account manager, revert when not account manager
  /// @param moneyMarketDs The storage of money market
  function onlyAccountManager(MoneyMarketDiamondStorage storage moneyMarketDs) internal view {
    if (!moneyMarketDs.accountManagersOk[msg.sender]) {
      revert LibMoneyMarket01_UnAuthorized();
    }
  }

  /// @dev Write off the subaccount's debt that has no collateral backed
  /// WARNING: Only called this when all interests have been accrued
  /// @param _subAccount The subAccount to be written off
  /// @param moneyMarketDs The storage of money market
  function writeOffBadDebt(
    address _account,
    address _subAccount,
    MoneyMarketDiamondStorage storage moneyMarketDs
  ) internal {
    // skip this if there're still collaterals under the subAccount
    if (moneyMarketDs.subAccountCollats[_subAccount].size != 0) {
      return;
    }

    LibDoublyLinkedList.Node[] memory _borrowed = moneyMarketDs.subAccountDebtShares[_subAccount].getAll();

    address _token;
    uint256 _shareToRemove;
    uint256 _amountToRemove;
    uint256 _length = _borrowed.length;

    // loop over all outstanding debt
    for (uint256 _i; _i < _length; ) {
      _token = _borrowed[_i].token;
      _shareToRemove = _borrowed[_i].amount;

      // Price in the actual amount to be written off
      _amountToRemove = LibShareUtil.shareToValue(
        _shareToRemove,
        moneyMarketDs.overCollatDebtValues[_token],
        moneyMarketDs.overCollatDebtShares[_token]
      );

      // Reset debts of the token under subAccount
      removeOverCollatDebtFromSubAccount(_account, _subAccount, _token, _shareToRemove, _amountToRemove, moneyMarketDs);

      emit LogWriteOffSubAccountDebt(_subAccount, _token, _shareToRemove, _amountToRemove);

      unchecked {
        ++_i;
      }
    }
  }
}


// File: solidity/contracts/money-market/libraries/LibSafeToken.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import { IERC20 } from "../interfaces/IERC20.sol";

library LibSafeToken {
  function safeTransfer(
    IERC20 _token,
    address to,
    uint256 value
  ) internal {
    require(isContract(_token), "!contract");
    (bool success, bytes memory data) = address(_token).call(
      abi.encodeWithSelector(_token.transfer.selector, to, value)
    );
    require(success && (data.length == 0 || abi.decode(data, (bool))), "!safeTransfer");
  }

  function safeTransferFrom(
    IERC20 _token,
    address from,
    address to,
    uint256 value
  ) internal {
    require(isContract(_token), "!not contract");
    (bool success, bytes memory data) = address(_token).call(
      abi.encodeWithSelector(_token.transferFrom.selector, from, to, value)
    );
    require(success && (data.length == 0 || abi.decode(data, (bool))), "!safeTransferFrom");
  }

  function safeApprove(
    IERC20 _token,
    address to,
    uint256 value
  ) internal {
    require(isContract(_token), "!not contract");
    (bool success, bytes memory data) = address(_token).call(
      abi.encodeWithSelector(_token.approve.selector, to, value)
    );
    require(success && (data.length == 0 || abi.decode(data, (bool))), "!safeApprove");
  }

  function safeIncreaseAllowance(
    IERC20 _token,
    address _spender,
    uint256 _addValue
  ) internal {
    require(isContract(_token), "!not contract");
    uint256 currentAllowance = _token.allowance(msg.sender, _spender);
    (bool success, bytes memory data) = address(_token).call(
      abi.encodeWithSelector(_token.approve.selector, _spender, currentAllowance + _addValue)
    );
    require(success && (data.length == 0 || abi.decode(data, (bool))), "!safeIncreaseAllowance");
  }

  function safeDecreaseAllowance(
    IERC20 _token,
    address _spender,
    uint256 _substractValue
  ) internal {
    unchecked {
      require(isContract(_token), "!not contract");
      uint256 currentAllowance = _token.allowance(address(this), _spender);
      require(currentAllowance >= _substractValue, "LibSafeToken: decreased allowance below zero");
      (bool success, bytes memory data) = address(_token).call(
        abi.encodeWithSelector(_token.approve.selector, _spender, currentAllowance - _substractValue)
      );
      require(success && (data.length == 0 || abi.decode(data, (bool))), "!safeDecreaseAllowance");
    }
  }

  function safeTransferETH(address to, uint256 value) internal {
    // solhint-disable-next-line no-call-value
    (bool success, ) = to.call{ value: value }(new bytes(0));
    require(success, "!safeTransferETH");
  }

  function isContract(IERC20 account) internal view returns (bool) {
    // This method relies on extcodesize, which returns 0 for contracts in
    // construction, since the code is only stored at the end of the
    // constructor execution.

    uint256 size;
    // solhint-disable-next-line no-inline-assembly
    assembly {
      size := extcodesize(account)
    }
    return size > 0;
  }
}


// File: solidity/contracts/money-market/libraries/LibShareUtil.sol
// SPDX-License-Identifier: BUSL
pragma solidity 0.8.19;

import { LibFullMath } from "./LibFullMath.sol";

library LibShareUtil {
  function shareToValue(
    uint256 _shareAmount,
    uint256 _totalValue,
    uint256 _totalShare
  ) internal pure returns (uint256) {
    if (_totalShare == 0) {
      return _shareAmount;
    }
    return LibFullMath.mulDiv(_shareAmount, _totalValue, _totalShare);
  }

  function valueToShare(
    uint256 _tokenAmount,
    uint256 _totalShare,
    uint256 _totalValue
  ) internal pure returns (uint256) {
    if (_totalShare == 0) {
      return _tokenAmount;
    }
    return LibFullMath.mulDiv(_tokenAmount, _totalShare, _totalValue);
  }

  function valueToShareRoundingUp(
    uint256 _tokenAmount,
    uint256 _totalShare,
    uint256 _totalValue
  ) internal pure returns (uint256) {
    uint256 _shares = valueToShare(_tokenAmount, _totalShare, _totalValue);
    uint256 _shareValues = shareToValue(_shares, _totalValue, _totalShare);
    if (_shareValues + 1 == _tokenAmount) {
      _shares += 1;
    }
    return _shares;
  }

  function shareToValueRoundingUp(
    uint256 _shareAmount,
    uint256 _totalValue,
    uint256 _totalShare
  ) internal pure returns (uint256) {
    uint256 _values = shareToValue(_shareAmount, _totalValue, _totalShare);
    uint256 _valueShares = valueToShare(_values, _totalShare, _totalValue);
    if (_valueShares + 1 == _shareAmount) {
      _values += 1;
    }
    return _values;
  }
}

