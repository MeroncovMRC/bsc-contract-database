{"BitMaps.sol":{"content":"pragma solidity 0.6.12;\n\nlibrary BitMaps {\n    struct BitMap {\n        mapping(uint256 =\u003e uint256) _data;\n    }\n\n    function get(BitMap storage bitmap, uint256 index) internal view returns (bool) {\n        uint256 bucket = index \u003e\u003e 8;\n        uint256 mask = 1 \u003c\u003c (index \u0026 0xff);\n        return bitmap._data[bucket] \u0026 mask != 0;\n    }\n\n    function setTo(BitMap storage bitmap, uint256 index, bool value) internal {\n        if (value) {\n            set(bitmap, index);\n        } else {\n            unset(bitmap, index);\n        }\n    }\n\n    function set(BitMap storage bitmap, uint256 index) internal {\n        uint256 bucket = index \u003e\u003e 8;\n        uint256 mask = 1 \u003c\u003c (index \u0026 0xff);\n        bitmap._data[bucket] |= mask;\n    }\n\n    function unset(BitMap storage bitmap, uint256 index) internal {\n        uint256 bucket = index \u003e\u003e 8;\n        uint256 mask = 1 \u003c\u003c (index \u0026 0xff);\n        bitmap._data[bucket] \u0026= ~mask;\n    }\n}"},"ERC721Enumerable onERC721Received.sol":{"content":"pragma solidity 0.6.12;\r\n\r\nimport \u0027./BitMaps.sol\u0027;\r\n\r\ninterface IERC721Receiver {\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\r\n}\r\n\r\ninterface IERC721 {\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    function approve(address to, uint256 tokenId) external;\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n}\r\n\r\ncontract Ownable {\r\n    mapping (address =\u003e bool) private ownerShips;\r\n\r\n    constructor () public{\r\n        ownerShips[msg.sender] = true;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(ownerShips[msg.sender], \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function addOwnership(address newOwner) public onlyOwner {\r\n        ownerShips[newOwner] = true;\r\n    }\r\n\r\n    function removeOwnership(address oldOwner) public onlyOwner {\r\n        ownerShips[oldOwner] = false;\r\n    }\r\n}\r\n\r\nlibrary Math {\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a \u003c b ? a : b;\r\n    }\r\n}\r\n\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp \u003e\u003e= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i \u003e 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value \u0026 0xf];\r\n            value \u003e\u003e= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\ncontract ERC721 is IERC721, Ownable {\r\n    using Strings for uint256;\r\n\r\n    mapping (uint256 =\u003e address) private _owners;\r\n\r\n    mapping (address =\u003e uint256) private _balances;\r\n\r\n    mapping (uint256 =\u003e address) private _tokenApprovals;\r\n\r\n    mapping (address =\u003e mapping (address =\u003e bool)) private _operatorApprovals;\r\n\r\n    mapping(address =\u003e mapping(uint256 =\u003e uint256)) private _ownedTokens;\r\n\r\n    mapping(uint256 =\u003e uint256) private _ownedTokensIndex;\r\n\r\n    uint256[] private _allTokens;\r\n\r\n    mapping(uint256 =\u003e uint256) private _allTokensIndex;\r\n\r\n    uint256 public burnAmount = 0;\r\n    string public baseTokenURI;\r\n\r\n    using BitMaps for BitMaps.BitMap;\r\n    BitMaps.BitMap private _isMinted;\r\n\r\n    event BaseURIChanged(string baseURI);\r\n\r\n    function name() public pure returns (string memory) {\r\n        return \"NFT\";\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return \"legend\";\r\n    }\r\n\r\n    function tokenURI(uint256 tokenId) public view returns (string memory) {\r\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\r\n        string memory baseURI = baseTokenURI;\r\n        return bytes(baseURI).length \u003e 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\r\n    }\r\n\r\n    function balanceOf(address owner) public view override returns (uint256) {\r\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\r\n        return _balances[owner];\r\n    }\r\n\r\n    function ownerOf(uint256 tokenId) public view override returns (address) {\r\n        address owner = _owners[tokenId];\r\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\r\n        return owner;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return 0;\r\n    }\r\n\r\n    function approve(address to, uint256 tokenId) public override {\r\n        address owner = ownerOf(tokenId);\r\n        require(to != owner, \"ERC721: approval to current owner\");\r\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), \"ERC721: approve caller is not owner nor approved for all\");\r\n        _approve(to, tokenId);\r\n    }\r\n\r\n    function getApproved(uint256 tokenId) public view override returns (address) {\r\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    function setApprovalForAll(address operator, bool approved) public override {\r\n        require(operator != msg.sender, \"ERC721: approve to caller\");\r\n        _operatorApprovals[msg.sender][operator] = approved;\r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    function isApprovedForAll(address owner, address operator) public view override returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public override {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public override {\r\n        transferFrom(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 tokenId) public override {\r\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n        _transfer(from, to, tokenId);\r\n    }\r\n\r\n    function transfer(address to, uint256 tokenId) public {\r\n        transferFrom(msg.sender, to, tokenId);\r\n    }\r\n\r\n    function _transfer(address from, address to, uint256 tokenId) private {\r\n        require(ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\r\n        require(to != address(0), \"ERC721: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, tokenId);\r\n        // Clear approvals from the previous owner\r\n        _approve(address(0), tokenId);\r\n\r\n        _balances[from] -= 1;\r\n        _balances[to] += 1;\r\n        _owners[tokenId] = to;\r\n\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n    function _approve(address to, uint256 tokenId) private {\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(ownerOf(tokenId), to, tokenId);\r\n    }\r\n\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) private view returns (bool) {\r\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\r\n        address owner = ownerOf(tokenId);\r\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n    }\r\n\r\n    function _exists(uint256 tokenId) private view returns (bool) {\r\n        return _owners[tokenId] != address(0);\r\n    }\r\n\r\n    function isMinted(uint256 tokenId) public view returns (bool) {\r\n        return _isMinted.get(tokenId);\r\n    }\r\n\r\n    function setBaseURI(string memory baseURI) external onlyOwner {\r\n        baseTokenURI = baseURI;\r\n        emit BaseURIChanged(baseURI);\r\n    }\r\n\r\n    function mint(address to, uint256 startid, uint256 num) public onlyOwner {\r\n        for (uint256 i = 0; i \u003c num; i++) {\r\n            _mint(to, startid+i);\r\n        }\r\n    }\r\n\r\n    function mint(address to, uint256 tokenId) public onlyOwner {\r\n        _mint(to, tokenId);\r\n    }\r\n\r\n    function _mint(address to, uint256 tokenId) private {\r\n        require(!isMinted(tokenId), \"tokenId already minted\");\r\n        _isMinted.set(tokenId);\r\n        _beforeTokenTransfer(address(0), to, tokenId);\r\n        _balances[to] += 1;\r\n        _owners[tokenId] = to;\r\n        emit Transfer(address(0), to, tokenId);\r\n    }\r\n\r\n    function burn(uint256 tokenId) public {\r\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"ERC721Burnable: caller is not owner nor approved\");\r\n        _burn(tokenId);\r\n    }\r\n\r\n    function _burn(uint256 tokenId) internal {\r\n        address owner = _owners[tokenId];\r\n\r\n        _beforeTokenTransfer(owner, address(0), tokenId);\r\n        // Clear approvals\r\n        _approve(address(0), tokenId);\r\n\r\n        _balances[owner] -= 1;\r\n        delete _owners[tokenId];\r\n        burnAmount++;\r\n\r\n        emit Transfer(owner, address(0), tokenId);\r\n    }\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly { size := extcodesize(account) }\r\n        return size \u003e 0;\r\n    }\r\n\r\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) private returns (bool) {\r\n        if (!isContract(to)) {\r\n            return true;\r\n        }\r\n\r\n        try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data) returns (bytes4 retval) {\r\n            return retval == IERC721Receiver(to).onERC721Received.selector;\r\n        } catch (bytes memory reason) {\r\n            if (reason.length == 0) {\r\n                revert(\"ERC721: transfer to non ERC721Receiver implementer\");\r\n            } else {\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    revert(add(32, reason), mload(reason))\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function tokenOfOwner(address owner, uint256 pageNum, uint256 pageSize) external view returns (uint256[] memory tokens, uint256 total) {\r\n        total = balanceOf(owner);\r\n        uint256 from = pageNum*pageSize;\r\n        if (total \u003c= from) {\r\n            return (new uint256[](0), total);\r\n        }\r\n\r\n        uint256 minNum = Math.min(total - from, pageSize);\r\n        tokens = new uint256[](minNum);\r\n        \r\n        for(uint256 i = 0; i \u003c minNum; i++){\r\n            tokens[i] = _ownedTokens[owner][from++];\r\n        }\r\n    }\r\n\r\n    function tokenOfAll(uint256 pageNum, uint256 pageSize) external view returns (uint256[] memory tokens, address[] memory owners, uint256 total) {\r\n        total = totalSupply();\r\n        uint256 from = pageNum*pageSize;\r\n        if (total \u003c= from) {\r\n            return (new uint256[](0), new address[](0), total);\r\n        }\r\n\r\n        uint256 minNum = Math.min(total - from, pageSize);\r\n        tokens = new uint256[](minNum);\r\n        owners = new address[](minNum);\r\n\r\n        uint256 tokenId;\r\n        \r\n        for(uint256 i = 0; i \u003c minNum; i++){\r\n            tokenId = _allTokens[from++];\r\n            tokens[i] = tokenId;\r\n            owners[i] = _owners[tokenId];\r\n        }\r\n    }\r\n\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\r\n        require(index \u003c balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\r\n        return _ownedTokens[owner][index];\r\n    }\r\n\r\n    function tokenByIndex(uint256 index) public view returns (uint256) {\r\n        require(index \u003c totalSupply(), \"ERC721Enumerable: global index out of bounds\");\r\n        return _allTokens[index];\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return _allTokens.length;\r\n    }\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal {\r\n        if (from == address(0)) {\r\n            _addTokenToAllTokensEnumeration(tokenId);\r\n        } else if (from != to) {\r\n            _removeTokenFromOwnerEnumeration(from, tokenId);\r\n        }\r\n        if (to == address(0)) {\r\n            _removeTokenFromAllTokensEnumeration(tokenId);\r\n        } else if (to != from) {\r\n            _addTokenToOwnerEnumeration(to, tokenId);\r\n        }\r\n    }\r\n\r\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\r\n        _allTokensIndex[tokenId] = _allTokens.length;\r\n        _allTokens.push(tokenId);\r\n    }\r\n\r\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\r\n        uint256 length = balanceOf(to);\r\n        _ownedTokens[to][length] = tokenId;\r\n        _ownedTokensIndex[tokenId] = length;\r\n    }\r\n\r\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\r\n        \r\n        uint256 lastTokenIndex = _allTokens.length - 1;\r\n        uint256 tokenIndex = _allTokensIndex[tokenId];\r\n    \r\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\r\n\r\n        _allTokens[tokenIndex] = lastTokenId;\r\n        _allTokensIndex[lastTokenId] = tokenIndex;\r\n\r\n        delete _allTokensIndex[tokenId];\r\n        _allTokens.pop();\r\n    }\r\n\r\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\r\n        uint256 lastTokenIndex = balanceOf(from) - 1;\r\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\r\n\r\n        if (tokenIndex != lastTokenIndex) {\r\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\r\n\r\n            _ownedTokens[from][tokenIndex] = lastTokenId;\r\n            _ownedTokensIndex[lastTokenId] = tokenIndex;\r\n        }\r\n\r\n        delete _ownedTokensIndex[tokenId];\r\n        delete _ownedTokens[from][lastTokenIndex];\r\n    }\r\n}"}}