pragma solidity >=0.6.0 <0.9.0;
//注意此处
pragma experimental ABIEncoderV2;  

interface IBEP20 {
    function totalSupply() external view returns (uint256);
    function decimals() external view returns (uint8);
    function symbol() external view returns (string memory);
    function name() external view returns (string memory);
    function getOwner() external view returns (address);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address _owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function burn(uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
}

library SafeMath {
    function add(uint x, uint y) internal pure returns (uint z) {
        require((z = x + y) >= x, 'ds-math-add-overflow');
    }

    function sub(uint x, uint y) internal pure returns (uint z) {
        require((z = x - y) <= x, 'ds-math-sub-underflow');
    }

    function mul(uint x, uint y) internal pure returns (uint z) {
        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');
    }
    
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        return c;
    }
    
    function sqrt(uint y) internal pure returns (uint z) {
        if (y > 3) {
            z = y;
            uint x = y / 2 + 1;
            while (x < z) {
                z = x;
                x = (y / x + x) / 2;
            }
        } else if (y != 0) {
            z = 1;
        }
    }
}


struct userSc {
     uint   date;
     uint   number;
     uint   status;
}

contract worSc{
      event RecWor(address indexed addr, uint num);
      event ScWor(address indexed addr, uint num);
       bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));
       address private admin;//管理员 
       using SafeMath for uint;
       address public WOR = address(0xd6edbB510af7901b2C049ce778b65a740c4aeB7f);
       function _safeTransfer(address token, address to, uint value) private {
            (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));
            require(success && (data.length == 0 || abi.decode(data, (bool))), 'Pancake: TRANSFER_FAILED');
       }
       mapping(address => userSc[]) userList;
       mapping(uint => userSc) countList;
       uint zong = 50000000000000000000000 ;
       uint day90 = 90 ;
       uint daycount = 0 ;
       uint count = 0 ;
       modifier isAdmin() {
        require(msg.sender == admin, 'FORBIDDEN');
        _;
       }

       constructor (){
            admin = msg.sender;
       }

       
     //   function extractWor(uint _value) external isAdmin{
       //     uint b = IBEP20(WOR).balanceOf(address(this));
     //       require(b >= _value,"Extraction failure");
     //        _safeTransfer(WOR,msg.sender,_value);
     //  }

       function getZong() public view returns(uint){
           return zong;
       }

       function getCount() public view returns(uint){
           return count;
       }

       function getCount(uint _count) public view returns(userSc memory){
           return countList[_count];
       }


       function getBalanceWor(address _address) public view returns(uint){
           return IBEP20(WOR).balanceOf(_address);
       }

       function gerZong(uint _value) public isAdmin {
           daycount = _value;
       }

         //获得rg
        function addressList(address _address) public view returns(userSc[] memory){
            return  userList[_address];
        }

        function scWor(uint _value) public {
            require(IBEP20(WOR).balanceOf(msg.sender) >= _value,"Wor balance deficiency");
            uint jv = _value*5/100;
            require(zong - jv >= 0,"Wor underreward");
            userSc[] storage com =  userList[msg.sender];   
            userSc memory sc = userSc(block.timestamp,_value,0);
            com.push(sc);
            zong -=jv;
            IBEP20(WOR).transferFrom(msg.sender, address(this), _value);
            count ++;
            countList[count] = sc;
            _safeTransfer(WOR,msg.sender,jv);
            emit ScWor(msg.sender,_value);
        }

        function gSc(address _address) public view returns(uint,uint){
            userSc[] storage com =  userList[_address]; 
            uint r = 0;
            uint k = 0;
            for (uint i = 0; i < com.length; i ++) {
                    uint day = block.timestamp.sub(com[i].date).div(86400);
                    uint c =  day.div(day90) + daycount;
                    if(c > 0 && com[i].status == 0){
                         k += com[i].number; 
                    }else if(com[i].status == 0){
                         r += com[i].number;
                    }
            } 
            return (r,k);
        }


        function recWor() public {
            userSc[] storage com =  userList[msg.sender]; 
            uint k;
            for (uint i = 0; i < com.length; i ++) {
                    uint day = block.timestamp.sub(com[i].date).div(86400);
                    uint c =  day.div(day90) + daycount;
                    if(c > 0 && com[i].status == 0){
                         k += com[i].number; 
                         com[i].status = 1;
                    }
            } 
            require(k > 0,"no reward");
            _safeTransfer(WOR,msg.sender,k);
            emit RecWor(msg.sender,k);
        }


}