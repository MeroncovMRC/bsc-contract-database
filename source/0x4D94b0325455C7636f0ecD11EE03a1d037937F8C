{"IGaugeFactory.sol":{"content":"/**\n * @title Interface Gauge Factory\n * @dev IGaugeFactory.sol contract\n *\n * @author - \u003cUSDFI TRUST\u003e\n * for the USDFI Trust\n *\n * SPDX-License-Identifier: GNU GPLv2\n *\n **/\n\npragma solidity =0.8.17;\n\ninterface IGaugeFactory {\n    function tokens() external view returns (address[] memory);\n\n    function getGauge(address token) external view returns (address);\n\n    function getBribes(address gauge) external view returns (address);\n\n    function reset(address user) external;\n\n    function poke(address owner) external;\n\n    function vote(\n        address user,\n        address[] calldata tokenVote,\n        uint256[] calldata weights\n    ) external;\n\n    function addGauge(address tokenLP, uint256 maxVotesToken)\n        external\n        returns (address);\n\n    function deprecateGauge(address token) external;\n\n    function resurrectGauge(address token) external;\n\n    function length() external view returns (uint256);\n\n    function distribute(uint256 start, uint256 end) external;\n\n    function updateVeProxy(address veProxy) external;\n\n    function updatePokeDelay(uint256 pokeDelay) external;\n\n    function updateMaxVotesToken(uint256 ID, uint256 maxVotesToken) external;\n\n    function bribeFactory() external view returns (address);\n\n    function totalWeight() external view returns (uint256);\n\n    function delay() external view returns (uint256);\n\n    function lastDistribute() external view returns (uint256);\n\n    function lastVote(address user) external view returns (uint256);\n\n    function nextPoke(address user) external view returns (uint256);\n\n    function lockedTotalWeight() external view returns (uint256);\n\n    function lockedBalance() external view returns (uint256);\n\n    function locktime() external view returns (uint256);\n\n    function epoch() external view returns (uint256);\n\n    function lockedWeights(address user) external view returns (uint256);\n\n    function maxVotesToken(address user) external view returns (uint256);\n\n    function hasDistributed(address user) external view returns (bool);\n\n    function _tokens(uint256 tokenID) external view returns (address);\n\n    function gauges(address token) external view returns (address);\n\n    function gaugeStatus(address token) external view returns (bool);\n\n    function gaugeExists(address token) external view returns (bool);\n\n    function pokeDelay() external view returns (uint256);\n\n    function bribes(address gauge) external view returns (address);\n\n    function weights(address token) external view returns (uint256);\n\n    function votes(address user, address token) external view returns (uint256);\n\n    function tokenVote(address user, uint256 tokenID)\n        external\n        view\n        returns (address);\n\n    function usedWeights(address user) external view returns (uint256);\n}\n"},"ReentrancyGuard.sol":{"content":"/**\r\n * @title ReentrancyGuard\r\n * @dev Reentrancy Guard contract\r\n *\r\n * @author - \u003cUSDFI TRUST\u003e\r\n * for the USDFI Trust\r\n *\r\n * SPDX-License-Identifier: MIT\r\n *\r\n * File @openzeppelin/contracts/utils/ReentrancyGuard.sol@v3.4.1\r\n * \r\n **/\r\n\r\npragma solidity =0.8.17;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot\u0027s contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler\u0027s defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction\u0027s gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor () internal {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}"},"veVoteProxy.sol":{"content":"/**\n * @title veVote Proxy\n * @dev veVoteProxy.sol contract\n *\n * @author - \u003cUSDFI TRUST\u003e\n * for the USDFI Trust\n *\n * SPDX-License-Identifier: Business Source License 1.1\n *\n **/\n\npragma solidity =0.8.17;\n\nimport \"./IGaugeFactory.sol\";\nimport \"./ReentrancyGuard.sol\";\n\ncontract veVoteProxy is ReentrancyGuard {\n    address public gaugeFactory = 0xB3863573d9f25e6a84895d4685a408db7a488416;\n\n    function poke() public nonReentrant {\n        IGaugeFactory(gaugeFactory).poke(msg.sender);\n    }\n\n    function vote(address[] calldata _tokenVote, uint256[] calldata _weights)\n        external\n        nonReentrant\n    {\n        IGaugeFactory(gaugeFactory).vote(msg.sender, _tokenVote, _weights);\n    }\n\n    function reset() external nonReentrant {\n        IGaugeFactory(gaugeFactory).reset(msg.sender);\n    }\n\n    function canVoted(address _voter) external view returns (bool) {\n        uint256 time = IGaugeFactory(gaugeFactory).epoch() -\n            IGaugeFactory(gaugeFactory).lastVote(_voter);\n        if (time \u003e 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function canVotedSender() external view returns (bool) {\n        uint256 time = IGaugeFactory(gaugeFactory).epoch() -\n            IGaugeFactory(gaugeFactory).lastVote(msg.sender);\n        if (time \u003e 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"}}