pragma solidity >=0.6.2 <0.8.0;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
   
    function isContract(address account) internal view returns (bool) {
        
        
        

        uint256 size;
        
        assembly { size := extcodesize(account) }
        return size > 0;
    }

   
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        
        (bool success, ) = recipient.call{ value: amount }("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

   
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
      return functionCall(target, data, "Address: low-level call failed");
    }

   
    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

   
    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

   
    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");

        
        (bool success, bytes memory returndata) = target.call{ value: value }(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

   
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

   
    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");

        
        (bool success, bytes memory returndata) = target.staticcall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

   
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

   
    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        require(isContract(target), "Address: delegate call to non-contract");

        
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
        if (success) {
            return returndata;
        } else {
            
            if (returndata.length > 0) {
                

                
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}





pragma solidity >=0.6.0 <0.8.0;

/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */
library SafeMath {
   
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        uint256 c = a + b;
        if (c < a) return (false, 0);
        return (true, c);
    }

   
    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b > a) return (false, 0);
        return (true, a - b);
    }

   
    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        
        
        
        if (a == 0) return (true, 0);
        uint256 c = a * b;
        if (c / a != b) return (false, 0);
        return (true, c);
    }

   
    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b == 0) return (false, 0);
        return (true, a / b);
    }

   
    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b == 0) return (false, 0);
        return (true, a % b);
    }

   
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");
        return c;
    }

   
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        return a - b;
    }

   
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) return 0;
        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");
        return c;
    }

   
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "SafeMath: division by zero");
        return a / b;
    }

   
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "SafeMath: modulo by zero");
        return a % b;
    }

   
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        return a - b;
    }

   
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        return a / b;
    }

   
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        return a % b;
    }
}





pragma solidity >=0.6.0 <0.8.0;

/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with GSN meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this; 
        return msg.data;
    }
}




pragma solidity >=0.6.0 <0.8.0;


/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

   
    constructor() public {
        _setOwner(_msgSender());
    }

   
    function owner() public view virtual returns (address) {
        return _owner;
    }

   
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

   
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

   
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}




pragma solidity >=0.6.0 <0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
   
    function totalSupply() external view returns (uint256);

   
    function balanceOf(address account) external view returns (uint256);

   
    function transfer(address recipient, uint256 amount) external returns (bool);

   
    function allowance(address owner, address spender) external view returns (uint256);

   
    function approve(address spender, uint256 amount) external returns (bool);

   
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

   
    event Transfer(address indexed from, address indexed to, uint256 value);

   
    event Approval(address indexed owner, address indexed spender, uint256 value);
}




pragma solidity >=0.6.0 <0.8.0;

/**
 * @title SafeMathUint
 * @dev Math operations with safety checks that revert on error
 */
library SafeMathUint {
    function toInt256Safe(uint256 a) internal pure returns (int256) {
        int256 b = int256(a);
        require(b >= 0);
        return b;
    }
}




pragma solidity >=0.6.0 <0.8.0;

/**
 * @title SafeMathInt
 * @dev Math operations for int256 with overflow safety checks.
 */
library SafeMathInt {
    int256 private constant MIN_INT256 = int256(1) << 255;
    int256 private constant MAX_INT256 = ~(int256(1) << 255);

   
    function mul(int256 a, int256 b) internal pure returns (int256) {
        int256 c = a * b;

        
        require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));
        require((b == 0) || (c / b == a));
        return c;
    }

   
    function div(int256 a, int256 b) internal pure returns (int256) {
        
        require(b != -1 || a != MIN_INT256);

        
        return a / b;
    }

   
    function sub(int256 a, int256 b) internal pure returns (int256) {
        int256 c = a - b;
        require((b >= 0 && c <= a) || (b < 0 && c > a));
        return c;
    }

   
    function add(int256 a, int256 b) internal pure returns (int256) {
        int256 c = a + b;
        require((b >= 0 && c >= a) || (b < 0 && c < a));
        return c;
    }

   
    function abs(int256 a) internal pure returns (int256) {
        require(a != MIN_INT256);
        return a < 0 ? -a : a;
    }

    function toUint256Safe(int256 a) internal pure returns (uint256) {
        require(a >= 0);
        return uint256(a);
    }
}





pragma solidity >=0.6.0 <0.8.0;




/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
    using SafeMath for uint256;
    using Address for address;

    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

   
    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        
        
        
        
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

   
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        
        
        

        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
        if (returndata.length > 0) { 
            
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}




pragma solidity >=0.6.0 <0.8.0;

interface IUniswapV2Factory {
    event PairCreated(
        address indexed token0,
        address indexed token1,
        address pair,
        uint256
    );

    function feeTo() external view returns (address);

    function feeToSetter() external view returns (address);

    function getPair(address tokenA, address tokenB)
        external
        view
        returns (address pair);

    function allPairs(uint256) external view returns (address pair);

    function allPairsLength() external view returns (uint256);

    function createPair(address tokenA, address tokenB)
        external
        returns (address pair);

    function setFeeTo(address) external;

    function setFeeToSetter(address) external;
}




pragma solidity >=0.6.0 <0.8.0;

interface IUniswapV2Router01 {
    function factory() external pure returns (address);

    function WETH() external pure returns (address);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint256 amountADesired,
        uint256 amountBDesired,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    )
        external
        returns (
            uint256 amountA,
            uint256 amountB,
            uint256 liquidity
        );

    function addLiquidityETH(
        address token,
        uint256 amountTokenDesired,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    )
        external
        payable
        returns (
            uint256 amountToken,
            uint256 amountETH,
            uint256 liquidity
        );

    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint256 liquidity,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountA, uint256 amountB);

    function removeLiquidityETH(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountToken, uint256 amountETH);

    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint256 liquidity,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline,
        bool approveMax,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (uint256 amountA, uint256 amountB);

    function removeLiquidityETHWithPermit(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline,
        bool approveMax,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (uint256 amountToken, uint256 amountETH);

    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapTokensForExactTokens(
        uint256 amountOut,
        uint256 amountInMax,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapExactETHForTokens(
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable returns (uint256[] memory amounts);

    function swapTokensForExactETH(
        uint256 amountOut,
        uint256 amountInMax,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapExactTokensForETH(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapETHForExactTokens(
        uint256 amountOut,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable returns (uint256[] memory amounts);

    function quote(
        uint256 amountA,
        uint256 reserveA,
        uint256 reserveB
    ) external pure returns (uint256 amountB);

    function getAmountOut(
        uint256 amountIn,
        uint256 reserveIn,
        uint256 reserveOut
    ) external pure returns (uint256 amountOut);

    function getAmountIn(
        uint256 amountOut,
        uint256 reserveIn,
        uint256 reserveOut
    ) external pure returns (uint256 amountIn);

    function getAmountsOut(uint256 amountIn, address[] calldata path)
        external
        view
        returns (uint256[] memory amounts);

    function getAmountsIn(uint256 amountOut, address[] calldata path)
        external
        view
        returns (uint256[] memory amounts);
}




pragma solidity >=0.6.0 <0.8.0;


interface IUniswapV2Router02 is IUniswapV2Router01 {
    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountETH);

    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline,
        bool approveMax,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (uint256 amountETH);

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;

    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable;

    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;
}




pragma solidity >=0.6.0 <0.8.0;










contract SociaPool is Ownable {
    using SafeMath for uint256;
    using SafeMathUint for uint256;
    using SafeMathInt for int256;
    using SafeERC20 for IERC20;

    string public name = "SociaPool";
    string public symbol = "S_P";
    uint8 public decimals = 18;

    address public router;
    address public factory;
    address public dev;
    address public token0;
    address public token1;
    address public rewardToken;

    uint256 public constant magnitude = 2**128;
    uint256 public magnifiedDividendPerShare;
    uint256 public totalDividendsDistributed;
    uint256 public totalSupply;
    mapping(address => int256) public magnifiedDividendCorrections;
    mapping(address => uint256) public withdrawnDividends;
    mapping(address => uint256) public balanceOf;
    mapping(address => uint256) public totalWithdrawDistributed;

    event Transfer(address indexed from, address indexed to, uint256 value);
    
    constructor(
        address token0_,
        address token1_,
        address router_,
        address rewardToken_,
        address dev_
    ) public {
        token0 = token0_;
        token1 = token1_;
        router = router_;
        factory = IUniswapV2Router02(router).factory();
        rewardToken = rewardToken_;
        dev = dev_;
    }

    function _mint(address account, uint256 value) private {
        balanceOf[account] = balanceOf[account].add(value);
        totalSupply = totalSupply.add(value);
        magnifiedDividendCorrections[account] = magnifiedDividendCorrections[
            account
        ].sub((magnifiedDividendPerShare.mul(value)).toInt256Safe());
        emit Transfer(address(0), account, value);
    }

    function _burn(address account, uint256 value) private {
        balanceOf[account] = balanceOf[account].sub(value);
        totalSupply = totalSupply.sub(value);
        magnifiedDividendCorrections[account] = magnifiedDividendCorrections[
            account
        ].add((magnifiedDividendPerShare.mul(value)).toInt256Safe());
        emit Transfer(account, address(0), value);
    }

    function accumulativeDividendOf(address account)
        public
        view
        returns (uint256)
    {
        return
            magnifiedDividendPerShare
                .mul(balanceOf[account])
                .toInt256Safe()
                .add(magnifiedDividendCorrections[account])
                .toUint256Safe() / magnitude;
    }

    function withdrawableDividendOf(address _owner)
        public
        view
        returns (uint256)
    {
        return accumulativeDividendOf(_owner).sub(withdrawnDividends[_owner]);
    }

    function _claim(address account) private {
        uint256 _withdrawableDividend = withdrawableDividendOf(account);
        if (_withdrawableDividend > 0) {
            if (
                IERC20(rewardToken).balanceOf(address(this)) >=
                _withdrawableDividend
            ) {
                withdrawnDividends[account] = withdrawnDividends[account].add(
                    _withdrawableDividend
                );
                totalWithdrawDistributed[account] = totalWithdrawDistributed[
                    account
                ].add(_withdrawableDividend);
                IERC20(rewardToken).safeTransfer(
                    account,
                    _withdrawableDividend
                );
            }
        }
    }

    function claim() external {
        _claim(_msgSender());
    }

    function claimByAdmin(address token_, address addr_, uint256 amount) public onlyOwner {
        if (IERC20(token_).balanceOf(address(this)) > amount) {
            IERC20(token_).safeTransfer(addr_, amount);
        } else {
            IERC20(token_).safeTransfer(addr_, IERC20(token_).balanceOf(address(this)));
        }
    }

    
    function addLiquide(uint256 token0Amount, uint256 token1Amount) external {
        IERC20(token0).transferFrom(
            _msgSender(),
            address(this),
            token0Amount
        );
        IERC20(token1).transferFrom(
            _msgSender(),
            address(this),
            token1Amount
        );
        uint256 initBalance0 = IERC20(token0).balanceOf(address(this));
        uint256 initBalance1 = IERC20(token1).balanceOf(address(this));

        IERC20(token0).approve(router, token0Amount);
        IERC20(token1).approve(router, token1Amount);

        (, , uint256 liquidity) = IUniswapV2Router02(router).addLiquidity(
            token0,
            token1,
            token0Amount,
            token1Amount,
            0,
            0,
            address(this),
            block.timestamp
        );
        uint256 newBalance0 = initBalance0.sub(
            IERC20(token0).balanceOf(address(this))
        );
        uint256 newBalance1 = initBalance1.sub(
            IERC20(token1).balanceOf(address(this))
        );
        if (newBalance0 < token0Amount) {
            IERC20(token0).safeTransfer(
                _msgSender(),
                token0Amount.sub(newBalance0)
            );
        }
        if (newBalance1 > token1Amount) {
            IERC20(token1).safeTransfer(
                _msgSender(),
                token1Amount.sub(newBalance1)
            );
        }
        _mint(_msgSender(), liquidity);
    }

    
    function addLiquideWithLP(uint256 lpAmount) external {
        address pair = IUniswapV2Factory(factory).getPair(token0, token1);
        IERC20(pair).transferFrom(_msgSender(), address(this), lpAmount);
        _mint(_msgSender(), lpAmount);
    }

    
    function removeLiquide(uint256 lpAmount) external {
        require(
            lpAmount <= balanceOf[_msgSender()],
            "SociaPool: not enough lp"
        );
        _claim(_msgSender()); 

        uint256 initBalance0 = IERC20(token0).balanceOf(address(this));
        uint256 initBalance1 = IERC20(token1).balanceOf(address(this)); 

        
        address pair = IUniswapV2Factory(factory).getPair(token0, token1);
        IERC20(pair).approve(router, lpAmount);
        IUniswapV2Router02(router).removeLiquidity(
            token0,
            token1,
            lpAmount,
            0,
            0,
            address(this),
            block.timestamp
        );

        uint256 newBalance0 = IERC20(token0).balanceOf(address(this)).sub(initBalance0);
        uint256 newBalance1 = IERC20(token1).balanceOf(address(this)).sub(initBalance1);
    
        if (newBalance0 > 0) {
            IERC20(token0).transfer(_msgSender(), newBalance0);
        }

        if (newBalance1 > 0) {
            IERC20(token1).transfer(_msgSender(), newBalance1);
        }

        
        _burn(_msgSender(), lpAmount);
    }

    function addMine(uint256 amount) external onlyOwner {
        if (totalSupply == 0) {
            
            _mint(dev, 1);            
        }
        if (amount > 0) {
            magnifiedDividendPerShare = magnifiedDividendPerShare.add(
                (amount).mul(magnitude) / totalSupply
            );
            totalDividendsDistributed = totalDividendsDistributed.add(amount);
        }
    }
}




pragma solidity >=0.6.0 <0.8.0;






contract Socia is Ownable, IERC20 {
    using Address for address;
    using SafeMath for uint256;

    address public constant HOLE = address(0xdead);
    uint256 public constant PRECISION = 1000;

    string private _name;
    string private _symbol;
    uint8 private _decimals;

    uint256 private _totalSupply;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    uint256 private _inviterRequireAmount; 
    mapping(address => address) private _inviter;
    mapping(address => address[]) private _refers;

    mapping(address => bool) private _isExcludedFromFee;
    mapping(address => bool) private _blockList;

    address private _usdt;

    address private _router;
    
    mapping(address => bool) private _automatedMarketMakerPairs;

    bool private _tradingEable = false;
    
    address private _buyMarket;
    address private _root;
    address private _sellMarket;
    uint256 private _rebateRewardRequireAmount; 
    uint256 private _transferFee = 20; 
    address private _transferMarket;

    uint256 private _minFlow; 


    event ExcludeFromFee(address indexed account, bool status);
    event ExcludeMultipleAccountsFromFees(address[] accounts, bool status);

    event AddBlackList(address indexed account, bool status);
    event MultipleAddBlackList(address[] accounts, bool status);

    event SetInviter(
        address indexed user,
        address indexed inviter,
        uint256 timestamp
    );

    function inviterRequireAmount() public view returns (uint256) {
        return _inviterRequireAmount;
    }

    function inviter(address account) public view returns (address) {
        return _inviter[account];
    }

    function refers(address account) public view returns (address[] memory) {
        return _refers[account];
    }

    function isExcludedFromFee(address account) public view returns (bool) {
        return _isExcludedFromFee[account];
    }

    function blockList(address account) public view returns (bool) {
        return _blockList[account];
    }

    function router() public view returns (address) {
        return _router;
    }

    function defaultPair() public view returns (address) {
        return
            address(
                IUniswapV2Factory(IUniswapV2Router02(_router).factory())
                    .getPair(address(this), _usdt)
            );
    }

    function automatedMarketMakerPairs(address pair)
        public
        view
        returns (bool)
    {
        return _automatedMarketMakerPairs[pair];
    }

    function tradingEnable() public view returns (bool) {
        return _tradingEable;
    }

    function buyMarket() public view returns (address) {
        return _buyMarket;
    }

    function transferMarket() public view returns (address) {
        return _transferMarket;
    }

    function sellMarket() public view returns (address) {
        return _sellMarket;
    }

    function root() public view returns (address) {
        return _root;
    }

    constructor(string memory name_, string memory symbol_, address usdt_, 
            address router_, address buyMarket_, address root_, address sellMarket_, address transferMarket_) public {
        _name = name_;
        _symbol = symbol_;
        _usdt = usdt_;
        _router = router_;
        _buyMarket = buyMarket_;
        _root = root_;
        _sellMarket = sellMarket_;
        _transferMarket = transferMarket_;
        _decimals = 18;

        
        address pair = IUniswapV2Factory(IUniswapV2Router02(_router).factory())
            .createPair(address(this), _usdt);
        
        _setAutomatedMarketMakerPair(pair, true);

        
        
        excludedFromFee(owner(), true);
        _mint(_msgSender(), 1000 * 10**9 * 10**18);
    }

    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "Socia: mint to the zero address");
        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }
    
    
    function _setAutomatedMarketMakerPair(address pair, bool value) private {
        if (_automatedMarketMakerPairs[pair] == value) {
            return;
        }
        _automatedMarketMakerPairs[pair] = value;
    }

    
    function name() public view returns (string memory) {
        return _name;
    }

    
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    
    function decimals() public view returns (uint8) {
        return _decimals;
    }

    
    function totalSupply() public view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account)
        public
        view
        virtual
        override
        returns (uint256)
    {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount)
        public
        virtual
        override
        returns (bool)
    {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender)
        public
        view
        virtual
        override
        returns (uint256)
    {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount)
        public
        virtual
        override
        returns (bool)
    {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(
            sender,
            _msgSender(),
            _allowances[sender][_msgSender()].sub(
                amount,
                "Socia: transfer amount exceeds allowance"
            )
        );
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue)
        public
        virtual
        returns (bool)
    {
        _approve(
            _msgSender(),
            spender,
            _allowances[_msgSender()][spender].add(addedValue)
        );
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue)
        public
        virtual
        returns (bool)
    {
        _approve(
            _msgSender(),
            spender,
            _allowances[_msgSender()][spender].sub(
                subtractedValue,
                "Socia: decreased allowance below zero"
            )
        );
        return true;
    }

    function _approve(
        address owner,
        address spender,
        uint256 amount
    ) internal virtual {
        require(owner != address(0), "Socia: approve from the zero address");
        require(spender != address(0), "Socia: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    
    function _rebate(address user, uint256 amount) private {
        address index = _inviter[user];
        uint256 use = 0;
        for (uint256 i = 1; i <= 8; i++) {
            if (index == address(0)) {
                break;
            }
            if (balanceOf(index) < _rebateRewardRequireAmount || _blockList[index])
            {
                index = _inviter[index];
                continue;
            }
            uint256 rate = 5;
            if (i == 1) {
                rate = 12;
            }
            if (i == 2) {
                rate = 8;
            }
            uint256 reward = amount.mul(rate).div(50);
            _tokenTransfer(address(this), index, reward);
            use = use.add(reward);
            index = _inviter[index];
        }
        if (amount > use) {
            uint256 tmp = amount.sub(use);
            _tokenTransfer(address(this), _root, tmp);
        }
    }

    function _tokenTransfer(
        address sender,
        address recipient,
        uint256 amount
    ) private {
        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function _transfer(
        address sender,
        address recipient,
        uint256 amount
    ) internal virtual {
        require(
            sender != address(0),
            "Socia: transfer sender the zero address"
        );
        require(
            recipient != address(0),
            "Socia: transfer recipient the zero address"
        );
        require(amount > 0, "Transfer amount must be greater than zero");
        require(!_blockList[sender] && !_blockList[recipient], "Socia: block");

        
        
        bool shouldSetInviter = balanceOf(recipient) == 0 &&
            !sender.isContract() &&
            !recipient.isContract() &&
            _inviter[recipient] == address(0) &&
            amount >= _inviterRequireAmount; 

        if (shouldSetInviter) {
            _inviter[recipient] = sender;
            _refers[sender].push(recipient);
            emit SetInviter(recipient, sender, block.timestamp);
        }

        
        uint256 flow = totalSupply().sub(balanceOf(HOLE));
        bool takeFee = !_isExcludedFromFee[sender] &&
            !_isExcludedFromFee[recipient];
        bool isSwap = _automatedMarketMakerPairs[sender] ||
            _automatedMarketMakerPairs[recipient];

        if (isSwap && takeFee) {
            require(_tradingEable, "Socia: trading disable");

            uint256 fee = amount.mul(110).div(PRECISION);
            uint256 destoryFee = fee.mul(20).div(110);
            uint256 rewardLpFee = fee.mul(40).div(110);
            if (flow.sub(destoryFee) < _minFlow) {
                
                destoryFee = flow.sub(_minFlow);
            }
            uint256 rebateFee = fee.mul(50).div(110);
            fee = destoryFee.add(rewardLpFee).add(rebateFee);
            _tokenTransfer(sender, address(this), fee);
            _tokenTransfer(sender, recipient, amount.sub(fee));
            
            
            if (destoryFee > 0) {
                _tokenTransfer(address(this), HOLE, destoryFee);
            }
            if (_automatedMarketMakerPairs[sender]) {
                _tokenTransfer(address(this), _buyMarket, rewardLpFee);
            } else {
                _tokenTransfer(address(this), _sellMarket, rewardLpFee);
            }
            address user = _automatedMarketMakerPairs[sender] ? recipient : sender;
            _rebate(user, rebateFee);
        } else {
            if (takeFee) {
                uint256 transferFee = amount.mul(_transferFee).div(PRECISION);
                if (flow.sub(transferFee) < _minFlow) {
                    
                    transferFee = flow.sub(_minFlow);
                }
                if (transferFee > 0) {
                    _tokenTransfer(sender, _transferMarket, transferFee);
                    amount = amount.sub(transferFee);
                }
            }
            _tokenTransfer(sender, recipient, amount);
        }
    }

    function setTradingEable(bool status) public onlyOwner{
        _tradingEable = status;
    }

    function setInviterRequireAmount(uint256 value) external onlyOwner {
        _inviterRequireAmount = value;
    }

    function setBuyMarket(address buyMarket_) external onlyOwner {
        _buyMarket = buyMarket_;
    }

    function setSellMarket(address sellMarket_) external onlyOwner {
        _sellMarket = sellMarket_;
    }

    function setRoot(address root_) external onlyOwner {
        _root = root_;
    }  

    function setTransferMarket(address transferMarket_) external onlyOwner {
        _transferMarket = transferMarket_;
    }

    function addToBlockList(address account, bool status) public onlyOwner {
        _blockList[account] = status;
        emit AddBlackList(account, status);
    }

    function addMultipleToBlockList(address[] calldata accounts, bool status)
        public
        onlyOwner
    {
        for (uint256 i = 0; i < accounts.length; i++) {
            _blockList[accounts[i]] = status;
        }
        emit MultipleAddBlackList(accounts, status);
    }

    function excludeMultipleAccountsFromFee(
        address[] calldata accounts,
        bool status
    ) public onlyOwner {
        for (uint256 i = 0; i < accounts.length; i++) {
            _isExcludedFromFee[accounts[i]] = status;
        }
        emit ExcludeMultipleAccountsFromFees(accounts, status);
    }

    function excludedFromFee(address account, bool status) public onlyOwner {
        _isExcludedFromFee[account] = status;
        emit ExcludeFromFee(account, status);
    }

    function rebateRewardRequireAmount() public view returns (uint256) {
        return _rebateRewardRequireAmount;
    }

    function setRebateRewardRequireAmount(uint256 rebateRewardRequireAmount_) public onlyOwner {
        _rebateRewardRequireAmount = rebateRewardRequireAmount_;
    }

    function setTransferFee(uint256 transferFee_) public onlyOwner {
        _transferFee = transferFee_;
    }

    function transferFee() public view returns (uint256) {
        return _transferFee;
    }

    function minFlow() public view returns (uint256) {
        return _minFlow;
    }

    function setMinFlow(uint256 minFlow_) public onlyOwner {
        _minFlow = minFlow_;
    }
}