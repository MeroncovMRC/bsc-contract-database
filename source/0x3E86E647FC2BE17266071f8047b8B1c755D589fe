{"EXTEND.sol":{"content":"pragma solidity ^0.4.24;\r\n\r\nimport \"./IERC20.sol\";\r\n\r\ncontract EXTEND is IERC20 {\r\n\r\n  mapping (address =\u003e mapping (bytes32 =\u003e uint[])) public refnosOf; //V9\r\n  mapping (address =\u003e address) public refAccounts; //REMT9\r\n\r\n  uint public constant MIN = 100; //REMT9\r\n  uint public constant ANNSEC = 31536000;\r\n\r\n  event Ref (address indexed referrer, address referee); //REMT9\r\n\r\n  constructor () public {\r\n    refAccounts[msg.sender] = creator; //REMT9\r\n  }\r\n\r\n  modifier checkRefAccount {\r\n    require (refAccounts[msg.sender] != 0x0);\r\n    _;\r\n  } //REMT9\r\n\r\n  modifier checkBalanceOf {\r\n    require (balanceOf[msg.sender] \u003e= MIN*PPT);\r\n    _;\r\n  } //REMT9\r\n\r\n  modifier checkTxGasPrice {\r\n    require (tx.gasprice \u003c= getGasPrice());\r\n    _;\r\n  } //REMT9\r\n\r\n  function requireBalance (uint256 value)\r\n  internal view { // Comes after [checkBalanceOf]\r\n    require (balanceOf[msg.sender]-MIN*PPT \u003e= value);\r\n  } //REMT9\r\n\r\n  function ethered (uint256 value)\r\n  internal view returns (bool) {\r\n    require (msg.value*value==0 \u0026\u0026 msg.value+value\u003e0, \"#eth:values\");\r\n    require (value\u003c=totalSupply, \"#eth:value\");\r\n    return msg.value\u003e0?true:false;\r\n  }\r\n\r\n  function addNo (string key, uint refno)\r\n  internal {\r\n    require (refno \u003e 0);\r\n    bytes32 pid = keccak256 (abi.encodePacked(key,msg.value\u003e0?\"E\":\"T\"));\r\n    refnosOf[msg.sender][pid].push (refno);\r\n    refnosOf[0x0][pid].push (refno);\r\n  } //V8\u003eREMT9\r\n\r\n  // PUBLIC VIEW\r\n\r\n  function getGasPrice () public view returns (uint256) {\r\n    uint256 gasPrice;\r\n    assembly {\r\n      gasPrice := gasprice()\r\n    }\r\n    return gasPrice;\r\n  } //REMT9\r\n\r\n  function refnos (address ua, string key, string form, uint skip, uint limit) public view returns (uint size, uint[] memory nos) {\r\n    uint[] memory therefno = refnosOf[ua][keccak256(abi.encodePacked(key,form))];\r\n    size = therefno.length;\r\n    if (size \u003c= skip) return;\r\n    uint start = size - skip;\r\n    uint count = start\u003elimit ? limit : start;\r\n    uint[] memory lst = new uint[](count);\r\n    for (uint i=0; i\u003ccount; i++) { lst[i] = therefno[i+skip]; }\r\n    nos = lst;\r\n  } //V8\u003eREMT9\r\n\r\n  // PUBLIC ACCESS\r\n\r\n  function ref (address referee)\r\n  checkRefAccount checkBalanceOf public returns (bool success) {\r\n    refAccounts[referee] = msg.sender;\r\n    emit Ref (msg.sender, referee);\r\n    return true;\r\n  } //REMT9\r\n\r\n  function transferToMany (address[] tos, uint256[] values, string note) public returns (bool success) {\r\n    require (tos.length == values.length);\r\n    note = \"\"; uint256 total; uint i;\r\n    for (i=0; i\u003ctos.length; i++) { total += values[i]; }\r\n    require (total\u003e0 \u0026\u0026 balanceOf[msg.sender]\u003e=total);\r\n    for (i=0; i\u003ctos.length; i++) {\r\n      move (msg.sender, tos[i], values[i]);\r\n    }\r\n    return true;\r\n  } //REMT9\r\n}"},"IERC20.sol":{"content":"pragma solidity ^0.4.24;\r\n\r\ncontract IERC20 {\r\n\r\n  string public name;\r\n  string public symbol;\r\n  uint8 public decimals;\r\n  uint256 public totalSupply;\r\n  mapping (address =\u003e uint256) public balanceOf;\r\n  mapping (address =\u003e mapping (address =\u003e uint256)) public allowance;\r\n\r\n  uint256 internal PPT;\r\n  string public author;\r\n  address public creator;\r\n\r\n  event Transfer (address indexed fromAddress, address indexed toAddress, uint256 txPenny);\r\n  event Approval (address indexed ownerAddress, address indexed spenderAddress, uint256 txPenny);\r\n\r\n  constructor () public {\r\n    decimals = 18;\r\n    PPT = 10**uint256(decimals);\r\n    author = \"ASINERUM INTERNATIONAL\";\r\n    creator = msg.sender;\r\n  }\r\n\r\n  function move (address from, address to, uint256 value)\r\n  internal {\r\n    require (value \u003c= balanceOf[from]);\r\n    require (balanceOf[to]+value \u003e balanceOf[to]);\r\n    uint256 sum = balanceOf[from] + balanceOf[to];\r\n    balanceOf[from] -= value;\r\n    balanceOf[to] += value;\r\n    assert (balanceOf[from]+balanceOf[to] == sum);\r\n    emit Transfer (from, to, value);\r\n  }\r\n\r\n  function transfer (address to, uint256 value) public returns (bool success) {\r\n    move (msg.sender, to, value);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom (address from, address to, uint256 value) public returns (bool success) {\r\n    require (value \u003c= allowance[from][msg.sender]);\r\n    allowance[from][msg.sender] -= value;\r\n    move (from, to, value);\r\n    return true;\r\n  } //V2\r\n\r\n  function approve (address spender, uint256 value) public returns (bool success) {\r\n    allowance[msg.sender][spender] = value;\r\n    emit Approval (msg.sender, spender, value);\r\n    return true;\r\n  } //V2\r\n}"},"KEY.sol":{"content":"pragma solidity ^0.4.24;\r\n\r\ncontract KEY {\r\n\r\n  function b2i (bytes32 bstr) public pure returns (uint num) {\r\n    for (uint index=0; index\u003cbstr.length; index++) {\r\n      num += uint(bstr[index])*(16**(index*2)+1);\r\n    }\r\n  }\r\n\r\n  function keygen (uint nonce, uint key) public view returns (uint num) {\r\n    num = b2i (keccak256 (abi.encodePacked (uint256(uint160(address(msg.sender))), key, nonce))); //V6\r\n  } //REMT9\r\n\r\n  function numgen (uint nonce, uint key) public view returns (uint num) {\r\n    num = b2i (keccak256 (abi.encodePacked (key, nonce, block.number, blockhash(block.number-1), block.coinbase, msg.sender, gasleft(), now)));\r\n  }\r\n}"},"MARKET.sol":{"content":"pragma solidity ^0.4.24;\r\n\r\nimport \"./EXTEND.sol\";\r\n\r\ncontract MARKET is EXTEND {\r\n\r\n  mapping (uint =\u003e Market) public markets;\r\n  struct Market { //V1\u003eREMT9\r\n    bool buytoken;\r\n    address maker;\r\n    uint256 value;\r\n    uint256 ppe; }\r\n\r\n  event Post (uint refno, bool indexed buy, address indexed maker, uint256 indexed ppe); //REMT9\r\n  event Acquire (uint indexed refno, address indexed taker, uint256 value); //REMT9\r\n\r\n  function post (uint refno, uint256 value, uint256 ppe) //REMT9\r\n  checkBalanceOf public payable returns (bool success) {\r\n    requireBalance (value);\r\n    require (markets[refno].maker==0x0, \"#refno\");\r\n    require (ppe\u003e0\u0026\u0026ppe\u003ctotalSupply, \"#rate\");\r\n    Market memory mi;\r\n    mi.buytoken = ethered (value);\r\n    mi.value = msg.value + value;\r\n    mi.maker = msg.sender;\r\n    mi.ppe = ppe;\r\n    markets[refno] = mi;\r\n    if (!mi.buytoken) move (msg.sender, address(this), value);\r\n    emit Post (refno, mi.buytoken, mi.maker, mi.ppe);\r\n    addNo (\"post\", refno); //V8\r\n    return true;\r\n  }\r\n\r\n  function acquire (uint refno, uint256 value)\r\n  checkTxGasPrice public payable returns (bool success) {\r\n    bool buytoken = ethered (value);\r\n    Market storage mi = markets[refno];\r\n    require (mi.maker!=0x0, \"#refno\");\r\n    require (mi.value\u003e0\u0026\u0026mi.ppe\u003e0, \"#data\");\r\n    require (mi.buytoken==(!buytoken), \"#request\");\r\n    uint256 pre = mi.value;\r\n    uint256 remit;\r\n    if (buytoken) {\r\n      remit = msg.value*mi.ppe/PPT;\r\n      require (remit\u003e0\u0026\u0026remit\u003c=mi.value, \"#volume\");\r\n      move (address(this), msg.sender, remit);\r\n      mi.maker.transfer (msg.value);\r\n    } else {\r\n      remit = value*PPT/mi.ppe;\r\n      require (remit\u003e0\u0026\u0026remit\u003c=mi.value, \"#volume\");\r\n      move (msg.sender, mi.maker, value);\r\n      msg.sender.transfer (remit);\r\n    }\r\n    mi.value -= remit;\r\n    assert (mi.value+remit == pre);\r\n    emit Acquire (refno, msg.sender, remit);\r\n    addNo (\"acquire\", refno); //V8\r\n    return true;\r\n  }\r\n}"},"PlanX.sol":{"content":"pragma solidity ^0.4.24;\r\n\r\nimport \"./MARKET.sol\";\r\n\r\ncontract PlanX is MARKET {\r\n\r\n  mapping (uint =\u003e Program) public programs;\r\n  struct Program {\r\n    bool eth;\r\n    address maker;\r\n    uint256 value;\r\n    uint petri;\r\n    uint open; }\r\n\r\n  mapping (uint =\u003e mapping (address =\u003e Invest)) public invests;\r\n  struct Invest {\r\n    uint256 amount;\r\n    uint start; }\r\n\r\n  uint public constant MAXPETRI = 10**9; //REMT9\r\n\r\n  event Programing (uint refno, address indexed maker, uint indexed petri, uint indexed open); //REMT9\r\n  event Investing (uint indexed refno, address indexed taker, uint256 value); //REMT9\r\n\r\n  event Close (uint refno, address indexed closer, uint256 value); //REMT9\r\n  event Withdraw (uint refno, address indexed drawer, uint256 value); //REMT9\r\n\r\n  function program (uint refno, uint petri, uint256 value)\r\n  checkBalanceOf public payable returns (bool success) {\r\n    requireBalance (value);\r\n    require (programs[refno].maker==0x0, \"#refno\");\r\n    require (petri\u003e0\u0026\u0026petri\u003cMAXPETRI, \"#rate\"); //REMT9\r\n    Program memory pi;\r\n    pi.eth = ethered (value);\r\n    pi.maker = msg.sender;\r\n    pi.value = msg.value + value;\r\n    pi.petri = petri;\r\n    pi.open = now;\r\n    programs[refno] = pi;\r\n    if (!pi.eth) move (msg.sender, address(this), value);\r\n    emit Programing (refno, pi.maker, pi.petri, pi.open);\r\n    addNo (\"program\", refno);\r\n    return true;\r\n  } //REMT9\r\n\r\n  function close (uint refno)\r\n  checkTxGasPrice checkBalanceOf public returns (bool success) {\r\n    Program storage pi = programs[refno];\r\n    require (pi.value\u003e0, \"#data\");\r\n    require (pi.maker==msg.sender, \"#user\");\r\n    uint256 draw = pi.value/2; //REMT9\r\n    if (pi.eth) pi.maker.transfer (draw);\r\n    else move (address(this), pi.maker, draw);\r\n    pi.value -= draw;\r\n    emit Close (refno, msg.sender, draw);\r\n    return true;\r\n  } //REMT9\r\n\r\n  function invest (uint refno, uint256 value)\r\n  checkTxGasPrice public payable returns (bool success) {\r\n    require (invests[refno][msg.sender].start==0, \"#invest\");\r\n    Program storage pi = programs[refno];\r\n    Invest memory ii;\r\n    bool eth = ethered (value);\r\n    require (pi.value\u003e0, \"#data\");\r\n    require (pi.eth==eth, \"#request\");\r\n    ii.start = now;\r\n    ii.amount = msg.value + value;\r\n    invests[refno][msg.sender] = ii;\r\n    if (!pi.eth) move (msg.sender, address(this), value);\r\n    pi.value += ii.amount;\r\n    emit Investing (refno, msg.sender, ii.amount);\r\n    addNo (\"invest\", refno);\r\n    return true;\r\n  }\r\n\r\n  function withdraw (uint refno)\r\n  checkTxGasPrice public returns (bool success) {\r\n    Program storage pi = programs[refno];\r\n    Invest storage ii = invests[refno][msg.sender];\r\n    uint256 cap = ii.amount+(ii.amount*pi.petri/10**9)*(now-ii.start); //REMT9\r\n    require (cap\u003e0\u0026\u0026cap\u003cpi.value, \"#fund\");\r\n    if (pi.eth) msg.sender.transfer (cap);\r\n    else move (address(this), msg.sender, cap);\r\n    pi.value -= cap;\r\n    ii.amount = 0;\r\n    ii.start = 0;\r\n    emit Withdraw (refno, msg.sender, cap);\r\n    return true;\r\n  }\r\n}"},"Remt.sol":{"content":"pragma solidity ^0.4.24;\r\n\r\nimport \"./KEY.sol\";\r\nimport \"./PlanX.sol\";\r\n\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\ncontract RemtBase is PlanX, KEY {\r\n\r\n  uint public STAGE;\r\n  uint public basicRate;\r\n  uint public randomKey;\r\n\r\n  uint public rewardStamp; //REMT9\r\n  uint public rewardInterval; //REMT9\r\n  uint256 public timeReward; //REMT9\r\n\r\n  uint256 public lottoVal; //REMT9\r\n  uint public lottoMod; //REMT9\r\n\r\n  mapping (uint =\u003e uint256) public blockPayouts;\r\n\r\n  constructor () public {\r\n    STAGE = now;\r\n    basicRate = 2400;\r\n    randomKey = 16**32;\r\n    timeReward = 1*PPT;\r\n    rewardStamp = now; //REMT9\r\n    rewardInterval = 60*20; //REMT9\r\n    lottoVal = 2048*PPT; //REMT9\r\n    lottoMod = 10**6; //REMT9\r\n    balanceOf[address(0)] = (10**9)*PPT;\r\n    rise (msg.sender, lottoVal); //REMT9\r\n  }\r\n\r\n  function rise (address to, uint256 value)\r\n  internal {\r\n    move (address(0), to, value);\r\n    totalSupply += value;\r\n  }\r\n\r\n  function nonced (uint nonce, uint mod)\r\n  internal returns (bool checked) {\r\n    checked = keygen (nonce, randomKey) % mod == randomKey % mod;\r\n    if (checked) randomKey = numgen (nonce, randomKey);\r\n  }\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\ncontract Remt is RemtBase {\r\n\r\n  constructor () public {\r\n    name = \"ULTRA RARE MINEABLE TOKEN WITH NO GOVERNANCE V9\";\r\n    symbol = \"REMT9\";\r\n  }\r\n\r\n  function mine (uint nonce)\r\n  checkTxGasPrice checkBalanceOf public returns (bool success) {\r\n    if (now-STAGE \u003e ANNSEC/2) {\r\n      timeReward /= 2;\r\n      STAGE = now;\r\n    }\r\n    if (blockPayouts[block.number] == 0) {\r\n      if (nonced(nonce,basicRate)) {\r\n        uint interval = now - rewardStamp;\r\n        uint256 reward = timeReward * interval;\r\n        blockPayouts[block.number] += reward;\r\n        if (interval \u003c rewardInterval) {\r\n          rewardInterval *= 2;\r\n          basicRate *= 10;\r\n        }\r\n        rewardStamp = now;\r\n        rise (msg.sender, reward);\r\n      }\r\n      if (nonced(nonce,lottoMod)) {\r\n        blockPayouts[block.number] += lottoVal;\r\n        lottoMod *= 10;\r\n        rise (msg.sender, lottoVal);\r\n      }\r\n    }\r\n    return true;\r\n  } //REMT9\r\n}"}}