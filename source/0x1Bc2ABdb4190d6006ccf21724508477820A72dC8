{"IERC20.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    \r\n    function symbol() external view returns(string memory);\r\n    \r\n    function name() external view returns(string memory);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n    \r\n    /**\r\n     * @dev Returns the number of decimal places\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"},"Ownable.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity 0.8.4;\r\n\r\n/**\r\n * @title Owner\r\n * @dev Set \u0026 change owner\r\n */\r\ncontract Ownable {\r\n\r\n    address private owner;\r\n    \r\n    // event for EVM logging\r\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\r\n    \r\n    // modifier to check if caller is owner\r\n    modifier onlyOwner() {\r\n        // If the first argument of \u0027require\u0027 evaluates to \u0027false\u0027, execution terminates and all\r\n        // changes to the state and to Ether balances are reverted.\r\n        // This used to consume all gas in old EVM versions, but not anymore.\r\n        // It is often a good idea to use \u0027require\u0027 to check if functions are called correctly.\r\n        // As a second argument, you can also provide an explanation about what went wrong.\r\n        require(msg.sender == owner, \"Caller is not owner\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Set contract deployer as owner\r\n     */\r\n    constructor() {\r\n        owner = msg.sender; // \u0027msg.sender\u0027 is sender of current call, contract deployer for a constructor\r\n        emit OwnerSet(address(0), owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Change owner\r\n     * @param newOwner address of new owner\r\n     */\r\n    function changeOwner(address newOwner) public onlyOwner {\r\n        emit OwnerSet(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Return owner address \r\n     * @return address of owner\r\n     */\r\n    function getOwner() external view returns (address) {\r\n        return owner;\r\n    }\r\n}"},"SafeMath.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003c= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003e 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}"},"XUSDMAXI.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\n\r\nimport \"./Ownable.sol\";\r\nimport \"./IERC20.sol\";\r\nimport \"./SafeMath.sol\";\r\n\r\ninterface IFlashBorrower {\r\n    /**\r\n     * @dev Receive a flash loan.\r\n     * @param initiator The initiator of the loan.\r\n     * @param token The loan currency, must be XUSD\r\n     * @param amount The amount of tokens lent.\r\n     * @param fee The additional amount of tokens to repay.\r\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\r\n     * @return The keccak256 hash of \"ERC3156FlashBorrower.onFlashLoan\"\r\n     */\r\n    function onFlashLoan(\r\n        address initiator,\r\n        address token,\r\n        uint256 amount,\r\n        uint256 fee,\r\n        bytes calldata data\r\n    ) external returns (bytes32);\r\n}\r\n\r\ninterface IFlashLender {\r\n    /**\r\n     * @dev The amount of currency available to be lent.\r\n     * @param token The loan currency.\r\n     * @return The amount of `token` that can be borrowed.\r\n     */\r\n    function maxFlashLoan(address token) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev The fee to be charged for a given loan.\r\n     * @param from The wallet borrowing the currency\r\n     * @param amount The amount of tokens lent.\r\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\r\n     */\r\n    function flashFee(address from, uint256 amount) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Initiate a flash loan.\r\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\r\n     * @param amount The amount of tokens lent.\r\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\r\n     */\r\n    function flashLoan(\r\n        IFlashBorrower receiver,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external returns (bool);\r\n}\r\n\r\ninterface IXUSD {\r\n    function burn(uint256 amount) external;\r\n    function resourceCollector() external view returns (address);\r\n    function calculatePrice() external view returns (uint256);\r\n    function mintFee() external view returns (uint256);\r\n}\r\n\r\ncontract XUSDMAXI is Ownable, IERC20, IFlashLender {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    // XUSD Token\r\n    address public constant XUSD = 0x324E8E649A6A3dF817F97CdDBED2b746b62553dD;\r\n\r\n    // Trackable User Info\r\n    struct UserInfo {\r\n        uint256 balance;\r\n        uint256 unlockBlock;\r\n        uint256 totalStaked;\r\n        uint256 totalWithdrawn;\r\n        bool isFlashFeeExempt;\r\n    }\r\n    // User -\u003e UserInfo\r\n    mapping ( address =\u003e UserInfo ) public userInfo;\r\n\r\n    // Unstake Early Fee\r\n    uint256 public leaveEarlyFee = 20;\r\n    uint256 public burnAllocation = 30;\r\n    uint256 public resourceAllocation = 35;\r\n\r\n    // Timer For Leave Early Fee\r\n    uint256 public leaveEarlyFeeTimer = 144000; // 5 days\r\n\r\n    // total supply of XUSD MAXI\r\n    uint256 private _totalSupply;\r\n\r\n    // flash loan fee\r\n    uint256 public flashLoanFee = 50;\r\n    // Callback Success\r\n    bytes32 public constant CALLBACK_SUCCESS = keccak256(\u0027ERC3156FlashBorrower.onFlashLoan\u0027);\r\n\r\n    // precision factor\r\n    uint256 private constant precision = 10**18;\r\n\r\n    // Reentrancy Guard\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status;\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"Reentrancy Guard call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    // Events\r\n    event PriceChange(uint256 previous, uint256 current, uint256 totalMAXISupply);\r\n    event Deposit(address depositor, uint256 amountXUSD);\r\n    event Withdraw(address withdrawer, uint256 amountXUSD);\r\n    event FeeTaken(uint256 fee);\r\n\r\n    constructor(){\r\n        _mint(address(0), 10, 18);      // ensure total supply never reaches 0\r\n        _mint(msg.sender, 10**18, 18 * 10**17);  // send 1...001 XUSD To contract on launch so price starts at 1\r\n        // set reentrancy\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    function name() external pure override returns (string memory) {\r\n        return \"XUSD MAXI\";\r\n    }\r\n    function symbol() external pure override returns (string memory) {\r\n        return \"XUSD MAXI\";\r\n    }\r\n    function decimals() external pure override returns (uint8) {\r\n        return 18;\r\n    }\r\n    function totalSupply() external view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /** Shows The Value In Stable Coins Of Users\u0027 Staked XUSD */\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return ReflectionsFromContractBalance(userInfo[account].balance).mul(XUSDPrice()).div(precision);\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        if (recipient == msg.sender) {\r\n            withdraw(amount);\r\n        }\r\n        return true;\r\n    }\r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        sender;\r\n        if (recipient == msg.sender) {\r\n            withdraw(amount);\r\n        }        \r\n        return true;\r\n    }\r\n    \r\n    function setFlashLoanFee(uint256 fee) external onlyOwner {\r\n        require(\r\n            fee \u003c= 100,\r\n            \u0027Fee Too High\u0027\r\n        );\r\n        flashLoanFee = fee;\r\n    }\r\n    function setLeaveEarlyFee(uint256 newLeaveEarlyFee) external onlyOwner {\r\n        require(\r\n            newLeaveEarlyFee \u003c= 100,\r\n            \u0027Early Fee Too High\u0027\r\n        );\r\n        leaveEarlyFee = newLeaveEarlyFee;\r\n    }\r\n    function setLeaveEarlyFeeTimer(uint256 newLeaveEarlyFeeTimer) external onlyOwner {\r\n        require(\r\n            newLeaveEarlyFeeTimer \u003c= 10**7,\r\n            \u0027Fee Timer Too High\u0027\r\n        );\r\n        leaveEarlyFeeTimer = newLeaveEarlyFeeTimer;\r\n    }\r\n\r\n    function setBurnAllocation(uint burnAllocation_) external onlyOwner {\r\n        require(\r\n            burnAllocation_ + resourceAllocation \u003c 100,\r\n            \u0027Invalid Amount\u0027\r\n        );\r\n        burnAllocation = burnAllocation_;\r\n    }\r\n\r\n    function setResourceAllocation(uint resourceAllocation_) external onlyOwner {\r\n        require(\r\n            burnAllocation + resourceAllocation_ \u003c 100,\r\n            \u0027Invalid Amount\u0027\r\n        );\r\n        resourceAllocation = resourceAllocation_;\r\n    }\r\n\r\n    function setFlashFeeExempt(address user, bool isExempt) external onlyOwner {\r\n        userInfo[user].isFlashFeeExempt = isExempt;\r\n    }\r\n\r\n    function withdrawBNB() external onlyOwner {\r\n        (bool s,) = payable(msg.sender).call{value: address(this).balance}(\"\");\r\n        require(s, \u0027Error On BNB Withdrawal\u0027);\r\n    }\r\n\r\n    function recoverForeignToken(address token) external onlyOwner {\r\n        require(\r\n            token != XUSD,\r\n            \u0027Cannot Withdraw XUSD Tokens\u0027\r\n        );\r\n        require(\r\n            IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this))),\r\n            \u0027Error Withdrawing Foreign Token\u0027\r\n        );\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev The amount of currency available to be lent.\r\n     * @param token The loan currency.\r\n     * @return The amount of `token` that can be borrowed.\r\n     */\r\n    function maxFlashLoan(address token) public view override returns (uint256) {\r\n        return token == XUSD ? IERC20(XUSD).balanceOf(address(this)) : 0;\r\n    }\r\n\r\n    /**\r\n     * @dev The fee to be charged for a given loan.\r\n     * @param from The wallet borrowing the currency\r\n     * @param amount The amount of tokens lent.\r\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\r\n     */\r\n    function flashFee(address from, uint256 amount) public view override returns (uint256) {\r\n        return userInfo[from].isFlashFeeExempt ? 0 : ( amount * flashLoanFee ) / 10**5;\r\n    }\r\n\r\n    /**\r\n     * @dev Initiate a flash loan, borrowing XUSD\r\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\r\n     * @param amount The amount of tokens lent.\r\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\r\n     */\r\n    function flashLoan(\r\n        IFlashBorrower receiver,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external nonReentrant override returns (bool) {\r\n         require(\r\n            amount \u003e 0 \u0026\u0026\r\n            amount \u003c= maxFlashLoan(XUSD),         \r\n            \"Insufficient Borrow Balance\"\r\n        );\r\n        require(\r\n            address(receiver) != address(0),\r\n            \u0027Zero Address\u0027\r\n        );\r\n\r\n        // track price change\r\n        uint oldPrice = _calculatePrice();\r\n\r\n        // calculate fee for loan\r\n        uint256 fee = flashFee(msg.sender, amount);\r\n\r\n        // Amount XUSD Before Loan\r\n        uint256 amountBefore = IERC20(XUSD).balanceOf(address(this));\r\n        \r\n        // XUSD Price before loan\r\n        uint256 xPriceBefore = XUSDPrice();\r\n\r\n        // Send Tokens To Receiver\r\n        require(\r\n            IERC20(XUSD).transfer(\r\n                address(receiver),\r\n                amount\r\n            ),\r\n            \u0027Error on XUSD Transfer\u0027\r\n        );\r\n\r\n        // trigger flash loan\r\n        require(\r\n            receiver.onFlashLoan(msg.sender, XUSD, amount, fee, data) == CALLBACK_SUCCESS,\r\n            \u0027CALLBACK_FAILED\u0027\r\n        );\r\n\r\n        // require more XUSD was returned\r\n        require(\r\n            IERC20(XUSD).balanceOf(address(this)) \u003e= amountBefore + fee,\r\n            \u0027Flash Loan Not Repaid\u0027\r\n        );\r\n\r\n        // take fee if applicable\r\n        if (fee \u003e 0) {\r\n            _takeFee(fee);\r\n        }\r\n\r\n        // get price after fee is taken\r\n        uint256 xPriceAfter = XUSDPrice();\r\n        require(\r\n            xPriceAfter \u003e= xPriceBefore,\r\n            \u0027XUSD Price Must Rise\u0027\r\n        );\r\n        // require price rises\r\n        _requirePriceRises(oldPrice);\r\n        return true;\r\n    }\r\n\r\n    /** BNB Sent To Contract Will Buy And Stake XUSD\r\n        Standard XUSD Mint Rates Still Apply\r\n     */\r\n    receive() external payable {\r\n        require(msg.value \u003e 0, \u0027Zero Value\u0027);\r\n        _onReceive(msg.sender, msg.value);\r\n    }\r\n\r\n    /**\r\n        Transfers in `amount` of XUSD From Sender\r\n        And Locks In Contract, Minting XUSD MAXI Tokens\r\n     */\r\n    function deposit(uint256 amount) external nonReentrant {\r\n\r\n        // track price change\r\n        uint oldPrice = _calculatePrice();\r\n\r\n        // Track Balance Before Deposit\r\n        uint previousBalance = IERC20(XUSD).balanceOf(address(this));\r\n        \r\n        // Transfer In XUSD\r\n        uint received = _transferIn(amount);\r\n\r\n        // Update Previous If First Mint\r\n        previousBalance = previousBalance == 0 ? IERC20(XUSD).balanceOf(address(this)) : previousBalance;\r\n\r\n        // mints correct token amount to sender given data\r\n        _mintTo(msg.sender, received, previousBalance, oldPrice);\r\n    }\r\n\r\n    /**\r\n        Redeems `amount` of USD Tokens, As Seen From BalanceOf()\r\n     */\r\n    function withdraw(uint256 amount) public nonReentrant returns (uint256) {\r\n\r\n        // track price change\r\n        uint oldPrice = _calculatePrice();\r\n\r\n        // XUSD Amount\r\n        uint XUSD_Amount = amount.mul(precision).div(XUSDPrice());\r\n\r\n        // XUSD Amount Into Contract Balance Amount\r\n        uint MAXI_Amount = XUSDToContractBalance(XUSD_Amount);\r\n\r\n        require(\r\n            userInfo[msg.sender].balance \u003e 0 \u0026\u0026\r\n            userInfo[msg.sender].balance \u003e= MAXI_Amount \u0026\u0026\r\n            balanceOf(msg.sender) \u003e= amount \u0026\u0026\r\n            XUSD_Amount \u003e 0 \u0026\u0026\r\n            MAXI_Amount \u003e 0,\r\n            \u0027Insufficient Funds\u0027\r\n        );\r\n\r\n        // burn MAXI Tokens From Sender\r\n        _burn(msg.sender, MAXI_Amount, amount);\r\n\r\n        // increment total withdrawn\r\n        userInfo[msg.sender].totalWithdrawn += XUSD_Amount;\r\n\r\n        // Take Fee If Withdrawn Before Timer\r\n        uint fee = remainingLockTime(msg.sender) == 0 ? 0 : _takeFee(XUSD_Amount.mul(leaveEarlyFee).div(1000));\r\n\r\n        // Send `sendAmount` to recipient, less fees if applicable\r\n        uint256 balLeft = IERC20(XUSD).balanceOf(address(this));\r\n        uint256 toSendRaw = XUSD_Amount.sub(fee).sub(10);\r\n        uint256 sendAmount = toSendRaw \u003c balLeft ? toSendRaw : balLeft;\r\n        require(\r\n            IERC20(XUSD).transfer(msg.sender, sendAmount),\r\n            \u0027Error On Token Transfer\u0027\r\n        );\r\n        // require price rises\r\n        _requirePriceRises(oldPrice);\r\n        emit Withdraw(msg.sender, sendAmount);\r\n        return sendAmount;\r\n    }\r\n\r\n    function _takeFee(uint256 fee) internal returns (uint256) {\r\n\r\n        // XUSD Resource Allocator\r\n        address resourceCollector = IXUSD(XUSD).resourceCollector();\r\n\r\n        // Contribute To XUSD And Reflect The Rest\r\n        uint resourcePortion = ( fee * resourceAllocation ) / 100;\r\n        uint burnPortion     = ( fee * burnAllocation ) / 100;\r\n\r\n        if (resourcePortion \u003e 0 \u0026\u0026 resourceCollector != address(0)) {\r\n            require(\r\n                IERC20(XUSD).transfer(resourceCollector, resourcePortion),\r\n                \u0027Error On Fee Transfer\u0027\r\n            );\r\n        }\r\n        \r\n        if (burnPortion \u003e 0) {\r\n            IXUSD(XUSD).burn(burnPortion);\r\n        }\r\n        emit FeeTaken(fee);\r\n        return fee;\r\n    }\r\n\r\n    function donate() external payable nonReentrant {\r\n        // track price change\r\n        uint oldPrice = _calculatePrice();\r\n\r\n        uint received = _buyXUSD(address(this).balance);\r\n        (uint num, uint denom) = getXUSDMintFee();\r\n        _takeFee(( received * ( num * 2 ) ) / denom);\r\n\r\n        // require price rises\r\n        _requirePriceRises(oldPrice);\r\n    }\r\n\r\n    function _onReceive(address sender, uint value) internal nonReentrant {\r\n        // track price change\r\n        uint oldPrice = _calculatePrice();\r\n\r\n        // Track Balance Before Deposit\r\n        uint previousBalance = IERC20(XUSD).balanceOf(address(this));\r\n\r\n        // mint XUSD\r\n        uint received = _buyXUSD(value);\r\n        (uint num, uint denom) = getXUSDMintFee();\r\n        uint toTrack = received - _takeFee(( received * num ) / denom);\r\n\r\n        // Update Previous If First Mint\r\n        previousBalance = previousBalance == 0 ? IERC20(XUSD).balanceOf(address(this)) : previousBalance;\r\n\r\n        // mints correct token amount to sender given data\r\n        _mintTo(sender, toTrack, previousBalance, oldPrice);\r\n    }\r\n\r\n    function _mintTo(address sender, uint256 received, uint256 previousBalance, uint256 oldPrice) internal {\r\n        // Number Of Maxi Tokens To Mint\r\n        uint nToMint = (_totalSupply.mul(received).div(previousBalance)).sub(10);\r\n        require(\r\n            nToMint \u003e 0,\r\n            \u0027Zero To Mint\u0027\r\n        );\r\n\r\n        // increment total staked\r\n        userInfo[sender].totalStaked += received;\r\n\r\n        // mint MAXI Tokens To Sender\r\n        _mint(sender, nToMint, received.mul(XUSDPrice()).div(precision));\r\n\r\n        // require price rises\r\n        _requirePriceRises(oldPrice);\r\n\r\n        emit Deposit(sender, received);\r\n    }\r\n\r\n    function _buyXUSD(uint amount) internal returns (uint256) {\r\n        require(\r\n            amount \u003e 0,\r\n            \u0027Zero Amount\u0027\r\n        );\r\n        uint before = IERC20(XUSD).balanceOf(address(this));\r\n        (bool s,) = payable(XUSD).call{value: amount}(\"\");\r\n        require(s, \u0027Failure On XUSD Purchase\u0027);\r\n        return IERC20(XUSD).balanceOf(address(this)).sub(before);\r\n    }\r\n\r\n    function _requirePriceRises(uint256 oldPrice) internal {\r\n        // fetch new price\r\n        uint256 newPrice = _calculatePrice();\r\n        // require price rises\r\n        require(\r\n            newPrice \u003e= oldPrice,\r\n            \u0027Price Must Rise\u0027\r\n        );\r\n        // emit event\r\n        emit PriceChange(oldPrice, newPrice, _totalSupply);\r\n    }\r\n\r\n\r\n    function _transferIn(uint256 amount) internal returns (uint256) {\r\n        uint before = IERC20(XUSD).balanceOf(address(this));\r\n        require(\r\n            IERC20(XUSD).transferFrom(msg.sender, address(this), amount),\r\n            \u0027Failure On TransferFrom\u0027\r\n        );\r\n        uint received = IERC20(XUSD).balanceOf(address(this)).sub(before);\r\n        require(\r\n            received \u003c= amount \u0026\u0026 received \u003e 0,\r\n            \u0027Error On Transfer In\u0027\r\n        );\r\n        return received;\r\n    }\r\n\r\n    /**\r\n     * Burns `amount` of Contract Balance Token\r\n     */\r\n    function _burn(address from, uint256 amount, uint256 stablesSent) private {\r\n        userInfo[from].balance = userInfo[from].balance.sub(amount);\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(from, address(0), stablesSent);\r\n    }\r\n\r\n    /**\r\n     * Mints `amount` of Contract Balance Token\r\n     */\r\n    function _mint(address to, uint256 amount, uint256 stablesWorth) private {\r\n        // allocate\r\n        userInfo[to].balance = userInfo[to].balance.add(amount);\r\n        _totalSupply = _totalSupply.add(amount);\r\n        // update locker info\r\n        userInfo[msg.sender].unlockBlock = block.number + leaveEarlyFeeTimer;\r\n        emit Transfer(address(0), to, stablesWorth);\r\n    }\r\n\r\n\r\n    /**\r\n        Converts An XUSD Amount Into An XUSD MAXI Amount\r\n     */\r\n    function XUSDToContractBalance(uint256 amount) public view returns (uint256) {\r\n        return amount.mul(precision).div(_calculatePrice());\r\n    }\r\n\r\n    /**\r\n        Converts An XUSD MAXI Amount Into An XUSD Amount\r\n     */\r\n    function ReflectionsFromContractBalance(uint256 amount) public view returns (uint256) {\r\n        return amount.mul(_calculatePrice()).div(precision);\r\n    }\r\n\r\n    /** Conversion Ratio For MAXI -\u003e XUSD */\r\n    function calculatePrice() external view returns (uint256) {\r\n        return _calculatePrice();\r\n    }\r\n    /**\r\n        Price OF XUSD\r\n     */\r\n    function XUSDPrice() public view returns (uint256) {\r\n        return IXUSD(XUSD).calculatePrice();\r\n    }\r\n    /**\r\n        Lock Time Remaining For Stakers\r\n     */\r\n    function remainingLockTime(address user) public view returns (uint256) {\r\n        return userInfo[user].unlockBlock \u003c block.number ? 0 : userInfo[user].unlockBlock - block.number;\r\n    }\r\n    \r\n    /** Conversion Ratio For MAXI -\u003e XUSD */\r\n    function _calculatePrice() internal view returns (uint256) {\r\n        uint256 backingValue = IERC20(XUSD).balanceOf(address(this));\r\n        return (backingValue.mul(precision)).div(_totalSupply);\r\n    }\r\n\r\n    /**\r\n        Fee Associated With Minting XUSD\r\n     */\r\n    function getXUSDMintFee() public view returns (uint256,uint256) {\r\n        uint denom = 10**5;\r\n        uint mintFee = IXUSD(XUSD).mintFee();\r\n        return (denom - mintFee, denom);\r\n    }\r\n\r\n    /** function has no use in contract */\r\n    function allowance(address holder, address spender) external pure override returns (uint256) { \r\n        holder;\r\n        spender;\r\n        return 0;\r\n    }\r\n    /** function has no use in contract */\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n}"}}