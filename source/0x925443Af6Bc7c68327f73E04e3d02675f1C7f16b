/**
 *Submitted for verification at BscScan.com on 2023-02-01
*/

/**
 *Submitted for verification at BscScan.com on 2022-12-08
*/

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.4;

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _transferOwnership(_msgSender());
    }

    function owner() public view virtual returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

abstract contract ReentrancyGuard {
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    modifier nonReentrant() {
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
        _status = _ENTERED;
        _;

        _status = _NOT_ENTERED;
    }
}

interface IBananaPool {
     struct UserInfo {
        uint256 shares; // How many LP tokens the user has provided.
    }
    function deposit(uint256 _pid, uint256 _wantAmt) external;
    function withdraw(uint256 _pid,uint256 _wantAmt) external;
    function userInfo(
        uint256,
        address
    ) external view returns(UserInfo memory);
}

interface IGnanaPool {
    function deposit(uint256 _amount) external;
    function withdraw(uint256 _amount) external;
}

interface IApeSwapRouter {
    function getAmountsOut(uint amountIn, address[] memory path) external returns (uint[] memory amounts);
    function swapExactETHForTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable returns (uint[] memory amounts);
    function swapExactTokensForETH(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable returns (uint[] memory amounts);
    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint[] memory amounts);
}

interface IApeSwapTreasury {
    function buy(uint _amount) external;
}

interface IMinter {
    function balanceOf(address owner) external returns (uint256);
    function ownerOf(uint256 tokenId) external returns (address);
    function totalSupply() external returns (uint256);
}

interface IDistributor {
    function addDistributionAmount(uint amount) external;
}

interface IBEP20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);
}

interface IStrategy {
    function sharesTotal() external view returns(uint);
}

interface IMasterChef {
    struct UserInfo {
        uint256 amount; // How many tokens the user has provided
        uint256 rewardDebt; // Reward debt. See explanation below
    }
    function userInfo(uint, address) external view returns(UserInfo memory);
}

contract EternalLabsXMainStreetStaker is Ownable, ReentrancyGuard {
    // using SafeMath for uint256;
    uint256 MAX_INT = 2**256 - 1;

    // informative variables
    uint public TOTAL_BNB_RECEIVED = 0;
    uint public TOTAL_BANANA_BOUGHT = 0;
    uint public TOTAL_BANANA_STAKED = 0;
    uint public TOTAL_GNANA_BOUGHT = 0;
    uint public TOTAL_GNANA_STAKED = 0;
    uint public TOTAL_MAINST_BURNED = 0;
    uint public TOTAL_BANANA_DISTRIBUTED = 0;

    uint256 public DISTRIBUTION_PERCENTAGE = 50; // between banana/gnana pools
    // ape vault for banana maximizer
    address public BANANA_POOL = 0x5711a833C943AD1e8312A9c7E5403d48c717e1aa;
    address public MASTERCHEF = 0x71354AC3c695dfB1d3f595AfA5D4364e9e06339B;
    address public STRATEGY = 0xaE9eD266Ea3d7Ae83CaD8fA3B143D3dc86B640bF;
    address public GNANA_POOL = 0x8F97B2E6559084CFaBA140e2AB4Da9aAF23FE7F8;
    address public APESWAP_ROUTER = 0xcF0feBd3f17CEf5b47b0cD257aCf6025c5BFf3b7; 
    address public MINTER = 0xa36c806c13851F8B27780753563fdDAA6566f996; 
    address public DISTRIBUTOR = 0x589671DC5A75f552d81A903C027Ee0E3FB1fDbc3;
    address public BOUNTY = 0xA97F7EB14da5568153Ea06b2656ccF7c338d942f; // mock address
    address public WRAPPED_BNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
    address public BANANA_TOKEN = 0x603c7f932ED1fc6575303D8Fb018fDCBb0f39a95;
    address public GNANA_TOKEN = 0xdDb3Bd8645775F59496c821E4F55A7eA6A6dc299;
    address public APESWAP_TREASURY = 0xec4b9d1fd8A3534E31fcE1636c7479BcD29213aE;
    address payable public ETERNALLABS_TREASURY = payable(0xA97F7EB14da5568153Ea06b2656ccF7c338d942f);
    address payable public FUNDING_WALLET = payable(0xA97F7EB14da5568153Ea06b2656ccF7c338d942f);
    address public MAINST_TOKEN = 0x8FC1A944c149762B6b578A06c0de2ABd6b7d2B89;

    uint public FUNDING_WALLET_PERCENTAGE = 2;
    uint public ETERNALLABS_PERCENTAGE = 2;
    uint public BOUNTY_PERCENTAGE = 40;
    uint public BANANA_REINVEST_PERCENTAGE = 5;
    uint public GNANA_REINVEST_PERCENTAGE = 5;
    uint public MAINST_BURN_PERCENTAGE = 2;
    uint public MAINST_TO_BURN = 0;

    bool public HARVEST_BANANA = true;
    bool public HARVEST_GNANA = true;

    constructor() {}

    function setHarvestBanana(bool set) public onlyOwner() {
        HARVEST_BANANA = set;
    }

    function setHarvestGnana(bool set) public onlyOwner() {
        HARVEST_GNANA = set;
    }

    function setBananaReinvestPercentage(uint _percent) public onlyOwner() {
        BANANA_REINVEST_PERCENTAGE = _percent;
    }

    function setGnanaReinvestPercentage(uint _percent) public onlyOwner() {
        GNANA_REINVEST_PERCENTAGE = _percent;
    }

    function setMainstBurnPercentage(uint _percent) public onlyOwner() {
        MAINST_BURN_PERCENTAGE = _percent;
    }

    function setFundingWallet(address payable _address) public onlyOwner() {
        FUNDING_WALLET = _address;
    }

    function setEternalLabsTreasury(address payable _address) public onlyOwner() {
        ETERNALLABS_TREASURY = _address;
    }

    function setMinterAddress(address minter) public onlyOwner {
        MINTER = minter;
    }

    function setDistributorAddress(address distributor) public onlyOwner {
        DISTRIBUTOR = distributor;
    }

    function setBountyAddress(address bounty) public onlyOwner {
        BOUNTY = bounty;
    }

    function setFundingWalletPercentage(uint _percent) public onlyOwner {
        FUNDING_WALLET_PERCENTAGE = _percent;
    }

    function setEternalLabsPercentage(uint _percent) public onlyOwner {
        ETERNALLABS_PERCENTAGE = _percent;
    }

    function changeBananaPoolAddress(address newBananaPoolAddress) public onlyOwner() {
        BANANA_POOL = newBananaPoolAddress;
    }

    function changeGananaPoolAddress(address newGananaPoolAddress) public onlyOwner() {
        GNANA_POOL = newGananaPoolAddress;
    }

    // distribution percentage between BANANA and GNANA pools
    function setDistributionPercentage(uint percentage) public onlyOwner() {
        require(percentage > 0 && percentage <= 100, "percentage should be between 1-100");
        DISTRIBUTION_PERCENTAGE = percentage;
    }

    function calculateBananaDistribution(uint bananaAmount) public view returns(uint[] memory _amounts) {
        uint forBananaPool = (bananaAmount / 100) * DISTRIBUTION_PERCENTAGE;
        uint forGananaPool = bananaAmount - forBananaPool;
        uint[] memory amounts = new uint[](2);
        amounts[0] = forBananaPool;
        amounts[1] = forGananaPool;
        return amounts;
    }

    function buyBanana(uint forBNBAmount) private returns(uint boughtBananaAmount) {
        address[] memory path = new address[](2);
        path[0] = WRAPPED_BNB;
        path[1] = BANANA_TOKEN;
        uint[] memory bananaAmountsOut = IApeSwapRouter(APESWAP_ROUTER).getAmountsOut(forBNBAmount, path);
        uint[] memory amounts = IApeSwapRouter(APESWAP_ROUTER).swapExactETHForTokens{value : forBNBAmount}(
            bananaAmountsOut[1],
            path,
            address(this),
            block.timestamp + 100
        );
        return amounts[1];
    }

    function buyGanana(uint forBananaAmount) private {
        IApeSwapTreasury(APESWAP_TREASURY).buy(forBananaAmount);
    }

    function stakeBanana(uint bananaToStake) private {
        IBananaPool(BANANA_POOL).deposit(41, bananaToStake);
    }

    // stake remaining banana if there is any or if contract is redeployed
    function stakeRemainingBanana() public onlyOwner() {
        uint remainingBanana = IBEP20(BANANA_TOKEN).balanceOf(address(this));
        IBananaPool(BANANA_POOL).deposit(41, remainingBanana);
        TOTAL_BANANA_STAKED += remainingBanana;
    }

    // stake remaining ganana if any or if contract is redeployed
    function stakeRemainingGnana() public onlyOwner() {
        uint gnanaToStake = IBEP20(GNANA_TOKEN).balanceOf(address(this));
        IGnanaPool(GNANA_POOL).deposit(gnanaToStake);
        TOTAL_GNANA_STAKED += gnanaToStake;
    }
    // withdraws whole amount of banana
    function harvestBanana() public {
        uint totalStaked = bananaStaked();
        if (totalStaked > TOTAL_BANANA_STAKED) {
            IBananaPool(BANANA_POOL).withdraw(41, totalStaked - TOTAL_BANANA_STAKED);
        }
    }

    function withdrawBanana(uint amount) public onlyOwner() {
        IBananaPool(BANANA_POOL).withdraw(41, amount);
        IBEP20(BANANA_TOKEN).transfer(msg.sender, IBEP20(BANANA_TOKEN).balanceOf(address(this)));
    }

    function withdrawLeftOverBanana() public onlyOwner() {
        IBEP20(BANANA_TOKEN).transfer(msg.sender, IBEP20(BANANA_TOKEN).balanceOf(address(this)));
    }

    function stakeGanana() private {
        IGnanaPool(GNANA_POOL).deposit(IBEP20(GNANA_TOKEN).balanceOf(address(this)));
    }

    function harvestGnana() private {
        IGnanaPool(GNANA_POOL).withdraw(0);
    }

    function withdrawGnana(uint _amount) public onlyOwner() {
        IGnanaPool(GNANA_POOL).withdraw(_amount);
        IBEP20(GNANA_TOKEN).transfer(msg.sender, IBEP20(GNANA_TOKEN).balanceOf(address(this)));
    }

    function withdrawLeftOverGnana() public onlyOwner() {
        IBEP20(GNANA_TOKEN).transfer(msg.sender, IBEP20(GNANA_TOKEN).balanceOf(address(this)));
    }

    function deposit() external payable nonReentrant() {
        TOTAL_BNB_RECEIVED += msg.value;
        uint bananaBought = buyBanana(msg.value);
        TOTAL_BANANA_BOUGHT += bananaBought;
        uint[] memory bananaDistribution = calculateBananaDistribution(bananaBought);
        stakeBanana(bananaDistribution[0]);
        buyGanana(bananaDistribution[1]);
        stakeGanana();
    }

    function bananaStaked() public view returns(uint) {
        uint256 userShares = IBananaPool(BANANA_POOL).userInfo(41, address(this)).shares;
        uint256 totalShares = IStrategy(STRATEGY).sharesTotal();
        uint256 userPercentage = (userShares * 10000000000) / totalShares;
        uint256 totalBananaStaked = IMasterChef(MASTERCHEF).userInfo(0, STRATEGY).amount;
        return (totalBananaStaked / 10000000000) * userPercentage;
    }

    function compound(address claimant) public nonReentrant() {
        require(msg.sender == BOUNTY || msg.sender == owner(), "MM: not bounty");
        if (HARVEST_BANANA) {
            harvestBanana();
        }
        if (HARVEST_GNANA) {
            harvestGnana();
        }
        uint totalBananaBalance = IBEP20(BANANA_TOKEN).balanceOf(address(this));
        if (BANANA_REINVEST_PERCENTAGE > 0) {
            uint bananaToReInvest = (totalBananaBalance / 100) * BANANA_REINVEST_PERCENTAGE; 
            TOTAL_BANANA_STAKED += bananaToReInvest;
            stakeBanana(bananaToReInvest);
        }
        if (GNANA_REINVEST_PERCENTAGE > 0) {
            buyGanana((totalBananaBalance / 100) * GNANA_REINVEST_PERCENTAGE);
            stakeGanana();
        }
        IBEP20(BANANA_TOKEN).transfer(claimant, (totalBananaBalance / 100) * BOUNTY_PERCENTAGE);
        IBEP20(BANANA_TOKEN).transfer(FUNDING_WALLET, (totalBananaBalance / 100) * FUNDING_WALLET_PERCENTAGE);
        IBEP20(BANANA_TOKEN).transfer(ETERNALLABS_TREASURY, (totalBananaBalance / 100) * ETERNALLABS_PERCENTAGE);
        uint mainstToBurn = (totalBananaBalance / 100) * MAINST_BURN_PERCENTAGE; 
        MAINST_TO_BURN += mainstToBurn;
        uint toDistribute = IBEP20(BANANA_TOKEN).balanceOf(address(this)) - mainstToBurn;
        IBEP20(MAINST_TOKEN).transfer(DISTRIBUTOR, toDistribute);
        IDistributor(DISTRIBUTOR).addDistributionAmount(toDistribute);
    }

    function fundWallet(uint bananaAmount) private returns(uint boughtBNB){
        address[] memory path = new address[](2);
        path[0] = BANANA_TOKEN;
        path[1] = WRAPPED_BNB;
        uint[] memory bnbAmountsOut = IApeSwapRouter(APESWAP_ROUTER).getAmountsOut(bananaAmount, path);
        uint[] memory amounts = IApeSwapRouter(APESWAP_ROUTER).swapExactTokensForETH(
            bananaAmount,
            bnbAmountsOut[1],
            path,
            msg.sender,
            block.timestamp + 100
        );
        return amounts[1];
    }

    function buyBackMainstreet(uint bananaAmount) private returns(uint mainstPurchased) {
        address[] memory path = new address[](3);
        path[0] = BANANA_TOKEN;
        path[1] = WRAPPED_BNB;
        path[2] = MAINST_TOKEN;
        uint[] memory mainstAmountsOut = IApeSwapRouter(APESWAP_ROUTER).getAmountsOut(bananaAmount, path);
        uint slippage = (mainstAmountsOut[2] / 100) * 12;
        IApeSwapRouter(APESWAP_ROUTER).swapExactTokensForTokens(
            bananaAmount,
            mainstAmountsOut[2] - slippage,
            path,
            address(this),
            block.timestamp + 100
        );
        return IBEP20(MAINST_TOKEN).balanceOf(address(this));
    }

    function burnMainst() public {
        uint amount = buyBackMainstreet(MAINST_TO_BURN);
        IBEP20(MAINST_TOKEN).transfer(0x000000000000000000000000000000000000dEaD, amount);
        TOTAL_MAINST_BURNED += amount;
        MAINST_TO_BURN = 0;
    }

    function withdrawRemainingMainstreet() public onlyOwner() {
        IBEP20(MAINST_TOKEN).transfer(msg.sender, IBEP20(MAINST_TOKEN).balanceOf(address(this)));
    }

    function getBananaApproved() public onlyOwner() {
        IBEP20(BANANA_TOKEN).approve(BANANA_POOL, MAX_INT);
        IBEP20(BANANA_TOKEN).approve(APESWAP_ROUTER, MAX_INT);
    }

    function getGnanaApproved() public onlyOwner() {
        IBEP20(GNANA_TOKEN).approve(GNANA_POOL, MAX_INT);
        IBEP20(BANANA_TOKEN).approve(APESWAP_TREASURY, MAX_INT); 
    }

    fallback() external payable { }
    
    receive() external payable { }
}