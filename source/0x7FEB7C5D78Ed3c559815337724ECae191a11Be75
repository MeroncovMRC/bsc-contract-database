{"IERC20.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\ninterface IERC20 {\n\n    function totalSupply() external view returns (uint256);\n    \n    function symbol() external view returns(string memory);\n    \n    function name() external view returns(string memory);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n    \n    /**\n     * @dev Returns the number of decimal places\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"},"LPTokenLocker.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"./IERC20.sol\";\n\ncontract TokenLocker {\n    \n    // Locker Unit\n    struct Locker {\n        uint256 numTokensLocked;\n        uint256 lastClaim;\n    }\n    \n    // Data\n    address public constant token = 0xF754817A9609cCf288fDc853F17B2B8D7b6F79FF;\n    uint256 public constant allowance = 5; // 0.5% per week\n    uint256 public constant claimWait = 200000;\n    address public constant marketing = 0xE0A243eb9169256936C505a162478f5988A6fb85;\n    \n    // User -\u003e Locker\n    mapping (address =\u003e Locker) users;\n    \n    // events\n    event Locked(address from, uint256 numberTokens);\n    event Claim(address from, uint256 numTokens);\n    \n    // claim\n    function claim() external {\n        \n        // number of tokens to unlock\n        uint256 numTokens = users[msg.sender].numTokensLocked;\n        require(numTokens \u003e 0, \u0027No Tokens Locked\u0027);\n        require(users[msg.sender].lastClaim + claimWait \u003c= block.number, \u0027Not Time To Claim\u0027);\n        // amount to send back\n        uint256 amount = (numTokens * allowance) / 10**3;\n        // update times\n        users[msg.sender].lastClaim = block.number;\n        users[msg.sender].numTokensLocked -= amount;\n        // transfer locked tokens to sender\n        bool s = IERC20(token).transfer(msg.sender, amount);\n        require(s, \u0027transfer failure\u0027);\n        emit Claim(msg.sender, numTokens);\n    }\n\n    // lock\n    function lock(uint256 numberTokens) external {\n        \n        uint256 diff = _transferInTokens(numberTokens);\n        require(diff \u003e 0, \u0027Zero Tokens Received\u0027);\n        \n        users[marketing].numTokensLocked += diff;\n        if (msg.sender == marketing) {\n            users[marketing].lastClaim = block.number;\n        }\n        \n        emit Locked(msg.sender, numberTokens);\n    }\n    \n    function getTimeTillClaim(address user) external view returns (uint256) {\n        return block.number \u003c= (users[user].lastClaim + claimWait) ? 0 : (block.number - (users[user].lastClaim + claimWait));\n    }\n    \n    function tokensLockedForUser(address user) external view returns (uint256) {\n        return users[user].numTokensLocked;\n    }\n    \n    function _transferInTokens(uint256 tokenAmount) internal returns (uint256) {\n        uint256 before = IERC20(token).balanceOf(address(this));\n        bool success = IERC20(token).transferFrom(msg.sender, address(this), tokenAmount);\n        require(success, \u0027Failure on Transfer From\u0027);\n        return IERC20(token).balanceOf(address(this)) - before;\n    }\n    \n}\n\n"}}