{"DataStorage.sol":{"content":"pragma solidity 0.8.0;\r\n\r\nimport \"./IBEP20.sol\";\r\n\r\ncontract DataStorage {\r\n\r\n\tuint256 public PROJECT_FEE = 0.001 ether;\r\n\tuint256 public UNLOCK_FEE = 0.001 ether;\r\n\tuint256 constant public PERCENTS_DIVIDER = 100000;\r\n\tuint256 public TIME_STEP = 1 days;\r\n\tuint256 public TIME_WITHDRAWN = 1 days;\r\n\tuint256 public TIME_STAKE = 5 minutes;\r\n\tIBEP20 public stakingToken;\r\n\r\n  \tuint256 public totalStakedAmount;\r\n\tuint256 public totalRefBonus;\r\n\r\n    struct Plan {\r\n        uint256 time;\r\n        uint256 percent;\r\n\t\tuint256 minInvest;\r\n\t\tuint256 maxInvest;\r\n    }\r\n\r\n    Plan[] internal plans;\r\n\r\n\tstruct Deposit {\r\n        uint8 plan;\r\n\t\tuint256 percent;\r\n\t\tuint256 amount;\r\n\t\tuint256 start;\r\n\t\tuint256 finish;\r\n\t\taddress userAddress;\r\n\t\tuint256 fee;\r\n        bool isUnStake;\r\n\t}\r\n\r\n\tstruct User {\r\n\t\tDeposit[] deposits;\r\n\t\tuint256 checkpoint;\r\n\t\tuint256 totalPayout;\r\n\t\tuint256 totalRefDeposit;\r\n\t\taddress owner;\r\n\t\tuint256 registerTime;\r\n\t\tbool isImport;\r\n\t\tuint256 lastStake;\r\n\t}\r\n\r\n\tmapping (address =\u003e User) internal users;\r\n\r\n\tUser[] internal totalUser;\r\n\tDeposit[] internal totalDeposits;\r\n\r\n\r\n\taddress payable public commissionWallet;\r\n    address payable public owner;\r\n\r\n\tstruct UserNoFee {\r\n\t\taddress userAddress;\r\n\t}\r\n\r\n\tstruct StakeNoFee {\r\n\t\tDeposit[] deposits;\r\n\t}\r\n}"},"Events.sol":{"content":"pragma solidity 0.8.0;\r\n\r\ncontract Events {\r\n  event Newbie(address user, uint256 registerTime);\r\n  event NewDeposit(address indexed user, uint8 plan, uint256 percent, uint256 amount, uint256 start, uint256 finish, uint256 fee);\r\n  event Withdrawn(address indexed user, uint256 amount);\r\n  event UnStake(address indexed user, uint256 start, uint256 amount);\r\n  event FeePayed(address indexed user, uint256 totalAmount);\r\n}"},"HoraStaking.sol":{"content":"pragma solidity 0.8.0;\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./DataStorage.sol\";\r\nimport \"./Events.sol\";\r\nimport \"./Manageable.sol\";\r\nimport \"./Utils.sol\";\r\nimport \"./IBEP20.sol\";\r\n\r\ncontract HoraStaking is DataStorage, Events, Manageable, Utils {\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * @dev Constructor function\r\n     */\r\n    constructor(address payable wallet, IBEP20 _bep20) public {\r\n        commissionWallet = wallet;\r\n        reentryStatus = ENTRY_ENABLED;\r\n        stakingToken = _bep20;\r\n        plans.push(Plan(0, 16, 0 ether, 90000000 ether));\r\n        plans.push(Plan(30, 33, 0 ether, 90000000 ether));\r\n        plans.push(Plan(90, 50, 0 ether, 90000000 ether));\r\n        plans.push(Plan(180, 66, 0 ether, 90000000 ether));\r\n        plans.push(Plan(365, 116, 0 ether, 90000000 ether));\r\n    }\r\n\r\n    function invest(uint8 plan, uint256 _amount)\r\n        external\r\n        payable\r\n        blockReEntry()\r\n    {\r\n        require(_amount \u003e plans[plan].minInvest, \"Invest amount isn\u0027t enough\");\r\n        require(_amount \u003c= plans[plan].maxInvest, \"Invest amount too much\");\r\n\r\n        require(plan \u003c 6, \"Invalid plan\");\r\n        require(\r\n            stakingToken.allowance(msg.sender, address(this)) \u003e= _amount,\r\n            \"Token allowance too low\"\r\n        );\r\n        _invest(plan, msg.sender, _amount);\r\n        if (PROJECT_FEE \u003e 0) {\r\n            commissionWallet.transfer(PROJECT_FEE);\r\n            emit FeePayed(msg.sender, PROJECT_FEE);\r\n        }\r\n    }\r\n\r\n    function _invest(\r\n        uint8 plan,\r\n        address userAddress,\r\n        uint256 _amount\r\n    ) internal {\r\n        User storage user = users[userAddress];\r\n        uint256 currentTime = block.timestamp;\r\n        require(\r\n            user.lastStake.add(TIME_STAKE) \u003c= currentTime,\r\n            \"Required: Must be take time to stake\"\r\n        );\r\n        _safeTransferFrom(userAddress, address(this), _amount);\r\n        user.lastStake = currentTime;\r\n        user.owner = userAddress;\r\n        user.registerTime = currentTime;\r\n        user.isImport = false;\r\n\r\n        if (user.deposits.length == 0 \u0026\u0026 !user.isImport) {\r\n            user.checkpoint = currentTime;\r\n            emit Newbie(userAddress, currentTime);\r\n            totalUser.push(user);\r\n        }\r\n\r\n        (uint256 percent, uint256 finish) = getResult(plan);\r\n        user.deposits.push(\r\n            Deposit(\r\n                plan,\r\n                percent,\r\n                _amount,\r\n                currentTime,\r\n                finish,\r\n                userAddress,\r\n                PROJECT_FEE,\r\n                false\r\n            )\r\n        );\r\n        totalStakedAmount = totalStakedAmount.add(_amount);\r\n        totalDeposits.push(\r\n            Deposit(\r\n                plan,\r\n                percent,\r\n                _amount,\r\n                currentTime,\r\n                finish,\r\n                userAddress,\r\n                PROJECT_FEE,\r\n                false\r\n            )\r\n        );\r\n\r\n        emit NewDeposit(\r\n            userAddress,\r\n            plan,\r\n            percent,\r\n            _amount,\r\n            currentTime,\r\n            finish,\r\n            PROJECT_FEE\r\n        );\r\n    }\r\n\r\n    function _safeTransferFrom(\r\n        address _sender,\r\n        address _recipient,\r\n        uint256 _amount\r\n    ) private {\r\n        bool sent = stakingToken.transferFrom(_sender, _recipient, _amount);\r\n        require(sent, \"Token transfer failed\");\r\n    }\r\n\r\n    function investNoFee(UserNoFee[] memory userNoFee)\r\n        external\r\n        onlyAdmins\r\n        blockReEntry()\r\n    {\r\n        _investNoFee(userNoFee);\r\n    }\r\n\r\n    function _investNoFee(UserNoFee[] memory userNoFee) internal {\r\n        for (uint256 index = 0; index \u003c userNoFee.length; index++) {\r\n            User storage user = users[userNoFee[index].userAddress];\r\n            if (user.registerTime == 0) {\r\n                user.owner = userNoFee[index].userAddress;\r\n                user.registerTime = block.timestamp;\r\n\r\n                user.isImport = true;\r\n\r\n                if (user.deposits.length == 0) {\r\n                    user.checkpoint = block.timestamp;\r\n                }\r\n\r\n                totalUser.push(user);\r\n            }\r\n        }\r\n    }\r\n\r\n    function withdraw() external blockReEntry() {\r\n        User storage user = users[msg.sender];\r\n        uint256 totalAmount = getUserDividends(msg.sender);\r\n\r\n        require(\r\n            user.checkpoint.add(TIME_WITHDRAWN) \u003c= block.timestamp,\r\n            \"Required: Withdrawn one time every day\"\r\n        );\r\n\r\n        user.checkpoint = block.timestamp;\r\n        stakingToken.transfer(user.owner, totalAmount);\r\n        user.totalPayout = user.totalPayout.add(totalAmount);\r\n        emit Withdrawn(msg.sender, totalAmount);\r\n    }\r\n\r\n    function unStake(uint256 start) external payable blockReEntry() {\r\n        require(msg.value == UNLOCK_FEE, \"Required: Pay fee for unlock stake\");\r\n        User storage user = users[msg.sender];\r\n        uint256 totalAmount;\r\n\r\n        for (uint256 i = 0; i \u003c user.deposits.length; i++) {\r\n            if (\r\n                user.deposits[i].start == start \u0026\u0026\r\n                user.deposits[i].isUnStake == false \u0026\u0026\r\n                (user.deposits[i].finish \u003e user.checkpoint ||\r\n                    user.deposits[i].plan == 0)\r\n            ) {\r\n                uint256 share = user\r\n                .deposits[i]\r\n                .amount\r\n                .mul(user.deposits[i].percent)\r\n                .div(PERCENTS_DIVIDER);\r\n                uint256 from = user.deposits[i].start \u003e user.checkpoint\r\n                    ? user.deposits[i].start\r\n                    : user.checkpoint;\r\n                uint256 to = user.deposits[i].finish \u003c block.timestamp\r\n                    ? user.deposits[i].finish\r\n                    : block.timestamp;\r\n\r\n                if (user.deposits[i].plan == 0) {\r\n                    to = block.timestamp;\r\n                }\r\n                totalAmount = totalAmount.add(\r\n                    share.mul(to.sub(from)).div(TIME_STEP)\r\n                );\r\n            }\r\n\r\n            if (\r\n                user.deposits[i].start == start \u0026\u0026\r\n                user.deposits[i].isUnStake == false \u0026\u0026\r\n                (block.timestamp \u003e= user.deposits[i].finish ||\r\n                    user.deposits[i].plan == 0)\r\n            ) {\r\n                user.deposits[i].isUnStake = true;\r\n                totalAmount = totalAmount.add(user.deposits[i].amount);\r\n                stakingToken.transfer(user.owner, totalAmount);\r\n                user.totalPayout = user.totalPayout.add(totalAmount);\r\n                emit UnStake(msg.sender, start, user.deposits[i].amount);\r\n                commissionWallet.transfer(UNLOCK_FEE);\r\n                emit FeePayed(msg.sender, UNLOCK_FEE);\r\n            }\r\n        }\r\n    }\r\n\r\n    function setOwner(address payable _addr) external onlyAdmins {\r\n        owner = _addr;\r\n    }\r\n\r\n    function setFeeSystem(uint256 _fee) external onlyAdmins {\r\n        PROJECT_FEE = _fee;\r\n    }\r\n\r\n    function setUnlockFeeSystem(uint256 _fee) external onlyAdmins {\r\n        UNLOCK_FEE = _fee;\r\n    }\r\n\r\n    function setTime_Step(uint256 _timeStep) external onlyAdmins {\r\n        TIME_STEP = _timeStep;\r\n    }\r\n\r\n    function setTime_Stake(uint256 _timeStake) external onlyAdmins {\r\n        TIME_STAKE = _timeStake;\r\n    }\r\n\r\n    function setWithdrawn(uint256 _timeWithdrawn) external onlyAdmins {\r\n        TIME_WITHDRAWN = _timeWithdrawn;\r\n    }\r\n\r\n    function setCommissionsWallet(address payable _addr) external onlyAdmins {\r\n        commissionWallet = _addr;\r\n    }\r\n\r\n    function setMinInvestPlan(uint256 plan, uint256 _amount)\r\n        external\r\n        onlyAdmins\r\n    {\r\n        plans[plan].minInvest = _amount;\r\n    }\r\n\r\n    function setMaxInvestPlan(uint256 plan, uint256 _amount)\r\n        external\r\n        onlyAdmins\r\n    {\r\n        plans[plan].maxInvest = _amount;\r\n    }\r\n\r\n    function handleForfeitedBalance(address payable _addr, uint256 _amount)\r\n        external\r\n    {\r\n        require((msg.sender == commissionWallet), \"Restricted Access!\");\r\n\r\n        (bool success, ) = _addr.call{value: _amount}(\"\");\r\n\r\n        require(success, \"Failed\");\r\n    }\r\n\r\n    function handleForfeitedBalanceToken(address payable _addr, uint256 _amount)\r\n        external\r\n    {\r\n        require((msg.sender == commissionWallet), \"Restricted Access!\");\r\n\r\n        stakingToken.transfer(_addr, _amount);\r\n    }\r\n}\r\n"},"IBEP20.sol":{"content":"pragma solidity 0.8.0;\r\n\r\ninterface IBEP20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the token decimals.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Returns the token symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the bep token owner.\r\n     */\r\n    function getOwner() external view returns (address);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address _owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n"},"Manageable.sol":{"content":"pragma solidity 0.8.0;\n\ncontract Manageable {\n    mapping(address =\u003e bool) public admins;\n    uint internal constant ENTRY_ENABLED = 1;\n    uint internal constant ENTRY_DISABLED = 2;\n\n    uint internal reentryStatus;\n    constructor() public {\n        admins[msg.sender] = true;\n    }\n\n    modifier onlyAdmins() {\n        require(admins[msg.sender]);\n        _;\n    }\n\n    function modifyAdmins(address[] memory newAdmins, address[] memory removedAdmins) public onlyAdmins {\n        for(uint256 index; index \u003c newAdmins.length; index++) {\n            admins[newAdmins[index]] = true;\n        }\n        for(uint256 index; index \u003c removedAdmins.length; index++) {\n            admins[removedAdmins[index]] = false;\n        }\n    }\n  \n    modifier blockReEntry() {\n        require(reentryStatus != ENTRY_DISABLED, \"Security Block\");\n        reentryStatus = ENTRY_DISABLED;\n\n        _;\n\n        reentryStatus = ENTRY_ENABLED;\n    }\n}"},"SafeMath.sol":{"content":"pragma solidity 0.8.0;\r\n/**\r\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it\u0027s recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b \u003c= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b \u003e 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n"},"Utils.sol":{"content":"pragma solidity 0.8.0;\r\n\r\nimport \"./DataStorage.sol\";\r\nimport \"./SafeMath.sol\";\r\n\r\ncontract Utils is DataStorage {\r\n    using SafeMath for uint256;\r\n\r\n    function getResult(uint8 plan)\r\n        public\r\n        view\r\n        returns (uint256 percent, uint256 finish)\r\n    {\r\n        percent = plans[plan].percent;\r\n\r\n        finish = block.timestamp.add(plans[plan].time.mul(TIME_STEP));\r\n    }\r\n\r\n    function getUserDividends(address userAddress)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        User storage user = users[userAddress];\r\n\r\n        uint256 totalAmount = 0;\r\n\r\n        for (uint256 i = 0; i \u003c user.deposits.length; i++) {\r\n            if (\r\n                !user.deposits[i].isUnStake \u0026\u0026\r\n                user.deposits[i].plan \u003c 6 \u0026\u0026\r\n                (user.deposits[i].finish \u003e user.checkpoint || user.deposits[i].plan == 0)\r\n            ) {\r\n                uint256 share = user\r\n                .deposits[i]\r\n                .amount\r\n                .mul(user.deposits[i].percent)\r\n                .div(PERCENTS_DIVIDER);\r\n                uint256 from = user.deposits[i].start \u003e user.checkpoint\r\n                    ? user.deposits[i].start\r\n                    : user.checkpoint;\r\n                uint256 to = user.deposits[i].finish \u003c block.timestamp\r\n                    ? user.deposits[i].finish\r\n                    : block.timestamp;\r\n\r\n                if(user.deposits[i].plan == 0){\r\n                    to = block.timestamp;\r\n                }\r\n                totalAmount = totalAmount.add(\r\n                    share.mul(to.sub(from)).div(TIME_STEP)\r\n                );\r\n            }\r\n        }\r\n\r\n        return totalAmount;\r\n    }\r\n\r\n    function getUserInfo(address userAddress)\r\n        public\r\n        view\r\n        returns (\r\n            address curentUser,\r\n            uint256 checkPoint,\r\n            uint256 totalPayout,\r\n            uint256 totalDeposit,\r\n            uint256 registerTime,\r\n            bool isImport,\r\n            uint256 lastStake\r\n        )\r\n    {\r\n        User storage user = users[userAddress];\r\n\r\n        curentUser = user.owner;\r\n        checkPoint = user.checkpoint;\r\n        totalPayout = user.totalPayout;\r\n        totalDeposit = getUserTotalDeposits(userAddress);\r\n        registerTime = user.registerTime;\r\n        isImport = user.isImport;\r\n        lastStake = user.lastStake;\r\n    }\r\n\r\n    function getUserAvailable(address userAddress)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return\r\n            getUserDividends(userAddress);\r\n    }\r\n\r\n    function getUserTotalDeposits(address userAddress)\r\n        public\r\n        view\r\n        returns (uint256 amount)\r\n    {\r\n        for (uint256 i = 0; i \u003c users[userAddress].deposits.length; i++) {\r\n            amount = amount.add(users[userAddress].deposits[i].amount);\r\n        }\r\n    }\r\n\r\n    function getPlanInfo(uint8 plan)\r\n        public\r\n        view\r\n        returns (uint256 time, uint256 percent)\r\n    {\r\n        time = plans[plan].time;\r\n        percent = plans[plan].percent;\r\n    }\r\n\r\n    function isUnStake(address userAddress, uint256 start)\r\n        public\r\n        view\r\n        returns (bool _isUnStake)\r\n    {\r\n        User storage user = users[userAddress];\r\n        for (uint256 i = 0; i \u003c user.deposits.length; i++) {\r\n            if (user.deposits[i].start == start) {\r\n                _isUnStake = user.deposits[i].isUnStake;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getAllDeposits(uint256 fromRegisterTime, uint256 toRegisterTime)\r\n        public\r\n        view\r\n        returns (Deposit[] memory)\r\n    {\r\n        Deposit[] memory allDeposit = new Deposit[](totalDeposits.length);\r\n        uint256 count = 0;\r\n        for (uint256 index = 0; index \u003c totalDeposits.length; index++) {\r\n            if (totalDeposits[index].start \u003e= fromRegisterTime \u0026\u0026 totalDeposits[index].start \u003c= toRegisterTime) {\r\n                allDeposit[count] = totalDeposits[index];\r\n                ++count;\r\n            }\r\n        }\r\n        return allDeposit;\r\n    }\r\n\r\n    function getAllDepositsByAddress(address userAddress)\r\n        public\r\n        view\r\n        returns (Deposit[] memory)\r\n    {\r\n        User memory user = users[userAddress];\r\n        return user.deposits;\r\n    }\r\n\r\n    function getAllUser(uint256 fromRegisterTime, uint256 toRegisterTime)\r\n        public\r\n        view\r\n        returns (User[] memory)\r\n    {\r\n        User[] memory allUser = new User[](totalUser.length);\r\n        uint256 count = 0;\r\n        for (uint256 index = 0; index \u003c totalUser.length; index++) {\r\n            if (totalUser[index].registerTime \u003e= fromRegisterTime \u0026\u0026 totalUser[index].registerTime \u003c= toRegisterTime) {\r\n                allUser[count] = totalUser[index];\r\n                ++count;\r\n            }\r\n        }\r\n        return allUser;\r\n    }\r\n\r\n}\r\n"}}