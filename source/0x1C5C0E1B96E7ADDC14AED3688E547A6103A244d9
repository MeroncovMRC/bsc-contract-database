
// File: /contracts/Router1.sol
// SPDX-License-Identifier: Unlicensed

import "@pancakeswap/pancake-contracts/interfaces/IBEP20.sol";
import "@pancakeswap-libs/pancake-swap-core/contracts/interfaces/IPancakeFactory.sol";
import "@pancakeswap-libs/pancake-swap-core/contracts/interfaces/IPancakePair.sol";
import "@pancakeswap/pancake-contracts/interfaces/IPancakeRouter02.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Address.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

pragma solidity ^0.8.19;

contract BRT is Context, IBEP20, Ownable, ReentrancyGuard {
    using Address for address;

    // Mappings
    mapping(address => uint256) private _rOwned;
    mapping(address => uint256) private _tOwned;
    mapping(address => mapping(address => uint256)) private _allowances;
    mapping(address => bool) private _isExcludedFromFee;
    mapping(address => bool) private _isExcluded;
    mapping(address => bool) public _isExcludedFromAntiWhale;
    mapping(address => bool) private _AddressExists;
    mapping(address => bool) private _isExcludedFromLottery;

    // Address arrays
    address[] private _addressList;
    address[] private _excluded;

    // Lottery related variables
    address private _lottoPotAddress;
    address private _lottoWalletAddress;
    uint256 public _lastLottoWinnerAmount;
    uint256 public _totalLottoPrize;
    uint public _lottoDrawCount;

    // Fee related variables
    uint256 public maxIterations;
    uint256[] private fees;
    uint256[] private previousFees;
    uint256 private constant MAX = ~uint256(0);
    uint256 private _tTotal = 28 * 10 ** 6 * 10 ** DECIMALS;
    uint256 private _rTotal = (MAX - (MAX % _tTotal));
    uint256 private _minLottoBalance = 28 * 10 ** 3 * 10 ** DECIMALS;
    uint256 public _maxTxAmount = 28 * 10 ** 6 * 10 ** DECIMALS;
    uint256 public constant MAX_ALLOWED_FEE = 1500;

    // Liquidity related variables
    uint256 private numTokensSellToAddToLiquidity;
    uint256 private numTokensSellToAddToLiquidityTrigger;

    // Threshold related variables
    uint256 public lotteryThreshold = 28 * 10 ** 2 * 10 ** DECIMALS;
    uint256 public _AntiWhaleThreshold = 28 * 10 ** 4 * 10 ** DECIMALS;

    // Wallet addresses
    address payable private _exchangeWallet;
    address payable private _teamWallet;
    address payable private _marketingAsiaWallet;
    address payable private _marketingAfricaWallet;
    address payable private _marketingNorthAmericaWallet;
    address payable private _marketingSouthAmericaWallet;
    address payable private _marketingAntarcticaWallet;
    address payable private _marketingEuropeWallet;
    address payable private _marketingAustraliaWallet;
    address payable private _devWallet;
    address payable private _lottoWallet;

    // Pancake related variables
    IPancakeRouter02 public pancakeRouter;
    IPancakePair public pancakePair;

    // Boolean flags
    bool public _isAntiWhaleEnabled = true;
    bool public swapAndLiquifyEnabled = true;
    bool public lottoEnabled = true;
    bool private inSwapAndLiquify;
    bool inLotteryDraw;
    bool private _callSwapAndLiquify = true;

    // Token details
    string private _name = "BridgesReunited";
    string private _symbol = "BRT";
    uint8 constant DECIMALS = 9;

    // FeeType enum
    enum FeeType {
        _LiquidityFee,
        _LottoFee,
        _DevFee,
        _TeamFee,
        _ExchangeFee,
        _MarketingAsiaFee,
        _MarketingAfricaFee,
        _MarketingNorthAmericaFee,
        _MarketingSouthAmericaFee,
        _MarketingAntarcticaFee,
        _MarketingEuropeFee,
        _MarketingAustraliaFee
    }

    // Structs
    struct TData {
        uint256 tAmount;
        BridgesMarketingData marketingData;
        BridgesTeamData teamData;
        BridgesSystemData systemData;
        uint256 currentRate;
    }

    struct BridgesMarketingData {
        uint256[7] fees; // An array to store the marketing fees
    }

    struct BridgesTeamData {
        uint256[3] fees; // An array to store the team fees
    }

    struct BridgesSystemData {
        uint256[2] fees; // An array to store the system fees
    }

    // Events
    event NumTokensSellToAddToLiquidityUpdated(
        uint256 newNumTokensSellToAddToLiquidity
    );
    event NumTokensSellToAddToLiquidityUpdatedTrigger(
        uint256 newNumTokensSellToAddToLiquidity
    );
    event SwapAndLiquifyEnabledUpdated(bool enabled);
    event DrawLotto(uint256 amount, uint _lottoDrawCount);
    event SkippedDrawLotto(uint256 lottoBalance, uint256 lotteryThreshold);

    event SwapAndLiquify(
        uint256 tokensSwapped,
        uint256 ethReceived,
        uint256 tokensIntoLiqudity
    );
    event TokensWithdrawn(
        address tokenAddress,
        address recipient,
        uint256 amount
    );

    // Modifiers
    modifier lockTheSwap() {
        inSwapAndLiquify = true;
        _;
        inSwapAndLiquify = false;
    }

    modifier lockTheLottery() {
        inLotteryDraw = true;
        _;
        inLotteryDraw = false;
    }

    constructor() {
        // Set initial owner reflection and add address
        _rOwned[_msgSender()] = _rTotal;
        addAddress(_msgSender());

        // Initialize lotto pot address
        _lottoPotAddress = address(1);

        // Set up PancakeRouter
        IPancakeRouter02 _pancakeRouter = IPancakeRouter02(
            0x10ED43C718714eb63d5aA57B78B54704E256024E
        );
        address pancakePairAddress = IPancakeFactory(_pancakeRouter.factory())
            .createPair(address(this), _pancakeRouter.WETH());
        pancakePair = IPancakePair(pancakePairAddress);
        pancakeRouter = _pancakeRouter;

        // Exclude owner, lotto pot and contract from fees
        _isExcludedFromFee[owner()] = true;
        _isExcludedFromFee[_lottoPotAddress] = true;
        _isExcludedFromFee[address(this)] = true;

        // Exclude owner, lotto pot, contract, router, and pair from AntiWhale
        _isExcludedFromAntiWhale[owner()] = true;
        _isExcludedFromAntiWhale[_lottoPotAddress] = true;
        _isExcludedFromAntiWhale[address(this)] = true;
        _isExcludedFromAntiWhale[address(pancakeRouter)] = true;
        _isExcludedFromAntiWhale[address(pancakePair)] = true;

        // Set max iterations and token sale limits
        maxIterations = 1;
        numTokensSellToAddToLiquidity = 14 * 10 ** 6 * 10 ** DECIMALS;
        numTokensSellToAddToLiquidityTrigger = 4 * 10 ** 4 * 10 ** DECIMALS;
        lotteryThreshold = 28 * 10 ** 2 * 10 ** DECIMALS;

        // Initialize fees
        _initializeFees();


        // Emit initial transfer event
        emit Transfer(address(0), _msgSender(), _tTotal);
    }


    //-------------------------------------------------------------------------
    //Token-related Functions
    //-------------------------------------------------------------------------


    /**
     * @dev Approves the specified amount of tokens to the specified spender.
     * @param owner The owner of the tokens.
     * @param spender The spender to approve for spending the tokens.
     * @param amount The amount of tokens to approve.
     */
    function _approve(address owner, address spender, uint256 amount) private {
        // Make sure the owner and spender addresses are not zero
        require(owner != address(0) && spender != address(0), "Err");
        // Set the allowance for the specified owner and spender
        _allowances[owner][spender] = amount;
        // Emit an Approval event
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Gets the current total supply of tokens.
     * @return rSupply The current supply of reflected tokens.
     * @return tSupply The current supply of total tokens.
     */
    function _getCurrentSupply()
        private
        view
        returns (uint256 rSupply, uint256 tSupply)
    {
        // Start with the total supply
        rSupply = _rTotal;
        tSupply = _tTotal;
        // Subtract the balances of all excluded addresses
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (
                _rOwned[_excluded[i]] > rSupply ||
                _tOwned[_excluded[i]] > tSupply
            ) {
                return (_rTotal, _tTotal);
            }
            rSupply -= _rOwned[_excluded[i]];
            tSupply -= _tOwned[_excluded[i]];
        }
        // Check if the remaining reflected supply is less than the minimum possible value
        if (rSupply < _rTotal / _tTotal) {
            return (_rTotal, _tTotal);
        }
        // Return the remaining supply values
        return (rSupply, tSupply);
    }
    /**
    // Returns values needed for the transfer
    // @param tAmount The transfer amount
    // @return rAmount The converted amount for the recipient
    // @return rTransferAmount The converted transfer amount
    // @return tTransferAmount The transfer amount minus fees
    // @return systemData The system fee data
    // @return teamData The team fee data
    // @return marketingData The marketing fee data
     */
    function _getValues(
        uint256 tAmount
    )
        private
        view
        returns (
            uint256,
            uint256,
            uint256,
            BridgesSystemData memory,
            BridgesTeamData memory,
            BridgesMarketingData memory
        )
    {
        // Get transfer values
        uint256 tTransferAmount = _getTValues(tAmount);
        uint256 currentRate = _getRate();
        uint256 rAmount = _calculateRValue(tAmount, currentRate);
        uint256 rTransferAmount = _calculateRValue(
            tTransferAmount,
            currentRate
        );

        // Get fee data
        BridgesSystemData memory systemData = _getSystemValues(tAmount);
        BridgesTeamData memory teamData = _getTeamValues(tAmount);
        BridgesMarketingData memory marketingData = _getMarketingValues(
            tAmount
        );

        // Return all necessary data
        return (
            rAmount,
            rTransferAmount,
            tTransferAmount,
            systemData,
            teamData,
            marketingData
        );
    }

    /**
     * @dev This method is responsible for taking all fees, if takeFee is true. It chooses the appropriate transfer method based on whether the sender and recipient are excluded from reward.
     * @param sender The address of the sender
     * @param recipient The address of the recipient
     * @param amount The amount of tokens to transfer
     * @param takeFee Boolean indicating whether or not to take fees
     */
    function _tokenTransfer(
        address sender,
        address recipient,
        uint256 amount,
        bool takeFee
    ) private {
        if (!takeFee) removeAllFee();

        if (_isExcluded[sender] && !_isExcluded[recipient]) {
            // Transfer from excluded
            _transferFromExcluded(sender, recipient, amount);
        } else if (!_isExcluded[sender] && _isExcluded[recipient]) {
            // Transfer to excluded
            _transferToExcluded(sender, recipient, amount);
        } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {
            // Standard transfer
            _transferStandard(sender, recipient, amount);
        } else if (_isExcluded[sender] && _isExcluded[recipient]) {
            // Transfer between excluded
            _transferBothExcluded(sender, recipient, amount);
        } else {
            // Standard transfer
            _transferStandard(sender, recipient, amount);
        }

        if (!takeFee) restoreAllFee();
    }

    /**
     * @dev Transfers the specified amount of tokens from one address to another.
     * @param from The address to transfer tokens from.
     * @param to The address to transfer tokens to.
     * @param amount The amount of tokens to transfer.
     */
    function _transfer(address from, address to, uint256 amount) private {
        // Make sure the from and to addresses are not zero
        require(from != address(0), "BEP20: transfer from the zero address");
        require(to != address(0), "BEP20: transfer to the zero address");
        // Make sure the transfer amount is greater than zero
        require(amount > 0, "Transfer amount must be greater than zero");
        // If the transaction is not initiated by the owner, make sure the transfer amount does not exceed the maximum allowed transaction amount
        if (from != owner() && to != owner()) {
            require(
                amount <= _maxTxAmount,
                "Transfer amount exceeds the maxTxAmount."
            );
        }

        // Check if the contract token balance is greater than or equal to the maximum allowed transaction amount
        uint256 contractTokenBalance = balanceOf(address(this));
        if (contractTokenBalance >= _maxTxAmount) {
            contractTokenBalance = _maxTxAmount;
        }

        // Check if the contract token balance is greater than or equal to the minimum number of tokens to sell to add liquidity and if the lottery balance is greater than or equal to the lottery threshold
        bool overMinTokenBalance = contractTokenBalance >=
            numTokensSellToAddToLiquidity;
        uint256 lottoBalance = balanceOf(_lottoPotAddress);
        bool overMinLottoBalance = lottoBalance >= lotteryThreshold;

        // If both conditions are met, decide whether to call the swapAndLiquify or drawLotto function based on the `_callSwapAndLiquify` variable
        if (overMinTokenBalance && overMinLottoBalance) {
            if (_callSwapAndLiquify) {
                if (
                    !inSwapAndLiquify &&
                    from != address(pancakePair) &&
                    swapAndLiquifyEnabled
                ) {
                    // If not currently in swapAndLiquify function and the transaction is not initiated by the PancakeSwap pair contract and swapAndLiquify is enabled, call the swapAndLiquify function with the specified number of tokens to sell
                    contractTokenBalance = numTokensSellToAddToLiquidity;
                    swapAndLiquify(contractTokenBalance);
                }
            } else {
                // If not currently in lottery draw and lotto is enabled, call the drawLotto function
                if (!inLotteryDraw && lottoEnabled) {
                    drawLotto();
                }
            }
            // Toggle the `_callSwapAndLiquify` variable
            _callSwapAndLiquify = !_callSwapAndLiquify;
        } else if (
            overMinTokenBalance &&
            !inSwapAndLiquify &&
            from != address(pancakePair) &&
            swapAndLiquifyEnabled
        ) {
            // If the contract token balance is greater than or equal to the minimum number of tokens to sell to add liquidity, and not currently in swapAndLiquify function, the transaction is not initiated by the PancakeSwap pair contract, and swapAndLiquify is enabled, call the swapAndLiquify function with the specified number of tokens to sell
            contractTokenBalance = numTokensSellToAddToLiquidity;
            swapAndLiquify(contractTokenBalance);
        } else if (overMinLottoBalance && !inLotteryDraw && lottoEnabled) {
            // If the lottery balance is greater than or equal to the lottery threshold, and not currently in lottery draw, and lotto is enabled, call the drawLotto function
            drawLotto();
        }

        // If anti-whale feature is enabled and the recipient is not excluded from anti-whale, perform anti-whale check
        if (_isAntiWhaleEnabled && !_isExcludedFromAntiWhale[to]) {
            if (from == address(pancakePair) && to != address(pancakeRouter)) {
                // If the transaction is initiated by the PancakeSwap pair contract and the recipient is not PancakeSwap router contract, make sure the transfer amount and recipient's balance do not exceed the anti-whale threshold
                require(
                    amount <= _AntiWhaleThreshold,
                    "Anti whale: can't buy more than the specified threshold"
                );
                require(
                    balanceOf(to) + amount <= _AntiWhaleThreshold,
                    "Anti whale: can't hold more than the specified threshold"
                );
            }
        }

        // By default, take fee
        bool takeFee = true;

        // If either the sender or the recipient is excluded from fee, do not take fee
        if (_isExcludedFromFee[from] || _isExcludedFromFee[to]) {
            takeFee = false;
        }

        // Add sender and recipient to the address list
        addAddress(from);
        addAddress(to);

        // Transfer tokens, take fee if necessary
        _tokenTransfer(from, to, amount, takeFee);
    }

    /**
     * @dev Transfer tokens from sender to recipient with fee deductions for system, marketing, and team.
     * @param sender The address of the sender.
     * @param recipient The address of the recipient.
     * @param tAmount The amount of tokens to transfer.
     */
    function _transferBothExcluded(
        address sender,
        address recipient,
        uint256 tAmount
    ) private {
        // Get the necessary values for transfer.
        (
            uint256 rAmount,
            uint256 rTransferAmount,
            uint256 tTransferAmount,
            BridgesSystemData memory systemData,
            BridgesTeamData memory teamData,
            BridgesMarketingData memory marketingData
        ) = _getValues(tAmount);

        // Subtract the transferred amount from the sender's balance.
        _tOwned[sender] -= tAmount;
        _rOwned[sender] -= rAmount;

        // Add the transferred amount to the recipient's balance.
        _tOwned[recipient] += tTransferAmount;
        _rOwned[recipient] += rTransferAmount;

        // Take system and lottery fees.
        _takeFees(
            address(this),
            systemData.fees[0],
            _isExcluded[address(this)]
        );
        _takeFees(
            _lottoPotAddress,
            systemData.fees[1],
            _isExcluded[_lottoPotAddress]
        );

        // Take marketing and team fees.
        _takeMarketingFees(marketingData);
        _takeTeamFees(teamData);

        // Emit transfer event.
        emit Transfer(sender, recipient, tTransferAmount);
    }

    /**
     * @dev Returns the number of decimals used by the token.
     * @return The number of decimals used by the token as a uint8.
     */
    function decimals() external pure returns (uint8) {
        return DECIMALS;
    }

    /**
     * @dev Fallback function to receive BNB.
     */
    receive() external payable {}

    /**
     * @dev Converts an amount of tokens to the corresponding amount of reflections.
     * @param tAmount The amount of tokens to convert.
     * @param deductTransferFee A boolean indicating whether the transfer fee should be deducted.
     * @return The corresponding amount of reflections as a uint256.
     */
    function reflectionFromToken(
        uint256 tAmount,
        bool deductTransferFee
    ) private view returns (uint256) {
        require(tAmount <= _tTotal, "Amount must be less than supply");
        if (!deductTransferFee) {
            (uint256 rAmount, , , , , ) = _getValues(tAmount);
            return rAmount;
        } else {
            (, uint256 rTransferAmount, , , , ) = _getValues(tAmount);
            return rTransferAmount;
        }
    }

    /**
     * @dev Gets the current exchange rate.
     * @return The current exchange rate.
     */
    function _getRate() private view returns (uint256) {
        // Get the current supply of reflected and total tokens
        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();
        // Calculate and return the exchange rate
        return rSupply / tSupply;
    }

    /**
     * @dev Adds an address to the list of existing addresses.
     * @param adr The address to add.
     */
    function addAddress(address adr) private {
        // If the address already exists, return
        if (_AddressExists[adr]) {
            return;
        }
        // Otherwise, add the address to the list and mark it as existing
        _AddressExists[adr] = true;
        _addressList.push(adr);
    }


    //-------------------------------------------------------------------------
    // Fees-related Functions
    //-------------------------------------------------------------------------

   /**
     * @dev Initializes the fees array and previousFees array.
     *      Sets default values for all fees.
     */
     function _initializeFees() private {
        // Initialize fees array with length 12 (for all 12 fees)
        fees = new uint256[](12);
        // Initialize previousFees array with length 12
        previousFees = new uint256[](12);

        // Set initial values for all fees
        fees[uint256(FeeType._LiquidityFee)] = 400;
        fees[uint256(FeeType._LottoFee)] = 100;
        fees[uint256(FeeType._DevFee)] = 100;
        fees[uint256(FeeType._TeamFee)] = 50;
        fees[uint256(FeeType._ExchangeFee)] = 50;
        fees[uint256(FeeType._MarketingAsiaFee)] = 50;
        fees[uint256(FeeType._MarketingAfricaFee)] = 20;
        fees[uint256(FeeType._MarketingNorthAmericaFee)] = 10;
        fees[uint256(FeeType._MarketingSouthAmericaFee)] = 10;
        fees[uint256(FeeType._MarketingAntarcticaFee)] = 10;
        fees[uint256(FeeType._MarketingEuropeFee)] = 50;
        fees[uint256(FeeType._MarketingAustraliaFee)] = 50;

        // Set previousFees array to the same initial values as fees array
        for (uint256 i = 0; i < fees.length; i++) {
            previousFees[i] = fees[i];
        }
    }
    /**
     * @dev Calculates the R value by multiplying the total value with the current rate.
     * @param tValue The total value to calculate the R value for.
     * @param currentRate The current exchange rate.
     * @return The R value.
     */
    function _calculateRValue(
        uint256 tValue,
        uint256 currentRate
    ) private pure returns (uint256) {
        return tValue * currentRate;
    }

    /**
     * @dev Calculates the marketing fees for the given transaction amount.
     * @param tAmount The transaction amount.
     * @return BridgesMarketingData The struct containing the calculated marketing fees.
     */
    function _getMarketingValues(
        uint256 tAmount
    ) private view returns (BridgesMarketingData memory) {
        uint256[7] memory marketingFees = [
            calculateFee(tAmount, FeeType._MarketingAsiaFee),
            calculateFee(tAmount, FeeType._MarketingAfricaFee),
            calculateFee(tAmount, FeeType._MarketingNorthAmericaFee),
            calculateFee(tAmount, FeeType._MarketingSouthAmericaFee),
            calculateFee(tAmount, FeeType._MarketingAntarcticaFee),
            calculateFee(tAmount, FeeType._MarketingEuropeFee),
            calculateFee(tAmount, FeeType._MarketingAustraliaFee)
        ];

        BridgesMarketingData memory marketingData = BridgesMarketingData({
            fees: marketingFees
        });

        return marketingData;
    }

    // Returns system fee values for the given transfer amount
    // @param tAmount The transfer amount
    // @return BridgesSystemData The system fee data
    function _getSystemValues(
        uint256 tAmount
    ) private view returns (BridgesSystemData memory) {
        // Calculate system fees for liquidity and lottery fees
        uint256[2] memory systemFees = [
            calculateFee(tAmount, FeeType._LiquidityFee),
            calculateFee(tAmount, FeeType._LottoFee)
        ];

        // Store system fee data in a struct
        BridgesSystemData memory systemData = BridgesSystemData({
            fees: systemFees
        });

        // Return system fee data
        return systemData;
    }

    /**
     * @dev Returns the transfer amount minus all fees
     * @param tAmount The transfer amount
     * @return The transfer amount minus all fees
     */
    function _getTValues(uint256 tAmount) private view returns (uint256) {
        // Get fee data for system, team, and marketing fees
        BridgesSystemData memory systemData = _getSystemValues(tAmount);
        BridgesTeamData memory teamData = _getTeamValues(tAmount);
        BridgesMarketingData memory marketingData = _getMarketingValues(
            tAmount
        );

        // Calculate total fees for system, team, and marketing fees
        uint256 totalSystemFees = _getTotalSystemFees(systemData);
        uint256 totalTeamFees = _getTotalTeamFees(teamData);
        uint256 totalMarketingFees = _getTotalMarketingFees(marketingData);

        // Calculate total fees
        uint256 totalFees = totalSystemFees +
            totalTeamFees +
            totalMarketingFees;

        // Calculate transfer amount minus fees
        uint256 tTransferAmount = tAmount - totalFees;

        // Return transfer amount minus fees
        return tTransferAmount;
    }

    // Returns team fee values for the given transfer amount
    // @param tAmount The transfer amount
    // @return BridgesTeamData The team fee data
    function _getTeamValues(
        uint256 tAmount
    ) private view returns (BridgesTeamData memory) {
        // Calculate team fees for developer, exchange, and team fees
        uint256[3] memory teamFees = [
            calculateFee(tAmount, FeeType._DevFee),
            calculateFee(tAmount, FeeType._ExchangeFee),
            calculateFee(tAmount, FeeType._TeamFee)
        ];

        // Store team fee data in a struct
        BridgesTeamData memory teamData = BridgesTeamData({fees: teamFees});

        // Return team fee data
        return teamData;
    }

    /**
     * @dev Returns the total marketing fees
     * @param marketingData The marketing fee data
     * @return The total marketing fees
     */
    function _getTotalMarketingFees(
        BridgesMarketingData memory marketingData
    ) private pure returns (uint256) {
        // Calculate total marketing fees by summing all marketing fees
        return
            marketingData.fees[0] +
            marketingData.fees[1] +
            marketingData.fees[2] +
            marketingData.fees[3] +
            marketingData.fees[4] +
            marketingData.fees[5] +
            marketingData.fees[6];
    }

    /**
     * @dev Returns the total system fees
     * @param systemData The system fee data
     * @return The total system fees
     */
    function _getTotalSystemFees(
        BridgesSystemData memory systemData
    ) private pure returns (uint256) {
        // Calculate total system fees by summing liquidity and lottery fees
        return systemData.fees[0] + systemData.fees[1];
    }

    /**
     * @dev Returns the total team fees
     * @param teamData The team fee data
     * @return The total team fees
     */
    function _getTotalTeamFees(
        BridgesTeamData memory teamData
    ) private pure returns (uint256) {
        // Calculate total team fees by summing developer, exchange, and team fees
        return teamData.fees[0] + teamData.fees[1] + teamData.fees[2];
    }

    /**
     * @dev Calculates the R values for the transfer
     * @param tAmount The transfer amount
     * @param currentRate The current exchange rate
     * @param systemData The system fee data
     * @param teamData The team fee data
     * @param marketingData The marketing fee data
     * @return The R values for the transfer
     */
    function _getRValues(
        uint256 tAmount,
        uint256 currentRate,
        BridgesSystemData memory systemData,
        BridgesTeamData memory teamData,
        BridgesMarketingData memory marketingData
    ) private pure returns (uint256, uint256) {
        // Calculate R values for each fee
        uint256 rAmount = _calculateRValue(tAmount, currentRate);
        uint256 rLiquidity = _calculateRValue(systemData.fees[0], currentRate);
        uint256 rLotto = _calculateRValue(systemData.fees[1], currentRate);
        uint256 rDev = _calculateRValue(teamData.fees[0], currentRate);
        uint256 rTeam = _calculateRValue(teamData.fees[1], currentRate);
        uint256 rExchange = _calculateRValue(teamData.fees[2], currentRate);
        uint256 rMarketingAsia = _calculateRValue(
            marketingData.fees[0],
            currentRate
        );
        uint256 rMarketingAfrica = _calculateRValue(
            marketingData.fees[1],
            currentRate
        );
        uint256 rMarketingNorthAmerica = _calculateRValue(
            marketingData.fees[2],
            currentRate
        );
        uint256 rMarketingSouthAmerica = _calculateRValue(
            marketingData.fees[3],
            currentRate
        );
        uint256 rMarketingAntarctica = _calculateRValue(
            marketingData.fees[4],
            currentRate
        );
        uint256 rMarketingEurope = _calculateRValue(
            marketingData.fees[5],
            currentRate
        );
        uint256 rMarketingAustralia = _calculateRValue(
            marketingData.fees[6],
            currentRate
        );

        // Calculate R transfer amount by subtracting all fee R values from total R value
        uint256 rTransferAmount = rAmount -
            rLiquidity -
            rLotto -
            rDev -
            rTeam -
            rExchange -
            rMarketingAsia -
            rMarketingAfrica -
            rMarketingNorthAmerica -
            rMarketingSouthAmerica -
            rMarketingAntarctica -
            rMarketingEurope -
            rMarketingAustralia;

        // Return R values for the transfer
        return (rAmount, rTransferAmount);
    }
  
    /**
     * @dev Sets all fees to zero by iterating through the `fees` array and setting non-zero values to zero.
     * Stores the previous non-zero fees in the `previousFees` array.
     */
    function removeAllFee() private {
        for (uint256 i = 0; i < fees.length; i++) {
            // If the fee is already zero, skip to the next iteration
            if (fees[i] == 0) {
                continue;
            }

            // Store the previous non-zero fee value
            previousFees[i] = fees[i];
            // Set the current fee to zero
            fees[i] = 0;
        }
    }

    /**
     * @dev Restores all previously set fees by iterating through the `fees` array and setting the values to the corresponding values in the `previousFees` array.
     */
    function restoreAllFee() private {
        for (uint256 i = 0; i < fees.length; i++) {
            // Set the current fee to its previous non-zero value
            fees[i] = previousFees[i];
        }
    }

    /**
     * @dev Takes the specified fee from the transaction and adds it to the specified wallet's balance.
     * @param wallet The wallet to add the fee to.
     * @param fee The fee amount to take.
     * @param isExcluded True if the wallet is excluded from reflections, false otherwise.
     */
    function _takeFees(address wallet, uint256 fee, bool isExcluded) private {
        // Calculate the current exchange rate
        uint256 currentRate = _getRate();
        // Calculate the reflected fee amount
        uint256 rFee = fee * currentRate;

        // Add the reflected fee amount to the specified wallet's balance
        _rOwned[wallet] += rFee;
        // If the wallet is excluded from reflections, add the actual fee amount to its balance as well
        if (isExcluded) {
            _tOwned[wallet] += fee;
        }
    }

    /**
     * @dev Takes marketing fees from the transaction and transfers them to the appropriate wallets.
     * @param marketingData The data struct containing the marketing fees.
     */
    function _takeMarketingFees(
        BridgesMarketingData memory marketingData
    ) private {
        // Transfer marketing fees to each marketing wallet
        _takeFees(
            _marketingAsiaWallet,
            marketingData.fees[0],
            _isExcluded[_marketingAsiaWallet]
        );
        _takeFees(
            _marketingAfricaWallet,
            marketingData.fees[1],
            _isExcluded[_marketingAfricaWallet]
        );
        _takeFees(
            _marketingNorthAmericaWallet,
            marketingData.fees[2],
            _isExcluded[_marketingNorthAmericaWallet]
        );
        _takeFees(
            _marketingSouthAmericaWallet,
            marketingData.fees[3],
            _isExcluded[_marketingSouthAmericaWallet]
        );
        _takeFees(
            _marketingAntarcticaWallet,
            marketingData.fees[4],
            _isExcluded[_marketingAntarcticaWallet]
        );
        _takeFees(
            _marketingEuropeWallet,
            marketingData.fees[5],
            _isExcluded[_marketingEuropeWallet]
        );
        _takeFees(
            _marketingAustraliaWallet,
            marketingData.fees[6],
            _isExcluded[_marketingAustraliaWallet]
        );
    }

    /**
     * @dev Takes team fees from the transaction and transfers them to the appropriate wallets.
     * @param teamData The data struct containing the team fees.
     */
    function _takeTeamFees(BridgesTeamData memory teamData) private {
        // Transfer team fees to each team wallet
        _takeFees(_devWallet, teamData.fees[0], _isExcluded[_devWallet]);
        _takeFees(
            _exchangeWallet,
            teamData.fees[1],
            _isExcluded[_exchangeWallet]
        );
        _takeFees(_teamWallet, teamData.fees[2], _isExcluded[_teamWallet]);
    }

    /**
     * @dev Calculates the specified fee amount for the given token amount and fee type.
     * @param _amount The token amount to calculate the fee for.
     * @param feeType The type of fee to calculate.
     * @return The calculated fee amount.
     */
    function calculateFee(
        uint256 _amount,
        FeeType feeType
    ) private view returns (uint256) {
        return (_amount * fees[uint256(feeType)]) / 10 ** 4;
    }

    /**
     * @dev Transfer tokens from one address to another with fees and redistribution
     * @param sender The address sending the tokens
     * @param recipient The address receiving the tokens
     * @param tAmount The amount of tokens to transfer
     */
    function _transferStandard(
        address sender,
        address recipient,
        uint256 tAmount
    ) private {
        // Get the amount of reflection tokens and transfer tokens based on the current rate
        (
            uint256 rAmount,
            uint256 rTransferAmount,
            uint256 tTransferAmount,
            BridgesSystemData memory systemData,
            BridgesTeamData memory teamData,
            BridgesMarketingData memory marketingData
        ) = _getValues(tAmount);

        // Subtract reflection tokens from sender and add to recipient
        _rOwned[sender] -= rAmount;
        _rOwned[recipient] += rTransferAmount;

        // Take fees from each fee recipient and distribute them to holders and the lottery pot
        _takeFees(
            address(this),
            systemData.fees[0],
            _isExcluded[address(this)]
        );
        _takeFees(
            _lottoPotAddress,
            systemData.fees[1],
            _isExcluded[_lottoPotAddress]
        );
        _takeFees(
            _marketingAsiaWallet,
            marketingData.fees[0],
            _isExcluded[_marketingAsiaWallet]
        );
        _takeFees(
            _marketingAfricaWallet,
            marketingData.fees[1],
            _isExcluded[_marketingAfricaWallet]
        );
        _takeFees(
            _marketingNorthAmericaWallet,
            marketingData.fees[2],
            _isExcluded[_marketingNorthAmericaWallet]
        );
        _takeFees(
            _marketingSouthAmericaWallet,
            marketingData.fees[3],
            _isExcluded[_marketingSouthAmericaWallet]
        );
        _takeFees(
            _marketingAntarcticaWallet,
            marketingData.fees[4],
            _isExcluded[_marketingAntarcticaWallet]
        );
        _takeFees(
            _marketingEuropeWallet,
            marketingData.fees[5],
            _isExcluded[_marketingEuropeWallet]
        );
        _takeFees(
            _marketingAustraliaWallet,
            marketingData.fees[6],
            _isExcluded[_marketingAustraliaWallet]
        );
        _takeFees(_devWallet, teamData.fees[0], _isExcluded[_devWallet]);
        _takeFees(
            _exchangeWallet,
            teamData.fees[1],
            _isExcluded[_exchangeWallet]
        );
        _takeFees(_teamWallet, teamData.fees[2], _isExcluded[_teamWallet]);

        // Emit Transfer event
        emit Transfer(sender, recipient, tTransferAmount);
    }

    /**
     * @dev Transfer tokens from sender to recipient when recipient is an excluded address
     * @param sender The address sending tokens
     * @param recipient The excluded address receiving tokens
     * @param tAmount The amount of tokens to transfer
     */
    function _transferToExcluded(
        address sender,
        address recipient,
        uint256 tAmount
    ) private {
        (
            uint256 rAmount,
            uint256 rTransferAmount,
            uint256 tTransferAmount,
            BridgesSystemData memory systemData,
            BridgesTeamData memory teamData,
            BridgesMarketingData memory marketingData
        ) = _getValues(tAmount);

        // Reduce the sender's reflected balance by the reflected amount of tokens
        _rOwned[sender] -= rAmount;

        // Add the transferred amount of tokens to the recipient's token balance
        _tOwned[recipient] += tTransferAmount;

        // Add the reflected transfer amount of tokens to the recipient's reflected balance
        _rOwned[recipient] += rTransferAmount;

        // Take fees
        _takeFees(
            address(this),
            systemData.fees[0],
            _isExcluded[address(this)]
        );
        _takeFees(
            _lottoPotAddress,
            systemData.fees[1],
            _isExcluded[_lottoPotAddress]
        );
        _takeFees(
            _marketingAsiaWallet,
            marketingData.fees[0],
            _isExcluded[_marketingAsiaWallet]
        );
        _takeFees(
            _marketingAfricaWallet,
            marketingData.fees[1],
            _isExcluded[_marketingAfricaWallet]
        );
        _takeFees(
            _marketingNorthAmericaWallet,
            marketingData.fees[2],
            _isExcluded[_marketingNorthAmericaWallet]
        );
        _takeFees(
            _marketingSouthAmericaWallet,
            marketingData.fees[3],
            _isExcluded[_marketingSouthAmericaWallet]
        );
        _takeFees(
            _marketingAntarcticaWallet,
            marketingData.fees[4],
            _isExcluded[_marketingAntarcticaWallet]
        );
        _takeFees(
            _marketingEuropeWallet,
            marketingData.fees[5],
            _isExcluded[_marketingEuropeWallet]
        );
        _takeFees(
            _marketingAustraliaWallet,
            marketingData.fees[6],
            _isExcluded[_marketingAustraliaWallet]
        );
        _takeFees(_devWallet, teamData.fees[0], _isExcluded[_devWallet]);
        _takeFees(
            _exchangeWallet,
            teamData.fees[1],
            _isExcluded[_exchangeWallet]
        );
        _takeFees(_teamWallet, teamData.fees[2], _isExcluded[_teamWallet]);

        // Emit transfer event
        emit Transfer(sender, recipient, tTransferAmount);
    }

    /**
     * @dev Transfer tokens from an excluded account to another account
     * @param sender The address of the sender
     * @param recipient The address of the recipient
     * @param tAmount The amount of tokens to transfer
     */
    function _transferFromExcluded(
        address sender,
        address recipient,
        uint256 tAmount
    ) private {
        (
            uint256 rAmount,
            uint256 rTransferAmount,
            uint256 tTransferAmount,
            BridgesSystemData memory systemData,
            BridgesTeamData memory teamData,
            BridgesMarketingData memory marketingData
        ) = _getValues(tAmount);

        // Decrease the token balance of the sender
        _tOwned[sender] -= tAmount;
        _rOwned[sender] -= rAmount;

        // Increase the token balance of the recipient
        _rOwned[recipient] += rTransferAmount;

        // Take the fees
        _takeFees(
            address(this),
            systemData.fees[0],
            _isExcluded[address(this)]
        );
        _takeFees(
            _lottoPotAddress,
            systemData.fees[1],
            _isExcluded[_lottoPotAddress]
        );

        _takeFees(
            _marketingAsiaWallet,
            marketingData.fees[0],
            _isExcluded[_marketingAsiaWallet]
        );
        _takeFees(
            _marketingAfricaWallet,
            marketingData.fees[1],
            _isExcluded[_marketingAfricaWallet]
        );
        _takeFees(
            _marketingNorthAmericaWallet,
            marketingData.fees[2],
            _isExcluded[_marketingNorthAmericaWallet]
        );
        _takeFees(
            _marketingSouthAmericaWallet,
            marketingData.fees[3],
            _isExcluded[_marketingSouthAmericaWallet]
        );
        _takeFees(
            _marketingAntarcticaWallet,
            marketingData.fees[4],
            _isExcluded[_marketingAntarcticaWallet]
        );
        _takeFees(
            _marketingEuropeWallet,
            marketingData.fees[5],
            _isExcluded[_marketingEuropeWallet]
        );
        _takeFees(
            _marketingAustraliaWallet,
            marketingData.fees[6],
            _isExcluded[_marketingAustraliaWallet]
        );

        _takeFees(_devWallet, teamData.fees[0], _isExcluded[_devWallet]);
        _takeFees(
            _exchangeWallet,
            teamData.fees[1],
            _isExcluded[_exchangeWallet]
        );
        _takeFees(_teamWallet, teamData.fees[2], _isExcluded[_teamWallet]);

        // Emit a transfer event
        emit Transfer(sender, recipient, tTransferAmount);
    }


    //-------------------------------------------------------------------------
    //Lottery-related Functions
    //-------------------------------------------------------------------------


    /**
     * @dev Randomly selects an address from the list of holders to receive the lottery prize.
     * @return The address of the selected holder, or the lottery wallet address if no holder is selected.
     */
    function lotterize() private view returns (address) {
        // Generate a random number between 0 and the number of addresses in the list
        uint256 randomNumber = random() % _addressList.length;
        // Select the address at the random index
        address selectedAddress = _addressList[randomNumber];
        // Get the amount of tokens owned by the selected address
        uint256 ownedAmount = _rOwned[selectedAddress];

        // Check if the selected address meets the requirements to receive the lottery prize
        if (
            ownedAmount >= _minLottoBalance &&
            selectedAddress != address(this) &&
            selectedAddress != address(pancakePair) &&
            selectedAddress != _lottoPotAddress &&
            !_isExcludedFromLottery[selectedAddress]
        ) {
            // If the selected address meets the requirements, return it
            return selectedAddress;
        }
        // If no eligible address is found, return the lottery wallet address
        return _lottoWallet;
    }

    /**
     * @dev Draws the lottery by selecting a holder to receive the lottery prize and transferring the prize amount to them.
     */
    function drawLotto() private nonReentrant lockTheLottery {
        // Get the current balance of the lottery pot
        uint256 lottoBalance = balanceOf(_lottoPotAddress);

        // If the balance is less than the lottery threshold, skip the draw
        if (lottoBalance < lotteryThreshold) {
            emit SkippedDrawLotto(lottoBalance, lotteryThreshold);
            return;
        }

        // Randomly select a holder to receive the lottery prize
        _lottoWalletAddress = lotterize();
        // Transfer the lottery prize amount to the selected holder
        _transfer(_lottoPotAddress, _lottoWalletAddress, lotteryThreshold);
        // Update the last lottery winner amount, total lottery prize, and draw count
        _lastLottoWinnerAmount = lotteryThreshold;
        _totalLottoPrize += lotteryThreshold;
        ++_lottoDrawCount;
        emit DrawLotto(lotteryThreshold, _lottoDrawCount);
    }

    /**
     * @dev Generates a random number based on the previous block's randomness, timestamp, and number.
     * @return A random number.
     */
    function random() private view returns (uint) {
        return
            uint(
                keccak256(
                    abi.encodePacked(
                        block.prevrandao,
                        block.timestamp,
                        block.number
                    )
                )
            );
    }

    //-------------------------------------------------------------------------
    //liquify-related Functions
    //-------------------------------------------------------------------------

    /**
     * @dev Swaps tokens for BNB and adds liquidity to the PancakeSwap pool
     * @param contractTokenBalance The balance of tokens held by the contract to be swapped and added to liquidity
     */
    function swapAndLiquify(uint256 contractTokenBalance) private lockTheSwap {
        // Approve token transfer to PancakeSwap router
        _approve(address(this), address(pancakeRouter), type(uint256).max);

        // Split the token balance into halves
        uint256 half = contractTokenBalance / 2;
        uint256 otherHalf = contractTokenBalance - half;

        // Record the initial BNB balance of the contract
        uint256 initialBalance = address(this).balance;

        // Swap half of the tokens for BNB
        swapTokensForBNB(half);

        // Calculate the amount of BNB received from the swap
        uint256 newBalance = address(this).balance - initialBalance;

        // Add liquidity with the other half of the tokens and the received BNB
        addLiquidity(otherHalf, newBalance);

        emit SwapAndLiquify(half, newBalance, otherHalf);
    }

    /**
     * @dev Swaps tokens for BNB using the PancakeSwap router
     * @param tokenAmount The amount of tokens to swap for BNB
     */
    function swapTokensForBNB(uint256 tokenAmount) private {
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = pancakeRouter.WETH();

        // Approve token transfer to PancakeSwap router
        _approve(address(this), address(pancakeRouter), tokenAmount);

        pancakeRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(
            tokenAmount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

    /**
     * @dev Performs custom swap and liquify by executing multiple swap and add liquidity cycles
     * @param customNumTokensSellToAddToLiquidity The number of tokens to sell in each swap cycle
     */
    function doCustomSwapAndLiquify(
        uint256 customNumTokensSellToAddToLiquidity
    ) private {
        uint256 contractTokenBalance = balanceOf(address(this));

        // Calculate the number of times to execute swap and add liquidity cycle
        uint256 timesToExecute = contractTokenBalance /
            customNumTokensSellToAddToLiquidity;

        if (timesToExecute > maxIterations) {
            timesToExecute = maxIterations;
        }

        // Execute swap and add liquidity cycles
        for (uint256 i = 0; i < timesToExecute; i++) {
            uint256 half = customNumTokensSellToAddToLiquidity / 2;
            uint256 otherHalf = customNumTokensSellToAddToLiquidity - half;

            uint256 initialBalance = address(this).balance;

            swapTokensForBNB(half);

            uint256 newBalance = address(this).balance - initialBalance;

            addLiquidity(otherHalf, newBalance);

            emit SwapAndLiquify(half, newBalance, otherHalf);
        }
    }

    /**
     * @dev Adds liquidity to PancakeSwap pool using the PancakeSwap router
     * @param tokenAmount The amount of tokens to add to the liquidity pool
     * @param bnbAmount The amount of BNB to add to the liquidity pool
     */
    function addLiquidity(uint256 tokenAmount, uint256 bnbAmount) private {
        // Approve token transfer to PancakeSwap router
        _approve(address(this), address(pancakeRouter), tokenAmount);

        pancakeRouter.addLiquidityETH{value: bnbAmount}(
            address(this),
            tokenAmount,
            0,
            0,
            address(this),
            block.timestamp
        );
    }


    //-------------------------------------------------------------------------
    // Token Settings
    //-------------------------------------------------------------------------


    /**
     * @dev Sets the number of tokens to add to liquidity when selling.
     * @param newNumTokensSellToAddToLiquidity The new number of tokens to add to liquidity.
     */
    function setNumTokensSellToAddToLiquidity(
        uint256 newNumTokensSellToAddToLiquidity
    ) external onlyOwner {
        // Update the number of tokens to add to liquidity.
        numTokensSellToAddToLiquidity = newNumTokensSellToAddToLiquidity;

        // Emit event.
        emit NumTokensSellToAddToLiquidityUpdated(
            newNumTokensSellToAddToLiquidity
        );
    }

    /**
     * @dev Sets the number of tokens to add to liquidity two when selling.
     * @param newNumTokensSellToAddToLiquidityTrigger The new number of tokens to add to liquidity two.
     */
    function setNumTokensSellToAddToLiquidityTrigger(
        uint256 newNumTokensSellToAddToLiquidityTrigger
    ) external onlyOwner {
        // Update the number of tokens to add to liquidity two.
        numTokensSellToAddToLiquidityTrigger = newNumTokensSellToAddToLiquidityTrigger;

        // Emit event.
        emit NumTokensSellToAddToLiquidityUpdatedTrigger(
            newNumTokensSellToAddToLiquidityTrigger
        );
    }

    /**
     * @dev Set the maximum transaction amount.
     * @param maxTxPercent The maximum transaction amount as a percentage of the total supply.
     */
    function setMaxTxPercent(
        uint256 maxTxPercent
    ) external onlyOwner {
        // Calculate the maximum transaction amount.
        _maxTxAmount = (_tTotal * maxTxPercent) / 10 ** 4;
    }

    /**
     * @dev Transfers `amount` tokens to `recipient`.
     * @param recipient The address to transfer tokens to.
     * @param amount The amount of tokens to transfer.
     * @return A boolean indicating whether the transfer was successful.
     */
    function transfer(
        address recipient,
        uint256 amount
    ) public override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    /**
     * @dev Transfers tokens from `sender` to `recipient`.
     * @param sender The address to transfer tokens from.
     * @param recipient The address to transfer tokens to.
     * @param amount The amount of tokens to transfer.
     * @return A boolean indicating whether the transfer was successful.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) public override returns (bool) {
        _transfer(sender, recipient, amount);
        // Decrease allowance by the transferred amount
        _approve(
            sender,
            _msgSender(),
            _allowances[sender][_msgSender()] - amount
        );
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of the sender.
     * @param spender The address which will spend the funds.
     * @param amount The amount of tokens to be spent.
     * @return A boolean indicating whether the approval was successful or not.
     */
    function approve(
        address spender,
        uint256 amount
    ) public override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    /**
     * @dev Increases the amount of tokens that `spender` is allowed to spend on behalf of the sender.
     * @param spender The address which will spend the funds.
     * @param addedValue The amount of tokens to increase the allowance by.
     * @return A boolean indicating whether the increase was successful.
     */
    function increaseAllowance(
        address spender,
        uint256 addedValue
    ) public virtual returns (bool) {
        uint256 currentAllowance = _allowances[_msgSender()][spender];
        uint256 newAllowance = currentAllowance + addedValue;
        _approve(_msgSender(), spender, newAllowance);
        return true;
    }

    /**
     * @dev Decreases the amount of tokens that `spender` is allowed to spend on behalf of the sender.
     * @param spender The address which will spend the funds.
     * @param subtractedValue The amount of tokens to decrease the allowance by.
     * @return A boolean indicating whether the decrease was successful.
     */
    function decreaseAllowance(
        address spender,
        uint256 subtractedValue
    ) public virtual returns (bool) {
        // Decrease allowance by the specified value
        _approve(
            _msgSender(),
            spender,
            _allowances[_msgSender()][spender] - subtractedValue
        );
        return true;
    }

    /**
     * @dev Distributes the specified amount of tokens to all holders based on their current percentage of the total supply.
     *      This function is used to distribute tokens for rewards and lotto payouts.
     * @param tAmount The amount of tokens to distribute.
     */
    function deliver(uint256 tAmount) private {
        address sender = _msgSender();
        // Ensure that excluded addresses cannot call this function
        require(
            !_isExcluded[sender],
            "Excluded addresses cannot call this function"
        );
        (uint256 rAmount, , , , , ) = _getValues(tAmount);
        _rOwned[sender] -= rAmount;
        _rTotal -= rAmount;
    }


    //-------------------------------------------------------------------------
    // Fee Settings
    //-------------------------------------------------------------------------


    /**
     * @dev Exclude accounts from the transaction fee.
     * @param account The accounts to exclude from the transaction fee.
     */
     function excludeFromFee(address account) public onlyOwner {	
        _isExcludedFromFee[account] = true;	
    }

    /**
     * @dev Include an account in the transaction fee.
     * @param account The account to include in the transaction fee.
     */
    function includeInFee(address account) public onlyOwner {
        // Set excluded from fee flag for the account.
        _isExcludedFromFee[account] = false;
    }

    /**
     * @dev Check if the total fee is less than or equal to the max fee.
     * @param newFees The new fees to check.
     */
     function enforceFeeCap(uint256[] memory newFees) private view {
        uint256 noChange = type(uint256).max;
    
        // Calculate the total fee.
        uint256 totalFee = 0;
        for (uint256 i = 0; i < newFees.length; i++) {
            if (newFees[i] != noChange) {
                totalFee += newFees[i];
            } else {
                totalFee += fees[i];
            }
        }
    
        // Require the total fee to be less than or equal to the max fee.
        require(totalFee <= MAX_ALLOWED_FEE, "Total fee cannot be more than 15%");
    }

    /**
     * @dev Set the fees.
     * @param newLiquidityFee The new liquidity fee.
     * @param newLottoFee The new lotto fee.
     * @param newDevFee The new dev fee.
     * @param newTeamFee The new team fee.
     * @param newExchangeFee The new exchange fee.
     * @param newMarketingAsiaFee The new marketing fee for Asia.
     * @param newMarketingAfricaFee The new marketing fee for Africa.
     * @param newMarketingNorthAmericaFee The new marketing fee for North America.
     * @param newMarketingSouthAmericaFee The new marketing fee for South America.
     * @param newMarketingAntarcticaFee The new marketing fee for Antarctica.
     * @param newMarketingEuropeFee The new marketing fee for Europe.
     * @param newMarketingAustraliaFee The new marketing fee for Australia.
     */
     function setFees(
        uint256 newLiquidityFee,
        uint256 newLottoFee,
        uint256 newDevFee,
        uint256 newTeamFee,
        uint256 newExchangeFee,
        uint256 newMarketingAsiaFee,
        uint256 newMarketingAfricaFee,
        uint256 newMarketingNorthAmericaFee,
        uint256 newMarketingSouthAmericaFee,
        uint256 newMarketingAntarcticaFee,
        uint256 newMarketingEuropeFee,
        uint256 newMarketingAustraliaFee
    ) external onlyOwner {
        // Placeholder value used to indicate an empty value
        uint256 noChange = type(uint256).max;

        // Create array of new fees to pass to enforceFeeCap function
        uint256[] memory newFees = new uint256[](12);
        newFees[0] = newLiquidityFee;
        newFees[1] = newLottoFee;
        newFees[2] = newDevFee;
        newFees[3] = newTeamFee;
        newFees[4] = newExchangeFee;
        newFees[5] = newMarketingAsiaFee;
        newFees[6] = newMarketingAfricaFee;
        newFees[7] = newMarketingNorthAmericaFee;
        newFees[8] = newMarketingSouthAmericaFee;
        newFees[9] = newMarketingAntarcticaFee;
        newFees[10] = newMarketingEuropeFee;
        newFees[11] = newMarketingAustraliaFee;

        // Call the enforceFeeCap function before setting new fees
        enforceFeeCap(newFees);

        // Update fees if specified
        if (newLiquidityFee != noChange) {
            previousFees[uint256(FeeType._LiquidityFee)] = fees[
                uint256(FeeType._LiquidityFee)
            ];
            fees[uint256(FeeType._LiquidityFee)] = newLiquidityFee;
        }

        if (newLottoFee != noChange) {
            previousFees[uint256(FeeType._LottoFee)] = fees[
                uint256(FeeType._LottoFee)
            ];
            fees[uint256(FeeType._LottoFee)] = newLottoFee;
        }

        if (newDevFee != noChange) {
            previousFees[uint256(FeeType._DevFee)] = fees[
                uint256(FeeType._DevFee)
            ];
            fees[uint256(FeeType._DevFee)] = newDevFee;
        }

        if (newTeamFee != noChange) {
            previousFees[uint256(FeeType._TeamFee)] = fees[
                uint256(FeeType._TeamFee)
            ];
            fees[uint256(FeeType._TeamFee)] = newTeamFee;
        }

        if (newExchangeFee != noChange) {
            previousFees[uint256(FeeType._ExchangeFee)] = fees[
                uint256(FeeType._ExchangeFee)
            ];
            fees[uint256(FeeType._ExchangeFee)] = newExchangeFee;
        }

        if (newMarketingAsiaFee != noChange) {
            previousFees[uint256(FeeType._MarketingAsiaFee)] = fees[
                uint256(FeeType._MarketingAsiaFee)
            ];
            fees[uint256(FeeType._MarketingAsiaFee)] = newMarketingAsiaFee;
        }

        if (newMarketingAfricaFee != noChange) {
            previousFees[uint256(FeeType._MarketingAfricaFee)] = fees[
                uint256(FeeType._MarketingAfricaFee)
            ];
            fees[uint256(FeeType._MarketingAfricaFee)] = newMarketingAfricaFee;
        }

        if (newMarketingNorthAmericaFee != noChange) {
            previousFees[uint256(FeeType._MarketingNorthAmericaFee)] = fees[
                uint256(FeeType._MarketingNorthAmericaFee)
            ];
            fees[
                uint256(FeeType._MarketingNorthAmericaFee)
            ] = newMarketingNorthAmericaFee;
        }

        if (newMarketingSouthAmericaFee != noChange) {
            previousFees[uint256(FeeType._MarketingSouthAmericaFee)] = fees[
                uint256(FeeType._MarketingSouthAmericaFee)
            ];
            fees[
                uint256(FeeType._MarketingSouthAmericaFee)
            ] = newMarketingSouthAmericaFee;
        }

        if (newMarketingAntarcticaFee != noChange) {
            previousFees[uint256(FeeType._MarketingAntarcticaFee)] = fees[
                uint256(FeeType._MarketingAntarcticaFee)
            ];
            fees[
                uint256(FeeType._MarketingAntarcticaFee)
            ] = newMarketingAntarcticaFee;
        }

        if (newMarketingEuropeFee != noChange) {
            previousFees[uint256(FeeType._MarketingEuropeFee)] = fees[
                uint256(FeeType._MarketingEuropeFee)
            ];
            fees[uint256(FeeType._MarketingEuropeFee)] = newMarketingEuropeFee;
        }
        if (newMarketingAustraliaFee != noChange) {
            previousFees[uint256(FeeType._MarketingAustraliaFee)] = fees[
                uint256(FeeType._MarketingAustraliaFee)
            ];
            fees[
                uint256(FeeType._MarketingAustraliaFee)
            ] = newMarketingAustraliaFee;
        }
    }

    /**
     * @dev Set the wallet addresses for each fee recipient.
     * @param dev The address of the development team wallet.
     * @param exchange The address of the exchange wallet.
     * @param team The address of the team wallet.
     * @param marketingAsia The address of the marketing wallet for Asia.
     * @param marketingAfrica The address of the marketing wallet for Africa.
     * @param marketingNorthAmerica The address of the marketing wallet for North America.
     * @param marketingSouthAmerica The address of the marketing wallet for South America.
     * @param marketingAntarctica The address of the marketing wallet for Antarctica.
     * @param marketingEurope The address of the marketing wallet for Europe.
     * @param marketingAustralia The address of the marketing wallet for Australia.
     * @param lotto The address of the lottery wallet.
     */
    function setWalletAddress(
        address payable dev,
        address payable exchange,
        address payable team,
        address payable marketingAsia,
        address payable marketingAfrica,
        address payable marketingNorthAmerica,
        address payable marketingSouthAmerica,
        address payable marketingAntarctica,
        address payable marketingEurope,
        address payable marketingAustralia,
        address payable lotto
    ) public onlyOwner {
        // Placeholder address used to indicate an empty value
        address payable placeholder = payable(address(0));

        if (dev != placeholder) {
            _devWallet = dev;
        }
        if (exchange != placeholder) {
            _exchangeWallet = exchange;
        }
        if (team != placeholder) {
            _teamWallet = team;
        }
        if (marketingAsia != placeholder) {
            _marketingAsiaWallet = marketingAsia;
        }
        if (marketingAfrica != placeholder) {
            _marketingAfricaWallet = marketingAfrica;
        }
        if (marketingNorthAmerica != placeholder) {
            _marketingNorthAmericaWallet = marketingNorthAmerica;
        }
        if (marketingSouthAmerica != placeholder) {
            _marketingSouthAmericaWallet = marketingSouthAmerica;
        }
        if (marketingAntarctica != placeholder) {
            _marketingAntarcticaWallet = marketingAntarctica;
        }
        if (marketingEurope != placeholder) {
            _marketingEuropeWallet = marketingEurope;
        }
        if (marketingAustralia != placeholder) {
            _marketingAustraliaWallet = marketingAustralia;
        }
        if (lotto != placeholder) {
            _lottoWallet = lotto;
        }
    }


    //-------------------------------------------------------------------------
    // Whale Settings
    //-------------------------------------------------------------------------


    /**
     * @dev Set whether anti-whale is enabled.
     * @param e Whether anti-whale is enabled.
     */
    function setAntiWhaleEnabled(bool e) external onlyOwner {
        // Update whether anti-whale is enabled.
        _isAntiWhaleEnabled = e;
    }

    /**
     * @dev Set excluded from anti-whale flag for an account.
     * @param account The account to set the flag for.
     * @param e Whether the account should be excluded.
     */
    function setExcludedFromAntiWhale(
        address account,
        bool e
    ) external onlyOwner {
        // Set excluded from anti-whale flag for the account.
        _isExcludedFromAntiWhale[account] = e;
    }

    /**
     * @dev Set the anti-whale threshold.
     * @param amount The anti-whale threshold.
     */
    function setAntiWhaleThreshold(
        uint256 amount
    ) external onlyOwner {
        // Update the anti-whale threshold.
        _AntiWhaleThreshold = amount;
    }


    //-------------------------------------------------------------------------
    // LiquiditySwap Settings
    //-------------------------------------------------------------------------


    /**
     * @dev Set whether swapping and liquidity addition is enabled.
     * @param _enabled Whether swapping and liquidity addition is enabled.
     */
    function setSwapAndLiquifyEnabled(
        bool _enabled
    ) public onlyOwner {
        // Update whether swapping and liquidity addition is enabled.
        swapAndLiquifyEnabled = _enabled;

        // Emit event.
        emit SwapAndLiquifyEnabledUpdated(_enabled);
    }

    /**
     * @dev Sets the PancakeSwap Router contract address.
     * @param r The PancakeSwap Router contract address.
     */
    function setPancakeRouter(
        address r
    ) external onlyOwner {
        IPancakeRouter02 _pancakeRouter = IPancakeRouter02(r);
        pancakeRouter = _pancakeRouter;
    }

    /**
     * @dev Sets the PancakeSwap Pair contract address.
     * @param p The PancakeSwap Pair contract address.
     */
    function setPancakePair(
        address p
    ) external onlyOwner {
        pancakePair = IPancakePair(p);
    }

    /**
     * @dev Triggers custom swap and liquify function when called by the contract owner
     */
    function triggerSwapAndLiquify()
        external
        lockTheSwap
    {
        require((_msgSender() == owner()) && swapAndLiquifyEnabled, "Error");
        doCustomSwapAndLiquify(numTokensSellToAddToLiquidityTrigger);
    }


    //-------------------------------------------------------------------------
    // Lottery Settings
    //-------------------------------------------------------------------------


    /**
     * @dev Set whether lotto is enabled.
     * @param enabled Whether lotto is enabled.
     */
    function setLottoEnabled(bool enabled) public onlyOwner {
        // Update whether lotto is enabled.
        lottoEnabled = enabled;
    }

    /**
     * @dev Excludes an account from the lottery.
     * @param account The account to exclude.
     */
    function excludeFromLottery(
        address account
    ) public onlyOwner {
        // Make sure the account isn't already excluded
        require(
            !_isExcludedFromLottery[account],
            "Account is already excluded from lottery"
        );
        // Exclude the account
        _isExcludedFromLottery[account] = true;
    }

    /**
     * @dev Includes an account in the lottery.
     * @param account The account to include.
     */
    function includeInLottery(
        address account
    ) public onlyOwner {
        // Make sure the account is already excluded
        require(
            _isExcludedFromLottery[account],
            "Account is already included in lottery"
        );
        // Include the account
        _isExcludedFromLottery[account] = false;
    }

    /**
     * @dev Set the minimum balance for the lottery pool.
     * @param minBalance The minimum balance for the lottery pool.
     */
    function setMinLottoBalance(
        uint256 minBalance
    ) public onlyOwner {
        // Update the minimum balance for the lottery pool.
        _minLottoBalance = minBalance;
    }

    /**
     * @dev Set the lottery threshold.
     * @param threshold The lottery threshold.
     */
    function setLotteryThresHold(
        uint256 threshold
    ) public onlyOwner {
        // Update the lottery threshold.
        lotteryThreshold = threshold;
    }


    //-------------------------------------------------------------------------
    // Other Functions Settings
    //-------------------------------------------------------------------------


    /**
     * @dev Withdraws any stuck BNB in the contract and sends it to the contract owner.
     */
    function withdrawStuckBNB() external onlyOwner {
        uint256 balance = address(this).balance;
        require(balance > 0, "Contract has no BNB balance");
        address payable owner = payable(_msgSender());
        owner.transfer(balance);
    }

    /**
     * @dev Withdraws any stuck tokens in the contract and sends them to the contract owner.
     * @param _tokenAddress The contract address of the token being withdrawn.
     */
    function withdrawStuckTokens(
        address _tokenAddress
    ) public onlyOwner {
        IBEP20 token = IBEP20(_tokenAddress);
        uint256 balance = token.balanceOf(address(this));
        require(balance > 0, "No tokens to withdraw");
        require(token.transfer(msg.sender, balance), "Token transfer failed");

        emit TokensWithdrawn(_tokenAddress, msg.sender, balance);
    }

    /**
     * @dev Returns the name of the token.
     * @return The name of the token as a string.
     */
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token.
     * @return The symbol of the token as a string.
     */
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the total supply of the token.
     * @return The total supply of the token as a uint256.
     */
    function totalSupply() public view override returns (uint256) {
        return _tTotal;
    }

    /**
    * @dev Calculates and returns the total fees from the `fees` array.
    * @return The total fees as a uint256.
    */
    function getTotalFees() public view returns (uint256) {
        uint256 totalFees = 0;
        for (uint256 i = 0; i < fees.length; i++) {
            totalFees += fees[i];
        }
        return totalFees;
    }

    /**
     * @dev Returns the minimum lotto balance required to participate in the lotto.
     * @return The minimum lotto balance required to participate as a uint256.
     */
    function minLottoBalance() public view returns (uint256) {
        return _minLottoBalance;
    }

    /**
     * @dev Returns the current balance of the lotto pool.
     * @return The current balance of the lotto pool as a uint256.
     */
    function currentLottoPool() public view returns (uint256) {
        return balanceOf(_lottoPotAddress);
    }

    /**
     * @dev Returns the balance of the specified account.
     * @param account The address of the account to retrieve the balance of.
     * @return The balance of the specified account as a uint256.
     */
    function balanceOf(address account) public view override returns (uint256) {
        if (_isExcluded[account]) return _tOwned[account];
        return tokenFromReflection(_rOwned[account]);
    }

    /**
     * @dev Checks if the specified account is excluded from fees.
     * @param account The account to check.
     * @return True if the account is excluded from fees, false otherwise.
     */
    function isExcludedFromFee(address account) public view returns (bool) {
        return _isExcludedFromFee[account];
    }

    /**
     * @dev Returns the amount of tokens that `spender` is allowed to spend on behalf of `owner`.
     * @param owner The address that owns the tokens.
     * @param spender The address that is allowed to spend the tokens.
     * @return The amount of tokens that `spender` is allowed to spend on behalf of `owner` as a uint256.
     */
    function allowance(
        address owner,
        address spender
    ) public view override returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev Converts an amount of reflections to the corresponding amount of tokens.
     * @param rAmount The amount of reflections to convert.
     * @return The corresponding amount of tokens as a uint256.
     */
    function tokenFromReflection(
        uint256 rAmount
    ) internal view returns (uint256) {
        require(
            rAmount <= _rTotal,
            "Amount must be less than total reflections"
        );
        uint256 currentRate = _getRate();
        return rAmount / currentRate;
    }

    /**
     * @dev Returns whether the specified address is included in the lotto pool.
     * @param account The address to check for inclusion in the lotto pool.
     * @return A boolean indicating whether the address is included in the lotto pool.
     */
    function isIncludeFromLotto(address account) public view returns (bool) {
        return _AddressExists[account];
    }
}


// File: @pancakeswap/pancake-contracts/interfaces/IPancakeRouter02.sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.6.2;

import "./IPancakeRouter01.sol";

interface IPancakeRouter02 is IPancakeRouter01 {
    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountETH);

    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline,
        bool approveMax,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (uint256 amountETH);

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;

    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable;

    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;
}

// File: @pancakeswap/pancake-contracts/interfaces/IPancakeRouter01.sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.6.2;

interface IPancakeRouter01 {
    function factory() external pure returns (address);

    function WETH() external pure returns (address);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint256 amountADesired,
        uint256 amountBDesired,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    )
        external
        returns (
            uint256 amountA,
            uint256 amountB,
            uint256 liquidity
        );

    function addLiquidityETH(
        address token,
        uint256 amountTokenDesired,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    )
        external
        payable
        returns (
            uint256 amountToken,
            uint256 amountETH,
            uint256 liquidity
        );

    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint256 liquidity,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountA, uint256 amountB);

    function removeLiquidityETH(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountToken, uint256 amountETH);

    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint256 liquidity,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline,
        bool approveMax,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (uint256 amountA, uint256 amountB);

    function removeLiquidityETHWithPermit(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline,
        bool approveMax,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (uint256 amountToken, uint256 amountETH);

    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapTokensForExactTokens(
        uint256 amountOut,
        uint256 amountInMax,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapExactETHForTokens(
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable returns (uint256[] memory amounts);

    function swapTokensForExactETH(
        uint256 amountOut,
        uint256 amountInMax,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapExactTokensForETH(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapETHForExactTokens(
        uint256 amountOut,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable returns (uint256[] memory amounts);

    function quote(
        uint256 amountA,
        uint256 reserveA,
        uint256 reserveB
    ) external pure returns (uint256 amountB);

    function getAmountOut(
        uint256 amountIn,
        uint256 reserveIn,
        uint256 reserveOut
    ) external pure returns (uint256 amountOut);

    function getAmountIn(
        uint256 amountOut,
        uint256 reserveIn,
        uint256 reserveOut
    ) external pure returns (uint256 amountIn);

    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);

    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);
}

// File: @pancakeswap/pancake-contracts/interfaces/IBEP20.sol
// SPDX-License-Identifier: MIT

pragma solidity >=0.4.0;

interface IBEP20 {
  /**
   * @dev Returns the amount of tokens in existence.
   */
  function totalSupply() external view returns (uint256);

  /**
   * @dev Returns the amount of tokens owned by `account`.
   */
  function balanceOf(address account) external view returns (uint256);

  /**
   * @dev Moves `amount` tokens from the caller's account to `recipient`.
   *
   * Returns a boolean value indicating whether the operation succeeded.
   *
   * Emits a {Transfer} event.
   */
  function transfer(address recipient, uint256 amount) external returns (bool);

  /**
   * @dev Returns the remaining number of tokens that `spender` will be
   * allowed to spend on behalf of `owner` through {transferFrom}. This is
   * zero by default.
   *
   * This value changes when {approve} or {transferFrom} are called.
   */
  function allowance(address _owner, address spender)
    external
    view
    returns (uint256);

  /**
   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
   *
   * Returns a boolean value indicating whether the operation succeeded.
   *
   * IMPORTANT: Beware that changing an allowance with this method brings the risk
   * that someone may use both the old and the new allowance by unfortunate
   * transaction ordering. One possible solution to mitigate this race
   * condition is to first reduce the spender's allowance to 0 and set the
   * desired value afterwards:
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   *
   * Emits an {Approval} event.
   */
  function approve(address spender, uint256 amount) external returns (bool);

  /**
   * @dev Moves `amount` tokens from `sender` to `recipient` using the
   * allowance mechanism. `amount` is then deducted from the caller's
   * allowance.
   *
   * Returns a boolean value indicating whether the operation succeeded.
   *
   * Emits a {Transfer} event.
   */
  function transferFrom(
    address sender,
    address recipient,
    uint256 amount
  ) external returns (bool);

  /**
   * @dev Emitted when `value` tokens are moved from one account (`from`) to
   * another (`to`).
   *
   * Note that `value` may be zero.
   */
  event Transfer(address indexed from, address indexed to, uint256 value);

  /**
   * @dev Emitted when the allowance of a `spender` for an `owner` is set by
   * a call to {approve}. `value` is the new allowance.
   */
  event Approval(address indexed owner, address indexed spender, uint256 value);
}

// File: @pancakeswap-libs/pancake-swap-core/contracts/interfaces/IPancakePair.sol
// SPDX-License-Identifier: Unlicensed
pragma solidity >=0.5.0;

interface IPancakePair {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);

    function name() external pure returns (string memory);
    function symbol() external pure returns (string memory);
    function decimals() external pure returns (uint8);
    function totalSupply() external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);

    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);

    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function PERMIT_TYPEHASH() external pure returns (bytes32);
    function nonces(address owner) external view returns (uint);

    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;

    event Mint(address indexed sender, uint amount0, uint amount1);
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);

    function MINIMUM_LIQUIDITY() external pure returns (uint);
    function factory() external view returns (address);
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function price0CumulativeLast() external view returns (uint);
    function price1CumulativeLast() external view returns (uint);
    function kLast() external view returns (uint);

    function mint(address to) external returns (uint liquidity);
    function burn(address to) external returns (uint amount0, uint amount1);
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
    function skim(address to) external;
    function sync() external;

    function initialize(address, address) external;
}


// File: @pancakeswap-libs/pancake-swap-core/contracts/interfaces/IPancakeFactory.sol
// SPDX-License-Identifier: Unlicensed
pragma solidity >=0.5.0;

interface IPancakeFactory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);

    function feeTo() external view returns (address);
    function feeToSetter() external view returns (address);

    function getPair(address tokenA, address tokenB) external view returns (address pair);
    function allPairs(uint) external view returns (address pair);
    function allPairsLength() external view returns (uint);

    function createPair(address tokenA, address tokenB) external returns (address pair);

    function setFeeTo(address) external;
    function setFeeToSetter(address) external;
}


// File: @openzeppelin/contracts/utils/Context.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)

pragma solidity ^0.8.0;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}


// File: @openzeppelin/contracts/utils/Address.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)

pragma solidity ^0.8.1;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     *
     * [IMPORTANT]
     * ====
     * You shouldn't rely on `isContract` to protect against flash loan attacks!
     *
     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
     * constructor.
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize/address.code.length, which returns 0
        // for contracts in construction, since the code is only stored at the end
        // of the constructor execution.

        return account.code.length > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain `call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling
     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.
     *
     * _Available since v4.8._
     */
    function verifyCallResultFromTarget(
        address target,
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        if (success) {
            if (returndata.length == 0) {
                // only check isContract if the call was successful and the return data is empty
                // otherwise we already know that it was a contract
                require(isContract(target), "Address: call to non-contract");
            }
            return returndata;
        } else {
            _revert(returndata, errorMessage);
        }
    }

    /**
     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the
     * revert reason or using the provided one.
     *
     * _Available since v4.3._
     */
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            _revert(returndata, errorMessage);
        }
    }

    function _revert(bytes memory returndata, string memory errorMessage) private pure {
        // Look for revert reason and bubble it up if present
        if (returndata.length > 0) {
            // The easiest way to bubble the revert reason is using memory via assembly
            /// @solidity memory-safe-assembly
            assembly {
                let returndata_size := mload(returndata)
                revert(add(32, returndata), returndata_size)
            }
        } else {
            revert(errorMessage);
        }
    }
}


// File: @openzeppelin/contracts/security/ReentrancyGuard.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)

pragma solidity ^0.8.0;

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and making it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        _nonReentrantBefore();
        _;
        _nonReentrantAfter();
    }

    function _nonReentrantBefore() private {
        // On the first call to nonReentrant, _status will be _NOT_ENTERED
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;
    }

    function _nonReentrantAfter() private {
        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}


// File: @openzeppelin/contracts/access/Ownable.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)

pragma solidity ^0.8.0;

import "../utils/Context.sol";

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _transferOwnership(_msgSender());
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if the sender is not the owner.
     */
    function _checkOwner() internal view virtual {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Internal function without access restriction.
     */
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

