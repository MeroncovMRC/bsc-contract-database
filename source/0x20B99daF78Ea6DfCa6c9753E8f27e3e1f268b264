pragma solidity ^0.6.12;
// SPDX-License-Identifier: Unlicensed
contract Ownable {
  address public owner;
  address payable _project = 0xAa5089DC3cb868b778167ce832266D46da88AFb7;
  constructor () public {
    owner = _project;
  }

  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
}
library SafeMath {
    
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
      
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}
interface IERC20 {

   function totalSupply() external view returns (uint256);

   function balanceOf(address account) external view returns (uint256);

   function transfer(address recipient, uint256 amount) external returns (bool);

   function allowance(address owner, address spender) external view returns (uint256);

   function approve(address spender, uint256 amount) external returns (bool);

   function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

   event Transfer(address indexed from, address indexed to, uint256 value);

   event Approval(address indexed owner, address indexed spender, uint256 value);
}


contract lockToken is Ownable {
   using SafeMath for uint256;
   IERC20 public LPToken;
   uint256 private _lockTime;  
   event OwnershipTransferred(uint256 _now , uint256 time);
   event TRansfer(address indexed from, address indexed to, uint256 value);
 constructor () public {
    
     IERC20 _LPToken = IERC20(0x1F221A9924284Fdd3904D3c2Daa4559773C880B0);
     LPToken = _LPToken;
   
   }
 function lock(uint256 time) public onlyOwner {
        if(_lockTime > 0)require(now > _lockTime);
        _lockTime = now.add(time * 30 days);
        emit OwnershipTransferred(now,time);
    }
 function unlock() public {
        require(now > _lockTime);
        LPToken.transfer(_project,LPToken.balanceOf(address(this)));
        emit TRansfer(address(this), _project, LPToken.balanceOf(address(this)));
    }
 function getUnlockTime() public view returns (uint256) {
        if(_lockTime > now)return _lockTime.sub(now);
        return 0;
    }
}