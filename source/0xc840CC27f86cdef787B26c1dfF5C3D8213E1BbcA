
// File: @openzeppelin/contracts/access/Ownable.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)

pragma solidity ^0.8.0;

import "../utils/Context.sol";

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _transferOwnership(_msgSender());
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if the sender is not the owner.
     */
    function _checkOwner() internal view virtual {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby disabling any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Internal function without access restriction.
     */
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}


// File: @openzeppelin/contracts/utils/Context.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)

pragma solidity ^0.8.0;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}


// File: contracts/MoonLock.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

import "@openzeppelin/contracts/access/Ownable.sol";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function decimals() external view returns (uint8);
}

interface IMembershipManager  {
   
    function isMember(address user) external view returns (bool isMember);
    function balanceOf(address owner) external view returns (uint256 balance);

}

library MoonLockLib {

    enum Status { PENDING, INPROGRESS, CANCELLED, SUCCESSFUL, FAILED }
    enum Vote { FAVOUR, AGAINST }

    struct Socials {
        string name;
        string imageUrl;
        string details;
        string twitterId;
        string discordId;
        string telegramId;
    }

    struct MoonLockInfo {   
        uint256 moonLockId;
        address moonLockAddress;
        address assetAddress;
        uint256 proposalsCount;
        bool isProposalActive;
        Socials socials;
    }

    struct UnlockProposal {
        uint256 id;
        string description;
        uint256 proposedAt;
        uint256 startingAt;
        uint8 durationInDays;
        uint256 voteCount;
        uint256 votesInFavour;
        uint256 votesAgainst;
        Status status;
    }

}

contract MoonLock {

    error MoonLock__OUT_OF_BOUND_REQUEST();
    error MoonLock__CONTRACT_IS_NOT_LOCKED();
    error MoonLock__PROPOSAL_ALREADY_ACTIVE();
    error MoonLock__STARTING_TIME_PASSED();
    error MoonLock__DURATION_NOT_ALLOWED();
    error MoonLock__PROPOSAL_NOT_ACTIVE();
    error MoonLock__PROPOSAL_ALREADY_INPROGRESS();
    error MoonLock__PROPOSAL_NOT_STARTED_YET();
    error MoonLock__INSUFFICIENT_BALANCE_FOR_VOTING();
    error MoonLock__ALREADY_VOTED();
    error MoonLock__PROPOSAL_EXPIRED();
    error MoonLock__PROPOSAL_NOT_EXPIRED_YET();
    error MoonLock__DAYS_OUT_OF_RANGE();
    error MoonLock__EXECUTOR_CANT_BE_NULL();
    error MoonLock__NOT_EXECUTOR();
    error MoonLock__NOT_OWNER_OF_ASSET();

    uint256 internal constant ONE_DAY = 24*60*60;
    address private s_orginalOwner;
    Executor private s_executor;

    MoonLockLib.MoonLockInfo private s_moonLockInfo;

    mapping(uint256 => MoonLockLib.UnlockProposal) private s_unlockProposals;
    mapping(uint256 => mapping(address => bool)) private s_voted;

    struct Executor {
        address executorAddress;
        uint256 effectiveFrom;
    }

    event ProposalCreated(uint256 propsalId, string description, uint256 startingAt, uint8 durationInDays);
    event ProposalCancelled(uint256 propsalId);
    event ProposalFinalized(uint256 propsalId, MoonLockLib.Status status);
    event VoteCasted(uint256 propsalId, MoonLockLib.Vote vote, uint256 amount);
    event OwnershipReleased(uint256 propsalId);
    event ExecutorUpdated(address newExecutor, uint256 effectiveFrom);
       
    modifier onlyEffectiveOwner(){
        if(s_executor.executorAddress != address(0) && block.timestamp >= s_executor.effectiveFrom){
            if(s_executor.executorAddress != msg.sender){
                revert MoonLock__NOT_EXECUTOR();
            }
            s_orginalOwner = msg.sender;
            s_executor.executorAddress = address(0);
            s_executor.effectiveFrom = 0;
        }
        else {
            if(s_orginalOwner != msg.sender){
                revert MoonLock__NOT_OWNER_OF_ASSET();
            }
        }
        _;
    }

    constructor(uint256 id, address assetAddress, MoonLockLib.Socials memory socials) {

        address assetOwner = Ownable(assetAddress).owner();
        s_orginalOwner = assetOwner;
        s_moonLockInfo = MoonLockLib.MoonLockInfo({
            moonLockId: id,
            moonLockAddress: address(this),
            assetAddress: assetAddress,
            proposalsCount: 0,
            isProposalActive: false,
            socials: socials
        });   
    }

    function isOwnershipLocked() public view returns(bool) {
        // Check if the contract owns the asset

        return Ownable(s_moonLockInfo.assetAddress).owner() == address(this);
    }

    function getProposals(uint256 from, uint256 count) external view returns(MoonLockLib.UnlockProposal[] memory) {
        // Retrieve an array of unlock proposals within the specified range
        
        if (from > s_moonLockInfo.proposalsCount) {
            revert MoonLock__OUT_OF_BOUND_REQUEST();
        }

        if (count > from) {
            count = from;
        }

        uint256 to = from - count;

        uint256 index = 0;
        MoonLockLib.UnlockProposal[] memory proposals = new MoonLockLib.UnlockProposal[](count);
        for (uint256 i = from; i > to; i--) {
            MoonLockLib.UnlockProposal memory p = s_unlockProposals[i];
            proposals[index] = p;
            index++;
        }

        return proposals;
    }

    function getLatestProposal() public view returns(MoonLockLib.UnlockProposal memory) {
        // Retrieve the latest unlock proposal
        
        return s_unlockProposals[s_moonLockInfo.proposalsCount];
    }

    function startProposal( string memory description, uint256 startingAt, uint8 durationInDays) public onlyEffectiveOwner  {
        // Start a new unlock proposal
        
        if (!isOwnershipLocked()) {
            revert MoonLock__CONTRACT_IS_NOT_LOCKED();
        }

        if (s_moonLockInfo.isProposalActive) {
            revert MoonLock__PROPOSAL_ALREADY_ACTIVE();
        }

        if (startingAt <= block.timestamp) {
            revert MoonLock__STARTING_TIME_PASSED();
        }

        if (durationInDays < 1 || durationInDays > 5) {
            revert MoonLock__DURATION_NOT_ALLOWED();
        }

        uint256 id = ++s_moonLockInfo.proposalsCount;

        MoonLockLib.UnlockProposal memory proposal = MoonLockLib.UnlockProposal({
                id: id,
                description: description,
                proposedAt: block.timestamp,
                startingAt: startingAt,
                durationInDays: durationInDays,
                voteCount: 0,
                votesInFavour: 0,
                votesAgainst: 0,
                status: MoonLockLib.Status.PENDING
            }
        );

        s_moonLockInfo.isProposalActive = true;
        s_unlockProposals[id] = proposal;

        emit ProposalCreated(id, description, startingAt, durationInDays);
    }

    function cancelProposal() public onlyEffectiveOwner {

        if (!s_moonLockInfo.isProposalActive) {
            revert MoonLock__PROPOSAL_NOT_ACTIVE();
        }

        MoonLockLib.UnlockProposal memory proposal = getLatestProposal();

        if ( block.timestamp > proposal.startingAt ){
            revert MoonLock__PROPOSAL_ALREADY_INPROGRESS();
        }

        s_unlockProposals[proposal.id].status = MoonLockLib.Status.CANCELLED;
        s_moonLockInfo.isProposalActive = false;
        emit ProposalCancelled(proposal.id);
    
    }

    function castVote(MoonLockLib.Vote vote) public {
        // Cast a vote for the latest unlock proposal
        
        if (!isOwnershipLocked()) {
            revert MoonLock__CONTRACT_IS_NOT_LOCKED();
        }

        MoonLockLib.UnlockProposal memory proposal = getLatestProposal();
        MoonLockLib.MoonLockInfo memory moonLockInfo = s_moonLockInfo;

        if (s_voted[proposal.id][msg.sender]) {
            revert MoonLock__ALREADY_VOTED();
        }

        if (!moonLockInfo.isProposalActive) {
            revert MoonLock__PROPOSAL_NOT_ACTIVE();
        }

        if (block.timestamp <= proposal.startingAt) {
            revert MoonLock__PROPOSAL_NOT_STARTED_YET();
        }

        if (proposal.status != MoonLockLib.Status.PENDING && proposal.status != MoonLockLib.Status.INPROGRESS) {
            revert MoonLock__PROPOSAL_NOT_ACTIVE();
        }

        if (proposal.status == MoonLockLib.Status.PENDING) {
            s_unlockProposals[proposal.id].status = MoonLockLib.Status.INPROGRESS;
        }

        IERC20 assetAddress = IERC20(moonLockInfo.assetAddress);
        uint256 balanceOfUser = assetAddress.balanceOf(msg.sender) / (10 ** assetAddress.decimals());

        if (balanceOfUser < 1) {
            revert MoonLock__INSUFFICIENT_BALANCE_FOR_VOTING();
        }

        if (block.timestamp > proposal.startingAt + (proposal.durationInDays * ONE_DAY)) {
            revert MoonLock__PROPOSAL_EXPIRED();
        }

        if (vote == MoonLockLib.Vote.FAVOUR) {
            s_unlockProposals[proposal.id].votesInFavour += balanceOfUser;
        } else {
            s_unlockProposals[proposal.id].votesAgainst += balanceOfUser;
        }

        s_voted[proposal.id][msg.sender] = true;
        s_unlockProposals[proposal.id].voteCount++;

        emit VoteCasted(proposal.id, vote, balanceOfUser);
    }

    function finalizeProposal() public onlyEffectiveOwner {
        // Finalize the latest unlock proposal
        
        MoonLockLib.UnlockProposal memory proposal = getLatestProposal();
        MoonLockLib.MoonLockInfo memory moonLockInfo = s_moonLockInfo;

        if (!moonLockInfo.isProposalActive) {
            revert MoonLock__PROPOSAL_NOT_ACTIVE();
        }


        if (block.timestamp < proposal.startingAt + proposal.durationInDays * ONE_DAY) {
            revert MoonLock__PROPOSAL_NOT_EXPIRED_YET();
        }

        if ( proposal.votesAgainst > proposal.votesInFavour) {

            s_unlockProposals[proposal.id].status = MoonLockLib.Status.FAILED;
            s_moonLockInfo.isProposalActive = false;
            emit ProposalFinalized(proposal.id, MoonLockLib.Status.FAILED);
    
        } else {
            // Return ownership to owner
            s_unlockProposals[proposal.id].status = MoonLockLib.Status.SUCCESSFUL;
            s_moonLockInfo.isProposalActive = false;
            
            removeExecutor();
            Ownable(moonLockInfo.assetAddress).transferOwnership(owner());
            
            emit ProposalFinalized(proposal.id, MoonLockLib.Status.SUCCESSFUL);
            emit OwnershipReleased(proposal.id);
        }

    }

    function updateSocials(MoonLockLib.Socials memory socials) public onlyEffectiveOwner {
        // Update the socials data
        
        s_moonLockInfo.socials = socials;
    }

    function getMoonLockInfo() public view returns(MoonLockLib.MoonLockInfo memory){
        return s_moonLockInfo;
    }

    function updateExecutor(address executorAddress, uint16 effectiveInDays) public onlyEffectiveOwner {

        if(effectiveInDays < 1 || effectiveInDays > 7300){ 
            revert MoonLock__DAYS_OUT_OF_RANGE();
        }

        if(executorAddress == address(0)){
            revert MoonLock__EXECUTOR_CANT_BE_NULL();
        }

        uint256 effectiveTime = block.timestamp + ONE_DAY * effectiveInDays;      
        s_executor.executorAddress = executorAddress;
        s_executor.effectiveFrom = effectiveTime;
        emit ExecutorUpdated(executorAddress, effectiveTime);
    }

    function removeExecutor() public onlyEffectiveOwner {
        s_executor.executorAddress = address(0);
        s_executor.effectiveFrom = 0;
        emit ExecutorUpdated(address(0), 0);
    }

    function executor() public view returns (Executor memory) {
        return s_executor;
    }

    function owner() public view returns (address) {
        if(s_executor.executorAddress != address(0) && block.timestamp >= s_executor.effectiveFrom){
            return s_executor.executorAddress;
        }
        else {
            return s_orginalOwner;
        }
    }

    function isVoted(uint256 proposalId, address voter) public view returns(bool){
        return s_voted[proposalId][voter];
    }

}

contract MoonLockFactory is Ownable {

    error MoonLockFactory__INSUFFICIENT_FUNDS(uint256 current, uint256 required);
    error MoonLockFactory__NOT_OWNER_OF_ASSET();
    error MoonLockFactory__NOT_A_PM_MEMBER();
    error MoonLockFactory__OUT_OF_BOUND_REQUEST();
    error MoonLockFactory__NO_FUNDS_AVAILABLE();
    error MoonLockFactory__CONTRACT_IS_PAUSED();

    uint256 private s_moonLockCount;
    uint256 private s_moonLockFee = 0 ether;
    bool private s_isPaused = false;
    IMembershipManager private s_membershipManager;
    mapping(uint256 id => MoonLock moonLock) public s_moonLockById;
    mapping(address asset => MoonLock[] moonLocks) private s_moonLocksByAsset;

    event Received(address from, uint256 amount);
    event MoonLockCreated( uint256 id, address moonLock );
    event MembershipManagerUpdated(address manager, uint256 timeStamp);

    constructor ( address membershipManager ) {
        s_membershipManager = IMembershipManager(membershipManager);
    }

    function createMoonLock(address assetAddress, MoonLockLib.Socials memory socials) external payable {

        if (s_isPaused) {
            revert MoonLockFactory__CONTRACT_IS_PAUSED();
        }

        if(msg.value < s_moonLockFee){
            revert MoonLockFactory__INSUFFICIENT_FUNDS({
                current: msg.value, 
                required: s_moonLockFee
            });
        }

        if( !s_membershipManager.isMember(msg.sender) ){
            revert MoonLockFactory__NOT_A_PM_MEMBER();
        }

        address assetOwner = Ownable(assetAddress).owner();
        if(msg.sender != assetOwner){
            revert MoonLockFactory__NOT_OWNER_OF_ASSET();
        }

        uint256 id = ++s_moonLockCount;
        MoonLock moonLock = new MoonLock({
            id: id, 
            assetAddress: assetAddress, 
            socials: socials
        });

        s_moonLockById[id] = moonLock;
        s_moonLocksByAsset[assetAddress].push(moonLock);

        emit MoonLockCreated( id, address(moonLock) );

    }

    function getMoonLocksInfoByIds(uint256 from, uint256 count) external view returns (MoonLockLib.MoonLockInfo[] memory){

        if (from > s_moonLockCount) {
            revert MoonLockFactory__OUT_OF_BOUND_REQUEST();
        }

        if (count > from) {
            count = from;
        }

        uint256 to = from - count;

        uint256 index = 0;
        MoonLockLib.MoonLockInfo[] memory moonLockInfos = new MoonLockLib.MoonLockInfo[](count);
        for (uint256 i = from; i > to; i--) {
            MoonLock ml = s_moonLockById[i];
            moonLockInfos[index] = ml.getMoonLockInfo();
            index++;
        }

        return moonLockInfos;

    }

    function getMoonLocksByAsset(address assetAddress) external view returns(MoonLock[] memory){
        return s_moonLocksByAsset[assetAddress];
    }

    function getMembershipManager() external view returns(IMembershipManager){
        return s_membershipManager;
    }

    function getCountOfMoonLocks() external view returns(uint256){
        return s_moonLockCount;
    }

    function getMoonLockFee() external view returns(uint256){
        return s_moonLockFee;
    }

    function isPaused() external view returns (bool) {
        return s_isPaused;
    }

    function updateFee(uint256 fee) external onlyOwner {
        s_moonLockFee = fee;
    }

    function changePauseStatus(bool action) public onlyOwner {
        s_isPaused = action;
    }

    function updateMembershipManager( address membershipManager ) external onlyOwner {
        s_membershipManager = IMembershipManager(membershipManager);
        emit MembershipManagerUpdated(membershipManager, block.timestamp);
    }

    function withdrawFunds() external onlyOwner {
        uint256 totalBalance = address(this).balance;
        if(totalBalance == 0){
            revert MoonLockFactory__NO_FUNDS_AVAILABLE();
        }
        payable(owner()).transfer(totalBalance);
    }

    receive() external payable {
        emit Received(msg.sender, msg.value);
    }

}
