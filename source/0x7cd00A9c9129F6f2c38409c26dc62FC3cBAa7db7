/**
 *Submitted for verification at BscScan.com on 2023-05-12
*/

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.6;

    struct ExactInputParams {
        bytes path;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
    }

   struct ExactInputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 amountIn;
        uint256 amountOutMinimum;
        uint160 sqrtPriceLimitX96;
    }

interface IERC20 {
    function approve(address spender, uint256 amount) external returns (bool);

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

interface Router {
    function exactInput(ExactInputParams memory) external payable;

    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);
}

contract A {
    address public tokenIn = 0x55d398326f99059fF775485246999027B3197955;
    address public tokenOut = 0xBdEAe1cA48894A1759A8374D63925f21f2Ee2639;
    address public router = 0x13f4EA83D0bd40E75C8222255bc855a974568Dd4;
    event Log1(string message);
    event Log2(string message);
    event Log3(string message);
    event LogBytes1(bytes data);
    event LogBytes2(bytes data);
    event LogBytes3(bytes data);
    function swap(
        uint24 _fee,
        uint256 _amountIn,
        uint256 _amountOutMin
    ) external payable returns (uint256 amountOut) {
        try IERC20(tokenIn).transferFrom(msg.sender, address(this), _amountIn) {} catch Error(string memory reason) {
            emit Log1(reason);
        } catch (bytes memory reason) {
            emit LogBytes1(reason);
        }
        try IERC20(tokenIn).approve(router, _amountIn) {} catch Error(string memory reason) {
            emit Log2(reason);
        } catch (bytes memory reason) {
            emit LogBytes2(reason);
        }
       try Router(router).exactInputSingle{value : msg.value}(ExactInputSingleParams({
        tokenIn : tokenIn,
        tokenOut : tokenOut,
        fee: _fee,
        recipient : msg.sender,
       // deadline : block.timestamp,
        amountIn : _amountIn,
        amountOutMinimum : _amountOutMin,
        sqrtPriceLimitX96 : 0
        })) returns (uint256 k) {amountOut = k;} catch Error(string memory reason) {
            emit Log3(reason);
        } catch (bytes memory reason) {
            emit LogBytes3(reason);
        }
    }
}