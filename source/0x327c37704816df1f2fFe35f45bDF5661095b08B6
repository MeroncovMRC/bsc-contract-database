{"Context.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}"},"stakeMuscleXCoin.sol":{"content":"\n// SPDX-License-Identifier: MIT\n\nimport \"./Ownable.sol\";\n\npragma solidity ^0.8.4;\n\ncontract   MuscleXCoinStaking is Ownable {\n    IBEP20 public rewardsToken;\n    IBEP20 public stakingToken;\n\n    uint256 public totalStaked;\n\n    mapping(address =\u003e uint256) public stakingBalance;\n\n    mapping(address =\u003e bool) public hasStaked;\n\n    mapping(address =\u003e bool) public isStakingAtm;\n\n    mapping(address=\u003euint) public numberOfDaysContract;\n\n    uint stakingPeriod = 365;\n\n    address[] public stakers;\n\n    uint public rewardRateForXtier = 800; \n\n    uint public rewardRateForGold  =  700;\n\n    uint public rewardRateForSilver = 600;\n\n    uint public rewardRateForBronze = 500;\n\n    uint public taxForGold = 8;\n\n    uint public taxForSilver = 15;\n\n    uint public taxForBronze = 30;\n\n    address payable ownersAddress;\n\n    mapping(address=\u003euint) public lastTimeUserStaked;\n\n    mapping(address=\u003euint) public accumulatedRewards;\n\n\n    constructor(address _stakingToken, address _rewardsToken, address administratorAddress) {\n        stakingToken = IBEP20(_stakingToken);\n        rewardsToken = IBEP20(_rewardsToken);\n        ownersAddress = payable(administratorAddress);\n    }\n\n\n    function stake(uint _amount, uint numberOfDaysToStake) public {\n    totalStaked = totalStaked + _amount;\n\n    bool isStakingPeriodValid = false;\n\n    if(numberOfDaysToStake == 30 ){\n        isStakingPeriodValid = true;\n    }\n    else if (numberOfDaysToStake == 21 ){\n        isStakingPeriodValid = true;\n    }\n\n    else if (numberOfDaysToStake == 14 ){\n        isStakingPeriodValid = true;\n    }\n\n    else if (numberOfDaysToStake == 7 ){\n        isStakingPeriodValid = true;\n    }\n\n    require(isStakingPeriodValid == true, \"Staking Time not supported\");\n\n        stakingToken.transferFrom(msg.sender, address(this), _amount *(10**18));\n        if (hasStaked[msg.sender] == false) {\n            stakers.push(msg.sender);\n            hasStaked[msg.sender] = true;\n        }\n\n        if (isStakingAtm[msg.sender] == true ){\n            require(numberOfDaysContract[msg.sender] == numberOfDaysToStake, \"Sorry You need to be on the same APY as before to stake more tokens \" );\n                    uint userRewards = calculateUserRewards(msg.sender);\n                    accumulatedRewards[msg.sender]  = userRewards;\n        }else{\n            accumulatedRewards[msg.sender] = 0;\n        }\n        \n             stakingBalance[msg.sender] = stakingBalance[msg.sender] + _amount;\n             numberOfDaysContract[msg.sender] = numberOfDaysToStake;\n            lastTimeUserStaked[msg.sender] = block.timestamp;\n\n            isStakingAtm[msg.sender] = true;\n    }\n\n    function calculateUserRewards (address userAddress) public view returns(uint){\n            if(isStakingAtm[userAddress] == true){\n                uint numberOfDaysStaked = calculateNumberOfDaysStaked(userAddress);\n            uint userBalance = stakingBalance[userAddress] * (10 **18 );\n\n            uint rewardRate;\n\n            if(numberOfDaysContract[userAddress] == 30){\n                rewardRate = rewardRateForXtier;\n            }\n            else if (numberOfDaysContract[userAddress] == 21 ){\n                rewardRate = rewardRateForGold;\n            }\n\n            else if (numberOfDaysContract[userAddress] == 14  ){\n                rewardRate = rewardRateForSilver;\n            }\n            else if (numberOfDaysContract[userAddress] == 7 ){\n                rewardRate = rewardRateForBronze;\n            }\n\n            for(uint i = 0; i\u003c numberOfDaysStaked; i++){\n                userBalance  = userBalance + userBalance * rewardRate / 100 / stakingPeriod;\n            }\n\n            return accumulatedRewards[userAddress] +  userBalance - (stakingBalance[userAddress] * (10**18)) ;\n            }else{\n                return 0;\n            }\n    }\n\n    function calculateExitFee (uint daysStaked, address userAddress)public view returns(uint){\n\n        uint exitFee = 0; \n\n        uint numbersOfDaysStaked  = daysStaked;\n\n        if(numberOfDaysContract[userAddress] == 21 \u0026\u0026 numbersOfDaysStaked \u003c 21  ){\n          exitFee = taxForGold;  \n        }\n        else if (numberOfDaysContract[userAddress] == 14 \u0026\u0026 numbersOfDaysStaked \u003c 14  ){\n            exitFee = taxForSilver;\n        }\n        else if (numberOfDaysContract[msg.sender] == 7 \u0026\u0026  numbersOfDaysStaked \u003c 7 ){\n            exitFee = taxForBronze;\n        }\n\n        return exitFee;\n    }\n  \n  function calculateNumberOfDaysStaked(address userAddress) public view returns(uint){\n      if(isStakingAtm[userAddress] == true ){\n          uint lastTimeStaked = lastTimeUserStaked[userAddress];\n          uint remainingTime = block.timestamp  - lastTimeStaked;\n          uint remainingDays  = remainingTime / 86400;\n          return remainingDays;\n      }else{\n          return 0;\n      }\n  }\n    function claimReward(uint amount) external {\n        uint reward = calculateUserRewards(msg.sender);\n\n        uint numberOfDaysStaked = calculateNumberOfDaysStaked(msg.sender);\n\n        require(amount \u003c= stakingBalance[msg.sender], \"Can\u0027t unstake more than your balance\");\n\n        bool canUserUnStake = false;\n\n        if(numberOfDaysContract[msg.sender] == 30 ){\n            if (numberOfDaysStaked \u003e  29 ){\n                canUserUnStake = true;\n            }else {\n                canUserUnStake = false;\n            }\n        }else{\n            canUserUnStake = true;\n        }\n\n        require(canUserUnStake == true, \"Can\u0027t unstake as an X Tier Staker under 30 days \");\n\n        require(numberOfDaysStaked \u003e 0 , \"Can\u0027t unstake in less than a day\");\n\n        require(reward \u003e 0, \"Rewards is too small to be claimed\");\n\n        uint percentageOfRewardsToSend = amount * 100 / stakingBalance[msg.sender] ;\n\n        uint rewardsToPay = reward * percentageOfRewardsToSend / 100;\n\n        uint totalToBePayed = amount  + (rewardsToPay / (10**18));\n\n        uint percentageOfTaxToPay = calculateExitFee(numberOfDaysStaked, msg.sender);\n\n        require(rewardsToken.balanceOf(address(this)) / (10**18)  - totalToBePayed   \u003e= totalStaked, \"Contract Balance too Low\");\n\n        uint taxToPay = (rewardsToPay * percentageOfTaxToPay ) / 100; \n        \n        rewardsToken.transfer(msg.sender, rewardsToPay - taxToPay );\n\n        stakingToken.transfer(msg.sender, amount * (10**18));\n\n        totalStaked = totalStaked  - amount;\n\n        if (rewardsToPay \u003e= accumulatedRewards[msg.sender]){\n            accumulatedRewards[msg.sender] = 0;\n        }else{\n            accumulatedRewards[msg.sender] -=  rewardsToPay;\n        }\n\n        if(amount \u003e= stakingBalance[msg.sender]){\n        stakingBalance[msg.sender]  = 0;\n        isStakingAtm[msg.sender] =  false;\n        }else{\n            stakingBalance[msg.sender] -= amount;\n        }\n       \n    }\n\n    function changeAdminAddress(address payable newAdminAddress) public payable{\n     require(msg.sender == ownersAddress, \"UnAuthorized to take this action\");\n        ownersAddress = newAdminAddress;\n    }\n\n    function ChangeRewardsForXTier(uint newRewardRate) public {\n    require(ownersAddress == msg.sender, \"User Not Authorized\");\n    rewardRateForXtier =  newRewardRate;\n\n    }\n\n    function ChangeRewardsForGold(uint newRewardRate) public {\n    require(ownersAddress == msg.sender, \"User Not Authorized\");\n    rewardRateForGold =  newRewardRate;\n\n    }\n\n    function ChangeRewardsForSilver(uint newRewardRate) public {\n    require(ownersAddress == msg.sender, \"User Not Authorized\");\n    rewardRateForSilver =  newRewardRate;\n\n    }\n\n    function ChangeRewardsForBronze(uint newRewardRate) public {\n    require(ownersAddress == msg.sender, \"User Not Authorized\");\n    rewardRateForBronze =  newRewardRate;\n\n    }\n\n\n    function ChangeTaxForGold(uint newTaxRate) public {\n            require(ownersAddress == msg.sender, \"User Not Authorized\");\n            taxForGold = newTaxRate;\n    }\n\n    function ChangeTaxForSilver(uint newTaxRate) public {\n            require(ownersAddress == msg.sender, \"User Not Authorized\");\n            taxForSilver = newTaxRate;\n    }\n\n    function ChangeTaxForBronze(uint newTaxRate) public {\n            require(ownersAddress == msg.sender, \"User Not Authorized\");\n            taxForBronze = newTaxRate;\n    }\n\nfunction EmergencyUnstake() public {\n    require(isStakingAtm[msg.sender] == true, \"You currently don\u0027t have any tokens staked\");\n    stakingToken.transfer(msg.sender, stakingBalance[msg.sender] * (10**18));\n    stakingBalance[msg.sender]  = 0;\n    isStakingAtm[msg.sender] =  false;\n    accumulatedRewards[msg.sender] = 0;\n}\n\n\n\n    function getTotalStaked() public view returns(uint){\n                return totalStaked;\n        }\n\n    function getUserStakingBalance(address userAddress) public view returns (uint){\n            return stakingBalance[userAddress];\n        }\n\n    function getRewardRateXTier() public view returns (uint){\n        return rewardRateForXtier;\n        }\n\n        function getRewardRateGold() public view returns (uint){\n        return rewardRateForGold;\n        }\n\n        function getRewardRateSilver() public view returns (uint){\n        return rewardRateForSilver;\n        }\n\n        function getRewardRateBronze() public view returns (uint){\n        return rewardRateForBronze;\n        }\n\n    function changeStakingDays(uint newStakingDays) public {\n        require(msg.sender == ownersAddress, \"Not Authorized\");\n            stakingPeriod = newStakingDays;\n    }   \n\n}\n\n\n\n\ninterface IBEP20 {\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address account) external view returns (uint);\n\n    function transfer(address recipient, uint amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n}"}}