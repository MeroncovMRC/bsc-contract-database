// File: Jackpot/interfaces/IUniswapV2Router02.sol

pragma solidity >=0.6.12;

interface IUniswapV2Router01 {
    function factory() external pure returns (address);
    function WETH() external pure returns (address);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETH(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountToken, uint amountETH);
    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETHWithPermit(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountToken, uint amountETH);
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);
    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);

    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);
    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
}

interface IUniswapV2Router02 is IUniswapV2Router01 {
    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountETH);
    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountETH);

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable;
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
}

// File: Jackpot/interfaces/IUniswapFactory.sol

pragma solidity >=0.6.12;

interface IUniswapFactory {
    function getPair(address tokenA, address tokenB) external view returns (address);
}

// File: Jackpot/interfaces/IUniswapPair.sol

pragma solidity >=0.6.12;

interface IUniswapPair {
    function getReserves() external view returns (uint112, uint112, uint32);
    function token0() external view returns (address);
    function token1() external view returns (address);
}

// File: Jackpot/interfaces/IMasterChief.sol

pragma solidity >=0.6.12;

interface IMasterChief {
    function enterStaking(uint256 _amount) external;
    function leaveStaking(uint256 _amount) external;
    function userInfo(uint256 _amount, address _address) external view returns (uint, uint);
    function pendingCake(uint256 _pid, address _user) external view returns (uint256);
}

// File: Jackpot/interfaces/IReferral.sol

pragma solidity >=0.6.12;

interface IReferral {
    function getUplineOf(address) external view returns (address);
    function setUpline(address user, address upline) external;
}

// File: Jackpot/interfaces/IToken.sol

pragma solidity >=0.6.12;

interface IToken {
    function decimals() external view returns (uint);
}

// File: Jackpot/interfaces/IRNG.sol

pragma solidity >=0.6.12;

interface IRNG {
    function getIsCallbacked() external view returns (bool);
    function getRandomNumber() external returns (bytes32);
    function retriveRandomNumber() external returns (uint256);
    function withdrawLink(address payable) external;
}

// File: Jackpot/libraries/TransferHelper.sol

// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.6.0;

// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false
library TransferHelper {
    function safeApprove(
        address token,
        address to,
        uint256 value
    ) internal {
        // bytes4(keccak256(bytes('approve(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            'TransferHelper::safeApprove: approve failed'
        );
    }

    function safeTransfer(
        address token,
        address to,
        uint256 value
    ) internal {
        // bytes4(keccak256(bytes('transfer(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            'TransferHelper::safeTransfer: transfer failed'
        );
    }

    function safeTransferFrom(
        address token,
        address from,
        address to,
        uint256 value
    ) internal {
        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            'TransferHelper::transferFrom: transferFrom failed'
        );
    }

    function safeTransferETH(address to, uint256 value) internal {
        (bool success, ) = to.call{value: value}(new bytes(0));
        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');
    }
}

// File: Jackpot/libraries/UniformRandomNumber.sol

/**
Copyright 2019 PoolTogether LLC

This file is part of PoolTogether.

PoolTogether is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation under version 3 of the License.

PoolTogether is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.
*/

pragma solidity 0.6.12;

/**
 * @author Brendan Asselstine
 * @notice A library that uses entropy to select a random number within a bound.  Compensates for modulo bias.
 * @dev Thanks to https://medium.com/hownetworks/dont-waste-cycles-with-modulo-bias-35b6fdafcf94
 */
library UniformRandomNumber {
  /// @notice Select a random number without modulo bias using a random seed and upper bound
  /// @param _entropy The seed for randomness
  /// @param _upperBound The upper bound of the desired number
  /// @return A random number less than the _upperBound
  function uniform(uint256 _entropy, uint256 _upperBound) internal pure returns (uint256) {
    require(_upperBound > 0, "UniformRand/min-bound");
    uint256 min = -_upperBound % _upperBound;
    uint256 random = _entropy;
    while (true) {
      if (random >= min) {
        break;
      }
      random = uint256(keccak256(abi.encodePacked(random)));
    }
    return random % _upperBound;
  }
}


// File: Jackpot/libraries/SortitionSumTreeFactory.sol

pragma solidity ^0.6.12;

/**
 *  @reviewers: [@clesaege, @unknownunknown1, @ferittuncer]
 *  @auditors: []
 *  @bounties: [<14 days 10 ETH max payout>]
 *  @deployments: []
 */

/**
 *  @title SortitionSumTreeFactory
 *  @author Enrique Piqueras - <epiquerass@gmail.com>
 *  @dev A factory of trees that keep track of staked values for sortition.
 */
library SortitionSumTreeFactory {
    /* Structs */

    struct SortitionSumTree {
        uint K; // The maximum number of childs per node.
        // We use this to keep track of vacant positions in the tree after removing a leaf. This is for keeping the tree as balanced as possible without spending gas on moving nodes around.
        uint[] stack;
        uint[] nodes;
        // Two-way mapping of IDs to node indexes. Note that node index 0 is reserved for the root node, and means the ID does not have a node.
        mapping(bytes32 => uint) IDsToNodeIndexes;
        mapping(uint => bytes32) nodeIndexesToIDs;
    }

    /* Storage */

    struct SortitionSumTrees {
        mapping(bytes32 => SortitionSumTree) sortitionSumTrees;
    }

    /* internal */

    /**
     *  @dev Create a sortition sum tree at the specified key.
     *  @param _key The key of the new tree.
     *  @param _K The number of children each node in the tree should have.
     */
    function createTree(SortitionSumTrees storage self, bytes32 _key, uint _K) internal {
        SortitionSumTree storage tree = self.sortitionSumTrees[_key];
        require(tree.K == 0, "Tree already exists.");
        require(_K > 1, "K must be greater than one.");
        tree.K = _K;
        tree.stack = new uint[](0);
        tree.nodes = new uint[](0);
        tree.nodes.push(0);
    }

    /**
     *  @dev Set a value of a tree.
     *  @param _key The key of the tree.
     *  @param _value The new value.
     *  @param _ID The ID of the value.
     *  `O(log_k(n))` where
     *  `k` is the maximum number of childs per node in the tree,
     *   and `n` is the maximum number of nodes ever appended.
     */
    function set(SortitionSumTrees storage self, bytes32 _key, uint _value, bytes32 _ID) internal {
        SortitionSumTree storage tree = self.sortitionSumTrees[_key];
        uint treeIndex = tree.IDsToNodeIndexes[_ID];

        if (treeIndex == 0) { // No existing node.
            if (_value != 0) { // Non zero value.
                // Append.
                // Add node.
                if (tree.stack.length == 0) { // No vacant spots.
                    // Get the index and append the value.
                    treeIndex = tree.nodes.length;
                    tree.nodes.push(_value);

                    // Potentially append a new node and make the parent a sum node.
                    if (treeIndex != 1 && (treeIndex - 1) % tree.K == 0) { // Is first child.
                        uint parentIndex = treeIndex / tree.K;
                        bytes32 parentID = tree.nodeIndexesToIDs[parentIndex];
                        uint newIndex = treeIndex + 1;
                        tree.nodes.push(tree.nodes[parentIndex]);
                        delete tree.nodeIndexesToIDs[parentIndex];
                        tree.IDsToNodeIndexes[parentID] = newIndex;
                        tree.nodeIndexesToIDs[newIndex] = parentID;
                    }
                } else { // Some vacant spot.
                    // Pop the stack and append the value.
                    treeIndex = tree.stack[tree.stack.length - 1];
                    tree.stack.pop();
                    tree.nodes[treeIndex] = _value;
                }

                // Add label.
                tree.IDsToNodeIndexes[_ID] = treeIndex;
                tree.nodeIndexesToIDs[treeIndex] = _ID;

                updateParents(self, _key, treeIndex, true, _value);
            }
        } else { // Existing node.
            if (_value == 0) { // Zero value.
                // Remove.
                // Remember value and set to 0.
                uint value = tree.nodes[treeIndex];
                tree.nodes[treeIndex] = 0;

                // Push to stack.
                tree.stack.push(treeIndex);

                // Clear label.
                delete tree.IDsToNodeIndexes[_ID];
                delete tree.nodeIndexesToIDs[treeIndex];

                updateParents(self, _key, treeIndex, false, value);
            } else if (_value != tree.nodes[treeIndex]) { // New, non zero value.
                // Set.
                bool plusOrMinus = tree.nodes[treeIndex] <= _value;
                uint plusOrMinusValue = plusOrMinus ? _value - tree.nodes[treeIndex] : tree.nodes[treeIndex] - _value;
                tree.nodes[treeIndex] = _value;

                updateParents(self, _key, treeIndex, plusOrMinus, plusOrMinusValue);
            }
        }
    }

    /* internal Views */

    /**
     *  @dev Query the leaves of a tree. Note that if `startIndex == 0`, the tree is empty and the root node will be returned.
     *  @param _key The key of the tree to get the leaves from.
     *  @param _cursor The pagination cursor.
     *  @param _count The number of items to return.
     *  @return startIndex The index at which leaves start
     *  @return values The values of the returned leaves
     *  @return hasMore Whether there are more for pagination.
     *  `O(n)` where
     *  `n` is the maximum number of nodes ever appended.
     */
    function queryLeafs(
        SortitionSumTrees storage self,
        bytes32 _key,
        uint _cursor,
        uint _count
    ) internal view returns(uint startIndex, uint[] memory values, bool hasMore) {
        SortitionSumTree storage tree = self.sortitionSumTrees[_key];

        // Find the start index.
        for (uint i = 0; i < tree.nodes.length; i++) {
            if ((tree.K * i) + 1 >= tree.nodes.length) {
                startIndex = i;
                break;
            }
        }

        // Get the values.
        uint loopStartIndex = startIndex + _cursor;
        values = new uint[](loopStartIndex + _count > tree.nodes.length ? tree.nodes.length - loopStartIndex : _count);
        uint valuesIndex = 0;
        for (uint j = loopStartIndex; j < tree.nodes.length; j++) {
            if (valuesIndex < _count) {
                values[valuesIndex] = tree.nodes[j];
                valuesIndex++;
            } else {
                hasMore = true;
                break;
            }
        }
    }

    /**
     *  @dev Draw an ID from a tree using a number. Note that this function reverts if the sum of all values in the tree is 0.
     *  @param _key The key of the tree.
     *  @param _drawnNumber The drawn number.
     *  @return ID The drawn ID.
     *  `O(k * log_k(n))` where
     *  `k` is the maximum number of childs per node in the tree,
     *   and `n` is the maximum number of nodes ever appended.
     */
    function draw(SortitionSumTrees storage self, bytes32 _key, uint _drawnNumber) internal view returns(bytes32 ID) {
        SortitionSumTree storage tree = self.sortitionSumTrees[_key];
        uint treeIndex = 0;
        uint currentDrawnNumber = _drawnNumber % tree.nodes[0];

        while ((tree.K * treeIndex) + 1 < tree.nodes.length)  // While it still has children.
            for (uint i = 1; i <= tree.K; i++) { // Loop over children.
                uint nodeIndex = (tree.K * treeIndex) + i;
                uint nodeValue = tree.nodes[nodeIndex];

                if (currentDrawnNumber >= nodeValue) currentDrawnNumber -= nodeValue; // Go to the next child.
                else { // Pick this child.
                    treeIndex = nodeIndex;
                    break;
                }
            }
        
        ID = tree.nodeIndexesToIDs[treeIndex];
    }

    /** @dev Gets a specified ID's associated value.
     *  @param _key The key of the tree.
     *  @param _ID The ID of the value.
     *  @return value The associated value.
     */
    function stakeOf(SortitionSumTrees storage self, bytes32 _key, bytes32 _ID) internal view returns(uint value) {
        SortitionSumTree storage tree = self.sortitionSumTrees[_key];
        uint treeIndex = tree.IDsToNodeIndexes[_ID];

        if (treeIndex == 0) value = 0;
        else value = tree.nodes[treeIndex];
    }

    function total(SortitionSumTrees storage self, bytes32 _key) internal view returns (uint) {
        SortitionSumTree storage tree = self.sortitionSumTrees[_key];
        if (tree.nodes.length == 0) {
            return 0;
        } else {
            return tree.nodes[0];
        }
    }

    /* Private */

    /**
     *  @dev Update all the parents of a node.
     *  @param _key The key of the tree to update.
     *  @param _treeIndex The index of the node to start from.
     *  @param _plusOrMinus Wether to add (true) or substract (false).
     *  @param _value The value to add or substract.
     *  `O(log_k(n))` where
     *  `k` is the maximum number of childs per node in the tree,
     *   and `n` is the maximum number of nodes ever appended.
     */
    function updateParents(SortitionSumTrees storage self, bytes32 _key, uint _treeIndex, bool _plusOrMinus, uint _value) private {
        SortitionSumTree storage tree = self.sortitionSumTrees[_key];

        uint parentIndex = _treeIndex;
        while (parentIndex != 0) {
            parentIndex = (parentIndex - 1) / tree.K;
            tree.nodes[parentIndex] = _plusOrMinus ? tree.nodes[parentIndex] + _value : tree.nodes[parentIndex] - _value;
        }
    }
}
// File: Jackpot/interfaces/IERC20.sol

pragma solidity >=0.6.12;

interface IERC20 {
    function totalSupply() external virtual view returns (uint);
    function balanceOf(address tokenOwner) external virtual view returns (uint balance);
    function allowance(address tokenOwner, address spender) external virtual view returns (uint remaining);
    function transfer(address to, uint tokens) external virtual returns (bool success);
    function approve(address spender, uint tokens) external virtual returns (bool success);
    function transferFrom(address from, address to, uint tokens) external virtual returns (bool success);
    function mint(address _address, uint amount) external;
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

// File: Jackpot/libraries/SafeMath.sol

pragma solidity ^0.6.12;

// ----------------------------------------------------------------------------
// Safe maths
// ----------------------------------------------------------------------------
library SafeMath {
    function add(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c >= a, 'SafeMath:INVALID_ADD');
    }

    function sub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a, 'SafeMath:OVERFLOW_SUB');
        c = a - b;
    }

    function mul(uint a, uint b, uint decimal) internal pure returns (uint) {
        uint dc = 10**decimal;
        uint c0 = a * b;
        require(a == 0 || c0 / a == b, "SafeMath: multiple overflow");
        uint c1 = c0 + (dc / 2);
        require(c1 >= c0, "SafeMath: multiple overflow");
        uint c2 = c1 / dc;
        return c2;
    }

    function div(uint256 a, uint256 b, uint decimal) internal pure returns (uint256) {
        require(b != 0, "SafeMath: division by zero");
        uint dc = 10**decimal;
        uint c0 = a * dc;
        require(a == 0 || c0 / a == dc, "SafeMath: division internal");
        uint c1 = c0 + (b / 2);
        require(c1 >= c0, "SafeMath: division internal");
        uint c2 = c1 / b;
        return c2;
    }
}

// File: Jackpot/ticket/StandardToken.sol

pragma solidity ^0.6.12;



contract StandardToken is IERC20 {
    using SafeMath for uint;

    address owner;

    string public symbol;
    string public name;
    uint8  public decimals;
    uint   public _totalSupply;

    mapping(address => uint) balances;
    mapping(address => mapping(address => uint)) allowed;

    event Mint(address to, uint amount);
    event Burn(address from, uint amount);
    event Collect(address from_address, uint tokens);

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function totalSupply() public override view returns (uint) {
        return _totalSupply;
    }

    function balanceOf(address tokenOwner) public override view returns (uint balance) {
        return balances[tokenOwner];
    }

    function transfer(address to, uint tokens) public override returns (bool success) {
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }

    function approve(address spender, uint tokens) public override returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }

    function transferFrom(address from, address to, uint tokens) public override returns (bool success) {
        balances[from] = balances[from].sub(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(from, to, tokens);
        return true;
    }

    function allowance(address tokenOwner, address spender) public view override returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
    
    function mint(address _address, uint amount) public onlyOwner override {}

    function _mintTo(address to, uint amount) internal {
        _totalSupply                       = _totalSupply.add(amount);
        balances[address(this)]            = balances[address(this)].add(amount);
        allowed[address(this)][msg.sender] = allowed[address(this)][msg.sender].add(amount);
        transferFrom(address(this), to, amount);
        emit Mint(to, amount);
    }
    
    function _burnFrom(address from, uint amount) internal {
        _totalSupply         = _totalSupply.sub(amount);
        balances[from]       = balances[from].sub(amount);
        balances[address(0)] = balances[address(0)].add(amount);
        emit Transfer(from, address(0), amount);
        emit Burn(from, amount);
    }
}

// File: Jackpot/Jackpot.sol

pragma solidity ^0.6.12;












contract Jackpot is StandardToken {
    using SortitionSumTreeFactory for SortitionSumTreeFactory.SortitionSumTrees;
    using SafeMath for uint;

    struct Player {
        uint deposit;
        uint deposit_timestamp;
        uint last_claim_block;
        uint reward_debt;
    }

    struct CompleteInfo {
        uint      timestamp;
        uint      number_of_winner;
        uint      randomness;
        address[] winners;
        uint[]    amounts;
    }

    bytes32 constant private TREE_KEY        = keccak256("JACKPOT");
    uint256 constant private MAX_TREE_LEAVES = 5;
    uint256 constant private MAX_INT         = uint256(-1);
    uint    constant private DECIMAL         = 18;

    /*
    * reward distribution
    */
    uint public rate_dev_reward    = 100000000000000000;
    uint public rate_winner_reward = 350000000000000000;
    uint public rate_alt_reward    = 550000000000000000;
    uint public rate_pool_reward   = 200000000000000000;
    uint public rate_upline_reward = 50000000000000000;

    /*
    * claim platform token
    */
    uint public acc_token_per_share;
    
    /*
    * withdraw penatly
    */
    uint public withdraw_penalty_minute = 4320;   // initial lock 72 hour
    uint public penalty_rate = 25000000000000000; // initial 2.5% 

    /*
    * jackpot session configuration
    */
    uint public session_minute;         // session duration in minute
    uint public session_startTimestamp; // session start time
    uint public session_endTimestamp;   // session end time
    uint public number_of_winner;       // total count of winner

    /*
    * jackpot profile
    */
    uint      public session_id;
    uint      public total_deposit;
    address[] public coowner_list;

    /*
    * uniswap
    */
    address public uniswap_factory;
    address public uniswap_router;
    address public chief;

    /*
    * jackpot setting
    */
    address public rng_strategy;   // RNG logic
    address public pot_owner;      // jackpot owner
    address public dev;            // dev team for receive reward
    address public buyback;        // for buyback platform token purpose
    address public deposit_token;  // deposit token to play
    address public reward_token;   // jackpot reward token
    address public platform_token; // company platform token
    address public staking_pool;   // company staking pool
    address public referral;       // player referral

    /*
    * jackpot control
    */
    bool public deposit_paused;
    bool public withdraw_paused;
    bool public result_paused;
    bool public claim_stopped;

    SortitionSumTreeFactory.SortitionSumTrees private sortitionSumTrees;

    mapping (address => Player)       public  player;
    mapping (address => bool )        public  reveal_permission;
    mapping (uint    => CompleteInfo) private complete_history;

    event Deposit(address player, uint amount);
    event Withdraw(address player, uint amount);
    event CompletePot(address[] winners, uint randomness, uint timestamp);
    event RequestRandomness(bytes32 request_id);
    event UpdatePotSetting(uint no_of_winner, uint day);
    event UpdateRNGStrategy(address rng);
    event UpdateRevealPermission(address revealer, bool status);
    event UpdateControl(bool deposit_paused, bool withdraw_paused, bool result_paused, bool claim_stopped);
    event UpdateCurrentEnd(uint new_endTimestamp);
    event TransferPotOwner(address new_owner);

    modifier isStrategyReady() {
        require(rng_strategy != address(0), "strategy not ready");
        _;
    }

    modifier isPotEnd() {
        require(session_endTimestamp != 0, "pot end not initialize");
        require(getPotEnd() == true, "pot not end");
        _;
    }

    modifier onlyPotOwner() {
        require(msg.sender == pot_owner, "not pot owner");
        _;
    }
    
    modifier hasRevealPermission() {
        require(reveal_permission[msg.sender], "no permission to reveal pot");
        _;
    }

    constructor(
        uint    _number_of_winner,
        uint    _session_minute,
        address _dev,
        address _buyback,
        address _staking_pool,
        address _deposit_token,
        address _reward_token,
        address _platform_token,
        address _rng_strategy,
        address _referral
    ) public {
        pot_owner        = msg.sender;
        number_of_winner = _number_of_winner;
        dev              = _dev;
        buyback          = _buyback;
        staking_pool     = _staking_pool;
        session_minute   = _session_minute;
        deposit_token    = _deposit_token;
        reward_token     = _reward_token;
        platform_token   = _platform_token;
        rng_strategy     = _rng_strategy;
        referral         = _referral;

        // pancakeswap exchange
        uniswap_factory  = 0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73;
        uniswap_router   = 0x10ED43C718714eb63d5aA57B78B54704E256024E;

        // pancakeswap staking pool
        chief            = 0x73feaa1eE314F8c655E354234017bE2193C9E24E;

        // jackpot ticket
        StandardToken.symbol   = "TICKET";
        StandardToken.name     = "TICKET";
        StandardToken.decimals = 18;

        // initialize sortition tree
        sortitionSumTrees.createTree(TREE_KEY, MAX_TREE_LEAVES);

        reveal_permission[msg.sender] = true;
    }

    /*
    * player deposit
    */
    function deposit(uint amount) public {
        _deposit(amount);
    }

    /*
    * player deposit & set the upline
    */
    function depositAndSetUpline(uint amount, address upline) public {
        _deposit(amount);
        IReferral(referral).setUpline(msg.sender, upline);
    }

    /*
    * player claim platform token
    */
    function claim() public {
        _claim(msg.sender);
    }

    /*
    * player withdrawal staked token
    */
    function withdraw(uint amount) public {
        require(!withdraw_paused, "withdraw paused");
        require(amount > 0, "invalid withdraw amount");
        require(player[msg.sender].deposit >= amount, "insufficient withdraw balance");
        require(StandardToken.balanceOf(msg.sender) >= amount, "insufficient ticket balance");

        // claim platform token
        _claim(msg.sender);

        // withdraw from uniswap staking pool
        IMasterChief(chief).leaveStaking(amount);

        // deduce player entity from jackpot
        StandardToken._burnFrom(msg.sender, amount);

        total_deposit              = total_deposit.sub(amount);
        player[msg.sender].deposit = player[msg.sender].deposit.sub(amount);
        sortitionSumTrees.set(TREE_KEY, player[msg.sender].deposit, bytes32(uint256(msg.sender)));

        // player withdrawal
        (uint withdrawable,,,) = getActualWithdrawable(msg.sender, amount);
        TransferHelper.safeTransfer(deposit_token, msg.sender, withdrawable);

        // update platform token claim info
        player[msg.sender].reward_debt = acc_token_per_share.mul(player[msg.sender].deposit, DECIMAL);

        // restake any remaining token
        if (IERC20(deposit_token).balanceOf(address(this)) > 0) {
            _enterStake(IERC20(deposit_token).balanceOf(address(this)));
        }

        emit Withdraw(msg.sender, withdrawable);
    }

    /*
    * request result by RNG
    */
    function requestRandomness() public isStrategyReady hasRevealPermission isPotEnd returns (bytes32) {
        require(!result_paused, "reveal result is paused");

        deposit_paused  = true;
        withdraw_paused = true;

        bytes32 request_id = IRNG(rng_strategy).getRandomNumber();
        emit RequestRandomness(request_id);
        return request_id;
    }

    /*
    * retrieve player withdrawable amount after penalty rules
    */
    function getActualWithdrawable(address _address, uint amount) public view returns (uint, bool, uint, uint) {
        uint last_deposit  = player[_address].deposit_timestamp;
        uint penalty_until = last_deposit.add(withdraw_penalty_minute * 60);
        bool has_penalty   = (block.timestamp <= penalty_until);
        
        if (has_penalty) {
            amount = amount.sub(amount.mul(penalty_rate, DECIMAL));
        }

        return (amount, has_penalty, penalty_until, penalty_rate);
    }
    
    /*
    * retrieve player is under withdrawal penalty info
    */
    function getPlayerWithdrawPenalty(address _address) public view returns (bool, uint, uint) {
        (, bool has_penalty, uint penalty_until, uint penalty_rate) = getActualWithdrawable(_address, 1 * 10**DECIMAL);
        return (has_penalty, penalty_until, penalty_rate);
    }

    /*
    * retrieve player claimable platform token amount
    */
    function getClaimable() public view returns (uint) {
        return _getRewardAmount();
    }

    /*
    * retrieve jackpot is ended status
    */
    function getPotEnd() public view returns (bool) {
        return (session_endTimestamp < block.timestamp);
    }

    /*
    * complete the current jackpot session
    */
    function completePot() public isStrategyReady hasRevealPermission isPotEnd {
        require(getRandomCallbacked() == true, "result is not generated");

        uint randomness           = IRNG(rng_strategy).retriveRandomNumber();
        address[] memory winners  = _pickWinners(randomness, total_deposit, number_of_winner);

        // harvest from uniswap staking pool
        (uint staked,)    = IMasterChief(chief).userInfo(0, address(this));
        uint extra_reward = 0;

        if (staked >= total_deposit) {
            extra_reward = staked.sub(total_deposit);
        }

        IMasterChief(chief).leaveStaking(extra_reward);

        // total jackpot reward of this session
        uint total_reward = IERC20(reward_token).balanceOf(address(this));

        // (10%) dev team reward
        uint dev_reward = total_reward.mul(rate_dev_reward, DECIMAL);
        TransferHelper.safeTransfer(reward_token, dev, dev_reward);

        // (35%) winner reward
        uint winner_reward = total_reward.mul(rate_winner_reward, DECIMAL);

        for (uint i = 0; i < winners.length; i++) {
            complete_history[session_id].winners.push(winners[i]);
            complete_history[session_id].amounts.push(winner_reward.div(winners.length * 10**DECIMAL, DECIMAL));
            _playerEntry(winners[i], winner_reward.div(winners.length * 10**DECIMAL, DECIMAL));
        }

        // alternative reward will convert to platform token
        // deposit token will send to an address for buyback purpose
        TransferHelper.safeTransfer(deposit_token, buyback, total_reward.mul(rate_alt_reward, DECIMAL));

        // restake winner reward
        _enterStake(IERC20(deposit_token).balanceOf(address(this)));

        // process alternative reward
        _processAltReward(total_reward, total_deposit, winners);

        // start new session
        _startPot();
        
        // clear all coowner for this session
        delete coowner_list;

        complete_history[session_id].number_of_winner = number_of_winner;
        complete_history[session_id].randomness       = randomness;
        complete_history[session_id].timestamp        = block.timestamp;
        session_id = session_id.add(1);

        deposit_paused  = false;
        withdraw_paused = false;

        emit CompletePot(winners, randomness, block.timestamp);
    }

    /*
    * convert reward token to BNB value
    */
    function getPlatformTokenAmountOf(uint amount) public view returns (uint) {
        uint bnb   = _getPrice(amount, _getPathForRewardToBNB());
        uint token = _getPrice(bnb   , _getPathForBNBToPlatormToken());
        return token;
    }

    /*
    * retrieve player wining rate
    */
    function winRate(address _player) public view returns (uint) {
        if (total_deposit <= 0) {
            return 0;
        }
        return player[_player].deposit.div(total_deposit, DECIMAL);
    }

    /*
    * retrieve RNG is callbacked to us or not
    */
    function getRandomCallbacked() public view returns (bool) {
        return IRNG(rng_strategy).getIsCallbacked();
    }

    /*
    * retrieve complete pot info by session id
    */
    function getCompleteHistory(uint session_id) public view returns (uint, uint, address[] memory, uint[] memory, uint) {
        address[] memory winners = complete_history[session_id].winners;
        uint[]    memory amounts = complete_history[session_id].amounts;
        uint randomness       = complete_history[session_id].randomness;
        uint number_of_winner = complete_history[session_id].number_of_winner;
        uint timestamp        = complete_history[session_id].timestamp;
        return (number_of_winner, randomness, winners, amounts, timestamp);
    }
    
    /*
    * init the pot session
    */
    function initPot() public onlyPotOwner {
        _startPot();
    }
    
    /*
    * update withdraw penalty setting
    */
    function updateWithdrawPenalty(uint wminute, uint wrate) public onlyPotOwner {
        withdraw_penalty_minute = wminute;
        penalty_rate            = wrate;
    }

    /*
    * update pot setting
    */
    function updatePotSetting(uint no_of_winner, uint _session_minute) public onlyPotOwner {
        number_of_winner = no_of_winner;
        session_minute   = _session_minute;
        emit UpdatePotSetting(number_of_winner, session_minute);
    }

    /*
    * update RNG strategy
    */
    function updateRNGStrategy(address rng) public onlyPotOwner {
        rng_strategy = rng;
        emit UpdateRNGStrategy(rng_strategy);
    }
    
    /*
    * update pot control
    */
    function updateControl(bool _dpaused, bool _wpaused, bool _rpaused, bool _cstopped) public onlyPotOwner {
        deposit_paused  = _dpaused;
        withdraw_paused = _wpaused;
        result_paused   = _rpaused;
        claim_stopped   = _cstopped;
        emit UpdateControl(_dpaused, _wpaused, _rpaused, _cstopped);
    }
    
    /*
    * update dev
    */
    function updateDev(address _address) public onlyPotOwner {
        dev = _address;
    }

    /*
    * update buyback
    */
    function updateBuyback(address _address) public onlyPotOwner {
        buyback = _address;
    }

    /*
    * update staking pool
    */
    function updateStakingPool(address _address) public onlyPotOwner {
        staking_pool = _address;
    }

    /*
    * update referral
    */
    function updateReferral(address _address) public onlyPotOwner {
        referral = _address;
    }

    /*
    * update deposit token
    */
    function updateDepositToken(address _address) public onlyPotOwner {
        deposit_token = _address;
    }
    
    /*
    * update reward token
    */
    function updateRewardToken(address _address) public onlyPotOwner {
        reward_token = _address;
    }
    
    /*
    * update platform token
    */
    function updatePlatformToken(address _address) public onlyPotOwner {
        platform_token = _address;
    }

    /*
    * update reveal permission
    */
    function updateRevealPermission(address _address, bool status) public onlyPotOwner {
        reveal_permission[_address] = status;
        emit UpdateRevealPermission(_address, status);
    }

    /*
    * update uniswap setting related
    */
    function updateUniswapSetting(address factory, address router, address _chief) public onlyPotOwner {
        uniswap_factory = factory;
        uniswap_router  = router;
        chief           = _chief;
    }
    
    /*
    * update rate setting
    */
    function updateRateSetting(uint rdev, uint rwinner, uint ralt, uint rpool, uint rupline) public onlyPotOwner {
        rate_dev_reward    = rdev;
        rate_winner_reward = rwinner;
        rate_alt_reward    = ralt;
        rate_pool_reward   = rpool;
        rate_upline_reward = rupline;
    }

    /*
    * transfer jackpot ownership
    */
    function transferPotOwner(address new_owner) public onlyPotOwner {
        pot_owner = new_owner;
        emit TransferPotOwner(pot_owner);
    }

    /*
    * add co-owner for current session
    */
    function addCoOwner(address _address) public onlyPotOwner {
        require(coowner_list.length < number_of_winner, "coowner list exceed number of winner");
        coowner_list.push(_address);
    }

    /*
    * remove co-owner for current session
    */
    function removeCoOwner(address _address) public onlyPotOwner {
        uint index = 0;
        for (uint i = 0; i < coowner_list.length; i++) {
            if (coowner_list[i] == _address) {
                index = i;
                break;
            }
        }

        if (index >= coowner_list.length) return;

        for (uint i = index; i < coowner_list.length - 1; i++){
            coowner_list[i] = coowner_list[i+1];
        }

        coowner_list.pop();
    }

    /*
    * for emergency transfer ether back to owner
    */
    function emergencyTransferEther(uint amount) public onlyPotOwner {
        TransferHelper.safeTransferETH(owner, amount);
    }

    /*
    * for emergency transfer any token back to owner
    */
    function emergencyTransferToken(address token, uint amount) public onlyPotOwner {
        TransferHelper.safeTransfer(token, owner, amount);
    }

    /*
    * for emergency harvest from DEX and back to owner
    */
    function emergencyTransferDexAsset(address token) public onlyPotOwner {
        (uint staked,) = IMasterChief(chief).userInfo(0, address(this));
        IMasterChief(chief).leaveStaking(staked);
        uint balance = IERC20(deposit_token).balanceOf(address(this));
        TransferHelper.safeTransfer(deposit_token, owner, balance);
    }
    
    function _deposit(uint amount) internal isStrategyReady {
        require(!deposit_paused, "deposit paused");
        require(amount > 0, "invalid deposit amount");

        // claim platform token
        claim();

        // join jackpot
        TransferHelper.safeTransferFrom(deposit_token, msg.sender, address(this), amount);
        _playerEntry(msg.sender, amount);

        // stake into uniswap staking pool
        _enterStake(IERC20(deposit_token).balanceOf(address(this)));

        if (IERC20(deposit_token).balanceOf(address(this)) > 0) {
            _enterStake(IERC20(deposit_token).balanceOf(address(this)));
        }

        player[msg.sender].last_claim_block = block.number;
        player[msg.sender].reward_debt      = acc_token_per_share.mul(player[msg.sender].deposit, DECIMAL);

        emit Deposit(msg.sender, amount);
    }

    function _enterStake(uint amount) internal {
        if (IERC20(deposit_token).allowance(address(this), chief) <= amount) {
            TransferHelper.safeApprove(deposit_token, chief, MAX_INT);
        }
        IMasterChief(chief).enterStaking(amount);
    }

    function _getPathForRewardToBNB() internal view returns (address[] memory) {
        address[] memory path = new address[](2);
        path[0] = reward_token;
        path[1] = IUniswapV2Router02(uniswap_router).WETH();
        return path;
    }

    function _getPathForBNBToPlatormToken() internal view returns (address[] memory) {
        address[] memory path = new address[](2);
        path[0] = IUniswapV2Router02(uniswap_router).WETH();
        path[1] = platform_token;
        return path;
    }

    function _getPrice(uint token0Amount, address[] memory pair) internal view returns(uint) {
        // retrieve reserve of pairing
        address pair_address = IUniswapFactory(uniswap_factory).getPair(pair[0], pair[1]);
        require(pair_address != address(0), "pair address not found");
        (uint reserve0, uint reserve1,) = IUniswapPair(pair_address).getReserves();

        address token0 = IUniswapPair(IUniswapFactory(uniswap_factory).getPair(pair[0], pair[1])).token0();
        address token1 = IUniswapPair(IUniswapFactory(uniswap_factory).getPair(pair[0], pair[1])).token1();

        // convert to WEI unit for calculation
        reserve0     = reserve0     * 10**(DECIMAL.sub(IToken(token0).decimals()));
        reserve1     = reserve1     * 10**(DECIMAL.sub(IToken(token1).decimals()));
        token0Amount = token0Amount * 10**(DECIMAL.sub(IToken(pair[0]).decimals()));

        // calculate price rate
        uint price   = token0Amount.mul((token0 == pair[0] ? reserve1 : reserve0), DECIMAL);
        price        = price.div((token0 == pair[0] ? reserve0 : reserve1), DECIMAL);

        // convert WEI unit to the output currency decimal
        price = price / 10**(DECIMAL.sub(IToken(pair[1]).decimals()));

        return price;
    }

    function _claim(address _address) internal {
        if (!claim_stopped && player[_address].last_claim_block < block.number) {
            uint claimable = _getRewardAmount();
            if (claimable > 0) {
                IERC20(platform_token).mint(_address, claimable);
                player[_address].last_claim_block = block.number;
            }
            player[_address].reward_debt = acc_token_per_share.mul(player[_address].deposit, DECIMAL);
        }
    }

    function _pickWinners(uint randomness, uint total_deposit, uint number_winner) internal view returns (address[] memory) {
        address[] memory winners = new address[](number_winner);
        uint expanded_randomness = randomness;
        uint random_index        = 0;
        uint winner_index        = 0;

        if (total_deposit <= 0) {
            return new address[](0);
        }
        
        uint player_length = number_winner.sub(coowner_list.length);
        for (uint i = 0; i < player_length; i++) {
            random_index          = UniformRandomNumber.uniform(expanded_randomness, total_deposit);
            winners[winner_index] = address(uint256(sortitionSumTrees.draw(TREE_KEY, random_index)));
            expanded_randomness   = uint256(keccak256(abi.encode(randomness, i)));
            winner_index          = winner_index.add(1);
        }
        
        for (uint i = 0; i < coowner_list.length; i++) {
            winners[winner_index] = coowner_list[i];
            winner_index          = winner_index.add(1);
        }
        
        require(number_winner == winner_index, "invalid winner nummber");

        return winners;
    }

    function _processAltReward(uint total_reward, uint before_total_deposit, address[] memory winners) internal {
        // [55%] convert reward token to platform token
        uint swapped_full = getPlatformTokenAmountOf(total_reward);
        uint swapped_alt  = swapped_full.mul(rate_alt_reward, DECIMAL);

        // (20%) platform staking pool
        uint stake_reward = swapped_full.mul(rate_pool_reward, DECIMAL);
        IERC20(platform_token).mint(staking_pool, stake_reward);

        // (5%) winner upline reward platform token
        uint referral_reward = swapped_full.mul(rate_upline_reward, DECIMAL);

        // (30%) non winner reward
        swapped_alt = swapped_alt.sub(stake_reward).sub(referral_reward);
        _updateAccTokenPerShare(swapped_alt, before_total_deposit);

        for (uint i = 0; i < winners.length; i++) {
            if (IReferral(referral).getUplineOf(winners[i]) == address(0)) {
                continue;
            }

            IERC20(platform_token).mint(
                IReferral(referral).getUplineOf(winners[i]),
                referral_reward.div(winners.length * 10**DECIMAL, DECIMAL)
            );
        }
    }

    function _getRewardAmount() internal view returns (uint) {
        if (total_deposit <= 0) {
            return (0);
        }

        uint user_staked = player[msg.sender].deposit;
        uint user_debt   = player[msg.sender].reward_debt;
        uint claimable   = acc_token_per_share.mul(user_staked, DECIMAL).sub(user_debt);

        return (claimable);
    }

    function _updateAccTokenPerShare(uint reward, uint _total_deposit) internal {
        uint result = 0;
        if (_total_deposit > 0) {
            result = reward.div(_total_deposit, DECIMAL);
        }
        acc_token_per_share = acc_token_per_share.add(result);
    }

    function _playerEntry(address _address, uint amount) internal {
        total_deposit                      = total_deposit.add(amount);
        player[_address].deposit           = player[_address].deposit.add(amount);
        player[_address].deposit_timestamp = block.timestamp;

        sortitionSumTrees.set(TREE_KEY, player[_address].deposit, bytes32(uint256(_address)));
        StandardToken._mintTo(_address, amount);
    }

    function _startPot() internal {
        require(session_minute > 0, "session duration cannot be zero");
        session_startTimestamp = block.timestamp;
        session_endTimestamp   = session_startTimestamp.add(session_minute * 60);
    }
}