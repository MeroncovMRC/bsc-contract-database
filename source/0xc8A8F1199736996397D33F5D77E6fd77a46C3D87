
// File: project:/contracts/Delegatable.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

abstract contract Delegatable {
    mapping (address => address) public delegations;
    address private senderOverride;
    //设置代理
    function setDelegate(address delegate) external {
        require(tx.origin == msg.sender, "NO_CONTRACT");

        delegations[msg.sender] = delegate;
    }

    function removeDelegate() external {
        delegations[msg.sender] = address(0);
    }
    //代理调用这个函数，msg.sender是代理，trader是真实用户   delegations[用户地址]=代理地址
    function delegatedAction(address trader, bytes calldata call_data) external returns (bytes memory) {
        require(delegations[trader] == msg.sender, "DELEGATE_NOT_APPROVED");

        senderOverride = trader;
        (bool success, bytes memory result) = address(this).delegatecall(call_data);
        if (!success) {
            // Next 5 lines from https://ethereum.stackexchange.com/a/83577 (return the original revert reason)
            if (result.length < 68) revert();
            assembly {
                result := add(result, 0x04)
            }
            revert(abi.decode(result, (string)));
        }

        senderOverride = address(0);

        return result;
    }

    //虽然调用是由代理发起的，但是这里需要的msg.sender是真实用户的地址
    function _msgSender() public view returns (address) {
        if (senderOverride == address(0)) {
            return msg.sender;
        } else {
            return senderOverride;
        }
    }
}

// File: project:/contracts/GNSTradingV6_2.sol
// SPDX-License-Identifier: MIT
import './interfaces/StorageInterfaceV5.sol';
import './interfaces/GNSPairInfosInterfaceV6.sol';
import './interfaces/GNSReferralsInterfaceV6_2.sol';
import './Delegatable.sol';

pragma solidity 0.8.17;

contract GNSTradingV6_2 is Delegatable {
	uint public aaa=0;
    // Contracts (constant)
    StorageInterfaceV5 public immutable storageT;
    NftRewardsInterfaceV6 public immutable nftRewards;
    GNSPairInfosInterfaceV6 public immutable pairInfos;
    GNSReferralsInterfaceV6_2 public immutable referrals;

    // Params (constant)
    uint constant PRECISION = 1e10;
    uint constant MAX_SL_P = 75;  // -75% PNL

    // Params (adjustable)
    uint public maxPosDai;            // 1e18 (eg. 75000 * 1e18)
    uint public limitOrdersTimelock;  // block (eg. 30)
    uint public marketOrdersTimeout;  // block (eg. 30)

    // State
    bool public isPaused;  // Prevent opening new trades
    bool public isDone;    // Prevent any interaction with the contract

    // Events
    event Done(bool done);
    event Paused(bool paused);

    event NumberUpdated(string name, uint value);

    event MarketOrderInitiated(
        uint indexed orderId,
        address indexed trader,
        uint indexed pairIndex,
        uint newPrice,
        uint newTp,
        uint newSl,
        uint positionSizeDai,
        uint leverage,
        bool buy,
        uint spreadReductionId,
        uint blocknumber,
        uint slippageP,
        bool open
    );

    event OpenLimitPlaced(
        address indexed trader,
        uint indexed pairIndex,
        uint index,
        uint newPrice,
        uint newTp,
        uint newSl,
        uint positionSizeDai,
        uint leverage,
        bool buy,
        uint spreadReductionId,
        uint blocknumber
    );
    event OpenLimitUpdated(
        address indexed trader,
        uint indexed pairIndex,
        uint index,
        uint newPrice,
        uint newTp,
        uint newSl
    );
    event OpenLimitCanceled(
        address indexed trader,
        uint indexed pairIndex,
        uint index
    );

    event TpUpdated(
        address indexed trader,
        uint indexed pairIndex,
        uint index,
        uint newTp
    );
    event SlUpdated(
        address indexed trader,
        uint indexed pairIndex,
        uint index,
        uint newSl
    );
    event SlUpdateInitiated(
        uint indexed orderId,
        address indexed trader,
        uint indexed pairIndex,
        uint index,
        uint newSl
    );

    event NftOrderInitiated(
        uint orderId,
        address indexed nftHolder,
        address indexed trader,
        uint indexed pairIndex
    );
    event NftOrderSameBlock(
        address indexed nftHolder,
        address indexed trader,
        uint indexed pairIndex
    );

    event ChainlinkCallbackTimeout(
        uint indexed orderId,
        StorageInterfaceV5.PendingMarketOrder order
    );
    event CouldNotCloseTrade(
        address indexed trader,
        uint indexed pairIndex,
        uint index
    );

    error openTrade_error(string e_errorinfo,address e_trader,uint e_pairIndex,uint e_positionSizeDai,uint e_openPrice,uint e_tp,uint e_sl,uint e_val1);

    constructor(
        StorageInterfaceV5 _storageT,
        NftRewardsInterfaceV6 _nftRewards,
        GNSPairInfosInterfaceV6 _pairInfos,
        GNSReferralsInterfaceV6_2 _referrals,
        uint _maxPosDai,
        uint _limitOrdersTimelock,
        uint _marketOrdersTimeout
    ) {
        require(address(_storageT) != address(0)
        && address(_nftRewards) != address(0)
        && address(_pairInfos) != address(0)
        && address(_referrals) != address(0)
        && _maxPosDai > 0
        && _limitOrdersTimelock > 0
            && _marketOrdersTimeout > 0, "WRONG_PARAMS");

        storageT = _storageT;
        nftRewards = _nftRewards;
        pairInfos = _pairInfos;
        referrals = _referrals;

        maxPosDai = _maxPosDai;
        limitOrdersTimelock = _limitOrdersTimelock;
        marketOrdersTimeout = _marketOrdersTimeout;
    }

    // Modifiers
    modifier onlyGov(){
        require(msg.sender == storageT.gov(), "GOV_ONLY");
        _;
    }
    modifier notContract(){
        require(tx.origin == msg.sender);
        _;
    }
    modifier notDone(){
        require(!isDone, "DONE");
        _;
    }

    // Manage params
    function setMaxPosDai(uint value) external onlyGov{
        require(value > 0, "VALUE_0");
        maxPosDai = value;

        emit NumberUpdated("maxPosDai", value);
    }
    function setLimitOrdersTimelock(uint value) external onlyGov{
        require(value > 0, "VALUE_0");
        limitOrdersTimelock = value;

        emit NumberUpdated("limitOrdersTimelock", value);
    }
    function setMarketOrdersTimeout(uint value) external onlyGov{
        require(value > 0, "VALUE_0");
        marketOrdersTimeout = value;

        emit NumberUpdated("marketOrdersTimeout", value);
    }

    // Manage state
    function pause() external onlyGov{
        isPaused = !isPaused;

        emit Paused(isPaused);
    }
    function done() external onlyGov{
        isDone = !isDone;

        emit Done(isDone);
    }
	
	/*function getStr(uint i) public returns (string memory c) {
        if (i == 0) return "0";
        uint j = i;
        uint length;
        while (j != 0){
            length++;
            j /= 10;
        }
        bytes memory bstr = new bytes(length);
        uint k = length - 1;
        while (i != 0){
            bstr[k--] = bytes1(uint8(48 + i % 10));
            i /= 10;
        }
        c = string(bstr);
    }

	function strConcat(string memory _a, string memory _b) public returns (string memory){
		bytes memory _ba = bytes(_a);
		bytes memory _bb = bytes(_b);
		string memory ret = new string(_ba.length + _bb.length);
		bytes memory bret = bytes(ret);
		uint k = 0;
		uint i = 0;
		for (i = 0; i < _ba.length; i++) bret[k++] = _ba[i];
		for (i = 0; i < _bb.length; i++) bret[k++] = _bb[i];
		return string(ret);
	}*/

    function checkParams(StorageInterfaceV5.Trade memory t,NftRewardsInterfaceV6.OpenLimitOrderType orderType,uint spreadReductionId,uint slippageP) public {
        AggregatorInterfaceV6_2 aggregator = storageT.priceAggregator();
        PairsStorageInterfaceV6 pairsStored = aggregator.pairsStorage();
        address sender = _msgSender(); //取真实用户的地址，有可能这个调用是由代理发起的

        uint _pairIndex=t.pairIndex*10000000+t.leverage*10000+(t.buy?1:0)*1000+uint(orderType)*100+slippageP/1e10; //格式： xxx 000 0 0 00
        //bool errflag=false;
        string memory errorinfo="";
        uint _val1=0;
        //uint totalOrdersCount=storageT.openTradesCount(sender,t.pairIndex)+storageT.pendingMarketOpenCount(sender,t.pairIndex)+storageT.openLimitOrdersCount(sender,t.pairIndex);

        //require(!isPaused, "PAUSED"); //是否已暂停下单
        if(isPaused)
        {
           //errflag=true;
           errorinfo="PAUSED";
        }
        //require(storageT.openTradesCount(sender, t.pairIndex) + storageT.pendingMarketOpenCount(sender, t.pairIndex) + storageT.openLimitOrdersCount(sender, t.pairIndex) < storageT.maxTradesPerPair(),"MAX_TRADES_PER_PAIR");//开仓仓位数+pending市价开仓单+限价单 < 3
        else if(storageT.openTradesCount(sender,t.pairIndex)+storageT.pendingMarketOpenCount(sender,t.pairIndex)+storageT.openLimitOrdersCount(sender,t.pairIndex) >= storageT.maxTradesPerPair())
        {
            //errflag=true;
            errorinfo="MAX_TRADES_PER_PAIR";
            _val1=storageT.openTradesCount(sender,t.pairIndex)+storageT.pendingMarketOpenCount(sender,t.pairIndex)+storageT.openLimitOrdersCount(sender,t.pairIndex);
        }
        //require(storageT.pendingOrderIdsCount(sender) < storageT.maxPendingMarketOrders(),"MAX_PENDING_ORDERS");//每个用户的pending市价单数量 < maxPendingMarketOrders = 5 市价单不是立即成交吗？为什么会有这个判断? 不一定是立即成交，回调有延时
        else if(storageT.pendingOrderIdsCount(sender) >= storageT.maxPendingMarketOrders())
        {
            //errflag=true;
            errorinfo="MAX_PENDING_ORDERS";
            _val1=storageT.pendingOrderIdsCount(sender);
        }
        //require(t.positionSizeDai <= maxPosDai, "ABOVE_MAX_POS");  //maxPosDai是可设置的
        else if(t.positionSizeDai > maxPosDai)
        {
            //errflag=true;
            errorinfo="ABOVE_MAX_POS";
            _val1=maxPosDai;
        }
        //require(t.positionSizeDai * t.leverage >= pairsStored.pairMinLevPosDai(t.pairIndex), "BELOW_MIN_POS");//交易对指向的Fee结构中的minLevPosDai字段
        else if(t.positionSizeDai * t.leverage < pairsStored.pairMinLevPosDai(t.pairIndex))
        {
            //errflag=true;
            errorinfo="BELOW_MIN_POS";
            _val1=pairsStored.pairMinLevPosDai(t.pairIndex);
        } 
        //require(t.leverage > 0 && t.leverage >= pairsStored.pairMinLeverage(t.pairIndex) && t.leverage <= pairsStored.pairMaxLeverage(t.pairIndex),"LEVERAGE_INCORRECT");//交易对指向的Group结构中的minLeverage字段和maxLeverage
        else if(!(t.leverage > 0 && t.leverage >= pairsStored.pairMinLeverage(t.pairIndex) && t.leverage <= pairsStored.pairMaxLeverage(t.pairIndex)))
        {
            //errflag=true;
            errorinfo="LEVERAGE_INCORRECT";
            _val1=pairsStored.pairMaxLeverage(t.pairIndex);
        }
        //require(spreadReductionId == 0 || storageT.nfts(spreadReductionId - 1).balanceOf(sender) > 0,"NO_CORRESPONDING_NFT_SPREAD_REDUCTION");//用户在NftInterfaceV5合约中的折扣余量
        else if(!(spreadReductionId == 0 || storageT.nfts(spreadReductionId - 1).balanceOf(sender) > 0))
        {
            //errflag=true;
            errorinfo="NO_CORRESPONDING_NFT_SPREAD_REDUCTION";
            _val1=storageT.nfts(spreadReductionId - 1).balanceOf(sender);
        }    
        //require(t.tp == 0 || (t.buy ? t.tp > t.openPrice : t.tp < t.openPrice), "WRONG_TP");//看多：止盈价 > 开仓价   看空：止盈价 < 开仓价
        else if(!(t.tp == 0 || (t.buy ? t.tp > t.openPrice : t.tp < t.openPrice)))
        {
            //errflag=true;
            errorinfo="WRONG_TP";
            _val1=t.openPrice;
        }
        //require(t.sl == 0 || (t.buy ? t.sl < t.openPrice : t.sl > t.openPrice), "WRONG_SL");//看多：止损价 < 开仓价   看空：止损价 > 开仓价
        else if(!(t.sl == 0 || (t.buy ? t.sl < t.openPrice : t.sl > t.openPrice)))
        {
            //errflag=true;
            errorinfo="WRONG_SL";
            _val1=t.openPrice;
        }
        if(bytes(errorinfo).length != 0)
        {
            revert openTrade_error({e_errorinfo:errorinfo,e_trader:t.trader,e_pairIndex:_pairIndex,e_positionSizeDai:t.positionSizeDai,e_openPrice:t.openPrice,e_tp:t.tp,e_sl:t.sl,e_val1:_val1});
        }
    }

    function emit_OpenLimitPlaced(address sender,StorageInterfaceV5.Trade memory t,uint index,uint spreadReductionId) public {
        emit OpenLimitPlaced(
                sender,
                t.pairIndex,
                index,
                t.openPrice,
                t.tp,
                t.sl,
                t.positionSizeDai,
                t.leverage,
                t.buy,
                spreadReductionId,
                block.number
            );
    }

    function emit_MarketOrderInitiated(uint orderId,address sender,StorageInterfaceV5.Trade memory t,uint spreadReductionId,uint slippageP) public {
        emit MarketOrderInitiated(
                orderId,
                sender,
                t.pairIndex,
                t.openPrice,
                t.tp,
                t.sl,
                t.positionSizeDai,
                t.leverage,
                t.buy,
                spreadReductionId,
                block.number,
                slippageP,
                true
            );
    }

    // Open new trade (MARKET/LIMIT)
    function openTrade(
        StorageInterfaceV5.Trade memory t,
        NftRewardsInterfaceV6.OpenLimitOrderType orderType, // LEGACY => market
        uint spreadReductionId, //持有NFT可以折扣
        uint slippageP, // for market orders only,滑点
        address referrer //邀请人，如果填写地址0，表示没有邀请人
    ) external notContract notDone {  
        AggregatorInterfaceV6_2 aggregator = storageT.priceAggregator();
        PairsStorageInterfaceV6 pairsStored = aggregator.pairsStorage();
        address sender = _msgSender(); //取真实用户的地址，有可能这个调用是由代理发起的
        
        checkParams(t,orderType, spreadReductionId, slippageP);
        
        //priceImpactP = (storageT.openInterestDai(pairIndex, long ? 0 : 1) + t.positionSizeDai * t.leverage / 2) * PRECISION / 1e18 / onePercentDepth;
        //uint priceImpact = priceImpactP * openPrice / PRECISION / 100;
        (uint priceImpactP,) = pairInfos.getTradePriceImpact(
            0,
            t.pairIndex,
            t.buy,
            t.positionSizeDai * t.leverage
        );

        //require(priceImpactP * t.leverage <= pairInfos.maxNegativePnlOnOpenP(), "PRICE_IMPACT_TOO_HIGH");//priceImpactP是PriceImpact影响百分比，maxNegativePnlOnOpenP可设置
        if(priceImpactP * t.leverage > pairInfos.maxNegativePnlOnOpenP())
        {
            uint _pairIndex=t.pairIndex*10000000+t.leverage*10000+(t.buy?1:0)*1000+uint(orderType)*100+slippageP/1e10; //格式： xxx 000 0 0 00
            revert openTrade_error({e_errorinfo:"PRICE_IMPACT_TOO_HIGH",e_trader:t.trader,e_pairIndex:_pairIndex,e_positionSizeDai:t.positionSizeDai,e_openPrice:t.openPrice,e_tp:t.tp,e_sl:t.sl,e_val1:priceImpactP * t.leverage});
        }

        storageT.transferDai(sender, address(storageT), t.positionSizeDai);//将用户的下单DAI转到GNSTradingStorageV5合约地址

        if (orderType != NftRewardsInterfaceV6.OpenLimitOrderType.LEGACY) { //限价单
            uint index = storageT.firstEmptyOpenLimitIndex(sender, t.pairIndex);//找到openLimitOrderIds[_o.trader][_o.pairIndex][0~2]中的空位

            storageT.storeOpenLimitOrder(
                StorageInterfaceV5.OpenLimitOrder(
                    sender,
                    t.pairIndex, //交易对id
                    index,       //用户限价单id  0~2
                    t.positionSizeDai,    //下单DAI
                    spreadReductionId > 0 ? storageT.spreadReductionsP(spreadReductionId - 1) : 0,//持有NFT的折扣[15, 20, 25, 30, 35]，spreadReductionId表示NFT的id
                    t.buy,              //看多，看空
                    t.leverage,         //杠杆
                    t.tp,               //止盈
                    t.sl,               //止损
                    t.openPrice,        //开仓价  minPrice
                    t.openPrice,        //开仓价  maxPrice
                    block.number,       //区块号
                    0                   //tokenId
                )
            );

            nftRewards.setOpenLimitOrderType(sender, t.pairIndex, index, orderType);//在GNSNftRewardsV6合约中记录订单的类型

            /*emit OpenLimitPlaced(
                sender,
                t.pairIndex,
                index,
                t.openPrice,
                t.tp,
                t.sl,
                t.positionSizeDai,
                t.leverage,
                t.buy,
                spreadReductionId,
                block.number
            );*/
            emit_OpenLimitPlaced(sender,t,index,spreadReductionId);

        }else{ //市价单
            uint orderId = aggregator.getPrice(
                t.pairIndex,  //交易对id
                AggregatorInterfaceV6_2.OrderType.MARKET_OPEN, //市价单开仓
                t.positionSizeDai * t.leverage
            );

            storageT.storePendingMarketOrder(
                StorageInterfaceV5.PendingMarketOrder(
                    StorageInterfaceV5.Trade(
                        sender,
                        t.pairIndex, //交易对id
                        0,           //index，在registerTrade函数里设置trade.index = storageT.firstEmptyTradeIndex(trade.trader, trade.pairIndex);
                        0,           //initialPosToken，在registerTrade函数里设置trade.initialPosToken = trade.positionSizeDai * PRECISION / v.tokenPriceDai;
                        t.positionSizeDai, //下单DAI
                        0,                 //开仓价
                        t.buy,             //看多，看空
                        t.leverage,        //杠杆
                        t.tp,              //止盈
                        t.sl               //止损
                    ),
                    0,      //区块号，限价单是block.number，这里是0，在storePendingMarketOrder函数中会置为block.number
                    t.openPrice, //开仓价  wantedPrice
                    slippageP,   //滑点
                    spreadReductionId > 0 ? storageT.spreadReductionsP(spreadReductionId - 1) : 0,//持有NFT的折扣[15, 20, 25, 30, 35]，spreadReductionId表示NFT的id
                    0            //tokenId
                ), orderId, true //true表示开仓，false为平仓
            );

            /*emit MarketOrderInitiated(
                orderId,
                sender,
                t.pairIndex,
                t.openPrice,
                t.tp,
                t.sl,
                t.positionSizeDai,
                t.leverage,
                t.buy,
                spreadReductionId,
                block.number,
                slippageP,
                true
            );*/
            emit_MarketOrderInitiated(orderId,sender,t,spreadReductionId,slippageP);
        }

        referrals.registerPotentialReferrer(sender, referrer); //邀请人统计。  referrer邀请了sender
    }

    // Close trade (MARKET)
    function closeTradeMarket(
        uint pairIndex,
        uint index
    ) external notContract notDone {
        aaa=1;
		address sender = _msgSender();

        StorageInterfaceV5.Trade memory t = storageT.openTrades( //找到Trade对象
            sender, pairIndex, index
        );

        StorageInterfaceV5.TradeInfo memory i = storageT.openTradesInfo( //找到TradeInfo对象
            sender, pairIndex, index 
        );
		
		//getStr(aaa);


        require(storageT.pendingOrderIdsCount(sender)
            < storageT.maxPendingMarketOrders(), "MAX_PENDING_ORDERS"); //pending市价单数量 < 5

        require(!i.beingMarketClosed, "ALREADY_BEING_CLOSED");//这个单尚未平仓
        require(t.leverage > 0, "NO_TRADE"); //有杠杆

        uint orderId = storageT.priceAggregator().getPrice(
            pairIndex, //交易对
            AggregatorInterfaceV6_2.OrderType.MARKET_CLOSE, //平仓单
            t.initialPosToken * i.tokenPriceDai * t.leverage / PRECISION  //平仓时：数量*价格*杠杆
        );

        storageT.storePendingMarketOrder(
            StorageInterfaceV5.PendingMarketOrder( //市价单平仓时，也会先生成一个pendingMarketOrder订单
                StorageInterfaceV5.Trade(
                    sender, 
                    pairIndex, //交易对
                    index,     //空闲位置
                    0,         //initialPosToken
                    0,         //positionSizeDai
                    0,         //openPrice
                    false,     //buy，对于平仓单无意义
                    0,         //leverage
                    0,         //tp
                    0          //sl
                ),
                0,             //block
                0,             //wantedPrice
                0,             //slippageP
                0,             //spreadReductionP
                0              //tokenId
            ), orderId, false  //false表示平仓
        );

        emit MarketOrderInitiated(
            orderId,
            sender,
            pairIndex,
            t.openPrice,
            t.tp,
            t.sl,
            t.positionSizeDai,
            t.leverage,
            t.buy,
            i.tokenPriceDai,
            block.number,
            t.initialPosToken,
            false
        );
    }

    // Manage limit order (OPEN)
    function updateOpenLimitOrder(
        uint pairIndex,
        uint index,
        uint price,  // PRECISION
        uint tp,
        uint sl
    ) external notContract notDone {

        address sender = _msgSender();

        require(storageT.hasOpenLimitOrder(sender, pairIndex, index), //限价单存在
            "NO_LIMIT");

        StorageInterfaceV5.OpenLimitOrder memory o = storageT.getOpenLimitOrder( //取到OpenLimitOrder
            sender, pairIndex, index
        );

        require(block.number - o.block >= limitOrdersTimelock, "LIMIT_TIMELOCK"); //锁定一段时间才能更新，limitOrdersTimelock可设置
        //看多：tp > price   看空：tp < price
        require(tp == 0 || (o.buy ?       
        tp > price :
        tp < price), "WRONG_TP");
        //看多：sl < price   看空：sl > price
        require(sl == 0 || (o.buy ?       
        sl < price :
        sl > price), "WRONG_SL");

        o.minPrice = price; //更新价格
        o.maxPrice = price;

        o.tp = tp;  //更新止赢
        o.sl = sl;  //更新止损

        storageT.updateOpenLimitOrder(o); //更新限价单

        emit OpenLimitUpdated(
            sender,
            pairIndex,
            index,
            price,
            tp,
            sl
        );
    }

    function cancelOpenLimitOrder(
        uint pairIndex,
        uint index
    ) external notContract notDone {

        address sender = _msgSender();

        require(storageT.hasOpenLimitOrder(sender, pairIndex, index), //限价单存在
            "NO_LIMIT");

        StorageInterfaceV5.OpenLimitOrder memory o = storageT.getOpenLimitOrder( //取到OpenLimitOrder
            sender, pairIndex, index
        );

        require(block.number - o.block >= limitOrdersTimelock, "LIMIT_TIMELOCK"); //锁定一段时间才能撤单，limitOrdersTimelock可设置

        storageT.unregisterOpenLimitOrder(sender, pairIndex, index); //删除OpenLimitOrder
        storageT.transferDai(address(storageT), sender, o.positionSize); //退回DAI给用户

        emit OpenLimitCanceled(
            sender,
            pairIndex,
            index
        );
    }

    // Manage limit order (TP/SL)
    function updateTp(
        uint pairIndex,
        uint index,
        uint newTp
    ) external notContract notDone {

        address sender = _msgSender();

        StorageInterfaceV5.Trade memory t = storageT.openTrades(
            sender, pairIndex, index
        );

        StorageInterfaceV5.TradeInfo memory i = storageT.openTradesInfo(
            sender, pairIndex, index
        );

        require(t.leverage > 0, "NO_TRADE");
        require(block.number - i.tpLastUpdated >= limitOrdersTimelock, //锁定一段时间才能更新tp，limitOrdersTimelock可设置
            "LIMIT_TIMELOCK");

        storageT.updateTp(sender, pairIndex, index, newTp);//更新：Trade的tp=newTp，TradeInfo的tpLastUpdated=block.number

        emit TpUpdated(
            sender,
            pairIndex,
            index,
            newTp
        );
    }

    function updateSl(
        uint pairIndex,
        uint index,
        uint newSl
    ) external notContract notDone {

        address sender = _msgSender();

        StorageInterfaceV5.Trade memory t = storageT.openTrades(
            sender, pairIndex, index
        );

        StorageInterfaceV5.TradeInfo memory i = storageT.openTradesInfo(
            sender, pairIndex, index
        );

        require(t.leverage > 0, "NO_TRADE");

        uint maxSlDist = t.openPrice * MAX_SL_P / 100 / t.leverage;//最大止损允许的偏差

        require(newSl == 0 || (t.buy ?      //看多：newSl >= t.openPrice - maxSlDist  看空：newSl <= t.openPrice + maxSlDist
        newSl >= t.openPrice - maxSlDist :
        newSl <= t.openPrice + maxSlDist), "SL_TOO_BIG");

        require(block.number - i.slLastUpdated >= limitOrdersTimelock, //锁定一段时间才能更新sl，limitOrdersTimelock可设置
            "LIMIT_TIMELOCK");

        AggregatorInterfaceV6_2 aggregator = storageT.priceAggregator();

        if (newSl == 0
            || !aggregator.pairsStorage().guaranteedSlEnabled(pairIndex)) { //group==0表示加密货币

            storageT.updateSl(sender, pairIndex, index, newSl);//更新：Trade的sl=newSl，TradeInfo的slLastUpdated=block.number

            emit SlUpdated(
                sender,
                pairIndex,
                index,
                newSl
            );

        } else { //非加密货币
            uint orderId = aggregator.getPrice(  //预言机获取当前价格，sl必须<=当前价格
                pairIndex,
                AggregatorInterfaceV6_2.OrderType.UPDATE_SL,
                t.initialPosToken * i.tokenPriceDai * t.leverage / PRECISION
            );

            aggregator.storePendingSlOrder( //保存为sl单
                orderId,
                AggregatorInterfaceV6_2.PendingSl(
                    sender, pairIndex, index, t.openPrice, t.buy, newSl
                )
            );

            emit SlUpdateInitiated(
                orderId,
                sender,
                pairIndex,
                index,
                newSl
            );
        }
    }

    // Execute limit order
    function executeNftOrder(
        //OPEN表示：限价单：价格有交叉(下单价>=当前价)时将限价单变为成交
        //LIQ表示：(看多)当前价格<=清算价格时平仓
        //TP表示： (看多)当前价格>=TP时平仓
        //SL表示： (看多)当前价格<=SL时平仓
        StorageInterfaceV5.LimitOrder orderType, //TP, SL, LIQ(后三种都是限价单的平仓单), OPEN(将限价单改为成交)
        address trader,
        uint pairIndex,
        uint index,
        uint nftId,
        uint nftType
    ) external notContract notDone {

        address sender = _msgSender();

        //require(nftType >= 1 && nftType <= 5, "WRONG_NFT_TYPE");//5种nft类型
        //require(storageT.nfts(nftType - 1).ownerOf(nftId) == sender, "NO_NFT");//当前用户是nftId的拥有者
        
		//require(0x0 == sender, "NO_NFT"); todo
        require(block.number >=
            storageT.nftLastSuccess(nftId) + storageT.nftSuccessTimelock(), //nft奖励后要锁定nftSuccessTimelock = 30个块
            "SUCCESS_TIMELOCK");

        StorageInterfaceV5.Trade memory t;

        if (orderType == StorageInterfaceV5.LimitOrder.OPEN) {
            require(storageT.hasOpenLimitOrder(trader, pairIndex, index), //限价单存在
                "NO_LIMIT");

        } else {
            t = storageT.openTrades(trader, pairIndex, index); //取到Trade对象

            require(t.leverage > 0, "NO_TRADE"); //必须有杠杆

            if (orderType == StorageInterfaceV5.LimitOrder.LIQ) {
                //看多：清算价=openPrice-openPrice*(collateral*LIQ_THRESHOLD_P/100-rolloverFee-fundingFee)/collateral/leverage
                //看空：清算价=openPrice+openPrice*(collateral*LIQ_THRESHOLD_P/100-rolloverFee-fundingFee)/collateral/leverage
                uint liqPrice = getTradeLiquidationPrice(t);//根据开仓价得到清算价，限价单的开仓价就是用户指定的价格，下单时还不存在各种费用的影响

                require(t.sl == 0 || (t.buy ? //看多：liqPrice清算价 > 止损   看空：liqPrice清算价 < 止损 ？？？
                liqPrice > t.sl :
                liqPrice < t.sl), "HAS_SL");

            } else {
                require(orderType != StorageInterfaceV5.LimitOrder.SL || t.sl > 0, //如果是sl单，必须sl > 0
                    "NO_SL");
                require(orderType != StorageInterfaceV5.LimitOrder.TP || t.tp > 0, //如果是tp单，必须tp > 0
                    "NO_TP");
            }
        }

        NftRewardsInterfaceV6.TriggeredLimitId memory triggeredLimitId =
        NftRewardsInterfaceV6.TriggeredLimitId(
            trader, pairIndex, index, orderType
        );

        if(!nftRewards.triggered(triggeredLimitId)
        || nftRewards.timedOut(triggeredLimitId)){ //？？？

            uint leveragedPosDai;

            if(orderType == StorageInterfaceV5.LimitOrder.OPEN){ //限价单转成交

                StorageInterfaceV5.OpenLimitOrder memory l = storageT.getOpenLimitOrder( //取到限价单
                    trader, pairIndex, index
                );

                leveragedPosDai = l.positionSize * l.leverage; //用户下单DAI*杠杆

                (uint priceImpactP, ) = pairInfos.getTradePriceImpact( //PriceImpact对价格的影响百分比
                    0,
                    l.pairIndex,
                    l.buy,
                    leveragedPosDai
                );
 
            require(priceImpactP * l.leverage <= pairInfos.maxNegativePnlOnOpenP(), //PriceImpact对价格的影响不能太大
                "PRICE_IMPACT_TOO_HIGH");

            }else{
                leveragedPosDai = t.initialPosToken * storageT.openTradesInfo( //计算成交后的用户开仓当前投资，要用initialPosToken*GNS价格
                    trader, pairIndex, index
                ).tokenPriceDai * t.leverage / PRECISION;
            }

            storageT.transferLinkToAggregator(sender, pairIndex, leveragedPosDai);//使用预言机需要付费linkFee(_pairIndex, _leveragedPosDai)

            uint orderId = storageT.priceAggregator().getPrice(
                pairIndex,
                orderType == StorageInterfaceV5.LimitOrder.OPEN ?
                AggregatorInterfaceV6_2.OrderType.LIMIT_OPEN :
                AggregatorInterfaceV6_2.OrderType.LIMIT_CLOSE, //TP, SL, LIQ
                leveragedPosDai
            );

            storageT.storePendingNftOrder(
                StorageInterfaceV5.PendingNftOrder( //限价单的执行OPEN, TP, SL, LIQ要先生成pendingNftOrder，保存到reqID_pendingNftOrder[orderId]
                    sender,
                    nftId,
                    trader,
                    pairIndex,
                    index,
                    orderType
                ), orderId
            );

            nftRewards.storeFirstToTrigger(triggeredLimitId, sender);//t.first = _bot; t.block = block.number; 记录第一个执行者

            emit NftOrderInitiated(
                orderId,
                sender,
                trader,
                pairIndex
            );

        }else{
            nftRewards.storeTriggerSameBlock(triggeredLimitId, sender);//t.sameBlock.push(_bot); 记录后面的其它执行者

            emit NftOrderSameBlock(
                sender,
                trader,
                pairIndex
            );
        }
    }
    // Avoid stack too deep error in executeNftOrder
    function getTradeLiquidationPrice(
        StorageInterfaceV5.Trade memory t
    ) private view returns(uint){
        return pairInfos.getTradeLiquidationPrice(
            t.trader,
            t.pairIndex,
            t.index,
            t.openPrice,
            t.buy,
            t.initialPosToken * storageT.openTradesInfo(
                t.trader, t.pairIndex, t.index
            ).tokenPriceDai / PRECISION,
            t.leverage
        );
    }

    // Market timeout
    function openTradeMarketTimeout(uint _order) external notContract notDone {
        address sender = _msgSender();

        StorageInterfaceV5.PendingMarketOrder memory o =
        storageT.reqID_pendingMarketOrder(_order);

        StorageInterfaceV5.Trade memory t = o.trade;

        require(o.block > 0
            && block.number >= o.block + marketOrdersTimeout, "WAIT_TIMEOUT");

        require(t.trader == sender, "NOT_YOUR_ORDER");
        require(t.leverage > 0, "WRONG_MARKET_ORDER_TYPE");

        storageT.unregisterPendingMarketOrder(_order, true);
        storageT.transferDai(address(storageT), sender, t.positionSizeDai);

        emit ChainlinkCallbackTimeout(
            _order,
            o
        );
    }

    function closeTradeMarketTimeout(uint _order) external notContract notDone {
        address sender = _msgSender();

        StorageInterfaceV5.PendingMarketOrder memory o =
        storageT.reqID_pendingMarketOrder(_order);

        StorageInterfaceV5.Trade memory t = o.trade;

        require(o.block > 0
            && block.number >= o.block + marketOrdersTimeout, "WAIT_TIMEOUT");

        require(t.trader == sender, "NOT_YOUR_ORDER");
        require(t.leverage == 0, "WRONG_MARKET_ORDER_TYPE");

        storageT.unregisterPendingMarketOrder(_order, false);

        (bool success, ) = address(this).delegatecall(
            abi.encodeWithSignature(
                "closeTradeMarket(uint256,uint256)",
                t.pairIndex,
                t.index
            )
        );

        if(!success){
            emit CouldNotCloseTrade(
                sender,
                t.pairIndex,
                t.index
            );
        }

        emit ChainlinkCallbackTimeout(
            _order,
            o
        );
    }
}

// File: project:/contracts/interfaces/GNSPairInfosInterfaceV6.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

interface GNSPairInfosInterfaceV6{
    function maxNegativePnlOnOpenP() external view returns(uint); // PRECISION (%)

    function storeTradeInitialAccFees(
        address trader,
        uint pairIndex,
        uint index,
        bool long
    ) external;

    function getTradePriceImpact(
        uint openPrice,   // PRECISION
        uint pairIndex,
        bool long,
        uint openInterest // 1e18 (DAI)
    ) external view returns(
        uint priceImpactP,      // PRECISION (%)
        uint priceAfterImpact   // PRECISION
    );

    function getTradeLiquidationPrice(
        address trader,
        uint pairIndex,
        uint index,
        uint openPrice,  // PRECISION
        bool long,
        uint collateral, // 1e18 (DAI)
        uint leverage
    ) external view returns(uint); // PRECISION

    function getTradeValue(
        address trader,
        uint pairIndex,
        uint index,
        bool long,
        uint collateral,   // 1e18 (DAI)
        uint leverage,
        int percentProfit, // PRECISION (%)
        uint closingFee    // 1e18 (DAI)
    ) external returns(uint); // 1e18 (DAI)
}

// File: project:/contracts/interfaces/GNSReferralsInterfaceV6_2.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

interface GNSReferralsInterfaceV6_2{
    function registerPotentialReferrer(address trader, address referral) external;
    function distributePotentialReward(
        address trader,
        uint volumeDai,
        uint pairOpenFeeP,
        uint tokenPriceDai
    ) external returns(uint);
    function getPercentOfOpenFeeP(address trader) external view returns(uint);
    function getTraderReferrer(address trader) external view returns(address referrer);
}

// File: project:/contracts/interfaces/IGToken.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

interface IGToken{
    function manager() external view returns(address);
    function admin() external view returns(address);
    function currentEpoch() external view returns(uint);
    function currentEpochStart() external view returns(uint);
    function currentEpochPositiveOpenPnl() external view returns(uint);
    function updateAccPnlPerTokenUsed(uint prevPositiveOpenPnl, uint newPositiveOpenPnl) external returns(uint);

    struct LockedDeposit {
        address owner;
        uint shares;          // 1e18
        uint assetsDeposited; // 1e18
        uint assetsDiscount;  // 1e18
        uint atTimestamp;     // timestamp
        uint lockDuration;    // timestamp
    }
    function getLockedDeposit(uint depositId) external view returns(LockedDeposit memory);

    function sendAssets(uint assets, address receiver) external;
    function receiveAssets(uint assets, address user) external;
    function distributeReward(uint assets) external;

    function currentBalanceDai() external view returns(uint);
}

// File: project:/contracts/interfaces/NftInterfaceV5.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

interface NftInterfaceV5{
    function balanceOf(address) external view returns (uint);
    function ownerOf(uint) external view returns (address);
    function transferFrom(address, address, uint) external;
    function tokenOfOwnerByIndex(address, uint) external view returns(uint);
}

// File: project:/contracts/interfaces/PairsStorageInterfaceV6.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

interface PairsStorageInterfaceV6{
    enum FeedCalculation { DEFAULT, INVERT, COMBINE }    // FEED 1, 1 / (FEED 1), (FEED 1)/(FEED 2)
    struct Feed{ address feed1; address feed2; FeedCalculation feedCalculation; uint maxDeviationP; } // PRECISION (%)
    function incrementCurrentOrderId() external returns(uint);
    function updateGroupCollateral(uint, uint, bool, bool) external;
    function pairJob(uint) external returns(string memory, string memory, bytes32, uint);
    function pairFeed(uint) external view returns(Feed memory);
    function pairSpreadP(uint) external view returns(uint);
    function pairMinLeverage(uint) external view returns(uint);
    function pairMaxLeverage(uint) external view returns(uint);
    function groupMaxCollateral(uint) external view returns(uint);
    function groupCollateral(uint, bool) external view returns(uint);
    function guaranteedSlEnabled(uint) external view returns(bool);
    function pairOpenFeeP(uint) external view returns(uint);
    function pairCloseFeeP(uint) external view returns(uint);
    function pairOracleFeeP(uint) external view returns(uint);
    function pairNftLimitOrderFeeP(uint) external view returns(uint);
    function pairReferralFeeP(uint) external view returns(uint);
    function pairMinLevPosDai(uint) external view returns(uint);
}

// File: project:/contracts/interfaces/StorageInterfaceV5.sol
// SPDX-License-Identifier: MIT
import './TokenInterfaceV5.sol';
import './NftInterfaceV5.sol';
import './IGToken.sol';
import './PairsStorageInterfaceV6.sol';

pragma solidity 0.8.17;

interface PoolInterfaceV5{
    function increaseAccTokensPerLp(uint) external;
}

interface PausableInterfaceV5{
    function isPaused() external view returns (bool);
}

interface StorageInterfaceV5{
    enum LimitOrder { TP, SL, LIQ, OPEN }
    struct Trade{
        address trader;
        uint pairIndex;
        uint index;
        uint initialPosToken;       // 1e18
        uint positionSizeDai;       // 1e18
        uint openPrice;             // PRECISION
        bool buy;
        uint leverage; // 10
        uint tp;                    // PRECISION
        uint sl;                    // PRECISION
    }
    struct TradeInfo{
        uint tokenId;
        uint tokenPriceDai;         // PRECISION
        uint openInterestDai;       // 1e18
        uint tpLastUpdated;
        uint slLastUpdated;
        bool beingMarketClosed;
    }
    struct OpenLimitOrder{
        address trader;
        uint pairIndex;
        uint index;
        uint positionSize;          // 1e18 (DAI or GFARM2)
        uint spreadReductionP;
        bool buy;
        uint leverage;
        uint tp;                    // PRECISION (%)
        uint sl;                    // PRECISION (%)
        uint minPrice;              // PRECISION
        uint maxPrice;              // PRECISION
        uint block;
        uint tokenId;               // index in supportedTokens
    }
    struct PendingMarketOrder{
        Trade trade;
        uint block;
        uint wantedPrice;           // PRECISION
        uint slippageP;             // PRECISION (%)
        uint spreadReductionP;
        uint tokenId;               // index in supportedTokens
    }
    struct PendingNftOrder{
        address nftHolder;
        uint nftId;
        address trader;
        uint pairIndex;
        uint index;
        LimitOrder orderType;
    }
    function PRECISION() external pure returns(uint);
    function gov() external view returns(address);
    function dev() external view returns(address);
    function dai() external view returns(TokenInterfaceV5);
    function token() external view returns(TokenInterfaceV5);
    function linkErc677() external view returns(TokenInterfaceV5);
    function priceAggregator() external view returns(AggregatorInterfaceV6_2);
    function vault() external view returns(IGToken);
    function trading() external view returns(address);
    function callbacks() external view returns(address);
    function handleTokens(address,uint,bool) external;
    function transferDai(address, address, uint) external;
    function transferLinkToAggregator(address, uint, uint) external;
    function unregisterTrade(address, uint, uint) external;
    function unregisterPendingMarketOrder(uint, bool) external;
    function unregisterOpenLimitOrder(address, uint, uint) external;
    function hasOpenLimitOrder(address, uint, uint) external view returns(bool);
    function storePendingMarketOrder(PendingMarketOrder memory, uint, bool) external;
    function openTrades(address, uint, uint) external view returns(Trade memory);
    function openTradesInfo(address, uint, uint) external view returns(TradeInfo memory);
    function updateSl(address, uint, uint, uint) external;
    function updateTp(address, uint, uint, uint) external;
    function getOpenLimitOrder(address, uint, uint) external view returns(OpenLimitOrder memory);
    function spreadReductionsP(uint) external view returns(uint);
    function storeOpenLimitOrder(OpenLimitOrder memory) external;
    function reqID_pendingMarketOrder(uint) external view returns(PendingMarketOrder memory);
    function storePendingNftOrder(PendingNftOrder memory, uint) external;
    function updateOpenLimitOrder(OpenLimitOrder calldata) external;
    function firstEmptyTradeIndex(address, uint) external view returns(uint);
    function firstEmptyOpenLimitIndex(address, uint) external view returns(uint);
    function increaseNftRewards(uint, uint) external;
    function nftSuccessTimelock() external view returns(uint);
    function reqID_pendingNftOrder(uint) external view returns(PendingNftOrder memory);
    function updateTrade(Trade memory) external;
    function nftLastSuccess(uint) external view returns(uint);
    function unregisterPendingNftOrder(uint) external;
    function handleDevGovFees(uint, uint, bool, bool) external returns(uint);
    function distributeLpRewards(uint) external;
    function storeTrade(Trade memory, TradeInfo memory) external;
    function openLimitOrdersCount(address, uint) external view returns(uint);
    function openTradesCount(address, uint) external view returns(uint);
    function pendingMarketOpenCount(address, uint) external view returns(uint);
    function pendingMarketCloseCount(address, uint) external view returns(uint);
    function maxTradesPerPair() external view returns(uint);
    function pendingOrderIdsCount(address) external view returns(uint);
    function maxPendingMarketOrders() external view returns(uint);
    function openInterestDai(uint, uint) external view returns(uint);
    function getPendingOrderIds(address) external view returns(uint[] memory);
    function nfts(uint) external view returns(NftInterfaceV5);
    function fakeBlockNumber() external view returns(uint); // Testing
}

interface AggregatorInterfaceV6_2{
    enum OrderType { MARKET_OPEN, MARKET_CLOSE, LIMIT_OPEN, LIMIT_CLOSE, UPDATE_SL }
    function pairsStorage() external view returns(PairsStorageInterfaceV6);
    function getPrice(uint,OrderType,uint) external returns(uint);
    function tokenPriceDai() external returns(uint);
    function linkFee(uint,uint) external view returns(uint);
    function openFeeP(uint) external view returns(uint);
    function pendingSlOrders(uint) external view returns(PendingSl memory);
    function storePendingSlOrder(uint orderId, PendingSl calldata p) external;
    function unregisterPendingSlOrder(uint orderId) external;
    struct PendingSl{address trader; uint pairIndex; uint index; uint openPrice; bool buy; uint newSl; }
}

interface NftRewardsInterfaceV6{
    struct TriggeredLimitId{ address trader; uint pairIndex; uint index; StorageInterfaceV5.LimitOrder order; }
    enum OpenLimitOrderType{ LEGACY, REVERSAL, MOMENTUM }
    function storeFirstToTrigger(TriggeredLimitId calldata, address) external;
    function storeTriggerSameBlock(TriggeredLimitId calldata, address) external;
    function unregisterTrigger(TriggeredLimitId calldata) external;
    function distributeNftReward(TriggeredLimitId calldata, uint) external;
    function openLimitOrderTypes(address, uint, uint) external view returns(OpenLimitOrderType);
    function setOpenLimitOrderType(address, uint, uint, OpenLimitOrderType) external;
    function triggered(TriggeredLimitId calldata) external view returns(bool);
    function timedOut(TriggeredLimitId calldata) external view returns(bool);
}

// File: project:/contracts/interfaces/TokenInterfaceV5.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

interface TokenInterfaceV5{
    function burn(address, uint256) external;
    function mint(address, uint256) external;
    function transfer(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns(bool);
    function balanceOf(address) external view returns(uint256);
    function hasRole(bytes32, address) external view returns (bool);
    function approve(address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
}
