{"Address.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\u0027s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"},"FundService.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./SafeERC20.sol\";\n\n/**\n * @dev Implementation of the Xend Effect FundService Manager (What does the contract do)\n *\n * 1. Receive any ERC20 token\n * 2. Receive ETH\n * 3. Send Out any ERC20 token\n * 4. Send out ETH\n * 5. Create Contract adminsser\n * 6. Change Contract admin status (revoke \u0026 enable)\n * 7. Change Contract Ownership, accept contract Ownership\n * 8. Let Admin Distribute Any Token to Multiple Addresses\n * 9. Let members Deposit with the stable currency after approving the contract to spend token (eg BUSD only)\n * 10. Let Members Withdraw the Stable Currency from their own deposit\n * 11. Let Owner Disable/Enable Withdrawal\n * 12. Let admin remove/update locked user funds in batches\n */\n\n/**\n * @title FundService\n * @dev   Receive funds, manage and distribute tokens to winners.\n */\ncontract FundService is ReentrancyGuard {\n    using SafeMath for uint256;\n    // using Address for address;\n    using SafeERC20 for IERC20;\n\n    string public name; //=\u003e do not add payable here, we are in 0.8.0: the contract creator is stored here \u003c==\n    address public owner; // the contract name, eg XendEffectBSC to identify the contract on admin dashboard    /\n    uint256 public adminCount = 0; // Admin struct is used to store array of public address of                           /\n    bool public allowWithdrawal = true; // other admins such that they can perform some actions like approve withdrawal       /\n    address public newOwner; // When contract creator wish to make another address the creator(handover)           /\n    //=\u003e its stored here for the new guy to accept to become creator                   \u003c==\n    address stableCurrencyContract = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56; // BUSD\n    uint256 maxLoopTimes = 500; // every loop operation should not be unlimited loop\n\n    mapping(address =\u003e memberBalanceAddressMapping) public memberBalances;\n\n    mapping(uint256 =\u003e Admin) public admins;\n\n    struct Admin {\n        // to store admins details\n        uint256 id; // created id on blockchain\n        string _id; // local admin id, mongodb\n        string name;\n        address admin;\n        address father;\n        bool isActive;\n    }\n\n    struct memberBalanceAddressMapping {\n        address _address;\n        uint256 balance;\n    }\n\n    event Received(address, uint256);\n\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\n\n    event AdminAdded(\n        uint256 id,\n        string _id,\n        string name,\n        address admin,\n        address father,\n        bool isActive\n    );\n\n    event AdminRevoked(\n        uint256 id,\n        string _id,\n        string name,\n        address admin,\n        address father,\n        bool isActive\n    );\n\n    event TokenDistributted(\n        address contract_address,\n        address[] recipients,\n        uint256[] amounts,\n        uint256 admin,\n        string indexed batchID\n    );\n\n    event NativeTokenDistributted(\n        address[] recipients,\n        uint256[] amounts,\n        uint256 admin,\n        string indexed launchpadSaleId,\n        string batchID\n    );\n\n    event FundExtracted(\n        address[] winners,\n        uint256[] amounts,\n        string indexed launchpadSaleId,\n        string indexed batchID\n    );\n\n    event FundInjected(\n        address[] winners,\n        uint256[] amounts,\n        string indexed launchpadSaleId,\n        string indexed batchID\n    );\n\n    event StableCurrencyDeposited(\n        uint256 amount,\n        uint256 balance,\n        address indexed memberAddress\n    );\n\n    event MemberBalanceMappingUpdated(\n        address indexed oldAddress,\n        address indexed newAddress\n    );\n\n    //event EtherWithdrawn(uint256 amount, address recipient, address sender);\n\n    event TokenTransfer(\n        address contractAddress,\n        address indexed recipient,\n        uint256 amount,\n        uint256 indexed adminId,\n        uint256 indexed date\n    );\n\n    constructor() {\n        name = \"XendEffectLaunchpad\";\n        owner = msg.sender;\n        emit OwnerSet(address(0), owner);\n    }\n\n    modifier restricted() {\n        require(\n            msg.sender == owner,\n            \"This action can only be performed by the contract\u0027s creator\"\n        );\n        _; // run this modifier before the function where we called it.\n    }\n\n    modifier onlyAdmins(uint256 _id) {\n        Admin memory _admin = admins[_id];\n\n        if (msg.sender != owner) {\n            // if  its the contract owner we allow instantly else, validate admin\n\n            require(\n                msg.sender == _admin.admin,\n                \"This action can only be performed by an admin\"\n            );\n\n            require(\n                _admin.isActive,\n                \"This action can only be performed by active admin\"\n            );\n        }\n        _; // proceed to the function where we called it...\n    }\n\n    receive() external payable {\n        // this() can receive ETH\n        emit Received(msg.sender, msg.value);\n    }\n\n    /**\n     *    @notice Get the balance of an account\u0027s Tokens.\n     *    @param _address  The address of the token depositor\n     *   @return        The balance of the Token depositor requested\n     */\n    function getMemberBalance(address _address) public view returns (uint256) {\n        return memberBalances[_address].balance;\n    }\n\n    /**\n     * @dev Member Deposit our stable currency (eg BUSD) to this contract address\n     *      approve function is called on the stable currency contract first via web3 (Member approve this() to spend token)\n     *      We then call transferFrom to complete action and update the member balance in MemberBalance =\u003e public balances here\n     *      @param amount  The amount of the token the member wants to deposit(in wei)\n     */\n    function depositStableCurrency(uint256 amount) external {\n        address member_address = msg.sender;\n\n        memberBalanceAddressMapping memory member = memberBalances[\n            member_address\n        ];\n\n        // aproval must have been given in front end.\n        // Token token = Token(0x1Ee19db4eA9537E38fC7c9Bc1DDd7444Ef6627B6); // BUSD / BUST(staging) ERC20 token contract\n        //  Token token = Token(stableCurrencyContract); // BUSD / BUST(staging) ERC20 token contract\n        // require(token.transferFrom(member_address, address(this), amount), \"transfer Token fails, maybe approval not given\");\n\n        IERC20 token = IERC20(stableCurrencyContract); // BUSD / BUST(staging) ERC20 token contract\n\n        token.safeTransferFrom(member_address, address(this), amount);\n\n        // set the member balance in contract\n        if (member._address == member_address) {\n            member.balance = amount.add(member.balance); // update balance\n            memberBalances[member_address] = member;\n        } else {\n            memberBalances[member_address] = memberBalanceAddressMapping(\n                member_address,\n                amount\n            ); // set new member\n        }\n\n        // check if the balance is set?\n\n        emit StableCurrencyDeposited(amount, member.balance, member_address);\n    }\n\n    /**\n     * @dev Contract Creator can update the member address if needed\n     *       ----\n     */\n    function updateMemberBalanceMapping(\n        address member_address,\n        address member_new_address\n    ) public restricted {\n     \n        memberBalanceAddressMapping memory member = memberBalances[\n            member_address\n        ];\n        memberBalanceAddressMapping memory new_member = memberBalances[\n            member_new_address\n        ];\n\n        // console.log(\u0027contract member mapping \u0027, member);\n        // we cannot update it if the member_new_address exist in the mappings\n\n        // require(new_member._address != member_new_address, \"New address already exist and cannot be used to update\");\n        require(\n            new_member._address != member_new_address,\n            \"New address already exist and cannot be used to update\"\n        );\n\n        member._address = member_new_address; // update balance\n        memberBalances[member_new_address] = member; // sets new member with the same data of old member\n        delete memberBalances[member_address];\n\n        emit MemberBalanceMappingUpdated(member_address, member_new_address);\n    }\n\n    /**\n     * @dev Withdraw amount in wei posted by member to his wallet; $memberBalances must show the user have funds\n     *      and contract must have fund, and allowWithdrawal is set to true by Owner\n     *      substract the amount from member balance and update the  member balance in MemberBalance =\u003e public balances;\n     *      @param amount  The amount of the token the member wants to withdraw(in wei)\n     */\n    function withdrawStableCurrency(uint256 amount) external nonReentrant {\n        memberBalanceAddressMapping memory member = memberBalances[msg.sender];\n\n        require(\n            allowWithdrawal,\n            \"Withdrawal Suspended, allowWithdrawal is false\"\n        );\n\n        require(member.balance \u003e= amount, \"Insuficient Fund\");\n\n        // require(address(this).balance \u003e= member.balance, \u0027Withdrawal Suspended\u0027);\n\n        // update the member balance in contract\n        member.balance = (member.balance).sub(amount);\n        memberBalances[msg.sender] = member; // \u003e\u003e should we tranfer before updating balance?\n\n        /*  Token token = Token(stableCurrencyContract); // BUSD / BUST(staging) ERC20 token contract\n        require(token.transfer(msg.sender, amount), \"\u0027Withdrawal Failed, Member should try again later\");\n         */\n        IERC20 token = IERC20(stableCurrencyContract); // ERC20 token contract\n        // require(token.transfer(recipient, amount), \"transfer Token fails\");\n\n        token.safeTransfer(msg.sender, amount); \n\n        emit TokenTransfer(\n            stableCurrencyContract,\n            msg.sender,\n            amount,\n            0,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Owner call this function to extract/Deduct locked funds; When Members apply for a Sale,\n     *      their deposited fund is locked in local db(mongo), admin must call this function in batches\n     *      to mass deduct the fund from the raffle winners memberBalances after the reffle draw: esle\n     *      the winners can still withdraw fund from the contract. Meanwhile if a member have unsuficient fund\n     *      while admin is trying to call this function, vaidations in front end will remove such user from winners\n     *      list and asign the next available member with valid requirements\n     *      @param winners  The array of winner wallet address (strings) separated by comas thus [\u00270x0...\u0027, \u00270xa\u0027, ...]\n     *      @param amounts  The array of winner amounts(in wei) matching winners[] indexes separated by comas thus [500000, 70000000, ...]\n     *      @param launchpad_sale_id  The id of the lauchpad sale id in our local db, usually ObjectID set as string here\n     *      @param batch_id  The id of the fund extraction batch in our local db, usually ObjectID set as string here: should we have over 10k records, of cus we might not post all once to this function\n     *       @return       True if the action complete\n     */\n    function extractWinnersFund(\n        address[] calldata winners,\n        uint256[] calldata amounts,\n        string calldata launchpad_sale_id,\n        string calldata batch_id\n    ) external restricted returns (bool) {\n        require(\n            winners.length == amounts.length \u0026\u0026 winners.length \u003e= 1,\n            \"Something is wrong with data posted\"\n        );\n\n        require(\n            winners.length \u003c= maxLoopTimes,\n            \"Something is wrong with data posted, data too large\"\n        );\n\n\n        /*\n            so we have some winners who already funded wallet amounts.. \n            this fund was loocked in local db before.\n            deduct the amounts from each user memberBalances on the contract. \n            we do not care if the user balance is 0 (we make his new balance -ve) as user balances should be validated \n            in front end before calling this function NB: winners can also withdraw their fund anytime if this function is not called yet.\n       */\n        for (uint256 i = 0; i \u003c winners.length; i++) {\n            memberBalanceAddressMapping memory member = memberBalances[\n                winners[i]\n            ];\n            //  require(member.balance \u003e= amount, \u0027one user Insuficient Fund\u0027);\n            address winners_ = winners[i];\n            member.balance = (member.balance).sub(amounts[i]);\n            memberBalances[winners_] = member;\n        }\n\n        // emit event that can be used to mark the saleID is fundExtracted=true\n        emit FundExtracted(\n            winners,\n            amounts,\n            launchpad_sale_id,\n            batch_id\n        );\n\n        return true;\n    }\n\n    /**\n     * @dev This is direct Oposite of extractWinnersFund() function should admin have to add funds to user wallets in mass for any reason\n     *       @return       True if the action complete\n     */\n    function injectWalletFunds(\n        address[] calldata winners,\n        uint256[] calldata amounts,\n        string calldata launchpad_sale_id,\n        string calldata batch_id\n    ) external restricted returns (bool) {\n        require(\n            winners.length == amounts.length \u0026\u0026 winners.length \u003e= 1,\n            \"Something is wrong with data posted\"\n        );\n\n        require(\n            winners.length \u003c= maxLoopTimes,\n            \"Something is wrong with data posted, data too large\"\n        );\n\n        for (uint256 i = 0; i \u003c winners.length; i++) {\n            memberBalanceAddressMapping memory member = memberBalances[\n                winners[i]\n            ];\n            address winners_ = winners[i];\n            member.balance = (member.balance).add(amounts[i]);\n            memberBalances[winners_] = member;\n        }\n\n        emit FundInjected(\n            winners,\n            amounts,\n            launchpad_sale_id,\n            batch_id\n        );\n\n        return true;\n    }\n\n    /**\n     * @dev Contract Creator can make another account the contract owner\n     *       MUST revert if `msg.sender` is the zero address.\n     *      @param _newOwner  The wallet address of the new expected owner\n     *      @return       True if the action complete\n     */\n    function changeOwner(address payable _newOwner)\n        public\n        restricted\n        returns (bool)\n    {\n        require(_newOwner != address(0), \"only new person can be set\");\n        newOwner = _newOwner;\n\n        return true;\n    }\n\n    /**\n    * @dev  Accept to become the new contract owner(if you are set as newOwner already) and be able to perform actions. \n            accept is required should changeOwner makes mistake it can be reverted by him too\n            MUST revert if `msg.sender` is not set as newOwner already by the owner\n    */\n    function acceptOwnership() public {\n        require(\n            msg.sender == newOwner,\n            \"You are not invited to become owner yet.\"\n        );\n        owner = newOwner;\n        emit OwnerSet(owner, newOwner);\n    }\n\n    /**\n     * @dev  Get the ETH balance of this contract\n     *        @return    ETH balance\n     */\n    function getBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    /**\n     * @dev Contract Creator can make other accounts admin\n     *       MUST revert if `admin name` is not provided\n     *      @param _id  The id of the admin in our local db, usially ObjectID (string)\n     *      @param _name  The last_name of the admin in our local db, usually string like \u0027Amaka\u0027\n     *      @param _admin_address  The default_wallet of the admin in our local db\n     */\n    function createAdmin(\n        string memory _id,\n        string memory _name,\n        address payable _admin_address\n    ) public restricted {\n        // admins can approve fund withdrawals and more(if need be)\n        require(bytes(_name).length \u003e 0, \"Name should be surname and required\");\n        //require (_admin_address != \u0027 \u0027, \u0027Admin public key is required\u0027);\n        adminCount++;\n\n        // create the admin\n        admins[adminCount] = Admin(\n            adminCount,\n            _id,\n            _name,\n            _admin_address,\n            msg.sender,\n            true\n        );\n\n        emit AdminAdded(\n            adminCount,\n            _id,\n            _name,\n            _admin_address,\n            msg.sender,\n            true\n        );\n    }\n\n    /**\n     * @dev Contract Creator can change the admin status, suspend and unsuspend\n     *       MUST revert if `_id` is not provided or not in contract index\n     *      @param _id  The id of the admin in contract emiited when admin was created\n     *      @param _status  can be true or false\n     */\n    function revokeAdmin(uint256 _id, bool _status) public restricted {\n\n        Admin memory _admin = admins[_id]; // instance of admin from Admins storage: _id = serial id on blockchain\n\n        require(\n            _admin.id \u003e 0 \u0026\u0026 _admin.id \u003c= adminCount,\n            \"Provide valid admin ID\"\n        );\n\n        _admin.isActive = _status;\n\n        // update the admin in array\n        admins[_id] = _admin;\n\n        // admin revoked event\n        emit AdminRevoked(\n            _admin.id,\n            _admin._id,\n            _admin.name,\n            _admin.admin,\n            _admin.father,\n            _status\n        );\n    }\n\n    /**\n     * @dev Contract Creator can stop/enable members from withdrawals\n     *       Switches the status to opoosite of what it is currently\n     *      @return    True if the action complete\n     */\n    function revokeWithdrawal() public restricted returns (bool) {\n        allowWithdrawal = !allowWithdrawal;\n\n        return true;\n    }\n\n    /**\n     * @dev Contract Creator can change the stable currency contract address that memebrs use to deposit and withdraw\n     *       eg. switch from BUSD to DAI etc.\n     *      @param _address  The token contract address\n     *      @return         True if the action complete\n     */\n    function setStableContractAddress(address _address)\n        public\n        restricted\n        returns (bool)\n    {\n        stableCurrencyContract = _address;\n\n        return true;\n    }\n\n /**\n     * @dev Contract Creator can set MaxLoopCount number of times a loop is allowed to run here\n     *       eg. switch from BUSD to DAI etc.\n     *      @param _count  number like 100 or 30\n     *      @return         True if the action complete\n     */\n    function setMaxLoopTimes(uint256 _count)\n        public\n        restricted\n        returns (bool)\n    {\n        maxLoopTimes = _count;\n\n        return true;\n    }\n\n    \n    /**\n     * @dev Contract Creator can withdraw ether if accidentaly sent to this contract or otherwise\n     *      @param recipient  The wallet to receive the transfer\n     *      @param amount     mount to wthdraw\n     *      @return           True if the action complete\n     */\n    function transferNativeToken(address payable recipient, uint256 amount)\n        external\n        restricted\n        returns (bool)\n    {\n        // transfer Ether to the recipient address\n\n        // make sure we have the balance\n\n        //--- ok, trasfer will just fail anyway..\n\n        recipient.transfer(amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Transfers any ERC20 token found in this contract given the token contract address:\n     *      only owner/admins can perform this action : should any token is accidentaly sent to the contract we can recover it with this.\n     *      @param contract_address  The token contract address\n     *      @param recipient  address to receive the token\n     *      @param amount  Amount of token to be sent (in wei)\n     *      @param _admin_id  ID of the admin calling the function\n     *       @return       True if the action complete\n     */\n    function transferToken(\n        address payable contract_address,\n        address payable recipient,\n        uint256 amount,\n        uint256 _admin_id\n    ) external onlyAdmins(_admin_id) returns (bool) {\n        // check if contract_address is actually a contract  \u003e\u003e moved validation to web3\n        /*   uint256 tokenCode;\n           assembly { tokenCode := extcodesize(contract_address) } // contract code size\n           require(tokenCode \u003e 0 \u0026\u0026 contract_address.call(bytes4(0x70a08231), recipient),\n            \"transfer Token fails: pass token contract address only\");\n        */\n\n        IERC20 token = IERC20(contract_address); // ERC20 token contract\n        // require(token.transfer(recipient, amount), \"transfer Token fails\");\n\n        token.safeTransfer(recipient, amount);\n\n        // safe tranfer\n\n        emit TokenTransfer(\n            contract_address,\n            recipient,\n            amount,\n            _admin_id,\n            block.timestamp\n        );\n\n        return true;\n    }\n\n    /**\n     * @dev Admin call this function to mass distrubute  tokens to winners in batches\n     *      only owner/admins can perform this action : Projects can always send their erc20 token to this contract for distribution\n     *      @param contract_address  The token contract address of the token that must have already been sent to the contract from the Company doing sale\n     *      @param recipients  The array of winner wallet address (strings) separated by comas thus [\u00270x0...\u0027, \u00270xa\u0027, ...]\n     *      @param amounts  The array of winner amounts(in wei) matching winners[] indexes separated by comas thus [500000, 70000000, ...]\n     *      @param admin_id  ID of the admin calling the function\n     *      @param batch_id  token distribution can be done in batches when the number of winners are large\n     *       @return       True if the action complete\n     */\n    function distributeToken(\n        address payable contract_address,\n        address[] calldata recipients,\n        uint256[] calldata amounts,\n        uint256 admin_id,\n        string calldata batch_id\n    ) external onlyAdmins(admin_id) returns (bool) {\n        require(\n            recipients.length == amounts.length \u0026\u0026 recipients.length \u003e= 1,\n            \"Something is wrong with data posted\"\n        );\n\n        require(\n            recipients.length \u003c= maxLoopTimes,\n            \"Something is wrong with data posted, data too large\"\n        );\n\n        // bytes4 fID= bytes4(keccak256(\"transfer(address,uint256)\")); //\n\n        IERC20 token = IERC20(contract_address); // ERC20 token contract\n\n        for (uint256 i = 0; i \u003c recipients.length; i++) {\n            //if(!token.call(fID, recipients[i], amounts[i])) { revert(); }\n\n            // if(!token.transfer(recipients[i], amounts[i])) { revert(); }\n\n            token.safeTransfer(recipients[i], amounts[i]);\n        }\n\n        emit TokenDistributted(\n            contract_address,\n            recipients,\n            amounts,\n            admin_id,\n            batch_id\n        );\n\n        return true;\n    }\n\n    /**\n     * @dev Admin call this function to mass distrubute  eth to winners in batches\n     *      only owner/admins can perform this action : Should the Project wants to distribute Ether or BNB intead of an ERC20 Token (you are covered)\n     *      @param recipients  The array of winner wallet address (strings) separated by comas thus [\u00270x0...\u0027, \u00270xa\u0027, ...]\n     *      @param amounts  The array of winner amounts(in wei) matching winners[] indexes separated by comas thus [500000, 70000000, ...]\n     *      @param admin_id  ID of the admin calling the function\n     *      @param launchpad_sale_id  ID of the sale in local Db usually ObjectID, strigified here\n     *      @param batch_id  token distribution can be done in batches when the number of winners are large\n     *       @return       True if the action complete\n     */\n    function distributeNativeToken(\n        address[] calldata recipients,\n        uint256[] calldata amounts,\n        uint256 admin_id,\n        string calldata launchpad_sale_id,\n        string calldata batch_id\n    ) external onlyAdmins(admin_id) returns (bool) {\n        require(\n            recipients.length == amounts.length \u0026\u0026 recipients.length \u003e= 1,\n            \"Something is wrong with data posted\"\n        );\n        require(\n            recipients.length \u003c= maxLoopTimes,\n            \"Something is wrong with data posted, data too large\"\n        );\n\n        for (uint256 i = 0; i \u003c recipients.length; i++) {\n            payable(recipients[i]).transfer(amounts[i]);\n\n            //if(!payable(recipients[i]).transfer(amount[i])) { revert(); }\n        }\n\n        emit NativeTokenDistributted(\n            recipients,\n            amounts,\n            admin_id,\n            launchpad_sale_id,\n            batch_id\n        );\n\n        return true;\n    }\n\n}\n"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}"},"ReentrancyGuard.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\u0027s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\u0027s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\u0027s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}"},"SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Address.sol\";\nimport \"./ReentrancyGuard.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \u0027safeIncreaseAllowance\u0027 and \u0027safeDecreaseAllowance\u0027\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\u0027s return data size checking mechanism, since\n        // we\u0027re implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"},"Token.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// THIS ERC 20 CONTRACT IS ONLY USED BY TEST SUITE TO MINT TEMPORARY TOKENS (Spirit Token) FOR TESTING PURPOSES THATS ALL.\n\n/* //import \u0027https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol\u0027;\nimport \"../node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nabstract contract Token is ERC20 {}\n */\n\n// \u003e\u003e to deploy we can comment everything below out and above uncomment\n\n contract Token {\n// test token to enable test contract locally\n    string  public name = \"Spirit Token\";\n    string  public symbol = \"SPRT\";\n    uint256 public totalSupply = 1000000000000000000000000; // 1 million tokens\n    uint8   public decimals = 18;\n\n    event Transfer(\n        address indexed _from,\n        address indexed _to,\n        uint256 _value\n    );\n\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _value\n    );\n\n    mapping(address =\u003e uint256) public balanceOf;\n    mapping(address =\u003e mapping(address =\u003e uint256)) public allowance;\n\n    constructor() {\n        balanceOf[msg.sender] = totalSupply;\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] \u003e= _value);\n        balanceOf[msg.sender] -= _value;\n        balanceOf[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value \u003c= balanceOf[_from]);\n        require(_value \u003c= allowance[_from][msg.sender]);\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        allowance[_from][msg.sender] -= _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n}"}}