{"MerkleTreeWithHistory.sol":{"content":"// https://tornado.cash\n/*\n * d888888P                                           dP              a88888b.                   dP\n *    88                                              88             d8\u0027   `88                   88\n *    88    .d8888b. 88d888b. 88d888b. .d8888b. .d888b88 .d8888b.    88        .d8888b. .d8888b. 88d888b.\n *    88    88\u0027  `88 88\u0027  `88 88\u0027  `88 88\u0027  `88 88\u0027  `88 88\u0027  `88    88        88\u0027  `88 Y8ooooo. 88\u0027  `88\n *    88    88.  .88 88       88    88 88.  .88 88.  .88 88.  .88 dP Y8.   .88 88.  .88       88 88    88\n *    dP    `88888P\u0027 dP       dP    dP `88888P8 `88888P8 `88888P\u0027 88  Y88888P\u0027 `88888P8 `88888P\u0027 dP    dP\n * ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\n */\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\n\ninterface IHasher {\n  function MiMCSponge(uint256 in_xL, uint256 in_xR) external pure returns (uint256 xL, uint256 xR);\n}\n\ncontract MerkleTreeWithHistory {\n  uint256 public constant FIELD_SIZE = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n  uint256 public constant ZERO_VALUE = 21663839004416932945382355908790599225266501822907911457504978515578255421292; // = keccak256(\"tornado\") % FIELD_SIZE\n  IHasher public immutable hasher;\n\n  uint32 public levels;\n\n  // the following variables are made public for easier testing and debugging and\n  // are not supposed to be accessed in regular code\n\n  // filledSubtrees and roots could be bytes32[size], but using mappings makes it cheaper because\n  // it removes index range check on every interaction\n  mapping(uint256 =\u003e bytes32) public filledSubtrees;\n  mapping(uint256 =\u003e bytes32) public roots;\n  uint32 public constant ROOT_HISTORY_SIZE = 30;\n  uint32 public currentRootIndex = 0;\n  uint32 public nextIndex = 0;\n\n  constructor(uint32 _levels, IHasher _hasher) {\n    require(_levels \u003e 0, \"_levels should be greater than zero\");\n    require(_levels \u003c 32, \"_levels should be less than 32\");\n    require(address(0) != address(_hasher), \"set hasher to the zero address\");\n    levels = _levels;\n    hasher = _hasher;\n\n    for (uint32 i = 0; i \u003c _levels; i++) {\n      filledSubtrees[i] = zeros(i);\n    }\n\n    roots[0] = zeros(_levels - 1);\n  }\n\n  /**\n    @dev Hash 2 tree leaves, returns MiMC(_left, _right)\n  */\n  function hashLeftRight(\n    IHasher _hasher,\n    bytes32 _left,\n    bytes32 _right\n  ) public pure returns (bytes32) {\n    require(uint256(_left) \u003c FIELD_SIZE, \"_left should be inside the field\");\n    require(uint256(_right) \u003c FIELD_SIZE, \"_right should be inside the field\");\n    uint256 R = uint256(_left);\n    uint256 C = 0;\n    (R, C) = _hasher.MiMCSponge(R, C);\n    R = addmod(R, uint256(_right), FIELD_SIZE);\n    (R, C) = _hasher.MiMCSponge(R, C);\n    return bytes32(R);\n  }\n\n  function _insert(bytes32 _leaf) internal returns (uint32 index) {\n    uint32 _nextIndex = nextIndex;\n    require(_nextIndex != uint32(2)**levels, \"Merkle tree is full. No more leaves can be added\");\n    uint32 currentIndex = _nextIndex;\n    bytes32 currentLevelHash = _leaf;\n    bytes32 left;\n    bytes32 right;\n\n    for (uint32 i = 0; i \u003c levels; i++) {\n      if (currentIndex % 2 == 0) {\n        left = currentLevelHash;\n        right = zeros(i);\n        filledSubtrees[i] = currentLevelHash;\n      } else {\n        left = filledSubtrees[i];\n        right = currentLevelHash;\n      }\n      currentLevelHash = hashLeftRight(hasher, left, right);\n      currentIndex /= 2;\n    }\n\n    uint32 newRootIndex = (currentRootIndex + 1) % ROOT_HISTORY_SIZE;\n    currentRootIndex = newRootIndex;\n    roots[newRootIndex] = currentLevelHash;\n    nextIndex = _nextIndex + 1;\n    return _nextIndex;\n  }\n\n  /**\n    @dev Whether the root is present in the root history\n  */\n  function isKnownRoot(bytes32 _root) public view returns (bool) {\n    if (_root == 0) {\n      return false;\n    }\n    uint32 _currentRootIndex = currentRootIndex;\n    uint32 i = _currentRootIndex;\n    do {\n      if (_root == roots[i]) {\n        return true;\n      }\n      if (i == 0) {\n        i = ROOT_HISTORY_SIZE;\n      }\n      i--;\n    } while (i != _currentRootIndex);\n    return false;\n  }\n\n  /**\n    @dev Returns the last root\n  */\n  function getLastRoot() public view returns (bytes32) {\n    return roots[currentRootIndex];\n  }\n\n  /// @dev provides Zero (Empty) elements for a MiMC MerkleTree. Up to 32 levels\n  function zeros(uint256 i) public pure returns (bytes32) {\n    if (i == 0) return bytes32(0x2fe54c60d3acabf3343a35b6eba15db4821b340f76e741e2249685ed4899af6c);\n    else if (i == 1) return bytes32(0x256a6135777eee2fd26f54b8b7037a25439d5235caee224154186d2b8a52e31d);\n    else if (i == 2) return bytes32(0x1151949895e82ab19924de92c40a3d6f7bcb60d92b00504b8199613683f0c200);\n    else if (i == 3) return bytes32(0x20121ee811489ff8d61f09fb89e313f14959a0f28bb428a20dba6b0b068b3bdb);\n    else if (i == 4) return bytes32(0x0a89ca6ffa14cc462cfedb842c30ed221a50a3d6bf022a6a57dc82ab24c157c9);\n    else if (i == 5) return bytes32(0x24ca05c2b5cd42e890d6be94c68d0689f4f21c9cec9c0f13fe41d566dfb54959);\n    else if (i == 6) return bytes32(0x1ccb97c932565a92c60156bdba2d08f3bf1377464e025cee765679e604a7315c);\n    else if (i == 7) return bytes32(0x19156fbd7d1a8bf5cba8909367de1b624534ebab4f0f79e003bccdd1b182bdb4);\n    else if (i == 8) return bytes32(0x261af8c1f0912e465744641409f622d466c3920ac6e5ff37e36604cb11dfff80);\n    else if (i == 9) return bytes32(0x0058459724ff6ca5a1652fcbc3e82b93895cf08e975b19beab3f54c217d1c007);\n    else if (i == 10) return bytes32(0x1f04ef20dee48d39984d8eabe768a70eafa6310ad20849d4573c3c40c2ad1e30);\n    else if (i == 11) return bytes32(0x1bea3dec5dab51567ce7e200a30f7ba6d4276aeaa53e2686f962a46c66d511e5);\n    else if (i == 12) return bytes32(0x0ee0f941e2da4b9e31c3ca97a40d8fa9ce68d97c084177071b3cb46cd3372f0f);\n    else if (i == 13) return bytes32(0x1ca9503e8935884501bbaf20be14eb4c46b89772c97b96e3b2ebf3a36a948bbd);\n    else if (i == 14) return bytes32(0x133a80e30697cd55d8f7d4b0965b7be24057ba5dc3da898ee2187232446cb108);\n    else if (i == 15) return bytes32(0x13e6d8fc88839ed76e182c2a779af5b2c0da9dd18c90427a644f7e148a6253b6);\n    else if (i == 16) return bytes32(0x1eb16b057a477f4bc8f572ea6bee39561098f78f15bfb3699dcbb7bd8db61854);\n    else if (i == 17) return bytes32(0x0da2cb16a1ceaabf1c16b838f7a9e3f2a3a3088d9e0a6debaa748114620696ea);\n    else if (i == 18) return bytes32(0x24a3b3d822420b14b5d8cb6c28a574f01e98ea9e940551d2ebd75cee12649f9d);\n    else if (i == 19) return bytes32(0x198622acbd783d1b0d9064105b1fc8e4d8889de95c4c519b3f635809fe6afc05);\n    else if (i == 20) return bytes32(0x29d7ed391256ccc3ea596c86e933b89ff339d25ea8ddced975ae2fe30b5296d4);\n    else if (i == 21) return bytes32(0x19be59f2f0413ce78c0c3703a3a5451b1d7f39629fa33abd11548a76065b2967);\n    else if (i == 22) return bytes32(0x1ff3f61797e538b70e619310d33f2a063e7eb59104e112e95738da1254dc3453);\n    else if (i == 23) return bytes32(0x10c16ae9959cf8358980d9dd9616e48228737310a10e2b6b731c1a548f036c48);\n    else if (i == 24) return bytes32(0x0ba433a63174a90ac20992e75e3095496812b652685b5e1a2eae0b1bf4e8fcd1);\n    else if (i == 25) return bytes32(0x019ddb9df2bc98d987d0dfeca9d2b643deafab8f7036562e627c3667266a044c);\n    else if (i == 26) return bytes32(0x2d3c88b23175c5a5565db928414c66d1912b11acf974b2e644caaac04739ce99);\n    else if (i == 27) return bytes32(0x2eab55f6ae4e66e32c5189eed5c470840863445760f5ed7e7b69b2a62600f354);\n    else if (i == 28) return bytes32(0x002df37a2642621802383cf952bf4dd1f32e05433beeb1fd41031fb7eace979d);\n    else if (i == 29) return bytes32(0x104aeb41435db66c3e62feccc1d6f5d98d0a0ed75d1374db457cf462e3a1f427);\n    else if (i == 30) return bytes32(0x1f3c6fd858e9a7d4b0d1f38e256a09d81d5a5e3c963987e2d4b814cfab7c6ebb);\n    else if (i == 31) return bytes32(0x2c7a07d20dff79d01fecedc1134284a8d08436606c93693b67e333f671bf69cc);\n    else revert(\"Index out of bounds\");\n  }\n}\n"},"safemath.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity 0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler\u0027s built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c \u003c a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b \u003e a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n            // benefit is lost if \u0027b\u0027 is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003c= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003e 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003e 0, errorMessage);\n            return a % b;\n        }\n    }\n}"},"whalefog-erc20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\n\nimport \"./MerkleTreeWithHistory.sol\";\nimport \"./safemath.sol\";\n\ninterface IDepositVerifier {\n  function verifyProof(bytes memory _proof, uint256[2] memory _input) external  returns(bool);\n}\n\ninterface IWithdrawVerifier {\n  function verifyProof(bytes memory _proof, uint256[8] memory _input) external  returns(bool);\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint);\n    function balanceOf(address tokenOwner) external view returns (uint balance);\n    function allowance(address tokenOwner, address spender) external view returns (uint remaining);\n    function transfer(address to, uint tokens) external returns (bool success);\n    function approve(address spender, uint tokens) external returns (bool success);\n    function transferFrom(address from, address to, uint tokens) external returns (bool success);\n\n    event Transfer(address indexed from, address indexed to, uint tokens);\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\n\ncontract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\u0027s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\u0027s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\u0027s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\ncontract whalefogERC20 is MerkleTreeWithHistory, ReentrancyGuard {\n  mapping(bytes32 =\u003e bool) public vouchers;\n  mapping(bytes32 =\u003e bool) public commitments;\n  IDepositVerifier public dpVerifier;\n  IWithdrawVerifier public wdVerifier;\n  IERC20 public token;\n  address public operator;\n  address payable public treasury;\n\n  using SafeMath for uint256;\n\n  uint256 public bnbfee = 0;       //unit is gwei\n  uint256 public relayfee = 0;   //100 percent is 100,000\n  uint256 public min = 0;\n\n  uint256 internal _MAX = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n  modifier onlyOperator {\n    require(msg.sender == operator, \"Only operator can call this function.\");\n    _;\n  }\n\n  event Deposit(bytes32 indexed commitment, uint256 balance, uint32 leafIndex, uint256 timestamp);\n  event Withdrawal(address to, bytes32 voucher, uint256 balance, address indexed relayer, uint256 fee, uint32 leafIndex, uint256 timestamp);\n  event SetFee(uint256 _bnbfee, uint256 _relayfee, uint256 _min);\n  event UpdateDPVerifier(address _newVerifier);\n  event UpdateWDVerifier(address _newVerifier);\n  event UpdateToken(address _newToekn);\n  event ChangeOperator(address _newOperator);\n  event ChangeTreasury(address _newTreasury);\n\n  constructor(\n    IDepositVerifier _dpVerifier,\n    IWithdrawVerifier _wdVerifier,\n    IHasher _hasher,\n    uint32 _merkleTreeHeight,\n    IERC20 _token\n  ) MerkleTreeWithHistory(_merkleTreeHeight, _hasher)  {\n    dpVerifier = _dpVerifier;\n    wdVerifier = _wdVerifier;\n    operator = msg.sender;\n    treasury = payable(msg.sender);\n    token = _token;\n  }\n\n  \n  function deposit(bytes32 _commitment, uint248 _balance, bytes calldata _proof) external payable nonReentrant {\n    require(!commitments[_commitment], \"The commitment has been submitted\");\n    require(_balance \u003e= min ,\"deposit balance is less than minimum\");\n    require(msg.value == bnbfee,\"msg value is less than bnb fee \");\n    \n    require(dpVerifier.verifyProof(_proof, [uint256(_balance),uint256(_commitment)]), \"Invalid deposit proof\");\n    require(token.transferFrom(msg.sender,address(this),uint256(_balance)),\"erc20 transfer error\");\n    \n    uint32 insertedIndex = _insert(_commitment);\n    commitments[_commitment] = true;\n    \n    (bool success, ) = treasury.call{value: bnbfee}(\"\");\n    require(success, \"Address: unable to send value, treasury may have reverted\");\n    emit Deposit(_commitment, uint256(_balance), insertedIndex, block.timestamp);\n  }\n\n  \n  function withdraw(bytes calldata _proof, bytes32 _root, bytes32 _voucher,  uint248 _amount,bytes32 _commitment, address payable _recipient, address payable _relayer, uint256 _fee, uint256 _refund) external payable nonReentrant {\n    require(_fee \u003c= (uint256(_amount).mul(relayfee).div(100000)), \"Fee exceeds transfer value\");\n    require(_amount \u003e= min ,\"withdraw balance is less than minimum\");\n    require(!vouchers[_voucher], \"The voucher has been already used\");\n    require(!commitments[_commitment], \"The commitment has been submitted\");\n    \n    require(isKnownRoot(_root), \"Cannot find your merkle root\"); // Make sure to use a recent one\n    require(wdVerifier.verifyProof(_proof, [uint256(_root), uint256(_voucher), uint256(_amount), uint256(_commitment), uint256(uint160(address(_recipient))), uint256(uint160(address(_relayer))), _fee, _refund]), \"Invalid withdraw proof\");\n\n    vouchers[_voucher] = true;\n    commitments[_commitment] = true;\n    uint32 insertedIndex = _insert(_commitment);\n    emit Deposit(_commitment, uint256(_MAX), insertedIndex, block.timestamp);\n    _processWithdraw(_amount, _recipient, _relayer, _fee);\n    emit Withdrawal(_recipient, _voucher, _amount, _relayer, _fee, insertedIndex, block.timestamp);\n  }\n\n  function isSpent(bytes32 _voucher) public view returns(bool) {\n    return vouchers[_voucher];\n  }\n\n  function isSpentArray(bytes32[] calldata _vouchers) external view returns(bool[] memory spent) {\n    spent = new bool[](_vouchers.length);\n    for(uint i = 0; i \u003c _vouchers.length; i++) {\n      if (isSpent(_vouchers[i])) {\n        spent[i] = true;\n      }\n    }\n  }\n\n  function setFee(uint256 _bnbfee, uint256 _relayfee, uint256 _min) external onlyOperator {\n    require(_relayfee \u003c 100000, \"repalyfee should less than 100000\");\n    bnbfee = _bnbfee;\n    relayfee = _relayfee;\n    min = _min;\n    emit SetFee(_bnbfee, _relayfee, _min);\n  }\n\n  function updateDPVerifier(address _newVerifier) external onlyOperator {\n    dpVerifier = IDepositVerifier(_newVerifier);\n    emit UpdateDPVerifier(_newVerifier);\n  }\n\n  function updateWDVerifier(address _newVerifier) external onlyOperator {\n    wdVerifier = IWithdrawVerifier(_newVerifier);\n    emit UpdateWDVerifier(_newVerifier);\n  }\n\n  function updateToken(address _newToekn) external onlyOperator {\n    token = IERC20(_newToekn);\n    emit UpdateToken(_newToekn);\n  }\n\n  function changeOperator(address _newOperator) external onlyOperator {\n    //require(_newOperator != address(0),\"new operator should not be zero\");\n    operator = _newOperator;\n    emit ChangeOperator(_newOperator);\n  }\n\n  function changeTreasury(address payable _newTreasury) external onlyOperator {\n    treasury = _newTreasury;\n    emit ChangeTreasury(_newTreasury);\n  }\n\n  function _processWithdraw(uint256 _amount, address payable _recipient, address payable _relayer, uint256 _fee) internal {\n      \n      uint256 relayamount = _amount.mul(relayfee).div(100000);\n      uint256 reamount = _amount.sub(relayamount); \n      \n      //_recipient.transfer(reamount - _fee);\n      require(token.transfer(_recipient, reamount.sub(_fee)),\"ERC20 transfer error 1\");\n\n      if (relayamount \u003e 0) {\n        //_relayer.transfer(relayamount);\n        require(token.transfer(_relayer, relayamount),\"ERC20 transfer error 2\");\n      }\n      \n      if (_fee \u003e 0) {\n        //_relayer.transfer(_fee); \n        require(token.transfer(_relayer, _fee),\"ERC20 transfer error 3\");\n      }\n\n  }\n}\n"}}