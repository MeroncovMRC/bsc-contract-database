{"Bank.sol":{"content":"// SPDX-License-Identifier: BSD-3-Clause\r\n\r\npragma solidity 0.8.17;\r\n\r\nimport \"./Data.sol\";\r\n\r\ncontract Bank is Data {\r\n\r\n  function initiateDistribute() external hasAccount(msg.sender) {\r\n    uint amount = distribute(systemBalance);\r\n\r\n    systemBalance -= amount;\r\n  }\r\n\r\n  function distribute(uint _amount) internal returns (uint) {\r\n    require(_amount \u003e 0, \"No amount transferred\");\r\n\r\n    uint amount = _amount - (_amount % 100);\r\n    uint percentage = amount / 100;\r\n    uint total_used = 0;\r\n    uint pay = 0;\r\n\r\n    for (uint num = 0; num \u003c totalHolders;num++) {\r\n      pay = percentage * accountStorage[accountLookup[num]].percentage;\r\n\r\n      if (pay \u003e 0) {\r\n        if ((total_used + pay) \u003e amount) { //Ensure we do not pay out too much\r\n          pay = amount - total_used;\r\n        }\r\n\r\n        deposit(accountLookup[num], pay);\r\n        total_used += pay;\r\n      }\r\n\r\n      if (total_used \u003e= amount) { //Ensure we stop if we have paid out everything\r\n        break;\r\n      }\r\n    }\r\n\r\n    return total_used;\r\n  }\r\n\r\n  function deposit(address _to, uint _amount) internal hasAccount(_to) {\r\n    accountStorage[_to].amount += _amount;\r\n  }\r\n\r\n  fallback() external payable {\r\n    systemBalance += msg.value;\r\n  }\r\n\r\n  receive() external payable {\r\n    systemBalance += msg.value;\r\n  }\r\n\r\n  function getSystemBalance() external view hasAccount(msg.sender) returns (uint) {\r\n    return systemBalance;\r\n  }\r\n\r\n  function getBalance() external view hasAccount(msg.sender) returns (uint) {\r\n    return accountStorage[msg.sender].amount;\r\n  }\r\n\r\n  function getReceived() external view hasAccount(msg.sender) returns (uint) {\r\n    return accountStorage[msg.sender].received;\r\n  }\r\n  \r\n  function withdraw(uint _amount) external payable hasAccount(msg.sender) canWithdraw(msg.sender) blockReEntry() {\r\n    require(accountStorage[msg.sender].amount \u003e= _amount \u0026\u0026 _amount \u003e 0, \"Not enough funds\");\r\n\r\n    accountStorage[msg.sender].amount -= _amount;\r\n    accountStorage[msg.sender].received += _amount;\r\n\r\n    (bool success, ) = msg.sender.call{value: _amount}(\"\");\r\n    \r\n    require(success, \"Transfer failed\");\r\n  }\r\n\r\n  function withdrawTo(address payable _to, uint _amount) external hasAccount(msg.sender) canWithdraw(msg.sender) blockReEntry() {\r\n    require(accountStorage[msg.sender].amount \u003e= _amount \u0026\u0026 _amount \u003e 0, \"Not enough funds\");\r\n\r\n    accountStorage[msg.sender].amount -= _amount;\r\n    accountStorage[msg.sender].received += _amount;\r\n\r\n    (bool success, ) = _to.call{value: _amount}(\"\");\r\n    \r\n    require(success, \"Transfer failed\");\r\n  }\r\n\r\n  function subPercentage(address _addr, uint _percentage) internal hasAccount(_addr) {\r\n      accountStorage[_addr].percentage -= _percentage;\r\n    }\r\n\r\n  function addPercentage(address _addr, uint _percentage) internal hasAccount(_addr) {\r\n    accountStorage[_addr].percentage += _percentage;\r\n  }\r\n\r\n  function getPercentage() external view hasAccount(msg.sender) returns (uint) {\r\n    return accountStorage[msg.sender].percentage;\r\n  }\r\n\r\n  function validateBalance() external hasAccount(msg.sender) returns (uint) { //Allow any account to verify/adjust contract balance\r\n    uint amount = systemBalance;\r\n\r\n    for (uint num = 0; num \u003c totalHolders;num++) {\r\n      amount += accountStorage[accountLookup[num]].amount;\r\n    }\r\n\r\n    if (amount \u003c address(this).balance) {\r\n      uint balance = address(this).balance;\r\n      balance -= amount;\r\n\r\n      systemBalance += balance;\r\n\r\n      return balance;\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  function createAccount(address _addr, uint _amount, uint _percentage, uint _agreementAmount, bool _withdraw) internal {\r\n    accountStorage[_addr] = Account({amount: _amount, received: 0, percentage: _percentage, withdraw: _withdraw, exists: true});\r\n    agreementAmount[totalHolders] = _agreementAmount;\r\n    accountLookup[totalHolders++] = _addr;\r\n  }\r\n\r\n  function deleteAccount(address _addr, address _to) internal hasAccount(_addr) {\r\n    deposit(_to, accountStorage[_addr].amount);\r\n\r\n    for (uint8 num = 0; num \u003c totalHolders;num++) {\r\n      if (accountLookup[num] == _addr) {\r\n        delete(accountLookup[num]);\r\n        break;\r\n      }\r\n    }\r\n\r\n    delete(accountStorage[_addr]);\r\n  }\r\n}"},"Data.sol":{"content":"// SPDX-License-Identifier: BSD-3-Clause\r\n\r\npragma solidity 0.8.17;\r\n\r\ncontract Data {\r\n\r\n  struct Account {\r\n    uint amount;\r\n    uint received;\r\n    uint percentage;\r\n    bool exists;\r\n    bool withdraw;\r\n  }\r\n  \r\n  uint internal constant ENTRY_ENABLED = 1;\r\n  uint internal constant ENTRY_DISABLED = 2;\r\n\r\n  uint internal totalHolders;\r\n  uint internal reEntryStatus;\r\n  uint internal systemBalance = 0;\r\n  \r\n  address internal owner;\r\n  \r\n  mapping(uint =\u003e uint) internal agreementAmount;\r\n  mapping(uint =\u003e address) internal accountLookup;\r\n  mapping(address =\u003e address) internal transferTo;\r\n  mapping(address =\u003e Account) internal accountStorage;  \r\n\r\n  modifier hasAccount(address _addr) {\r\n    require(accountStorage[_addr].exists, \"Restricted Access!\");\r\n    _;\r\n  }\r\n\r\n  modifier blockReEntry() {      \r\n    require(reEntryStatus != ENTRY_DISABLED, \"Security Block\");\r\n    reEntryStatus = ENTRY_DISABLED;\r\n\r\n    _;\r\n\r\n    reEntryStatus = ENTRY_ENABLED;\r\n  }\r\n\r\n  modifier canWithdraw(address _addr) {\r\n    require(accountStorage[_addr].withdraw, \"Restricted Access!\");\r\n    _;\r\n  }\r\n\r\n  modifier isOwner(address _addr) {\r\n    require(owner == _addr, \"Restricted Access!\");\r\n    _;\r\n  }\r\n\r\n  modifier canTransfer(address _addr) {\r\n    require(accountStorage[_addr].exists == true \u0026\u0026 accountStorage[_addr].withdraw == false, \"Restricted Access!\");\r\n    _;\r\n  }\r\n}"},"Distribute.sol":{"content":"// SPDX-License-Identifier: BSD-3-Clause\r\n\r\npragma solidity 0.8.17;\r\n\r\nimport \"./Bank.sol\";\r\n\r\ncontract Distribute is Bank {\r\n\r\n  constructor(address[] memory _addr, uint[] memory _perc, uint[] memory _amount, bool[] memory _withdraw) {\r\n    reEntryStatus = ENTRY_ENABLED;\r\n    owner = msg.sender;\r\n\r\n    uint percentage = 0;\r\n\r\n    for (uint i = 0;i \u003c _addr.length;i++) {\r\n      percentage = percentage + _perc[i];\r\n    }\r\n\r\n    require(percentage == 100, \"Percentage does not equal 100%\");\r\n\r\n    for (uint i=0;i \u003c _addr.length;i++) {\r\n      if (i == 0) {\r\n        createAccount(_addr[i], address(this).balance, _perc[i], _amount[i], _withdraw[i]);\r\n      } else {\r\n        createAccount(_addr[i], 0, _perc[i], _amount[i], _withdraw[i]);\r\n      }\r\n    }\r\n  }\r\n\r\n  function reviewAgreement(uint _account) external hasAccount(msg.sender) {\r\n    require(agreementAmount[_account] \u003e 0, \"No agreement on account\");\r\n\r\n    if (accountStorage[accountLookup[_account]].received \u003e agreementAmount[_account]) {\r\n      agreementAmount[_account] = 0;\r\n      subPercentage(accountLookup[_account], 72);\r\n      deleteAccount(accountLookup[_account], accountLookup[0]);\r\n      addPercentage(accountLookup[1], 18);\r\n      addPercentage(accountLookup[2], 18);\r\n      addPercentage(accountLookup[3], 18);\r\n      addPercentage(accountLookup[4], 14);\r\n      addPercentage(accountLookup[5], 4);\r\n    }\r\n  }\r\n\r\n  function isAgreementCompleted(uint _account) external view hasAccount(msg.sender) returns (bool) {\r\n    return agreementAmount[_account] == 0;\r\n  }\r\n}"}}