{"AggregatorV3Interface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity \u003e=0.6.0;\n\ninterface AggregatorV3Interface {\n\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n"},"notary.sol":{"content":"pragma solidity ^0.6.7;\r\n\r\n import \"./AggregatorV3Interface.sol\";\r\n// import \"@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\";\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.6.7;\r\n\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor() internal {}\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.6.7;\r\n\r\ncontract Ownable is Context {\r\n    address payable private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() internal {\r\n        _owner = _msgSender();\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    function owner() public view returns (address payable) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"not the owner\");\r\n        _;\r\n    }\r\n\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address payable newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address payable newOwner) internal {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n// 1 - admin\r\n// 2 - sub admin\r\n// 3 - superadmin\r\n\r\npragma solidity ^0.6.7;\r\n\r\ncontract Notary is Ownable {\r\n\r\n    struct FirstLevelUsers {\r\n        uint64 transactionCount ;\r\n        uint64 sluAllowanceCount ;\r\n        int256 perTransactionFee ;\r\n        address[] usersWhitelisted ;\r\n        bool isEUR ;\r\n        uint256 accessLevel ;\r\n    }\r\n    struct DocData {\r\n        uint256 time;\r\n        string sha256Hash;\r\n        string ipfsHash;\r\n        string fileName;\r\n        string sessionKey;\r\n        address creator;\r\n        address user;\r\n    }\r\n    struct FLUBatch {\r\n        address user  ;\r\n        uint64 transactionCount ;\r\n        uint64 sluAllowanceCount ;\r\n        int256 perTransactionFee ;\r\n        bool isEUR ;\r\n        uint256 accessLevel;\r\n    }\r\n    struct AdminWhitelistCount {\r\n        uint256 subAdminCount;\r\n        uint256 fluCount;\r\n        address[] adminsWhiteListed;\r\n    }\r\n      AggregatorV3Interface internal priceFeed;\r\n      AggregatorV3Interface internal priceEUR;\r\n    mapping(address =\u003e DocData[]) public documents;\r\n    mapping(address =\u003e FirstLevelUsers) public firstLevelUsers;\r\n    mapping(address =\u003e mapping(address =\u003e bool)) public secondLevelUsers;\r\n    mapping(address =\u003e bool ) public isFirstLevelUser;\r\n    mapping(address =\u003e uint256 ) public adminLevel;\r\n    mapping(address=\u003e  address[]) private adminFLUAddress;\r\n    mapping(address =\u003e AdminWhitelistCount ) public adminWhitelistCount;\r\n    address[] public FLUAddress;\r\n    string public name;\r\n    uint256 batchLimit = 10;\r\n    \r\n    constructor(\r\n    string memory name_\r\n    \r\n    ) public Ownable() {\r\n        priceFeed = AggregatorV3Interface(0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE);\r\n        priceEUR = AggregatorV3Interface(0x0bf79F617988C472DcA68ff41eFe1338955b9A80);\r\n        name = name_;\r\n        adminLevel[msg.sender] = 1 ;\r\n        isFirstLevelUser[msg.sender] = true;\r\n        firstLevelUsers[msg.sender] = FirstLevelUsers({\r\n            transactionCount : 1000000,\r\n            sluAllowanceCount : 1000000,\r\n            perTransactionFee : 0,\r\n            usersWhitelisted : new address[](0),\r\n            isEUR : true,\r\n            accessLevel : 4\r\n            });\r\n    }\r\n        function getPriceUSDETH() public view returns (int) {\r\n        (\r\n            uint80 roundID, \r\n            int price,\r\n            uint startedAt,\r\n            uint timeStamp,\r\n            uint80 answeredInRound\r\n        ) = priceFeed.latestRoundData();\r\n        return price;\r\n    }\r\n        function getPriceUSDEUR() public view returns (int) {\r\n        (\r\n            uint80 roundID, \r\n            int price,\r\n            uint startedAt,\r\n            uint timeStamp,\r\n            uint80 answeredInRound\r\n        ) = priceEUR.latestRoundData();\r\n        return price;\r\n    }\r\n            function getAllPriceUSDEUR() public view returns (uint80,int256,uint256,uint256,uint80) {\r\n        (\r\n            uint80 roundID, \r\n            int price,\r\n            uint startedAt,\r\n            uint timeStamp,\r\n            uint80 answeredInRound\r\n        ) = priceEUR.latestRoundData();\r\n        return (roundID, price, startedAt, timeStamp, answeredInRound);\r\n    }\r\n        function getPrices(bool _curr ) public view returns (int) {\r\n            if(_curr){\r\n                return (getPriceUSDETH()*(10**8))/getPriceUSDEUR();\r\n            }else{\r\n                return getPriceUSDETH();\r\n            }\r\n    }\r\n      \r\n      function _addFLU(FLUBatch  memory _FLUBatch) private returns (bool) {\r\n         firstLevelUsers[_FLUBatch.user] = FirstLevelUsers({\r\n            transactionCount : _FLUBatch.transactionCount,\r\n            sluAllowanceCount : _FLUBatch.sluAllowanceCount,\r\n            perTransactionFee : _FLUBatch.perTransactionFee,\r\n            usersWhitelisted : new address[](0),\r\n            isEUR : _FLUBatch.isEUR,\r\n            accessLevel : _FLUBatch.accessLevel\r\n            });\r\n            return true;\r\n       }\r\n\r\n        function checkAdmins (uint256 l) private pure{\r\n          require(l==1 || l ==2, \"na\");\r\n          }\r\n    function addFirstLevelUser(FLUBatch  memory _FLUBatch ) public  {\r\n        require(adminLevel[msg.sender]==1 || adminLevel[msg.sender]==2 || adminLevel[msg.sender]==3,\"na\");\r\n        require(!isFirstLevelUser[_FLUBatch.user],\"uae\");\r\n            _addFLU( _FLUBatch );\r\n            isFirstLevelUser[_FLUBatch.user] = true;\r\n            FLUAddress.push(_FLUBatch.user);\r\n            adminFLUAddress[msg.sender].push(_FLUBatch.user);\r\n            if(adminLevel[msg.sender] == 2 || adminLevel[msg.sender] == 3) adminWhitelistCount[msg.sender].fluCount -- ;\r\n    }\r\n    function _changeFLUFee(address _user, int256 _fee) private {\r\n        firstLevelUsers[_user].perTransactionFee = _fee;\r\n    }\r\n    function _changeFLUcurr(address  _user,  bool curr) private {\r\n        firstLevelUsers[_user].isEUR = curr;\r\n    }\r\n    function _changeFLUTransactionCount(address _user,  uint64 _tranCount) private {\r\n        firstLevelUsers[_user].transactionCount = _tranCount;\r\n    }\r\n    function _changeFLUsluCount(address  _user,  uint64 _sluCount) private {\r\n        firstLevelUsers[_user].sluAllowanceCount = _sluCount;\r\n    }\r\n    function changeFLUFee(address _user, int256 _fee) public {\r\n        checkAdmins(adminLevel[msg.sender]);\r\n        _changeFLUFee(_user,_fee );\r\n    }\r\n    function changeFLUscurr(address  _user, bool _curr) public {\r\n        checkAdmins(adminLevel[msg.sender]);\r\n        _changeFLUcurr(_user,_curr);\r\n    }\r\n    function changeFLUTransactionCount(address _user,  uint64 _tranCount) public {\r\n      checkAdmins(adminLevel[msg.sender]);\r\n        _changeFLUTransactionCount(_user,_tranCount);\r\n    }\r\n    function changeFLUsluCount(address  _user,  uint64 _sluCount) public {\r\n      checkAdmins(adminLevel[msg.sender]);\r\n        _changeFLUsluCount(_user,_sluCount);\r\n    }\r\n    function _changeFLUAccessLevel(address _user, uint256 _accessLevel) private {\r\n        firstLevelUsers[_user].accessLevel = _accessLevel;\r\n    } \r\n    function changeFLUAccessLevel(address _user, uint256 _accessLevel)public {\r\n       checkAdmins(adminLevel[msg.sender]);\r\n        _changeFLUAccessLevel(_user,_accessLevel);\r\n    }\r\n    struct FLUBatchUp {\r\n        address[] user ;\r\n        uint64 transactionCount ;\r\n        uint64 sluAllowanceCount ;\r\n        int256 perTransactionFee ;\r\n        uint256 accessLevel;\r\n    }\r\n    function changeFLUBatchDetails(FLUBatchUp memory _FLUBatchUp) public {\r\n         require(_FLUBatchUp.user.length\u003cbatchLimit,\"na\");\r\n         checkAdmins(adminLevel[msg.sender]);\r\n            \r\n        for(uint i=0;i\u003c_FLUBatchUp.user.length;i++){\r\n          address _FLUuser = _FLUBatchUp.user[i];\r\n          firstLevelUsers[_FLUuser].transactionCount = _FLUBatchUp.transactionCount;\r\n          firstLevelUsers[_FLUuser].sluAllowanceCount = _FLUBatchUp.sluAllowanceCount;\r\n          firstLevelUsers[_FLUuser].perTransactionFee = _FLUBatchUp.perTransactionFee;\r\n          firstLevelUsers[_FLUuser].accessLevel = _FLUBatchUp.accessLevel;\r\n          }\r\n        }\r\n    \r\n    function addFLUBatch(FLUBatch [] memory _FLUBatch ) public {\r\n    require(adminLevel[msg.sender]==1 || adminLevel[msg.sender]==2 || adminLevel[msg.sender]==3,\"na\");\r\n     require(_FLUBatch.length\u003cbatchLimit, \"LE\");\r\n     for(uint i = 0; i\u003c_FLUBatch.length;i++ ){\r\n         address _user = _FLUBatch[i].user;\r\n         if(!isFirstLevelUser[_user]){\r\n            _addFLU(_FLUBatch[i]);\r\n            isFirstLevelUser[_user] = true;\r\n            FLUAddress.push(_user);\r\n            adminFLUAddress[msg.sender].push(_user);\r\n         }\r\n         if(adminLevel[msg.sender]== 2 || adminLevel[msg.sender]== 3) adminWhitelistCount[msg.sender].fluCount -- ;\r\n     }   \r\n    }\r\n    \r\n    function whitelistSecondLevelUser(address slUser_) public {\r\n        require(isFirstLevelUser[msg.sender], \"not first level user\");\r\n        require(!secondLevelUsers[slUser_][msg.sender], \"user already exist\");\r\n        require(firstLevelUsers[msg.sender].sluAllowanceCount \u003e 0 , \"not enough slu left\");\r\n        secondLevelUsers[slUser_][msg.sender] = true; \r\n        firstLevelUsers[msg.sender].usersWhitelisted.push(slUser_);\r\n        firstLevelUsers[msg.sender].sluAllowanceCount = firstLevelUsers[msg.sender].sluAllowanceCount - 1;\r\n    }\r\n    \r\n    struct Doc {\r\n        string sha256Hash ;\r\n        string ipfsHash ;\r\n        string fileName ;\r\n        address _sharedAddress ;\r\n        string _sessionKey ;\r\n    }\r\n    function _createDoc ( Doc memory _doc) private view returns (DocData memory ){\r\n       return DocData({\r\n          time : block.timestamp,\r\n          sha256Hash : _doc.sha256Hash,\r\n          ipfsHash : _doc.ipfsHash,\r\n          fileName : _doc.fileName,\r\n          sessionKey : _doc._sessionKey, \r\n          creator : msg.sender,\r\n          user :_doc._sharedAddress\r\n        });\r\n    }\r\n    function createDocument(Doc memory _doc) public payable returns (bool) {\r\n        require(isFirstLevelUser[msg.sender],\"not FLU\");\r\n        require(firstLevelUsers[msg.sender].transactionCount \u003e 0, \"not etl\");\r\n        require(int(msg.value)\u003e=calculateFeeETH(firstLevelUsers[msg.sender].perTransactionFee,firstLevelUsers[msg.sender].isEUR),\"pay assigned transaction fee\");\r\n       if(firstLevelUsers[msg.sender].accessLevel == 1){\r\n           bytes memory bIPFSHash = bytes(_doc.ipfsHash);\r\n           require(bIPFSHash.length == 0  , \"FNA\" );\r\n           require(_doc._sharedAddress == address(0),\"FNA\");\r\n       } else if (firstLevelUsers[msg.sender].accessLevel == 2){\r\n           require(_doc._sharedAddress == address(0) , \"FNA\" );\r\n       }\r\n        // DocData memory newDocData = _createDoc(_doc);\r\n        if(_doc._sharedAddress!= address(0)){\r\n            require(firstLevelUsers[msg.sender].sluAllowanceCount \u003e 0 , \"na slucount left\");\r\n            documents[_doc._sharedAddress].push(_createDoc(_doc));\r\n            firstLevelUsers[msg.sender].usersWhitelisted.push(_doc._sharedAddress);\r\n            firstLevelUsers[msg.sender].sluAllowanceCount --;\r\n        }\r\n        documents[msg.sender].push(_createDoc(_doc));\r\n        firstLevelUsers[msg.sender].transactionCount -- ;\r\n        owner().transfer(msg.value);\r\n        return true;\r\n\r\n    }\r\n    function createDocumentBatch(Doc [] memory _batchDoc) public payable returns (bool) {\r\n        require(_batchDoc.length\u003cbatchLimit, \"LE\");\r\n        require(firstLevelUsers[msg.sender].accessLevel == 4, \"FNA\");\r\n        require(isFirstLevelUser[msg.sender],\"not flu\");\r\n        require(firstLevelUsers[msg.sender].transactionCount \u003e 0, \"not enough transactions left\");\r\n        require(int(msg.value)\u003e=calculateFeeETH(firstLevelUsers[msg.sender].perTransactionFee,firstLevelUsers[msg.sender].isEUR),\"pay assigned transaction fee\");\r\n     for(uint i =0 ;i \u003c _batchDoc.length ;i++){\r\n        require(firstLevelUsers[msg.sender].transactionCount \u003e 0, \"not enough transactions left\");\r\n         documents[msg.sender].push(_createDoc(_batchDoc[i]));\r\n        if(_batchDoc[i]._sharedAddress!= address(0)){\r\n            require(firstLevelUsers[msg.sender].sluAllowanceCount \u003e 0 , \"not enough slua left\");\r\n            documents[_batchDoc[i]._sharedAddress].push(_createDoc(_batchDoc[i]));\r\n            firstLevelUsers[msg.sender].usersWhitelisted.push(_batchDoc[i]._sharedAddress);\r\n            firstLevelUsers[msg.sender].sluAllowanceCount --;\r\n        }\r\n        }\r\n        firstLevelUsers[msg.sender].transactionCount -- ;\r\n        owner().transfer(msg.value);\r\n        return true;\r\n    }\r\n     \r\n     function shareDocument( uint256 _id , address sluAddress , string memory _sessionKey) public payable returns (bool) {\r\n         require(isFirstLevelUser[msg.sender],\"not first level user\");\r\n         require(firstLevelUsers[msg.sender].transactionCount \u003e 0, \"not enough transactions left\");\r\n         require(int(msg.value)\u003e=calculateFeeETH(firstLevelUsers[msg.sender].perTransactionFee,firstLevelUsers[msg.sender].isEUR),\"pay assigned transaction fee\");\r\n         require(firstLevelUsers[msg.sender].accessLevel \u003e 2, \"FNA\");\r\n         documents[sluAddress].push(documents[msg.sender][_id]);\r\n         documents[sluAddress][_id].sessionKey = _sessionKey;\r\n         uint c =0;\r\n         for(uint i = 0 ; i \u003c firstLevelUsers[msg.sender].usersWhitelisted.length; i++ ){\r\n             if(sluAddress == firstLevelUsers[msg.sender].usersWhitelisted[i]){\r\n                 c+=1;\r\n             }\r\n         }\r\n         if(c==1){\r\n         firstLevelUsers[msg.sender].usersWhitelisted.push(sluAddress);\r\n         }\r\n         firstLevelUsers[msg.sender].transactionCount -- ;\r\n         owner().transfer(msg.value);\r\n         return true;\r\n     }\r\n     \r\n    function getDocs() public view returns( DocData  [] memory){\r\n        return documents[msg.sender];\r\n    }\r\n    function adminCounts() public view returns( AdminWhitelistCount memory){\r\n        return adminWhitelistCount[msg.sender];\r\n    }\r\n    function disableFLU(address _user) public {\r\n        require(adminLevel[msg.sender]==1 || adminLevel[msg.sender]==2 || adminLevel[msg.sender]==3);\r\n        require(isFirstLevelUser[_user],\"not flu\");\r\n        isFirstLevelUser[_user] = false;\r\n    }\r\n    \r\n    function calculateFeeETH(int256 _currfee, bool _curr) public view returns (int){\r\n        return (_currfee * (10**18))/(getPrices(_curr));\r\n        // return (_currfee*(10**26))/();\r\n    }\r\n    function fluDetails(address _fluAddress) public view returns (FirstLevelUsers memory ){\r\n        return firstLevelUsers[_fluAddress];\r\n    }\r\n    function getFLUAddress() public view returns (address [] memory ){\r\n        require (adminLevel[msg.sender] == 1);\r\n        return FLUAddress;\r\n    }\r\n    function addAdminPlusFlu(address _newAddress , uint256 level , uint256 _subAdminCount,uint256 _fluCount,FLUBatch  memory _FLUBatch  )public returns (bool){\r\n        addFirstLevelUser(_FLUBatch);\r\n        addAdminLevel(_newAddress , level , _subAdminCount,_fluCount);\r\n        return true;\r\n    }\r\n    function addAdminLevel (address _newAddress , uint256 level , uint256 _subAdminCount,uint256 _fluCount ) public {\r\n        checkAdmins(adminLevel[msg.sender]);\r\n      if(adminLevel[msg.sender] == 2 \u0026\u0026 (level == 1 || level == 2)) revert ();\r\n        adminLevel[_newAddress] = level;\r\n        changeAdminWhitelistCount(_newAddress, _subAdminCount,_fluCount);\r\n        adminWhitelistCount[msg.sender].adminsWhiteListed.push(_newAddress);\r\n        if(adminLevel[msg.sender]== 2) adminWhitelistCount[msg.sender].subAdminCount --;\r\n    }\r\n    function removeAdminLevel (address _newAddress ) public {\r\n    require(adminLevel[msg.sender]==1 || adminLevel[msg.sender]==2,\"FNA\");\r\n      if(adminLevel[msg.sender] == 2 \u0026\u0026 (adminLevel[_newAddress] == 1 || adminLevel[_newAddress] == 2)) revert ();\r\n        adminLevel[_newAddress] = 0;\r\n    }\r\n    function changeAdminWhitelistCount(address _adminAdress ,uint256 _subAdminCount,uint256 _fluCount   ) public {\r\n        checkAdmins(adminLevel[msg.sender]);\r\n        if(adminLevel[msg.sender]==2 \u0026\u0026 (adminLevel[_adminAdress] == 1 || adminLevel[_adminAdress] == 2)) revert();\r\n        adminWhitelistCount[_adminAdress].subAdminCount = adminLevel[msg.sender] == 2?0:_subAdminCount;\r\n        adminWhitelistCount[_adminAdress].fluCount = _fluCount;\r\n    }\r\n    function changeBatchLimit (uint256 _limit) public {\r\n        require(adminLevel[msg.sender]==1);\r\n        batchLimit = _limit;\r\n    }\r\n    function getFLUAddress2()public view returns (address [] memory ){\r\n         if(adminLevel[msg.sender] != 1 \u0026\u0026 adminLevel[msg.sender] != 2 \u0026\u0026 adminLevel[msg.sender] != 3)  revert();\r\n         return adminFLUAddress[msg.sender];\r\n    }\r\n}"}}