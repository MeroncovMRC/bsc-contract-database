{"BEP20.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\nimport \"./IBEP20.sol\";\r\nimport \"./Context.sol\";\r\nimport \"./Ownable.sol\";\r\n\r\n/*@dev Implementation of the {IBEP20} interface based on OpenZeppelin ERC20 Contract.*/\r\n\r\ncontract BEP20 is Context, IBEP20, Ownable {\r\n    mapping(address =\u003e uint256) private _balances;\r\n\r\n    mapping(address =\u003e mapping(address =\u003e uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner_ = _msgSender();\r\n        _transfer(owner_, to, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner_, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner_][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        address owner_ = _msgSender();\r\n        _approve(owner_, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function getOwner() external view returns (address) {\r\n        return owner();\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        address owner_ = _msgSender();\r\n        _approve(owner_, spender, allowance(owner_, spender) + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        address owner_ = _msgSender();\r\n        uint256 currentAllowance = allowance(owner_, spender);\r\n        require(currentAllowance \u003e= subtractedValue, \"BEP20: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(owner_, spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(from != address(0), \"BEP20: transfer from the zero address\");\r\n        require(to != address(0), \"BEP20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, amount);\r\n\r\n        uint256 fromBalance = _balances[from];\r\n        require(fromBalance \u003e= amount, \"BEP20: transfer amount exceeds balance\");\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\r\n            // decrementing then incrementing.\r\n            _balances[to] += amount;\r\n        }\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        _afterTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"BEP20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        unchecked {\r\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\r\n            _balances[account] += amount;\r\n        }\r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    function _approve(\r\n        address owner_,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner_ != address(0), \"BEP20: approve from the zero address\");\r\n        require(spender != address(0), \"BEP20: approve to the zero address\");\r\n\r\n        _allowances[owner_][spender] = amount;\r\n        emit Approval(owner_, spender, amount);\r\n    }\r\n\r\n    function _spendAllowance(\r\n        address owner_,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        uint256 currentAllowance = allowance(owner_, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance \u003e= amount, \"BEP20: insufficient allowance\");\r\n            unchecked {\r\n                _approve(owner_, spender, currentAllowance - amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}"},"Context.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}"},"IBEP20.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\ninterface IBEP20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the token decimals.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Returns the token symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the bep token owner.\r\n     */\r\n    function getOwner() external view returns (address);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"},"KvoltzVesting.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.17;\r\n\r\nimport \"./BEP20.sol\";\r\n\r\ncontract KvoltzVesting is Ownable{\r\n\r\n    BEP20 private kvoltzToken;\r\n    BEP20 private busdToken;\r\n    address constant BUSD_ADDRESS = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\r\n\r\n    mapping(address =\u003e uint) private seedSaleTokens;\r\n    mapping(address =\u003e uint) private seedSaleTokensReceived;\r\n    mapping(address =\u003e uint) private privateSaleTokens;\r\n    mapping(address =\u003e uint) private privateSaleTokensReceived;\r\n    mapping(address =\u003e uint) private advisorsTokens;\r\n    mapping(address =\u003e uint) private advisorsTokensReceived;\r\n    mapping(address =\u003e uint) private airdropTokens;\r\n    mapping(address =\u003e uint) private airdropTokensReceived;\r\n    mapping(address =\u003e bool) private isAdmin;\r\n\r\n    address[] private seedSaleBuyers;\r\n    address[] private privateSaleBuyers;\r\n    address[] private advisors;\r\n    address[] private airdrop;\r\n    address immutable private mainWallet;\r\n\r\n    bool private seedSaleOpen;\r\n    bool private privateSaleOpen;\r\n    bool private tgeSet;\r\n\r\n    uint private tgeTimestamp;\r\n\r\n    uint constant ONE_MONTH_IN_SECONDS = 2592000;\r\n\r\n    uint constant SEED_TOKENS = 8000000 ether;\r\n    uint constant SEED_CLIFF = 90 days;\r\n    uint constant SEED_VESTING = 950; //9.5%\r\n    uint constant SEED_TGE = 500; //5%\r\n\r\n    uint constant PRIVATE_TOKENS = 10000000 ether;\r\n    uint constant PRIVATE_CLIFF = 60 days;\r\n    uint constant PRIVATE_VESTING = 925; //9.25%\r\n    uint constant PRIVATE_TGE = 750; //7.5%\r\n\r\n    uint constant ADVISORS_TOKENS = 3000000 ether;\r\n    uint constant ADVISORS_CLIFF = 90 days;\r\n    uint constant ADVISORS_VESTING = 950; //9.5%\r\n    uint constant ADVISORS_TGE = 500; //5%\r\n\r\n    uint constant AIRDROP_TOKENS = 1000000 ether;\r\n    uint constant AIRDROP_CLIFF = 120 days;\r\n    uint constant AIRDROP_VESTING = 950; //9.5%\r\n    uint constant AIRDROP_TGE = 500; //5%\r\n\r\n    event KvoltzAddressUpdated(address _kvoltzTokenAddress);\r\n    event BUSDAddressUpdated(address _busdTokenAddress);\r\n    event AdminStatusSet(address _address, bool _status);\r\n    event SeedSalePurchased(uint _amount, address _address);\r\n    event PrivateSalePurchased(uint _amount, address _address);\r\n    event AdvisorsAdded(uint[] _amountKVZ, address[] _address);\r\n    event AirdropAdded(uint[] _amountKVZ, address[] _address);\r\n    event SeedSaleStatusChanged(bool _bool);\r\n    event PrivateSaleStatusChanged(bool _bool);\r\n    event TokenGenerationEventStarted();\r\n    event TokensDistributed();\r\n\r\n    constructor(address _mainWallet){\r\n        busdToken = BEP20(BUSD_ADDRESS);\r\n        seedSaleOpen = false;\r\n        privateSaleOpen = false;\r\n        mainWallet = _mainWallet;\r\n        tgeSet = false;\r\n        isAdmin[msg.sender] = true;\r\n    }\r\n\r\n    /*  Sets the token that will be vested by this Smart Contract. \r\n        It should be called as soon as the KVOLTZ token is deployed.\r\n    */\r\n\r\n    function setKvoltzTokenAddress(address _kvoltzTokenAddress) external onlyOwner{\r\n        kvoltzToken = BEP20(_kvoltzTokenAddress);\r\n        emit KvoltzAddressUpdated(_kvoltzTokenAddress);\r\n    }\r\n\r\n    /*  Sets the token that will used to buy the Seed/Private Sale.\r\n        This token is set to BUSD by default, so it might not be necessary.\r\n    */\r\n\r\n    function setBUSDTokenAddress(address _busdTokenAddress) external onlyOwner{\r\n        busdToken = BEP20(_busdTokenAddress);\r\n        emit BUSDAddressUpdated(_busdTokenAddress);\r\n    }\r\n\r\n    /*  Gives Admin privileges to a wallet.*/\r\n\r\n    function setAdmin(address _address, bool _status) external onlyOwner{\r\n        isAdmin[_address] = _status;\r\n        emit AdminStatusSet(_address, _status);\r\n    }\r\n\r\n    /* Returns the total amount of active vesting tokens in the Seed Sale.*/\r\n\r\n    function getSeedTokens() public view returns(uint seedTokensSold){\r\n        uint seedTokensSum = 0;\r\n        for(uint i = 0; i \u003c seedSaleBuyers.length; i++){\r\n            address receiverSeed = seedSaleBuyers[i];\r\n            seedTokensSum += seedSaleTokens[receiverSeed];\r\n        }\r\n        seedTokensSold = seedTokensSum;\r\n    }\r\n\r\n    /* Returns the total amount of active vesting tokens in the Private Sale.*/\r\n\r\n    function getPrivateTokens() public view returns(uint privateTokensSold){\r\n        uint privateTokensSum = 0;\r\n        for(uint i = 0; i \u003c privateSaleBuyers.length; i++){\r\n            address receiverPrivate = privateSaleBuyers[i];\r\n            privateTokensSum += privateSaleTokens[receiverPrivate];\r\n        }\r\n        privateTokensSold = privateTokensSum;\r\n    }\r\n\r\n    /* Returns the total amount of active vesting tokens for advisors.*/\r\n\r\n    function getAdvisorsTokens() public view returns(uint advisorsTokensSold){\r\n        uint advisorsTokensSum = 0;\r\n        for(uint i = 0; i \u003c advisors.length; i++){\r\n            address receiveradvisors = advisors[i];\r\n            advisorsTokensSum += advisorsTokens[receiveradvisors];\r\n        }\r\n        advisorsTokensSold = advisorsTokensSum;\r\n    }\r\n\r\n    /* Returns the total amount of active vesting tokens in the Airdrop.*/\r\n\r\n    function getAirdropTokens() public view returns(uint airdropTokensSold){\r\n        uint airdropTokensSum = 0;\r\n        for(uint i = 0; i \u003c airdrop.length; i++){\r\n            address receiverairdrop = airdrop[i];\r\n            airdropTokensSum += airdropTokens[receiverairdrop];\r\n        }\r\n        airdropTokensSold = airdropTokensSum;\r\n    }\r\n\r\n    /*  Allows the caller to buy Seed Sale tokens.\r\n        Minimum amount is 5000 BUSD by default.\r\n    */\r\n\r\n    function buySeedSale(uint _amount) external{\r\n        require(seedSaleOpen == true, \"Seed Sale is closed.\");\r\n        require( _amount \u003e= 5000 * 1 ether, \"Seed Sale minimum amount is 5000 BUSD.\");\r\n        require(getSeedTokens() + _amount \u003c= SEED_TOKENS, \"Seed Sale cap reached.\");\r\n        busdToken.transferFrom(msg.sender, mainWallet, _amount);\r\n        if(seedSaleTokens[msg.sender] == 0){\r\n            seedSaleBuyers.push(msg.sender);\r\n        }\r\n        seedSaleTokens[msg.sender] += _amount * 100 / 5; // Price: 0,05 BUSD\r\n        emit SeedSalePurchased(_amount, msg.sender);\r\n    }\r\n\r\n    /*  Allows the caller to buy Private Sale tokens.\r\n        Minimum amount is 100 BUSD by default.\r\n    */\r\n\r\n    function buyPrivateSale(uint _amount) external{\r\n        require(privateSaleOpen == true, \"Seed Sale is closed.\");\r\n        require( _amount \u003e= 100 * 1 ether, \"Private Sale minimum amount is 100 BUSD.\");\r\n        require(getPrivateTokens() + _amount \u003c= PRIVATE_TOKENS, \"Private Sale cap reached.\");\r\n        busdToken.transferFrom(msg.sender, mainWallet, _amount);\r\n        if(privateSaleTokens[msg.sender] == 0){\r\n            privateSaleBuyers.push(msg.sender);\r\n        }\r\n        privateSaleTokens[msg.sender] += _amount * 100 / 6; // Price: 0,06 BUSD\r\n        emit PrivateSalePurchased(_amount, msg.sender);\r\n    }\r\n\r\n    /*  Allows the admin to allocate Seed Sale tokens to a wallet.\r\n        Minimum amount is 5000 BUSD by default.\r\n    */\r\n\r\n    function buySeedSalePix(uint _amount, address _address) external{\r\n        require(isAdmin[msg.sender], \"Caller is not an Admin\");\r\n        require(seedSaleOpen == true, \"Seed Sale is closed.\");\r\n        require( _amount \u003e= 5000 * 1 ether, \"Seed Sale minimum amount is 5000 BUSD.\");\r\n        require(getSeedTokens() + _amount \u003c= SEED_TOKENS, \"Seed Sale cap reached.\");\r\n        if(seedSaleTokens[_address] == 0){\r\n            seedSaleBuyers.push(_address);\r\n        }\r\n        seedSaleTokens[_address] += _amount * 100 / 5;\r\n        emit SeedSalePurchased(_amount, _address);\r\n    }\r\n\r\n    /*  Allows the admin to allocate Private Sale tokens to a wallet.\r\n        Minimum amount is 100 BUSD by default.\r\n    */\r\n\r\n    function buyPrivateSalePix(uint _amount, address _address) external{\r\n        require(isAdmin[msg.sender], \"Caller is not an Admin\");\r\n        require(privateSaleOpen == true, \"Private Sale is closed.\");\r\n        require( _amount \u003e= 100 * 1 ether, \"Private Sale minimum amount is 100 BUSD.\");\r\n        require(getPrivateTokens() + _amount \u003c= PRIVATE_TOKENS, \"Private Sale cap reached.\");\r\n        if(privateSaleTokens[_address] == 0){\r\n            privateSaleBuyers.push(_address);\r\n        }\r\n        privateSaleTokens[_address] += _amount * 100 / 6;\r\n        emit PrivateSalePurchased(_amount, _address);\r\n    }\r\n\r\n    /*  Allows the admin to allocate Advisors tokens to a wallet.\r\n        Arguments are arrays to allow multiple inclusions in a single call.\r\n    */\r\n\r\n    function setAdvisor(uint[] calldata _amountKVZ, address[] calldata _address) external onlyOwner{\r\n        require(_amountKVZ.length == _address.length, \"Each Address must have an amount.\");\r\n        uint tokensSum = 0;\r\n        for(uint i = 0; i \u003c _amountKVZ.length; i++){\r\n            if(advisorsTokens[_address[i]] == 0){\r\n                advisors.push(_address[i]);\r\n            }\r\n            advisorsTokens[_address[i]] += _amountKVZ[i];\r\n            tokensSum += _amountKVZ[i];\r\n        }\r\n        require(getAdvisorsTokens() + tokensSum \u003c= ADVISORS_TOKENS, \"Advisors cap reached.\");\r\n        emit AdvisorsAdded(_amountKVZ, _address);\r\n    }\r\n\r\n    /*  Allows the admin to allocate Airdrop tokens to a wallet.\r\n        Arguments are arrays to allow multiple inclusions in a single call.\r\n    */\r\n\r\n    function setAirdrop(uint[] calldata _amountKVZ, address[] calldata _address) external onlyOwner{\r\n        require(_amountKVZ.length == _address.length, \"Each Address must have an amount.\");\r\n        uint tokensSum = 0;\r\n        for(uint i = 0; i \u003c _amountKVZ.length; i++){\r\n            if(advisorsTokens[_address[i]] == 0){\r\n                airdrop.push(_address[i]);\r\n            }\r\n            airdropTokens[_address[i]] += _amountKVZ[i];\r\n            tokensSum += _amountKVZ[i];\r\n        }\r\n        require(getAirdropTokens() + tokensSum \u003c= AIRDROP_TOKENS, \"Airdrop cap reached.\");\r\n        emit AirdropAdded(_amountKVZ, _address);\r\n    }\r\n\r\n    /* Allows to Open and Close the Seed Sale.*/\r\n\r\n    function setSeedSaleStatus(bool _bool) external onlyOwner{\r\n        seedSaleOpen = _bool;\r\n        emit SeedSaleStatusChanged(_bool);\r\n    }\r\n\r\n    /* Allows to Open and Close the Private Sale.*/\r\n\r\n    function setPrivateSaleStatus(bool _bool) external onlyOwner{\r\n        privateSaleOpen = _bool;\r\n        emit PrivateSaleStatusChanged(_bool);\r\n    }\r\n\r\n    /* Returns the remaining amount of Seed Sale vesting tokens of a wallet.*/\r\n\r\n    function getAddressSeedSaleTokens(address _address) public view returns(uint){\r\n        return (seedSaleTokens[_address] - seedSaleTokensReceived[_address]);\r\n    }\r\n\r\n    /* Returns the remaining amount of Private Sale vesting tokens of a wallet.*/\r\n\r\n    function getAddressPrivateSaleTokens(address _address) public view returns(uint){\r\n        return (privateSaleTokens[_address] - privateSaleTokensReceived[_address]);\r\n    }\r\n\r\n    /* Returns the remaining amount of Advisors vesting tokens of a wallet.*/\r\n\r\n    function getAdvisorsTokens(address _address) public view returns(uint){\r\n        return (advisorsTokens[_address] - advisorsTokensReceived[_address]);\r\n    }\r\n\r\n    /* Returns the remaining amount of Airdrop vesting tokens of a wallet.*/\r\n\r\n    function getAirdropTokens(address _address) public view returns(uint){\r\n        return (airdropTokens[_address] - airdropTokensReceived[_address]);\r\n    }\r\n\r\n    /*  Sets the starting timestamp for the vesting period.\r\n        Also distributes the TGE tokens percentage.\r\n    */\r\n\r\n    function tokenGenerationEvent() external onlyOwner{\r\n        require(!tgeSet, \"TGE already set.\");\r\n        tgeTimestamp = block.timestamp;\r\n        for(uint i = 0; i \u003c seedSaleBuyers.length; i++){\r\n            address receiverSeed = seedSaleBuyers[i];\r\n            uint availableTokensSeed = seedSaleTokens[receiverSeed]*SEED_TGE/10000;\r\n            kvoltzToken.transfer(receiverSeed, availableTokensSeed);\r\n        }\r\n        for(uint i = 0; i \u003c privateSaleBuyers.length; i++){\r\n            address receiverPrivate = privateSaleBuyers[i];\r\n            uint availableTokensPrivate = privateSaleTokens[receiverPrivate]*PRIVATE_TGE/10000;\r\n            kvoltzToken.transfer(receiverPrivate, availableTokensPrivate);\r\n        }\r\n        for(uint i = 0; i \u003c advisors.length; i++){\r\n            address receiverAdvisors = advisors[i];\r\n            uint availableTokensAdvisors = advisorsTokens[receiverAdvisors]*ADVISORS_TGE/10000;\r\n            kvoltzToken.transfer(receiverAdvisors, availableTokensAdvisors);\r\n        }\r\n        for(uint i = 0; i \u003c airdrop.length; i++){\r\n            address receiverAirdrop = airdrop[i];\r\n            uint availableTokensAirdrop = airdropTokens[receiverAirdrop]*AIRDROP_TGE/10000;\r\n            kvoltzToken.transfer(receiverAirdrop, availableTokensAirdrop);\r\n        }\r\n        tgeSet = true;\r\n        emit TokenGenerationEventStarted();\r\n    }\r\n\r\n    /*  Returns the total amount of tokens that can currently be distributed.\r\n        Should only be called after TGE is set, but can be called before to return the total amount of tokens that will be distributed.\r\n    */\r\n\r\n    function getAvailableTokens() external view returns(\r\n        uint currentSeedSaleTokens, \r\n        uint currentPrivateSaleTokens, \r\n        uint currentAdvisorsTokens,\r\n        uint currentAirdropTokens){\r\n        uint currentTime = block.timestamp - tgeTimestamp;\r\n        if(currentTime \u003e SEED_CLIFF){\r\n            uint seedVestingTime = currentTime - SEED_CLIFF;\r\n            uint availableParcelsSeed = seedVestingTime/ONE_MONTH_IN_SECONDS + 1; \r\n            if(availableParcelsSeed\u003e10){\r\n                availableParcelsSeed = 10;\r\n            }\r\n            for(uint i = 0; i \u003c seedSaleBuyers.length; i++){\r\n                address receiverSeed = seedSaleBuyers[i];\r\n                uint availableTokensSeed = seedSaleTokens[receiverSeed]*SEED_VESTING*availableParcelsSeed/10000 - seedSaleTokensReceived[receiverSeed];\r\n                currentSeedSaleTokens = availableTokensSeed;\r\n            }\r\n        }\r\n        if(currentTime \u003e PRIVATE_CLIFF){\r\n            uint privateVestingTime = currentTime - PRIVATE_CLIFF;\r\n            uint availableParcelsPrivate = privateVestingTime/ONE_MONTH_IN_SECONDS + 1; \r\n            if(availableParcelsPrivate\u003e10){\r\n                availableParcelsPrivate = 10;\r\n            }\r\n            for(uint i = 0; i \u003c privateSaleBuyers.length; i++){\r\n                address receiverPrivate = privateSaleBuyers[i];\r\n                uint availableTokensPrivate = privateSaleTokens[receiverPrivate]*PRIVATE_VESTING*availableParcelsPrivate/10000 - privateSaleTokensReceived[receiverPrivate];\r\n                currentPrivateSaleTokens = availableTokensPrivate;\r\n            }\r\n        }\r\n        if(currentTime \u003e ADVISORS_CLIFF){\r\n            uint advisorVestingTime = currentTime - ADVISORS_CLIFF;\r\n            uint availableParcelsAdvisors = advisorVestingTime/ONE_MONTH_IN_SECONDS + 1; \r\n            if(availableParcelsAdvisors\u003e10){\r\n                availableParcelsAdvisors = 10;\r\n            }\r\n            for(uint i = 0; i \u003c advisors.length; i++){\r\n                address receiverAdvisors = advisors[i];\r\n                uint availableTokensAdvisors = advisorsTokens[receiverAdvisors]*ADVISORS_VESTING*availableParcelsAdvisors/10000 - advisorsTokensReceived[receiverAdvisors];\r\n                currentAdvisorsTokens = availableTokensAdvisors;\r\n            }\r\n        }\r\n        if(currentTime \u003e AIRDROP_CLIFF){\r\n            uint airdropVestingTime = currentTime - AIRDROP_CLIFF;\r\n            uint availableParcelsAirdrop = airdropVestingTime/ONE_MONTH_IN_SECONDS + 1; \r\n            if(availableParcelsAirdrop\u003e10){\r\n                availableParcelsAirdrop = 10;\r\n            }\r\n            for(uint i = 0; i \u003c airdrop.length; i++){\r\n                address receiverAirdrop = airdrop[i];\r\n                uint availableTokensAirdrop = airdropTokens[receiverAirdrop]*AIRDROP_VESTING*availableParcelsAirdrop/10000 - airdropTokensReceived[receiverAirdrop];\r\n                currentAirdropTokens = availableTokensAirdrop;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    /*  Allows the admin to distribute all available vesting tokens.\r\n        Should be called monthly. \r\n    */\r\n\r\n    function distributeTokens() external{\r\n        require(isAdmin[msg.sender], \"Caller is not an Admin\");\r\n        require(tgeSet, \"Token Generation Event timestamp is not set.\");\r\n        uint currentTime = block.timestamp - tgeTimestamp;\r\n        if(currentTime \u003e SEED_CLIFF){\r\n            uint seedVestingTime = currentTime - SEED_CLIFF;\r\n            uint availableParcelsSeed = seedVestingTime/ONE_MONTH_IN_SECONDS + 1; \r\n            if(availableParcelsSeed\u003e10){\r\n                availableParcelsSeed = 10;\r\n            }\r\n            for(uint i = 0; i \u003c seedSaleBuyers.length; i++){\r\n                address receiver = seedSaleBuyers[i];\r\n                uint availableTokensSeed = seedSaleTokens[receiver]*SEED_VESTING*availableParcelsSeed/10000 - seedSaleTokensReceived[receiver];\r\n                kvoltzToken.transfer(receiver, availableTokensSeed);\r\n                seedSaleTokensReceived[receiver] += availableTokensSeed;\r\n            }\r\n        }\r\n        if(currentTime \u003e PRIVATE_CLIFF){\r\n            uint privateVestingTime = currentTime - PRIVATE_CLIFF;\r\n            uint availableParcelsPrivate = privateVestingTime/ONE_MONTH_IN_SECONDS + 1; \r\n            if(availableParcelsPrivate\u003e10){\r\n                availableParcelsPrivate = 10;\r\n            }\r\n            for(uint i = 0; i \u003c privateSaleBuyers.length; i++){\r\n                address receiver = privateSaleBuyers[i];\r\n                uint availableTokensPrivate = privateSaleTokens[receiver]*PRIVATE_VESTING*availableParcelsPrivate/10000 - privateSaleTokensReceived[receiver];\r\n                kvoltzToken.transfer(receiver, availableTokensPrivate);\r\n                privateSaleTokensReceived[receiver] += availableTokensPrivate;\r\n            }\r\n        }\r\n        if(currentTime \u003e ADVISORS_CLIFF){\r\n            uint advisorsVestingTime = currentTime - ADVISORS_CLIFF;\r\n            uint availableParcelsAdvisors = advisorsVestingTime/ONE_MONTH_IN_SECONDS + 1; \r\n            if(availableParcelsAdvisors\u003e10){\r\n                availableParcelsAdvisors = 10;\r\n            }\r\n            for(uint i = 0; i \u003c advisors.length; i++){\r\n                address receiverAdvisors = advisors[i];\r\n                uint availableTokensAdvisors = advisorsTokens[receiverAdvisors]*ADVISORS_VESTING*availableParcelsAdvisors/10000 - advisorsTokensReceived[receiverAdvisors];\r\n                kvoltzToken.transfer(receiverAdvisors, availableTokensAdvisors);\r\n                advisorsTokensReceived[receiverAdvisors] += availableTokensAdvisors;\r\n            }\r\n        }\r\n        if(currentTime \u003e AIRDROP_CLIFF){\r\n            uint airdropVestingTime = currentTime - AIRDROP_CLIFF;\r\n            uint availableParcelsAirdrop = airdropVestingTime/ONE_MONTH_IN_SECONDS + 1; \r\n            if(availableParcelsAirdrop\u003e10){\r\n                availableParcelsAirdrop = 10;\r\n            }\r\n            for(uint i = 0; i \u003c airdrop.length; i++){\r\n                address receiverAirdrop = airdrop[i];\r\n                uint availableTokensAirdrop = airdropTokens[receiverAirdrop]*AIRDROP_VESTING*availableParcelsAirdrop/10000 - airdropTokensReceived[receiverAirdrop];\r\n                kvoltzToken.transfer(receiverAirdrop, availableTokensAirdrop);\r\n                airdropTokensReceived[receiverAirdrop] += availableTokensAirdrop;\r\n            }\r\n        }\r\n        emit TokensDistributed();\r\n        \r\n    }\r\n\r\n    /*  Allows the Owner to withdraw BUSD tokens from this contract.\r\n        Should only be necessary if BUSD is mistakenly sent directly to the contract.\r\n    */\r\n\r\n    function withdraw() external onlyOwner{\r\n        uint balance__ = busdToken.balanceOf(address(this));\r\n        busdToken.transfer(msg.sender, balance__);\r\n    }\r\n}"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./Context.sol\";\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}"}}