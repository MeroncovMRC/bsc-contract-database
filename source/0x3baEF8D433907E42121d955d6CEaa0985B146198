{"Address.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\u0027s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) private pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"},"ERC1155MetaPackedBalance.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity \u003e=0.7.4 \u003c=0.8.9;\npragma experimental ABIEncoderV2;\n\n\nimport \"./ERC1155PackedBalance.sol\";\nimport \"./IERC20.sol\";\nimport \"./IERC1155.sol\";\nimport \"./LibBytes.sol\";\nimport \"./SignatureValidator.sol\";\n\n\n/**\n** @dev ERC-1155 with native MetaTransaction methods.\n**      These additional functions allow users to presign function calls and\n**      allow third parties to execute these on their behalf.\n**/\nabstract contract ERC1155MetaPackedBalance is ERC1155PackedBalance, SignatureValidator {\n    using LibBytes for bytes;\n\n\n    /*════════════oooooOooooo═════════════╗\n    ║█~~~~~~~~~~~~ VARIABLES ~~~~~~~~~~~~█║\n    ╚════════════════════════════════════*/\n\n    /**\n    ** Gas Receipt\n    **   feeTokenData : (bool, address, ?unit256)\n    **     1st element should be the address of the token\n    **     2nd argument (if ERC-1155) should be the ID of the token\n    **     Last element should be a 0x0 if ERC-20 and 0x1 for ERC-1155\n    **/\n    struct GasReceipt {\n        uint256 gasFee;           // Fixed cost for the tx\n        uint256 gasLimitCallback; // Maximum amount of gas the callback in transfer functions can use\n        address feeRecipient;     // Address to send payment to\n        bytes   feeTokenData;       // Data for token to pay for gas\n    }\n\n    /** Which token standard is used to pay gas fee */\n    enum FeeTokenType {\n        ERC1155,    // 0x00, ERC-1155 token - DEFAULT\n        ERC20,      // 0x01, ERC-20 token\n        NTypes      // 0x02, number of signature types. Always leave at end.\n    }\n\n    /** Signature nonce per address */\n    mapping (address =\u003e uint256) internal nonces;\n\n    // keccak256( \"metaSafeTransferFrom(address,address,uint256,uint256,bool,bytes)\" );\n    bytes32 internal constant META_TX_TYPEHASH = 0xce0b514b3931bdbe4d5d44e4f035afe7113767b7db71949271f6a62d9c60f558;\n    // keccak256( \"metaSafeBatchTransferFrom(address,address,uint256[],uint256[],bool,bytes)\" );\n    bytes32 internal constant META_BATCH_TX_TYPEHASH = 0xa3d4926e8cf8fe8e020cd29f514c256bc2eec62aa2337e415f1a33a4828af5a0;\n    // keccak256( \"metaSetApprovalForAll(address,address,bool,bool,bytes)\" );\n    bytes32 internal constant META_APPROVAL_TYPEHASH = 0xf5d4c820494c8595de274c7ff619bead38aac4fbc3d143b5bf956aa4b84fa524;\n    // keccak256( \"NEFTiAssetOwnership(address signer,uint256 tokenId)\" );\n    bytes32 public constant META_NEFTi_OWNERSHIP_TYPEHASH = 0x39ec3a9ba4d169b5881dc884412106cdbee7f26e164982c6e7299d408e770c78;\n\n    event NonceChange(address indexed signer, uint256 newNonce);\n\n\n    /*════════════oooooOooooo═════════════╗\n    ║█~~~~~~~~~~ META-TRANSFER ~~~~~~~~~~█║\n    ╚════════════════════════════════════*/\n\n    /**\n    ** @notice Allows anyone with a valid signature to transfer _amount amount of a token _id on the behalf of _from\n    ** @param _from     Source address\n    ** @param _to       Target address\n    ** @param _id       ID of the token type\n    ** @param _amount   Transfered amount\n    ** @param _isGasFee Whether gas is reimbursed to executor or not\n    ** @param _data     Encodes a meta transfer indicator, signature, gas payment receipt and extra transfer data\n    **   _data should be encoded as (\n    **   (bytes32 r, bytes32 s, uint8 v, uint256 nonce, SignatureType sigType),\n    **   (GasReceipt g, ?bytes transferData)\n    ** )\n    ** (i) i.e.: high level encoding should be (bytes, bytes), where the later bytes array is a nested bytes array\n    **/\n    function metaSafeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _id,\n        uint256 _amount,\n        bool    _isGasFee,\n        bytes   memory _data\n    )\n        public\n    {\n        require(_to != address(0), \"ERC1155MetaPackedBalance#metaSafeTransferFrom: INVALID_RECIPIENT\");\n\n        // Initializing\n        bytes memory transferData;\n        GasReceipt memory gasReceipt;\n\n        // Verify signature and extract the signed data\n        bytes memory signedData = _signatureValidation(\n            _from,\n            _data,\n            abi.encode(\n                META_TX_TYPEHASH,\n                _from, // Address as uint256\n                _to,   // Address as uint256\n                _id,\n                _amount,\n                _isGasFee ? uint256(1) : uint256(0)  // Boolean as uint256\n            )\n        );\n        // Transfer asset\n        _safeTransferFrom(_from, _to, _id, _amount);\n        // If Gas is being reimbursed\n        if (_isGasFee) {\n            (gasReceipt, transferData) = abi.decode(signedData, (GasReceipt, bytes));\n            // We need to somewhat protect relayers against gas griefing attacks in recipient contract.\n            // Hence we only pass the gasLimit to the recipient such that the relayer knows the griefing limit.\n            // Nothing can prevent the receiver to revert the transaction as close to the gasLimit as possible,\n            // but the relayer can now only accept meta-transaction gasLimit within a certain range.\n            _callonERC1155Received(_from, _to, _id, _amount, gasReceipt.gasLimitCallback, transferData);\n            // Transfer gas cost\n            _transferGasFee(_from, gasReceipt);\n        } else { _callonERC1155Received(_from, _to, _id, _amount, gasleft(), signedData); }\n    }\n\n    /**\n    ** @notice Allows anyone with a valid signature to transfer multiple types of tokens on the behalf of _from\n    ** @param _from     Source addresses\n    ** @param _to       Target addresses\n    ** @param _ids      IDs of each token type\n    ** @param _amounts  Transfer amounts per token type\n    ** @param _isGasFee Whether gas is reimbursed to executor or not\n    ** @param _data     Encodes a meta transfer indicator, signature, gas payment receipt and extra transfer data\n    **   _data should be encoded as (\n    **   (bytes32 r, bytes32 s, uint8 v, uint256 nonce, SignatureType sigType),\n    **   (GasReceipt g, ?bytes transferData)\n    ** )\n    ** (i) i.e.: high level encoding should be (bytes, bytes), where the later bytes array is a nested bytes array\n    **/\n    function metaSafeBatchTransferFrom(\n        address   _from,\n        address   _to,\n        uint256[] memory _ids,\n        uint256[] memory _amounts,\n        bool      _isGasFee,\n        bytes     memory _data\n    )\n        public\n    {\n        require(_to != address(0), \"ENEFTi1155MPB__metaSafeBatchTransferFrom__INVALID_RECIPIENT\");\n\n        // Initializing\n        bytes memory transferData;\n        GasReceipt memory gasReceipt;\n\n        // Verify signature and extract the signed data\n        bytes memory signedData = _signatureValidation(\n            _from,\n            _data,\n            abi.encode(\n                META_BATCH_TX_TYPEHASH,\n                _from, // Address as uint256\n                _to,   // Address as uint256\n                keccak256(abi.encodePacked(_ids)),\n                keccak256(abi.encodePacked(_amounts)),\n                _isGasFee ? uint256(1) : uint256(0)  // Boolean as uint256\n            )\n        );\n        // Transfer assets\n        _safeBatchTransferFrom(_from, _to, _ids, _amounts);\n        // If gas fee being reimbursed\n        if (_isGasFee) {\n            (gasReceipt, transferData) = abi.decode(signedData, (GasReceipt, bytes));\n            // We need to somewhat protect relayers against gas griefing attacks in recipient contract.\n            // Hence we only pass the gasLimit to the recipient such that the relayer knows the griefing\n            // limit. Nothing can prevent the receiver to revert the transaction as close to the gasLimit as\n            // possible, but the relayer can now only accept meta-transaction gasLimit within a certain range.\n            _callonERC1155BatchReceived(_from, _to, _ids, _amounts, gasReceipt.gasLimitCallback, transferData);\n            // Handle gas reimbursement\n            _transferGasFee(_from, gasReceipt);\n        } else { _callonERC1155BatchReceived(_from, _to, _ids, _amounts, gasleft(), signedData); }\n    }\n\n\n    /*════════════oooooOooooo═════════════╗\n    ║█~~~~~~~~~~~~~ OPERATOR ~~~~~~~~~~~~█║\n    ╚════════════════════════════════════*/\n\n    /**\n    ** @notice Approve the passed address to spend on behalf of _from if valid signature is provided\n    ** @param _owner     Address that wants to set operator status  _spender\n    ** @param _operator  Address to add to the set of authorized operators\n    ** @param _approved  True if the operator is approved, false to revoke approval\n    ** @param _isGasFee  Whether gas will be reimbursed or not, with vlid signature\n    ** @param _data      Encodes signature and gas payment receipt\n    **   _data should be encoded as (\n    **     (bytes32 r, bytes32 s, uint8 v, uint256 nonce, SignatureType sigType),\n    **     (GasReceipt g)\n    **   )\n    ** (i) i.e.: high level encoding should be (bytes, bytes), where the latter bytes array is a nested bytes array\n    **/\n    function metaSetApprovalForAll(\n        address _owner,\n        address _operator,\n        bool    _approved,\n        bool    _isGasFee,\n        bytes   memory _data\n    )\n        public\n    {\n        // Verify signature and extract the signed data\n        bytes memory signedData = _signatureValidation(\n            _owner,\n            _data,\n            abi.encode(\n                META_APPROVAL_TYPEHASH,\n                _owner,                              // Address as uint256\n                _operator,                           // Address as uint256\n                _approved ? uint256(1) : uint256(0), // Boolean as uint256\n                _isGasFee ? uint256(1) : uint256(0)  // Boolean as uint256\n            )\n        );\n        // Update operator status\n        operators[_owner][_operator] = _approved;\n        // Emit event\n        emit ApprovalForAll(_owner, _operator, _approved);\n        // Handle gas reimbursement\n        if (_isGasFee) {\n            GasReceipt memory gasReceipt = abi.decode(signedData, (GasReceipt));\n            _transferGasFee(_owner, gasReceipt);\n        }\n    }\n\n\n    /*════════════oooooOooooo═════════════╗\n    ║█~~~~~~~ SIGNATURE VALIDATION ~~~~~~█║\n    ╚════════════════════════════════════*/\n\n    /**\n    ** @notice Verifies signatures for this contract\n    ** @param _signer     Address of signer\n    ** @param _sigData    Encodes signature, gas payment receipt and transfer data (if any)\n    ** @param _encMembers Encoded EIP-712 type members (except nonce and _data), all need to be 32 bytes size\n    ** @dev _data should be encoded as (\n    **   (bytes32 r, bytes32 s, uint8 v, uint256 nonce, SignatureType sigType),\n    **   (GasReceipt g, ?bytes transferData)\n    ** )\n    ** (i) i.e.: high level encoding should be (bytes, bytes), where the latter bytes array is a nested bytes array\n    ** @dev A valid nonce is a nonce that is within 100 value from the current nonce\n    **/\n    function _signatureValidation(address _signer, bytes memory _sigData, bytes memory _encMembers)\n        internal\n        returns (bytes memory signedData)\n    {\n        bytes memory sig;\n        // Get signature and data to sign\n        (sig, signedData) = abi.decode(_sigData, (bytes, bytes));\n\n        // Get current nonce and nonce used for signature\n        uint256 currentNonce = nonces[_signer];        // Lowest valid nonce for signer\n        uint256 nonce = uint256(sig.readBytes32(65));  // Nonce passed in the signature object\n        // Verify if nonce is valid\n        require((nonce \u003e= currentNonce) \u0026\u0026 (nonce \u003c (currentNonce + 100)), \"ENEFTi1155MPB__|_signatureValidation__INVALID_NONCE\" );\n\n        // Take hash of bytes arrays\n        bytes32 hash = hashEIP712Message(keccak256(abi.encodePacked(_encMembers, nonce, keccak256(signedData))));\n        // Complete data to pass to signer verifier\n        bytes memory fullData = abi.encodePacked(_encMembers, nonce, signedData);\n        //Update signature nonce\n        nonces[_signer] = nonce + 1;\n        emit NonceChange(_signer, nonce + 1);\n        // Verify if _from is the signer\n        (bool isValid, ) = isValidSignature(_signer, hash, fullData, sig);\n        require(isValid, \"ENEFTi1155MPB__|_signatureValidation__INVALID_SIGNATURE\");\n        return signedData;\n    }\n\n    /**\n    ** @notice Returns the current nonce associated with a given address\n    ** @param _signer Address to query signature nonce for\n    **/\n    function getNonce(address _signer)\n        public view\n        returns (uint256 nonce)\n    { return nonces[_signer]; }\n\n    /**\n    ** @dev Meta to Verify Resource Asset Ownership\n    ** @param _signer  An address which request asset resource to verify\n    ** @param _hash    Hash of the signed data\n    ** @param _r       Signed R\n    ** @param _s       Signed S\n    ** @param _v       Signed V\n    ** keccak256(abi.encodePacked(\n    **    EIP191_HEADER,\n    **    keccak256(abi.encode( DOMAIN_SEPARATOR_TYPEHASH, address(this) )),\n    **    keccak256(abi.encode( META_NEFTi_OWNERSHIP_TYPEHASH, _signer, _tokenId ))\n    ** ));\n    **/\n    function verifyOwnership(\n        address _signer,\n        bytes32 _hash,\n        bytes32 _r,\n        bytes32 _s,\n        uint8   _v\n    )\n        public view\n        returns (bool success, address signer)\n    {\n        uint8 _st = 0x01;\n        bytes memory sig = abi.encodePacked(\n            _r, _s, _v,\n            (nonces[_signer] \u003e 0 ? nonces[_signer] : 1),\n            _st\n        );\n        bytes32 hashMessage = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _hash));\n        (bool ok, ) = isValidSignature(_signer, hashMessage, \"\", sig);\n        return ( ok, ok ? _signer : address(0) );\n    }\n\n\n    /*════════════oooooOooooo═════════════╗\n    ║█~~~~~~~~ GAS REIMBURSEMENT ~~~~~~~~█║\n    ╚════════════════════════════════════*/\n\n    /**\n    ** @notice Will reimburse tx.origin or fee recipient for the gas spent execution a transaction\n    **         Can reimbuse in any ERC-20 or ERC-1155 token\n    ** @param _from  Address from which the payment will be made from\n    ** @param _g     GasReceipt object that contains gas reimbursement information\n    **/\n    function _transferGasFee(address _from, GasReceipt memory _g)\n        internal\n    {\n        // Pop last byte to get token fee type\n        uint8 feeTokenTypeRaw = uint8(_g.feeTokenData.popLastByte());\n        // Ensure valid fee token type\n        require(feeTokenTypeRaw \u003c uint8(FeeTokenType.NTypes), \"ENEFTi1155MPB__|_transferGasFee__UNSUPPORTED_TOKEN\");\n\n        // Convert to FeeTokenType corresponding value\n        FeeTokenType feeTokenType = FeeTokenType(feeTokenTypeRaw);\n\n        // Declarations\n        address tokenAddress;\n        address feeRecipient;\n        uint256 tokenID;\n        uint256 fee = _g.gasFee;\n        // If receiver is 0x0, then anyone can claim, otherwise, refund addressee provided\n        feeRecipient = _g.feeRecipient == address(0) ? msg.sender : _g.feeRecipient;\n        // Fee token is ERC1155\n        if (feeTokenType == FeeTokenType.ERC1155) {\n            (tokenAddress, tokenID) = abi.decode(_g.feeTokenData, (address, uint256));\n            // Fee is paid from this ERC1155 contract\n            if (tokenAddress == address(this)) {\n                _safeTransferFrom(_from, feeRecipient, tokenID, fee);\n                // No need to protect against griefing since recipient (if contract) is most likely owned by the relayer\n                _callonERC1155Received(_from, feeRecipient, tokenID, gasleft(), fee, \"\");\n            }\n            // Fee is paid from another ERC-1155 contract\n            else { IERC1155(tokenAddress).safeTransferFrom(_from, feeRecipient, tokenID, fee, \"\"); }\n\n        }\n        // Fee token is ERC20\n        else {\n            tokenAddress = abi.decode(_g.feeTokenData, (address));\n            require(IERC20(tokenAddress).transferFrom(_from, feeRecipient, fee), \"ENEFTi1155MPB__|_transferGasFee__ERC20_TRANSFER_FAILED\");\n        }\n    }\n}\n"},"ERC1155MintBurnPackedBalance.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity \u003e=0.7.4 \u003c=0.8.9;\n\nimport \"./ERC1155MetaPackedBalance.sol\";\nimport \"./IERC1155Metadata.sol\";\n\n\n/**\n** @dev Multi-Fungible Tokens with minting and burning methods. These methods assume\n**      a parent contract to be executed as they are `internal` functions.\n**/\n// abstract contract ERC1155MintBurnPackedBalance is ERC1155PackedBalance, IERC1155Metadata {\nabstract contract ERC1155MintBurnPackedBalance is ERC1155MetaPackedBalance, IERC1155Metadata {\n    // URI\u0027s default URI prefix\n    string internal baseMetadataURI;\n\n\n    /*════════════oooooOooooo═════════════╗\n    ║█~~~~~~~~~~~~~ METADATA ~~~~~~~~~~~~█║\n    ╚════════════════════════════════════*/\n\n    /**\n    ** @notice A distinct Uniform Resource Identifier (URI) for a given token.\n    ** @dev URIs are assumed to be deterministically generated based on token ID, defined in RFC 3986.\n    ** @return URI string\n    **/\n    function uri(uint256 _id)\n        public view override\n        returns (string memory)\n    {\n        // return string(abi.encodePacked(baseMetadataURI, _uint2str(_id), \".json\"));\n        return string(abi.encodePacked(baseMetadataURI, _getURI(_id), \"/metadata.json\"));\n    }\n\n    /**\n    ** @dev Update Base MetadataURI of token id. URIs are defined in RFC 3986.\n    **      URIs are assumed to be deterministically generated based on token ID\n    ** @param _newBaseMetadataURI URI\n    **/\n    function setBaseMetadataURI(string memory _newBaseMetadataURI)\n        public onlyOwner\n    { _setBaseMetadataURI(_newBaseMetadataURI); }\n\n    /**\n    ** @notice Will emit default URI log event for corresponding token _id\n    ** @param _tokenIDs Array of IDs of tokens to log default URI\n    **/\n    function logURIs(uint256[] memory _tokenIDs)\n        public onlyOwner\n    { _logURIs(_tokenIDs); }\n    function _logURIs(uint256[] memory _tokenIDs)\n        internal\n    {\n        string memory tokenURI;\n        for (uint256 i = 0; i \u003c _tokenIDs.length; i++) {\n        tokenURI = string(abi.encodePacked(baseMetadataURI, _getURI(_tokenIDs[i]), \".json\"));\n        emit URI(tokenURI, _tokenIDs[i]);\n        }\n    }\n\n    /**\n    ** @notice Will update the base URL of token\u0027s URI\n    ** @param _newBaseMetadataURI New base URL of token\u0027s URI\n    **/\n    function _setBaseMetadataURI(string memory _newBaseMetadataURI)\n        internal\n    { baseMetadataURI = _newBaseMetadataURI; }\n\n\n    /*════════════oooooOooooo═════════════╗\n    ║█~~~~~~~~~~~~~ MINTING ~~~~~~~~~~~~~█║\n    ╚════════════════════════════════════*/\n\n    /**\n    ** @notice Mint amount of tokens of a given id\n    ** @param _to      The address to mint tokens to\n    ** @param _id      Token id to mint\n    ** @param _amount  The amount to be minted\n    ** @param _data    Data to pass if receiver is contract\n    **/\n    function _mint(address _to, uint256 _id, uint256 _amount, bytes memory _data)\n        internal\n    {\n        _id = (_id == 0) ? _requestId() : _id;\n        //-- transfer mint Fee\n        (uint8 _feeType, ) = getDefaultFeeType();\n        (uint256[3] memory mintFee, , ) = INEFTiMTFeeCalcExt(NEFTiMTFeeCalcExt).getMintFee(_amount);\n        _payFee(mintFee[0], mintFee[1], mintFee[2], _feeType);\n\n        if (_checkMintType(_id) == MintType.Add) {\n            _mintAddNew(_to, _id, _amount, _data);\n            _setMinters(_to, _id);\n            _setHoldedTokens(_to, _id);\n        }\n        else { _mintAddNew(_to, _id, _amount, _data); }\n    }\n\n    /**\n    ** @notice Mint to add more supply (internal use)\n    ** @param _to      The address to mint tokens to\n    ** @param _id      Token id to mint\n    ** @param _amount  The amount to be minted\n    ** @param _data    Data to pass if receiver is contract\n    **/\n    function _mintAddNew(address _to, uint256 _id, uint256 _amount, bytes memory _data)\n        internal\n    {\n        // Add _amount\n        _updateIDBalance(_to,   _id, _amount, Operations.Add);\n        // Add resource\n        _updateIDResources(_id, _data);\n        _setSupplies(_id, _amount, true);\n\n        emit TransferSingle(msg.sender, address(0x0), _to, _id, _amount);\n        // Calling onReceive method if recipient is contract\n        _callonERC1155Received(address(0x0), _to, _id, _amount, gasleft(), _data);\n    }\n\n    /**\n    ** @notice Mint tokens for each (_ids[i], _amounts[i]) pair\n    ** @param _to       The address to mint tokens to\n    ** @param _ids      Array of ids to mint\n    ** @param _amounts  Array of amount of tokens to mint per id\n    ** @param _data    Data to pass if receiver is contract\n    **/\n    function _batchMint(address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data)\n        internal\n    {\n        require(_ids.length == _amounts.length, \"ENEFTi1155MBPB.01.ARRAYS_LENGTH_MISMATCH\");\n\n        if (_ids.length \u003e 0) {\n            _ids[0] = (_ids[0] == 0) ? _requestId() : _ids[0];\n            address minter = minterOf(_ids[0]);\n            (uint8 _feeType, ) = getDefaultFeeType();\n            // Load first bin and index where the token ID balance exists\n            (uint256 bin, uint256 index) = getIDBinIndex(_ids[0]);\n            // Balance for current bin in memory (initialized with first transfer)\n            uint256 balTo = _viewUpdateBinValue(balances[_to][bin], index, _amounts[0], Operations.Add);\n\n            //-- transfer mint Fee all at once\n            (uint256[3] memory mintFee, , ) = INEFTiMTFeeCalcExt(NEFTiMTFeeCalcExt).getBatchMintFee(_amounts);\n            _payFee(mintFee[0], mintFee[1], mintFee[2], _feeType);\n            // Last bin updated\n            uint256 lastBin = bin;\n            uint256 i;\n            for (i = 1; i \u003c _ids.length; i++) {\n                _ids[i] = (_ids[i] == 0) ? _requestId() : _ids[i];\n                minter = minterOf(_ids[i]);\n                (bin, index) = getIDBinIndex(_ids[i]);\n\n                // If new bin\n                if (bin != lastBin) {\n                    if (_checkMintType(_ids[i-1]) == MintType.Add) {\n                        // Update storage balance of previous bin\n                        balances[_to][lastBin] = balTo;\n                        balTo = balances[_to][bin];\n                        // Update related storages\n                        _setMinters(_to, _ids[i-1]);\n                        _setSupplies(_ids[i-1], balTo, true);\n                        _setHoldedTokens(_to, _ids[i-1]);\n                        _updateIDResources(_ids[i-1], _data);\n                    }\n                    else {\n                        // Update balance storage\n                        balances[_to][lastBin] = balTo;\n                        balTo = balances[_to][bin];\n                        // Update related storages\n                        _updateIDResources(_ids[i-1], _data);\n                    }\n                    // Bin will be the most recent bin\n                    lastBin = bin;\n                }\n                // Update memory balance\n                balTo = _viewUpdateBinValue(balTo, index, _amounts[i], Operations.Add);\n            }\n\n            if (_checkMintType(_ids[i-1]) == MintType.Add) {\n                // Update storage of the last bin visited\n                balances[_to][bin] = balTo;\n                // Update related storages\n                _setMinters(_to, _ids[i-1]);\n                _setSupplies(_ids[i-1], balTo, true);\n                _setHoldedTokens(_to, _ids[i-1]);\n                _updateIDResources(_ids[i-1], _data);\n            }\n            else {\n                // Update storage balance of the last bin visited\n                balances[_to][bin] = balTo;\n                // Update related storages\n                _setSupplies(_ids[i-1], balTo, true);\n                _updateIDResources(_ids[i-1], _data);\n            }\n        }\n        // Empty Ids, nothing to proceed\n        else { return; }\n\n        emit TransferBatch(msg.sender, address(0x0), _to, _ids, _amounts);\n        // Calling onReceive method if recipient is contract\n        _callonERC1155BatchReceived(address(0x0), _to, _ids, _amounts, gasleft(), _data);\n    }\n\n\n    /*════════════oooooOooooo═════════════╗\n    ║█~~~~~~~~~~~~~ BURNING ~~~~~~~~~~~~~█║\n    ╚════════════════════════════════════*/\n\n    /**\n    ** @notice Burn amount of tokens of a given token id\n    ** @param _from    The address to burn tokens from\n    ** @param _id      Token id to burn\n    ** @param _amount  The amount to be burned\n    **/\n    function _burn(address _from, uint256 _id, uint256 _amount)\n        internal\n    {\n        // Substract _amount\n        _updateIDBalance(_from, _id, _amount, Operations.Sub);\n        _setSupplies(_id, _amount, false);\n        emit TransferSingle(msg.sender, _from, address(0x0), _id, _amount);\n    }\n\n    /**\n    ** @notice Burn tokens of given token id for each (_ids[i], _amounts[i]) pair\n    ** @dev This batchBurn method does not implement the most efficient way of updating\n    **      balances to reduce the potential bug surface as this function is expected to\n    **      be less common than transfers. EIP-2200 makes this method significantly\n    **      more efficient already for packed balances.\n    ** @param _from     The address to burn tokens from\n    ** @param _ids      Array of token ids to burn\n    ** @param _amounts  Array of the amount to be burned\n    **/\n    function _batchBurn(address _from, uint256[] memory _ids, uint256[] memory _amounts)\n        internal\n    {\n        // Number of burning to execute\n        uint256 nBurn = _ids.length;\n        require(nBurn == _amounts.length, \"ENEFTi1155MBPB.02.ARRAYS_LENGTH_MISMATCH\");\n\n        // Executing all burning\n        for (uint256 i = 0; i \u003c nBurn; i++) {\n            // Update storage balance\n            _updateIDBalance(_from,   _ids[i], _amounts[i], Operations.Sub); // Add amount to recipient\n            // Update related storages\n            _setSupplies(_ids[i], _amounts[i], false);\n        }\n\n        emit TransferBatch(msg.sender, _from, address(0x0), _ids, _amounts);\n    }\n}\n"},"ERC1155PackedBalance.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\npragma solidity \u003e=0.7.4 \u003c=0.8.9;\npragma experimental ABIEncoderV2;\n\nimport \"./SafeMath.sol\";\nimport \"./IERC1155TokenReceiver.sol\";\nimport \"./IERC1155.sol\";\nimport \"./INEFTiMultiTokens.sol\";\nimport \"./Address.sol\";\nimport \"./ERC165.sol\";\nimport \"./SafeERC20.sol\";\nimport \"./Ownable.sol\";\nimport \"./INEFTiMTFeeCalcExt.sol\";\n\n\n/**\n * @dev Implementation of Multi-Token Standard contract. This implementation of the ERC-1155 standard\n *      utilizes the fact that balances of different token ids can be concatenated within individual\n *      uint256 storage slots. This allows the contract to batch transfer tokens more efficiently at\n *      the cost of limiting the maximum token balance each address can hold. This limit is\n *      2^IDS_BITS_SIZE, which can be adjusted below. In practice, using IDS_BITS_SIZE smaller than 16\n *      did not lead to major efficiency gains.\n */\nabstract contract ERC1155PackedBalance is INEFTiMultiTokens, ERC165, Ownable {\n    using SafeMath for uint256;\n    using Address for address;\n    using SafeERC20 for IERC20;\n\n    /*════════════oooooOooooo═════════════╗\n    ║█~~~~~~~~~~~~ VARIABLES ~~~~~~~~~~~~█║\n    ╚════════════════════════════════════*/\n\n    // onReceive function signatures\n    bytes4 constant internal ERC1155_RECEIVED_VALUE = 0xf23a6e61;\n    bytes4 constant internal ERC1155_BATCH_RECEIVED_VALUE = 0xbc197c81;\n\n    // Constants regarding bin sizes for balance packing\n    // IDS_BITS_SIZE **MUST** be a power of 2 (e.g. 2, 4, 8, 16, 32, 64, 128)\n    uint256 internal constant IDS_BITS_SIZE   = 32;                  // Max balance amount in bits per token ID\n    uint256 internal constant IDS_PER_UINT256 = 256 / IDS_BITS_SIZE; // Number of ids per uint256\n\n    // Operations for _updateIDBalance\n    enum Operations { Add, Sub }\n    // MintType for _checkMintType\n    enum MintType { Add, Update }\n\n    address internal NEFTiMTFeeCalcExt;\n\n    /**\n    ** @dev MultiTokens balance storage layout\n    ** @params address  User Wallet Address\n    ** @params uint256  Token ID\n    ** @return uint256  Balance\n    **/\n    mapping (address =\u003e mapping(uint256 =\u003e uint256)) internal balances;\n    /**\n    ** @dev MultiTokens supplies each token id\n    ** @params uint256  Token ID\n    ** @return uint256  Supply\n    **/\n    mapping (uint256 =\u003e uint256) internal supplies;\n    /**\n    ** @dev MultiTokens minters address each token id\n    ** @params uint256  Token ID\n    ** @return Token id supply\n    **/\n    mapping (uint256 =\u003e address) internal minters;\n    /**\n    ** @dev MultiTokens resources data each token id\n    ** @params uint256  Token ID\n    ** @return Resource Data\n    **/\n    mapping (uint256 =\u003e bytes) internal resources;\n    /**\n    ** @dev MultiTokens holders map\n    ** @params address    User Wallet Address\n    ** @return uint256[]  List of Token ID\n    **/\n    mapping (address =\u003e uint256[]) internal holders;\n    /**\n    ** @dev Signature nonce of ReqMinter per address\n    ** @params address  User Wallet Address\n    ** @return uint256  Nonce\n    **/\n    mapping (address =\u003e uint256) internal reqIdNonces;\n    /**\n    ** @dev Operator to mint tokens\n    ** @params address  Item owner (authorizer)\n    ** @params address  Destination operator to authorize\n    ** @return bool - Allowance state\n    **/\n    mapping (address =\u003e mapping(address =\u003e bool)) internal operators;\n\n    event RequestId(address indexed asAddress, uint256 indexed asUInt);\n\n\n    /*════════════oooooOooooo═════════════╗\n    ║█~~~~~~~~~~~~ UTILITIES ~~~~~~~~~~~~█║\n    ╚════════════════════════════════════*/\n\n    /**\n    ** @dev Generate a unique ID (public use)\n    ** Sample: 0xf4a8f74879182ff2a07468508bec89e1e7464027\t\t          \n    **/  \n    function requestId()\n        public override\n    {\n        uint256 _id = _requestId();\n        emit RequestId(address(uint160(_id)), _id);\n    }\n\n    /**\n    ** @dev Generate a unique ID (internal use)\n    ** @return _id Unique Identifier\n    **/ \n    function _requestId()\n        internal\n        returns (uint256 _id)\n    {\n        uint256 nonce = reqIdNonces[msg.sender] + 1;\n        bytes32 b = keccak256(abi.encodePacked(blockhash(block.number - 1), msg.sender, nonce, block.timestamp));\n        bytes20 b20 = bytes20(b);\n        uint256 addr = 0;\n        for (uint256 index = b20.length-1; index \u003e 0; index--) {\n            addr += uint8(b20[index]) * ( 18 ** ((b20.length - index) * 2));\n        }\n        \n        address checkId = minters[addr];\n        reqIdNonces[msg.sender]++;\n\n        if (checkId != address(0)) { requestId(); }\n        else { return addr; }\n    }\n\n    /**\n    ** @dev Owned items of the given address\n    ** @param _holder The address of the owner\n    ** @return _ids The list of owned item ids\n    **/\n    function itemsOf(address _holder)\n        public override view\n        returns (uint256[] memory)\n    {\n        require(_holder != address(0), \"ENEFTi1155PB.01.INVALID_GIVEN_ADDRESS\");\n        return holders[_holder];\n    }\n\n    /**\n    ** @dev Set item to new owner\n    ** @param _holder Owner address\n    ** @param _id Item id\n    */\n    function _setHoldedTokens(address _holder, uint256 _id)\n        internal\n    {\n        if (holders[_holder].length \u003e 0) {\n            for (uint256 i=0; i \u003c holders[_holder].length; i++) {\n                if (holders[_holder][i] == _id) { return; }\n            }\n            holders[_holder].push(_id);\n        }\n        else { holders[_holder].push(_id); }\n    }\n\n    /**\n    ** @dev Get list of holded items by owner address\n    ** @param _holder Owner address\n    ** @return _ids List of holded items\n    **/\n    function _getHoldedTokens(address _holder)\n        internal view\n        returns (uint256[] memory)\n    {\n        if (holders[_holder].length == 0) { return holders[_holder]; }\n        \n        uint256 skip;\n        for (uint256 i=0; i \u003c holders[_holder].length; i++) {\n            if (_balanceOf( _holder, holders[_holder][i] ) == 0) { skip++; }\n        }\n        uint256[] memory ids = new uint[]( holders[_holder].length - skip );\n        uint256 idx;\n        for (uint256 j=0; j \u003c holders[_holder].length; j++) {\n            if (_balanceOf( _holder, holders[_holder][j] ) \u003e 0) {\n                ids[idx] = holders[_holder][j];\n                idx++;\n            }\n        }\n        return ids;\n    }\n\n    /**\n    ** @dev Update CalcFee extension\n    ** @param _newCalcFeeExt CalcFee extension\n    **/\n    function setCalcFeeExt(address _newCalcFeeExt)\n        public onlyOwner\n    {\n        require(_newCalcFeeExt != address(0), \"ENEFTi1155MBPB.02.UNKNOWN_EXTENSION\");\n        NEFTiMTFeeCalcExt = _newCalcFeeExt;\n    }\n\n    /**\n    ** @dev Get Default Fee type\n    ** @return (\n    **    feeType - Fee type\n    **    feeTypeAsString - Fee type as string\n    ** )\n    **/\n    function getDefaultFeeType()\n        public view\n        returns(uint8 feeType, string memory feeTypeAsString)\n    { return INEFTiMTFeeCalcExt(NEFTiMTFeeCalcExt).getDefaultPaymentType(); }\n\n    /**\n    ** @dev Get Mint Fee info\n    ** @param amount Amount of tokens to mint\n    ** @return (\n    **    mintFee - Fee format\n    **    multitokenOnEach - multiplier amounts\n    **    feeAs - Fee type as string\n    ** )\n    **/\n    function getMintFee(uint256 amount)\n        public override view\n        returns( uint256[3] memory mintFee, uint256 multitokenOnEach, string memory feeAs )\n    { return INEFTiMTFeeCalcExt(NEFTiMTFeeCalcExt).getMintFee(amount); }\n\n    /**\n    ** @dev Get Batch Mint Fee info\n    ** @param _amounts List of amounts of tokens to mint\n    ** @return (\n    **    mintFee - Fee format\n    **    multitokenOnEach - multiplier amounts\n    **    feeAs - Fee type as string\n    ** )\n    **/\n    function getBatchMintFee(uint256[] memory _amounts)\n        public override view\n        returns( uint256[3] memory mintFee, uint256 multitokenOnEach, string memory feeAs )\n    { return INEFTiMTFeeCalcExt(NEFTiMTFeeCalcExt).getBatchMintFee(_amounts); }\n    \n    /**\n    ** @dev Set item supply\n    ** @param _id Item id\n    ** @param _amount Supply amount\n    ** @param _addOperation True if Add operation, else Substract operation\n    **/\n    function _setSupplies(uint256 _id, uint256 _amount, bool _addOperation)\n        internal\n    { supplies[_id] = (_addOperation ? supplies[_id].add(_amount) : supplies[_id].sub(_amount)); }\n\n    /**\n    ** @dev Get item total supply\n    ** @param _id Item id\n    ** @return Total supply amount\n    **/\n    function totalSupply(uint256 _id)\n        public override view\n        returns( uint256 )\n    { return supplies[_id]; }\n\n    /**\n    ** @dev Set authorize minter of minted item\n    ** @param _holder Minter address (creator)\n    ** @param _id Item id\n    **/\n    function _setMinters(address _holder, uint256 _id)\n        internal\n    { minters[_id] = _holder; }\n\n    /**\n    ** @dev Get authorize minter of minted item\n    ** @param _id Item id\n    ** @return Minter address\n    **/\n    function minterOf(uint256 _id)\n        public override view\n        returns (address)\n    {\n        require(_id \u003e 0, \"ENEFTi1155PB.03.INVALID_GIVEN_ID\");\n        return minters[_id];\n    }\n\n    /**\n    ** @dev Check things before do mint new item (internal use)\n    ** @param _id Token Id\n    ** @return MintType operation Add or Update\n    **/\n    function _checkMintType(uint256 _id)\n        internal view\n        returns (MintType)\n    {\n        address minter = minterOf(_id);\n\n        // mint token for new token id\n        if (minter == address(0) || minter == address(0x0)) {\n            // OnlyOwner allowed for specific length of Ids\n            if (_id \u003c= 99999999999999999999) { require(msg.sender == owner(), \"ENEFTi1155MBPB.04.FORBIDDEN_ID\"); }\n            return (MintType.Add);\n        }\n        // mint token for existing id, to add amount\n        else {\n            require((msg.sender == minter) || (msg.sender == owner()), \"ENEFTi1155MBPB.05.UNATHORIZED_MINTER\");\n            require(totalSupply(_id) \u003e 1, \"ENEFTi1155MBPB.06.PROHIBITED_ON_NFT_TYPE\");\n            return (MintType.Update);\n        }\n    }\n\n    /**\n    ** @dev Execution to pay fee (internal use)\n    ** @param bnbFee If defined as coin\n    ** @param b20Fee If defined as erc-20 token\n    ** @param nftFee If defined as NEFTi token\n    **/\n    function _payFee(uint256 bnbFee, uint256 b20Fee, uint256 nftFee, uint8 fPayMode)\n        internal\n    {\n        IERC20 b20Token = IERC20(0x8e87DB40C5E9335a8FE19333Ffc19AD95C665f60); // DOO\n        IERC20 nftToken = IERC20(0xFaAb744dB9def8e13194600Ed02bC5D5BEd3B85C); // NFT\n\n        // MODE_BNB_NFT\n        if (fPayMode == 0) {\n            require(msg.value \u003e= bnbFee, \"ENEFTi1155MBPB.07.NOT_ENOUGH_COINS\");\n            require(nftToken.allowance(msg.sender, address(this)) \u003e= nftFee, \"ENEFTi1155MBPB.08.NFT_ALLOWANCE\");\n            transferCoin(payable(owner()), bnbFee);\n            nftToken.safeTransferFrom(msg.sender, owner(), nftFee);\n        }\n        // MODE_BNB\n        else if (fPayMode == 1) {\n            require(msg.value \u003e= bnbFee, \"ENEFTi1155MBPB.09.BNB.NOT_ENOUGH_COINS\");\n            transferCoin(payable(owner()), bnbFee);\n        }\n        // MODE_B20_NFT\n        else if (fPayMode == 2) {\n            require(b20Token.allowance(msg.sender, address(this)) \u003e= b20Fee, \"ENEFTi1155MBPB.10.B20_ALLOWANCE\");\n            require(nftToken.allowance(msg.sender, address(this)) \u003e= nftFee, \"ENEFTi1155MBPB.11.NFT_ALLOWANCE\");\n            b20Token.safeTransferFrom(msg.sender, owner(), b20Fee);\n            nftToken.safeTransferFrom(msg.sender, owner(), nftFee);\n        }\n        // MODE_B20\n        else if (fPayMode == 3) {\n            require(b20Token.allowance(msg.sender, address(this)) \u003e= b20Fee, \"ENEFTi1155MBPB.12.B20_ALLOWANCE\");\n            b20Token.safeTransferFrom(msg.sender, owner(), nftFee);\n        }\n        // MODE_NFT\n        else {\n            require(nftToken.allowance(msg.sender, address(this)) \u003e= nftFee, \"ENEFTi1155MBPB.13.NFT_ALLOWANCE\");\n            nftToken.safeTransferFrom(msg.sender, owner(), nftFee);\n        }\n    }\n\n    /**\n    ** @dev Execution transfer coin (internal use)\n    ** @param recipient Receiver address\n    ** @param amount    Amount for transfer\n    **/\n    function transferCoin(address recipient, uint256 amount)\n        private\n    { (bool res,) = recipient.call{value: amount}(\"\"); require(res, \"ENEFTi1155MBPB.14.BNB_TRANSFER_FAILED\"); }\n\n\n    /*════════════oooooOooooo═════════════╗\n    ║█~~~~~~~~~ PUBLIC TRANSFER ~~~~~~~~~█║\n    ╚════════════════════════════════════*/\n\n    /**\n    * @notice Transfers amount amount of an _id from the _from address to the _to address specified\n    * @param _from    Source address\n    * @param _to      Target address\n    * @param _id      ID of the token type\n    * @param _amount  Transfered amount\n    * @param _data    Additional data with no specified format, sent in call to `_to`\n    */\n    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes memory _data)\n        external override\n    {\n        require(\n            _from != address(0) \u0026\u0026\n            _to != address(0) \u0026\u0026\n            _amount \u003e 0,\n            \"ENEFTi1155PB.15.INVALID_GIVEN_PARAMETERS\"\n        );\n        require((msg.sender == _from) || operators[_from][msg.sender], \"ENEFTi1155PB.16.INVALID_OPERATOR\");\n        // require(_amount \u003c= balances);  Not necessary since checked with _viewUpdateBinValue() checks\n\n        _safeTransferFrom(_from, _to, _id, _amount);\n        _callonERC1155Received(_from, _to, _id, _amount, gasleft(), _data);\n    }\n\n    /**\n    * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\n    * @dev Arrays should be sorted so that all ids in a same storage slot are adjacent (more efficient)\n    * @param _from     Source addresses\n    * @param _to       Target addresses\n    * @param _ids      IDs of each token type\n    * @param _amounts  Transfer amounts per token type\n    * @param _data     Additional data with no specified format, sent in call to `_to`\n    */\n    function safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data)\n        external override\n    {\n        require(\n            _from != address(0) \u0026\u0026\n            _to != address(0) \u0026\u0026\n            _ids.length \u003e 0 \u0026\u0026\n            _amounts.length \u003e 0,\n            \"ENEFTi1155PB.17.INVALID_GIVEN_PARAMETERS\"\n        );\n        require(_ids.length == _amounts.length, \"ENEFTi1155PB.18.INVALID_ARRAYS_LENGTH\");\n        require((msg.sender == _from) || operators[_from][msg.sender], \"ENEFTi1155PB.19.INVALID_OPERATOR\");\n        _safeBatchTransferFrom(_from, _to, _ids, _amounts);\n        _callonERC1155BatchReceived(_from, _to, _ids, _amounts, gasleft(), _data);\n    }\n\n\n    /*════════════oooooOooooo═════════════╗\n    ║█~~~~~~~~ INTERNAL TRANSFER ~~~~~~~~█║\n    ╚════════════════════════════════════*/\n\n    /**\n    * @notice Transfers amount amount of an _id from the _from address to the _to address specified\n    * @param _from    Source address\n    * @param _to      Target address\n    * @param _id      ID of the token type\n    * @param _amount  Transfered amount\n    */\n    function _safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount)\n        internal\n    {\n        // Update balances\n        _updateIDBalance(_from, _id, _amount, Operations.Sub); // Subtract amount from sender\n        _updateIDBalance(_to,   _id, _amount, Operations.Add); // Add amount to recipient\n        _setHoldedTokens(_to, _id);\n        emit TransferSingle(msg.sender, _from, _to, _id, _amount);\n    }\n\n    /**\n    * @notice Verifies if receiver is contract and if so, calls (_to).onERC1155Received(...)\n    */\n    function _callonERC1155Received(address _from, address _to, uint256 _id, uint256 _amount, uint256 _gasLimit, bytes memory _data)\n        internal\n    {\n        // Check if recipient is contract\n        if (_to.isContract()) {\n        bytes4 retval = IERC1155TokenReceiver(_to).onERC1155Received{gas:_gasLimit}(msg.sender, _from, _id, _amount, _data);\n        require(retval == ERC1155_RECEIVED_VALUE, \"ENEFTi1155PB.20.INVALID_RECEIVED_VALUE\");\n        }\n    }\n\n    /**\n    * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\n    * @dev Arrays should be sorted so that all ids in a same storage slot are adjacent (more efficient)\n    * @param _from     Source addresses\n    * @param _to       Target addresses\n    * @param _ids      IDs of each token type\n    * @param _amounts  Transfer amounts per token type\n    */\n    function _safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts)\n    // function _safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data)\n        internal\n    {\n        uint256 nTransfer = _ids.length; // Number of transfer to execute\n\n        if (_from != _to \u0026\u0026 nTransfer \u003e 0) {\n        // Load first bin and index where the token ID balance exists\n        (uint256 bin, uint256 index) = getIDBinIndex(_ids[0]);\n\n        // Balance for current bin in memory (initialized with first transfer)\n        uint256 balFrom = _viewUpdateBinValue(balances[_from][bin], index, _amounts[0], Operations.Sub);\n        uint256 balTo = _viewUpdateBinValue(balances[_to][bin], index, _amounts[0], Operations.Add);\n\n        // Last bin updated\n        uint256 lastBin = bin;\n\n        uint256 i;\n        for (i = 1; i \u003c nTransfer; i++) {\n            (bin, index) = getIDBinIndex(_ids[i]);\n\n            // If new bin\n            if (bin != lastBin) {\n            // Update storage balance of previous bin\n            balances[_from][lastBin] = balFrom;\n            balances[_to][lastBin] = balTo;\n\n            _setHoldedTokens(_to, _ids[i-1]);\n            // _updateIDResources(_ids[i-1], _data);\n\n            balFrom = balances[_from][bin];\n            balTo = balances[_to][bin];\n\n            // Bin will be the most recent bin\n            lastBin = bin;\n            }\n\n            // Update memory balance\n            balFrom = _viewUpdateBinValue(balFrom, index, _amounts[i], Operations.Sub);\n            balTo = _viewUpdateBinValue(balTo, index, _amounts[i], Operations.Add);\n        }\n\n        // Update storage of the last bin visited\n        balances[_from][bin] = balFrom;\n        balances[_to][bin] = balTo;\n\n        _setHoldedTokens(_to, _ids[i-1]);\n        // _updateIDResources(_ids[i-1], _data);\n\n        // If transfer to self, just make sure all amounts are valid\n        } else {\n        for (uint256 i = 0; i \u003c nTransfer; i++) {\n            require(_balanceOf(_from, _ids[i]) \u003e= _amounts[i], \"ENEFTi1155PB.21.UNDERFLOW\");\n        }\n        }\n\n        // Emit event\n        emit TransferBatch(msg.sender, _from, _to, _ids, _amounts);\n    }\n\n    /**\n    * @notice Verifies if receiver is contract and if so, calls (_to).onERC1155BatchReceived(...)\n    */\n    function _callonERC1155BatchReceived(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts, uint256 _gasLimit, bytes memory _data)\n        internal\n    {\n        // Pass data if recipient is contract\n        if (_to.isContract()) {\n        bytes4 retval = IERC1155TokenReceiver(_to).onERC1155BatchReceived{gas: _gasLimit}(msg.sender, _from, _ids, _amounts, _data);\n        require(retval == ERC1155_BATCH_RECEIVED_VALUE, \"ENEFTi1155PB.22.INVALID_BATCH_RECEIVED_VALUE\");\n        }\n    }\n\n\n    /*════════════oooooOooooo═════════════╗\n    ║█~~~~~~~~~~~~ OPERATOR ~~~~~~~~~~~~~█║\n    ╚════════════════════════════════════*/\n\n    /**\n    * @notice Enable or disable approval for a third party (\"operator\") to manage all of caller\u0027s tokens\n    * @param _operator  Address to add to the set of authorized operators\n    * @param _approved  True if the operator is approved, false to revoke approval\n    */\n    function setApprovalForAll(address _operator, bool _approved)\n        external override\n    {\n        // Update operator status\n        operators[msg.sender][_operator] = _approved;\n        emit ApprovalForAll(msg.sender, _operator, _approved);\n    }\n\n    /**\n    * @notice Queries the approval status of an operator for a given owner\n    * @param _owner     The owner of the Tokens\n    * @param _operator  Address of authorized operator\n    * @return isOperator True if the operator is approved, false if not\n    */\n    function isApprovedForAll(address _owner, address _operator)\n        external override view returns (bool isOperator)\n    { return operators[_owner][_operator]; }\n\n\n    /*════════════oooooOooooo═════════════╗\n    ║█~~~~~~~~~ PUBLIC BALANCE ~~~~~~~~~~█║\n    ╚════════════════════════════════════*/\n\n    /**\n    * @notice Get the balance of an account\u0027s Tokens\n    * @param _owner  The address of the token holder\n    * @param _id     ID of the Token\n    * @return The _owner\u0027s balance of the Token type requested\n    */\n    function balanceOf(address _owner, uint256 _id)\n        external override view returns (uint256)\n    { return _balanceOf(_owner, _id); }\n    function _balanceOf(address _owner, uint256 _id)\n        internal view returns (uint256)\n    {\n        uint256 bin;\n        uint256 index;\n\n        //Get bin and index of _id\n        (bin, index) = getIDBinIndex(_id);\n        return getValueInBin(balances[_owner][bin], index);\n    }\n\n    /**\n    * @notice Get the balance of multiple account/token pairs\n    * @param _owners The addresses of the token holders (sorted owners will lead to less gas usage)\n    * @param _ids    ID of the Tokens (sorted ids will lead to less gas usage\n    * @return The _owner\u0027s balance of the Token types requested (i.e. balance for each (owner, id) pair)\n    **/\n    function balanceOfBatch(address[] memory _owners, uint256[] memory _ids)\n        external override view returns (uint256[] memory)\n    {\n        require(_owners.length == _ids.length, \"ENEFTi1155PB.23.INVALID_ARRAY_LENGTH\");\n        return _balanceOfBatch(_owners, _ids);\n    }\n    function _balanceOfBatch(address[] memory _owners, uint256[] memory _ids)\n        internal view returns (uint256[] memory)\n    {\n        uint256 n_owners = _owners.length;\n\n        // First values\n        (uint256 bin, uint256 index) = getIDBinIndex(_ids[0]);\n        uint256 balance_bin = balances[_owners[0]][bin];\n        uint256 last_bin = bin;\n\n        // Initialization\n        uint256[] memory batchBalances = new uint256[](n_owners);\n        batchBalances[0] = getValueInBin(balance_bin, index);\n\n        // Iterate over each owner and token ID\n        for (uint256 i = 1; i \u003c n_owners; i++) {\n        (bin, index) = getIDBinIndex(_ids[i]);\n\n        // SLOAD if bin changed for the same owner or if owner changed\n        if (bin != last_bin || _owners[i-1] != _owners[i]) {\n            balance_bin = balances[_owners[i]][bin];\n            last_bin = bin;\n        }\n\n        batchBalances[i] = getValueInBin(balance_bin, index);\n        }\n\n        return batchBalances;\n    }\n\n\n    /*════════════oooooOooooo═════════════╗\n    ║█~~~~~~~~~ PACKED BALANCE ~~~~~~~~~~█║\n    ╚════════════════════════════════════*/\n\n    /**\n    * @notice Update the balance of a id for a given address\n    * @param _address    Address to update id balance\n    * @param _id         Id to update balance of\n    * @param _amount     Amount to update the id balance\n    * @param _operation  Which operation to conduct :\n    *   Operations.Add: Add _amount to id balance\n    *   Operations.Sub: Substract _amount from id balance\n    */\n    function _updateIDBalance(address _address, uint256 _id, uint256 _amount, Operations _operation)\n        internal\n    {\n        // Get bin and index of _id\n        (uint256 bin, uint256 index) = getIDBinIndex(_id);\n        // Update balance\n        balances[_address][bin] = _viewUpdateBinValue(balances[_address][bin], index, _amount, _operation);\n    }\n\n    /**\n    * @notice Update a value in _binValues\n    * @param _binValues  Uint256 containing values of size IDS_BITS_SIZE (the token balances)\n    * @param _index      Index of the value in the provided bin\n    * @param _amount     Amount to update the id balance\n    * @param _operation  Which operation to conduct :\n    *   Operations.Add: Add _amount to value in _binValues at _index\n    *   Operations.Sub: Substract _amount from value in _binValues at _index\n    */\n    function _viewUpdateBinValue(uint256 _binValues, uint256 _index, uint256 _amount, Operations _operation)\n        internal pure returns (uint256 newBinValues)\n    {\n        uint256 shift = IDS_BITS_SIZE * _index;\n        uint256 mask = (uint256(1) \u003c\u003c IDS_BITS_SIZE) - 1;\n\n        if (_operation == Operations.Add) {\n        newBinValues = _binValues + (_amount \u003c\u003c shift);\n        require(newBinValues \u003e= _binValues, \"ENEFTi1155PB.24.OVERFLOW\");\n        require(\n            ((_binValues \u003e\u003e shift) \u0026 mask) + _amount \u003c 2**IDS_BITS_SIZE, // Checks that no other id changed\n            \"ENEFTi1155PB.25.OVERFLOW\"\n        );\n\n        } else if (_operation == Operations.Sub) {\n        newBinValues = _binValues - (_amount \u003c\u003c shift);\n        require(newBinValues \u003c= _binValues, \"ENEFTi1155PB.26.UNDERFLOW\");\n        require(\n            ((_binValues \u003e\u003e shift) \u0026 mask) \u003e= _amount, // Checks that no other id changed\n            \"ENEFTi1155PB.27.UNDERFLOW\"\n        );\n\n        } else {\n        revert(\"ENEFTi1155PB.28.INVALID_BIN_WRITE_OPERATION\"); // Bad operation\n        }\n\n        return newBinValues;\n    }\n\n    /**\n    * @notice Return the bin number and index within that bin where ID is\n    * @param _id  Token id\n    * @return bin index (Bin number, ID\"s index within that bin)\n    */\n    function getIDBinIndex(uint256 _id)\n        public pure returns (uint256 bin, uint256 index)\n    {\n        bin = _id / IDS_PER_UINT256;\n        index = _id % IDS_PER_UINT256;\n        return (bin, index);\n    }\n\n    /**\n    * @notice Return amount in _binValues at position _index\n    * @param _binValues  uint256 containing the balances of IDS_PER_UINT256 ids\n    * @param _index      Index at which to retrieve amount\n    * @return amount at given _index in _bin\n    */\n    function getValueInBin(uint256 _binValues, uint256 _index)\n        public pure returns (uint256)\n    {\n        // require(_index \u003c IDS_PER_UINT256) is not required since getIDBinIndex ensures `_index \u003c IDS_PER_UINT256`\n\n        // Mask to retrieve data for a given binData\n        uint256 mask = (uint256(1) \u003c\u003c IDS_BITS_SIZE) - 1;\n\n        // Shift amount\n        uint256 rightShift = IDS_BITS_SIZE * _index;\n        return (_binValues \u003e\u003e rightShift) \u0026 mask;\n    }\n\n\n    /*════════════oooooOooooo═════════════╗\n    ║█~~~~~~~~ METADATA INTERNAL ~~~~~~~~█║\n    ╚════════════════════════════════════*/\n\n    /**\n    ** @dev Update metadata URI of a Token (internal use)\n    ** @param _id ID of the Token\n    **/\n    function _updateIDResources(uint256 _id, bytes memory _data)\n        internal\n    {\n        uint256 bin;\n        uint256 index;\n\n        (bin, index) = getIDBinIndex(_id);\n\n        address minter = minters[bin];\n\n        require(\n        msg.sender == owner() ||\n        msg.sender == minter ||\n        minter == address(0) ||\n        minter == address(0x0),\n        \"ENEFTi1155PB.29.UNAUTHORIZED_MINTER\"\n        );\n\n        resources[_id] = _data;\n    }\n\n    /**\n    ** @dev Fetch the metadata URI of a token (internal use)\n    ** @param _id           Token id\n    ** @return MetadataURI of the Token\n    **/\n    function _getURI(uint256 _id)\n        internal view\n        returns (bytes memory)\n    { return resources[_id]; }\n\n\n    /*════════════oooooOooooo═════════════╗\n    ║█~~~~~~~~~~~~~ ERC-165 ~~~~~~~~~~~~~█║\n    ╚════════════════════════════════════*/\n\n    /**\n    * @notice Query if a contract implements an interface\n    * @param _interfaceID  The interface identifier, as specified in ERC-165\n    * @return `true` if the contract implements `_interfaceID` and\n    */\n    function supportsInterface(bytes4 _interfaceID)\n        public view virtual\n        override( ERC165 ) \n        returns (bool)\n    {\n        if (_interfaceID == type(IERC1155).interfaceId) {\n        return true;\n        }\n        return super.supportsInterface(_interfaceID);\n    }\n}\n"},"ERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /*\n     * bytes4(keccak256(\u0027supportsInterface(bytes4)\u0027)) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it\u0027s supported.\n     */\n    mapping(bytes4 =\u003e bool) private _supportedInterfaces;\n\n    constructor () {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n"},"IERC1155.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\npragma solidity \u003e=0.7.4 \u003c=0.8.9;\n\n\ninterface IERC1155 {\n\n  /****************************************|\n  |                 Events                 |\n  |_______________________________________*/\n\n  /**\n   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\n   *   Operator MUST be msg.sender\n   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\n   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\n   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the \"circulating supply\" for a given token ID\n   *   To broadcast the existence of a token ID with no initial balance, the contract SHOULD emit the TransferSingle event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\n   */\n  event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _amount);\n\n  /**\n   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\n   *   Operator MUST be msg.sender\n   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\n   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\n   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the \"circulating supply\" for a given token ID\n   *   To broadcast the existence of multiple token IDs with no initial balance, this SHOULD emit the TransferBatch event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\n   */\n  event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _amounts);\n\n  /**\n   * @dev MUST emit when an approval is updated\n   */\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n\n  /****************************************|\n  |                Functions               |\n  |_______________________________________*/\n\n  /**\n    * @notice Transfers amount of an _id from the _from address to the _to address specified\n    * @dev MUST emit TransferSingle event on success\n    * Caller must be approved to manage the _from account\u0027s tokens (see isApprovedForAll)\n    * MUST throw if `_to` is the zero address\n    * MUST throw if balance of sender for token `_id` is lower than the `_amount` sent\n    * MUST throw on any other error\n    * When transfer is complete, this function MUST check if `_to` is a smart contract (code size \u003e 0). If so, it MUST call `onERC1155Received` on `_to` and revert if the return amount is not `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n    * @param _from    Source address\n    * @param _to      Target address\n    * @param _id      ID of the token type\n    * @param _amount  Transfered amount\n    * @param _data    Additional data with no specified format, sent in call to `_to`\n    */\n  function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes calldata _data) external;\n\n  /**\n    * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\n    * @dev MUST emit TransferBatch event on success\n    * Caller must be approved to manage the _from account\u0027s tokens (see isApprovedForAll)\n    * MUST throw if `_to` is the zero address\n    * MUST throw if length of `_ids` is not the same as length of `_amounts`\n    * MUST throw if any of the balance of sender for token `_ids` is lower than the respective `_amounts` sent\n    * MUST throw on any other error\n    * When transfer is complete, this function MUST check if `_to` is a smart contract (code size \u003e 0). If so, it MUST call `onERC1155BatchReceived` on `_to` and revert if the return amount is not `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n    * Transfers and events MUST occur in the array order they were submitted (_ids[0] before _ids[1], etc)\n    * @param _from     Source addresses\n    * @param _to       Target addresses\n    * @param _ids      IDs of each token type\n    * @param _amounts  Transfer amounts per token type\n    * @param _data     Additional data with no specified format, sent in call to `_to`\n  */\n  function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external;\n\n  /**\n   * @notice Get the balance of an account\u0027s Tokens\n   * @param _owner  The address of the token holder\n   * @param _id     ID of the Token\n   * @return        The _owner\u0027s balance of the Token type requested\n   */\n  function balanceOf(address _owner, uint256 _id) external view returns (uint256);\n\n  /**\n   * @notice Get the balance of multiple account/token pairs\n   * @param _owners The addresses of the token holders\n   * @param _ids    ID of the Tokens\n   * @return        The _owner\u0027s balance of the Token types requested (i.e. balance for each (owner, id) pair)\n   */\n  function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);\n\n  /**\n   * @notice Enable or disable approval for a third party (\"operator\") to manage all of caller\u0027s tokens\n   * @dev MUST emit the ApprovalForAll event on success\n   * @param _operator  Address to add to the set of authorized operators\n   * @param _approved  True if the operator is approved, false to revoke approval\n   */\n  function setApprovalForAll(address _operator, bool _approved) external;\n\n  /**\n   * @notice Queries the approval status of an operator for a given owner\n   * @param _owner     The owner of the Tokens\n   * @param _operator  Address of authorized operator\n   * @return isOperator True if the operator is approved, false if not\n   */\n  function isApprovedForAll(address _owner, address _operator) external view returns (bool isOperator);\n\n}\n"},"IERC1155Metadata.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\npragma solidity \u003e=0.7.4 \u003c=0.8.9;\n\n\ninterface IERC1155Metadata {\n\n  event URI(string _uri, uint256 indexed _id);\n\n  /****************************************|\n  |                Functions               |\n  |_______________________________________*/\n\n  /**\n   * @notice A distinct Uniform Resource Identifier (URI) for a given token.\n   * @dev URIs are defined in RFC 3986.\n   *      URIs are assumed to be deterministically generated based on token ID\n   *      Token IDs are assumed to be represented in their hex format in URIs\n   * @return URI string\n   */\n  function uri(uint256 _id) external view returns (string memory);\n}\n"},"IERC1155TokenReceiver.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\npragma solidity \u003e=0.7.4 \u003c=0.8.9;\n\n\n/**\n * @dev ERC-1155 interface for accepting safe transfers.\n */\ninterface IERC1155TokenReceiver {\n\n  /**\n   * @notice Handle the receipt of a single ERC1155 token type\n   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated\n   * This function MAY throw to revert and reject the transfer\n   * Return of other amount than the magic value MUST result in the transaction being reverted\n   * Note: The token contract address is always the message sender\n   * @param _operator  The address which called the `safeTransferFrom` function\n   * @param _from      The address which previously owned the token\n   * @param _id        The id of the token being transferred\n   * @param _amount    The amount of tokens being transferred\n   * @param _data      Additional data with no specified format\n   * @return           `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n   */\n  function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _amount, bytes calldata _data) external returns(bytes4);\n\n  /**\n   * @notice Handle the receipt of multiple ERC1155 token types\n   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated\n   * This function MAY throw to revert and reject the transfer\n   * Return of other amount than the magic value WILL result in the transaction being reverted\n   * Note: The token contract address is always the message sender\n   * @param _operator  The address which called the `safeBatchTransferFrom` function\n   * @param _from      The address which previously owned the token\n   * @param _ids       An array containing ids of each token being transferred\n   * @param _amounts   An array containing amounts of each token being transferred\n   * @param _data      Additional data with no specified format\n   * @return           `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n   */\n  function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external returns(bytes4);\n}\n"},"IERC1271Wallet.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\npragma solidity \u003e=0.7.4 \u003c=0.8.9;\n\ninterface  IERC1271Wallet {\n  /**\n   * @notice Verifies whether the provided signature is valid with respect to the provided data\n   * @dev MUST return the correct magic value if the signature provided is valid for the provided data\n   *   \u003e The bytes4 magic value to return when signature is valid is 0x20c13b0b : bytes4(keccak256(\"isValidSignature(bytes,bytes)\")\n   *   \u003e This function MAY modify Ethereum\u0027s state\n   * @param _data       Arbitrary length data signed on the behalf of address(this)\n   * @param _signature  Signature byte array associated with _data\n   * @return magicValue Magic value 0x20c13b0b if the signature is valid and 0x0 otherwise\n   *\n   */\n  function isValidSignature(\n    bytes calldata _data,\n    bytes calldata _signature)\n    external\n    view\n    returns (bytes4 magicValue);\n\n  /**\n   * @notice Verifies whether the provided signature is valid with respect to the provided hash\n   * @dev MUST return the correct magic value if the signature provided is valid for the provided hash\n   *   \u003e The bytes4 magic value to return when signature is valid is 0x20c13b0b : bytes4(keccak256(\"isValidSignature(bytes,bytes)\")\n   *   \u003e This function MAY modify Ethereum\u0027s state\n   * @param _hash       keccak256 hash that was signed\n   * @param _signature  Signature byte array associated with _data\n   * @return magicValue Magic value 0x20c13b0b if the signature is valid and 0x0 otherwise\n   */\n  function isValidSignature(\n    bytes32 _hash,\n    bytes calldata _signature)\n    external\n    view\n    returns (bytes4 magicValue);\n}\n"},"IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"INEFTiLicense.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.9;\n\n/*\n**    █▄░█ █▀▀ █▀▀ ▀█▀ █ █▀█ █▀▀ █▀▄ █ ▄▀█\n**    █░▀█ ██▄ █▀░ ░█░ █ █▀▀ ██▄ █▄▀ █ █▀█\n**    ____________________________________\n**    https://neftipedia.com\n**    contact@neftipedia.com\n**/\n\n/** d6147a8a */\ninterface INEFTiLicense {\n    /** 921fe338 */\n    function legalInfo() external view\n        returns (string memory _title, string memory _license, string memory _version, string memory _url);\n}\n"},"INEFTiMTFeeCalcExt.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.9;\n\ninterface INEFTiMTFeeCalcExt {\n    function calculateFee(address holder, uint256 tokenAmount, uint8 fPayMode) external view\n        returns(\n            uint256 bnbFee,\n            uint256 b20Fee,\n            uint256 nftFee\n        );\n\n    function getBaseFee() external view\n        returns(\n            uint256[2] memory bnbMinMax,\n            uint256[2] memory b20MinMax,\n            uint256[2] memory nftMinMax,\n            uint256[3] memory nftFee,\n            uint256[3] memory multitokenFee,\n            uint256 multitokenOnEach,\n            string memory feeAs\n        );\n\n    function getDivider() external view\n        returns(uint256 _defaultDivider);\n\n    function getMintFee(uint256 _amount) external view\n        returns(\n            uint256[3] memory mintFee,\n            uint256 multitokenOnEach,\n            string memory feeAs\n        );\n\n    function getBatchMintFee(uint[] memory _amounts) external view\n        returns(\n            uint256[3] memory mintFee,\n            uint256 multitokenOnEach,\n            string memory feeAs\n        );\n\n    function getDefaultPaymentType() external view\n        returns(\n            uint8 defaultType,\n            string memory defaultTypeAsString\n        );\n}"},"INEFTiMultiTokens.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity \u003e=0.7.4 \u003c=0.8.9;\n\nimport \"./IERC1155.sol\";\n\ninterface INEFTiMultiTokens is IERC1155 {\n\n    /*════════════oooooOooooo═════════════╗\n    ║█~~~~~~~~~~~~ FUNCTIONS ~~~~~~~~~~~~█║\n    ╚════════════════════════════════════*/\n\n    /**\n    ** @notice Transfers amount of an _id from the _from address to the _to address specified\n    ** @dev MUST emit TransferSingle event on success\n    ** Caller must be approved to manage the _from account\u0027s tokens (see isApprovedForAll)\n    ** MUST throw if `_to` is the zero address\n    ** MUST throw if balance of sender for token `_id` is lower than the `_amount` sent\n    ** MUST throw on any other error\n    ** When transfer is complete, this function MUST check if `_to` is a smart contract (code size \u003e 0). If so, it MUST call `onERC1155Received` on `_to` and revert if the return amount is not `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n    ** @param _from    Source address\n    ** @param _to      Target address\n    ** @param _id      ID of the token type\n    ** @param _amount  Transfered amount\n    ** @param _data    Additional data with no specified format, sent in call to `_to`\n    **/\n    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes calldata _data) external override (IERC1155);\n\n    /**\n    ** @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\n    ** @dev MUST emit TransferBatch event on success\n    ** Caller must be approved to manage the _from account\u0027s tokens (see isApprovedForAll)\n    ** MUST throw if `_to` is the zero address\n    ** MUST throw if length of `_ids` is not the same as length of `_amounts`\n    ** MUST throw if any of the balance of sender for token `_ids` is lower than the respective `_amounts` sent\n    ** MUST throw on any other error\n    ** When transfer is complete, this function MUST check if `_to` is a smart contract (code size \u003e 0). If so, it MUST call `onERC1155BatchReceived` on `_to` and revert if the return amount is not `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n    ** Transfers and events MUST occur in the array order they were submitted (_ids[0] before _ids[1], etc)\n    ** @param _from     Source addresses\n    ** @param _to       Target addresses\n    ** @param _ids      IDs of each token type\n    ** @param _amounts  Transfer amounts per token type\n    ** @param _data     Additional data with no specified format, sent in call to `_to`\n    **/\n    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external override(IERC1155);\n\n    /**\n    ** @notice Get the balance of an account\u0027s Tokens\n    ** @param _owner  The address of the token holder\n    ** @param _id     ID of the Token\n    ** @return        The _owner\u0027s balance of the Token type requested\n    **/\n    function balanceOf(address _owner, uint256 _id) external view  override(IERC1155) returns (uint256);\n\n    /**\n    ** @notice Get the balance of multiple account/token pairs\n    ** @param _owners The addresses of the token holders\n    ** @param _ids    ID of the Tokens\n    ** @return        The _owner\u0027s balance of the Token types requested (i.e. balance for each (owner, id) pair)\n    **/\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view override(IERC1155) returns (uint256[] memory);\n\n    /**\n    ** @notice Enable or disable approval for a third party (\"operator\") to manage all of caller\u0027s tokens\n    ** @dev MUST emit the ApprovalForAll event on success\n    ** @param _operator  Address to add to the set of authorized operators\n    ** @param _approved  True if the operator is approved, false to revoke approval\n    **/\n    function setApprovalForAll(address _operator, bool _approved) external override(IERC1155);\n\n    /**\n    ** @notice Queries the approval status of an operator for a given owner\n    ** @param _owner     The owner of the Tokens\n    ** @param _operator  Address of authorized operator\n    ** @return isOperator True if the operator is approved, false if not\n    **/\n    function isApprovedForAll(address _owner, address _operator) external view override(IERC1155) returns (bool isOperator);\n\n\n    /*════════════oooooOooooo═════════════╗\n    ║█~~~~~~~~~ TOKEN PROPERTIES ~~~~~~~~█║\n    ╚════════════════════════════════════*/\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n\n\n    /*════════════oooooOooooo═════════════╗\n    ║█~~~~~~~~~~~ MINT \u0026 BURN ~~~~~~~~~~~█║\n    ╚════════════════════════════════════*/\n\n    function mint(address _to, uint256 _id, uint256 _value, bytes memory _data) external payable;\n\n    function batchMint(address _to, uint256[] memory _ids, uint256[] memory _values, bytes memory _data) external payable;\n\n    function burn(address _from, uint256 _id, uint256 _value) external;\n\n    function batchBurn(address _from, uint256[] memory _ids, uint256[] memory _values) external;\n\n\n    /*════════════oooooOooooo═════════════╗\n    ║█~~~~~~~~~~~~ UTILITIES ~~~~~~~~~~~~█║\n    ╚════════════════════════════════════*/\n\n    function requestId() external;\n\n    function totalSupply(uint256 _id) external view returns(uint256);\n\n    function minterOf(uint256 _id) external view returns (address);\n\n    function itemsOf(address _holder) external view returns (uint256[] memory);\n\n    function getMintFee(uint256 amount) external view returns(uint256[3] memory mintFee, uint256 multitokenOnEach, string memory feeAs);\n\n    function getBatchMintFee(uint[] memory _amounts) external view returns(uint256[3] memory mintFee, uint256 multitokenOnEach, string memory feeAs);\n\n}\n\n/**\n**    █▄░█ █▀▀ █▀▀ ▀█▀ █ █▀█ █▀▀ █▀▄ █ ▄▀█\n**    █░▀█ ██▄ █▀░ ░█░ █ █▀▀ ██▄ █▄▀ █ █▀█\n**    ____________________________________\n**    https://neftipedia.com\n**    contact@neftipedia.com\n**/\n"},"LibBytes.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n/*\n  Copyright 2018 ZeroEx Intl.\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n  http://www.apache.org/licenses/LICENSE-2.0\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n  This is a truncated version of the original LibBytes.sol library from ZeroEx.\n*/\n\npragma solidity \u003e=0.7.4 \u003c=0.8.9;\n\nlibrary LibBytes {\n  using LibBytes for bytes;\n\n  /***********************************|\n  |        Pop Bytes Functions        |\n  |__________________________________*/\n\n  /**\n   * @dev Pops the last byte off of a byte array by modifying its length.\n   * @param b Byte array that will be modified.\n   * @return result The byte that was popped off.\n   */\n  function popLastByte(bytes memory b)\n    internal\n    pure\n    returns (bytes1 result)\n  {\n    require(\n      b.length \u003e 0,\n      \"ENEFTiLB__popLastByte__GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n    );\n\n    // Store last byte.\n    result = b[b.length - 1];\n\n    assembly {\n      // Decrement length of byte array.\n      let newLen := sub(mload(b), 1)\n      mstore(b, newLen)\n    }\n    return result;\n  }\n\n\n  /***********************************|\n  |        Read Bytes Functions       |\n  |__________________________________*/\n\n  /**\n   * @dev Reads a bytes32 value from a position in a byte array.\n   * @param b Byte array containing a bytes32 value.\n   * @param index Index in byte array of bytes32 value.\n   * @return result bytes32 value from byte array.\n   */\n  function readBytes32(\n    bytes memory b,\n    uint256 index\n  )\n    internal\n    pure\n    returns (bytes32 result)\n  {\n    require(\n      b.length \u003e= index + 32,\n      \"ENEFTiLB__readBytes32__GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n    );\n\n    // Arrays are prefixed by a 256 bit length parameter\n    index += 32;\n\n    // Read the bytes32 from array memory\n    assembly {\n      result := mload(add(b, index))\n    }\n    return result;\n  }\n}"},"LibEIP712.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n// https://github.com/0xsequence/erc-1155/blob/master/src/contracts/utils/LibEIP712.sol\n\n/**\n * Copyright 2018 ZeroEx Intl.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *   http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity \u003e=0.7.4 \u003c=0.8.9;\n\n\ncontract LibEIP712 {\n\n  /***********************************|\n  |             Constants             |\n  |__________________________________*/\n\n  // keccak256( \"EIP712Domain(address verifyingContract)\" );\n  bytes32 internal constant DOMAIN_SEPARATOR_TYPEHASH = 0x035aff83d86937d35b32e04f0ddc6ff469290eef2f1b692d8a815c89404d4749;\n\n  // EIP-191 Header\n  string constant internal EIP191_HEADER = \"\\\\x19\\\\x01\";\n\n  /***********************************|\n  |          Hashing Function         |\n  |__________________________________*/\n\n  /**\n   * @dev Calculates EIP712 encoding for a hash struct in this EIP712 Domain.\n   * @param hashStruct The EIP712 hash struct.\n   * @return result EIP712 hash applied to this EIP712 Domain.\n   */\n  function hashEIP712Message(bytes32 hashStruct)\n      internal\n      view\n      returns (bytes32 result)\n  {\n    return keccak256(\n      abi.encodePacked(\n        EIP191_HEADER,\n        keccak256(\n          abi.encode(\n            DOMAIN_SEPARATOR_TYPEHASH,\n            address(this)\n          )\n        ),\n        hashStruct\n    ));\n  }\n}\n"},"Neftipedia.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity \u003e=0.7.4 \u003c=0.8.9;\npragma experimental ABIEncoderV2;\n\nimport \"./INEFTiLicense.sol\";\nimport \"./ERC1155MintBurnPackedBalance.sol\";\n\n/** 8662deae */\ncontract Neftipedia is ERC1155MintBurnPackedBalance {\n    bytes32 public version = keccak256(\"1.10.55\");\n    /** MultiTokens Info */\n    string private _name;\n    string private _symbol;\n    address private _legalInfo;\n\n    /** 5fff73ee */\n    function name() public override view virtual returns (string memory) { return _name; }\n    /** 77bde41b */\n    function symbol() public override view virtual returns (string memory) { return _symbol; }\n\n\n    /*════════════oooooOooooo═════════════╗\n    ║█~~~~~~~~~~~~~ ERC165 ~~~~~~~~~~~~~~█║\n    ╚════════════════════════════════════*/\n    \n    /**\n    ** 3986ebc7\n    ** @notice Query if a contract implements an interface\n    ** @dev Parent contract inheriting multiple contracts with supportsInterface()\n    **      need to implement an overriding supportsInterface() function specifying\n    **      all inheriting contracts that have a supportsInterface() function.\n    ** @param _interfaceID The interface identifier, as specified in ERC-165\n    ** @return `true` if the contract implements `_interfaceID`\n    **/\n    function supportsInterface(bytes4 _interfaceID)\n        public view virtual\n        override( ERC1155PackedBalance )\n        returns (bool)\n    { return super.supportsInterface(_interfaceID); }\n\n    /**\n    ** 1288e0ce\n    ** @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n    **/\n    constructor (\n        string memory name_,\n        string memory symbol_,\n        string memory baseMetadataURI_,\n        address calcFeeExt_,\n        address legalInfo_\n    )\n    {\n        _name = name_;\n        _symbol = symbol_;\n        _legalInfo = legalInfo_;\n        _setBaseMetadataURI(baseMetadataURI_);\n        setCalcFeeExt(calcFeeExt_);\n    }\n\n\n    /*════════════oooooOooooo═════════════╗\n    ║█~~~~~~~~~~~~~ MINTING ~~~~~~~~~~~~~█║\n    ╚════════════════════════════════════*/\n    \n    /**\n    ** 7de1cf6\n    ** @dev Mint _value of tokens of a given id\n    ** @param _to The address to mint tokens to.\n    ** @param _id token id to mint\n    ** @param _value The amount to be minted\n    ** @param _data Data to be passed if receiver is contract\n    **/\n    function mint(address _to, uint256 _id, uint256 _value, bytes memory _data)\n        public override payable\n    {\n        require(\n            _to != address(0) \u0026\u0026\n            _value \u003e 0,\n            \"ENEFTiMP.01.INVALID_ARGUMENTS\"\n        );\n        _mint(_to, _id, _value, _data);\n    }\n    \n    /**\n    ** 57392d88\n    ** @dev Mint tokens for each ids in _ids\n    ** @param _to The address to mint tokens to.\n    ** @param _ids Array of ids to mint\n    ** @param _values Array of amount of tokens to mint per id\n    ** @param _data Data to be passed if receiver is contract\n    **/\n    function batchMint(address _to, uint256[] memory _ids, uint256[] memory _values, bytes memory _data)\n        public override payable\n    { _batchMint(_to, _ids, _values, _data); }\n\n\n    /*════════════oooooOooooo═════════════╗\n    ║█~~~~~~~~~~~~~ BURNING ~~~~~~~~~~~~~█║\n    ╚════════════════════════════════════*/\n    \n    /**\n    ** ceb8d4bb\n    ** @dev burn _value of tokens of a given token id\n    ** @param _from The address to burn tokens from.\n    ** @param _id token id to burn\n    ** @param _value The amount to be burned\n    **/\n    function burn(address _from, uint256 _id, uint256 _value)\n        public override\n    { _burn(_from, _id, _value); }\n\n    /**\n    ** e20954ea\n    ** @dev burn _value of tokens of a given token id\n    ** @param _from The address to burn tokens from.\n    ** @param _ids Array of token ids to burn\n    ** @param _values Array of the amount to be burned\n    **/\n    function batchBurn(address _from, uint256[] memory _ids, uint256[] memory _values)\n        public override\n    { _batchBurn(_from, _ids, _values); }\n\n    /**\n    ** 1955f1b8\n    ** @dev Show legal info\n    ** @return (\n    **    string title,\n    **    string license,\n    **    string version,\n    **    string url\n    ** )\n    **/\n    function legalInfo()\n        public view\n        returns (string memory _title, string memory _license, string memory _version, string memory _url)\n    { (_title, _license, _version, _url) = INEFTiLicense(_legalInfo).legalInfo(); }\n\n    /**\n    ** 31084f3e\n    ** @dev Update legal info\n    ** @param _newLegalInfo Updated info\n    **/\n    function updateLicense(address _newLegalInfo)\n        public onlyOwner\n    { _legalInfo = _newLegalInfo; }\n\n\n    /*════════════════════════════oooooOooooo════════════════════════════╗\n    ║█  (!) WARNING  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~█║\n    ╚════════════════════════════════════════════════════════════════════╝\n    ║  There are no handler in fallback function,                        ║\n    ║  If there are any incoming value directly to Smart Contract, will  ║\n    ║  considered as generous donation. And Thank you!                   ║\n    ╚═══════════════════════════════════════════════════════════════════*/\n    receive () external payable /* nonReentrant */ {}\n    fallback () external payable /* nonReentrant */ {}\n}\n\n/**\n**    █▄░█ █▀▀ █▀▀ ▀█▀ █ █▀█ █▀▀ █▀▄ █ ▄▀█\n**    █░▀█ ██▄ █▀░ ░█░ █ █▀▀ ██▄ █▄▀ █ █▀█\n**    ____________________________________\n**    https://neftipedia.com\n**    contact@neftipedia.com\n**/\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT OR Apache-2.0\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\n\npragma solidity \u003e=0.7.4 \u003c=0.8.9;\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address private _owner_;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor () {\n    _owner_ = msg.sender;\n    emit OwnershipTransferred(address(0), _owner_);\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == _owner_, \"ENEFTiOA__onlyOwner__SENDER_IS_NOT_OWNER\");\n    _;\n  }\n\n  /**\n   * @notice Transfers the ownership of the contract to new address\n   * @param _newOwner Address of the new owner\n   */\n  function transferOwnership(address _newOwner)\n    public onlyOwner\n  {\n    require(_newOwner != address(0), \"ENEFTiOA__transferOwnership__INVALID_ADDRESS\");\n    emit OwnershipTransferred(_owner_, _newOwner);\n    _owner_ = _newOwner;\n  }\n\n  /**\n   * @notice Returns the address of the owner.\n   */\n  function owner()\n    public view\n    returns (address)\n  { return _owner_; }\n}"},"SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IERC20.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \u0027safeIncreaseAllowance\u0027 and \u0027safeDecreaseAllowance\u0027\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\u0027s return data size checking mechanism, since\n        // we\u0027re implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler\u0027s built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations.\n *\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c \u003c a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b \u003e a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n            // benefit is lost if \u0027b\u0027 is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003c= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003e 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003e 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"},"SignatureValidator.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n// https://github.com/0xsequence/erc-1155/blob/master/src/contracts/utils/SignatureValidator.sol\n\npragma solidity \u003e=0.7.4 \u003c=0.8.9;\n\nimport \"./IERC1271Wallet.sol\";\nimport \"./LibBytes.sol\";\nimport \"./LibEIP712.sol\";\n\n/**\n * @dev Contains logic for signature validation.\n * Signatures from wallet contracts assume ERC-1271 support (https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1271.md)\n * Notes: Methods are strongly inspired by contracts in https://github.com/0xProject/0x-monorepo/blob/development/\n */\ncontract SignatureValidator is LibEIP712 {\n  using LibBytes for bytes;\n\n  /***********************************|\n  |             Variables             |\n  |***********************************/\n\n  // bytes4(keccak256(\"isValidSignature(bytes,bytes)\"))\n  bytes4 constant internal ERC1271_MAGICVALUE = 0x20c13b0b;\n\n  // bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))\n  bytes4 constant internal ERC1271_MAGICVALUE_BYTES32 = 0x1626ba7e;\n\n  // uint256 public chainId;\n  // address private _cVerify;\n  // bytes32 public NCS; // NEFTi Content Salt\n  // bytes32 public constant EIP712_DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)\");\n  // bytes32 public constant NEFTi_IDENTITY_TYPEHASH = keccak256(\"NEFTiIdentity(address wallet,uint256 tokenId,uint256 nonce)\");\n  // bytes32 public EIP712_DOMAIN_SEPARATOR;\n\n  // Allowed signature types.\n  enum SignatureType {\n    Illegal,         // 0x00, default value\n    EIP712,          // 0x01\n    EthSign,         // 0x02\n    WalletBytes,     // 0x03 To call isValidSignature(bytes, bytes) on wallet contract\n    WalletBytes32,   // 0x04 To call isValidSignature(bytes32, bytes) on wallet contract\n    NSignatureTypes  // 0x05, number of signature types. Always leave at end.\n  }\n\n  // uint8 private test = 0;\n  // event Logger(uint8 log);\n  // event Logger(bytes32 log);\n  // event Logger(address log);\n\n\n  /***********************************|\n  |        Signature Functions        |\n  |***********************************/\n\n  /**\n   * @dev Verifies that a hash has been signed by the given signer.\n   * @param _signerAddress  Address that should have signed the given hash.\n   * @param _hash           Hash of the EIP-712 encoded data\n   * @param _data           Full EIP-712 data structure that was hashed and signed\n   * @param _sig            Proof that the hash has been signed by signer.\n   *      For non wallet signatures, _sig is expected to be an array tightly encoded as\n   *      (bytes32 r, bytes32 s, uint8 v, uint256 nonce, SignatureType sigType)\n   * @return isValid True if the address recovered from the provided signature matches the input signer address.\n   */\n  function isValidSignature(\n    address _signerAddress,\n    bytes32 _hash,\n    bytes memory _data,\n    bytes memory _sig\n  )\n    public\n    view\n    returns (bool isValid, address signer)\n  {\n    require(\n      _sig.length \u003e 0,\n      \"ENEFTiSV.isValidSignature.LENGTH_GREATER_THAN_0_REQUIRED\"\n    );\n\n    require(\n      _signerAddress != address(0x0),\n      \"ENEFTiSV.isValidSignature.INVALID_SIGNER\"\n    );\n\n    // Pop last byte off of signature byte array.\n    uint8 signatureTypeRaw = uint8(_sig.popLastByte());\n\n    // Ensure signature is supported\n    require(\n      signatureTypeRaw \u003c uint8(SignatureType.NSignatureTypes),\n      \"ENEFTiSV.isValidSignature.UNSUPPORTED_SIGNATURE\"\n    );\n\n    // Extract signature type\n    SignatureType signatureType = SignatureType(signatureTypeRaw);\n\n    // Variables are not scoped in Solidity.\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n    address recovered;\n\n    // Always illegal signature.\n    // This is always an implicit option since a signer can create a\n    // signature array with invalid type or length. We may as well make\n    // it an explicit option. This aids testing and analysis. It is\n    // also the initialization value for the enum type.\n    if (signatureType == SignatureType.Illegal) {\n      revert(\"ENEFTiSV.isValidSignature.ILLEGAL_SIGNATURE\");\n    }\n    \n    // Signature using EIP712\n    else if (signatureType == SignatureType.EIP712) {\n      require(\n        _sig.length == 97,\n        \"ENEFTiSV.isValidSignature.LENGTH_97_REQUIRED\"\n      );\n      r = _sig.readBytes32(0);\n      s = _sig.readBytes32(32);\n      v = uint8(_sig[64]);\n      recovered = ecrecover(_hash, v, r, s);\n      isValid = _signerAddress == recovered;\n      return (isValid, recovered);\n    }\n    \n    // Signed using web3.eth_sign() or Ethers wallet.signMessage()\n    else if (signatureType == SignatureType.EthSign) {\n      require(\n        _sig.length == 97,\n        \"ENEFTiSV.isValidSignature.LENGTH_97_REQUIRED\"\n      );\n      r = _sig.readBytes32(0);\n      s = _sig.readBytes32(32);\n      v = uint8(_sig[64]);\n      recovered = ecrecover(\n        keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _hash)),\n        v,\n        r,\n        s\n      );\n      isValid = _signerAddress == recovered;\n      return (isValid, recovered);\n    }\n\n    // Signature verified by wallet contract with data validation.\n    else if (signatureType == SignatureType.WalletBytes) {\n      isValid = ERC1271_MAGICVALUE == IERC1271Wallet(_signerAddress).isValidSignature(_data, _sig);\n      return (isValid, address(0x0));\n    }\n\n    // Signature verified by wallet contract without data validation.\n    else if (signatureType == SignatureType.WalletBytes32) {\n      isValid = ERC1271_MAGICVALUE_BYTES32 == IERC1271Wallet(_signerAddress).isValidSignature(_hash, _sig);\n      return (isValid, address(0x0));\n    }\n\n    // Anything else is illegal (We do not return false because\n    // the signature may actually be valid, just not in a format\n    // that we currently support. In this case returning false\n    // may lead the caller to incorrectly believe that the\n    // signature was invalid.)\n    else { revert(\"ENEFTiSV.isValidSignature.UNSUPPORTED_SIGNATURE\"); }\n  }\n}\n"}}