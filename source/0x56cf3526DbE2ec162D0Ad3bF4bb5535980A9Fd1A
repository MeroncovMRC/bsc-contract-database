// SPDX-License-Identifier: MIT



//   (((,                                                                     */// 
//    ((((#**                                                               **///// 
//    ((((####///                                                       ***(/////// 
//     (((#######///                                                 ***((((//////  
//     (((##########////                                         ****(((((((//////  
//     (((############/////                                   ****/(((((((((//////  
//     (((###############////////////////////////////////////***((((((((((((//////  
//     (((##################/////////////////////////////////###((((((((((((//////  
//      ((#####################///////////////////////////######((((((((((((/////   
//      ((######################/////////////////////////#######((((((((((((/////   
//      ((######################%///////////////////////########((((((((((((/////   
//      ((######################%///////////////////////########((((((((((((/////   
//      ((######################%%/////////////////////#########((((((((((((////*   
//     **(######################%%%///////////////////##########((((((((((((////**                            
//     **(######################%%%///////////////////##########((((((((((((////**                      
//    ****#############@@@@@####%%%%/////////////////#######@@@@@((((((((((///***,         
//    ****##############@@@@@@@@@%%%////////////////####@@@@@@@@@(((((((((((///***,      
//   .****################@@@@&#%%%%%///////////////######&@@@@@((((((((((((///***,     
//   ******#####################%%%%%%/////////////#############((((((((((((//****,,     
//   ******#####################%%%%%%/////////////#############((((((((((((//****,, 
//    *******###################%%%%%%%///////////%#############((((((((((((******,  
//       *****///###############%%%%%%%%/////////%%#############((((((((********    
//          **//////############%%%%%%%%/////////%%#############(((((********       
//             /////////########%%%%%%%%%///////%%%#############(********,          
//                *///////######%%%%%%%%%///////%%%############*******              
//                   ////######%%%%%%%%%%/////%%%%###########(****                 
//                        //#####%%%%%%%%%%%///%%%%%###########**                    
//                         #####%%%%%%%%%%%///%%%%%##########/                      
//                          ####%%%%%%%%%%%%/%%%%%%##########                       
//                          /###%%%%%%%%@&%%(%%&&%%#########/                       
//                           //#%%%%%%@@@@@@@@@@@@@#######//                        
//                           ///%%%%%%%@@@@@@@@@@@%######///                        
//                            ////%%%%%%%%@@@@@@%%%####////                         
//                              ///%%%%%%%%///%%%%%###///                           
//                                ///%%%%///////%%%#///                             
//                                   /%%/////////%%/    






pragma solidity ^0.8.12;
pragma experimental ABIEncoderV2;

// IERC20 interface taken from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol)
interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

// Context abstract contract taken from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

// SafeMath library taken from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol
library SafeMath {

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }


    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}

// Address library taken from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol
library Address {
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.

        uint256 size;
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }

    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCall(target, data, "Address: low-level call failed");
    }

    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");

        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");

        (bool success, bytes memory returndata) = target.staticcall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(isContract(target), "Address: delegate call to non-contract");

        (bool success, bytes memory returndata) = target.delegatecall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function _verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) private pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length > 0) {
                // The easiest way to bubble the revert reason is using memory via assembly

                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

// Ownable abstract contract taken from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _setOwner(_msgSender());
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

/**
 * @dev The official RainbowToken smart contract
 */
contract WenDistributionToken is Context, IERC20, Ownable {
    using SafeMath for uint256;
    using Address for address;
    
    // General Info
    string private _name     = "WenDistributionToken";
    string private _symbol   = "WENDT";
    uint8  private _decimals = 9;
    
    
    // Balances
    mapping (address => uint256) private _tOwned;
    mapping (address => mapping (address => uint256)) private _allowances;


    // Supply
    uint256 private constant MAX = ~uint256(0);
    uint256 private _tTotal = 6 * 10**8 * 10**9;
    
    
    //The Holder struct for the holders array to get all holder addresses and the balance
    struct Holder{
        address holderAddress;
        uint256 holderBalance;
    }

    //Holder Array which will be given back in the Getter Function
    Holder[] holders;

    constructor () {
        // Mint the total reflection balance to the deployer of this contract
        _tOwned[_msgSender()] = _tTotal;
        // Adds Contract creator to Holder List
        holders.push(Holder(_msgSender(),_tTotal));
    }
    
    /**
     * @notice Required to recieve BNB from PancakeSwap V2 Router when swaping
     */
    receive() external payable {}
        function allowance(address owner, address spender) external view override returns (uint256) {
        return _allowances[owner][spender];
    }

    //Returns the Holder Array with all Holders
    function returnHolder() public view returns(Holder[] memory){
        return holders;
    }

    //Approves the addresses and returns true if they are allowed
    function approve(address spender, uint256 amount) external override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    //You can choose form where to where the tokens should be transferred
    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    //Increases the Allowance of valid addresses
    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    //Decreases the allowance of valid addresses
    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    //approves if address is allowed to transfer
    function _approve(address owner, address spender, uint256 amount) private {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @notice Withdraws non-RAINBOW tokens that are stuck as to not interfere with the liquidity
     */
    function withdrawForeignToken(address token) public onlyOwner() {
        require(address(this) != address(token), "Cannot withdraw native token");
        IERC20(address(token)).transfer(msg.sender, IERC20(token).balanceOf(address(this)));
    }
    
    /**
     * @notice Transfers BNB to an address
     */
    function transferBNBToAddress(address payable recipient, uint256 amount) private {
        recipient.transfer(amount);
    }
    
    function name() external view returns (string memory) {
        return _name;
    }

    function symbol() external view returns (string memory) {
        return _symbol;
    }

    function decimals() external view returns (uint8) {
        return _decimals;
    }

    function totalSupply() external view override returns (uint256) {
        return _tTotal;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _tOwned[account];
    }

    function transfer(address recipient, uint256 amount) external override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }
   
    /**
     * @notice Handles the before and after of a token transfer, such as taking fees and firing off a swap and liquify event
     */
    function _transfer(address from, address to, uint256 amount) private {
        require(from != address(0), "ERC20: transfer from the zero address");
        require(to != address(0), "ERC20: transfer to the zero address");
        require(amount > 0, "Transfer amount must be greater than zero");
        
        // Transfer the token amount from sender to receipient.
        _tokenTransfer(from, to, amount);
    }
    
    /**
     * @notice Handles the actual token transfer
     */
    function _tokenTransfer(address sender, address recipient, uint256 tAmount) private {
        
        //Decrease the total amount of sender
		_tOwned[sender] = _tOwned[sender] - tAmount;

        //Increase the total amount of receiver
		_tOwned[recipient] = _tOwned[recipient] + tAmount;
		
        //Updates the Holder array _holders
        _addOrUpdateHolderList(sender,_tOwned[sender]);

        //Updates the Holder array _holders
        _addOrUpdateHolderList(recipient,_tOwned[recipient]);

        // Emit an event 
        emit Transfer(sender, recipient, tAmount);
    }

    /**
     * @notice Updates the holder array that can be called from outside
     */
    function _addOrUpdateHolderList(address addr, uint256 amount) private {
        bool inList = false;
        //look if receiver is already in the holder list and update the amount
        for(uint i = 0; i < holders.length; i++){
            if(holders[i].holderAddress == addr){
                holders[i].holderBalance = amount;
                inList = true;
            }
        }

        //if the receiver is not in the list, it gets added
        if(!inList){
            holders.push(Holder(addr,amount));
        }
    }
}