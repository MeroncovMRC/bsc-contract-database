// SPDX-License-Identifier: MIT

pragma solidity 0.8.19;

interface IERC20 {
  function transfer(address recipient, uint256 amount) external returns (bool);
  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

contract permission {
    mapping(address => mapping(string => bytes32)) private permit;

    function newpermit(address adr,string memory str) internal { permit[adr][str] = bytes32(keccak256(abi.encode(adr,str))); }

    function clearpermit(address adr,string memory str) internal { permit[adr][str] = bytes32(keccak256(abi.encode("null"))); }

    function checkpermit(address adr,string memory str) public view returns (bool) {
        if(permit[adr][str]==bytes32(keccak256(abi.encode(adr,str)))){ return true; }else{ return false; }
    }

    modifier forRole(string memory str) {
        require(checkpermit(msg.sender,str),"Permit Revert!");
        _;
    }
}

contract BWGMasterChef is permission {

    event Deposit(address indexed from,address indexed to,uint256 amount,uint256 blockstamp);
    event Withdraw(address indexed to,uint256 amount,uint256 blockstamp);
    event Claim(address indexed to,uint256 amount,uint256 blockstamp);
    
    struct userInfo {
        uint256 amount;
        uint256 rewards;
        uint256 rewardDebt;
    }

    address public treasury;

    address public rewardToken;
    address public lpToken;
    address public _owner;

    uint256 public rewardPerBlock;
    uint256 public totalSupply;
    uint256 public latestBlock;
    uint256 public accumulated;
    bool public poolActived;

    mapping(address => userInfo) public user;

    constructor() {
        rewardPerBlock = 115740740740741;
        rewardToken = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;
        lpToken = 0xa261A6C7Fe2E88D74ec2b2899FAac7da68e6381d;
        _owner = msg.sender;
        newpermit(_owner,"owner");
    }

    function deposit(address addr,uint256 amount) external returns (bool) {
        require(amount > 0, "Deposit amount can't be zero");
        require(poolActived,"Pool Was Not Actived");
        harvestRewards(addr);
        uint256 fee = amount * 2 / 100;
        amount = amount - fee;
        IERC20(lpToken).transferFrom(msg.sender,treasury,fee);
        user[addr].amount = user[addr].amount + amount;
        user[addr].rewardDebt = user[addr].amount * accumulated / 1e12;
        totalSupply = totalSupply + amount;
        IERC20(lpToken).transferFrom(msg.sender,address(this),amount);
        emit Deposit(msg.sender,addr,amount,block.timestamp);
        return true;
    }

    function withdraw() external returns (bool) {
        address addr = msg.sender;
        uint256 amount = user[addr].amount;
        require(amount > 0, "Withdraw amount can't be zero");
        harvestRewards(addr);
        user[addr].amount = 0;
        user[addr].rewardDebt = user[addr].amount * accumulated / 1e12;
        totalSupply = totalSupply - amount;
        IERC20(lpToken).transfer(addr,amount);
        emit Withdraw(msg.sender,amount,block.timestamp);
        return true;
    }

    function claimHarvestRewards() public returns (bool) {
        harvestRewards(msg.sender);
        return true;
    }

    function harvestRewards(address addr) internal {
        updatePoolRewards();
        uint256 rewardsToHarvest = (user[addr].amount * accumulated / 1e12) - user[addr].rewardDebt;
        if (rewardsToHarvest == 0) {
            user[addr].rewardDebt = user[addr].amount * accumulated / 1e12;
            return;
        }
        user[addr].rewards = 0;
        user[addr].rewardDebt = user[addr].amount * accumulated / 1e12;
        if(rewardsToHarvest>0){
            IERC20(rewardToken).transferFrom(treasury,addr,rewardsToHarvest);
            emit Claim(msg.sender,rewardsToHarvest,block.timestamp);
        }
    }

    function updatePoolRewards() internal {
        if (totalSupply == 0) {
            latestBlock = block.timestamp;
            return;
        }
        uint256 period = block.timestamp - latestBlock;
        uint256 rewards = period * rewardPerBlock;
        accumulated = accumulated + (rewards * 1e12 / totalSupply);
        latestBlock = block.timestamp;
    }

    function pendingReward(address addr) external view returns (uint256) {
        if (totalSupply == 0) { return 0; }
        uint256 period = block.timestamp - latestBlock;
        uint256 rewards = period * rewardPerBlock;
        uint256 t_accumulated = accumulated + (rewards * 1e12 / totalSupply);
        return (user[addr].amount * t_accumulated / 1e12) - user[addr].rewardDebt;
    }

    function poolActiveToggle() public forRole("owner") returns (bool) {
        poolActived = !poolActived;
        return true;
    }

    function updateTokenAddress(address[] memory Addresses) external forRole("owner") returns (bool) {
        rewardToken = Addresses[0];
        lpToken = Addresses[1];
        treasury = Addresses[2];
        return true;
    }

    function updateRewardPerBlock(uint256 amount) external forRole("owner") returns (bool) {
        rewardPerBlock = amount;
        updatePoolRewards();
        return true;
    }

    function grantRole(address adr,string memory role) public forRole("owner") returns (bool) {
        newpermit(adr,role);
        return true;
    }

    function revokeRole(address adr,string memory role) public forRole("owner") returns (bool) {
        clearpermit(adr,role);
        return true;
    }

    function transferOwnership(address adr) public forRole("owner") returns (bool) {
        newpermit(adr,"owner");
        clearpermit(msg.sender,"owner");
        _owner = adr;
        return true;
    }

}