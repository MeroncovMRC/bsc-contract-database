// Sources flattened with hardhat v2.13.0 https://hardhat.org

// File contracts/interface/IBEP20.sol

// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.9;

interface IBEP20 {
  /**
   * @dev Returns the amount of tokens in existence.
   */
  function totalSupply() external view returns (uint256);

  /**
   * @dev Returns the token decimals.
   */
  function decimals() external view returns (uint8);

  /**
   * @dev Returns the token symbol.
   */
  function symbol() external view returns (string memory);

  /**
  * @dev Returns the token name.
  */
  function name() external view returns (string memory);

  /**
   * @dev Returns the bep token owner.
   */
  function getOwner() external view returns (address);

  /**
   * @dev Returns the amount of tokens owned by `account`.
   */
  function balanceOf(address account) external view returns (uint256);

  /**
   * @dev Moves `amount` tokens from the caller's account to `recipient`.
   *
   * Returns a boolean value indicating whether the operation succeeded.
   *
   * Emits a {Transfer} event.
   */
  function transfer(address recipient, uint256 amount) external returns (bool);

  /**
   * @dev Returns the remaining number of tokens that `spender` will be
   * allowed to spend on behalf of `owner` through {transferFrom}. This is
   * zero by default.
   *
   * This value changes when {approve} or {transferFrom} are called.
   */
  function allowance(address _owner, address spender) external view returns (uint256);

  /**
   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
   *
   * Returns a boolean value indicating whether the operation succeeded.
   *
   * IMPORTANT: Beware that changing an allowance with this method brings the risk
   * that someone may use both the old and the new allowance by unfortunate
   * transaction ordering. One possible solution to mitigate this race
   * condition is to first reduce the spender's allowance to 0 and set the
   * desired value afterwards:
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   *
   * Emits an {Approval} event.
   */
  function approve(address spender, uint256 amount) external returns (bool);

  /**
   * @dev Moves `amount` tokens from `sender` to `recipient` using the
   * allowance mechanism. `amount` is then deducted from the caller's
   * allowance.
   *
   * Returns a boolean value indicating whether the operation succeeded.
   *
   * Emits a {Transfer} event.
   */
  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

  /**
   * @dev Emitted when `value` tokens are moved from one account (`from`) to
   * another (`to`).
   *
   * Note that `value` may be zero.
   */
  event Transfer(address indexed from, address indexed to, uint256 value);

  /**
   * @dev Emitted when the allowance of a `spender` for an `owner` is set by
   * a call to {approve}. `value` is the new allowance.
   */
  event Approval(address indexed owner, address indexed spender, uint256 value);
}


// File contracts/contract/Investment.sol

pragma solidity ^0.8.9;
// import "hardhat/console.sol";
contract Investment {
    string private letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    string private adminCode = "ADMIN";
    string private firstCode = "GANESH";
    address token = 0x55d398326f99059fF775485246999027B3197955;
    uint256 counter = 1;
    uint8 digit = 18;
    uint256 private userCount = 0;
    uint8 private length = 6;
    address private admin;
    address private company;
    uint256[] public slots = [
        20 * 10 ** 18,
        40 * 10 ** 18,
        80 * 10 ** 18,
        160 * 10 ** 18,
        320 * 10 ** 18,
        640 * 10 ** 18,
        1280 * 10 ** 18,
        2560 * 10 ** 18,
        5120 * 10 ** 18
    ];
    struct History {
        string from;
        string transactionType;
        uint256 amount;
        uint256 timestamp;
    }
    struct Node {
        string user;
        bool status;
    }
    struct Tree {
        uint256 count;
        Node[] nodes;
    }
    struct User {
        uint256 id;
        address wallet;
        string referrer;
        string referralCode;
        uint8 startRank;
        uint8 currentRank;
        uint256 missingIncentive;
        uint8 childNum;
        uint256 referralEarning;
        uint256 pool1Earning;
        uint256 pool2Earning;
        uint256 pool3Earning;
        uint256 pool4Earning;
        uint256 totalEarning;
    }
    struct Position {
        uint256 row;
        uint256 column;
    }
    User[] private users;
    mapping(string => string[]) private children;
    mapping(address => History[]) private histories;
    mapping(address => mapping(uint8 => Tree)) private trees;
    mapping(uint8 => Position) public positions;
    mapping(uint8 => mapping(uint256 => mapping(uint256 => string)))
        private pools;
    modifier onlyAdmin() {
        require(admin == msg.sender, "You are not admin");
        _;
    }

    constructor(address _address) {
        admin = msg.sender;
        company = _address;
        Position storage pool1 = positions[0];
        pool1.row = 1;
        pool1.column = 1;
        Position storage pool2 = positions[1];
        pool2.row = 1;
        pool2.column = 1;
        Position storage pool3 = positions[2];
        pool3.row = 1;
        pool3.column = 1;
        Position storage pool4 = positions[3];
        pool4.row = 1;
        pool4.column = 1;
    }

    function compareStrings(
        string memory firstString,
        string memory secondString
    ) private pure returns (bool) {
        return keccak256(bytes(firstString)) == keccak256(bytes(secondString));
    }

    function saveHistory(
        string memory _from,
        address _to,
        string memory _transactionType,
        uint256 _amount
    ) private {
        History[] storage transactionHistories = histories[_to];
        transactionHistories.push(
            History({
                from: _from,
                transactionType: _transactionType,
                amount: _amount,
                timestamp: block.timestamp
            })
        );
    }

    function sendToAdmin(
        string memory _from,
        string memory _transactionType,
        uint256 _amount
    ) private {
        IBEP20 USDT = IBEP20(token);
        USDT.transfer(company, _amount);
        saveHistory(_from, company, _transactionType, _amount);
    }

    function sendToAffiliate(
        string memory _from,
        address _to,
        string memory _transactionType,
        uint256 _amount
    ) private {
        IBEP20 USDT = IBEP20(token);
        USDT.transfer(_to, _amount);
        User memory user = getUserByAddress(_to);
        if (compareStrings(_transactionType, "direct")) {
            user.referralEarning = user.referralEarning + _amount;
            user.totalEarning = user.totalEarning + _amount;
        }
        if (compareStrings(_transactionType, "Autopool1")) {
            user.pool1Earning = user.pool1Earning + _amount;
            user.totalEarning = user.totalEarning + _amount;
        }
        if (compareStrings(_transactionType, "Autopool2")) {
            user.pool2Earning = user.pool2Earning + _amount;
            user.totalEarning = user.totalEarning + _amount;
        }
        if (compareStrings(_transactionType, "Autopool3")) {
            user.pool3Earning = user.pool3Earning + _amount;
            user.totalEarning = user.totalEarning + _amount;
        }
        if (compareStrings(_transactionType, "Autopool4")) {
            user.pool4Earning = user.pool4Earning + _amount;
            user.totalEarning = user.totalEarning + _amount;
        }
        updateUser(user.id, user);
        saveHistory(_from, _to, _transactionType, _amount);
    }

    function updatePool(User memory _user, uint256 _amount) private {
        string memory from = _user.referralCode;
        if (_amount <= slots[3]) {
            uint256 entryCount = _amount / (slots[0]);
            for (uint8 i = 0; i < entryCount; i++) {
                Position storage position1 = positions[0];
                uint256 row = position1.row;
                uint256 col = position1.column;
                pools[0][row][col] = from;
                string memory parent = pools[0][row - 1][(col - 1) / 4 + 1];
                if (col % 4 == 0) {
                    // Spill over position
                    if (col == 4 ** (row - 1)) {
                        row++;
                        col = 1;
                    } else {
                        col++;
                    }
                    pools[0][row][col] = parent;
                    string memory upline = pools[0][row - 1][(col - 1) / 4 + 1];
                    User memory user = getUserByCode(upline);
                    sendToAffiliate(from, user.wallet, "Autopool1", slots[0]);
                } else {
                    if (col % 4 == 3) {
                        //Autopool2
                        Position storage position2 = positions[1];
                        uint256 row2 = position2.row;
                        uint256 col2 = position2.column;
                        pools[1][row2][col2] = parent;
                        if (col2 % 2 == 0) {
                            string memory upline = pools[1][row2 - 1][
                                (col2 - 1) / 2 + 1
                            ];
                            if (col2 == 2 ** (row2 - 1)) {
                                row2++;
                                col2 = 1;
                            } else {
                                col2++;
                            }
                            pools[1][row2][col2] = upline;
                            string memory payUpline = pools[1][row2 - 1][
                                (col2 - 1) / 2 + 1
                            ];
                            User memory user = getUserByCode(payUpline);
                            sendToAffiliate(
                                parent,
                                user.wallet,
                                "Autopool2",
                                slots[1]
                            );
                        } else {
                            if (row2 == 1 && col2 == 1) {
                                sendToAdmin(parent, "Autopool2", slots[1]);
                            } else {
                                string memory payUpline = pools[1][row2 - 1][
                                    (col2 - 1) / 2 + 1
                                ];
                                User memory user = getUserByCode(payUpline);
                                sendToAffiliate(
                                    parent,
                                    user.wallet,
                                    "Autopool2",
                                    slots[1]
                                );
                            }
                        }
                        col2++;
                        if (row2 == 1 && col2 == 2) {
                            row2++;
                            col2 = 1;
                        }
                        position2.row = row2;
                        position2.column = col2;
                    } else {
                        if (row == 1 && col == 1) {
                            sendToAdmin(from, "Autopool1", slots[0]);
                        } else {
                            if (col == 1) {
                                User memory user = getUserByCode(parent);
                                sendToAffiliate(
                                    from,
                                    user.wallet,
                                    "Autopool1",
                                    slots[0]
                                );
                            } else {}
                        }
                    }
                }
                col++;
                if (row == 1 && col == 2) {
                    row++;
                    col = 1;
                }
                position1.row = row;
                position1.column = col;
            }
        } else {
            uint256 entryCount = _amount / (slots[3]);
            for (uint8 i = 0; i < entryCount; i++) {
                Position storage position3 = positions[2];
                uint256 row = position3.row;
                uint256 col = position3.column;
                pools[2][row][col] = from;
                string memory parent = pools[2][row - 1][(col - 1) / 3 + 1];
                if (col % 3 == 0) {
                    // Spill over position
                    if (col == 3 ** (row - 1)) {
                        row++;
                        col = 1;
                    } else {
                        col++;
                    }
                    pools[2][row][col] = parent;
                    string memory upline = pools[2][row - 1][(col - 1) / 3 + 1];
                    User memory user = getUserByCode(upline);
                    sendToAffiliate(from, user.wallet, "Autopool3", slots[3]);
                } else {
                    if (col % 3 == 2) {
                        Position storage position4 = positions[3];
                        uint256 row4 = position4.row;
                        uint256 col4 = position4.column;
                        pools[3][row4][col4] = parent;
                        if (col4 % 2 == 0) {
                            string memory upline = pools[3][row4 - 1][
                                (col4 - 1) / 2 + 1
                            ];
                            if (col4 == 2 ** (row4 - 1)) {
                                row4++;
                                col4 = 1;
                            } else {
                                col4++;
                            }
                            pools[3][row4][col4] = upline;
                            string memory payUpline = pools[3][row4 - 1][
                                (col4 - 1) / 2 + 1
                            ];
                            User memory user = getUserByCode(payUpline);
                            sendToAffiliate(
                                parent,
                                user.wallet,
                                "Autopool4",
                                slots[3]
                            );
                        } else {
                            if (row4 == 1 && col4 == 1) {
                                sendToAdmin(parent, "Autopool4", slots[3]);
                            } else {
                                string memory payUpline = pools[3][row4 - 1][
                                    (col4 - 1) / 2 + 1
                                ];
                                User memory user = getUserByCode(payUpline);
                                sendToAffiliate(
                                    parent,
                                    user.wallet,
                                    "Autopool4",
                                    slots[3]
                                );
                            }
                        }
                        col4++;
                        if (row4 == 1 && col4 == 2) {
                            row4++;
                            col4 = 1;
                        }
                        position4.row = row4;
                        position4.column = col4;
                    } else {
                        if (row == 1 && col == 1) {
                            sendToAdmin(from, "Autopool3", slots[3]);
                        } else {
                            if (col == 1) {
                                User memory user = getUserByCode(parent);
                                sendToAffiliate(
                                    from,
                                    user.wallet,
                                    "Autopool3",
                                    slots[3]
                                );
                            } else {}
                        }
                    }
                }
                col++;
                if (row == 1 && col == 2) {
                    row++;
                    col = 1;
                }
                position3.row = row;
                position3.column = col;
            }
        }
    }

    function processDeposit(
        User memory _user,
        uint256 _amount,
        bool spill
    ) private returns (bool) {
        uint256 referAmount = 0;
        if (_amount > slots[0]) {
            referAmount = _amount / 2;
            updatePool(_user, _amount / 2);
        } else referAmount = slots[0];
        if (compareStrings(_user.referrer, adminCode)) {
            sendToAdmin(_user.referralCode, "direct", referAmount);
        } else {
            User memory upline = getUserByCode(_user.referrer);
            uint8 index = 0;
            for (uint8 i = 0; i < slots.length; i++) {
                if (slots[i] == _amount) index = i + 1;
                else continue;
            }
            if (index <= upline.currentRank) {
                Tree storage tree = trees[upline.wallet][index];
                uint256 count = tree.count;
                Node memory node = Node({
                    status: spill,
                    user: _user.referralCode
                });
                tree.count++;
                tree.nodes.push(node);
                if (count == 0) {
                    // First tree
                    sendToAffiliate(
                        _user.referralCode,
                        upline.wallet,
                        "direct",
                        referAmount
                    );
                } else if (count % 4 == 1 || count % 4 == 0) {
                    sendToAffiliate(
                        _user.referralCode,
                        upline.wallet,
                        "direct",
                        referAmount
                    );
                    return true;
                } else if (count % 4 == 2) {
                    sendToAffiliate(
                        _user.referralCode,
                        upline.wallet,
                        "direct",
                        referAmount / 2
                    );
                    if (compareStrings(upline.referrer, adminCode)) {
                        sendToAdmin(
                            _user.referralCode,
                            "direct",
                            referAmount / 2
                        );
                    } else {
                        User memory uplineUpline = getUserByCode(
                            upline.referrer
                        );
                        sendToAffiliate(
                            _user.referralCode,
                            uplineUpline.wallet,
                            "direct",
                            referAmount / 2
                        );
                    }
                } else {
                    if (_amount == slots[0]) {
                        if (compareStrings(upline.referrer, adminCode)) {
                            sendToAdmin(
                                _user.referralCode,
                                "direct",
                                referAmount
                            );
                        } else {
                            User memory uplineUpline = getUserByCode(
                                upline.referrer
                            );
                            sendToAffiliate(
                                _user.referralCode,
                                uplineUpline.wallet,
                                "direct",
                                referAmount
                            );
                        }
                    } else {
                        processDeposit(upline, _amount / 2, true);
                    }
                }
            } else {
                //Missing Incentive
                upline.missingIncentive = upline.missingIncentive + referAmount;
                updateUser(upline.id, upline);

                if (compareStrings(upline.referrer, adminCode)) {
                    sendToAdmin(_user.referralCode, "direct", referAmount);
                } else {
                    while (upline.currentRank < index) {
                        upline = getUserByCode(upline.referrer);
                        if (compareStrings(upline.referrer, adminCode)) {
                            sendToAdmin(
                                _user.referralCode,
                                "direct",
                                referAmount
                            );
                            break;
                        } else {
                            continue;
                        }
                    }
                    if (
                        upline.currentRank >= index &&
                        !compareStrings(upline.referrer, adminCode)
                    )
                        sendToAffiliate(
                            _user.referralCode,
                            upline.wallet,
                            "direct",
                            referAmount
                        );
                }
            }
        }
        return true;
    }

    function getUserByAddress(
        address _address
    ) public view returns (User memory) {
        for (uint256 i = 0; i < userCount; i++) {
            User memory user = users[i];
            if (user.wallet == _address) return user;
            else continue;
        }
        User memory newUser;
        return newUser;
    }

    function getUserByCode(
        string memory _code
    ) public view returns (User memory) {
        for (uint256 i = 0; i < userCount; i++) {
            User memory user = users[i];
            if (compareStrings(user.referralCode, _code)) return user;
            else continue;
        }
        User memory newUser;
        return newUser;
    }

    function updateUser(uint256 _id, User memory _user) private returns (bool) {
        User storage user = users[_id];
        user.id = _user.id;
        user.wallet = _user.wallet;
        user.referralCode = _user.referralCode;
        user.referrer = _user.referrer;
        user.startRank = _user.startRank;
        user.currentRank = _user.currentRank;
        user.missingIncentive = _user.missingIncentive;
        user.childNum = _user.childNum;
        user.referralEarning = _user.referralEarning;
        user.pool1Earning = _user.pool1Earning;
        user.pool2Earning = _user.pool2Earning;
        user.pool3Earning = _user.pool3Earning;
        user.pool4Earning = _user.pool4Earning;
        user.totalEarning = _user.totalEarning;
        return true;
    }

    function createUser(User memory _user) private returns (bool) {
        users.push(
            User({
                id: _user.id,
                wallet: _user.wallet,
                referralCode: _user.referralCode,
                referrer: _user.referrer,
                startRank: _user.startRank,
                currentRank: _user.currentRank,
                missingIncentive: _user.missingIncentive,
                childNum: _user.childNum,
                referralEarning: 0,
                pool1Earning: 0,
                pool2Earning: 0,
                pool3Earning: 0,
                pool4Earning: 0,
                totalEarning: 0
            })
        );
        return true;
    }

    function deposit(
        uint256 _amount,
        string memory _code
    ) public returns (string memory code) {
        uint8 index = 0;
        for (uint8 i = 0; i < slots.length; i++) {
            if (_amount == slots[i]) index = i + 1;
            else continue;
        }
        require(index != 0, "Invalid Slot");
        IBEP20 USDT = IBEP20(token);
        require(USDT.balanceOf(msg.sender) >= _amount, "Insufficient Balance");
        require(
            USDT.allowance(msg.sender, address(this)) >= _amount,
            "Insufficient allowance"
        );
        User memory user = getUserByAddress(msg.sender);
        if (user.startRank == 0) {
            User memory upline = getUserByCode(_code);
            require(
                userCount == 0 || upline.startRank != 0,
                "Invalid Referral Code"
            );
            USDT.transferFrom(msg.sender, address(this), _amount);
            user.id = userCount;
            user.startRank = index;
            user.currentRank = index;
            user.wallet = msg.sender;
            if (userCount == 0) {
                user.referralCode = firstCode;
                code = firstCode;
                user.referrer = adminCode;
            } else {
                code = generateCode();
                user.referralCode = code;
                user.referrer = _code;
            }
            createUser(user);
            userCount++;
            if (upline.startRank != 0) {
                upline.childNum++;
                children[upline.referralCode].push(user.referralCode);
                updateUser(upline.id, upline);
                processDeposit(user, _amount, false);
            } else {
                if (_amount == slots[0])
                    sendToAdmin(user.referralCode, "direct", _amount);
                else {
                    sendToAdmin(user.referralCode, "direct", _amount / 2);
                    updatePool(user, _amount / 2);
                }
            }
        } else {
            require((index == user.currentRank + 1), "Invalid slot");
            USDT.transferFrom(msg.sender, address(this), _amount);
            user.currentRank = user.currentRank + 1;
            updateUser(user.id, user);
            processDeposit(user, _amount, false);
        }
    }

    function setCompany(address _newCompany) public onlyAdmin returns (bool) {
        company = _newCompany;
        return true;
    }

    function setAdmin(address _newAdmin) public onlyAdmin returns (bool) {
        admin = _newAdmin;
        return true;
    }

    function getAdmin() public view returns (address) {
        return admin;
    }

    function getCompany() public view returns (address) {
        return company;
    }

    function getCodeLength() public view returns (uint8) {
        return length;
    }

    function getTotalUser() public view returns (uint256) {
        return userCount;
    }

    function setCodeLength(uint8 _newLength) public onlyAdmin returns (bool) {
        length = _newLength;
        return true;
    }

    function getTree(
        address _address,
        uint8 _slot
    ) public view returns (Tree memory) {
        return trees[_address][_slot];
    }

    function getPosition(uint8 _slot) public view returns (Position memory) {
        return positions[_slot];
    }

    function getPoolUser(
        uint8 poolIndex,
        uint8 row,
        uint8 col
    ) private view returns (string memory) {
        return pools[poolIndex][row][col];
    }

    function getHistory(
        address _address
    ) public view returns (History[] memory) {
        return histories[_address];
    }

    function getAllUsers() public view returns (User[] memory) {
        return users;
    }

    function generateCode() private returns (string memory) {
        bytes memory randomWord = new bytes(length);
        bytes memory chars = new bytes(36);
        chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

        for (uint8 i = 0; i < length; i++) {
            uint randomNumber = random(26);
            // Index access for string is not possible
            randomWord[i] = chars[randomNumber];
        }
        return string(randomWord);
    }

    function random(uint8 number) private returns (uint) {
        counter++;
        return
            uint(
                keccak256(
                    abi.encodePacked(
                        block.timestamp,
                        block.number,
                        msg.sender,
                        counter
                    )
                )
            ) % number;
    }

    function getChildren(
        string memory _code
    ) public view returns (string[] memory) {
        return children[_code];
    }
}