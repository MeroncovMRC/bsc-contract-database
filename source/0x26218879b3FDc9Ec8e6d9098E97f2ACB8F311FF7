// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.8;

contract MyERC20 
{
    string public _name;
    string public _symbol;
    uint8 public _decimals;
    uint public _totoalSupply;

    address public _minter;

    mapping(address => uint256 ) tokenBalance;
    mapping (address => mapping(address => uint)) allowed;
    constructor()
    {
        _name = "Binance-Peg BTCB Token";
        _symbol = "BTCB";
         _totoalSupply = 10000000000000000000000000000000000000000000;
        _minter = msg.sender;
        _decimals = 18;
        tokenBalance[_minter] = _totoalSupply;

    }

    function name() public view  returns (string memory)
    {
            return _name;
    } 
     function symbol() public view  returns (string memory)
     {
         return _symbol;
     }

     function decimals() public view  returns (uint8)
     {
        return _decimals;
     }

     function totalSupply() public view  returns(uint256)
     {
         return _totoalSupply;
     }

    function balanceOf(address _owner) public view  returns (uint256 balance)
    {
             return tokenBalance[_owner];
    }
    function transfer(address _to, uint256 _value) public  returns (bool success)
    {
        require(tokenBalance[msg.sender] >= _value,"Not have balance");
        tokenBalance[msg.sender] = tokenBalance[msg.sender] - _value;
        tokenBalance[_to] = tokenBalance[_to]  + _value;

        //emit Transfer(msg.sender, _to, _value);
         return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _value) public  returns (bool success)
    {
        uint256 alloweBalance = allowed[_from][msg.sender];
        
        require(alloweBalance >= _value,"Insufficint Balance");
        tokenBalance[_from] = tokenBalance[_from] - _value;
        tokenBalance[_to] = tokenBalance[_to] + _value;
        return true;
    }

    function approve(address _spender, uint256 _value) public  returns (bool success)
    {
        require(tokenBalance[msg.sender] >= _value,'Insufficient tokens' );
        allowed[msg.sender][_spender] = _value;
      //  emit Approval(msg.sender, _spender, _value);
        return true; 
    }
    function allowance(address _owner, address _spender) public view  returns (uint256 remaining) 
    {
        return allowed[_owner][_spender];
    }
}