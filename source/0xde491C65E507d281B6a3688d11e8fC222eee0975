// SPDX-License-Identifier: Unlicensed

pragma solidity 0.8.10;


interface IERC20 {
    
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

}

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        this; 
        return msg.data;
    }
}

abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    constructor () {
        _owner = 0x627C95B6fD9026E00Ab2c373FB08CC47E02629a0;
        emit OwnershipTransferred(address(0), _owner);
    }
    function owner() public view virtual returns (address) {
        return _owner;
    }
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }
    
}


contract GEN_Split is Ownable{

    address payable private Wallet_DEV = payable(0x627C95B6fD9026E00Ab2c373FB08CC47E02629a0);
    address payable private Wallet_GEN = payable(0xD05895EDF847e1712721Cc9e0427Aa26289A6Bc5);
    
    receive() external payable {}

    function Process_BNB() external {
        uint256 contractBNB = address(this).balance;
        if (contractBNB > 0) {
        
        uint256 BNB = contractBNB/2;

        Send_BNB(BNB, Wallet_DEV);
        Send_BNB(BNB, Wallet_GEN);
        
        }
    }

    function Process_Tokens(address Token_Address, uint256 Percent_of_Tokens) public returns(bool _sent){
        if(Percent_of_Tokens > 100){Percent_of_Tokens = 100;}
        uint256 totalRandom = IERC20(Token_Address).balanceOf(address(this));
        uint256 removeRandom = totalRandom * Percent_of_Tokens / 100;
        _sent = IERC20(Token_Address).transfer(Wallet_DEV, removeRandom);
    }      

    function Update_DEV(address payable wallet) public onlyOwner() {
        Wallet_DEV = wallet;
    }

    function Update_GEN(address payable wallet) public onlyOwner() {
        Wallet_GEN = wallet;
    }

    function Send_BNB(uint256 amount, address payable sendTo) private {
        sendTo.transfer(amount);
    }  
}