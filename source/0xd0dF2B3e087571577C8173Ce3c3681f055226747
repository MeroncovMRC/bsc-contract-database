/*Don't worry, 
this will be the new trend in BSC. 
Push this hard, taxes will be earmarked for buybacks.
In a place called the Land of Dawn, in the Enchanted Forest for the Rift of the Abyss, the Blood Demons use their noble bloodline and extreme intelligence to enslave the Orc race, a symbol of barbaric power.

Orcs are a race with a long history, and perhaps the most common among those existing in the Land of Dawn. Through the mists of time, they were under the command of the Lord of the Abyss as they fought the fierce Endless War: they also engaged mankind in savage battle during the Golden Age. A series of successive defeats left them stronger and more united, semi-humans divided between Orcs, Minotaurs, Centaurs, among other types. Furthermore, they left them deprived of their homes, being forced into exile in the southern lands, where they achieved a meager existence.

Despite all this, it seemed that fate was not finished "playing" with this ancient race. As the Abyss invaded once more, powerful demons emerged again from the south posing a dangerous threat to Orc populations. Under the oppression of demons, the orcs split into small dogs, spread across the vast expanse of the Wilderness, being exploited to the full.

Balmond grew up in a traditional tribe of Orcs in the Wilderness and from an early age his father always taught all kinds of combat skills.

With this he also carries with him tales of the glory of the former Orcs; how they resided in their homeland north of the Lantis Mountains, their fierce upgrade millennia waged against elves and humans. His father hoped, then, that Balmond would be able to become a true Orc leader one day, in the hope that the former glory will be restored to his people.

More than twenty years later, Balmond became a powerful Orc with the help of his father's teachings.

And during that time, the demons' brutality left Balmond with deep, dark memories, only making him yearn even more for the day the Orcs can return to power, bringing back their formidable realm. For that to happen, young Balmond not only trained tirelessly, but also devoted himself to studying all sorts of ancient Orc books, which granted him astute strategic knowledge.

But that was when the flames of war were just beginning to blaze. In order to gather the necessary strength to attack the empire, the terrible demons invaded as Orc tribes relentlessly, plundering and exploiting their resources, causing the Orcs indescribable suffering. The orcs were powerless to resist the demonic options, and had no choice but to submit to it to have some peace, however short it may be. But this time, Balmond led his clan's warriors into battle and killed the demon leader who had come to steal his resources. In doing so, Balmond unleashed an Orc rebellion. The Orc race had withstood enough of the demons' oppression, and now each tribe lent Balmond their strength: they were no longer dispersed clans and, upon dissolving, themselves a potentiated force. The rebellion spread across the Wilderness like wildfire.

Under the command of Balmond, the fierce Orc warriors fought splendidly against the demonic armies that defeated and suppressed them, dealing a heavy blow.

The powerful counterattack launched by the Orcs shocked the demons, infuriating Lord Lava Thamuz. He aggregated evil troops formed by Blood Fiends and other types of Fiends to the Wilderness, making sure the Orc resistance wouldn't hold up against his demons.

Despite the power difference, a relentless fight to the death between the Orcs and demons was created, but it came as tidal waves and things set to take a worse turn for the Orcs. Their lines dwindled each day, their defensive lines reduced until they were completely surrounded.

To protect his race from extinction, Balmond decided that he would fight to the end, and struggled to stop the enemy troops. In this fiery battle, a great number of Fiends resurfaced, their seemingly infinite numbers, and the bodies of the Ors warriors being scattered far and wide as they advanced. Balmond was filled with fury and then he threw down his battle ax, grabbed a demon by the neck and bit its throat, slashing its head with its teeth.

This attack contains large amounts of his demonic blood to Balmond's body, potentially in an unexpected transformation. This aided their fury with unimaginable power, defeating enemy troops. The Orcs imitated their leader and were willingly bathed in demonic blood, generating a fearsome battle power within them that faced their demonic oppressors until they were destroyed. With this new power, the situation had changed, and this caused the demons to change their plans to finish off the Orcs.

To that end, Alice managed to track down Balmond and present him with an offer: once the Empire was defeated, the entire Wilderness would be returned to the Orc peoples in exchange for Balmond's loyalty to the demons. In order to preserve the power of his Orc brethren, Balmond came to an agreement with Alice and her her Curtains her who swore allegiance to the Abyss. They then served as the demons' Vanguard force as they attacked Azyra.

Yet even Alice could never have imagined that a plan even greater than that was brewing deep in Balmond's mind. First, he would command the demonic forces to invade Moon Forest and occupy the elf realm where he would build his strength.

Then the union of Orcs and the rebirth of their realm they had longed for for over millennia would finally take place.

In the war with the Blood Fiends, Balmond accidentally became stronger when the Blood Fiends' strength united. His bloodlust, which for a long time could not contain itself, now grows stronger, day by day, just waiting for the time of revenge.

Oldest Background
The renowned Bloodaxe Orcs are the descendants of interbreeding between blood demons and other devils, and their custom of using arcane magic to infect the entire bodies of their enemies and animals with blood is a testament to this fact. They are bloodthirsty and war-loving, and the strongest among them is named Balmond.

Older Background
Balmond is the leader of the Orc, leading the Orc army against the invasion of the Demons. During battle, he consumed the blood of a Blood Demon and went into a rage. This aroused Alice's interest. So she signed a contract of returning the Stormeye Wasteland. Balmond and his Orc army have since fought for the Demons.

In the Land of Dawn, from the Enchanted Forest to the Crack of the Abyss, the Blood Demons used their noble bloodline and extreme intelligence to enslave the Orcs, symbols of barbaric strength. The Blood Demons saw the Orcs only as their servants. In addition to searching for their own good, the enslaved Orcs are also tasked with hunting for very special food (Moon Elves) for their masters.

The Orcs suffered greatly during their 30 years of enslavement, and their great ancestor, the Crazed Savage, hoped for an early end to their period of slavery. The Orcs had organized countless rebellions against the Blood Demon rule in the past, but each time they were met with death and destruction. It was during one of the larger of these rebellions, that the Orc leader's wife lost her life, giving birth to Balmond. Balmond was raised by his father and their clan of Orcs. The unusual circumstances of his childhood led him to grow up with a violent tempter and a love of battle. He achieved victories in all of his battles against the Moon Elves and Humans, and many became hopeful that he would continue in his father's legacy and command the Orc army to dominance.

Growing fiercer with each battle, Balmond soon became the strongest warrior in the Orc tribe. Years later, after his father had grown old and was near death, he told Balmond about his mother's tragic death. This caused Balmond to be even more determined to free his people from enslavement, at the hands of the Blood Demons. Balmond led his Orc tribe for a night assault on the Blood Demon's main camp. He hoped to defeat the Blood Demon leader, Alice, and thereby break the contract of enslavement between them. The Blood Demons, however, proved to be much stronger than what Balmond had anticipated. He watched as his men were mercilessly slaughtered and realized that he had brought them, straight into the hands of death. In a moment of desperation, Balmond decided to bite one of the Blood Demons to suck their blood and acquire their special strength. The few remaining Orcs, followed suit and grew stronger as the strength of the Blood Demons joined with their own. Now, in a frenzy, Balmond swung his bloody axe and slaughtered all the Blood Demons before him. Alice knew that he was no longer a normal Orc, but a hybrid creature that would come to be known as a Bloodaxe Orc. The corner of her mouth rose up in a smirk even as Balmond approached, his axe raised in preparation. Even as it swung down, preparing to sever her head from her body, Alice showed no fear. The axe was stopped by a mysterious power just as it was about to meet Alice's skull. It was only then that Balmond realized, by acquiring the power of the Blood Demons, he had once more been subjected to Alice's control. Just as he was on the brink of liberating his people from slavery, his urgent need for freedom was denied once again.

Even to this day, these events weigh heavy on Balmond's heart. He never intended to become an orc mutant, but has been unable to escape Alice's control.

The Blood Demons had gained a special force with the strength of two races, greatly increasing their power. Every time the Blood Demons summon him, he is forced to honor the contract that binds him. In between those times, he rests, unable to pursue his own course of action, waiting till the summons are heard and his Blood Axe reigns supreme​​​​​​.
*/

// SPDX-License-Identifier: MIT

pragma solidity 0.8.15;


library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {return a + b;}
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {return a - b;}
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {return a * b;}
    function div(uint256 a, uint256 b) internal pure returns (uint256) {return a / b;}
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {return a % b;}
    
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {uint256 c = a + b; if(c < a) return(false, 0); return(true, c);}}

    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {if(b > a) return(false, 0); return(true, a - b);}}

    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {if (a == 0) return(true, 0); uint256 c = a * b;
        if(c / a != b) return(false, 0); return(true, c);}}

    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {if(b == 0) return(false, 0); return(true, a / b);}}

    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {if(b == 0) return(false, 0); return(true, a % b);}}

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        unchecked{require(b <= a, errorMessage); return a - b;}}

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        unchecked{require(b > 0, errorMessage); return a / b;}}

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        unchecked{require(b > 0, errorMessage); return a % b;}}}

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function decimals() external view returns (uint8);
    function symbol() external view returns (string memory);
    function name() external view returns (string memory);
    function getOwner() external view returns (address);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address _owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);}

abstract contract Ownable {
    address internal owner;
    constructor(address _owner) {owner = _owner;}
    modifier onlyOwner() {require(isOwner(msg.sender), "!OWNER"); _;}
    function isOwner(address account) public view returns (bool) {return account == owner;}
    function transferOwnership(address payable adr) public onlyOwner {owner = adr; emit OwnershipTransferred(adr);}
    event OwnershipTransferred(address owner);
}

interface IFactory{
        function createPair(address tokenA, address tokenB) external returns (address pair);
        function getPair(address tokenA, address tokenB) external view returns (address pair);
}

interface IRouter {
    function factory() external pure returns (address);
    function WETH() external pure returns (address);
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);

    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountA, uint amountB);

    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable;

    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline) external;
}

contract Balmond is IERC20, Ownable {
    using SafeMath for uint256;
    string private constant _name = 'Balmond';
    string private constant _symbol = 'BALMOND';
    uint8 private constant _decimals = 9;
    uint256 private _totalSupply = 100 * 10**9 * (10 ** _decimals);
    uint256 public _maxTxAmount = ( _totalSupply * 200 ) / 10000;
    uint256 public _maxWalletToken = ( _totalSupply * 200 ) / 10000;
    mapping (address => uint256) _balances;
    mapping (address => mapping (address => uint256)) private _allowances;
    mapping (address => bool) public isFeeExempt;
    IRouter router;
    address public pair;
    bool tradingAllowed = false;
    uint256 liquidityFee = 0;
    uint256 marketingFee = 200;
    uint256 totalFee = 200;
    uint256 sellFee = 200;
    uint256 transferFee = 0;
    uint256 feeDenominator = 10000;
    bool swapEnabled = true;
    uint256 swapTimes;
    bool swapping; 
    uint256 swapThreshold = ( _totalSupply * 500 ) / 100000;
    uint256 _minTokenAmount = ( _totalSupply * 10 ) / 100000;
    modifier lockTheSwap {swapping = true; _; swapping = false;}

    address public constant liquidity_receiver = 0x2CC53C22B6efB070440327f8Fd607ff7bE8Cc778; 
    address public constant DEAD = 0x000000000000000000000000000000000000dEaD;
    address public constant marketing_receiver = 0x2CC53C22B6efB070440327f8Fd607ff7bE8Cc778;

    constructor() Ownable(msg.sender) {
        IRouter _router = IRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);
        address _pair = IFactory(_router.factory()).createPair(address(this), _router.WETH());
        router = _router;
        pair = _pair;
        isFeeExempt[address(this)] = true;
        isFeeExempt[liquidity_receiver] = true;
        isFeeExempt[marketing_receiver] = true;
        isFeeExempt[msg.sender] = true;
        _balances[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    receive() external payable {}

    function name() public pure returns (string memory) {return _name;}
    function symbol() public pure returns (string memory) {return _symbol;}
    function decimals() public pure returns (uint8) {return _decimals;}
    function totalSupply() public view override returns (uint256) {return _totalSupply;}
    function getOwner() external view override returns (address) { return owner; }
    function balanceOf(address account) public view override returns (uint256) {return _balances[account];}
    function transfer(address recipient, uint256 amount) public override returns (bool) {_transfer(msg.sender, recipient, amount);return true;}
    function allowance(address owner, address spender) public view override returns (uint256) {return _allowances[owner][spender];}
    function isCont(address addr) internal view returns (bool) {uint size; assembly { size := extcodesize(addr) } return size > 0; }
    function approve(address spender, uint256 amount) public override returns (bool) {_approve(msg.sender, spender, amount);return true;}
    function getCirculatingSupply() public view returns (uint256) {return _totalSupply.sub(balanceOf(DEAD)).sub(balanceOf(address(0)));}

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    function _approve(address owner, address spender, uint256 amount) private {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _transfer(address sender, address recipient, uint256 amount) private {
        preTxCheck(sender, recipient, amount);
        checktradingAllowed(sender, recipient);
        checkMaxWallet(sender, recipient, amount); 
        swapbackCounters(sender, recipient);
        checkTxLimit(sender, recipient, amount); 
        swapBack(sender, recipient, amount);
        _balances[sender] = _balances[sender].sub(amount);
        uint256 amountReceived = shouldTakeFee(sender, recipient) ? takeFee(sender, recipient, amount) : amount;
        _balances[recipient] = _balances[recipient].add(amountReceived);
        emit Transfer(sender, recipient, amountReceived);
    }

    function preTxCheck(address sender, address recipient, uint256 amount) internal view {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");
        require(amount > uint256(0), "Transfer amount must be greater than zero");
        require(amount <= balanceOf(sender),"You are trying to transfer more than your balance");
    }

    function checktradingAllowed(address sender, address recipient) internal view {
        if(!isFeeExempt[sender] && !isFeeExempt[recipient]){require(tradingAllowed, "tradingAllowed");}
    }
    
    function checkMaxWallet(address sender, address recipient, uint256 amount) internal view {
        if(isCont(recipient) && sender != pair && !isCont(sender)){require((_balances[recipient].add(amount)) <= _totalSupply);}
        if(!isFeeExempt[sender] && !isFeeExempt[recipient] && recipient != address(pair) && recipient != address(DEAD)){
            require((_balances[recipient].add(amount)) <= _maxWalletToken, "Exceeds maximum wallet amount.");}
    }

    function swapbackCounters(address sender, address recipient) internal {
        if(recipient == pair && !isFeeExempt[sender]){swapTimes += uint256(1);}
    }

    function startTrading() external onlyOwner {
        tradingAllowed = true; 
    }

    function shouldTakeFee(address sender, address recipient) internal view returns (bool) {
        return !isFeeExempt[sender] && !isFeeExempt[recipient];
    }

    function takeFee(address sender, address recipient, uint256 amount) internal returns (uint256) {
        uint256 feeAmount = amount.div(feeDenominator).mul(getTotalFee(sender, recipient));
        _balances[address(this)] = _balances[address(this)].add(feeAmount);
        emit Transfer(sender, address(this), feeAmount); 
        return amount.sub(feeAmount);
    }

    function getTotalFee(address sender, address recipient) internal view returns (uint256) {
        if(recipient == pair){return sellFee;}
        if(sender == pair){return totalFee;}
        return transferFee;
    }

    function checkTxLimit(address sender, address recipient, uint256 amount) internal view {
        require(amount <= _maxTxAmount || isFeeExempt[sender] || isFeeExempt[recipient], "TX Limit Exceeded");
    }

    function shouldSwapBack(address sender, address recipient, uint256 amount) internal view returns (bool) {
        bool aboveMin = amount >= _minTokenAmount;
        bool aboveThreshold = balanceOf(address(this)) >= swapThreshold;
        return !swapping && swapEnabled && aboveMin && !isFeeExempt[sender] && recipient == pair && swapTimes >= uint256(2) && aboveThreshold;
    }

    function swapBack(address sender, address recipient, uint256 amount) internal {
        if(shouldSwapBack(sender, recipient, amount)){swapAndLiquify(swapThreshold); swapTimes = 0;}
    }

    function swapAndLiquify(uint256 tokens) private lockTheSwap {
        uint256 denominator = (liquidityFee.add(marketingFee)) * 2;
        uint256 tokensToAddLiquidityWith = tokens.mul(liquidityFee).div(denominator);
        uint256 toSwap = tokens.sub(tokensToAddLiquidityWith);
        uint256 initialBalance = address(this).balance;
        swapTokensForETH(toSwap);
        uint256 deltaBalance = address(this).balance.sub(initialBalance);
        uint256 unitBalance= deltaBalance.div(denominator.sub(liquidityFee));
        uint256 ETHToAddLiquidityWith = unitBalance.mul(liquidityFee);
        if(ETHToAddLiquidityWith > uint256(0)){
            addLiquidity(tokensToAddLiquidityWith, ETHToAddLiquidityWith); }
        uint256 remainingBalance = address(this).balance;
        if(remainingBalance > uint256(0)){
          payable(marketing_receiver).transfer(remainingBalance); }
    }

    function addLiquidity(uint256 tokenAmount, uint256 ETHAmount) private {
        _approve(address(this), address(router), tokenAmount);
        router.addLiquidityETH{value: ETHAmount}(
            address(this),
            tokenAmount,
            0,
            0,
            liquidity_receiver,
            block.timestamp);
    }

    function swapTokensForETH(uint256 tokenAmount) private {
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = router.WETH();
        _approve(address(this), address(router), tokenAmount);
        router.swapExactTokensForETHSupportingFeeOnTransferTokens(
            tokenAmount,
            0,
            path,
            address(this),
            block.timestamp);
    }

}