{"EnumerableSet.sol":{"content":"pragma solidity ^0.8.0;\n/*\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`) and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    struct Set {\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0 means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        uint256 valueIndex = set._indexes[value];\n        if (valueIndex != 0) {\n            // we swap the element to delete with the last one in the array, and then remove the last element.\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n                set._values[toDeleteIndex] = lastValue;\n                set._indexes[lastValue] = valueIndex;\n            }\n            set._values.pop();\n            delete set._indexes[value];\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    // Return the entire set in an array\n    // WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n    // to mostly be used by view accessors that are queried without any gas fees. \n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n\n    struct AddressSet {\n        Set _inner;\n    }\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n        assembly {\n            result := store\n        }\n        return result;\n    }\n\n\n    struct UintSet {\n        Set _inner;\n    }\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n        assembly {\n            result := store\n        }\n        return result;\n    }\n\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n        assembly {\n            result := store\n        }\n        return result;\n    }\n}"},"Nodes.sol":{"content":"pragma solidity 0.8.17;\r\n\r\nimport \"./EnumerableSet.sol\";\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n   \r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary Math {\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a \u003c b ? a : b;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    constructor () {\r\n        _owner = msg.sender;\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract Nodes is Ownable {\r\n    IERC20 public constant c_erc20 = IERC20(0x2c44b726ADF1963cA47Af88B284C06f30380fC78);\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n    EnumerableSet.AddressSet private nodes;\r\n\r\n    mapping(address =\u003e uint256) public withdrawns;\r\n    uint256 public dividendTime = 1685703600; // 2023-06-02 19:00:00\r\n    uint256 public duration = 7 days;\r\n    uint256 public feeRate = 3;\r\n    address public feeAddress = 0xc33ba9A342cB9E705f2B342ef62Ef8b544eE1aEF;\r\n\r\n    struct RecordDividend {\r\n        uint64 timestamp;\r\n        uint64 num;\r\n        uint128 amount;\r\n    }\r\n    RecordDividend[] public records;\r\n\r\n    function setTime(uint256 d, uint256 i) external onlyOwner {\r\n        dividendTime = d;\r\n        duration = i;\r\n    }\r\n   \r\n    function addNode(address[] calldata addrs) external onlyOwner {\r\n        uint256 len = addrs.length;\r\n        for (uint256 i; i \u003c len; ++i) {\r\n            nodes.add(addrs[i]);\r\n        }\r\n    }\r\n\r\n    function removeNode(address[] calldata addrs) external onlyOwner {\r\n        uint256 len = addrs.length;\r\n        for (uint256 i; i \u003c len; ++i) {\r\n            nodes.remove(addrs[i]);\r\n        }\r\n    }\r\n\r\n    function setFeeRate(uint256 fr, address fa) external onlyOwner {\r\n        feeRate = fr;\r\n        feeAddress = fa;\r\n    }\r\n\r\n    function getERC201(IERC20 c_erc2, uint256 amount) external onlyOwner {\r\n        c_erc2.transfer(msg.sender, amount);\r\n    }\r\n\r\n    function getDividend() external {\r\n        require(block.timestamp \u003e dividendTime + duration, \u0027no time\u0027);\r\n        uint256 interval = (block.timestamp - dividendTime)/duration;\r\n        dividendTime += interval*duration;\r\n\r\n        uint256 feeAmount = c_erc20.balanceOf(address(this)) * feeRate / 100;\r\n        c_erc20.transfer(feeAddress, feeAmount);\r\n        uint256 len = nodes.length();\r\n        uint256 o = c_erc20.balanceOf(address(this))/len;\r\n        for (uint256 i; i \u003c len; ++i) {\r\n            address addr = nodes.at(i);\r\n            c_erc20.transfer(addr, o);\r\n            withdrawns[addr] += o;\r\n        }\r\n        records.push(RecordDividend(uint64(block.timestamp), uint64(len), uint128(o*len)));\r\n    }\r\n\r\n    function nodeInfo(address addr) external view returns(uint256, uint256, bool, uint256, uint256, uint256) {\r\n        return (nodes.length(), c_erc20.balanceOf(address(this)), nodes.contains(addr), withdrawns[addr], dividendTime, duration);\r\n    }\r\n\r\n    function nodesInfo() external view returns(address[] memory addrs, uint256[] memory withdrawnAmounts) {\r\n        uint256 len = nodes.length();\r\n        addrs = new address[](len);\r\n        withdrawnAmounts = new uint256[](len);\r\n        for (uint256 i; i \u003c len; ++i) {\r\n            address addr = nodes.at(i);\r\n            addrs[i] = addr;\r\n            withdrawnAmounts[i] = withdrawns[addr];\r\n        }\r\n    }\r\n\r\n    function recordInfo() external view returns(RecordDividend[] memory o) {\r\n        o = records;\r\n    }\r\n\r\n    function getRecordsByPage(uint256 pageNum, uint256 pageSize) external view returns (RecordDividend[] memory o, uint256 total) {\r\n        total = records.length;\r\n        uint256 from = pageNum*pageSize;\r\n        if (total \u003c= from) {\r\n            return (new RecordDividend[](0), total);\r\n        }\r\n\r\n        uint256 minNum = Math.min(total - from, pageSize);\r\n        from = total - from - 1;\r\n        o = new RecordDividend[](minNum);\r\n        \r\n        for (uint256 i; i \u003c minNum; ++i) {\r\n            o[i] = records[from];\r\n            if(from \u003e 0) {\r\n                from--;\r\n            }\r\n        }\r\n    }\r\n}"}}