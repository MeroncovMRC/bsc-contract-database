// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;


contract MyNFT {
    struct NFTData {
        uint256 tokenId;
        string name;
        string location;
        string metaverse;
        address owner;
        uint256 woodCount;
        uint256 stoneCount;   
        string metadataURI;
    }


    

    mapping(uint256 => NFTData) public lands;
    mapping(address => mapping(uint256 => uint256)) public resourcesExtracted;


    // mapping(uint256 => NFTData) public lands;
    mapping(address => uint256[]) public ownedLands;


    uint256 private currentTokenId;
    uint256 private constant maxSupply = 100;

    event LandMinted(uint256 indexed tokenId, address indexed owner);
    event LandTransferred(uint256 indexed tokenId, address indexed from, address indexed to);
    event MetadataUpdated(uint256 indexed tokenId, string metadataURI);


  

    constructor() {
        currentTokenId = 0;
    }

     function mintLand(string memory metadataURI) external {
        require(currentTokenId < maxSupply, "Maximum supply reached");

        currentTokenId++;
        lands[currentTokenId] = NFTData(currentTokenId, "Land Name", "Location", "Metaverse", msg.sender, 1000, 1000, metadataURI);

        ownedLands[msg.sender].push(currentTokenId);

        emit LandMinted(currentTokenId, msg.sender);
        emit MetadataUpdated(currentTokenId, metadataURI);
    }

    function transferLand(uint256 tokenId, address to) external {
        require(lands[tokenId].owner == msg.sender, "You don't own this land");

        lands[tokenId].owner = to;
        removeTokenFromOwnedLands(tokenId, msg.sender);
        ownedLands[to].push(tokenId);

        emit LandTransferred(tokenId, msg.sender, to);
    }
    function removeTokenFromOwnedLands(uint256 tokenId, address owner) internal {
        uint256[] storage tokens = ownedLands[owner];
        for (uint256 i = 0; i < tokens.length; i++) {
            if (tokens[i] == tokenId) {
                if (i != tokens.length - 1) {
                    tokens[i] = tokens[tokens.length - 1];
                }
                tokens.pop();
                break;
            }
        }
    }
    function updateMetadata(uint256 tokenId, string memory metadataURI) external {
        require(lands[tokenId].owner == msg.sender, "You don't own this land");

        lands[tokenId].metadataURI = metadataURI;

        emit MetadataUpdated(tokenId, metadataURI);
    }

    function getOwnedLands(address owner) external view returns (uint256[] memory) {
        return ownedLands[owner];
    }






  


    // Function to update the metaverse and location of an NFT
    function updateNFTLocation(uint256 tokenId, string memory newMetaverse, string memory newLocation) external {
        require(tokenId > 0, "Invalid token ID");
        require(lands[tokenId].tokenId == tokenId, "NFT does not exist");

        lands[tokenId].metaverse = newMetaverse;
        lands[tokenId].location = newLocation;
    }

    // Function to extract wood from the land
    function extractWood(uint256 tokenId, uint256 amount) external {
        require(tokenId > 0, "Invalid token ID");
        require(lands[tokenId].tokenId == tokenId, "NFT does not exist");
        require(amount > 0, "Invalid amount");

        NFTData storage nft = lands[tokenId];
        require(nft.woodCount + amount >= nft.woodCount, "Integer overflow");

        nft.woodCount += amount;
        resourcesExtracted[msg.sender][tokenId] += amount;
    }

    // Function to extract stone from the land
    function extractStone(uint256 tokenId, uint256 amount) external {
        require(tokenId > 0, "Invalid token ID");
        require(lands[tokenId].tokenId == tokenId, "NFT does not exist");
        require(amount > 0, "Invalid amount");

        NFTData storage nft = lands[tokenId];
        require(nft.stoneCount + amount >= nft.stoneCount, "Integer overflow");

        require(amount <= getAvailableStone(tokenId), "Insufficient stone supply");

        nft.stoneCount += amount;
        resourcesExtracted[msg.sender][tokenId] += amount;
    }

    // Function to get the available stone supply for a land
    function getAvailableStone(uint256 tokenId) public view returns (uint256) {
        require(tokenId > 0, "Invalid token ID");
        require(lands[tokenId].tokenId == tokenId, "NFT does not exist");

        NFTData storage nft = lands[tokenId];
        uint256 extractedStone = resourcesExtracted[msg.sender][tokenId];
        uint256 totalStone = nft.stoneCount;

        if (extractedStone < totalStone) {
            return totalStone - extractedStone;
        } else {
            return 0;
        }
    }



    
}


// Helper library for removing elements from an array
library ArrayUtils {
    function remove(uint256[] storage array, uint256 element) internal {
        for (uint256 i = 0; i < array.length; i++) {
            if (array[i] == element) {
                array[i] = array[array.length - 1];
                array.pop();
                return;
            }
        }
    }
}