{"ConfigurablePools.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"./Declaration.sol\";\nimport \"./OwnableSafe.sol\";\n\n/**\n * @title ConfigurablePools\n * @author Aaron Hanson \u003ccoffee.becomes.code@gmail.com\u003e\n */\nabstract contract ConfigurablePools is OwnableSafe, Declaration {\n\n    struct PoolInfo {\n        uint40 lockDays;\n        uint40 rewardRate;\n        bool isFlexible;\n        uint256 totalStaked;\n        uint256 totalRewardsReserved;\n    }\n\n    uint256 public constant NUM_POOLS = 4;\n\n    mapping(uint256 =\u003e PoolInfo) public pools;\n\n    constructor() {\n        pools[0] = PoolInfo(60, 15, true, 0, 0);\n        pools[1] = PoolInfo(15, 35, false, 0, 0);\n        pools[2] = PoolInfo(30, 50, false, 0, 0);\n        pools[3] = PoolInfo(60, 75, false, 0, 0);\n    }\n\n    function editPoolTerms(\n        uint256 _poolID,\n        uint40 _newLockDays,\n        uint40 _newRewardRate\n    )\n        external\n        onlyOwner\n    {\n        require(\n            _poolID \u003c NUM_POOLS,\n            \"Invalid pool ID\"\n        );\n\n        require(\n            _newLockDays \u003e 0,\n            \"Lock days cannot be zero\"\n        );\n\n        require(\n            _newRewardRate \u003e 0,\n            \"Reward rate cannot be zero\"\n        );\n\n        pools[_poolID].lockDays = _newLockDays;\n        pools[_poolID].rewardRate = _newRewardRate;\n    }\n\n}"},"ContextSimple.sol":{"content":"// SPDX-License-Identifier: MIT\n// Based on OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\n// With _msgData() removed\n\npragma solidity ^0.8.11;\n\n/**\n * @dev Provides the msg.sender in the current execution context.\n */\nabstract contract ContextSimple {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n}\n"},"Declaration.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\ninterface IERC20 {\n\n    function transfer(\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n}\n\nabstract contract Declaration {\n\n    uint40 constant ONE_DAY = 60 * 60 * 24;\n    uint40 constant ONE_YEAR = ONE_DAY * 365;\n\n    IERC20 public immutable KAINET;\n\n    constructor(\n        address _immutableKainet\n    ) {\n        KAINET = IERC20(_immutableKainet);\n    }\n\n}"},"KainetStaking.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"./RewardsVault.sol\";\n\n/**\n * @title KainetStaking\n * @author Aaron Hanson \u003ccoffee.becomes.code@gmail.com\u003e\n */\ncontract KainetStaking is RewardsVault {\n\n    struct Stake {\n        uint256 amount;\n        bool isActive;\n        uint40 poolID;\n        uint40 rewardRate;\n        uint40 startTimestamp;\n        uint40 maturityTimestamp;\n    }\n\n    mapping(address =\u003e mapping(bytes16 =\u003e Stake)) public stakes;\n\n    mapping(address =\u003e uint256) public stakeCount;\n\n    event StakeBegan (\n        bytes16 indexed stakeID,\n        address indexed staker,\n        uint40 indexed poolID,\n        uint256 amount,\n        uint40 rewardRate,\n        uint256 rewardAtMaturity,\n        uint40 startTimestamp,\n        uint40 maturityTimestamp\n    );\n\n    event StakeEnded (\n        bytes16 indexed stakeID,\n        address indexed staker,\n        uint40 indexed poolID,\n        uint256 rewardPaid,\n        uint256 endTimestamp\n    );\n\n    constructor(\n        address _immutableKainet\n    )\n        Declaration(_immutableKainet)\n    {}\n\n    function beginStake(\n        uint40 _poolID,\n        uint256 _amount\n    )\n        external\n        returns (bytes16 stakeID)\n    {\n        require(\n            _poolID \u003c NUM_POOLS,\n            \"Invalid pool ID\"\n        );\n\n        require(\n            _amount \u003e 0,\n            \"Amount cannot be zero\"\n        );\n\n        PoolInfo storage pool = pools[_poolID];\n\n        uint256 maxReward = _calcStakeMaxReward(\n            pool,\n            _amount\n        );\n\n        require(\n            maxReward \u003c= vaultAvailableBalance,\n            \"Vault cannot cover rewards\"\n        );\n\n        unchecked {\n            vaultAvailableBalance -= maxReward;\n        }\n\n        pool.totalStaked += _amount;\n        pool.totalRewardsReserved += maxReward;\n\n        KAINET.transferFrom(\n            _msgSender(),\n            address(this),\n            _amount\n        );\n\n        uint40 blockTimestamp = uint40(block.timestamp);\n        uint40 maturityTimestamp = blockTimestamp + pool.lockDays * ONE_DAY;\n\n        Stake memory stake = Stake(\n            _amount,\n            true,\n            _poolID,\n            pool.rewardRate,\n            blockTimestamp,\n            maturityTimestamp\n        );\n\n        stakeID = getStakeID(\n            _msgSender(),\n            stakeCount[_msgSender()]\n        );\n\n        stakes[_msgSender()][stakeID] = stake;\n        stakeCount[_msgSender()] += 1;\n\n        emit StakeBegan(\n            stakeID,\n            _msgSender(),\n            _poolID,\n            stake.amount,\n            stake.rewardRate,\n            maxReward,\n            stake.startTimestamp,\n            stake.maturityTimestamp\n        );\n    }\n\n    function endStake(\n        bytes16 _stakeID\n    )\n        external\n    {\n        Stake storage stake = stakes[_msgSender()][_stakeID];\n        PoolInfo storage pool = pools[stake.poolID];\n\n        require(\n            stake.isActive == true,\n            \"Stake is inactive\"\n        );\n\n        (\n            uint256 reward,\n            uint256 unusedReservedReward\n        ) = _stakeWithdrawableReward(stake);\n\n        stake.isActive = false;\n        vaultAvailableBalance += unusedReservedReward;\n        pool.totalRewardsReserved -= reward + unusedReservedReward;\n        pool.totalStaked -= stake.amount;\n\n        KAINET.transfer(\n            _msgSender(),\n            stake.amount + reward\n        );\n\n        emit StakeEnded(\n            _stakeID,\n            _msgSender(),\n            stake.poolID,\n            reward,\n            block.timestamp\n        );\n    }\n\n    function getStakeID(\n        address _staker,\n        uint256 _stakeIndex\n    )\n        public\n        pure\n        returns (bytes16 id)\n    {\n        id = bytes16(bytes32(uint256(keccak256(\n            abi.encodePacked(_staker, _stakeIndex)\n        ))));\n    }\n\n    function stakeInfo(\n        address _staker,\n        bytes16 _stakeID\n    )\n        external\n        view\n        returns (\n            uint256 amount,\n            uint40 lockDays,\n            bool isActive,\n            uint40 poolID,\n            uint40 rewardRate,\n            uint40 startTimestamp,\n            uint40 maturityTimestamp,\n            bool isMature,\n            uint256 withdrawableReward,\n            uint256 unusedReservedReward\n        )\n    {\n        Stake memory stake = stakes[_staker][_stakeID];\n\n        amount = stake.amount;\n        lockDays = (stake.maturityTimestamp - stake.startTimestamp) / ONE_DAY;\n        isActive = stake.isActive;\n        poolID = stake.poolID;\n        rewardRate = stake.rewardRate;\n        startTimestamp = stake.startTimestamp;\n        maturityTimestamp = stake.maturityTimestamp;\n        isMature = block.timestamp \u003e= stake.maturityTimestamp;\n        (withdrawableReward, unusedReservedReward) = _stakeWithdrawableReward(\n            stake\n        );\n    }\n\n    function calcStakeMaxReward(\n        uint40 _poolID,\n        uint256 _amount\n    )\n        external\n        view\n        returns (uint256 maxReward)\n    {\n        maxReward = _calcStakeMaxReward(\n            pools[_poolID],\n            _amount\n        );\n    }\n\n    function stakeWithdrawableReward(\n        address _staker,\n        bytes16 _stakeID\n    )\n        external\n        view\n        returns (uint256 withdrawableReward)\n    {\n        Stake memory stake = stakes[_staker][_stakeID];\n        (withdrawableReward, ) = _stakeWithdrawableReward(\n            stake\n        );\n    }\n\n    function _stakeWithdrawableReward(\n        Stake memory _stake\n    )\n        private\n        view\n        returns (\n            uint256 withdrawableReward,\n            uint256 unusedReservedReward\n        )\n    {\n        if (_stake.isActive == true) {\n            uint256 rewardAtMaturity = _calculateReward(\n                _stake.amount,\n                _stake.rewardRate,\n                _stake.maturityTimestamp - _stake.startTimestamp\n            );\n\n            withdrawableReward = _calculateReward(\n                _stake.amount,\n                _stake.rewardRate,\n                _stakeRewardableDuration(\n                    _stake\n                )\n            );\n\n            unusedReservedReward = rewardAtMaturity - withdrawableReward;\n        }\n        else {\n            withdrawableReward = 0;\n            unusedReservedReward = 0;\n        }\n    }\n\n    function _stakeRewardableDuration(\n        Stake memory _stake\n    )\n        private\n        view\n        returns (uint256 duration)\n    {\n        if (block.timestamp \u003e= _stake.maturityTimestamp) {\n            duration = _stake.maturityTimestamp - _stake.startTimestamp;\n        }\n        else {\n            PoolInfo memory pool = pools[_stake.poolID];\n            duration = pool.isFlexible == true\n                ? block.timestamp - _stake.startTimestamp\n                : 0;\n        }\n    }\n\n    function _calcStakeMaxReward(\n        PoolInfo memory _pool,\n        uint256 _amount\n    )\n        private\n        pure\n        returns (uint256 maxReward)\n    {\n        maxReward = _amount\n        * _pool.lockDays\n        * _pool.rewardRate\n        / 36500;\n    }\n\n    function _calculateReward(\n        uint256 _amount,\n        uint256 _rewardRate,\n        uint256 _duration\n    )\n        private\n        pure\n        returns (uint256 reward)\n    {\n        reward = _amount * _rewardRate * _duration / 100 / ONE_YEAR;\n    }\n\n}"},"OwnableSafe.sol":{"content":"// SPDX-License-Identifier: MIT\n// Based on OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\n// With renounceOwnership() removed\n\npragma solidity ^0.8.11;\n\nimport \"./ContextSimple.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableSafe is ContextSimple {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"},"RewardsVault.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"./ConfigurablePools.sol\";\n\n/**\n * @title RewardsVault\n * @author Aaron Hanson \u003ccoffee.becomes.code@gmail.com\u003e\n */\nabstract contract RewardsVault is ConfigurablePools {\n\n    uint256 public vaultAvailableBalance;\n\n    function donateToVault(\n        uint256 _amount\n    )\n        external\n    {\n        vaultAvailableBalance += _amount;\n\n        KAINET.transferFrom(\n            _msgSender(),\n            address(this),\n            _amount\n        );\n    }\n\n    function withdrawFromVault(\n        uint256 _amount\n    )\n        external\n        onlyOwner\n    {\n        vaultAvailableBalance -= _amount;\n\n        KAINET.transfer(\n            _msgSender(),\n            _amount\n        );\n    }\n\n}"}}