// SPDX-License-Identifier: UNILICENSED

pragma solidity 0.8.16;

interface IBEP20 {
  function totalSupply() external view returns (uint256);

  function decimals() external view returns (uint8);

  function symbol() external view returns (string memory);

  function name() external view returns (string memory);

  function getOwner() external view returns (address);

  function balanceOf(address account) external view returns (uint256);

  function transfer(address recipient, uint256 amount) external returns (bool);

  function allowance(address _owner, address spender) external view returns (uint256);

  function approve(address spender, uint256 amount) external returns (bool);

  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

  event Transfer(address indexed from, address indexed to, uint256 value);

  event Approval(address indexed owner, address indexed spender, uint256 value);
}

library Address {
  function isContract(address account) internal view returns (bool) {
    bytes32 codehash;
    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
    // solhint-disable-next-line no-inline-assembly
    assembly {
      codehash := extcodehash(account)
    }
    return (codehash != 0x0 && codehash != accountHash);
  }
}

library SafeBEP20 {
  using SafeMath for uint256;
  using Address for address;

  function safeTransfer(IBEP20 token, address to, uint256 value) internal {
    callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
  }

  function safeTransferFrom(IBEP20 token, address from, address to, uint256 value) internal {
    callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
  }

  function safeApprove(IBEP20 token, address spender, uint256 value) internal {
    require(
      (value == 0) || (token.allowance(address(this), spender) == 0),
      'SafeBEP20: approve from non-zero to non-zero allowance'
    );
    callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
  }

  function callOptionalReturn(IBEP20 token, bytes memory data) private {
    require(address(token).isContract(), 'SafeBEP20: call to non-contract');

    // solhint-disable-next-line avoid-low-level-calls
    (bool success, bytes memory returndata) = address(token).call(data);
    require(success, 'SafeBEP20: low-level call failed');

    if (returndata.length > 0) {
      // Return data is optional
      // solhint-disable-next-line max-line-length
      require(abi.decode(returndata, (bool)), 'SafeBEP20: BEP20 operation did not succeed');
    }
  }
}

interface IERC20 {
  function totalSupply() external view returns (uint256);

  /**
   * @dev Returns the amount of tokens owned by `account`.
   */
  function balanceOf(address account) external view returns (uint256);

  /**
   * @dev Moves `amount` tokens from the caller's account to `recipient`.
   *
   * Returns a boolean value indicating whether the operation succeeded.
   *
   * Emits a {Transfer} event.
   */
  function transfer(address recipient, uint256 amount) external returns (bool);

  /**
   * @dev Returns the remaining number of tokens that `spender` will be
   * allowed to spend on behalf of `owner` through {transferFrom}. This is
   * zero by default.
   *
   * This value changes when {approve} or {transferFrom} are called.
   */
  function allowance(address owner, address spender) external view returns (uint256);

  /**
   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
   *
   * Returns a boolean value indicating whether the operation succeeded.
   *
   * IMPORTANT: Beware that changing an allowance with this method brings the risk
   * that someone may use both the old and the new allowance by unfortunate
   * transaction ordering. One possible solution to mitigate this race
   * condition is to first reduce the spender's allowance to 0 and set the
   * desired value afterwards:
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   *
   * Emits an {Approval} event.
   */
  function approve(address spender, uint256 amount) external returns (bool);

  /**
   * @dev Moves `amount` tokens from `sender` to `recipient` using the
   * allowance mechanism. `amount` is then deducted from the caller's
   * allowance.
   *
   * Returns a boolean value indicating whether the operation succeeded.
   *
   * Emits a {Transfer} event.
   */
  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

  /**
   * @dev Emitted when `value` tokens are moved from one account (`from`) to
   * another (`to`).
   *
   * Note that `value` may be zero.
   */
  event Transfer(address indexed from, address indexed to, uint256 value);

  /**
   * @dev Emitted when the allowance of a `spender` for an `owner` is set by
   * a call to {approve}. `value` is the new allowance.
   */
  event Approval(address indexed owner, address indexed spender, uint256 value);
}

// File: @openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol

pragma solidity ^0.8.0;

/**
 * @dev Interface for the optional metadata functions from the ERC20 standard.
 *
 * _Available since v4.1._
 */
interface IERC20Metadata is IERC20 {
  /**
   * @dev Returns the name of the token.
   */
  function name() external view returns (string memory);

  /**
   * @dev Returns the symbol of the token.
   */
  function symbol() external view returns (string memory);

  /**
   * @dev Returns the decimals places of the token.
   */
  function decimals() external view returns (uint8);
}

/**
 * Math operations with safety checks that throw on overflows.
 */
library SafeMath {
  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
    if (a == 0) {
      return 0;
    }
    c = a * b;
    require(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    // uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return a / b;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
    c = a + b;
    require(c >= a);
    return c;
  }
}

abstract contract Context {
  function _msgSender() internal view virtual returns (address) {
    return msg.sender;
  }

  function _msgData() internal view virtual returns (bytes calldata) {
    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
    return msg.data;
  }
}

// ----------------------------------------------------------------------------
// Owned contract
// ----------------------------------------------------------------------------
abstract contract Ownable is Context {
  address private _owner;

  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

  /**
   * @dev Initializes the contract setting the deployer as the initial owner.
   */
  constructor() {
    address msgSender = _msgSender();
    _owner = msgSender;
    emit OwnershipTransferred(address(0), msgSender);
  }

  /**
   * @dev Returns the address of the current owner.
   */
  function owner() public view virtual returns (address) {
    return _owner;
  }

  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(owner() == _msgSender(), 'Ownable: caller is not the owner');
    _;
  }

  /**
   * @dev Leaves the contract without owner. It will not be possible to call
   * `onlyOwner` functions anymore. Can only be called by the current owner.
   *
   * NOTE: Renouncing ownership will leave the contract without an owner,
   * thereby removing any functionality that is only available to the owner.
   */
  function renounceOwnership() public virtual onlyOwner {
    emit OwnershipTransferred(_owner, address(0));
    _owner = address(0);
  }

  /**
   * @dev Transfers ownership of the contract to a new account (`newOwner`).
   * Can only be called by the current owner.
   */
  function transferOwnership(address newOwner) public virtual onlyOwner {
    require(newOwner != address(0), 'Ownable: new owner is the zero address');
    emit OwnershipTransferred(_owner, newOwner);
    _owner = newOwner;
  }
}

contract PlatformDeposit is Ownable {
  using SafeMath for uint256;
  using SafeBEP20 for IBEP20;

  IBEP20 public token;
  mapping(address => bool) public isUser;
  mapping(address => uint256) public userAmount;
  mapping(address => uint256[]) public userDeductEvents;
  uint256 public depositTokens = 100;
  uint256 public creationdepositTokens = 1000;
  address public eventsAddress;
  address public arbitratorAddress;

  constructor(IBEP20 eToken, uint256 deposittok) {
    token = eToken;
    depositTokens = deposittok;
  }

  function setDepositAmount(uint256 depositAmount) public onlyOwner {
    require(depositAmount > 0, 'Amount cannot be 0');
    depositTokens = depositAmount;
  }

  function setCreationDepositAmount(uint256 depositAmount) public onlyOwner {
    require(depositAmount > 0, 'Amount cannot be 0');
    creationdepositTokens = depositAmount;
  }

  function setEventContractAddress(address contractAddress) public onlyOwner {
    eventsAddress = contractAddress;
  }

  function setArbitratorContractAddress(address contractAddress) public onlyOwner {
    arbitratorAddress = contractAddress;
  }

  function deposit(uint256 tokens) public {
    // require( keccak256(abi.encodePacked(eventsAddress)) != keccak256(abi.encodePacked("")), "Event contact address not present.");
    require(tokens >= depositTokens, 'minimum tokens conditon not met');
    require(token.balanceOf(msg.sender) >= tokens, 'Not enough tokens');
    require(!Arbitrator(arbitratorAddress).isArbitrator(msg.sender), 'Sender is an arbitrator');
    token.safeTransferFrom(msg.sender, address(this), tokens);
    isUser[msg.sender] = true;
    userAmount[msg.sender] = userAmount[msg.sender].add(tokens);
  }

  function deductDeposit(address userAddress, address arbWallet) public returns (bool) {
    require(Events(eventsAddress).checkUserCommunityEvent(msg.sender), 'Sender Not Valid.');
    require(userAmount[userAddress] >= depositTokens, 'Not enough tokens');
    token.safeTransfer(arbWallet, depositTokens);
    userAmount[userAddress] = userAmount[userAddress].sub(depositTokens);
    return true;
  }

  function getBalance(address user) external view returns (uint256) {
    return userAmount[user];
  }

  function hasDeposit(address user) external view returns (uint256) {
    if (userAmount[user] >= creationdepositTokens) {
      return 2;
    } else if (userAmount[user] >= depositTokens) {
      return 1;
    } else {
      return 0;
    }
  }

  function withdraw(uint256 tokens) public {
    require(isUser[msg.sender], 'no deposit');
    require(userAmount[msg.sender] >= tokens, 'Not enough deposit');
    require(!Events(eventsAddress).checkLiveBets(msg.sender), 'Cannot withdraw deposits as user has live bets');
    token.safeTransfer(msg.sender, tokens);
    userAmount[msg.sender] = userAmount[msg.sender] - tokens;
    if (userAmount[msg.sender] < depositTokens) {
      isUser[msg.sender] = false;
    }
  }

  function transferAnyBEP20(address _tokenAddress, address _to, uint256 _amount) external {
    require((owner() == _to), 'Not a valid owner address');
    IERC20Metadata(_tokenAddress).transfer(_to, _amount);
  }

  function transferStuckBNB(address _to, uint256 _amount) external {
    require((owner() == _to), 'Not a valid owner address');
    payable(_to).transfer(_amount);
  }
}

contract Arbitrator is Ownable {
  using SafeMath for uint256;
  using SafeBEP20 for IBEP20;

  IBEP20 public token;
  mapping(address => bool) public isArbitrator;
  mapping(address => uint256) public arbitratorAmount;
  mapping(address => uint256) public arbitratorWrongInput;
  uint256 public minimumTokens = 100;
  uint256 public wrongInputLimit = 3;
  address burnBuyBack;
  address public depositContractAddress;
  address public eventsAddress;

  constructor(IBEP20 eToken, uint256 minimum, address burnBuyBackAddr) {
    token = eToken;
    minimumTokens = minimum;
    burnBuyBack = burnBuyBackAddr;
  }

  function setDepositContractAddress(address contractAddress) public onlyOwner {
    depositContractAddress = contractAddress;
  }

  function setEventContractAddress(address contractAddress) public onlyOwner {
    eventsAddress = contractAddress;
  }

  function setWrongInputLimit(uint256 wrongLimit) public onlyOwner {
    wrongInputLimit = wrongLimit;
  }

  function setMinimumTokens(uint256 minimum) public onlyOwner {
    require(minimum > 0, 'minimum tokens cannot be 0');
    minimumTokens = minimum;
  }

  function join(uint256 tokens) public {
    require(!isArbitrator[msg.sender], 'already arbitrator');
    require(tokens >= minimumTokens, 'minimum tokens conditon not meet');
    require(token.balanceOf(msg.sender) >= tokens, 'Not enough tokens');
    require(!PlatformDeposit(depositContractAddress).isUser(msg.sender), 'User cannot be arbitrator');
    token.safeTransferFrom(msg.sender, address(this), tokens);
    isArbitrator[msg.sender] = true;
    arbitratorAmount[msg.sender] = tokens;
    arbitratorWrongInput[msg.sender] = 0;
  }

  function addWrongInput(address arbitrator) public {
    require(isArbitrator[arbitrator], 'Not an arbitrator');
    require(Events(eventsAddress).checkUserCommunityEvent(msg.sender), 'Sender Not Valid.');
    arbitratorWrongInput[arbitrator] = arbitratorWrongInput[arbitrator] + 1;
    if (arbitratorWrongInput[arbitrator] >= wrongInputLimit) {
      token.safeTransfer(burnBuyBack, arbitratorAmount[msg.sender]);
      arbitratorAmount[msg.sender] = 0;
      isArbitrator[arbitrator] = false;
    }
  }

  function getWrongInputs(address arbitratoraddr) public view returns (uint256) {
    return arbitratorWrongInput[arbitratoraddr];
  }

  function leave() public {
    require(isArbitrator[msg.sender], 'not an arbitrator');
    if (arbitratorAmount[msg.sender] > 0) {
      token.safeTransfer(msg.sender, arbitratorAmount[msg.sender]);
    }
    isArbitrator[msg.sender] = false;
    arbitratorAmount[msg.sender] = 0;
    arbitratorWrongInput[msg.sender] = 0;
  }

  function transferAnyBEP20(address _tokenAddress, address _to, uint256 _amount) external {
    require((owner() == _to), 'Not a valid owner address');
    IERC20Metadata(_tokenAddress).transfer(_to, _amount);
  }

  function transferStuckBNB(address _to, uint256 _amount) external {
    require((owner() == _to), 'Not a valid owner address');
    payable(_to).transfer(_amount);
  }
}

contract Events is Ownable {
  //using SafeBEP20 for IBEP20;

  // IBEP20 private token;
  IERC20 private erc20StableCoinContract;
  address private erc20StableContractAddress;
  uint256 private eventId;

  struct Community {
    uint256 eventId;
    string category;
    address cEvent;
  }
  struct eventDetails {
    string category;
    string name;
    uint256 bidStartTime;
    uint256 endTime;
    uint256 bidEndTime;
    string outcomeSource;
    string notes;
    string[] outcomes;
    uint256[] outcomeNumbers;
  }

  Community[] public communityEvents;
  Community[] public communityOngoingEvents;
  struct Category {
    string categoryName;
    string parentCategory;
  }
  Category[] private categoryList;
  mapping(string => bool) private isCategory;
  mapping(address => uint256[]) public userLiveEvents;
  mapping(address => uint256[]) public userAllEvents;
  address private depositContractAddress;
  address private arbContractAddress;
  address public buyBackBurnWallet = 0x3AC744069bC1905035099a57e36324994B60d894;
  address public oracleWallet = 0xaC343624ce992a53F1865Ab826381C493c263252;
  uint256[] public calPara = [24, 24, 2, 1, 70, 0, 0];

  constructor(
    //IBEP20 eToken,
    address depositContractAddr,
    address arbContractAddr,
    address erc20StableContractAddr
  ) {
    // token = eToken;
    depositContractAddress = depositContractAddr;
    arbContractAddress = arbContractAddr;
    erc20StableContractAddress = erc20StableContractAddr;
    erc20StableCoinContract = IERC20(erc20StableContractAddr);
  }

  function isOwner(address _toAddress) public view returns (bool) {
    return (owner() == _toAddress);
  }

  function getEventId() private returns (uint256) {
    return eventId++;
  }

  function userJoinEvent(address userAddress, uint256 peventId) public {
    userLiveEvents[userAddress].push(peventId);
    userAllEvents[userAddress].push(peventId);
  }

  function userLeaveEvent(address userAddress, uint256 peventId) public {
    for (uint256 i = 0; i < userLiveEvents[userAddress].length; i++) {
      if (userLiveEvents[userAddress][i] == peventId) {
        userLiveEvents[userAddress][i] = userLiveEvents[userAddress][userLiveEvents[userAddress].length - 1];
        userLiveEvents[userAddress].pop();
      }
    }
  }

  function eventClosed(uint256 peventId) public {
    for (uint256 i = 0; i < communityOngoingEvents.length; i++) {
      if (communityOngoingEvents[i].eventId == peventId) {
        if (msg.sender == communityOngoingEvents[i].cEvent) {
          communityOngoingEvents[i] = communityOngoingEvents[communityOngoingEvents.length - 1];
          communityOngoingEvents.pop();
        }
      }
    }
  }

  function addCategory(string memory categoryName, string memory parentCategory) external onlyOwner {
    require(keccak256(abi.encodePacked(categoryName)) != keccak256(abi.encodePacked('')), 'No category specified');
    require(!isCategory[categoryName], 'Category already exists');
    if (keccak256(abi.encodePacked(parentCategory)) != keccak256(abi.encodePacked(''))) {
      require(isCategory[parentCategory], 'Parent Category not found');
    }
    Category memory newCat = Category(categoryName, parentCategory);
    categoryList.push(newCat);
    isCategory[categoryName] = true;
  }

  function getCategoryList() external view returns (Category[] memory) {
    return categoryList;
  }

  function checkLiveBets(address userAddress) external view returns (bool) {
    if (userLiveEvents[userAddress].length > 0) {
      return true;
    } else {
      return false;
    }
  }

  function checkUserCommunityEvent(address pevent) external view returns (bool) {
    bool isValid = false;
    for (uint256 i = 0; i < communityOngoingEvents.length; i++) {
      if (communityOngoingEvents[i].cEvent == pevent) {
        isValid = true;
      }
    }
    return isValid;
  }

  function createCommunityEvent(
    string memory pcategory,
    string memory pname,
    uint256 pbidStartTime,
    uint256 pendTime,
    uint256 pbidEndTime,
    string memory poutcomeSource,
    string memory pnotes,
    string[] memory poutcomes,
    uint256[] memory poutcomeNumbers
  ) public {
    require(
      PlatformDeposit(depositContractAddress).hasDeposit(msg.sender) == 2,
      'No platform deposit found for the user.'
    );
    Community memory communityEvent;
    communityEvent.category = pcategory;
    uint256 newTempEventId = getEventId();
    communityEvent.eventId = newTempEventId;
    eventDetails memory evntDetails;
    evntDetails.category = pcategory;
    evntDetails.name = pname;
    evntDetails.bidStartTime = pbidStartTime;
    evntDetails.endTime = pendTime;
    evntDetails.bidEndTime = pbidEndTime;
    evntDetails.outcomeSource = poutcomeSource;
    evntDetails.notes = pnotes;
    evntDetails.outcomes = poutcomes;
    evntDetails.outcomeNumbers = poutcomeNumbers;

    if (calPara[6] > 0) {
      require(erc20StableCoinContract.balanceOf(msg.sender) >= calPara[6], 'Not enough tokens for creation fee');
      erc20StableCoinContract.transferFrom(msg.sender, address(this), calPara[6]);
    }

    communityEvent.cEvent = address(
      new CommunityEvent(
        //  token,
        erc20StableCoinContract,
        newTempEventId,
        evntDetails,
        address(this),
        arbContractAddress,
        depositContractAddress,
        msg.sender
      )
    );
    // userJoinEvent(msg.sender, newTempEventId);
    communityEvents.push(communityEvent);
    communityOngoingEvents.push(communityEvent);
  }

  function transferAnyBEP20(address _tokenAddress, address _to, uint256 _amount) external {
    require((owner() == _to), 'Not a valid owner address');
    IERC20Metadata(_tokenAddress).transfer(_to, _amount);
  }

  function transferStuckBNB(address _to, uint256 _amount) external {
    require((owner() == _to), 'Not a valid owner address');
    payable(_to).transfer(_amount);
  }

  function setPara(address pbuyBackBurnWallet, address poracleWallet, uint256[] memory para) public onlyOwner {
    buyBackBurnWallet = pbuyBackBurnWallet;
    oracleWallet = poracleWallet;
    for (uint256 t = 0; t < para.length; t++) {
      calPara[t] = para[t];
    }
  }
}

contract CommunityEvent is Ownable {
  using SafeMath for uint256;
  using SafeBEP20 for IBEP20;

  address private arbitratorAddress;
  address private depositAddress;
  address private creatorAddress;

  uint256 public eventId;
  //  IBEP20 private token;
  IERC20 private erc20StableCoinContract;
  string public eventName;
  uint256 public endTimeStamp;
  uint256 public bidStartTimeStamp;
  uint256 public bidEndTimeStamp;
  string public outcomeSource;
  string public notes;

  address[] public eventUsers;
  mapping(address => bool) isEventUser;
  mapping(address => uint256) public userBalance;
  mapping(address => uint256) public userInvested;
  address[] public eventArbitrators;
  mapping(address => uint256) public eventArbitratorVote;
  mapping(address => bool) isEventArbitrator;
  address private mainContractAddress;

  enum Status {
    Open,
    Claimed,
    Resolved,
    InDispute,
    InArbitration,
    Cancelled
  }

  Status public status;

  struct Outcome {
    uint256 number;
    string name;
    uint256 totalAmount;
    uint256 acceptCount;
    uint256 rejectCount;
    mapping(address => uint256) userAmounts;
    address[] users;
    mapping(address => bool) userVotes;
  }

  uint256[] private outcomeNumbers;
  uint256[] private arbOutcomes;
  mapping(uint256 => Outcome) public outcomes;
  mapping(uint256 => uint256) private arbVotes;
  mapping(address => bool) public isDisputer;
  address public disputers;
  uint256 public disputersOutcome;
  uint256 public reportingOutcome;
  address public reportingUser;
  uint256 public winningOutcome;
  uint256 public arbitrationEndTime;

  event BidRaised(address indexed user, string outcome, uint256 outcomeNumber, uint256 amount, uint256 now);

  constructor(
    IERC20 terc20StableCoinContract,
    uint256 eId,
    Events.eventDetails memory ev,
    address mContractAddress,
    address arbContractAddress,
    address depositContractAddress,
    address creatorAddr
  ) {
    erc20StableCoinContract = terc20StableCoinContract;
    eventId = eId;
    eventName = ev.name;
    bidStartTimeStamp = ev.bidStartTime;
    endTimeStamp = ev.endTime;
    bidEndTimeStamp = ev.bidEndTime;
    outcomeSource = ev.outcomeSource;
    notes = ev.notes;
    status = Status.Open;
    mainContractAddress = mContractAddress;
    arbitratorAddress = arbContractAddress;
    depositAddress = depositContractAddress;
    creatorAddress = creatorAddr;

    eventUsers.push(msg.sender);
    isEventUser[msg.sender] = true;

    arbitrationEndTime =
      endTimeStamp +
      ((Events(mainContractAddress).calPara(0) + Events(mainContractAddress).calPara(1)) * 1 hours);

    createOutcomes(ev.outcomes, ev.outcomeNumbers);
  }

  function getOutcomeList() public view returns (uint256[] memory values) {
    return (outcomeNumbers);
  }

  function getCloseTime() public view returns (uint256) {
    return endTimeStamp + (Events(mainContractAddress).calPara(0) * 1 hours);
  }

  function createOutcomes(string[] memory userOutcomes, uint256[] memory outcomeNos) private onlyOwner {
    for (uint256 i = 0; i < outcomeNos.length; i++) {
      Outcome storage outcome = outcomes[outcomeNos[i]];
      outcome.number = outcomeNos[i];
      outcome.name = userOutcomes[i];
      outcome.totalAmount = 0;
      outcome.acceptCount = 0;
      outcome.rejectCount = 0;
      outcomeNumbers.push(outcomeNos[i]);
    }
  }

  function join(uint256[] memory outcomeNos, uint256[] memory amounts) public {
    require(status == Status.Open, 'Event is not open');
    require(block.timestamp >= bidStartTimeStamp, 'Bidding time has not started.');
    require(block.timestamp <= bidEndTimeStamp, 'Bidding time has ended.');
    require(PlatformDeposit(depositAddress).hasDeposit(msg.sender) >= 1, 'No platform deposit found for the user.');

    for (uint256 i = 0; i < outcomeNos.length; i++) {
      require(erc20StableCoinContract.balanceOf(msg.sender) >= amounts[i], 'Not enough fund');
      erc20StableCoinContract.transferFrom(msg.sender, address(this), amounts[i]);
      Outcome storage outcome = outcomes[outcomeNos[i]];
      outcome.userAmounts[msg.sender] = outcome.userAmounts[msg.sender].add(amounts[i]);

      outcome.totalAmount = outcome.totalAmount.add(amounts[i]);
      if (!outcome.userVotes[msg.sender]) {
        outcome.userVotes[msg.sender] = true;
        outcome.users.push(msg.sender);
      }

      userInvested[msg.sender] += amounts[i];
      emit BidRaised(msg.sender, outcome.name, outcome.number, amounts[i], block.timestamp);
    }

    if (!isEventUser[msg.sender]) {
      Events(mainContractAddress).userJoinEvent(msg.sender, eventId);

      eventUsers.push(msg.sender);
      isEventUser[msg.sender] = true;
      userBalance[msg.sender] = 0;
    }
  }

  function claim(uint256 outcomeNo) public {
    require(status == Status.Open, 'Event is not open');
    require(block.timestamp >= endTimeStamp, 'Claim can be done only after event ends.');
    require(
      block.timestamp <= endTimeStamp + Events(mainContractAddress).calPara(0) * 1 hours,
      'Claim time not valid.'
    );
    require(isEventUser[msg.sender], 'You have not joined the event');

    status = Status.Claimed;
    reportingOutcome = outcomeNo;
    reportingUser = msg.sender;
  }

  function raiseDispute(uint256 outcomeNo) public {
    require(status == Status.Claimed, 'Event is not in claimed state.');
    require(block.timestamp >= endTimeStamp, 'Dispute can be raised only after event ends.');
    require(
      block.timestamp <= endTimeStamp + Events(mainContractAddress).calPara(0) * 1 hours,
      'Dispute time not valid.'
    );
    require(isEventUser[msg.sender], 'You have not joined the event');
    require(!isDisputer[msg.sender], 'Already voted');
    require(reportingOutcome != outcomeNo, 'Claimed output is same.');
    if (!isDisputer[msg.sender]) {
      isDisputer[msg.sender] = true;
      disputers = msg.sender;
      disputersOutcome = outcomeNo;
      status = Status.InDispute;
      arbitrationEndTime = block.timestamp + (Events(mainContractAddress).calPara(1) * 1 hours);
    }
  }

  function arbitratorVote(uint256 outcomeNo) public {
    require(Arbitrator(arbitratorAddress).isArbitrator(msg.sender), 'Not an arbitrator');
    require(
      (status == Status.InArbitration) ||
        (status == Status.InDispute) ||
        ((status == Status.Open &&
          block.timestamp >= endTimeStamp + (Events(mainContractAddress).calPara(0) * 1 hours)) &&
          block.timestamp <= arbitrationEndTime),
      'Time Invalid.'
    );
    require(!isEventArbitrator[msg.sender], 'Already Voted');
    isEventArbitrator[msg.sender] = true;
    eventArbitrators.push(msg.sender);
    eventArbitratorVote[msg.sender] = outcomeNo;
    status = Status.InArbitration;
  }

  function closeEvent() public {
    require(status != Status.Resolved && status != Status.Cancelled, 'Status is already Resolved/Cancelled');

    if (status == Status.Claimed) {
      require(block.timestamp > endTimeStamp + (Events(mainContractAddress).calPara(0) * 1 hours), 'Time not valid');
    } else {
      require(block.timestamp > arbitrationEndTime, 'Time not valid-');
    }

    if (status == Status.Open) {
      closeCancelStatus();
      status = Status.Cancelled;
    } else if (status == Status.Claimed) {
      closeClaimedStatus(reportingOutcome);
      status = Status.Resolved;
    } else if (status == Status.InDispute) {
      closeCancelStatus();
      status = Status.Cancelled;
    } else if (status == Status.InArbitration) {
      closeArbitrationStatus();
    }

    for (uint256 i = 0; i < eventUsers.length; i++) {
      Events(mainContractAddress).userLeaveEvent(eventUsers[i], eventId);
    }
    Events(mainContractAddress).eventClosed(eventId);
  }

  function closeCancelStatus() private {
    for (uint256 i = 0; i < eventUsers.length; i++) {
      if (userInvested[eventUsers[i]] > 0) {
        userBalance[eventUsers[i]] = userInvested[eventUsers[i]];
      }
    }
  }

  function getOutcomeUserAmounts(address useraddr, uint256 outcomeno) public view returns (uint256) {
    Outcome storage outcome = outcomes[outcomeNumbers[outcomeno]];
    return outcome.userAmounts[useraddr];
  }

  function getOutcomeUsers(uint256 outcomeno) public view returns (address[] memory) {
    Outcome storage outcome = outcomes[outcomeNumbers[outcomeno]];
    return outcome.users;
  }

  function getUserInvested(address useraddr) public view returns (uint256) {
    return userInvested[useraddr];
  }

  function closeClaimedStatus(uint256 pwinningOutcome) private {
    winningOutcome = pwinningOutcome;
    (uint256 total, uint256 winnersTotal) = getTotalAmounts(winningOutcome);
    if (winnersTotal > 0) {
      for (uint256 i = 0; i < outcomeNumbers.length; i++) {
        if (outcomeNumbers[i] == winningOutcome) {
          Outcome storage outcome = outcomes[outcomeNumbers[i]];
          for (uint256 j = 0; j < outcome.users.length; j++) {
            uint256 userAmount = outcome.userAmounts[outcome.users[j]];
            userBalance[outcome.users[j]] = calculateAmount(total, winnersTotal, userAmount);
          }
        }
      }
    }
    (, uint256 buyBackAMount, uint256 oracleAMount, uint256 creatorAmount) = calculatebuyBackAndOracle(
      total,
      winnersTotal
    );
    if (buyBackAMount > 0) {
      erc20StableCoinContract.transfer(Events(mainContractAddress).buyBackBurnWallet(), buyBackAMount);
    }
    if (oracleAMount > 0) {
      erc20StableCoinContract.transfer(Events(mainContractAddress).oracleWallet(), oracleAMount);
    }
    if (creatorAmount > 0) {
      userBalance[creatorAddress] += creatorAmount;
    }
  }

  function closeArbitrationStatus() private {
    uint256 maxVoteCount;
    uint256 maxVoteOutcome;
    uint256 i;
    for (i = 0; i < eventArbitrators.length; i++) {
      if (eventArbitratorVote[eventArbitrators[i]] > 0) {
        if (arbVotes[eventArbitratorVote[eventArbitrators[i]]] == 0) {
          arbOutcomes.push(eventArbitratorVote[eventArbitrators[i]]);
        }
        arbVotes[eventArbitratorVote[eventArbitrators[i]]] += 1;
        if (arbVotes[eventArbitratorVote[eventArbitrators[i]]] > maxVoteCount) {
          maxVoteCount = arbVotes[eventArbitratorVote[eventArbitrators[i]]];
          maxVoteOutcome = eventArbitratorVote[eventArbitrators[i]];
        }
      }
    }
    if (maxVoteCount.mul(100).div(eventArbitrators.length) >= Events(mainContractAddress).calPara(4)) {
      winningOutcome = maxVoteOutcome;
      if (reportingOutcome != winningOutcome) {
        PlatformDeposit(depositAddress).deductDeposit(reportingUser, Events(mainContractAddress).oracleWallet());
      } else {
        // for (i = 0; i < disputers.length; i++) {
        PlatformDeposit(depositAddress).deductDeposit(disputers, Events(mainContractAddress).oracleWallet());
        // }
      }

      for (i = 0; i < eventArbitrators.length; i++) {
        if (eventArbitratorVote[eventArbitrators[i]] != winningOutcome) {
          Arbitrator(arbitratorAddress).addWrongInput(eventArbitrators[i]);
        }
      }

      closeClaimedStatus(winningOutcome);
      status = Status.Resolved;
    } else {
      closeCancelStatus();
      status = Status.Cancelled;
    }
  }

  function calculatebuyBackAndOracle(
    uint256 total,
    uint256 winnersTotal
  ) public view returns (uint256, uint256, uint256, uint256) {
    uint256 creatorAMount = 0;
    uint256 totalExcludingWinner = total - winnersTotal;
    uint256 oracleAMount = totalExcludingWinner.mul(Events(mainContractAddress).calPara(3)).div(100);
    uint256 buyBackAMount = totalExcludingWinner.mul(Events(mainContractAddress).calPara(2)).div(100);
    if (Events(mainContractAddress).calPara(5) > 0) {
      creatorAMount = totalExcludingWinner.mul(Events(mainContractAddress).calPara(5)).div(100);
    }
    total = total - oracleAMount - buyBackAMount - creatorAMount;
    if (winnersTotal == 0) {
      buyBackAMount = buyBackAMount + total;
    }
    return (total, buyBackAMount, oracleAMount, creatorAMount);
  }

  function calculateAmount(uint256 total, uint256 winnersTotal, uint256 investedAmount) public view returns (uint256) {
    uint256 tranferAmount = 0;

    (uint256 totalExcludingBurnOracle, , , ) = calculatebuyBackAndOracle(total, winnersTotal);

    //For each user = All total: 350 * (user1: 100 / all winners total: (100 + 50))
    tranferAmount = totalExcludingBurnOracle.mul(investedAmount).div(winnersTotal);
    return tranferAmount;
  }

  function getTotalAmounts(uint256 pwinningOutcome) public view returns (uint256, uint256) {
    uint256 total = 0;
    uint256 winnerstotal = 0;
    for (uint256 i = 0; i < outcomeNumbers.length; i++) {
      total = total.add(outcomes[outcomeNumbers[i]].totalAmount);
    }
    winnerstotal = winnerstotal.add(outcomes[pwinningOutcome].totalAmount);
    return (total, winnerstotal);
  }

  function claimAmount() public returns (uint256) {
    require(userBalance[msg.sender] > 0, 'Nothing to claim');
    uint256 tAmount = userBalance[msg.sender];
    erc20StableCoinContract.transfer(msg.sender, tAmount);
    userBalance[msg.sender] = 0;
    return tAmount;
  }

  function transferAnyBEP20(address _tokenAddress, address _to, uint256 _amount) external {
    require(Events(mainContractAddress).isOwner(_to), 'Not a valid owner address');
    IERC20Metadata(_tokenAddress).transfer(_to, _amount);
  }

  function transferStuckBNB(address _to, uint256 _amount) external {
    require(Events(mainContractAddress).isOwner(_to), 'Not a valid owner address');
    payable(_to).transfer(_amount);
  }
}