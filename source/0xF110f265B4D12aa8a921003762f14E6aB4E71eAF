{"BEP20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nimport \"./IBEP20.sol\";\nimport \"./Ownable.sol\";\n\ncontract BEP20 is IBEP20, Ownable {\n    mapping (address =\u003e uint256) private _balances;\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\n\n    string private constant NAME = \"DBQuest\";\n    string private constant SYMBOL = \"DBQ\";\n    uint8 private constant DECIMALS = 18;\n    uint256 private constant TOTAL_SUPPLY = 10**9 * 10**DECIMALS;\n\n    constructor(address owner, address recipient) Ownable(owner) {\n        require(recipient != address(0), \"Transfer to zero address\");\n        _balances[recipient] = TOTAL_SUPPLY;\n        emit Transfer(address(0), recipient, TOTAL_SUPPLY);\n    }\n\n    function getOwner() public view returns (address) {\n        return owner();\n    }\n\n    function decimals() public pure returns (uint8) {\n        return DECIMALS;\n    }\n\n    function symbol() external pure returns (string memory) {\n        return SYMBOL;\n    }\n\n    function name() external pure returns (string memory) {\n        return NAME;\n    }\n\n    function totalSupply() public pure returns (uint256) {\n        return TOTAL_SUPPLY;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) external returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) external view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) external returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance \u003e= amount, \"BEP20: transfer amount exceeds allowance\");\n            unchecked {\n                _approve(sender, msg.sender, currentAllowance - amount);\n            }\n        }\n\n        _transfer(sender, recipient, amount);\n\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[msg.sender][spender];\n        require(currentAllowance \u003e= subtractedValue, \"BEP20: decreased allowance below zero\");\n        unchecked {\n            _approve(msg.sender, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"BEP20: transfer from the zero address\");\n        require(recipient != address(0), \"BEP20: transfer to the zero address\");\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance \u003e= amount, \"BEP20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"BEP20: approve from the zero address\");\n        require(spender != address(0), \"BEP20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n}\n"},"DBQ.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nimport \"./BEP20.sol\";\nimport \"./IDEX.sol\";\n\ncontract DBQ is BEP20 {\n    IDEXRouter public constant ROUTER = IDEXRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    address public immutable pair;\n\n    address public marketingWallet;\n    address public sparkWallet;\n\n    uint256 public swapThreshold = 1;\n    bool public swapWholeStorage = true;\n    bool public swapEnabled = true;\n    bool inSwap;\n\n    bool tradingEnabled;\n    bool dynamicBuyTaxEnabled = true;\n    bool dynamicSellTaxEnabled = true;\n\n    uint256 public buyTax = 800;\n    uint256 public sellTax = 1200;\n    uint256 public transferTax = 5000;\n\n    uint256 public liquidityShare = 170;\n    uint256 public marketingShare = 680;\n    uint256 public sparkShare = 150;\n    uint256 totalShares = 1000;\n    uint256 constant TAX_DENOMINATOR = 10000;\n\n    uint256 public transferGas = 25000;\n    uint256 public launchTime;\n\n    mapping (address =\u003e bool) public isWhitelisted;\n    mapping (address =\u003e bool) public isCEX;\n    mapping (address =\u003e bool) public isMarketMaker;\n\n    event EnableTrading();\n    event DisableDynamicBuyTax();\n    event DisableDynamicSellTax();\n    event TriggerSwapBack(uint256 amount);\n    event RecoverBNB(address recipient, uint256 amount);\n    event RecoverBEP20(address indexed token, address recipient, uint256 amount);\n    event SetIsWhitelisted(address indexed account, bool indexed status);\n    event SetIsCEX(address indexed account, bool indexed exempt);\n    event SetIsMarketMaker(address indexed account, bool indexed isMM);\n    event SetTaxes(uint256 buy, uint256 sell, uint256 transfer);\n    event SetShares(uint256 liquidityShare, uint256 marketingShare, uint256 sparkShare);\n    event SetSwapBackSettings(bool enabled, bool swapAll, uint256 amount);\n    event SetTransferGas(uint256 newGas, uint256 oldGas);\n    event SetMarketingWallet(address newWallet, address oldWallet);\n    event SetSparkWallet(address newAddress, address oldAddress);\n    event AutoLiquidity(uint256 pair, uint256 tokens);\n    event DepositMarketing(address indexed wallet, uint256 amount);\n    event DepositSpark(address indexed wallet, uint256 amount);\n\n    constructor(address owner, address marketing, address spark, address saleHost) BEP20(owner, saleHost) {\n        pair = IDEXFactory(ROUTER.factory()).createPair(ROUTER.WETH(), address(this));\n        _approve(address(this), address(ROUTER), type(uint256).max);\n        isMarketMaker[pair] = true;\n\n        sparkWallet = spark;\n        marketingWallet = marketing;\n        isWhitelisted[saleHost] = true;\n    }\n\n    // Override\n\n    function _transfer(address sender, address recipient, uint256 amount) internal override {\n        if (isWhitelisted[sender] || isWhitelisted[recipient] || inSwap) {\n            super._transfer(sender, recipient, amount);\n            return;\n        }\n        require(tradingEnabled, \"Trading is disabled\");\n\n        if (_shouldSwapBack(recipient)) {\n            uint256 swapAmount = swapWholeStorage ? balanceOf(address(this)) : swapThreshold;\n            _swapBack(swapAmount);\n        }\n        uint256 amountAfterTaxes = _takeTax(sender, recipient, amount);\n\n        super._transfer(sender, recipient, amountAfterTaxes);\n    }\n\n    // Public\n\n    /**\n     * @dev Decrease the buy tax from 99% to normal rate within 3 minutes.\n     * Returns buy tax percentage\n     */\n    function getDynamicBuyTax() public view returns (uint256) {\n        uint256 endingTime = launchTime + 3 minutes;\n\n        if (endingTime \u003e block.timestamp) {\n            uint256 remainingTime = endingTime - block.timestamp;\n            return buyTax + 9100 * remainingTime / 3 minutes;\n        } else {\n            return buyTax;\n        }\n    }\n\n    /**\n     * @dev Decrease the sell tax from 18% to normal rate within 5 hours.\n     * Returns sell tax percentage\n     */\n    function getDynamicSellTax() public view returns (uint256) {\n        uint256 endingTime = launchTime + 5 hours;\n\n        if (endingTime \u003e block.timestamp) {\n            uint256 remainingTime = endingTime - block.timestamp;\n            return sellTax + 600 * remainingTime / 5 hours;\n        } else {\n            return sellTax;\n        }\n    }\n\n    receive() external payable {}\n\n    // Private\n\n    function _takeTax(address sender, address recipient, uint256 amount) private returns (uint256) {\n        if (amount == 0) { return amount; }\n\n        uint256 taxAmount = amount * _getTotalTax(sender, recipient) / TAX_DENOMINATOR;\n        if (taxAmount \u003e 0) { super._transfer(sender, address(this), taxAmount); }\n\n        return amount - taxAmount;\n    }\n\n    function _getTotalTax(address sender, address recipient) private view returns (uint256) {\n        if (isCEX[recipient]) { return 0; }\n        if (isCEX[sender]) { return buyTax; }\n\n        if (isMarketMaker[sender]) {\n            return dynamicBuyTaxEnabled ? getDynamicBuyTax() : buyTax;\n        } else if (isMarketMaker[recipient]) {\n            return dynamicSellTaxEnabled ? getDynamicSellTax() : sellTax;\n        } else {\n            return transferTax;\n        }\n    }\n\n    function _shouldSwapBack(address recipient) private view returns (bool) {\n        return isMarketMaker[recipient] \u0026\u0026 swapEnabled \u0026\u0026 balanceOf(address(this)) \u003e= swapThreshold;\n    }\n\n    function _swapBack(uint256 tokenAmount) private {\n        inSwap = true;\n\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = ROUTER.WETH();\n\n        uint256 liquidityTokens = tokenAmount * liquidityShare / totalShares / 2;\n        uint256 amountToSwap = tokenAmount - liquidityTokens;\n        uint256 balanceBefore = address(this).balance;\n\n        ROUTER.swapExactTokensForETH(\n            amountToSwap,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n\n        uint256 amountBNB = address(this).balance - balanceBefore;\n        uint256 totalBNBShares = totalShares - liquidityShare / 2;\n\n        uint256 amountBNBLiquidity = amountBNB * liquidityShare / totalBNBShares / 2;\n        uint256 amountBNBMarketing = amountBNB * marketingShare / totalBNBShares;\n        uint256 amountBNBSpark = amountBNB * sparkShare / totalBNBShares;\n\n        (bool marketingSuccess,) = payable(marketingWallet).call{value: amountBNBMarketing, gas: transferGas}(\"\");\n        if (marketingSuccess) { emit DepositMarketing(marketingWallet, amountBNBMarketing); }\n        (bool sparkSuccess,) = payable(sparkWallet).call{value: amountBNBSpark, gas: transferGas}(\"\");\n        if (sparkSuccess) { emit DepositSpark(sparkWallet, amountBNBSpark); }\n\n        if (liquidityTokens \u003e 0) {\n            ROUTER.addLiquidityETH{value: amountBNBLiquidity}(\n                address(this),\n                liquidityTokens,\n                0,\n                0,\n                address(this),\n                block.timestamp\n            );\n\n            emit AutoLiquidity(amountBNBLiquidity, liquidityTokens);\n        }\n\n        inSwap = false;\n    }\n\n    // Owner\n\n    function enableTrading() external onlyOwner {\n        require(!tradingEnabled, \"Trading is already enabled\");\n        tradingEnabled = true;\n        launchTime = block.timestamp;\n        emit EnableTrading();\n    }\n\n    function disableDynamicBuyTax() external onlyOwner {\n        dynamicBuyTaxEnabled = false;\n        emit DisableDynamicBuyTax();\n    }\n\n    function disableDynamicSellTax() external onlyOwner {\n        dynamicSellTaxEnabled = false;\n        emit DisableDynamicSellTax();\n    }\n\n    function triggerSwapBack(bool swapAll, uint256 amount) external onlyOwner {\n        uint256 tokenAmount = swapAll ? balanceOf(address(this)) : amount * 10**decimals();\n        require(balanceOf(address(this)) \u003e= tokenAmount, \"Insufficient balance\");\n        _swapBack(tokenAmount);\n        emit TriggerSwapBack(tokenAmount);\n    }\n\n    function recoverBNB(address recipient) external onlyOwner {\n        uint256 amount = address(this).balance;\n        (bool sent,) = payable(recipient).call{value: amount, gas: transferGas}(\"\");\n        require(sent, \"Tx failed\");\n        emit RecoverBNB(recipient, amount);\n    }\n\n    function recoverBEP20(IBEP20 token, address recipient) external onlyOwner {\n        require(address(token) != address(this), \"Can\u0027t withdraw DBQ\");\n        uint256 amount = token.balanceOf(address(this));\n        token.transfer(recipient, amount);\n        emit RecoverBEP20(address(token), recipient, amount);\n    }\n\n    function setIsWhitelisted(address account, bool value) external onlyOwner {\n        isWhitelisted[account] = value;\n        emit SetIsWhitelisted(account, value);\n    }\n\n    function setIsCEX(address account, bool value) external onlyOwner {\n        isCEX[account] = value;\n        emit SetIsCEX(account, value);\n    }\n\n    function setIsMarketMaker(address account, bool value) external onlyOwner {\n        require(account != pair, \"Can\u0027t modify pair\");\n        isMarketMaker[account] = value;\n        emit SetIsMarketMaker(account, value);\n    }\n\n    function setTaxes(uint256 newBuyTax, uint256 newSellTax, uint256 newTransferTax) external onlyOwner {\n        require(newBuyTax \u003c= 1500 \u0026\u0026 newSellTax \u003c= 2000 \u0026\u0026 newTransferTax \u003c= 7500, \"Too high taxes\");\n        buyTax = newBuyTax;\n        sellTax = newSellTax;\n        transferTax = newTransferTax;\n        emit SetTaxes(buyTax, sellTax, transferTax);\n    }\n\n    function setShares(\n        uint256 newLiquidityShare,\n        uint256 newMarketingShare,\n        uint256 newSparkShare\n    ) external onlyOwner {\n        uint256 currentSparkRatio = 1e18 * sparkShare / totalShares;\n        uint256 newSparkRatio = 1e18 * newSparkShare / (newLiquidityShare + newMarketingShare + newSparkShare);\n        require(newSparkRatio \u003c= currentSparkRatio, \"Can\u0027t increase Spark ratio\");\n\n        liquidityShare = newLiquidityShare;\n        marketingShare = newMarketingShare;\n        sparkShare = newSparkShare;\n        totalShares = liquidityShare + marketingShare + sparkShare;\n        emit SetShares(liquidityShare, marketingShare, sparkShare);\n    }\n\n    function setSwapBackSettings(bool enabled, bool swapAll, uint256 amount) external onlyOwner {\n        uint256 tokenAmount = amount * 10**decimals();\n        swapEnabled = enabled;\n        swapWholeStorage = swapAll;\n        swapThreshold = tokenAmount;\n        emit SetSwapBackSettings(enabled, swapAll, tokenAmount);\n    }\n\n    function setTransferGas(uint256 newGas) external onlyOwner {\n        require(newGas \u003e= 21000 \u0026\u0026 newGas \u003c= 50000, \"Invalid gas parameter\");\n        emit SetTransferGas(newGas, transferGas);\n        transferGas = newGas;\n    }\n\n    function setMarketingWallet(address newWallet) external onlyOwner {\n        require(newWallet != address(0), \"New marketing wallet is the zero address\");\n        emit SetMarketingWallet(newWallet, marketingWallet);\n        marketingWallet = newWallet;\n    }\n\n    function setSparkWallet(address newAddress) external onlyOwner {\n        require(newAddress != address(0), \"New spark wallet is the zero address\");\n        emit SetSparkWallet(newAddress, sparkWallet);\n        sparkWallet = newAddress;\n    }\n}\n"},"IBEP20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\ninterface IBEP20 {\n    function totalSupply() external view returns (uint256);\n    function decimals() external view returns (uint8);\n    function symbol() external view returns (string memory);\n    function name() external view returns (string memory);\n    function getOwner() external view returns (address);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address _owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"IDEX.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\ninterface IDEXFactory {\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n}\n\ninterface IDEXRouter {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function swapExactTokensForETH(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n}\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nabstract contract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    modifier onlyOwner() {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    constructor(address newOwner) {\n        _owner = newOwner;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    function owner() internal view returns (address) {\n        return _owner;\n    }\n}\n"}}