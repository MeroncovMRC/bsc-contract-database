{"Address.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly { size := extcodesize(account) }\r\n        return size \u003e 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length \u003e 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}"},"AddressRegistry.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nimport \"./Owned.sol\";\n\ncontract AddressRegistry is Owned {\n\n    modifier transferGateOnly() {\n        require (msg.sender == transferGate, \"Transfer Gate only\");\n        _;\n    }\n\n    address public transferGate;\n    \n    mapping (address =\u003e bool) public freeParticipantControllers;\n    mapping (address =\u003e bool) public freeParticipant;\n    mapping (address =\u003e bool) public eliteParticipant;\n    mapping (address =\u003e bool) public blacklist;\n\n    function setTransferGate(address _transferGate) public ownerOnly() {\n        transferGate = _transferGate;\n    }\n\n    function setFreeParticipantController(address freeParticipantController, bool allow) public transferGateOnly() {\n        freeParticipantControllers[freeParticipantController] = allow;\n    }\n\n    function setFreeParticipant(address participant, bool free) public transferGateOnly() {\n        freeParticipant[participant] = free;\n    }\n\n    function setEliteParticipant(address holder, bool trusted) public transferGateOnly() {\n        eliteParticipant[holder] = trusted;\n    }\n\n    function setBlacklisted(address account, bool blacklisted) public transferGateOnly() {\n        blacklist[account] = blacklisted;\n    }\n}"},"BurnPit.sol":{"content":"// SPDX-License-Identifier: U-U-U-UPPPPP!!!\r\npragma solidity ^0.7.4;\r\n\r\nimport \"./IERC20.sol\";\r\n\r\ncontract BurnPit {\r\n    \r\n    IERC20 public token;\r\n\r\n    constructor (address _token) {\r\n        token = IERC20(_token);\r\n    }\r\n\r\n    function burned() public view returns (uint256) {\r\n        return (token.balanceOf(address(this)));\r\n    }\r\n}"},"EliteFloorCalculator.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nimport \"./IFloorCalculator.sol\";\nimport \"./SafeMath.sol\";\nimport \"./ISwapRouter02.sol\";\nimport \"./ISwapFactory.sol\";\nimport \"./TokensRecoverable.sol\";\nimport \"./EnumerableSet.sol\";\n\ncontract EliteFloorCalculator is IFloorCalculator, TokensRecoverable {\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    IERC20 immutable rootedToken;\n    address immutable rootedElitePair;\n    address immutable rootedBasePair;\n    ISwapRouter02 immutable internal swapRouter;\n    ISwapFactory immutable internal swapFactory;\n    EnumerableSet.AddressSet ignoredAddresses;\n\n    constructor(IERC20 _rootedToken, IERC20 _eliteToken, IERC20 _baseToken, ISwapFactory _swapFactory, ISwapRouter02 _swapRouter) {\n        rootedToken = _rootedToken;\n        swapFactory = _swapFactory;\n        swapRouter = _swapRouter;\n\n        rootedElitePair = _swapFactory.getPair(address(_eliteToken), address(_rootedToken));\n        rootedBasePair = _swapFactory.getPair(address(_baseToken), address(_rootedToken));\n    }    \n\n\n    function setIgnoreAddresses(address ignoredAddress, bool add) public ownerOnly() {\n        if (add) { \n            ignoredAddresses.add(ignoredAddress); \n        } else { \n            ignoredAddresses.remove(ignoredAddress); \n        }\n    }\n\n    function isIgnoredAddress(address ignoredAddress) public view returns (bool) {\n        return ignoredAddresses.contains(ignoredAddress);\n    }\n\n    function ignoredAddressCount() public view returns (uint256) {\n        return ignoredAddresses.length();\n    }\n\n    function ignoredAddressAt(uint256 index) public view returns (address) {\n        return ignoredAddresses.at(index);\n    }\n\n    function ignoredAddressesTotalBalance() public view returns (uint256) {\n        uint256 total = 0;\n        for (uint i = 0; i \u003c ignoredAddresses.length(); i++) {\n            total = total.add(rootedToken.balanceOf(ignoredAddresses.at(i)));\n        }\n\n        return total;\n    }\n\n    function calculateSubFloor(IERC20 baseToken, IERC20 eliteToken) public override view returns (uint256) {\n        uint256 totalRootedInPairs = rootedToken.balanceOf(rootedElitePair).add(rootedToken.balanceOf(rootedBasePair));\n        uint256 totalBaseAndEliteInPairs = eliteToken.balanceOf(rootedElitePair).add(baseToken.balanceOf(rootedBasePair));\n        uint256 rootedCirculatingSupply = rootedToken.totalSupply().sub(totalRootedInPairs).sub(ignoredAddressesTotalBalance());\n        uint256 amountUntilFloor = swapRouter.getAmountOut(rootedCirculatingSupply, totalRootedInPairs, totalBaseAndEliteInPairs);\n\n        uint256 totalExcessInPools = totalBaseAndEliteInPairs.sub(amountUntilFloor);\n        uint256 previouslySwept = eliteToken.totalSupply().sub(baseToken.balanceOf(address(eliteToken)));\n        \n        if (previouslySwept \u003e= totalExcessInPools) { return 0; }\n\n        return totalExcessInPools.sub(previouslySwept);\n    }\n}"},"EliteFloorCalculatorV1.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nimport \"./IFloorCalculator.sol\";\nimport \"./SafeMath.sol\";\nimport \"./SwapLibrary.sol\";\nimport \"./ISwapFactory.sol\";\nimport \"./TokensRecoverable.sol\";\nimport \"./EnumerableSet.sol\";\n\ncontract EliteFloorCalculatorV1 is IFloorCalculator, TokensRecoverable {\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    IERC20 immutable rootedToken;\n    ISwapFactory immutable swapFactory;\n    EnumerableSet.AddressSet ignoredAddresses;\n\n    constructor(IERC20 _rootedToken, ISwapFactory _swapFactory) {\n        rootedToken = _rootedToken;\n        swapFactory = _swapFactory;\n    }    \n\n    function setIgnoreAddresses(address ignoredAddress, bool add) public ownerOnly() {\n        if (add) { \n            ignoredAddresses.add(ignoredAddress); \n        } else { \n            ignoredAddresses.remove(ignoredAddress); \n        }\n    }\n\n    function isIgnoredAddress(address ignoredAddress) public view returns (bool) {\n        return ignoredAddresses.contains(ignoredAddress);\n    }\n\n    function ignoredAddressCount() public view returns (uint256) {\n        return ignoredAddresses.length();\n    }\n\n    function ignoredAddressAt(uint256 index) public view returns (address) {\n        return ignoredAddresses.at(index);\n    }\n\n    function ignoredAddressesTotalBalance() public view returns (uint256) {\n        uint256 total = 0;\n        for (uint i = 0; i \u003c ignoredAddresses.length(); i++) {\n            total = total.add(rootedToken.balanceOf(ignoredAddresses.at(i)));\n        }\n\n        return total;\n    }\n\n    function calculateExcessInPool(IERC20 token, address pair, uint256 liquidityShare, uint256 rootedTokenTotalSupply, uint256 rootedTokenPoolsLiquidity) internal view returns (uint256) {\n        uint256 freeRootedToken = (rootedTokenTotalSupply.sub(rootedTokenPoolsLiquidity)).mul(liquidityShare).div(1e12);\n\n        uint256 sellAllProceeds = 0;\n        if (freeRootedToken \u003e 0) {\n            address[] memory path = new address[](2);\n            path[0] = address(rootedToken);\n            path[1] = address(token);\n            uint256[] memory amountsOut = SwapLibrary.getAmountsOut(address(swapFactory), freeRootedToken, path);\n            sellAllProceeds = amountsOut[1];\n        }\n\n        uint256 backingInPool = token.balanceOf(pair);\n        if (backingInPool \u003c= sellAllProceeds) { return 0; }\n        uint256 excessInPool = backingInPool - sellAllProceeds;\n\n        return excessInPool;\n    }\n\n    function calculateExcessInPools(IERC20 baseToken, IERC20 eliteToken) public view returns (uint256) {\n        address rootedElitePair = SwapLibrary.pairFor(address(swapFactory), address(rootedToken), address(eliteToken));\n        address rootedBasePair = SwapLibrary.pairFor(address(swapFactory), address(rootedToken), address(baseToken));   \n        \n        uint256 rootedTokenTotalSupply = rootedToken.totalSupply().sub(ignoredAddressesTotalBalance());\n        uint256 rootedTokenPoolsLiquidity = rootedToken.balanceOf(rootedElitePair).add(rootedToken.balanceOf(rootedBasePair));\n        uint256 baseTokenPoolsLiquidity = eliteToken.balanceOf(rootedElitePair).add(baseToken.balanceOf(rootedBasePair));\n\n        uint256 rootedLiquidityShareInElitePair = rootedToken.balanceOf(rootedElitePair).mul(1e12).div(rootedTokenPoolsLiquidity);\n        uint256 eliteLiquidityShareInElitePair = eliteToken.balanceOf(rootedElitePair).mul(1e12).div(baseTokenPoolsLiquidity);\n        uint256 avgLiquidityShareInElitePair = (rootedLiquidityShareInElitePair.add(eliteLiquidityShareInElitePair)).div(2);\n        uint256 one = 1e12;\n\n        uint256 excessInElitePool = calculateExcessInPool(eliteToken, rootedElitePair, avgLiquidityShareInElitePair, rootedTokenTotalSupply, rootedTokenPoolsLiquidity);\n        uint256 excessInBasePool = calculateExcessInPool(baseToken, rootedBasePair, (one).sub(avgLiquidityShareInElitePair), rootedTokenTotalSupply, rootedTokenPoolsLiquidity);\n        return excessInElitePool.add(excessInBasePool);\n    }\n\n    function calculateSubFloor(IERC20 baseToken, IERC20 eliteToken) public override view returns (uint256) {        \n        uint256 excessInPools = calculateExcessInPools(baseToken, eliteToken);\n        uint256 requiredBacking = eliteToken.totalSupply().sub(excessInPools);\n        uint256 currentBacking = baseToken.balanceOf(address(eliteToken));\n        if (requiredBacking \u003e= currentBacking) { return 0; }\n        return currentBacking - requiredBacking;\n    }\n}"},"EliteToken.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nimport \"./ERC31337.sol\";\nimport \"./IERC20.sol\";\n\ncontract EliteToken is ERC31337 {\n    using Address for address;\n    using SafeMath for uint256;\n    \n    mapping (address =\u003e bool) public freeParticipantControllers;\n    mapping (address =\u003e bool) public freeParticipants; \n\n    mapping (address =\u003e bool) public burnRateControllers;\n\n    uint16 burnRate;   \n\n    constructor (IERC20 _wrappedToken) ERC31337(_wrappedToken, \"Elite SDE\", \"eSDE\") { }    \n\n    function setFreeParticipantController(address freeParticipantController, bool allow) public ownerOnly() {\n        freeParticipantControllers[freeParticipantController] = allow;\n    }\n\n    function setFreeParticipant(address participant, bool free) public {\n        require (msg.sender == owner || freeParticipantControllers[msg.sender], \"Not an owner or free participant controller\");\n        freeParticipants[participant] = free;\n    }\n\n    function setBurnRateController(address burnRateController, bool allow) public ownerOnly() {\n        burnRateControllers[burnRateController] = allow;\n    }\n\n    function setBurnRate(uint16 _burnRate) public {\n        require (msg.sender == owner || burnRateControllers[msg.sender], \"Not an owner or burn rate controller\");\n        require (_burnRate \u003c= 10000, \"But rate must be less or equal to 100%\");\n       \n        burnRate = _burnRate;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual override {\n        require(sender != address(0), \"EliteToken: transfer from the zero address\");\n        require(recipient != address(0), \"EliteToken: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n        uint256 remaining = amount;\n\n        if (!freeParticipants[sender] \u0026\u0026 !freeParticipants[recipient] \u0026\u0026 burnRate \u003e 0) {\n            uint256 burn = amount * burnRate / 10000;\n            amount = remaining = remaining.sub(burn, \"Burn too much\");\n            _burn(sender, burn);\n        }\n        \n        _balanceOf[sender] = _balanceOf[sender].sub(amount, \"EliteToken: transfer amount exceeds balance\");\n        _balanceOf[recipient] = _balanceOf[recipient].add(remaining);\n        \n        emit Transfer(sender, recipient, remaining);\n    }\n}"},"EnumerableSet.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity \u003e=0.6.0 \u003c0.8.0;\r\n\r\nlibrary EnumerableSet {\r\n    struct Set {\r\n        bytes32[] _values;\r\n        mapping (bytes32 =\u003e uint256) _indexes;\r\n    }\r\n\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) {\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n            bytes32 lastvalue = set._values[lastIndex];\r\n\r\n            set._values[toDeleteIndex] = lastvalue;\r\n            set._indexes[lastvalue] = toDeleteIndex + 1;\r\n            set._values.pop();\r\n\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        require(set._values.length \u003e index, \"EnumerableSet: index out of bounds\");\r\n        return set._values[index];\r\n    }\r\n\r\n    // Bytes32Set\r\n\r\n    struct Bytes32Set {\r\n        Set _inner;\r\n    }\r\n\r\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _add(set._inner, value);\r\n    }\r\n\r\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _remove(set._inner, value);\r\n    }\r\n\r\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\r\n        return _contains(set._inner, value);\r\n    }\r\n\r\n    function length(Bytes32Set storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\r\n        return _at(set._inner, index);\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint256(_at(set._inner, index)));\r\n    }\r\n\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n}"},"ERC20.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\nimport \"./SafeMath.sol\";\r\n\r\nimport \"./IERC20.sol\";\r\n\r\nabstract contract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    string public override name;\r\n    string public override symbol;\r\n    \r\n    uint8 public override decimals = 18;\r\n\r\n    uint256 public override totalSupply;\r\n\r\n    mapping (address =\u003e uint256) internal _balanceOf;\r\n    mapping (address =\u003e mapping (address =\u003e uint256)) public override allowance;\r\n\r\n    constructor (string memory _name, string memory _symbol) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n    }\r\n\r\n    function balanceOf(address a) public virtual override view returns (uint256) { return _balanceOf[a]; }\r\n\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        uint256 oldAllowance = allowance[sender][msg.sender];\r\n        if (oldAllowance != uint256(-1)) {\r\n            _approve(sender, msg.sender, oldAllowance.sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(msg.sender, spender, allowance[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        _approve(msg.sender, spender, allowance[msg.sender][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        _balanceOf[sender] = _balanceOf[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balanceOf[recipient] = _balanceOf[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        totalSupply = totalSupply.add(amount);\r\n        _balanceOf[account] = _balanceOf[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        _balanceOf[account] = _balanceOf[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        totalSupply = totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        allowance[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _setupDecimals(uint8 _decimals) internal {\r\n        decimals = _decimals;\r\n    }\r\n\r\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\r\n        uint256 currentAllowance = allowance[owner][spender];\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance \u003e= amount, \"ERC20: insufficient allowance\");\r\n            _approve(owner, spender, currentAllowance - amount);\r\n        }\r\n    }\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n}"},"ERC31337.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\nimport \"./SafeERC20.sol\";\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./IERC31337.sol\";\r\nimport \"./IFloorCalculator.sol\";\r\n\r\nimport \"./WrappedERC20.sol\";\r\n\r\ncontract ERC31337 is WrappedERC20, IERC31337 {\r\n    using SafeERC20 for IERC20;\r\n\r\n    IFloorCalculator public override floorCalculator;\r\n    \r\n    mapping (address =\u003e bool) public override sweepers;\r\n\r\n    constructor(IERC20 _wrappedToken, string memory _name, string memory _symbol) WrappedERC20(_wrappedToken, _name, _symbol) {}\r\n\r\n    function setFloorCalculator(IFloorCalculator _floorCalculator) public override ownerOnly() {\r\n        floorCalculator = _floorCalculator;\r\n    }\r\n\r\n    function setSweeper(address sweeper, bool allow) public override ownerOnly() {\r\n        sweepers[sweeper] = allow;\r\n    }\r\n\r\n    function sweepFloor(address to) public override returns (uint256 amountSwept) {\r\n        require (to != address(0));\r\n        require (sweepers[msg.sender], \"Sweepers only\");\r\n        amountSwept = floorCalculator.calculateSubFloor(wrappedToken, this);\r\n        if (amountSwept \u003e 0) {\r\n            wrappedToken.safeTransfer(to, amountSwept);\r\n        }\r\n    }\r\n}"},"FeeSplitter.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nimport \"./IERC20.sol\";\nimport \"./IGatedERC20.sol\";\nimport \"./SafeMath.sol\";\nimport \"./SafeERC20.sol\";\nimport \"./Address.sol\";\nimport \"./TokensRecoverable.sol\";\nimport \u0027./ISwapRouter02.sol\u0027;\n\ncontract FeeSplitter is TokensRecoverable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using Address for address;\n    \n    address public devAddress;\n\n    ISwapRouter02 public immutable router;\n\n    mapping (IGatedERC20 =\u003e uint256) public sellRates;\n    mapping (IGatedERC20 =\u003e uint256) public keepRates;\n\n    mapping (IGatedERC20 =\u003e address[]) public chainTokenFeeCollectors;\n    mapping (IGatedERC20 =\u003e uint256[]) public chainTokenFeeRates;\n\n    mapping (IGatedERC20 =\u003e address[]) public rootedTokenFeeCollectors;\n    mapping (IGatedERC20 =\u003e uint256[]) public rootedTokenFeeRates;\n\n    mapping (IGatedERC20 =\u003e address[]) public sellPaths;\n\n    constructor(address _devAddress, ISwapRouter02 _router) {\n        devAddress = _devAddress;\n        router = _router;\n    }\n\n    function setDevAddress(address _devAddress) public ownerOnly() {\n        devAddress = _devAddress;\n    }\n\n    function setFees(IGatedERC20 token, uint256 sellRate, uint256 keepRate) public ownerOnly() {\n        require (sellRate + keepRate == 10000, \"Total fee rate must be 100%\");\n\n        sellRates[token] = sellRate;\n        keepRates[token] = keepRate;\n        \n        token.approve(address(router), uint256(-1));\n    }\n\n    function setChainTokenFeeCollectors(IGatedERC20 token, address[] memory collectors, uint256[] memory rates) public ownerOnly() {\n        require (collectors.length == rates.length, \"Fee Collectors and Rates must be the same size\");\n        \n        uint256 totalRate = 0;\n        for (uint256 i = 0; i \u003c rates.length; i++) {\n            totalRate = totalRate + rates[i];\n        }\n        \n        require (totalRate == 10000, \"Total fee rate must be 100%\");\n\n        chainTokenFeeCollectors[token] = collectors;\n        chainTokenFeeRates[token] = rates;\n    }\n\n    function setRootedTokenFeeCollectors(IGatedERC20 token, address[] memory collectors, uint256[] memory rates) public ownerOnly() {\n        require (collectors.length == rates.length, \"Fee Collectors and Rates must be the same size\");\n        \n        uint256 totalRate = 0;\n        for (uint256 i = 0; i \u003c rates.length; i++) {\n            totalRate = totalRate + rates[i];\n        }\n\n        require (totalRate == 10000, \"Total fee rate must be 100%\");\n\n        rootedTokenFeeCollectors[token] = collectors;\n        rootedTokenFeeRates[token] = rates;\n    }\n\n    function setSellPath(IGatedERC20 token, address[] memory path) public ownerOnly() {\n        require (path[0] == address(token), \"Invalid path\");\n\n        sellPaths[token] = path;\n    }\n\n    function payFees(IGatedERC20 token) public {\n        uint256 balance = token.balanceOf(address(this));\n        require (balance \u003e 0, \"Nothing to pay\");\n\n        // If sell percentage of a token is more than zero, process the sell and distribute tokens\n        if (sellRates[token] \u003e 0) {\n            uint256 sellAmount = sellRates[token] * balance / 10000;\n            \n            // Get the path of token to token\n            address[] memory path = sellPaths[token];\n\n            // Carry out the swap\n            uint256[] memory amounts = router.swapExactTokensForTokens(sellAmount, 0, path, address(this), block.timestamp);\n \n            // Get the collectors and rates for the token\n            address[] memory collectors = chainTokenFeeCollectors[token];\n            uint256[] memory rates = chainTokenFeeRates[token];\n\n            // Distribute the tokens\n            uint256 lastIndex = path.length - 1;\n            distribute(IERC20(path[lastIndex]), amounts[lastIndex], collectors, rates);\n        }\n\n        // If keep percentage of a token is more than zero, distribute tokens\n        if (keepRates[token] \u003e 0) {\n            uint256 keepAmount = keepRates[token] * balance / 10000;\n            address[] memory collectors = rootedTokenFeeCollectors[token];\n            uint256[] memory rates = rootedTokenFeeRates[token];\n            distribute(token, keepAmount, collectors, rates);\n        }\n    }\n    \n    function distribute(IERC20 token, uint256 amount, address[] memory collectors, uint256[] memory rates) private {\n        for (uint256 i = 0; i \u003c collectors.length; i++) {\n            address collector = collectors[i];\n            uint256 rate = rates[i];\n\n            if (rate \u003e 0) {\n                uint256 feeAmount = rate * amount / 10000;\n                token.transfer(collector, feeAmount);\n            }\n        }\n    }\n}"},"GatedERC20.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./SafeMath.sol\";\r\n\r\nimport \"./IGatedERC20.sol\";\r\nimport \"./ITransferGate.sol\";\r\n\r\nimport \"./TokensRecoverable.sol\";\r\n\r\nimport \"./ERC20.sol\";\r\n\r\nabstract contract GatedERC20 is ERC20, TokensRecoverable, IGatedERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    ITransferGate public override transferGate;\r\n\r\n    constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) {}\r\n\r\n    function setTransferGate(ITransferGate _transferGate) public override ownerOnly() {\r\n        transferGate = _transferGate;\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual override {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        ITransferGate _transferGate = transferGate;\r\n        uint256 remaining = amount;\r\n        \r\n        if (address(_transferGate) != address(0)) {\r\n            address splitter = _transferGate.feeSplitter();\r\n            uint256 fees = _transferGate.handleTransfer(msg.sender, sender, recipient, amount);\r\n            if (fees \u003e 0) {\r\n               _balanceOf[splitter] = _balanceOf[splitter].add(fees);\r\n                emit Transfer(sender, splitter, fees);\r\n                remaining = remaining.sub(fees);\r\n            }           \r\n        }\r\n\r\n        _balanceOf[sender] = _balanceOf[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balanceOf[recipient] = _balanceOf[recipient].add(remaining);\r\n        emit Transfer(sender, recipient, remaining);\r\n    }\r\n\r\n    function burn(uint256 amount) public override {\r\n        _burn(msg.sender, amount);\r\n    }\r\n}"},"IAddressRegistry.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\ninterface IAddressRegistry {\r\n    function freeParticipantControllers(address) external view returns (bool);\r\n    function freeParticipant(address) external view returns (bool);\r\n    function eliteParticipant(address) external view returns (bool);\r\n    function blacklist(address) external view returns (bool);\r\n\r\n    function setTransferGate(address _transferGate) external;\r\n\r\n    function setFreeParticipantController(address freeParticipantController, bool allow) external;\r\n    function setFreeParticipant(address participant, bool free) external;\r\n    function setEliteParticipant(address holder, bool trusted) external;\r\n    function setBlacklisted(address account, bool blacklisted) external;\r\n}"},"IERC20.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\ninterface IERC20 {\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address _account) external view returns (uint256);\r\n    function transfer(address _recipient, uint256 _amount) external returns (bool);\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n    function approve(address _spender, uint256 _amount) external returns (bool);\r\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n}"},"IERC31337.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\nimport \"./IWrappedERC20.sol\";\r\nimport \"./IFloorCalculator.sol\";\r\n\r\ninterface IERC31337 is IWrappedERC20 {\r\n    function floorCalculator() external view returns (IFloorCalculator);\r\n    function sweepers(address _sweeper) external view returns (bool);\r\n    \r\n    function setFloorCalculator(IFloorCalculator _floorCalculator) external;\r\n    function setSweeper(address _sweeper, bool _allow) external;\r\n    function sweepFloor(address _to) external returns (uint256 amountSwept);\r\n}"},"IFloorCalculator.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\nimport \"./IERC20.sol\";\r\n\r\ninterface IFloorCalculator {\r\n    function calculateSubFloor(IERC20 baseToken, IERC20 eliteToken) external view returns (uint256);\r\n}"},"IGatedERC20.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./ITransferGate.sol\";\r\n\r\ninterface IGatedERC20 is IERC20 {\r\n    function transferGate() external view returns (ITransferGate);\r\n\r\n    function setTransferGate(ITransferGate _transferGate) external;\r\n    function burn(uint256 amount) external;\r\n}"},"ILiquidityController.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\ninterface ILiquidityController {\r\n    function balancePriceBase(uint256 amount) external;\r\n    function balancePriceElite(uint256 amount) external;\r\n    function removeBuyAndTax(uint256 amount, address token, uint16 tax, uint256 time) external;\r\n    function buyAndTax(address token, uint256 amountToSpend, uint16 tax, uint256 time) external;\r\n    function transferTokens(address token, address to, uint256 amount) external;\r\n    function sweepFloor() external;\r\n    function zapEliteToBase(uint256 liquidity) external;\r\n    function zapBaseToElite(uint256 liquidity) external;\r\n    function wrapToElite(uint256 baseAmount) external;\r\n    function unwrapElite(uint256 eliteAmount) external;\r\n    function addLiquidity(address eliteOrBase, uint256 baseAmount) external;\r\n    function removeLiquidity(address eliteOrBase, uint256 tokens) external;    \r\n    function buyRooted(address token, uint256 amountToSpend) external;\r\n    function sellRooted(address token, uint256 amountToSpend) external;   \r\n}"},"ILiquidityLockedERC20.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\nimport \"./ISwapPair.sol\";\r\n\r\ninterface ILiquidityLockedERC20 {\r\n    function setLiquidityLock(ISwapPair _liquidityPair, bool _locked) external;\r\n}"},"IMarketDistribution.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\ninterface IMarketDistribution {\r\n    function distributionComplete() external view returns (bool);\r\n    function vestingPeriodStartTime() external view returns (uint256); \r\n    function vestingPeriodEndTime() external view returns (uint256);\r\n    \r\n    function distribute() external;        \r\n    function claim(address account) external returns (uint256);\r\n    function claimReferralRewards(address account, uint256 referralShare) external;\r\n}"},"IMarketGeneration.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\ninterface IMarketGeneration {\r\n    function contribution(address) external view returns (uint256);\r\n    function referralPoints(address) external view returns (uint256);    \r\n    function totalContribution() external view returns (uint256);\r\n    function totalReferralPoints() external view returns (uint256);\r\n}"},"IOwned.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\ninterface IOwned {\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    function owner() external view returns (address);\r\n\r\n    function transferOwnership(address newOwner) external;\r\n    function claimOwnership() external;\r\n}"},"ISwapFactory.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\ninterface ISwapFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}"},"ISwapPair.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\ninterface ISwapPair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}"},"ISwapRouter01.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\ninterface ISwapRouter01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}"},"ISwapRouter02.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\nimport \u0027./ISwapRouter01.sol\u0027;\r\n\r\ninterface ISwapRouter02 is ISwapRouter01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountETH);\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\r\n}"},"ITokensRecoverable.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\nimport \"./IERC20.sol\";\r\n\r\ninterface ITokensRecoverable {\r\n    function recoverTokens(IERC20 token) external;\r\n}"},"ITransferGate.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\ninterface ITransferGate {\r\n    function feeSplitter() external view returns (address);\r\n    function handleTransfer(address msgSender, address from, address to, uint256 amount) external returns (uint256);\r\n}"},"IWrappedERC20.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./IWrappedERC20Events.sol\";\r\n\r\ninterface IWrappedERC20 is IERC20, IWrappedERC20Events {\r\n    function wrappedToken() external view returns (IERC20);\r\n    function depositTokens(uint256 _amount) external;\r\n    function withdrawTokens(uint256 _amount) external;\r\n}"},"IWrappedERC20Events.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\ninterface IWrappedERC20Events {\r\n    event Deposit(address indexed from, uint256 amount);\r\n    event Withdrawal(address indexed to, uint256 amount);\r\n}\r\n"},"LiquidityController.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\nimport \"./TokensRecoverable.sol\";\r\nimport \"./IERC31337.sol\";\r\nimport \"./ISwapRouter02.sol\";\r\nimport \"./IERC20.sol\";\r\nimport \"./RootedTransferGate.sol\";\r\nimport \"./ISwapFactory.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport \"./ILiquidityController.sol\";\r\nimport \"./IFloorCalculator.sol\";\r\n\r\ncontract LiquidityController is TokensRecoverable, ILiquidityController {\r\n    using SafeMath for uint256;\r\n\r\n    modifier liquidityControllerOnly() {\r\n        require(liquidityControllers[msg.sender], \"Not a Liquidity Controller\");\r\n        _;\r\n    }\r\n\r\n    ISwapRouter02 immutable swapRouter;\r\n    ISwapFactory immutable swapFactory;\r\n    \r\n    IERC20 immutable rooted;\r\n    IERC20 immutable base;\r\n    IERC20 immutable rootedEliteLP;\r\n    IERC20 immutable rootedBaseLP;\r\n\r\n    IERC31337 immutable elite;\r\n\r\n    IFloorCalculator public calculator;\r\n    \r\n    RootedTransferGate public gate;\r\n    \r\n    mapping(address =\u003e bool) public liquidityControllers;\r\n\r\n    constructor(ISwapRouter02 _swapRouter, IERC20 _base, IERC20 _rooted, IERC31337 _elite, IFloorCalculator _calculator, RootedTransferGate _gate) {\r\n        swapRouter = _swapRouter;\r\n        base = _base;\r\n        elite = _elite;\r\n        rooted = _rooted;\r\n        calculator = _calculator;\r\n        gate = _gate;\r\n\r\n        ISwapFactory _swapFactory = ISwapFactory(_swapRouter.factory());\r\n        swapFactory = _swapFactory;        \r\n        \r\n        _base.approve(address(_elite), uint256(-1));\r\n        _base.approve(address(_swapRouter), uint256(-1));\r\n        _rooted.approve(address(_swapRouter), uint256(-1));\r\n\r\n        IERC20 _rootedBaseLP = IERC20(_swapFactory.getPair(address(_base), address(_rooted)));\r\n        _rootedBaseLP.approve(address(_swapRouter), uint256(-1));\r\n        rootedBaseLP = _rootedBaseLP;\r\n        \r\n        _elite.approve(address(_swapRouter), uint256(-1));\r\n        \r\n        IERC20 _rootedEliteLP = IERC20(_swapFactory.getPair(address(_elite), address(_rooted)));\r\n        _rootedEliteLP.approve(address(_swapRouter), uint256(-1));\r\n        rootedEliteLP = _rootedEliteLP;\r\n    }\r\n\r\n    function buyPath(address token) public view returns (address[] memory) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(token);\r\n        path[1] = address(rooted);\r\n        return path;\r\n    }\r\n\r\n    function sellPath(address token) public view returns (address[] memory) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(rooted);\r\n        path[1] = address(token);\r\n        return path;\r\n    }\r\n\r\n    // Owner function to enable other contracts or addresses to use the Liquidity Controller\r\n    function setLiquidityController(address controlAddress, bool controller) public ownerOnly() {\r\n        liquidityControllers[controlAddress] = controller;\r\n    }\r\n\r\n    // Owner function to set the calculator and gate\r\n    function setCalculatorAndGate(IFloorCalculator _calculator, RootedTransferGate _gate) public ownerOnly() {\r\n        calculator = _calculator;\r\n        gate = _gate;\r\n    }\r\n\r\n    // Transfer tokens from the controller\r\n    function transferTokens(address token, address to, uint256 amount) public override liquidityControllerOnly() {\r\n        IERC20(token).transfer(to, amount);\r\n    }\r\n\r\n    // Removes liquidity, buys from either pool, sets a temporary dump tax\r\n    function removeBuyAndTax(uint256 amount, address token, uint16 tax, uint256 time) public override liquidityControllerOnly() {\r\n        gate.setUnrestricted(true);\r\n        amount = removeLiq(token, amount);\r\n        buyRootedToken(token, amount);\r\n        gate.setDumpTax(tax, time);\r\n        gate.setUnrestricted(false);\r\n    }\r\n\r\n    // Use Base tokens held by this contract to buy from the Base Pool and sell in the Elite Pool\r\n    function balancePriceBase(uint256 amount) public override liquidityControllerOnly() {\r\n        amount = buyRootedToken(address(base), amount);\r\n        amount = sellRootedToken(address(elite), amount);\r\n        elite.withdrawTokens(amount);\r\n    }\r\n\r\n    // Use Base tokens held by this contract to buy from the Elite Pool and sell in the Base Pool\r\n    function balancePriceElite(uint256 amount) public override liquidityControllerOnly() {        \r\n        elite.depositTokens(amount);\r\n        amount = buyRootedToken(address(elite), amount);\r\n        amount = sellRootedToken(address(base), amount);\r\n    }\r\n\r\n    // Uses value in the controller to buy\r\n    function buyAndTax(address token, uint256 amountToSpend, uint16 tax, uint256 time) public override liquidityControllerOnly() {\r\n        buyRootedToken(token, amountToSpend);\r\n        gate.setDumpTax(tax, time);\r\n    }\r\n\r\n    // Sweeps the Base token under the floor to this address\r\n    function sweepFloor() public override liquidityControllerOnly() {\r\n        elite.sweepFloor(address(this));\r\n    }\r\n\r\n    // Move liquidity from Elite pool ---\u003e\u003e Base pool\r\n    function zapEliteToBase(uint256 liquidity) public override liquidityControllerOnly() {       \r\n        gate.setUnrestricted(true);\r\n        liquidity = removeLiq(address(elite), liquidity);\r\n        elite.withdrawTokens(liquidity);\r\n        addLiq(address(base), liquidity);\r\n        gate.setUnrestricted(false);\r\n    }\r\n\r\n    // Move liquidity from Base pool ---\u003e\u003e Elite pool\r\n    function zapBaseToElite(uint256 liquidity) public override liquidityControllerOnly() {\r\n        gate.setUnrestricted(true);\r\n        liquidity = removeLiq(address(base), liquidity);\r\n        elite.depositTokens(liquidity);\r\n        addLiq(address(elite), liquidity);\r\n        gate.setUnrestricted(false);\r\n    }\r\n\r\n    function wrapToElite(uint256 baseAmount) public override liquidityControllerOnly() {\r\n        elite.depositTokens(baseAmount);\r\n    }\r\n\r\n    function unwrapElite(uint256 eliteAmount) public override liquidityControllerOnly() {\r\n        elite.withdrawTokens(eliteAmount);\r\n    }\r\n\r\n    function addLiquidity(address eliteOrBase, uint256 baseAmount) public override liquidityControllerOnly() {\r\n        gate.setUnrestricted(true);\r\n        addLiq(eliteOrBase, baseAmount);\r\n        gate.setUnrestricted(false);\r\n    }\r\n\r\n    function removeLiquidity(address eliteOrBase, uint256 tokens) public override liquidityControllerOnly() {\r\n        gate.setUnrestricted(true);\r\n        removeLiq(eliteOrBase, tokens);\r\n        gate.setUnrestricted(false);\r\n    }\r\n\r\n    function buyRooted(address token, uint256 amountToSpend) public override liquidityControllerOnly() {\r\n        buyRootedToken(token, amountToSpend);\r\n    }\r\n\r\n    function sellRooted(address token, uint256 amountToSpend) public override liquidityControllerOnly() {\r\n        sellRootedToken(token, amountToSpend);\r\n    }\r\n\r\n    function addLiq(address eliteOrBase, uint256 baseAmount) internal {\r\n        swapRouter.addLiquidity(address(eliteOrBase), address(rooted), baseAmount, rooted.balanceOf(address(this)), 0, 0, address(this), block.timestamp);\r\n    }\r\n\r\n    function removeLiq(address eliteOrBase, uint256 tokens) internal returns (uint256) {\r\n        (tokens, ) = swapRouter.removeLiquidity(address(eliteOrBase), address(rooted), tokens, 0, 0, address(this), block.timestamp);\r\n        return tokens;\r\n    }\r\n\r\n    function buyRootedToken(address token, uint256 amountToSpend) internal returns (uint256) {\r\n        uint256[] memory amounts = swapRouter.swapExactTokensForTokens(amountToSpend, 0, buyPath(token), address(this), block.timestamp);\r\n        amountToSpend = amounts[1];\r\n        return amountToSpend;\r\n    }\r\n\r\n    function sellRootedToken(address token, uint256 amountToSpend) internal returns (uint256) {\r\n        uint256[] memory amounts = swapRouter.swapExactTokensForTokens(amountToSpend, 0, sellPath(token), address(this), block.timestamp);\r\n        amountToSpend = amounts[1];\r\n        return amountToSpend;\r\n    }\r\n}"},"LiquidityLockedERC20.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\nimport \"./ERC20.sol\";\r\n\r\nimport \"./ISwapPair.sol\";\r\nimport \"./ILiquidityLockedERC20.sol\";\r\n\r\nimport \"./Owned.sol\";\r\n\r\nimport \"./GatedERC20.sol\";\r\n\r\nabstract contract LiquidityLockedERC20 is GatedERC20, ILiquidityLockedERC20 {\r\n    mapping (ISwapPair =\u003e bool) public liquidityPairLocked;\r\n    mapping (address =\u003e bool) public liquidityController;\r\n\r\n    struct CallRecord {\r\n        address origin;\r\n        uint32 blockNumber;\r\n        bool transferFrom;\r\n    }\r\n\r\n    CallRecord balanceAllowed;\r\n\r\n    constructor(string memory _name, string memory _symbol) GatedERC20(_name, _symbol) { }\r\n\r\n    function setLiquidityLock(ISwapPair _liquidityPair, bool _locked) public override {\r\n        require (liquidityController[msg.sender], \"Liquidity controller only\");\r\n        require (_liquidityPair.token0() == address(this) || _liquidityPair.token1() == address(this), \"Unrelated pair\");\r\n        liquidityPairLocked[_liquidityPair] = _locked;\r\n    }\r\n\r\n    function setLiquidityController(address _liquidityController, bool _canControl) public ownerOnly() {\r\n        liquidityController[_liquidityController] = _canControl;\r\n    }\r\n\r\n    function balanceOf(address account) public override view returns (uint256) {\r\n        ISwapPair pair = ISwapPair(address(msg.sender));\r\n        if (liquidityPairLocked[pair]) {\r\n            CallRecord memory last = balanceAllowed;\r\n            require (last.origin == tx.origin \u0026\u0026 last.blockNumber == block.number, \"Liquidity is locked\");\r\n            if (last.transferFrom) {\r\n                (uint256 reserve0, uint256 reserve1,) = pair.getReserves();\r\n                IERC20 token0 = IERC20(pair.token0());\r\n                if (address(token0) == address(this)) {\r\n                    require (IERC20(pair.token1()).balanceOf(address(pair)) \u003c reserve1, \"Liquidity is locked\");\r\n                }\r\n                else {\r\n                    require (token0.balanceOf(address(pair)) \u003c reserve0, \"Liquidity is locked\");\r\n                }\r\n            }\r\n        }\r\n        return super.balanceOf(account);\r\n    }\r\n\r\n    function allowBalance(bool _transferFrom) private {\r\n        CallRecord memory last = balanceAllowed;\r\n        CallRecord memory allow = CallRecord({ \r\n            origin: tx.origin,\r\n            blockNumber: uint32(block.number),\r\n            transferFrom: _transferFrom\r\n        });\r\n        require (last.origin != allow.origin || last.blockNumber != allow.blockNumber || last.transferFrom != allow.transferFrom, \"Liquidity is locked (Please try again next block)\");\r\n        balanceAllowed = allow;\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {        \r\n        if (liquidityPairLocked[ISwapPair(address(msg.sender))]) {\r\n            allowBalance(false);\r\n        } else {\r\n            balanceAllowed = CallRecord({ origin: address(0), blockNumber: 0, transferFrom: false });\r\n        }\r\n        return super.transfer(recipient, amount);\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        if (liquidityPairLocked[ISwapPair(recipient)]) {\r\n            allowBalance(true);\r\n        } else {\r\n            balanceAllowed = CallRecord({ origin: address(0), blockNumber: 0, transferFrom: false });\r\n        }\r\n        return super.transferFrom(sender, recipient, amount);\r\n    }\r\n}"},"MarketDistribution.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\nimport \"./IMarketDistribution.sol\";\r\nimport \"./IMarketGeneration.sol\";\r\nimport \"./RootedToken.sol\";\r\nimport \"./RootedTransferGate.sol\";\r\nimport \"./TokensRecoverable.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport \"./IERC31337.sol\";\r\nimport \"./IERC20.sol\";\r\nimport \"./ISwapRouter02.sol\";\r\nimport \"./ISwapFactory.sol\";\r\nimport \"./ISwapPair.sol\";\r\nimport \"./SafeERC20.sol\";\r\n\r\ncontract MarketDistribution is TokensRecoverable, IMarketDistribution {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    bool public override distributionComplete;\r\n\r\n    ISwapRouter02 swapRouter;\r\n    ISwapFactory swapFactory;\r\n\r\n    IMarketGeneration public marketGeneration;\r\n    RootedToken public rootedToken;\r\n    IERC31337 public eliteToken;\r\n    IERC20 public baseToken;\r\n\r\n    address public devAddress;\r\n    address public liquidityController;\r\n    \r\n    ISwapPair public rootedEliteLP;\r\n    ISwapPair public rootedBaseLP;\r\n\r\n    uint256 public constant rootedTokenSupply = 1e24; // 1 million\r\n\r\n    uint256 public totalBaseTokenCollected;\r\n    uint256 public totalBoughtForContributors;\r\n\r\n    mapping (address =\u003e uint256) public claimTime;\r\n    mapping (address =\u003e uint256) public totalClaim;\r\n    mapping (address =\u003e uint256) public remainingClaim;\r\n    \r\n    uint256 public totalBoughtForReferrals;\r\n    uint256 public recoveryDate = block.timestamp + 2592000; // 1 Month\r\n    \r\n    uint16 public developerPercentage;\r\n\r\n    uint16 public preBuyForReferralsPercent;\r\n    uint16 public preBuyForContributorsPercent;\r\n    uint16 public preBuyForMarketStabilizationPercent;\r\n\r\n    uint256 public override vestingPeriodStartTime;\r\n    uint256 public override vestingPeriodEndTime; \r\n    \r\n    uint256 public vestingDuration;\r\n    uint256 public rootedBottom;\r\n\r\n    constructor(address _devAddress) {\r\n        devAddress = _devAddress;\r\n    }\r\n\r\n    function init(\r\n        RootedToken _rootedToken, \r\n        IERC31337 _eliteToken, \r\n        address _liquidityController,\r\n        ISwapRouter02 _swapRouter, \r\n        IMarketGeneration _marketGeneration,\r\n        uint256 _vestingDuration, \r\n        uint16 _developerPercentage, \r\n        uint16 _preBuyForReferralsPercent, \r\n        uint16 _preBuyForContributorsPercent, \r\n        uint16 _preBuyForMarketStabilizationPercent) public ownerOnly() {        \r\n        rootedToken = _rootedToken;\r\n        eliteToken = _eliteToken;\r\n        baseToken = _eliteToken.wrappedToken();\r\n        liquidityController = _liquidityController;\r\n        swapRouter = _swapRouter;\r\n        swapFactory = ISwapFactory(_swapRouter.factory());\r\n        marketGeneration = _marketGeneration;\r\n        vestingDuration = _vestingDuration;\r\n        developerPercentage = _developerPercentage;\r\n        preBuyForReferralsPercent = _preBuyForReferralsPercent;\r\n        preBuyForContributorsPercent = _preBuyForContributorsPercent;\r\n        preBuyForMarketStabilizationPercent = _preBuyForMarketStabilizationPercent;\r\n    }\r\n\r\n    function setupEliteRooted() public {\r\n        rootedEliteLP = ISwapPair(swapFactory.getPair(address(eliteToken), address(rootedToken)));\r\n        if (address(rootedEliteLP) == address(0)) {\r\n            rootedEliteLP = ISwapPair(swapFactory.createPair(address(eliteToken), address(rootedToken)));\r\n            require (address(rootedEliteLP) != address(0));\r\n        }\r\n    }\r\n\r\n    function setupBaseRooted() public {\r\n        rootedBaseLP = ISwapPair(swapFactory.getPair(address(baseToken), address(rootedToken)));\r\n        if (address(rootedBaseLP) == address(0)) {\r\n            rootedBaseLP = ISwapPair(swapFactory.createPair(address(baseToken), address(rootedToken)));\r\n            require (address(rootedBaseLP) != address(0));\r\n        }\r\n    }\r\n\r\n    function completeSetup() public ownerOnly() {   \r\n        require (address(rootedEliteLP) != address(0), \"Rooted Elite pool is not created\");\r\n        require (address(rootedBaseLP) != address(0), \"Rooted Base pool is not created\");   \r\n\r\n        eliteToken.approve(address(swapRouter), uint256(-1));\r\n        rootedToken.approve(address(swapRouter), uint256(-1));\r\n        baseToken.safeApprove(address(swapRouter), uint256(-1));\r\n        baseToken.safeApprove(address(eliteToken), uint256(-1));\r\n        rootedBaseLP.approve(address(swapRouter), uint256(-1));\r\n        rootedEliteLP.approve(address(swapRouter), uint256(-1));\r\n    }\r\n\r\n    function distribute() public override {\r\n        require (msg.sender == address(marketGeneration), \"Unauthorized\");\r\n        require (!distributionComplete, \"Distribution complete\");\r\n   \r\n        vestingPeriodStartTime = block.timestamp;\r\n        vestingPeriodEndTime = block.timestamp + vestingDuration;\r\n        distributionComplete = true;\r\n\r\n        totalBaseTokenCollected = baseToken.balanceOf(address(marketGeneration));\r\n        baseToken.safeTransferFrom(msg.sender, address(this), totalBaseTokenCollected);  \r\n\r\n        RootedTransferGate gate = RootedTransferGate(address(rootedToken.transferGate()));\r\n\r\n        gate.setUnrestricted(true);\r\n        rootedToken.mint(rootedTokenSupply);\r\n\r\n        createRootedEliteLiquidity();\r\n\r\n        eliteToken.sweepFloor(address(this));        \r\n        eliteToken.depositTokens(baseToken.balanceOf(address(this)));\r\n                \r\n        buyTheBottom();        \r\n        preBuyForReferrals();\r\n        preBuyForContributors();\r\n        sellTheTop();\r\n\r\n        uint256 devShare = totalBaseTokenCollected * developerPercentage / 10000;\r\n\r\n        baseToken.transfer(devAddress, devShare);\r\n        \r\n        baseToken.transfer(liquidityController, baseToken.balanceOf(address(this)));      \r\n\r\n        createRootedBaseLiquidity();       \r\n\r\n        gate.setUnrestricted(false);\r\n    }   \r\n    \r\n    function createRootedEliteLiquidity() private {\r\n        eliteToken.depositTokens(baseToken.balanceOf(address(this)));\r\n        swapRouter.addLiquidity(address(eliteToken), address(rootedToken), eliteToken.balanceOf(address(this)), rootedToken.totalSupply(), 0, 0, address(this), block.timestamp);\r\n    }\r\n\r\n    function buyTheBottom() private {\r\n        uint256 amount = totalBaseTokenCollected * preBuyForMarketStabilizationPercent / 10000;  \r\n        uint256[] memory amounts = swapRouter.swapExactTokensForTokens(amount, 0, eliteRootedPath(), address(this), block.timestamp);        \r\n        rootedBottom = amounts[1];\r\n    }\r\n\r\n    function sellTheTop() private {\r\n        uint256[] memory amounts = swapRouter.swapExactTokensForTokens(rootedBottom, 0, rootedElitePath(), address(this), block.timestamp);\r\n        uint256 eliteAmount = amounts[1];\r\n        eliteToken.withdrawTokens(eliteAmount);\r\n    }   \r\n    \r\n    function preBuyForReferrals() private {\r\n        uint256 amount = totalBaseTokenCollected * preBuyForReferralsPercent / 10000;\r\n        uint256[] memory amounts = swapRouter.swapExactTokensForTokens(amount, 0, eliteRootedPath(), address(this), block.timestamp);\r\n        totalBoughtForReferrals = amounts[1];\r\n    }\r\n\r\n    function preBuyForContributors() private {\r\n        uint256 preBuyAmount = totalBaseTokenCollected * preBuyForContributorsPercent / 10000;\r\n        uint256 eliteBalance = eliteToken.balanceOf(address(this));\r\n        uint256 amount = preBuyAmount \u003e eliteBalance ? eliteBalance : preBuyAmount;\r\n        uint256[] memory amounts = swapRouter.swapExactTokensForTokens(amount, 0, eliteRootedPath(), address(this), block.timestamp);\r\n        totalBoughtForContributors = amounts[1];\r\n    }\r\n\r\n    function createRootedBaseLiquidity() private {\r\n        uint256 elitePerLpToken = eliteToken.balanceOf(address(rootedEliteLP)).mul(1e18).div(rootedEliteLP.totalSupply());\r\n        uint256 lpAmountToRemove = baseToken.balanceOf(address(eliteToken)).mul(1e18).div(elitePerLpToken);\r\n        \r\n        (uint256 eliteAmount, uint256 rootedAmount) = swapRouter.removeLiquidity(address(eliteToken), address(rootedToken), lpAmountToRemove, 0, 0, address(this), block.timestamp);\r\n        \r\n        uint256 baseInElite = baseToken.balanceOf(address(eliteToken));\r\n        uint256 baseAmount = eliteAmount \u003e baseInElite ? baseInElite : eliteAmount;       \r\n        \r\n        eliteToken.withdrawTokens(baseAmount);\r\n        swapRouter.addLiquidity(address(baseToken), address(rootedToken), baseAmount, rootedAmount, 0, 0, liquidityController, block.timestamp);\r\n        rootedEliteLP.transfer(liquidityController, rootedEliteLP.balanceOf(address(this)));\r\n        eliteToken.transfer(liquidityController, eliteToken.balanceOf(address(this)));\r\n    }\r\n\r\n    function eliteRootedPath() private view returns (address[] memory) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(eliteToken);\r\n        path[1] = address(rootedToken);\r\n        return path;\r\n    }\r\n\r\n    function rootedElitePath() private view returns (address[] memory) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(rootedToken);\r\n        path[1] = address(eliteToken);\r\n        return path;\r\n    }\r\n    \r\n    function getTotalClaim(address account) public view returns (uint256) {\r\n        uint256 contribution = marketGeneration.contribution(account);\r\n        return contribution == 0 ? 0 : contribution.mul(totalBoughtForContributors).div(marketGeneration.totalContribution());\r\n    }\r\n\r\n    function getReferralClaim(address account) public view returns (uint256) {\r\n        uint256 referralShare = marketGeneration.referralPoints(account);\r\n        return referralShare == 0 ? 0 : referralShare.mul(totalBoughtForReferrals).div(marketGeneration.totalReferralPoints());\r\n    }\r\n\r\n    function claim(address account) public override returns (uint256) {\r\n        require (distributionComplete, \"Distribution is not completed\");\r\n        require (msg.sender == address(marketGeneration), \"Unauthorized\");\r\n\r\n        if (totalClaim[account] == 0) {\r\n            totalClaim[account] = remainingClaim[account] = getTotalClaim(account);\r\n        }\r\n\r\n        uint256 share = totalClaim[account];\r\n        uint256 endTime = vestingPeriodEndTime \u003e block.timestamp ? block.timestamp : vestingPeriodEndTime;\r\n\r\n        require (claimTime[account] \u003c endTime, \"Already claimed\");\r\n\r\n        uint256 claimStartTime = claimTime[account] == 0 ? vestingPeriodStartTime : claimTime[account];\r\n        share = (endTime.sub(claimStartTime)).mul(share).div(vestingDuration);\r\n        claimTime[account] = block.timestamp;\r\n        remainingClaim[account] -= share;\r\n        rootedToken.transfer(account, share);\r\n\r\n        return share;\r\n    }\r\n\r\n    function claimReferralRewards(address account, uint256 referralShare) public override {\r\n        require (distributionComplete, \"Distribution is not completed\");\r\n        require (msg.sender == address(marketGeneration), \"Unauthorized\");\r\n\r\n        uint256 share = referralShare.mul(totalBoughtForReferrals).div(marketGeneration.totalReferralPoints());\r\n        rootedToken.transfer(account, share);\r\n    }\r\n}"},"MarketGeneration.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nimport \"./IMarketDistribution.sol\";\nimport \"./IMarketGeneration.sol\";\nimport \"./TokensRecoverable.sol\";\nimport \"./SafeERC20.sol\";\nimport \"./SafeMath.sol\";\nimport \"./IERC20.sol\";\n\ncontract MarketGeneration is TokensRecoverable, IMarketGeneration {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    modifier active() {\n        require (isActive, \"Distribution not active\");\n        _;\n    }\n\n    IERC20 public baseToken;\n    IMarketDistribution public marketDistribution;\n\n    address public devAddress;    \n\n    bool public isActive;\n\n    uint256 public refundsAllowedUntil;\n\n    uint256 public override totalReferralPoints;\n    uint256 public override totalContribution;\n\n    mapping (address =\u003e uint256) public override contribution;\n    mapping (address =\u003e uint256) public override referralPoints;\n    \n    constructor(address _devAddress) {\n        devAddress = _devAddress;\n    }\n\n    receive() external payable active() {\n        payable(devAddress).transfer(msg.value);\n    }\n\n    function init(IERC20 _baseToken) public ownerOnly() {\n        require (!isActive \u0026\u0026 block.timestamp \u003e= refundsAllowedUntil, \"Already activated\");\n        baseToken = _baseToken;\n    }\n\n    function activate(IMarketDistribution _marketDistribution) public ownerOnly() {\n        require (!isActive \u0026\u0026 block.timestamp \u003e= refundsAllowedUntil, \"Already activated\");        \n        require (address(_marketDistribution) != address(0));\n        marketDistribution = _marketDistribution;\n        isActive = true;\n    }\n\n    function setMarketDistribution(IMarketDistribution _marketDistribution) public ownerOnly() active() {\n        require (address(_marketDistribution) != address(0), \"Invalid market distribution\");\n        if (_marketDistribution == marketDistribution) { return; }\n        marketDistribution = _marketDistribution;\n        refundsAllowedUntil = block.timestamp + 86400;\n    }\n\n    function complete() public ownerOnly() active() {\n        require (block.timestamp \u003e= refundsAllowedUntil, \"Refund period is still active\");\n\n        isActive = false;\n\n        baseToken.safeApprove(address(marketDistribution), uint256(-1));\n\n        marketDistribution.distribute();\n    }\n\n    function allowRefunds() public ownerOnly() active() {\n        isActive = false;\n        refundsAllowedUntil = uint256(-1);\n    }\n\n    function refund(uint256 amount) private {\n        (bool success,) = msg.sender.call{ value: amount }(\"\");\n        require (success, \"Refund transfer failed\");  \n          \n        totalContribution -= amount;\n        contribution[msg.sender] = 0;\n\n        uint256 refPoints = referralPoints[msg.sender];\n\n        if (refPoints \u003e 0) {\n            totalReferralPoints -= refPoints;\n            referralPoints[msg.sender] = 0;\n        }\n    }\n\n    function claim() public {\n        uint256 amount = contribution[msg.sender];\n        uint256 claimedAmount = 0;\n\n        require (amount \u003e 0, \"Nothing to claim\");\n        \n        if (refundsAllowedUntil \u003e block.timestamp) {\n            refund(amount);\n        } else {\n            claimedAmount = marketDistribution.claim(msg.sender);\n        }\n    }\n\n    function claimReferralRewards() public {\n        require (referralPoints[msg.sender] \u003e 0, \"No rewards to claim\");\n        \n        uint256 refShare = referralPoints[msg.sender];\n        referralPoints[msg.sender] = 0;\n        marketDistribution.claimReferralRewards(msg.sender, refShare);\n    }\n\n    function contribute(address referral, uint256 amount) public active() {\n        require(baseToken.transferFrom(msg.sender, address(this), amount), \"Transfer failed\");\n\n        if (referral == address(0) || referral == msg.sender) {\n            referralPoints[devAddress] += amount;\n            totalReferralPoints += amount;\n        } else {\n            referralPoints[msg.sender] += amount;\n            referralPoints[referral] += amount;\n            totalReferralPoints +=(amount + amount);\n        }\n\n        contribution[msg.sender] += amount;\n        totalContribution += amount;\n    }\n}"},"Migrations.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity \u003e=0.4.22 \u003c0.8.0;\n\ncontract Migrations {\n  address public owner = msg.sender;\n  uint public last_completed_migration;\n\n  modifier restricted() {\n    require(\n      msg.sender == owner,\n      \"This function is restricted to the contract\u0027s owner\"\n    );\n    _;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n}\n"},"Owned.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\nimport \"./IOwned.sol\";\r\n\r\nabstract contract Owned is IOwned {\r\n    address public override owner = msg.sender;\r\n    address internal pendingOwner;\r\n\r\n    modifier ownerOnly() {\r\n        require (msg.sender == owner, \"Owner only\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public override ownerOnly() {\r\n        pendingOwner = newOwner;\r\n    }\r\n\r\n    function claimOwnership() public override {\r\n        require (pendingOwner == msg.sender);\r\n        pendingOwner = address(0);\r\n        emit OwnershipTransferred(owner, msg.sender);\r\n        owner = msg.sender;\r\n    }\r\n}"},"RootedToken.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nimport \"./LiquidityLockedERC20.sol\";\n\ncontract RootedToken is LiquidityLockedERC20(\"Stronghands DEX Elite\", \"SDE\") {\n    address public minter;\n\n    function setMinter(address _minter) public ownerOnly() {\n        minter = _minter;\n    }\n\n    function mint(uint256 amount) public {\n        require(msg.sender == minter, \"Not a minter\");\n        require(this.totalSupply() == 0, \"Already minted\");\n        _mint(msg.sender, amount);\n    }\n}"},"RootedTransferGate.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\nimport \"./Address.sol\";\r\nimport \"./IERC20.sol\";\r\nimport \"./ISwapPair.sol\";\r\nimport \"./ILiquidityLockedERC20.sol\";\r\nimport \"./ISwapRouter02.sol\";\r\nimport \"./SafeERC20.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport \"./TokensRecoverable.sol\";\r\nimport \"./ITransferGate.sol\";\r\nimport \"./IAddressRegistry.sol\";\r\n\r\ncontract RootedTransferGate is TokensRecoverable, ITransferGate {   \r\n    using Address for address;\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n\r\n    ISwapPair public mainPool;\r\n    ISwapRouter02 immutable internal swapRouter;\r\n    ILiquidityLockedERC20 immutable internal rootedToken;\r\n    IAddressRegistry public addressRegistry;\r\n\r\n    bool public unrestricted;\r\n    mapping (address =\u003e bool) public unrestrictedControllers;\r\n    mapping (address =\u003e bool) public feeControllers;\r\n    mapping (address =\u003e uint16) public poolsTaxRates;\r\n\r\n    address public override feeSplitter;\r\n\r\n    uint16 public feesRate;\r\n    uint16 public dumpTaxStartRate;\r\n    \r\n    uint256 public dumpTaxDurationInSeconds;\r\n    uint256 public dumpTaxEndTimestamp;\r\n\r\n    constructor(ILiquidityLockedERC20 _rootedToken, ISwapRouter02 _swapRouter) {\r\n        rootedToken = _rootedToken;\r\n        swapRouter = _swapRouter;\r\n    }\r\n\r\n    function setUnrestrictedController(address unrestrictedController, bool allow) public ownerOnly() {\r\n        unrestrictedControllers[unrestrictedController] = allow;\r\n    }\r\n    \r\n    function setFeeControllers(address feeController, bool allow) public ownerOnly() {\r\n        feeControllers[feeController] = allow;\r\n    }\r\n\r\n    function setFreeParticipantController(address freeParticipantController, bool allow) public ownerOnly() {\r\n        addressRegistry.setFreeParticipantController(freeParticipantController, allow);\r\n    }\r\n\r\n    function setEliteParticipant(address trustedWallet, bool allow) public ownerOnly() {\r\n        addressRegistry.setEliteParticipant(trustedWallet, allow);\r\n    }\r\n\r\n    function setBlacklist(address blacklistedWallet, bool allow) public ownerOnly() {\r\n        addressRegistry.setBlacklisted(blacklistedWallet, allow);\r\n    }\r\n\r\n    function setFreeParticipant(address participant, bool free) public {\r\n        require (msg.sender == owner || addressRegistry.freeParticipantControllers(msg.sender), \"Not an owner or free participant controller\");\r\n        addressRegistry.setFreeParticipant(participant, free);\r\n    }\r\n\r\n    function setFeeSplitter(address _feeSplitter) public ownerOnly() {\r\n        feeSplitter = _feeSplitter;\r\n    }\r\n\r\n    function setUnrestricted(bool _unrestricted) public {\r\n        require (unrestrictedControllers[msg.sender], \"Not an unrestricted controller\");\r\n        unrestricted = _unrestricted;\r\n        rootedToken.setLiquidityLock(mainPool, !_unrestricted);\r\n    }\r\n\r\n    function setAddressRegistry(address _addressRegistry) public ownerOnly() {\r\n        addressRegistry = IAddressRegistry(_addressRegistry);\r\n    }\r\n\r\n    function setMainPool(address _mainPool) public ownerOnly() {\r\n        mainPool = ISwapPair(_mainPool);\r\n    }\r\n\r\n    function setPoolTaxRate(address pool, uint16 taxRate) public ownerOnly() {\r\n        require (taxRate \u003c= 10000, \"Fee rate must be less than or equal to 100%\");\r\n        poolsTaxRates[pool] = taxRate;        \r\n    }\r\n\r\n    function setDumpTax(uint16 startTaxRate, uint256 durationInSeconds) public {\r\n        require (feeControllers[msg.sender] || msg.sender == owner, \"Not an owner or fee controller\");\r\n        require (startTaxRate \u003c= 10000, \"Dump tax rate must be less than or equal to 100%\");\r\n\r\n        dumpTaxStartRate = startTaxRate;\r\n        dumpTaxDurationInSeconds = durationInSeconds;\r\n        dumpTaxEndTimestamp = block.timestamp + durationInSeconds;\r\n    }\r\n\r\n    function getDumpTax() public view returns (uint256) {\r\n        if (block.timestamp \u003e= dumpTaxEndTimestamp) {\r\n            return 0;\r\n        }\r\n        \r\n        return dumpTaxStartRate*(dumpTaxEndTimestamp - block.timestamp)*1e18/dumpTaxDurationInSeconds/1e18;\r\n    }\r\n\r\n    function setFees(uint16 _feesRate) public {\r\n        require (feeControllers[msg.sender] || msg.sender == owner, \"Not an owner or fee controller\");\r\n        require (_feesRate \u003c= 10000, \"Fee rate must be less than or equal to 100%\");\r\n        feesRate = _feesRate;\r\n    }\r\n\r\n    function handleTransfer(address, address from, address to, uint256 amount) public virtual override returns (uint256 fees) {\r\n        if (unrestricted || addressRegistry.freeParticipant(from) || addressRegistry.freeParticipant(to)) {\r\n            return 0;\r\n        }\r\n\r\n        if (addressRegistry.blacklist(from) || addressRegistry.blacklist(to)) {\r\n            return amount;\r\n        }\r\n\r\n        uint16 poolTaxRate = poolsTaxRates[to];\r\n\r\n        uint256 dumpTaxInEffect = getDumpTax();\r\n\r\n        if (addressRegistry.eliteParticipant(from) || addressRegistry.eliteParticipant(to)) {\r\n            dumpTaxInEffect = 0;\r\n        }\r\n\r\n        if (poolTaxRate \u003e feesRate) {\r\n            uint256 totalTax = dumpTaxInEffect + poolTaxRate;\r\n            return totalTax \u003e= 10000 ? amount : amount * totalTax / 10000;\r\n        }\r\n\r\n        return amount * feesRate / 10000;\r\n    }   \r\n}"},"SafeERC20.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\nimport \"./Address.sol\";\r\nimport \"./SafeMath.sol\";\r\n\r\nimport \"./IERC20.sol\";\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {        \r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length \u003e 0) {\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003c= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003e 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}"},"StakingToken.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nimport \"./SafeMath.sol\";\nimport \"./IERC20.sol\";\nimport \"./ERC20.sol\";\nimport \"./TokensRecoverable.sol\";\n\ncontract StakingToken is ERC20(\"Staked SDE\", \"xSDE\"), TokensRecoverable {\n    using SafeMath for uint256;\n    IERC20 public immutable rooted;\n\n    mapping(uint256 =\u003e uint256) public startingTaxRateForStake;\n\n    constructor(IERC20 _rooted) {\n        rooted = _rooted;\n    }\n\n    ////////////////////\n    // VIEW FUNCTIONS //\n    ////////////////////\n\n    function getRootedToStake(uint256 amount) public view returns (uint256) {\n        uint256 totalRooted = rooted.balanceOf(address(this));\n        uint256 totalShares = this.totalSupply();\n\n        if (totalShares == 0 || totalRooted == 0) {\n            return amount;\n        } else {\n            return amount.mul(totalShares).div(totalRooted);\n        }\n    }\n\n    function getStakeToRooted(uint256 share) public view returns (uint256) {\n        uint256 totalShares = this.totalSupply();\n        return share.mul(rooted.balanceOf(address(this))).div(totalShares);\n    }\n\n    /////////////////////\n    // WRITE FUNCTIONS //\n    /////////////////////\n\n    // Stake rooted, get staking shares\n    function stake(uint256 amount) public {\n        uint256 totalRooted = rooted.balanceOf(address(this));\n        uint256 totalShares = this.totalSupply();\n\n        if (totalShares == 0 || totalRooted == 0) {\n            _mint(msg.sender, amount);\n        } else {\n            uint256 mintAmount = amount.mul(totalShares).div(totalRooted);\n            _mint(msg.sender, mintAmount);\n        }\n\n        rooted.transferFrom(msg.sender, address(this), amount);\n    }\n\n    // Unstake shares, claim back rooted\n    function unstake(uint256 share) public {\n        uint256 totalShares = this.totalSupply();\n        uint256 unstakeAmount = share.mul(rooted.balanceOf(address(this))).div(totalShares);\n\n        _burn(msg.sender, share);\n        rooted.transfer(msg.sender, unstakeAmount);\n    }\n\n    function canRecoverTokens(IERC20 token) internal override view returns (bool) { \n        return address(token) != address(rooted); \n    }\n}"},"SwapLibrary.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\nimport \"./SafeMath.sol\";\r\n\r\nimport \"./ISwapPair.sol\";\r\n\r\nlibrary SwapLibrary {\r\n    using SafeMath for uint;\r\n\r\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\r\n        require(tokenA != tokenB, \u0027SwapLibrary: IDENTICAL_ADDRESSES\u0027);\r\n        (token0, token1) = tokenA \u003c tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), \u0027SwapLibrary: ZERO_ADDRESS\u0027);\r\n    }\r\n\r\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\r\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\r\n        pair = address(uint(keccak256(abi.encodePacked(\r\n                hex\u0027ff\u0027,\r\n                factory,\r\n                keccak256(abi.encodePacked(token0, token1)),\r\n                hex\u002749fce07dac7533431899a4f0b442a33e33814f7456d8761e6e916cb6d9a1ddc0\u0027 // init code hash\r\n            ))));\r\n    }\r\n\r\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\r\n        (address token0,) = sortTokens(tokenA, tokenB);\r\n        pairFor(factory, tokenA, tokenB);\r\n        (uint reserve0, uint reserve1,) = ISwapPair(pairFor(factory, tokenA, tokenB)).getReserves();\r\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n    }\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\r\n        require(amountA \u003e 0, \u0027SwapLibrary: INSUFFICIENT_AMOUNT\u0027);\r\n        require(reserveA \u003e 0 \u0026\u0026 reserveB \u003e 0, \u0027SwapLibrary: INSUFFICIENT_LIQUIDITY\u0027);\r\n        amountB = amountA.mul(reserveB) / reserveA;\r\n    }\r\n\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\r\n        require(amountIn \u003e 0, \u0027SwapLibrary: INSUFFICIENT_INPUT_AMOUNT\u0027);\r\n        require(reserveIn \u003e 0 \u0026\u0026 reserveOut \u003e 0, \u0027SwapLibrary: INSUFFICIENT_LIQUIDITY\u0027);\r\n        uint amountInWithFee = amountIn.mul(998);\r\n        uint numerator = amountInWithFee.mul(reserveOut);\r\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\r\n        require(amountOut \u003e 0, \u0027SwapLibrary: INSUFFICIENT_OUTPUT_AMOUNT\u0027);\r\n        require(reserveIn \u003e 0 \u0026\u0026 reserveOut \u003e 0, \u0027SwapLibrary: INSUFFICIENT_LIQUIDITY\u0027);\r\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\r\n        uint denominator = reserveOut.sub(amountOut).mul(998);\r\n        amountIn = (numerator / denominator).add(1);\r\n    }\r\n\r\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\r\n        require(path.length \u003e= 2, \u0027SwapLibrary: INVALID_PATH\u0027);\r\n        amounts = new uint[](path.length);\r\n        amounts[0] = amountIn;\r\n        for (uint i; i \u003c path.length - 1; i++) {\r\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\r\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\r\n        }\r\n    }\r\n\r\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\r\n        require(path.length \u003e= 2, \u0027SwapLibrary: INVALID_PATH\u0027);\r\n        amounts = new uint[](path.length);\r\n        amounts[amounts.length - 1] = amountOut;\r\n        for (uint i = path.length - 1; i \u003e 0; i--) {\r\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\r\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\r\n        }\r\n    }\r\n}"},"TeamSplitter.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\nimport \"./Address.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport \"./SafeERC20.sol\";\r\n\r\nimport \"./TokensRecoverable.sol\";\r\nimport \"./Whitelist.sol\";\r\n\r\ncontract TeamSplitter is Whitelist, TokensRecoverable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n\r\n    mapping (IERC20 =\u003e address[]) public feeCollectors;\r\n    mapping (IERC20 =\u003e uint256[]) public feeRates;\r\n\r\n    constructor() {\r\n    }\r\n\r\n    function setFees(IERC20 token, uint256 burnRate, address[] memory collectors, uint256[] memory rates) public ownerOnly() {\r\n        \r\n        uint256 totalRate = burnRate;\r\n\r\n        for (uint256 i = 0; i \u003c rates.length; i++) {\r\n            totalRate = totalRate + rates[i];\r\n        }\r\n\r\n        require (totalRate == 10000, \"Total fee rate must be 100%\");\r\n        \r\n        if (token.balanceOf(address(this)) \u003e 0) {\r\n            distribute(token);\r\n        }\r\n\r\n        feeCollectors[token] = collectors;\r\n        feeRates[token] = rates;\r\n    }\r\n\r\n    function distribute(IERC20 token) public {\r\n        uint256 balance = token.balanceOf(address(this));\r\n        require (balance \u003e 0, \"Nothing to pay\");\r\n\r\n        address[] memory collectors = feeCollectors[token];\r\n        uint256[] memory rates = feeRates[token];\r\n\r\n        for (uint256 i = 0; i \u003c collectors.length; i++) {\r\n            address collector = collectors[i];\r\n            uint256 rate = rates[i];\r\n\r\n            if (rate \u003e 0) {\r\n                uint256 feeAmount = rate * balance / 10000;\r\n                token.transfer(collector, feeAmount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function canRecoverTokens(IERC20 token) internal override view returns (bool) {\r\n        address[] memory collectors = feeCollectors[IERC20(address(token))];\r\n        return address(token) != address(this) \u0026\u0026 collectors.length == 0; \r\n    }\r\n}"},"TokensRecoverable.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\nimport \"./SafeERC20.sol\";\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./ITokensRecoverable.sol\";\r\n\r\nimport \"./Owned.sol\";\r\n\r\nabstract contract TokensRecoverable is Owned, ITokensRecoverable {\r\n    using SafeERC20 for IERC20;\r\n\r\n    function recoverTokens(IERC20 token) public override ownerOnly() {\r\n        require (canRecoverTokens(token));\r\n        token.safeTransfer(msg.sender, token.balanceOf(address(this)));\r\n    }\r\n\r\n    function canRecoverTokens(IERC20 token) internal virtual view returns (bool) { \r\n        return address(token) != address(this); \r\n    }\r\n}"},"Whitelist.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.7.4;\n\nimport \"./Owned.sol\";\n\ncontract Whitelist is Owned {\n\n    modifier onlyWhitelisted() {\n        if(active){\n            require(whitelist[msg.sender], \u0027not whitelisted\u0027);\n        }\n        _;\n    }\n\n    bool active = true;\n\n    mapping(address =\u003e bool) public whitelist;\n\n    event WhitelistedAddressAdded(address addr);\n    event WhitelistedAddressRemoved(address addr);\n\n    function activateDeactivateWhitelist() public ownerOnly() {\n        active = !active;\n    }\n\n    function addAddressToWhitelist(address addr) public ownerOnly() returns(bool success) {\n        if (!whitelist[addr]) {\n            whitelist[addr] = true;\n            emit WhitelistedAddressAdded(addr);\n            success = true;\n        }\n    }\n\n    function addAddressesToWhitelist(address[] calldata addrs) public ownerOnly() returns(bool success) {\n        for (uint256 i = 0; i \u003c addrs.length; i++) {\n            if (addAddressToWhitelist(addrs[i])) {\n                success = true;\n            }\n        }\n    }\n\n    function removeAddressFromWhitelist(address addr) ownerOnly() public returns(bool success) {\n        if (whitelist[addr]) {\n            whitelist[addr] = false;\n            emit WhitelistedAddressRemoved(addr);\n            success = true;\n        }\n    }\n\n    function removeAddressesFromWhitelist(address[] calldata addrs) ownerOnly() public returns(bool success) {\n        for (uint256 i = 0; i \u003c addrs.length; i++) {\n            if (removeAddressFromWhitelist(addrs[i])) {\n                success = true;\n            }\n        }\n    }\n}"},"WrappedERC20.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./SafeERC20.sol\";\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./IWrappedERC20.sol\";\r\n\r\nimport \"./TokensRecoverable.sol\";\r\n\r\nimport \"./ERC20.sol\";\r\n\r\ncontract WrappedERC20 is ERC20, IWrappedERC20, TokensRecoverable {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n\r\n    IERC20 public immutable override wrappedToken;\r\n\r\n    constructor (IERC20 _wrappedToken, string memory _name, string memory _symbol) ERC20(_name, _symbol) {        \r\n        if (_wrappedToken.decimals() != 18) {\r\n            _setupDecimals(_wrappedToken.decimals());\r\n        }\r\n        wrappedToken = _wrappedToken;\r\n    }\r\n\r\n    function depositTokens(uint256 _amount) public override {\r\n        _beforeDepositTokens(_amount);\r\n        uint256 myBalance = wrappedToken.balanceOf(address(this));\r\n        wrappedToken.safeTransferFrom(msg.sender, address(this), _amount);\r\n        uint256 received = wrappedToken.balanceOf(address(this)).sub(myBalance);\r\n        _mint(msg.sender, received);\r\n        emit Deposit(msg.sender, _amount);\r\n    }\r\n\r\n    function withdrawTokens(uint256 _amount) public override {\r\n        _beforeWithdrawTokens(_amount);\r\n        _burn(msg.sender, _amount);\r\n        uint256 myBalance = wrappedToken.balanceOf(address(this));\r\n        wrappedToken.safeTransfer(msg.sender, _amount);\r\n        require (wrappedToken.balanceOf(address(this)) == myBalance.sub(_amount), \"Transfer not exact\");\r\n        emit Withdrawal(msg.sender, _amount);\r\n    }\r\n\r\n    function canRecoverTokens(IERC20 token) internal virtual override view returns (bool) {\r\n        return token != this \u0026\u0026 token != wrappedToken;\r\n    }\r\n\r\n    function _beforeDepositTokens(uint256 _amount) internal virtual view { }\r\n    function _beforeWithdrawTokens(uint256 _amount) internal virtual view { }\r\n}"}}