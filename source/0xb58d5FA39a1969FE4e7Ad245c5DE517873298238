
// File: contracts/base/HedgepieAdapterList.sol
// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity ^0.8.4;

import "../interfaces/IAdapter.sol";
import "../interfaces/IHedgepieAuthority.sol";

import "./HedgepieAccessControlled.sol";

contract HedgepieAdapterList is HedgepieAccessControlled {
    struct AdapterInfo {
        address addr;
        string name;
        address stakingToken;
        bool status;
    }

    // list of adapters
    AdapterInfo[] public adapterList;

    // existing status of adapters
    mapping(address => bool) public adapterExist;

    /// @dev events
    event AdapterAdded(address indexed adapter);
    event AdapterActivated(address indexed strategy);
    event AdapterDeactivated(address indexed strategy);

    /**
     * @notice Construct
     * @param _hedgepieAuthority HedgepieAuthority address
     */
    constructor(
        address _hedgepieAuthority
    ) HedgepieAccessControlled(IHedgepieAuthority(_hedgepieAuthority)) {}

    /// @dev modifier for active adapters
    modifier onlyActiveAdapter(address _adapter) {
        require(adapterExist[_adapter], "Error: Adapter is not active");
        _;
    }

    /**
     * @notice Get a list of adapters
     */
    function getAdapterList() external view returns (AdapterInfo[] memory) {
        return adapterList;
    }

    /**
     * @notice Get adapter infor
     * @param _adapterAddr address of adapter that need to get information
     */
    function getAdapterInfo(
        address _adapterAddr
    )
        external
        view
        returns (
            address adapterAddr,
            string memory name,
            address stakingToken,
            bool status
        )
    {
        for (uint256 i; i < adapterList.length; i++) {
            if (adapterList[i].addr == _adapterAddr && adapterList[i].status) {
                adapterAddr = adapterList[i].addr;
                name = adapterList[i].name;
                stakingToken = adapterList[i].stakingToken;
                status = adapterList[i].status;

                break;
            }
        }
    }

    /**
     * @notice Get strategy address of adapter contract
     * @param _adapter  adapter address
     */
    function getAdapterStrat(
        address _adapter
    ) external view onlyActiveAdapter(_adapter) returns (address adapterStrat) {
        adapterStrat = IAdapter(_adapter).strategy();
    }

    // ===== AdapterManager functions =====
    /**
     * @notice Add adapters
     * @param _adapters  array of adapter address
     */
    /// #if_succeeds {:msg "Adapter not set correctly"} adapterList.length == old(adapterInfo.length) + 1;
    function addAdapters(
        address[] memory _adapters
    ) external onlyAdapterManager {
        for (uint i = 0; i < _adapters.length; i++) {
            require(!adapterExist[_adapters[i]], "Already added");
            require(_adapters[i] != address(0), "Invalid adapter address");

            adapterList.push(
                AdapterInfo({
                    addr: _adapters[i],
                    name: IAdapter(_adapters[i]).name(),
                    stakingToken: IAdapter(_adapters[i]).stakingToken(),
                    status: true
                })
            );
            adapterExist[_adapters[i]] = true;

            emit AdapterAdded(_adapters[i]);
        }
    }

    /**
     * @notice Remove adapter
     * @param _adapterId  array of adapter id
     * @param _status  array of adapter status
     */
    /// #if_succeeds {:msg "Status not updated"} adapterList[_adapterId].status == _status;
    function setAdapters(
        uint256[] memory _adapterId,
        bool[] memory _status
    ) external onlyAdapterManager {
        require(_adapterId.length == _status.length, "Invalid array length");

        for (uint i = 0; i < _adapterId.length; i++) {
            require(
                _adapterId[i] < adapterList.length,
                "Invalid adapter address"
            );
            adapterList[_adapterId[i]].status = _status[i];

            if (_status[i])
                emit AdapterActivated(adapterList[_adapterId[i]].addr);
            else emit AdapterDeactivated(adapterList[_adapterId[i]].addr);
        }
    }
}


// File: contracts/interfaces/IAdapter.sol
// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity ^0.8.4;

import "./IWrap.sol";
import "../base/BaseAdapter.sol";

interface IAdapter {
    function stakingToken() external view returns (address);

    function strategy() external view returns (address);

    function name() external view returns (string memory);

    function rewardToken() external view returns (address);

    function rewardToken1() external view returns (address);

    function router() external view returns (address);

    function swapRouter() external view returns (address);

    function authority() external view returns (address);

    function deposit(
        uint256 _tokenId
    ) external payable returns (uint256 amountOut);

    function withdraw(
        uint256 _tokenId,
        uint256 _amount
    ) external payable returns (uint256 amountOut);

    function claim(
        uint256 _tokenId
    ) external payable returns (uint256 amountOut);

    function pendingReward(
        uint256 _tokenId
    ) external view returns (uint256 amountOut, uint256 withdrawable);

    function adapterInfos(
        uint256 _tokenId
    ) external view returns (BaseAdapter.AdapterInfo memory);

    function userAdapterInfos(
        uint256 _tokenId
    ) external view returns (BaseAdapter.UserAdapterInfo memory);

    function mAdapter() external view returns (BaseAdapter.AdapterInfo memory);

    function removeFunds(
        uint256 _tokenId
    ) external payable returns (uint256 amount);

    function getUserAmount(
        uint256 _tokenId
    ) external view returns (uint256 amount);

    function updateFunds(
        uint256 _tokenId
    ) external payable returns (uint256 amount);
}


// File: contracts/interfaces/IHedgepieAuthority.sol
// SPDX-License-Identifier: AGPL-3.0
pragma solidity ^0.8.4;

interface IHedgepieAuthority {
    /* ========== EVENTS ========== */

    event GovernorPushed(
        address indexed from,
        address indexed to,
        bool _effectiveImmediately
    );
    event PathManagerPushed(
        address indexed from,
        address indexed to,
        bool _effectiveImmediately
    );
    event AdapterManagerPushed(
        address indexed from,
        address indexed to,
        bool _effectiveImmediately
    );

    event GovernorPulled(address indexed from, address indexed to);
    event PathManagerPulled(address indexed from, address indexed to);
    event AdapterManagerPulled(address indexed from, address indexed to);

    event HInvestorUpdated(address indexed from, address indexed to);
    event HYBNFTUpdated(address indexed from, address indexed to);
    event HAdapterListUpdated(address indexed from, address indexed to);
    event PathFinderUpdated(address indexed from, address indexed to);

    /* ========== VIEW ========== */

    function governor() external view returns (address);

    function pathManager() external view returns (address);

    function adapterManager() external view returns (address);

    function hInvestor() external view returns (address);

    function hYBNFT() external view returns (address);

    function hAdapterList() external view returns (address);

    function pathFinder() external view returns (address);

    function paused() external view returns (bool);
}


// File: contracts/base/HedgepieAccessControlled.sol
// SPDX-License-Identifier: AGPL-3.0
pragma solidity ^0.8.4;

import "../interfaces/IHedgepieAuthority.sol";

abstract contract HedgepieAccessControlled {
    /* ========== EVENTS ========== */

    event AuthorityUpdated(IHedgepieAuthority indexed authority);

    string UNAUTHORIZED = "UNAUTHORIZED"; // save gas

    string PAUSED = "PAUSED"; // save gas

    /* ========== STATE VARIABLES ========== */

    IHedgepieAuthority public authority;

    /* ========== Constructor ========== */

    constructor(IHedgepieAuthority _authority) {
        authority = _authority;
        emit AuthorityUpdated(_authority);
    }

    /* ========== MODIFIERS ========== */

    modifier whenNotPaused() {
        require(!authority.paused(), PAUSED);
        _;
    }

    modifier onlyGovernor() {
        require(msg.sender == authority.governor(), UNAUTHORIZED);
        _;
    }

    modifier onlyPathManager() {
        require(msg.sender == authority.pathManager(), UNAUTHORIZED);
        _;
    }

    modifier onlyAdapterManager() {
        require(msg.sender == authority.adapterManager(), UNAUTHORIZED);
        _;
    }

    modifier onlyInvestor() {
        require(msg.sender == authority.hInvestor(), UNAUTHORIZED);
        _;
    }

    /* ========== GOV ONLY ========== */

    function setAuthority(
        IHedgepieAuthority _newAuthority
    ) external onlyGovernor {
        authority = _newAuthority;
        emit AuthorityUpdated(_newAuthority);
    }
}


// File: contracts/interfaces/IWrap.sol
// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity ^0.8.4;

interface IWrap {
    function deposit(uint256 amount) external;

    function withdraw(uint256 share) external;

    function deposit() external payable;
}


// File: contracts/base/BaseAdapter.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "../interfaces/IYBNFT.sol";
import "../interfaces/IPathFinder.sol";
import "../interfaces/IHedgepieInvestor.sol";
import "../interfaces/IHedgepieAuthority.sol";

import "./HedgepieAccessControlled.sol";

abstract contract BaseAdapter is HedgepieAccessControlled {
    struct UserAdapterInfo {
        uint256 amount; // Staking token amount
        uint256 userShare1; // Reward tokens' share
        uint256 userShare2; // Reward tokens' share
        uint256 rewardDebt1; // Reward Debt for reward tokens
        uint256 rewardDebt2; // Reward Debt for reward tokens
    }

    struct AdapterInfo {
        uint256 accTokenPerShare1; // Accumulated per share for first reward token
        uint256 accTokenPerShare2; // Accumulated per share for first reward token
        uint256 totalStaked; // Total staked staking token
    }

    uint256 public pid;

    address public stakingToken;

    address public rewardToken;

    address public rewardToken1;

    address public repayToken;

    address public strategy;

    address public router;

    address public swapRouter;

    address public wbnb;

    string public name;

    AdapterInfo public mAdapter;

    // nft id => UserAdapterInfo
    mapping(uint256 => UserAdapterInfo) public userAdapterInfos;

    // nft id => AdapterInfo
    mapping(uint256 => AdapterInfo) public adapterInfos;

    constructor(
        address _hedgepieAuthority
    ) HedgepieAccessControlled(IHedgepieAuthority(_hedgepieAuthority)) {}

    /** @notice get user staked amount */
    function getUserAmount(
        uint256 _tokenId
    ) external view returns (uint256 amount) {
        return userAdapterInfos[_tokenId].amount;
    }

    /**
     * @notice deposit to strategy
     * @param _tokenId YBNFT token id
     */
    function deposit(
        uint256 _tokenId
    ) external payable virtual returns (uint256 amountOut) {}

    /**
     * @notice withdraw from strategy
     * @param _tokenId YBNFT token id
     * @param _amount amount of staking tokens to withdraw
     */
    function withdraw(
        uint256 _tokenId,
        uint256 _amount
    ) external payable virtual returns (uint256 amountOut) {}

    /**
     * @notice claim reward from strategy
     * @param _tokenId YBNFT token id
     */
    function claim(
        uint256 _tokenId
    ) external payable virtual returns (uint256 amountOut) {}

    /**
     * @notice Remove funds
     * @param _tokenId YBNFT token id
     */
    function removeFunds(
        uint256 _tokenId
    ) external payable virtual returns (uint256 amountOut) {}

    /**
     * @notice Update funds
     * @param _tokenId YBNFT token id
     */
    function updateFunds(
        uint256 _tokenId
    ) external payable virtual returns (uint256 amountOut) {}

    /**
     * @notice Get pending token reward
     * @param _tokenId YBNFT token id
     */
    function pendingReward(
        uint256 _tokenId
    ) external view virtual returns (uint256 reward, uint256 withdrawable) {}
}


// File: contracts/interfaces/IYBNFT.sol
// SPDX-License-Identifier: None
pragma solidity ^0.8.4;

interface IYBNFT {
    struct AdapterParam {
        uint256 allocation;
        address token;
        address addr;
    }

    function getCurrentTokenId() external view returns (uint256);

    function performanceFee(uint256 tokenId) external view returns (uint256);

    function getTokenAdapterParams(
        uint256 tokenId
    ) external view returns (AdapterParam[] memory);

    function exists(uint256) external view returns (bool);

    function mint(
        uint256[] calldata,
        address[] calldata,
        address[] calldata,
        uint256,
        string memory
    ) external;

    function updateTVLInfo(
        uint256 _tokenId,
        uint256 _value,
        bool _adding
    ) external;

    function updateTradedInfo(
        uint256 _tokenId,
        uint256 _value,
        bool _adding
    ) external;

    function updateProfitInfo(
        uint256 _tokenId,
        uint256 _value,
        bool _adding
    ) external;

    function updateParticipantInfo(
        uint256 _tokenId,
        address _account,
        bool _adding
    ) external;
}


// File: contracts/interfaces/IPathFinder.sol
// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity ^0.8.4;

interface IPathFinder {
    function getPaths(
        address _router,
        address _inToken,
        address _outToken
    ) external view returns (address[] memory);
}


// File: contracts/interfaces/IHedgepieInvestor.sol
// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity ^0.8.4;

interface IHedgepieInvestor {
    function treasury() external view returns (address);

    function updateFunds(uint256 _tokenId) external;

    function deposit(uint256 _tokenId) external;

    function withdraw(uint256 _tokenId) external;

    function claim(uint256 _tokenId) external;

    function pendingReward(
        uint256 _tokenId,
        address _account
    ) external returns (uint256 amountOut, uint256 withdrawable);
}

