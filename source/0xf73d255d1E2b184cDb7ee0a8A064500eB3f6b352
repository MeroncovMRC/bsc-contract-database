// File: @openzeppelin/contracts/security/ReentrancyGuard.sol



pragma solidity ^0.8.0;

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and make it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}

// File: TransferHelper.sol


pragma solidity >=0.8.3;

library TransferHelper {
    function safeApprove(address token, address to, uint value) internal {
        // bytes4(keccak256(bytes('approve(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');
    }

    function safeTransfer(address token, address to, uint value) internal {
        // bytes4(keccak256(bytes('transfer(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');
    }

    function safeTransferFrom(address token, address from, address to, uint value) internal {
        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');
    }

    function safeTransferBNB(address to, uint value) internal {
        (bool success,) = to.call{value:value}(new bytes(0));
        require(success, 'TransferHelper: BNB_TRANSFER_FAILED');
    }
}
// File: iWBNB.sol


pragma solidity 0.8.3;
interface iWBNB {
    function withdraw(uint256) external;
}
// File: iPOOLFACTORY.sol


pragma solidity 0.8.3;
interface iPOOLFACTORY {
    function isCuratedPool(address) external view returns (bool);
    function addCuratedPool(address) external;
    function removeCuratedPool(address) external;
    function isPool(address) external returns (bool);
    function getPool(address) external view returns(address);
    function getVaultAssets() external view returns(address [] memory);
    function getPoolAssets() external view returns(address [] memory);
    function curatedPoolCount() external view returns (uint);
}

// File: iRESERVE.sol


pragma solidity 0.8.3;
interface iRESERVE {
    function grantPOLFunds(uint, address) external; 
     function grantFunds(uint, address) external; 
    function emissions() external returns(bool); 
    function setGlobalFreeze(bool) external; 
    function setIncentiveAddresses(address, address, address, address) external;
    function globalFreeze() external returns(bool); 
    function freezeTime() external returns(uint256); 
    function polPoolAddress() external view returns(address); 
}

// File: iSYNTHVAULT.sol


pragma solidity 0.8.3;
interface iSYNTHVAULT{
   function depositForMember(address synth, address member) external;
   function setReserveClaim(uint256 _setSynthClaim) external;
}
// File: iSYNTHFACTORY.sol


pragma solidity 0.8.3;
interface iSYNTHFACTORY {
    function isSynth(address) external view returns (bool);
    function getSynth(address) external view returns (address);
    function removeSynth(address _token) external;
    function synthCount() external returns(uint);
}
// File: iSYNTH.sol


pragma solidity 0.8.3;
interface iSYNTH {
    function genesis() external view returns(uint);
    function TOKEN() external view returns(address);
    function POOL() external view returns(address);
    function mintSynth(address, uint) external returns(uint256);
    function burnSynth(uint) external returns(uint);
    function realise() external;
}

// File: iROUTER.sol


pragma solidity 0.8.3;
interface iROUTER {
    function addLiquidityForMember(uint, uint, address, address) external payable returns (uint);
      function synthMinting() external view returns (bool);
      function lastMonth() external view returns(uint); 
      function mapAddress_30DayDividends(address) external returns (uint);
      function mapAddress_Past30DayPoolDividends(address) external returns (uint);
      function addLiquidityAsym(uint input, bool fromBase, address token) external;
      function removeLiquidityExactAsym(uint input, bool fromBase, address token) external;
      function syncPool(address, uint256) external;
}
// File: iDAOVAULT.sol


pragma solidity 0.8.3;
interface iDAOVAULT{
  function getMemberWeight(address) external view returns (uint256);
  function getMemberPoolBalance(address, address) external view returns(uint);
  function getMemberLPWeight(address) external view returns(uint, uint);
  function depositLP(address, uint, address) external;
  function withdraw(address, address) external returns (bool);
  function totalWeight() external view returns (uint);
  function mapTotalPool_balance(address) external view returns (uint);
}
// File: iDAO.sol


pragma solidity 0.8.3;
interface iDAO {
    function ROUTER() external view returns(address);
    function DAOVAULT() external view returns(address);
    function BASE() external view returns(address);
    function LEND() external view returns(address);
    function UTILS() external view returns(address);
    function DAO() external view returns (address);
    function RESERVE() external view returns(address);
    function SYNTHVAULT() external view returns(address);
    function BONDVAULT() external view returns(address);
    function SYNTHFACTORY() external view returns(address);
    function POOLFACTORY() external view returns(address);
    function depositForMember(address pool, uint256 amount, address member) external;
    function currentProposal() external view returns (uint);
    function mapPID_open(uint) external view returns (bool);
    function isListed(address) external view returns (bool);
    function arrayMembers(uint) external view returns (address);
    function mapMember_lastTime(address) external view returns (uint);
}
// File: iBASE.sol


pragma solidity 0.8.3;

interface iBASE {
    function DAO() external view returns (iDAO);
    function secondsPerEra() external view returns (uint256);
    function changeDAO(address) external;
    function setParams(uint256, uint256) external;
    function flipEmissions() external;
    function mintFromDAO(uint256, address) external; 
    function burn(uint256) external; 
}
// File: iUTILS.sol

//SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;
interface iUTILS {
    function calcShare(uint, uint, uint) external pure returns (uint);
    function getFeeOnTransfer(uint256, uint256) external view returns(uint);
    function getPoolShareWeight(address, uint)external view returns(uint);
    function calcLiquidityUnits(uint, uint, uint, uint, uint) external pure returns (uint);
    function calcLiquidityHoldings(uint, address, address) external pure returns (uint);
    function calcSwapOutput(uint, uint, uint) external pure returns (uint);
    function calcSwapFee(uint, uint, uint) external pure returns (uint);
    function calcSwapValueInBase(address, uint) external view returns (uint);
    function calcSwapValueInToken(address, uint) external view returns (uint);
    function calcSpotValueInBaseWithSynth(address, uint) external view returns (uint);
    function calcSpotValueInBase(address, uint) external view returns (uint);
    function calcPart(uint, uint) external pure returns (uint);
    function calcLiquidityUnitsAsym(uint, address)external pure returns (uint);
    function calcActualSynthUnits(address, uint) external view returns (uint);
}
// File: iBEP20.sol


pragma solidity 0.8.3;
interface iBEP20 {
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint8);
    function totalSupply() external view returns (uint256);
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function allowance(address, address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
    function burn(uint) external;
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

// File: Pool.sol


pragma solidity 0.8.3;










contract Pool is iBEP20 {  
    address public immutable BASE;  // Address of SPARTA base token contract
    address public immutable TOKEN; // Address of the layer1 TOKEN represented in this pool
    uint256 public synthCap;    // Basis points hard cap of synths that can be minted vs tokenDepth
    uint256 public baseCap;     // Cap on the depth of the pool (in SPARTA)
    uint256 public oldRate;    // Pool ratio from last period
    uint256 private period;     // Timestamp of next period
    uint256 private freezePoint; // Basis points change to trigger a freeze
    bool public freeze;         // Freeze status of the pool
    uint256 private oneWeek;

    uint256 public stirRate; // Rate of steaming
    uint public lastStirred; // timestamp of last steamed
    uint public stirStamp; // timestamp of last time stir rate was adjusted
    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));

    string private _name;
    string private _symbol;
    uint8 public override immutable decimals;
    uint256 public override totalSupply;
    mapping(address => uint) private _balances;
    mapping(address => mapping(address => uint)) private _allowances;

    uint256 public baseAmount;  // SPARTA amount that should be in the pool
    uint256 public tokenAmount; // TOKEN amount that should be in the pool

    uint private lastMonth;          // Timestamp of the start of current metric period (For UI)
    uint public immutable genesis;  // Timestamp from when the pool was first deployed (For UI)

    uint256 public map30DPoolRevenue;       // Tally of revenue during current incomplete metric period (for UI)
    uint256 public mapPast30DPoolRevenue;   // Tally of revenue from last full metric period (for UI)
    uint256 [] private revenueArray;         // Array of the last two full metric periods (For UI)
    
    event AddLiquidity(address indexed member, address indexed tokenAddress, uint inputBase, uint inputToken, uint unitsIssued);
    event RemoveLiquidity(address indexed member, address indexed tokenAddress, uint outputBase, uint outputToken, uint unitsClaimed);
    event Swapped(address indexed tokenFrom, address indexed tokenTo, address indexed recipient, uint inputAmount, uint outputAmount, uint fee);
    event MintSynth(address indexed member, address indexed synthAddress, uint256 baseAmount, uint256 liqUnits, uint256 synthAmount);
    event BurnSynth(address indexed member, address indexed synthAddress, uint256 baseAmount, uint256 liqUnits, uint256 synthAmount);

    function SYNTH() public view returns(address) {
        return iSYNTHFACTORY(_DAO().SYNTHFACTORY()).getSynth(TOKEN); // Get the relevant synth address
    }

    function _DAO() internal view returns(iDAO) {
        return iBASE(BASE).DAO(); // Get the DAO address reported by Sparta base contract
    }

    // Restrict access
    modifier onlyPROTOCOL() {
        require(msg.sender == _DAO().ROUTER() || msg.sender == _DAO().SYNTHVAULT() || msg.sender == _DAO().POOLFACTORY()); 
        _;
    }
    modifier onlyDAO() {
        require(msg.sender == _DAO().DAO() || msg.sender == _DAO().ROUTER() || msg.sender == _DAO().SYNTHVAULT());
        _;
    }
     modifier onlySYNTH() {
        require(msg.sender == SYNTH());
        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(SYNTH()));
        _;
    }

    constructor (address _base, address _token) {
        BASE = _base;
        TOKEN = _token;
        string memory poolName = "-SpartanProtocolPool";
        string memory poolSymbol = "-SPP";
        _name = string(abi.encodePacked(iBEP20(_token).name(), poolName));
        _symbol = string(abi.encodePacked(iBEP20(_token).symbol(), poolSymbol));
        decimals = 18;
        genesis = block.timestamp;
        period = block.timestamp + 60; 
        lastMonth = block.timestamp;
        synthCap = 2500; //25%
        freezePoint = 3000; //30%
        baseCap = 100000*10**18; //RAISE THE CAPS
        lastStirred = 0;
        oneWeek = 604800;//604800 mainnet
    }

    //========================================iBEP20=========================================//

    function name() external view override returns (string memory) {
        return _name;
    }

    function symbol() external view override returns (string memory) {
        return _symbol;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    function transfer(address recipient, uint256 amount) external virtual override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function approve(address spender, uint256 amount) external virtual override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {
        uint256 currentAllowance = _allowances[msg.sender][spender];
        require(currentAllowance >= subtractedValue, "!approval");
        _approve(msg.sender, spender, currentAllowance - subtractedValue);
        return true;
    }

    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), "!owner");
        require(spender != address(0), "!spender");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function transferFrom(address sender, address recipient, uint256 amount) external virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        uint256 currentAllowance = _allowances[sender][msg.sender];
        require(currentAllowance >= amount, "!approval");
        _approve(sender, msg.sender, currentAllowance - amount);
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), "!sender");
        require(recipient != address(0), '!BURN');
        uint256 senderBalance = _balances[sender];
        require(senderBalance >= amount, "!balance");
        _balances[sender] = senderBalance - amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "!account");
        totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    function burn(uint256 amount) external onlySYNTH virtual override {
        _burn(msg.sender, amount);
    }

    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), "!account");
        uint256 accountBalance = _balances[account];
        require(accountBalance >= amount, "!balance");
        _balances[account] = accountBalance - amount;
        totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }

    //====================================POOL FUNCTIONS =================================//

    // Contract adds liquidity for user 
    function addForMember(address member) external onlyPROTOCOL returns (uint liquidityUnits){
        uint256 _actualInputBase = _getAddedBaseAmount(); // Get the received SPARTA amount
        uint256 _actualInputToken = _getAddedTokenAmount(); // Get the received TOKEN amount
        liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnits(_actualInputBase, baseAmount, _actualInputToken, tokenAmount, totalSupply); // Calculate LP tokens to mint
        if(baseAmount == 0 || tokenAmount == 0){
            uint createFee = 100 * liquidityUnits / 10000; // First liqAdd charges 1% fee to the base contract (permanently removed from circulation; prevent 1wei rounding)
            liquidityUnits -= createFee; // Remove fee from the calculated LP units
            _mint(BASE, createFee); // Mint the fee portion of the LP units to the BASE contract (permanently removed from circulation)
            oldRate = (10**18 * _actualInputBase) / _actualInputToken; // Set the first / initial rate
        }
        _incrementPoolBalances(_actualInputBase, _actualInputToken); // Update recorded BASE and TOKEN amounts
        _mint(member, liquidityUnits); // Mint the remaining LP tokens directly to the user
        emit AddLiquidity(member, TOKEN, _actualInputBase, _actualInputToken, liquidityUnits);
        return liquidityUnits;
    }

    // Contract removes liquidity for the user
    function removeForMember(address recipient, address actualMember) external onlyPROTOCOL returns (uint outputBase, uint outputToken) {
        require(block.timestamp > (genesis + oneWeek)); // Can not remove liquidity until 7 days after pool's creation
        uint256 _actualInputUnits = balanceOf(address(this)); // Get the received LP units amount
        iUTILS _utils = iUTILS(_DAO().UTILS()); // Interface the UTILS contract
        outputBase = _utils.calcLiquidityHoldings(_actualInputUnits, BASE, address(this)); // Get the SPARTA value of LP units
        outputToken = _utils.calcLiquidityHoldings(_actualInputUnits, TOKEN, address(this)); // Get the TOKEN value of LP units
        _decrementPoolBalances(outputBase, outputToken); // Update recorded SPARTA and TOKEN amounts
        _burn(address(this), _actualInputUnits); // Burn the LP tokens
        _safeTransfer(BASE, recipient,outputBase);        
        _safeTransfer(TOKEN, recipient,outputToken);
        emit RemoveLiquidity(actualMember, TOKEN, outputBase, outputToken, _actualInputUnits);
        return (outputBase, outputToken);
    }

    // Contract swaps tokens for the member
    function swapTo(address token, address member) external onlyPROTOCOL returns (uint outputAmount, uint fee) {
        require((token == BASE || token == TOKEN)); // Must be SPARTA or the pool's relevant TOKEN
        address _fromToken; uint _amount;
        if(token == BASE){
            _fromToken = TOKEN; // If SPARTA is selected; swap from TOKEN
            _amount = _getAddedTokenAmount(); // Get the received TOKEN amount
            (outputAmount, fee) = _swapTokenToBase(_amount); // Calculate the SPARTA output from the swap
        } else {
            _fromToken = BASE; // If TOKEN is selected; swap from SPARTA
            _amount = _getAddedBaseAmount(); // Get the received SPARTA amount
            (outputAmount, fee) = _swapBaseToToken(_amount); // Calculate the TOKEN output from the swap
        }
        emit Swapped(_fromToken, token, member, _amount, outputAmount, fee);
        _safeTransfer(token, member,outputAmount);  
        return (outputAmount, fee);
    }

    // Swap SPARTA for Synths
    function mintSynth(address member) external onlyPROTOCOL returns(uint outputAmount, uint fee) {
        address synthOut = SYNTH(); // Get the synth address
        require(iROUTER(_DAO().ROUTER()).synthMinting());  
        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthOut)); // Must be a valid Synth
        iUTILS _utils = iUTILS(_DAO().UTILS()); // Interface the UTILS contract
        uint256 _actualInputBase = _getAddedBaseAmount(); // Get received SPARTA amount
        uint256 steamedSynths = stirCauldron(synthOut);
        uint256 output = _utils.calcSwapOutput(_actualInputBase, baseAmount, tokenAmount); // Calculate value of swapping SPARTA to the relevant underlying TOKEN (virtualised)
        lastStirred = block.timestamp;
        outputAmount = output * 9900 / 10000; //1% fee reduction
        require(outputAmount <= steamedSynths); //steam synths
        uint _liquidityUnits = _utils.calcLiquidityUnitsAsym(_actualInputBase, address(this)); // Calculate LP tokens to be minted
        _incrementPoolBalances(_actualInputBase, 0); // Update recorded SPARTA amount
        uint _fee = _utils.calcSwapFee(_actualInputBase, baseAmount, tokenAmount); // Calc slip fee in TOKEN (virtualised)
        fee = _utils.calcSpotValueInBase(TOKEN, _fee); // Convert TOKEN fee to SPARTA
        _mint(synthOut, _liquidityUnits); // Mint the LP tokens directly to the Synth contract to hold
        iSYNTH(synthOut).mintSynth(address(_DAO().SYNTHVAULT()), outputAmount); // Mint the Synth tokens directly to the synthVault
        iSYNTHVAULT(_DAO().SYNTHVAULT()).depositForMember(synthOut, member); //Deposit on behalf of member
        _addPoolMetrics(fee); // Add slip fee to the revenue metrics
        emit MintSynth(member,synthOut, _actualInputBase, _liquidityUnits, outputAmount);
        return (outputAmount, fee);
    }
    
    // Swap Synths for SPARTA
    function burnSynth(address recipient, address actualMember) external onlyPROTOCOL returns(uint outputAmount, uint fee) {
        address synthIN = SYNTH(); // Get the synth address
        require(synthIN != address(0)); // Must be a valid Synth
        iUTILS _utils = iUTILS(_DAO().UTILS()); // Interface the UTILS contract
        uint _actualInputSynth = iBEP20(synthIN).balanceOf(address(this)); // Get received SYNTH amount
        uint output = _utils.calcSwapOutput(_actualInputSynth, tokenAmount, baseAmount); // Calculate value of swapping relevant underlying TOKEN to SPARTA (virtualised)
        uint outputBase = output * 9500 / 10000; //5% reduction
        fee = _utils.calcSwapFee(_actualInputSynth, tokenAmount, baseAmount); // Calc slip fee in SPARTA (virtualised)
        _decrementPoolBalances(outputBase, 0); // Update recorded SPARTA amount
        _addPoolMetrics(fee); // Add slip fee to the revenue metrics
        uint liqUnits = iSYNTH(synthIN).burnSynth(_actualInputSynth); // Burn the input SYNTH units 
        _burn(synthIN, liqUnits); // Burn the synth-held LP units
        _safeTransfer(BASE, recipient,outputBase);  
        emit BurnSynth(actualMember,synthIN, outputBase, liqUnits, _actualInputSynth);
        return (outputBase, fee);
    }

    function stirCauldron(address synth) public returns (uint256 steamedSynths){ 
          uint256 synthsCap = tokenAmount * synthCap / 10000;
          uint256 liquidSynths; uint256 totalSup = iBEP20(synth).totalSupply();
          steamedSynths = 0;
         if(synthsCap >= totalSup){
             liquidSynths = synthsCap - totalSup; 
         }
         if(lastStirred != 0){ 
            uint secondsSinceStirred = block.timestamp - lastStirred; //Get last time since stirred
            steamedSynths = secondsSinceStirred * stirRate; //time since last minted
         }else{
            lastStirred = block.timestamp;
            stirStamp = block.timestamp;
            stirRate = liquidSynths / oneWeek;
            steamedSynths = 14400 * stirRate;  //4hrs
         }
         if(block.timestamp > (stirStamp + oneWeek)){
            stirRate = liquidSynths / oneWeek;
            stirStamp = block.timestamp;
         }
    }

    //=======================================INTERNAL MATHS======================================//

    // Check the SPARTA amount received by this Pool
    function _getAddedBaseAmount() internal view returns(uint256 _actual){
        uint _baseBalance = iBEP20(BASE).balanceOf(address(this));
        if(_baseBalance > baseAmount){
            _actual = _baseBalance - baseAmount;
        } else {
            _actual = 0;
        }
        return _actual;
    }
  
    // Check the TOKEN amount received by this Pool
    function _getAddedTokenAmount() internal view returns(uint256 _actual){
        uint _tokenBalance = iBEP20(TOKEN).balanceOf(address(this)); 
        if(_tokenBalance > tokenAmount){
            _actual = _tokenBalance - tokenAmount;
        } else {
            _actual = 0;
        }
        return _actual;
    }

    // Calculate output of swapping SPARTA for TOKEN & update recorded amounts
    function _swapBaseToToken(uint256 _x) internal returns (uint256 _y, uint256 _fee){
        uint256 _X = baseAmount;
        uint256 _Y = tokenAmount;
        iUTILS _utils = iUTILS(_DAO().UTILS());
        _y =  _utils.calcSwapOutput(_x, _X, _Y); // Calc TOKEN output 
        uint fee = _utils.calcSwapFee(_x, _X, _Y); // Calc TOKEN fee 
        _fee = _utils.calcSpotValueInBase(TOKEN, fee); // Convert TOKEN fee to SPARTA
        _setPoolAmounts(_X + _x, _Y - _y); // Update recorded BASE and TOKEN amounts
        _addPoolMetrics(_fee); // Add slip fee to the revenue metrics
        return (_y, _fee);
    }

    // Calculate output of swapping TOKEN for SPARTA & update recorded amounts
    function _swapTokenToBase(uint256 _x) internal returns (uint256 _y, uint256 _fee){
        uint256 _X = tokenAmount;
        uint256 _Y = baseAmount;
        iUTILS _utils = iUTILS(_DAO().UTILS());
        _y = _utils.calcSwapOutput(_x, _X, _Y); // Calc SPARTA output 
        _fee = _utils.calcSwapFee(_x, _X, _Y); // Calc SPARTA fee 
        _setPoolAmounts(_Y - _y, _X + _x); // Update recorded BASE and TOKEN amounts
        _addPoolMetrics(_fee); // Add slip fee to the revenue metrics
        return (_y, _fee);
    }

    //=======================================BALANCES=========================================//

    // Sync internal balances to actual
    function sync() external onlyDAO  {
        baseAmount = iBEP20(BASE).balanceOf(address(this));
        tokenAmount = iBEP20(TOKEN).balanceOf(address(this));
    }

    // Set internal balances
    function _setPoolAmounts(uint256 _baseAmount, uint256 _tokenAmount) internal {
        baseAmount = _baseAmount;
        tokenAmount = _tokenAmount; 
        _safetyCheck();
    }

    // Increment internal balances
    function _incrementPoolBalances(uint _baseAmount, uint _tokenAmount) internal {
        require((baseAmount + _baseAmount) < baseCap); // SPARTA input must not push TVL over the cap
        baseAmount += _baseAmount;
        tokenAmount += _tokenAmount;
        _safetyCheck();
    }

    // Decrement internal balances
    function _decrementPoolBalances(uint _baseAmount, uint _tokenAmount) internal {
        baseAmount -= _baseAmount;
        tokenAmount -= _tokenAmount; 
        _safetyCheck();
    }

    function _safeTransfer(address token, address to, uint value) private {
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TRANSFER_FAILED');
    }

    function _safetyCheck() internal {
            uint currentRate = (10**18 * baseAmount) / tokenAmount; // Get current rate
            uint rateDiff; uint256 rateDiffBP;
            if (currentRate > oldRate) {
                rateDiff = currentRate - oldRate; // Get absolute rate diff
                rateDiffBP = rateDiff * 10000 / currentRate; // Get basispoints difference
            } else {
                rateDiff = oldRate - currentRate; // Get absolute rate diff
                rateDiffBP = rateDiff * 10000 / oldRate; // Get basispoints difference
            }
            if (rateDiffBP >= freezePoint) {
                freeze = true; // If exceeding; flip freeze to true
            } else if (block.timestamp > period) {
                period = block.timestamp + 3600; // Set new period
                oldRate = currentRate; // Update the stored ratio
            }
            if(freeze){
                if(rateDiffBP <= freezePoint){
                    freeze = false; // If exceeding; flip freeze to false
                }
                if (block.timestamp > period) {
                    period = block.timestamp + 3600; // Set new period
                    oldRate = (currentRate + oldRate ) / 2; //Smooth rate increase
                }
            }  
    }
  
    //===========================================POOL FEE ROI=================================//

    function _addPoolMetrics(uint256 _fee) internal {
        if (block.timestamp <= (lastMonth + 2592000)) {
            map30DPoolRevenue = map30DPoolRevenue + _fee;
        } else {
            lastMonth = block.timestamp;
            mapPast30DPoolRevenue = map30DPoolRevenue;
            _archiveRevenue(mapPast30DPoolRevenue);
            map30DPoolRevenue = _fee;
        }
    }

    function _archiveRevenue(uint _totalRev) internal {
        if (revenueArray.length == 2) {
            revenueArray[0] = revenueArray[1]; // Shift previous value to start of array
            revenueArray[1] = _totalRev; // Replace end of array with new value
        } else {
            revenueArray.push(_totalRev);
        }
    }

    //=========================================== SYNTH CAPS =================================//
    
    function setSynthCap(uint256 _synthCap) external onlyPROTOCOL {
        require(_synthCap <= 3000);
        synthCap = _synthCap;
    }

    function RTC(uint256 _newRTC) external onlyPROTOCOL {
        require(_newRTC <= (baseCap * 2));
        baseCap = _newRTC;
    }

    function setFreezePoint(uint256 _newFreezePoint) external onlyPROTOCOL {
        freezePoint = _newFreezePoint;
    }
}

// File: Router.sol


pragma solidity 0.8.3;








contract Router is ReentrancyGuard{
    address private immutable BASE;  // SPARTA base contract address
    address private immutable WBNB;  // Address of WBNB
    address private DEPLOYER;        // Address that deployed the contract
    uint256 public diviClaim;       // Basis points vs RESERVE holdings max dividend per month
    uint public lastMonth;          // Timestamp of the start of current metric period (For UI)
    uint256 private curatedPoolsCount; // Count of curated pools, synced from PoolFactory once per month
    bool public synthMinting;
    uint public minDiv;

    mapping(address=> uint) public mapAddress_30DayDividends; // Current incomplete-period NET SPARTA divis by pool
    mapping(address=> uint) public mapAddress_Past30DayPoolDividends; // Previous full-period NET SPARTA divis by pool
    event Dividend(address Pool, uint256 amount);
    // Restrict access
    modifier onlyDAO() {
        require(msg.sender == _DAO().DAO() || msg.sender == DEPLOYER);
        _;
    }
    modifier onlyRESERVE() {
        require(msg.sender == _DAO().RESERVE());
        _;
    }

    // Can purge deployer once DAO is stable and final
    function purgeDeployer() external onlyDAO {
        DEPLOYER = address(0);
    }

    constructor (address _base, address _wbnb) {
        BASE = _base;
        WBNB = _wbnb;
        diviClaim = 500;
        synthMinting = false;
        DEPLOYER = msg.sender;
        minDiv = 10**18;
    }

    receive() external payable {} // Used to receive BNB from WBNB contract

    function _DAO() internal view returns(iDAO) {
        return iBASE(BASE).DAO(); // Get the DAO address from SPARTA base contract
    }

    // User adds liquidity
    function addLiquidity(uint inputToken, uint baseAmount, address token) external payable{
        addLiquidityForMember(inputToken, baseAmount, token, msg.sender);
    }

    // Contract adds liquidity for user
    function addLiquidityForMember(uint inputToken, uint baseAmount, address token, address member) public payable returns (uint256 LPsMinted) {
        iPOOLFACTORY _poolFactory = iPOOLFACTORY(_DAO().POOLFACTORY()); // Interface the PoolFactory
        address pool = _poolFactory.getPool(token); // Get pool address
        require(_poolFactory.isPool(pool) == true, '!POOL'); // Pool must be valid
        _handleTransferIn(BASE, baseAmount, pool); // Transfer SPARTA (User -> Pool)
        _handleTransferIn(token, inputToken, pool); // Transfer TOKEN (User -> Pool)
        LPsMinted = Pool(pool).addForMember(member); // Add liquidity; tsf LPs (Pool -> User)
        _safetyTrigger(pool); // Check pool ratios
    }

    function addLiquidityAsym(uint input, bool fromBase, address token) external payable {
        addLiquidityAsymForMember(input, fromBase, token, msg.sender);
    }

    function addLiquidityAsymForMember(uint _input, bool _fromBase, address token, address _member) public payable {
        iPOOLFACTORY _poolFactory = iPOOLFACTORY(_DAO().POOLFACTORY()); // Interface the PoolFactory
        address _pool = _poolFactory.getPool(token); // Get pool address
        require(_poolFactory.isPool(_pool) == true, '!POOL'); // Pool must be valid
        address _token = token; // Get token address
        if(token == address(0)){_token = WBNB;} // Handle BNB -> WBNB
        if(_fromBase){
            _handleTransferIn(BASE, _input, address(this));
            _handleTransferOut(BASE, (_input / 2), _pool);
            Pool(_pool).swapTo(_token, address(this)); // Swap TOKEN to SPARTA (Pool -> router)
            _handleTransferOut(BASE, iBEP20(BASE).balanceOf(address(this)), _pool); // Tsf swapped SPARTA (Router -> Pool)
            _handleTransferOut(_token, iBEP20(_token).balanceOf(address(this)), _pool); // Tsf remaining BNB (Router -> Pool)
        } else {
            _handleTransferIn(token, _input, address(this));
            _handleTransferOut(_token, (_input / 2), _pool);
            Pool(_pool).swapTo(BASE, address(this)); // Swap TOKEN to SPARTA (Pool -> router)
            _handleTransferOut(BASE, iBEP20(BASE).balanceOf(address(this)), _pool); // Tsf swapped SPARTA (Router -> Pool)
            _handleTransferOut(_token, iBEP20(_token).balanceOf(address(this)), _pool); // Tsf remaining BNB (Router -> Pool)
        }
        Pool(_pool).addForMember(_member); // Add liquidity; tsf LPs (Pool -> User)
        _safetyTrigger(_pool); // Check pool ratios
    }

    // Swap LP tokens for a different pool's LP tokens
    function zapLiquidity(uint unitsInput, address fromPool, address toPool) external nonReentrant {
        require(fromPool != toPool && unitsInput > 0, '!VALID'); // Pools must be different and input must be valid
        iPOOLFACTORY _poolFactory = iPOOLFACTORY(_DAO().POOLFACTORY()); // Interface the PoolFactory
        require(_poolFactory.isPool(fromPool) == true, '!POOL'); // FromPool must be a valid pool
        if(_poolFactory.isCuratedPool(fromPool)){
            require(Pool(fromPool).freeze() == false);
        }
        require(_poolFactory.isPool(toPool) == true, '!POOL'); // ToPool must be a valid pool
        address _fromToken = Pool(fromPool).TOKEN(); // Get token underlying the fromPool
        address _toToken = Pool(toPool).TOKEN(); // Get token underlying the toPool
        address _member = msg.sender; // Get user's address
        TransferHelper.safeTransferFrom(fromPool, _member, fromPool, unitsInput);
        Pool(fromPool).removeForMember(address(this), _member); // Remove liquidity; tsf SPARTA and fromTOKEN (Pool -> Router)
        TransferHelper.safeTransfer(_fromToken, fromPool, iBEP20(_fromToken).balanceOf(address(this)));
        Pool(fromPool).swapTo(BASE, address(this)); // Swap fromTOKEN for SPARTA (FromPool -> Router)
        TransferHelper.safeTransfer(BASE, toPool, iBEP20(BASE).balanceOf(address(this)) / 2);
        Pool(toPool).swapTo(_toToken, address(this)); // Swap SPARTA for toTOKEN (ToPool -> Router)
        TransferHelper.safeTransfer(BASE, toPool, iBEP20(BASE).balanceOf(address(this)));
        TransferHelper.safeTransfer(_toToken, toPool, iBEP20(_toToken).balanceOf(address(this)));
        Pool(toPool).addForMember(_member); // Add liquidity; tsf LPs (Pool -> User)
        _safetyTrigger(fromPool); // Check fromPool ratios
        _safetyTrigger(toPool); // Check toPool ratios
    }

    // User removes liquidity - redeems exact qty of LP tokens
    function removeLiquidityExact(uint units, address token) public {
        require(units > 0, '!VALID'); // Must be a valid amount
        iPOOLFACTORY _poolFactory = iPOOLFACTORY(_DAO().POOLFACTORY()); // Interface the PoolFactory
        address _pool = _poolFactory.getPool(token); // Get the pool address
        if(_poolFactory.isCuratedPool(_pool)){
            require(Pool(_pool).freeze() == false);
        }
        require(_poolFactory.isPool(_pool) == true, '!POOL'); // Pool must be valid
        address _member = msg.sender; // Get user's address
        TransferHelper.safeTransferFrom(_pool, _member, _pool, units);
        if(token != address(0)){
            Pool(_pool).removeForMember(_member, _member); // If not BNB; remove liquidity; tsf SPARTA and TOKEN (Pool -> User)
        } else {
            Pool(_pool).removeForMember(address(this), _member); // If BNB; remove liquidity; tsf SPARTA and WBNB (Pool -> Router)
            uint outputBase = iBEP20(BASE).balanceOf(address(this)); // Check the received SPARTA amount (Router)
            uint outputToken = iBEP20(WBNB).balanceOf(address(this)); // Check the received WBNB amount (Router)
            _handleTransferOut(token, outputToken, _member); // Unwrap to BNB & tsf (Router -> User)
            _handleTransferOut(BASE, outputBase, _member); // Tsf SPARTA (Router -> User)
        }
        _safetyTrigger(_pool); // Check pool ratio

    }

    function removeLiquidityExactAsym(uint units, bool toBase, address token) public {
        require(units > 0, '!VALID'); // Must be a valid amount
        iPOOLFACTORY _poolFactory = iPOOLFACTORY(_DAO().POOLFACTORY()); // Interface the PoolFactory
        address _pool = _poolFactory.getPool(token); // Get pool address
        require(_poolFactory.isPool(_pool) == true, '!POOL'); // Pool must be valid
        require(Pool(_pool).freeze() == false); 
        address _member = msg.sender; // Get user's address
        TransferHelper.safeTransferFrom(_pool, _member, _pool, units);
        Pool(_pool).removeForMember(address(this),_member); // Remove liquidity; tsf SPARTA and TOKEN (Wrapped) (Pool -> Router)
        address _token = token; // Get token address
        if(token == address(0)){_token = WBNB;} // Handle BNB -> WBNB
        uint fee;
        if(toBase){
            TransferHelper.safeTransfer(_token, _pool, iBEP20(_token).balanceOf(address(this)));
            (, fee) = Pool(_pool).swapTo(BASE, address(this)); // Swap TOKEN (Wrapped) to SPARTA (Pool -> Router)
             TransferHelper.safeTransfer(BASE, _member, iBEP20(BASE).balanceOf(address(this)));
        } else {
            TransferHelper.safeTransfer(BASE, _pool, iBEP20(BASE).balanceOf(address(this)));
            (, fee) = Pool(_pool).swapTo(_token, address(this)); // Swap SPARTA to TOKEN (Pool -> Router)
            _handleTransferOut(token, iBEP20(_token).balanceOf(address(this)), _member); // Tsf total TOKEN (Router -> User)
        } 
        _safetyTrigger(_pool); // Check pool ratios
        _getsDividend(_pool, fee); // Check for dividend & tsf (Reserve -> Pool)
    }
 
    //============================== Swapping Functions ====================================//
    
    // Swap SPARTA for TOKEN
    function buyTo(uint amount, address token, address member, uint minAmount) public {
        iPOOLFACTORY _poolFactory = iPOOLFACTORY(_DAO().POOLFACTORY()); // Interface the PoolFactory
        address _pool = _poolFactory.getPool(token); // Get the pool address
        require(_poolFactory.isPool(_pool) == true, '!POOL'); // Pool must be valid
        _handleTransferIn(BASE, amount, _pool); // Tsf SPARTA (User -> Pool)
        uint fee;
        if(token != address(0)){
            (uint output, uint feey) = Pool(_pool).swapTo(token, member); // If not BNB; swap SPARTA to TOKEN (Pool -> User)
            require(output >= minAmount, '!RATE'); // Revert if output is too low
            fee = feey;
        } else {
            (uint output, uint feez) = Pool(_pool).swapTo(WBNB, address(this)); // If BNB; Swap SPARTA to WBNB (Pool -> Router)
            require(output >= minAmount, '!RATE'); // Revert if output is too low
            _handleTransferOut(token, output, member); // Unwrap to BNB & tsf (Router -> User)
            fee = feez;
        }
        _safetyTrigger(_pool); // Check pool ratios
        _getsDividend(_pool, fee); // Check for dividend & tsf (Reserve -> Pool)
    }

    // Swap TOKEN for SPARTA
    function sellTo(uint amount, address token, address member, uint minAmount, bool yesDiv) public payable returns (uint){
        iPOOLFACTORY _poolFactory = iPOOLFACTORY(_DAO().POOLFACTORY()); // Interface the PoolFactory
        address _pool = _poolFactory.getPool(token); // Get pool address
        require(_poolFactory.isPool(_pool) == true, '!POOL'); // Pool must be valid
        _handleTransferIn(token, amount, _pool); // Tsf TOKEN (Not wrapped) (User -> Pool)
        (uint output, uint fee) = Pool(_pool).swapTo(BASE, member); // Swap TOKEN to SPARTA (Pool -> User)
        require(output >= minAmount, '!RATE'); // Revert if output is too low
        _safetyTrigger(_pool); // Check pool ratios
        if(yesDiv){
             _getsDividend(_pool, fee); // Check for dividend & tsf (Reserve -> Pool)
        }
        return fee;
    }

    // User performs a simple swap (to -> from)
    function swap(uint256 inputAmount, address fromToken, address toToken, uint256 minAmount) external payable{
        swapTo(inputAmount, fromToken, toToken, msg.sender, minAmount);
    }

    // Contract checks which swap function the user will require
    function swapTo(uint256 inputAmount, address fromToken, address toToken, address member, uint256 minAmount) public payable{
        require(fromToken != toToken); // Tokens must not be the same
        if(fromToken == BASE){
            buyTo(inputAmount, toToken, member, minAmount); // Swap SPARTA to TOKEN (User -> Pool -> User)
        } else if(toToken == BASE) {
            sellTo(inputAmount, fromToken, member, minAmount, true); // Swap TOKEN to SPARTA (User -> Pool -> User)
        } else {
            iPOOLFACTORY _poolFactory = iPOOLFACTORY(_DAO().POOLFACTORY()); // Interface the PoolFactory
            address _poolTo = _poolFactory.getPool(toToken); // Get pool address
            require(_poolFactory.isPool(_poolTo) == true, '!POOL'); // Pool must be valid
            sellTo(inputAmount, fromToken, _poolTo, 0, false); // Swap TOKEN (Not wrapped) to SPARTA (User -> fromPool -> toPool)
            address _toToken = toToken;
            if(toToken == address(0)){_toToken = WBNB;} // Handle BNB -> WBNB
            (uint _zz, uint _feez) = Pool(_poolTo).swapTo(_toToken, address(this)); // Swap SPARTA to TOKEN (Wrapped) (toPool -> Router)
            require(_zz >= minAmount, '!RATE'); // Revert if output is too low
            _safetyTrigger(_poolTo); // Check pool ratios
            _handleTransferOut(toToken, iBEP20(_toToken).balanceOf(address(this)), member); // Tsf TOKEN (Unwrapped) (Router -> User)
            _getsDividend(_poolTo, _feez); // Check for dividend & tsf (Reserve -> Pool)
        }
    }

    //================================ Swap Synths ========================================//
    
    // Swap TOKEN to Synth
    function swapAssetToSynth(uint inputAmount, address fromToken, address toSynth) external payable {
        require(inputAmount > 0, '!VALID'); // Must be a valid amount
        require(fromToken != toSynth); // Tokens must not be the same
        require(iRESERVE(_DAO().RESERVE()).globalFreeze() != true, '!SAFE'); // Must not be a global freeze
        address _pool = iSYNTH(toSynth).POOL(); // Get underlying pool address
        require(iPOOLFACTORY(_DAO().POOLFACTORY()).isPool(_pool) == true, '!POOL'); // Pool must be valid
        if(fromToken != BASE){
            sellTo(inputAmount, fromToken, address(this), 0, false); // Swap TOKEN to SPARTA (User -> Pool -> Router)
           TransferHelper.safeTransfer(BASE, _pool, iBEP20(BASE).balanceOf(address(this)));
        } else {
             TransferHelper.safeTransferFrom(BASE, msg.sender, _pool, inputAmount);
        }
        (, uint fee) = Pool(_pool).mintSynth(msg.sender); // Swap SPARTA for SYNTH (Pool -> User)
        _safetyTrigger(_pool); // Check pool ratios
        _getsDividend(_pool, fee); // Check for dividend & tsf (Reserve -> Pool)
        require(iRESERVE(_DAO().RESERVE()).globalFreeze() != true, '!SAFE'); // Must not be a global freeze
    }
   
    // Swap Synth to TOKEN
    function swapSynthToAsset(uint inputAmount, address fromSynth, address toToken) external {
        require(inputAmount > 0, '!VALID'); // Must be a valid amount
        require(fromSynth != toToken); // Tokens must not be the same
        require(iRESERVE(_DAO().RESERVE()).globalFreeze() != true, '!SAFE'); // Must not be a global freeze
        iPOOLFACTORY _poolFactory = iPOOLFACTORY(_DAO().POOLFACTORY()); // Interface the PoolFactory
        address _synthPool = iSYNTH(fromSynth).POOL(); // Get underlying synthPool address
        require(_poolFactory.isPool(_synthPool) == true, '!POOL'); // synthPool must be valid
        TransferHelper.safeTransferFrom(fromSynth, msg.sender, _synthPool, inputAmount);
        uint synthFee;
        if(toToken == BASE){
            (, synthFee) = Pool(_synthPool).burnSynth(msg.sender, msg.sender); // Swap SYNTH to SPARTA (synthPool -> User)
        } else {
             address _swapPool = _poolFactory.getPool(toToken); // Get TOKEN's relevant swapPool address
               require(_poolFactory.isPool(_swapPool) == true, '!POOL'); // swapPool must be valid
               uint swapFee;
               uint outputAmountY;
            (, synthFee) = Pool(_synthPool).burnSynth(address(this), msg.sender); // Swap SYNTH to SPARTA (synthPool -> Router)
                _handleTransferOut(BASE, iBEP20(BASE).balanceOf(address(this)), _swapPool); // Tsf SPARTA (Router -> swapPool)
            if(toToken != address(0)){
                (, swapFee) = Pool(_swapPool).swapTo(toToken, msg.sender); // Swap SPARTA to TOKEN (swapPool -> User)
            } else {
                (outputAmountY, swapFee) = Pool(_swapPool).swapTo(WBNB, address(this)); // Swap SPARTA to WBNB (swapPool -> Router)
                _handleTransferOut(toToken, outputAmountY, msg.sender); // Tsf BNB (Unwrapped) (Router -> User)
            }
            _safetyTrigger(_swapPool); // Check swapPool ratios
            _getsDividend(_swapPool, swapFee); // Check for dividend & tsf (Reserve -> swapPool)
        }
        _safetyTrigger(_synthPool); // Check synthPool ratios
        _getsDividend(_synthPool, synthFee); // Check for dividend & tsf (Reserve -> synthPool)
        require(iRESERVE(_DAO().RESERVE()).globalFreeze() != true, '!SAFE'); // Must not be a global freeze
    }

    //============================== Token Transfer Functions ======================================//
    
    // Handle the transfer of assets from user (wrap BNB)
    function _handleTransferIn(address _token, uint256 _amount, address _pool) internal nonReentrant {
        require(_amount > 0, '!GAS'); // Amount must be valid
        if(_token == address(0)){
            require((_amount == msg.value)); // Amount must be == msg.value
            TransferHelper.safeTransferBNB(WBNB,  _amount);
            TransferHelper.safeTransfer(WBNB, _pool, _amount);
        } else {
            TransferHelper.safeTransferFrom(_token, msg.sender, _pool, _amount);
        }
    }

    // Handle the transfer of assets to user (Unwrap BNB)
    function _handleTransferOut(address _token, uint256 _amount, address _recipient) internal nonReentrant {
        if(_amount > 0) {
            if (_token == address(0)) {
                iWBNB(WBNB).withdraw(_amount); // Unwrap WBNB to BNB (Router -> Router)
                TransferHelper.safeTransferBNB( _recipient,  _amount);
            } else {
                TransferHelper.safeTransfer(_token, _recipient, _amount);
            }
        }
    }
    
    //============================= Token Dividends / Curated Pools =================================//

    // Check if fee should generate a dividend & send it to the pool
    function _getsDividend(address _pool, uint fee) internal {
        if(iPOOLFACTORY(_DAO().POOLFACTORY()).isCuratedPool(_pool) == true){
            if(fee < minDiv){
                fee = minDiv;
            }
            _addDividend(_pool, fee); // Check for dividend & tsf (Reserve -> Pool)
        }
    }

    // Calculate the Dividend and transfer it to the pool
    function _addDividend(address _pool, uint256 _fees) internal {
        uint reserve = iBEP20(BASE).balanceOf(_DAO().RESERVE()); // Get SPARTA balance in the RESERVE contract
        bool emissions = iRESERVE(_DAO().RESERVE()).emissions();
        if(reserve > 0 && emissions){
           uint256 _curatedPoolsCount = iPOOLFACTORY(_DAO().POOLFACTORY()).curatedPoolCount(); 
           if(_curatedPoolsCount != curatedPoolsCount){
               curatedPoolsCount = _curatedPoolsCount;
           }
            uint256 _dividendReward = (reserve * diviClaim) / _curatedPoolsCount / 10000; // Get the dividend share 
            if((mapAddress_30DayDividends[_pool] + _fees) < _dividendReward){
                _revenueDetails(_fees, _pool); // Add to revenue metrics
                iRESERVE(_DAO().RESERVE()).grantFunds(_fees, _pool); // Tsf SPARTA dividend (Reserve -> Pool)
                Pool(_pool).sync(); // Sync the pool balances to attribute the dividend to the existing LPers
                emit Dividend(_pool, _fees); 
            }
        }
    }

    function _revenueDetails(uint _fees, address _pool) internal {
        if(lastMonth == 0){
            lastMonth = block.timestamp;
        }
        if(block.timestamp <= lastMonth + 2592000){ // 30 days
            mapAddress_30DayDividends[_pool] = mapAddress_30DayDividends[_pool] + _fees;
        } else {
            lastMonth = block.timestamp;
            mapAddress_Past30DayPoolDividends[_pool] = mapAddress_30DayDividends[_pool];
            mapAddress_30DayDividends[_pool] = _fees;
        }
    }
    function _migrateRevenue(address oldRouter) external onlyDAO {
        lastMonth = iROUTER(oldRouter).lastMonth();  
        address [] memory pools = iPOOLFACTORY(_DAO().POOLFACTORY()).getPoolAssets(); 
        for(uint i = 0; i < pools.length; i++){
            mapAddress_30DayDividends[pools[i]] = iROUTER(oldRouter).mapAddress_30DayDividends(pools[i]);  
            mapAddress_Past30DayPoolDividends[pools[i]] = iROUTER(oldRouter).mapAddress_Past30DayPoolDividends(pools[i]);   
        }
    }
    
    //======================= Change Dividend Variables ===========================//

    function changeDiviClaim(uint _newDiviClaim, uint _newDivFee) external onlyDAO {
        require(_newDiviClaim > 0 && _newDiviClaim < 5000, '!VALID');
        require(_newDivFee < 1000, '!VALID');
        diviClaim = _newDiviClaim;
        minDiv = _newDivFee * 10**18;
    }

    function changeSynthCap(uint synthCap, address _pool) external onlyDAO {
        Pool(_pool).setSynthCap(synthCap);
    }

    function RTC(uint poolRTC, address _pool) external onlyDAO {
        Pool(_pool).RTC(poolRTC);
    }
    function flipSynthMinting() external onlyDAO {
        synthMinting = !synthMinting;
    }
    function syncPool(address _pool, uint256 amount) external onlyRESERVE {
        address _token = Pool(_pool).TOKEN();
        uint256 baseValue = iUTILS(_DAO().UTILS()).calcSpotValueInBase(_token, amount);
        _revenueDetails(baseValue, _pool);
        Pool(_pool).sync(); // Sync the pool balances to attribute reward to the LPers
    }

    function _safetyTrigger(address _pool) internal {
        if(iPOOLFACTORY(_DAO().POOLFACTORY()).isCuratedPool(_pool)){
            if(Pool(_pool).freeze()){
                iRESERVE(_DAO().RESERVE()).setGlobalFreeze(true);   
            } 
            if(iRESERVE(_DAO().RESERVE()).globalFreeze()){
                uint256 freezeTime = iRESERVE(_DAO().RESERVE()).freezeTime(); 
                if(block.timestamp > freezeTime + 3600){
                   iRESERVE(_DAO().RESERVE()).setGlobalFreeze(false);   
                }
              }
        }
    }


    function updatePoolStatus() external {
       if(iRESERVE(_DAO().RESERVE()).globalFreeze()){
        address [] memory _vaultAssets = iPOOLFACTORY(_DAO().POOLFACTORY()).getVaultAssets(); // Get list of vault enabled assets
        bool unfreeze = true;
        for(uint i = 0; i < _vaultAssets.length; i++){
            if(Pool(_vaultAssets[i]).freeze()){
               unfreeze = false;
            }
        }
        if(unfreeze){
           iRESERVE(_DAO().RESERVE()).setGlobalFreeze(false);
        }
    }
    }

}