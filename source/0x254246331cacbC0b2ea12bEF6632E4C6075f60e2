{"Address.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\n\nlibrary Address {\n\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256(\u0027\u0027)`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash \u0026\u0026 codehash != 0x0);\n    }\n\n    /**\n     * @dev Replacement for Solidity\u0027s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n\n}\n"},"IERC20.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\ninterface IERC20 {\n\n    function totalSupply() external view returns (uint256);\n    \n    function symbol() external view returns(string memory);\n    \n    function name() external view returns(string memory);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n    \n    /**\n     * @dev Returns the number of decimal places\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"},"IUniswapV2Router02.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    payable\n    returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n    external\n    payable\n    returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"},"IXUSD.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"./IERC20.sol\";\n\n/**\n * Exempt Surge Interface\n */\ninterface IXUSD is IERC20 {\n    function sell(uint256 amount) external;\n    function getUnderlyingAsset() external returns(address);\n    function stakeUnderlyingAsset(uint256 numTokens) external returns(bool);\n    function stakeUnderlyingAsset(address recipient, uint256 numTokens) external returns (bool);\n    function eraseHoldings(uint256 nHoldings) external;\n    function transferOwnership(address newOwner) external;\n    function volumeFor(address wallet) external view returns (uint256);\n}\n"},"ReentrantGuard.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nabstract contract ReentrancyGuard {\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private _status;\n    constructor () {\n        _status = _NOT_ENTERED;\n    }\n\n    modifier nonReentrant() {\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n        _status = _ENTERED;\n        _;\n        _status = _NOT_ENTERED;\n    }\n}\n"},"SafeMath.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"},"xUSD.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"./SafeMath.sol\";\nimport \"./Address.sol\";\nimport \"./ReentrantGuard.sol\";\nimport \"./IXUSD.sol\";\nimport \"./IUniswapV2Router02.sol\";\n\n/**\n * Contract: xUSD Token\n * Developed By: Markymark ( DeFi Mark / MoonMark )\n *\n * Token with a built in Automated Market Maker\n * Send BNB to contract and it will mint xUSD Tokens\n * Stake BUSD into contract and it will mint xUSD Tokens\n * Sell this token to redeem underlying BUSD Tokens\n * Price is calculated as a ratio between Total Supply and underlying asset quantity in Contract\n */\ncontract XUSD is ReentrancyGuard, IXUSD {\n    \n    using SafeMath for uint256;\n    using Address for address;\n\n    // token data\n    string constant _name = \"xUSD\";\n    string constant _symbol = \"XUSD\";\n    uint8 constant _decimals = 18;\n    uint256 constant precision = 10**18;\n    \n    // 10 xUSD Starting Supply\n    uint256 _totalSupply = 10 * 10**_decimals;\n    \n    // balances\n    mapping (address =\u003e uint256) _balances;\n    mapping (address =\u003e mapping (address =\u003e uint256)) _allowances;\n\n    // Fees\n    uint256 public constant mintFee        = 99250;   // 0.75% buy fee\n    uint256 public constant sellFee        = 99750;   // 0.25% sell fee \n    uint256 public constant transferFee    = 99750;   // 0.25% transfer fee\n    uint256 public constant feeDenominator = 10**5;\n    \n    // Underlying Asset\n    address public constant _token = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\n    \n    // fee exemption for staking / utility\n    mapping ( address =\u003e bool ) public isFeeExempt;\n    \n    // volume for each recipient\n    mapping ( address =\u003e uint256 ) _volumeFor;\n    \n    // PCS Router\n    IUniswapV2Router02 _router; \n    \n    // BNB -\u003e Token\n    address[] path;\n    \n    // token purchase slippage maximum \n    uint256 public _tokenSlippage = 995;\n    \n    // owner\n    address _owner;\n    \n    // Activates Token Trading\n    bool Token_Activated;\n    \n    // fund data \n    bool allowFunding;\n    address _fund;\n    uint256 _fundingFeeDenominator;\n\n    modifier onlyOwner() {\n        require(msg.sender == _owner, \u0027Only Owner Function\u0027);\n        _;\n    }\n\n    // initialize some stuff\n    constructor () {\n        \n        // router\n        _router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n        path = new address[](2);\n        path[0] = _router.WETH();\n        path[1] = _token;\n        \n        // Fund\n        _fund = 0x849827eFB61f67F7aCF25Ee92cf9a8BE1F6F0869;\n        _fundingFeeDenominator = 5;\n        \n        // fee exempt fund + owner + router for LP injection\n        isFeeExempt[msg.sender] = true;\n        isFeeExempt[0x10ED43C718714eb63d5aA57B78B54704E256024E] = true;\n        isFeeExempt[_fund] = true;\n        \n        // allocate one token to dead wallet to ensure total supply never reaches 0\n        address dead = 0x000000000000000000000000000000000000dEaD;\n        _balances[address(this)] = (_totalSupply - 1);\n        _balances[dead] = 1;\n        \n        // ownership\n        _owner = msg.sender;\n        \n        // emit allocations\n        emit Transfer(address(0), address(this), (_totalSupply - 1));\n        emit Transfer(address(0), dead, 1);\n    }\n\n    function totalSupply() external view override returns (uint256) { return _totalSupply; }\n    function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }\n    function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }\n    \n    function name() public pure override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public pure override returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return _decimals;\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n  \n    /** Transfer Function */\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\n        return _transferFrom(msg.sender, recipient, amount);\n    }\n\n    /** Transfer Function */\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\n        _allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount, \u0027Insufficient Allowance\u0027);\n        return _transferFrom(sender, recipient, amount);\n    }\n    \n    /** Internal Transfer */\n    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\n        // make standard checks\n        require(recipient != address(0) \u0026\u0026 sender != address(0), \"Transfer To Zero Address\");\n        require(amount \u003e 0, \"Transfer amount must be greater than zero\");\n        // track price change\n        uint256 oldPrice = _calculatePrice();\n        \n        // fee exempt\n        bool takeFee = !( isFeeExempt[sender] || isFeeExempt[recipient] );\n        \n        // amount to give recipient\n        uint256 tAmount = takeFee ? amount.mul(transferFee).div(feeDenominator) : amount;\n        \n        // tax taken from transfer\n        uint256 tax = amount.sub(tAmount);\n        \n        // subtract from sender\n        _balances[sender] = _balances[sender].sub(amount, \"Insufficient Balance\");\n        \n        if (allowFunding \u0026\u0026 sender != _fund \u0026\u0026 recipient != _fund \u0026\u0026 takeFee) {\n            \n            // allocate percentage to Funding\n            uint256 allocation = tax.div(_fundingFeeDenominator);\n            \n            if (allocation \u003e 0) {\n                _mint(_fund, allocation);\n            }\n        }\n        \n        // give reduced amount to receiver\n        _balances[recipient] = _balances[recipient].add(tAmount);\n        \n        // burn the tax\n        if (tax \u003e 0) {\n            _totalSupply = _totalSupply.sub(tax);\n            emit Transfer(sender, address(0), tax);\n        }\n        \n        // volume for\n        _volumeFor[sender] += amount;\n        _volumeFor[recipient] += tAmount;\n        \n        // Price difference\n        uint256 currentPrice = _calculatePrice();\n        // Require Current Price \u003e= Last Price\n        require(currentPrice \u003e= oldPrice, \u0027Price Must Rise For Transaction To Conclude\u0027);\n        // Transfer Event\n        emit Transfer(sender, recipient, tAmount);\n        // Emit The Price Change\n        emit PriceChange(oldPrice, currentPrice, _totalSupply);\n        return true;\n    }\n    \n    /** Stake Tokens and Deposits xUSD in Sender\u0027s Address, Must Have Prior Approval */\n    function stakeUnderlyingAsset(uint256 numTokens) external override nonReentrant returns (bool) {\n        return _stakeUnderlyingAsset(numTokens, msg.sender);\n    }\n    \n    /** Stake Underlying Asset Tokens and Deposits xUSD in Recipient\u0027s Address, Must Have Prior Approval */\n    function stakeUnderlyingAsset(address recipient, uint256 numTokens) external override nonReentrant returns (bool) {\n        return _stakeUnderlyingAsset(numTokens, recipient);\n    }\n    \n    /** Sells xUSD Tokens And Deposits Underlying Asset Tokens into Seller\u0027s Address */\n    function sell(uint256 tokenAmount) external override nonReentrant {\n        _sell(tokenAmount, msg.sender);\n    }\n    \n    /** Sells xUSD Tokens And Deposits Underlying Asset Tokens into Recipients\u0027s Address */\n    function sell(address recipient, uint256 tokenAmount) external nonReentrant {\n        _sell(tokenAmount, recipient);\n    }\n    \n    /** Sells All xUSD Tokens And Deposits Underlying Asset Tokens into Seller\u0027s Address */\n    function sellAll() external nonReentrant {\n        _sell(_balances[msg.sender], msg.sender);\n    }\n    \n    /** Sells Without Including Decimals */\n    function sellInWholeTokenAmounts(uint256 amount) external nonReentrant {\n        _sell(amount.mul(10**_decimals), msg.sender);\n    }\n    \n    /** Deletes xUSD Tokens Sent To Contract */\n    function takeOutGarbage() external nonReentrant {\n        _checkGarbageCollector();\n    }\n    \n    /** Allows A User To Erase Their Holdings From Supply */\n    function eraseHoldings(uint256 nHoldings) external override {\n        // get balance of caller\n        uint256 bal = _balances[msg.sender];\n        require(bal \u003e= nHoldings \u0026\u0026 bal \u003e 0, \u0027Zero Holdings\u0027);\n        // if zero erase full balance\n        uint256 burnAmount = nHoldings == 0 ? bal : nHoldings;\n        // Track Change In Price\n        uint256 oldPrice = _calculatePrice();\n        // burn tokens from sender + supply\n        _burn(msg.sender, burnAmount);\n        // Emit Price Difference\n        emit PriceChange(oldPrice, _calculatePrice(), _totalSupply);\n        // Emit Call\n        emit ErasedHoldings(msg.sender, burnAmount);\n    }\n    \n    \n    ///////////////////////////////////\n    //////  INTERNAL FUNCTIONS  ///////\n    ///////////////////////////////////\n    \n    /** Purchases xUSD Token and Deposits Them in Recipient\u0027s Address */\n    function _purchase(address recipient) private nonReentrant returns (bool) {\n        // make sure emergency mode is disabled\n        require(Token_Activated || _owner == msg.sender, \u0027Token Not Activated\u0027);\n        // calculate price change\n        uint256 oldPrice = _calculatePrice();\n        // previous amount of Tokens before we received any\n        uint256 prevTokenAmount = IERC20(_token).balanceOf(address(this));\n        // minimum output amount\n        uint256 minOut = _router.getAmountsOut(msg.value, path)[1].mul(_tokenSlippage).div(1000);\n        // buy Token with the BNB received\n        _router.swapExactETHForTokens{value: msg.value}(\n            minOut,\n            path,\n            address(this),\n            block.timestamp.add(30)\n        );\n        // balance of tokens after swap\n        uint256 currentTokenAmount = IERC20(_token).balanceOf(address(this));\n        // number of Tokens we have purchased\n        uint256 difference = currentTokenAmount.sub(prevTokenAmount);\n        // if this is the first purchase, use new amount\n        prevTokenAmount = prevTokenAmount == 0 ? currentTokenAmount : prevTokenAmount;\n        // differentiate purchase\n        emit TokenPurchased(difference, recipient);\n        // mint to recipient\n        return _handleMinting(recipient, difference, prevTokenAmount, oldPrice);\n    }\n    \n    /** Stake Tokens and Deposits xUSD in Sender\u0027s Address, Must Have Prior Approval */\n    function _stakeUnderlyingAsset(uint256 numTokens, address recipient) internal returns (bool) {\n        // make sure emergency mode is disabled\n        require(Token_Activated || _owner == msg.sender, \u0027Token Not Activated\u0027);\n        // users token balance\n        uint256 userTokenBalance = IERC20(_token).balanceOf(msg.sender);\n        // ensure user has enough to send\n        require(userTokenBalance \u003e 0 \u0026\u0026 numTokens \u003c= userTokenBalance, \u0027Insufficient Balance\u0027);\n        // calculate price change\n        uint256 oldPrice = _calculatePrice();\n        // previous amount of Tokens before any are received\n        uint256 prevTokenAmount = IERC20(_token).balanceOf(address(this));\n        // move asset into xUSD Token\n        bool success = IERC20(_token).transferFrom(msg.sender, address(this), numTokens);\n        // balance of tokens after transfer\n        uint256 currentTokenAmount = IERC20(_token).balanceOf(address(this));\n        // number of Tokens we have purchased\n        uint256 difference = currentTokenAmount.sub(prevTokenAmount);\n        // ensure nothing unexpected happened\n        require(difference \u003c= numTokens \u0026\u0026 difference \u003e 0, \u0027Failure on Token Evaluation\u0027);\n        // ensure a successful transfer\n        require(success, \u0027Failure On Token TransferFrom\u0027);\n        // if this is the first purchase, use new amount\n        prevTokenAmount = prevTokenAmount == 0 ? currentTokenAmount : prevTokenAmount;\n        // Emit Staked\n        emit TokenStaked(difference, recipient);\n        // Handle Minting\n        return _handleMinting(recipient, difference, prevTokenAmount, oldPrice);\n    }\n    \n    /** Sells xUSD Tokens And Deposits Underlying Asset Tokens into Recipients\u0027s Address */\n    function _sell(uint256 tokenAmount, address recipient) internal {\n        require(tokenAmount \u003e 0 \u0026\u0026 _balances[msg.sender] \u003e= tokenAmount);\n        // calculate price change\n        uint256 oldPrice = _calculatePrice();\n        // fee exempt\n        bool takeFee = !isFeeExempt[msg.sender];\n        \n        // tokens post fee to swap for underlying asset\n        uint256 tokensToSwap = takeFee ? tokenAmount.mul(sellFee).div(feeDenominator) : tokenAmount.sub(100, \u0027100 Asset Minimum For Fee Exemption\u0027);\n\n        // value of taxed tokens\n        uint256 amountUnderlyingAsset = (tokensToSwap.mul(oldPrice)).div(precision);\n        // require above zero value\n        require(amountUnderlyingAsset \u003e 0, \u0027Zero Assets To Redeem For Given Value\u0027);\n        \n        // burn from sender + supply \n        _burn(msg.sender, tokenAmount);\n        \n        uint256 allocation = 0;\n        if (allowFunding \u0026\u0026 msg.sender != _fund \u0026\u0026 takeFee) {\n            // tax taken\n            uint256 taxTaken = tokenAmount.sub(tokensToSwap);\n            // allocate percentage to Fund\n            allocation = taxTaken.div(_fundingFeeDenominator);\n            if (allocation \u003e 0) {\n                // mint to Fund\n                _mint(_fund, allocation);\n            }\n        }\n\n        // send Tokens to Seller\n        bool successful = IERC20(_token).transfer(recipient, amountUnderlyingAsset);\n        // ensure Tokens were delivered\n        require(successful, \u0027Underlying Asset Transfer Failure\u0027);\n        // get current price\n        uint256 newPrice = _calculatePrice();\n        // Require Current Price \u003e= Last Price\n        require(newPrice \u003e= oldPrice, \u0027Price Must Rise For Transaction To Conclude\u0027);\n        // Differentiate Sell\n        emit TokenSold(tokenAmount, amountUnderlyingAsset, recipient);\n        // Emit The Price Change\n        emit PriceChange(oldPrice, newPrice, _totalSupply);\n    }\n    \n    /** Handles Minting Logic To Create New Surge Tokens*/\n    function _handleMinting(address recipient, uint256 received, uint256 prevTokenAmount, uint256 oldPrice) private returns(bool) {\n\n        // fee exempt\n        bool takeFee = !isFeeExempt[msg.sender];\n        \n        // find the number of tokens we should mint to keep up with the current price\n        uint256 tokensToMintNoTax = _totalSupply.mul(received).div(prevTokenAmount);\n        \n        // apply fee to minted tokens to inflate price relative to total supply\n        uint256 tokensToMint = takeFee ? tokensToMintNoTax.mul(mintFee).div(feeDenominator) : tokensToMintNoTax.sub(100, \u0027100 Asset Minimum For Fee Exemption\u0027);\n\n        // revert if under 1\n        require(tokensToMint \u003e 0, \u0027Must Purchase At Least One xUSD\u0027);\n        \n        if (allowFunding \u0026\u0026 takeFee) {\n            // difference\n            uint256 taxTaken = tokensToMintNoTax.sub(tokensToMint);\n            // allocate tokens to go to the Fund\n            uint256 allocation = taxTaken.div(_fundingFeeDenominator);\n            // allocate if greater than zero\n            if (allocation \u003e 0) {\n                // mint to Fund\n                _mint(_fund, allocation);\n            }\n        }\n        \n        // mint to Buyer\n        _mint(recipient, tokensToMint);\n        // Calculate Price After Transaction\n        uint256 newPrice = _calculatePrice();\n        // Require Current Price \u003e= Last Price\n        require(newPrice \u003e= oldPrice, \u0027Price Must Rise For Transaction To Conclude\u0027);\n        // Emit The Price Change\n        emit PriceChange(oldPrice, newPrice, _totalSupply);\n        return true;\n    }\n    \n    /** Mints Tokens to the Receivers Address */\n    function _mint(address receiver, uint amount) private {\n        _balances[receiver] = _balances[receiver].add(amount);\n        _totalSupply = _totalSupply.add(amount);\n        _volumeFor[receiver] += amount;\n        emit Transfer(address(0), receiver, amount);\n    }\n    \n    /** Mints Tokens to the Receivers Address */\n    function _burn(address receiver, uint amount) private {\n        _balances[receiver] = _balances[receiver].sub(amount, \u0027Insufficient Balance\u0027);\n        _totalSupply = _totalSupply.sub(amount, \u0027Negative Supply\u0027);\n        _volumeFor[receiver] += amount;\n        emit Transfer(receiver, address(0), amount);\n    }\n\n    /** Make Sure there\u0027s no Native Tokens in contract */\n    function _checkGarbageCollector() internal {\n        uint256 bal = _balances[address(this)];\n        if (bal \u003e 10) {\n            // Track Change In Price\n            uint256 oldPrice = _calculatePrice();\n            // burn amount\n            _burn(address(this), bal);\n            // Emit Collection\n            emit GarbageCollected(bal);\n            // Emit Price Difference\n            emit PriceChange(oldPrice, _calculatePrice(), _totalSupply);\n        }\n    }\n    \n    \n    ///////////////////////////////////\n    //////    READ FUNCTIONS    ///////\n    ///////////////////////////////////\n    \n    \n    /** Price Of XUSD in BUSD With 18 Points Of Precision */\n    function calculatePrice() external view returns (uint256) {\n        return _calculatePrice();\n    }\n    \n    /** Precision Of $0.001 */\n    function price() external view returns (uint256) {\n        return _calculatePrice().mul(10**3).div(precision);\n    }\n    \n    /** Returns the Current Price of 1 Token */\n    function _calculatePrice() internal view returns (uint256) {\n        uint256 tokenBalance = IERC20(_token).balanceOf(address(this));\n        return (tokenBalance.mul(precision)).div(_totalSupply);\n    }\n\n    /** Returns the value of your holdings before the sell fee */\n    function getValueOfHoldings(address holder) public view returns(uint256) {\n        return _balances[holder].mul(_calculatePrice()).div(precision);\n    }\n\n    /** Returns the value of your holdings after the sell fee */\n    function getValueOfHoldingsAfterTax(address holder) external view returns(uint256) {\n        return getValueOfHoldings(holder).mul(sellFee).div(feeDenominator);\n    }\n\n    /** Returns The Address of the Underlying Asset */\n    function getUnderlyingAsset() external override pure returns(address) {\n        return _token;\n    }\n    \n    /** Volume in xUSD For A Particular Wallet */\n    function volumeFor(address wallet) external override view returns (uint256) {\n        return _volumeFor[wallet];\n    }\n    \n    ///////////////////////////////////\n    //////   OWNER FUNCTIONS    ///////\n    ///////////////////////////////////\n    \n    \n    /** Enables Trading For This Token, This Action Cannot be Undone */\n    function ActivateToken() external onlyOwner {\n        require(!Token_Activated, \u0027Already Activated Token\u0027);\n        Token_Activated = true;\n        allowFunding = true;\n        emit TokenActivated();\n    }\n    \n    /** Updates The Buy/Sell/Stake and Transfer Fee Allocated Toward Funding */\n    function updateFundingValues(bool _allowFunding, uint256 _denominator) external onlyOwner {\n        require(_denominator \u003e= 2, \u0027Fees Too High\u0027);\n        allowFunding = _allowFunding;\n        _fundingFeeDenominator = _denominator;\n        emit UpdatedFundingValues(_allowFunding, _denominator);\n    }\n    \n    /** Updates The Address Of The Fund Receiver */\n    function updateFundAddress(address newFund) external onlyOwner {\n        _fund = newFund;\n        emit UpdatedFundAddress(newFund);\n    }\n    \n    /** Excludes Contract From Fees */\n    function setFeeExemption(address Contract, bool exempt) external onlyOwner {\n        require(Contract != address(0));\n        isFeeExempt[Contract] = exempt;\n        emit SetFeeExemption(Contract, exempt);\n    }\n    \n    /** Updates The Threshold To Trigger The Garbage Collector */\n    function changeTokenSlippage(uint256 newSlippage) external onlyOwner {\n        require(newSlippage \u003c= 995, \u0027invalid slippage\u0027);\n        _tokenSlippage = newSlippage;\n        emit UpdateTokenSlippage(newSlippage);\n    }\n    \n    /** Transfers Ownership To Another User */\n    function transferOwnership(address newOwner) external override onlyOwner {\n        _owner = newOwner;\n        emit TransferOwnership(newOwner);\n    }\n    \n    /** Transfers Ownership To Zero Address */\n    function renounceOwnership() external onlyOwner {\n        _owner = address(0);\n        emit TransferOwnership(address(0));\n    }\n    \n    /** Mint Tokens to Buyer */\n    receive() external payable {\n        _checkGarbageCollector();\n        _purchase(msg.sender);\n    }\n    \n    \n    ///////////////////////////////////\n    //////        EVENTS        ///////\n    ///////////////////////////////////\n    \n    event UpdatedFundingValues(bool allowFunding, uint256 denominator);\n    event PriceChange(uint256 previousPrice, uint256 currentPrice, uint256 totalSupply);\n    event ErasedHoldings(address who, uint256 amountTokensErased);\n    event UpdatedFundAddress(address newFund);\n    event GarbageCollected(uint256 amountTokensErased);\n    event UpdateTokenSlippage(uint256 newSlippage);\n    event UpdatedAllowFunding(bool _allowFunding);\n    event TransferOwnership(address newOwner);\n    event TokenStaked(uint256 assetsReceived, address recipient);\n    event SetFeeExemption(address Contract, bool exempt);\n    event TokenActivated();\n    event TokenSold(uint256 amountxUSD, uint256 assetsRedeemed, address recipient);\n    event TokenPurchased(uint256 assetsReceived, address recipient);\n    \n}\n"}}