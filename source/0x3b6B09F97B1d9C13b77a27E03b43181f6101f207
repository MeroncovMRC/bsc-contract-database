// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

contract BabyDragon {
    string public name = "BabyDragon";
    string public symbol = "BabyDragon";
    uint256 public totalSupply = 10000000000 * 10**18; // 总发行量为 10000,000,000
    uint8 public decimals = 18;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    uint256 public taxPercentage = 5;
    uint256 public liquidityFee = 2;
    uint256 public marketingFee = 1;
    uint256 public burnFee = 2;

    address public liquidityWallet = 0x3897Ea2317F6868deff5cc72170939BFab4f815B;
    address public marketingWallet = 0xaB90f9C07fc984B70506361e4a562A07b9c8b76a;
    address public burnAddress = 0x000000000000000000000000000000000000dEaD;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        balanceOf[msg.sender] = totalSupply;
    }

    function _transfer(
        address from,
        address to,
        uint256 value
    ) internal {
        require(from != address(0), "Invalid sender address");
        require(to != address(0), "Invalid recipient address");
        require(value > 0, "Transfer amount must be greater than zero");
        require(balanceOf[from] >= value, "Insufficient balance");

        uint256 taxAmount = value * taxPercentage / 100;
        uint256 tokensToTransfer = value - taxAmount;

        // Transfer tokens
        balanceOf[from] -= value;
        balanceOf[to] += tokensToTransfer;

        // Calculate and distribute fees
        uint256 liquidityAmount = taxAmount * liquidityFee / taxPercentage;
        uint256 marketingAmount = taxAmount * marketingFee / taxPercentage;
        uint256 burnAmount = taxAmount - liquidityAmount - marketingAmount;

        balanceOf[liquidityWallet] += liquidityAmount;
        balanceOf[marketingWallet] += marketingAmount;
        totalSupply -= burnAmount;

        emit Transfer(from, to, tokensToTransfer);

        // Transfer fees
        emit Transfer(from, liquidityWallet, liquidityAmount);
        emit Transfer(from, marketingWallet, marketingAmount);
        emit Transfer(from, burnAddress, burnAmount);
    }

    function transfer(address to, uint256 value) public returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(
        address from,
        address to,
        uint256 value
    ) public returns (bool) {
        require(value <= balanceOf[from], "Insufficient balance");
        require(value <= allowance[from][msg.sender], "Insufficient allowance");

        allowance[from][msg.sender] -= value;
        _transfer(from, to, value);

        return true;
    }
}