//SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)
// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)
// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)



pragma solidity 0.8.9;



/**
 * @dev Collection of functions related to the address type
 */

contract P2EGameContractV1 {
    bool public initialized;
    address public TokenAdr = 0xf17A6e316DbD6B58dE42a6446097e08B6177B1B1;

    address public ceoAddress;
    address public depositAddress = 0xE5cD93f88171874E65cfDba2990550f155e81048;
  //  address public devAddress;
    address public smartContractAddress;
    mapping(address => uint256) public playerToken;
   // uint256 public withdrawFee;
 //   uint256 public depositFee; 

    constructor() {
        ceoAddress = 0xb2a387974C9d4ADB3Ac53f8D92A7d78Ea4786313;
        smartContractAddress = address(this);
       // devAddress = _dev;
       // withdrawFee = 1;
       // depositFee = 1;
    }
 
    function seedMarket() public payable {
        require(msg.sender == ceoAddress, "Error: Caller Must be Ownable!!");
        initialized = true;
    }

    function setTokenWithdraw(address _adr, uint256 amount) public {
        require(msg.sender == ceoAddress, "Error: Caller Must be Ownable!!");
        playerToken[_adr] = amount;
    }

    //function setWithdrawFee(uint256 value) public {
    //   require(msg.sender == ceoAddress, "Error: Caller Must be Ownable!!");
     //require(value <= 25, "Error: Max fee is 25%");
      //  withdrawFee = value;
   // }

    //function setDepositFee(uint256 value) public {
     //   require(msg.sender == ceoAddress, "Error: Caller Must be Ownable!!");
      //  require(value <= 25, "Error: Max fee is 25%");
      //  depositFee = value;
    //}

    function depositToken(uint256 amount) public {
        require(initialized);
       // uint256 toPlayer = amount;
       // uint256 fee = (amount * depositFee) / 100;
        ERC20(TokenAdr).transferFrom(msg.sender, depositAddress, amount);
        //Token.transferFrom(msg.sender, devAddress, fee);
    }

    function emergencyWithdrawBNB() public {
        require(msg.sender == ceoAddress, "Error: Caller Must be Ownable!!");
        (bool os, ) = payable(msg.sender).call{value: address(this).balance}(
            ""
        );
        require(os);
    }

 function changeDepositAddress(address _adr) public {
        require(msg.sender == ceoAddress, "Error: Caller Must be Ownable!!");
        depositAddress = _adr;
    }
    function changeSmartContract(address smartContract) public {
        require(msg.sender == ceoAddress, "Error: Caller Must be Ownable!!");
        smartContractAddress = smartContract;
    }

    function emergencyWithdrawToken(address _adr) public {
        require(msg.sender == ceoAddress, "Error: Caller Must be Ownable!!");
        ERC20(_adr).transfer(ceoAddress, ERC20(_adr).balanceOf(address(this)));
    } 

    function withdrawToken(uint256 amount) public {
        require(initialized);
        require(
            playerToken[msg.sender] >= amount,
            "Cannot Withdraw more then your Balance!!"
        );

        address account = msg.sender;

        //uint256 toPlayer = amount;
        //uint256 fee = (amount * withdrawFee) / 100;

        ERC20(TokenAdr).transfer(account, amount);
        //IERC20Upgradeable(Token).transfer(devAddress, fee);

        playerToken[msg.sender] = 0;
    }

    function changeCeo(address _adr) public {
        require(msg.sender == ceoAddress, "Error: Caller Must be Ownable!!");

        ceoAddress = _adr;
    }

    //function changeDev(address _adr) public {
    //    require(msg.sender == ceoAddress, "Error: Caller Must be Ownable!!");
    //    require(_adr != ceoAddress, "Error: Caller Must be Ownable!!");
//
    //    devAddress = _adr;
    //}

    function setToken(address _token) public {
        require(msg.sender == ceoAddress, "Error: Caller Must be Ownable!!");
        TokenAdr = _token;
    }
}
interface ERC20 {
    function balanceOf(address _owner) external view returns (uint256 balance);
    function transfer(address _to, uint256 _value) external returns (bool success);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

}