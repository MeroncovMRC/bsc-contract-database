{"IERC20.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\ninterface IERC20 {\n\n    function totalSupply() external view returns (uint256);\n    \n    function symbol() external view returns(string memory);\n    \n    function name() external view returns(string memory);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n    \n    /**\n     * @dev Returns the number of decimal places\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"},"LuxeStaking.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\nimport \"./IERC20.sol\";\nimport \"./Ownable.sol\";\nimport \"./SafeMath.sol\";\n\ninterface IRewardGiver {\n    function requestRewards() external;\n}\n\n/**\n    Staking Platform developed by dappd\n    visit luxemeta.app or dappd.net to learn more\n */\ncontract LuxeStaking is Ownable, IERC20 {\n\n    using SafeMath for uint256;\n\n    // Staking Token\n    IERC20 public immutable token;\n\n    // Staking Protocol Token Info\n    string private _name;\n    string private _symbol;\n    uint8 private immutable _decimals;\n\n    // Trackable User Info\n    struct UserInfo {\n        uint256 balance;\n        uint256 unlockBlock;\n        uint256 totalStaked;\n        uint256 totalWithdrawn;\n    }\n    // User -\u003e UserInfo\n    mapping ( address =\u003e UserInfo ) public userInfo;\n\n    // Unstake Early Fee\n    uint256 public leaveEarlyFee;\n\n    // Timer For Leave Early Fee\n    uint256 public leaveEarlyFeeTimer;\n\n    // total supply of MAXI\n    uint256 private _totalSupply;\n\n    // Swapper To Purchase Token From BNB\n    address public tokenSwapper;\n\n    // Reward Distribution Contract\n    IRewardGiver public rewardGiver;\n\n    // precision factor\n    uint256 private constant precision = 10**18;\n\n    // Reentrancy Guard\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private _status;\n    modifier nonReentrant() {\n        require(_status != _ENTERED, \"Reentrancy Guard call\");\n        _status = _ENTERED;\n        _;\n        _status = _NOT_ENTERED;\n    }\n\n    // Events\n    event Deposit(address depositor, uint256 amountToken);\n    event Withdraw(address withdrawer, uint256 amountToken);\n    event FeeTaken(uint256 fee);\n\n    constructor(\n        address token_, \n        string memory name_, \n        string memory symbol_,\n        address tokenSwapper_,\n        uint256 leaveEarlyFee_,\n        uint256 leaveEarlyFeeTimer_\n    ) {\n\n        require(token_ != address(0), \u0027Zero Address\u0027);\n        require(tokenSwapper_ != address(0), \u0027Zero Address\u0027);\n        require(leaveEarlyFee_ \u003c= 100, \u0027Fee Too High\u0027);\n        require(leaveEarlyFeeTimer_ \u003c= 10**7, \u0027Fee Timer Too Long\u0027);\n\n        // pair token data\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = IERC20(token_).decimals();\n\n        // staking data\n        leaveEarlyFee = leaveEarlyFee_;\n        leaveEarlyFeeTimer = leaveEarlyFeeTimer_;\n        tokenSwapper = tokenSwapper_;\n\n        // pair staking token\n        token = IERC20(token_);\n\n        // set reentrancy\n        _status = _NOT_ENTERED;\n        \n        // emit transfer so bscscan registers contract as token\n        emit Transfer(address(0), msg.sender, 0);\n    }\n\n    function name() external view override returns (string memory) {\n        return _name;\n    }\n    function symbol() external view override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() external view override returns (uint8) {\n        return _decimals;\n    }\n    function totalSupply() external view override returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    /** Shows The Value Of Users\u0027 Staked Token */\n    function balanceOf(address account) public view override returns (uint256) {\n        return ReflectionsFromContractBalance(userInfo[account].balance);\n    }\n\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\n        if (recipient == msg.sender) {\n            withdraw(amount);\n        }\n        return true;\n    }\n    function transferFrom(address, address recipient, uint256 amount) external override returns (bool) {\n        if (recipient == msg.sender) {\n            withdraw(amount);\n        }        \n        return true;\n    }\n\n    function setLeaveEarlyFee(uint256 newLeaveEarlyFee) external onlyOwner {\n        require(\n            newLeaveEarlyFee \u003c= 100,\n            \u0027Early Fee Too High\u0027\n        );\n        leaveEarlyFee = newLeaveEarlyFee;\n    }\n\n    function setLeaveEarlyFeeTimer(uint256 newLeaveEarlyFeeTimer) external onlyOwner {\n        require(\n            newLeaveEarlyFeeTimer \u003c= 10**7,\n            \u0027Fee Timer Too High\u0027\n        );\n        leaveEarlyFeeTimer = newLeaveEarlyFeeTimer;\n    }\n\n    function setTokenSwapper(address newTokenSwapper) external onlyOwner {\n        require(\n            newTokenSwapper != address(0),\n            \u0027Zero Address\u0027\n        );\n        tokenSwapper = newTokenSwapper;\n    }\n\n    function setRewardGiver(address newRewardGiver) external onlyOwner {\n        require(\n            newRewardGiver != address(0),\n            \u0027Zero Address\u0027\n        );\n        rewardGiver = IRewardGiver(newRewardGiver);\n    }\n\n    function withdrawBNB() external onlyOwner {\n        (bool s,) = payable(msg.sender).call{value: address(this).balance}(\"\");\n        require(s, \u0027Error On BNB Withdrawal\u0027);\n    }\n\n    function recoverForeignToken(IERC20 _token) external onlyOwner {\n        require(\n            address(_token) != address(token),\n            \u0027Cannot Withdraw Staking Tokens\u0027\n        );\n        require(\n            _token.transfer(msg.sender, _token.balanceOf(address(this))),\n            \u0027Error Withdrawing Foreign Token\u0027\n        );\n    }\n\n    function requestRewards() public {\n        if (address(rewardGiver) != address(0)) {\n            try rewardGiver.requestRewards() {} catch {}\n        }\n    }\n\n    /** Native Sent To Contract Will Buy And Stake Token\n        Standard Token Purchase Rates Still Apply\n     */\n    receive() external payable {\n        require(msg.value \u003e 0, \u0027Zero Value\u0027);\n\n        // Track Balance Before Deposit\n        uint previousBalance = token.balanceOf(address(this));\n\n        // first purchase\n        bool firstPurchase = _totalSupply == 0 || previousBalance == 0;\n\n        // request rewards\n        if (!firstPurchase) {\n            requestRewards();\n        }\n\n        // Purchase Staking Token\n        uint received = _buyToken(msg.value);\n\n        if (firstPurchase) {\n            _registerFirstPurchase(received);\n        } else {\n            _mintTo(msg.sender, received, previousBalance);\n        }\n    }\n\n    /**\n        Transfers in `amount` of Token From Sender\n        And Locks In Contract, Minting MAXI Tokens\n     */\n    function deposit(uint256 amount) external nonReentrant {\n\n        // Track Balance Before Deposit\n        uint previousBalance = token.balanceOf(address(this));\n\n        // first purchase\n        bool firstPurchase = _totalSupply == 0 || previousBalance == 0;\n\n        // request rewards\n        if (!firstPurchase) {\n            requestRewards();\n        }\n\n        // Transfer In Token\n        uint received = _transferIn(amount);\n\n        if (firstPurchase) {\n            _registerFirstPurchase(received);\n        } else {\n            _mintTo(msg.sender, received, previousBalance);\n        }        \n    }\n\n    /**\n        Redeems `amount` of Underlying Tokens, As Seen From BalanceOf()\n     */\n    function withdraw(uint256 amount) public nonReentrant returns (uint256) {\n\n        // Token Amount Into Contract Balance Amount\n        uint MAXI_Amount = amount == balanceOf(msg.sender) ? userInfo[msg.sender].balance : TokenToContractBalance(amount);\n\n        require(\n            userInfo[msg.sender].balance \u003e 0 \u0026\u0026\n            userInfo[msg.sender].balance \u003e= MAXI_Amount \u0026\u0026\n            balanceOf(msg.sender) \u003e= amount \u0026\u0026\n            amount \u003e 0 \u0026\u0026\n            MAXI_Amount \u003e 0,\n            \u0027Insufficient Funds\u0027\n        );\n\n        // burn MAXI Tokens From Sender\n        _burn(msg.sender, MAXI_Amount, amount);\n\n        // increment total withdrawn\n        userInfo[msg.sender].totalWithdrawn += amount;\n\n        // Take Fee If Withdrawn Before Timer\n        uint fee = remainingLockTime(msg.sender) == 0 ? 0 : _takeFee(amount.mul(leaveEarlyFee).div(1000));\n\n        // send amount less fee\n        uint256 sendAmount = amount.sub(fee);\n        uint256 balance = token.balanceOf(address(this));\n        if (sendAmount \u003e balance) {\n            sendAmount = balance;\n        }\n        \n        // transfer token to sender\n        require(\n            token.transfer(msg.sender, sendAmount),\n            \u0027Error On Token Transfer\u0027\n        );\n\n        // request rewards\n        requestRewards();\n\n        emit Withdraw(msg.sender, sendAmount);\n        return sendAmount;\n    }\n\n    function donate() external payable nonReentrant {\n        // request rewards\n        requestRewards();\n        // buy staking token\n        _buyToken(address(this).balance);\n    }\n\n    /**\n        Registers the First Stake\n     */\n    function _registerFirstPurchase(uint received) internal {\n        \n        // increment total staked\n        userInfo[msg.sender].totalStaked += received;\n\n        // mint MAXI Tokens To Sender\n        _mint(msg.sender, received, received);\n\n        emit Deposit(msg.sender, received);\n    }\n\n\n    function _takeFee(uint256 fee) internal returns (uint256) {\n        emit FeeTaken(fee);\n        return fee;\n    }\n\n    function _mintTo(address sender, uint256 received, uint256 previousBalance) internal {\n        // Number Of Maxi Tokens To Mint\n        uint nToMint = (_totalSupply.mul(received).div(previousBalance)).sub(10);\n        require(\n            nToMint \u003e 0,\n            \u0027Zero To Mint\u0027\n        );\n\n        // increment total staked\n        userInfo[sender].totalStaked += received;\n\n        // mint MAXI Tokens To Sender\n        _mint(sender, nToMint, received);\n\n        emit Deposit(sender, received);\n    }\n\n    function _buyToken(uint amount) internal returns (uint256) {\n        require(\n            amount \u003e 0,\n            \u0027Zero Amount\u0027\n        );\n        uint before = token.balanceOf(address(this));\n        (bool s,) = payable(tokenSwapper).call{value: amount}(\"\");\n        require(s, \u0027Failure On Token Purchase\u0027);\n        uint received = token.balanceOf(address(this)).sub(before);\n        require(received \u003e 0, \u0027Zero Received\u0027);\n        return received;\n    }\n\n    function _transferIn(uint256 amount) internal returns (uint256) {\n        uint before = token.balanceOf(address(this));\n        require(\n            token.transferFrom(msg.sender, address(this), amount),\n            \u0027Failure On TransferFrom\u0027\n        );\n        uint received = token.balanceOf(address(this)).sub(before);\n        require(\n            received \u003c= amount \u0026\u0026 received \u003e 0,\n            \u0027Error On Transfer In\u0027\n        );\n        return received;\n    }\n\n    /**\n     * Burns `amount` of Contract Balance Token\n     */\n    function _burn(address from, uint256 amount, uint256 amountToken) private {\n        userInfo[from].balance = userInfo[from].balance.sub(amount);\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(from, address(0), amountToken);\n    }\n\n    /**\n     * Mints `amount` of Contract Balance Token\n     */\n    function _mint(address to, uint256 amount, uint256 stablesWorth) private {\n        // allocate\n        userInfo[to].balance = userInfo[to].balance.add(amount);\n        _totalSupply = _totalSupply.add(amount);\n        // update locker info\n        userInfo[msg.sender].unlockBlock = block.number + leaveEarlyFeeTimer;\n        emit Transfer(address(0), to, stablesWorth);\n    }\n\n\n    /**\n        Converts A Staking Token Amount Into A MAXI Amount\n     */\n    function TokenToContractBalance(uint256 amount) public view returns (uint256) {\n        return amount.mul(precision).div(_calculatePrice());\n    }\n\n    /**\n        Converts A MAXI Amount Into An Token Amount\n     */\n    function ReflectionsFromContractBalance(uint256 amount) public view returns (uint256) {\n        return amount.mul(_calculatePrice()).div(precision);\n    }\n\n    /** Conversion Ratio For MAXI -\u003e Token */\n    function calculatePrice() external view returns (uint256) {\n        return _calculatePrice();\n    }\n\n    /**\n        Lock Time Remaining For Stakers\n     */\n    function remainingLockTime(address user) public view returns (uint256) {\n        return userInfo[user].unlockBlock \u003c block.number ? 0 : userInfo[user].unlockBlock - block.number;\n    }\n\n    /** Returns Total Profit for User In Token From MAXI */\n    function getTotalProfits(address user) external view returns (uint256) {\n        uint top = balanceOf(user) + userInfo[user].totalWithdrawn;\n        return top \u003c= userInfo[user].totalStaked ? 0 : top - userInfo[user].totalStaked;\n    }\n    \n    /** Conversion Ratio For MAXI -\u003e Token */\n    function _calculatePrice() internal view returns (uint256) {\n        uint256 backingValue = token.balanceOf(address(this));\n        return (backingValue.mul(precision)).div(_totalSupply);\n    }\n\n    /** function has no use in contract */\n    function allowance(address, address) external pure override returns (uint256) { \n        return 0;\n    }\n    /** function has no use in contract */\n    function approve(address spender, uint256) public override returns (bool) {\n        emit Approval(msg.sender, spender, 0);\n        return true;\n    }\n}"},"Ownable.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.14;\n\n/**\n * @title Owner\n * @dev Set \u0026 change owner\n */\ncontract Ownable {\n\n    address private owner;\n    \n    // event for EVM logging\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\n    \n    // modifier to check if caller is owner\n    modifier onlyOwner() {\n        // If the first argument of \u0027require\u0027 evaluates to \u0027false\u0027, execution terminates and all\n        // changes to the state and to Ether balances are reverted.\n        // This used to consume all gas in old EVM versions, but not anymore.\n        // It is often a good idea to use \u0027require\u0027 to check if functions are called correctly.\n        // As a second argument, you can also provide an explanation about what went wrong.\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n    \n    /**\n     * @dev Set contract deployer as owner\n     */\n    constructor() {\n        owner = msg.sender; // \u0027msg.sender\u0027 is sender of current call, contract deployer for a constructor\n        emit OwnerSet(address(0), owner);\n    }\n\n    /**\n     * @dev Change owner\n     * @param newOwner address of new owner\n     */\n    function changeOwner(address newOwner) public onlyOwner {\n        emit OwnerSet(owner, newOwner);\n        owner = newOwner;\n    }\n\n    /**\n     * @dev Return owner address \n     * @return address of owner\n     */\n    function getOwner() external view returns (address) {\n        return owner;\n    }\n}"},"SafeMath.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"}}