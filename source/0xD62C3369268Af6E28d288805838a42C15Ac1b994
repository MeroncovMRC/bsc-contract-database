// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
// IERC20 For the Tokens
interface IERC20 {
    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(
        address owner,
        address spender
    ) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `from` to `to` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
}
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _setOwner(_msgSender());
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}
// ICO Contract 
contract MUSDICO is Ownable {

    IERC20 public MusdToken; // The address of the MUSD Token contract.

    address public sellerAddress; // The address of the contract owner.

    uint256 public presaleTokenAmount; // The total amount of tokens allocated for the pre-sale.

    bool public presaleActive = true; // Flag indicating whether the ICO is currently active.

    uint256 public maxTxAmount = 1000; // The maximum token amount that can be purchased in a single transaction.

    uint256 public maxWalletAmount = 1000000; // The maximum token amount that a single wallet can hold.

    uint256 public totalSold = 0; // The total amount of MUSD tokens that have been sold.

    uint256 public totalFund = 0 ether; // The total amount of funds raised in Ether.

    // address[] public acceptableTokens; // List of BEP-20 tokens accepted for purchase.
    struct acceptableTokens{
        uint256 id;
        address token;
        uint256 exPrice;
        uint256 soldAmount ;
        uint256 fundsAmount ;
    }
    mapping(uint256 => acceptableTokens) public acceptableToken; // Mapping of stage ID to Stage structure.
    struct Stage {
        uint256 id; // Unique ID of the ICO stage.
        uint256 price; // Token price for this stage.
        uint256 start; // Start timestamp of the stage.
        uint256 end; // End timestamp of the stage.
    } // Structure representing an ICO stage.

    mapping(uint256 => Stage) public stages; // Mapping of stage ID to Stage structure.

    uint256 public maxStage = 4; // The maximum number of stages in the ICO.

    uint256 public currentStageId = 0; // The ID of the currently active stage.
    uint256 public acceptableTokensLastId =0;
    uint256 public bnbExPrice = 0;

    /**
        * @dev Contract constructor to initialize MUSD token and seller address.
        * @param _MusdToken The address of the MUSD token contract.
        * @param _seller The address of the seller associated with this contract.
    */
    constructor(address _MusdToken, address _seller) {
        MusdToken = IERC20(_MusdToken);
        sellerAddress = _seller;
    }

    /**
        * @dev Update the MUSD token contract address.
        * @param _MusdToken The address of the new MUSD token contract.
        * @notice Only the contract owner can call this function.
        * @dev Requires that the new token address is not the zero address.
    */
    function updateToken(address _MusdToken) public onlyOwner {
        require(_MusdToken != address(0), "Token is zero address!");
        MusdToken = IERC20(_MusdToken);
    }

    /**
        * @dev Update the seller address.
        * @param _seller The new address to be set as the seller.
        * @notice Only the contract owner can call this function.
    */
    function setSellerAddress(address _seller) public onlyOwner {
        sellerAddress = _seller;
    }

    /**
        * @dev Set the pre-sale token amount based on the allowance from the seller's address.
        * @notice Only the contract owner can call this function.
    */
    function setPresaleTokenAmount() public onlyOwner {
        presaleTokenAmount = MusdToken.allowance(sellerAddress, address(this));
    }

    /**
        * @dev Set the maximum token amount that can be purchased in a single transaction.
        * @param _amount The new maximum transaction amount.
        * @notice Only the contract owner can call this function.
    */
    function setMaxTxAmount(uint256 _amount) public onlyOwner {
        maxTxAmount = _amount;
    }

    function setBnbExPrice(uint256 _price) public onlyOwner {
        bnbExPrice = _price;
    }

    /**
        * @dev Update the maximum token amount that a single wallet can hold.
        * @param _amount The new maximum wallet amount.
        * @notice Only the contract owner can call this function.
    */
    function setMaxWalletAmount(uint256 _amount) public onlyOwner {
        maxWalletAmount = _amount;
    }

    /**
        * @dev Toggle the pre-sale activation status.
        * @notice Only the contract owner can call this function.
    */
    function flipPresaleActive() public onlyOwner {
        presaleActive = !presaleActive;
    }

    /**
        * @dev Withdraw funds from the contract to the owner's address, if conditions are met.
        * @notice Only the contract owner can call this function.
        * @notice Soft cap must be reached, and balance must equal the hard cap for withdrawal.
        * @return A boolean indicating the success of the withdrawal.
    */
    function withdrawFunds() public onlyOwner returns (bool) {
        bool success = payable(msg.sender).send(address(this).balance);
        if (success) {
            totalFund = address(this).balance;
        }
        return success;
    }

//Start: Buy Tokens

    /**
        * @dev Purchase tokens from the presale using Ether.
        * @param _amount The desired amount of tokens to purchase.
        * @notice Requires that the presale is active and the user is within a valid stage.
        * @notice The user must provide enough Ether to cover the token purchase.
        * @notice Total tokens sold and wallet limits are enforced.
    */
    function buyToken(uint256 _amount) public payable {
        require(presaleActive, "Presale is not active!");
        require(_amount >= 0, "Please enter minimum token!");
        uint256 _id = getCurrentStageIdActive();
        require(_id > 0, "Stage info not available!");
        Stage memory currentStage = stages[_id];

        require(currentStage.start <= block.timestamp, "Presale has not started yet");
        require(currentStage.end >= block.timestamp, "Presale has ended");
    
        uint256 amountToBuy = _amount * currentStage.price; // Calculate the total cost in wei

        require(msg.value >= amountToBuy, "Not enough payment");

        uint256 _totalAmount = amountToBuy ;
        require(
            (totalSold + _totalAmount) <= presaleTokenAmount,
            "Presale token amount exceeds!"
        );
        require(
            _totalAmount <= (maxTxAmount * 1 ether),
            "Maximum transaction limit excceds!"
        );
        require(
            (_totalAmount + MusdToken.balanceOf(msg.sender)) <=
                (maxWalletAmount * 1 ether),
            "Maximum wallet token limit excceds!"
        );
        bool success = MusdToken.transferFrom(
            sellerAddress,
            msg.sender,
            _totalAmount
        );
        require(success, "Failed to transfer token!");
        totalSold += _totalAmount;
        totalFund += msg.value;
    }
    function buyTokensWithBNB(uint256 amount) external payable {
        IERC20 token = IERC20(MusdToken);
        uint256 _id = getCurrentStageIdActive();
        require(_id > 0, "Stage info not available!");
        Stage memory currentStage = stages[_id];

        require(currentStage.start <= block.timestamp, "Presale has not started yet");
        require(currentStage.end >= block.timestamp, "Presale has ended");
        uint256 tokenPrice = currentStage.price;
        uint256 amountToBuy = amount * tokenPrice;

        require(amountToBuy > 0, "Insufficient BNB sent");

        uint256 remainingTokens = token.balanceOf(address(this));
        require(
            remainingTokens >= amountToBuy,
            "Not enough tokens left for this phase"
        );

        totalSold += amountToBuy;
        token.transfer(msg.sender, amountToBuy);
       
    }
    function buyTokenWithBep20Tokens(uint256 _amount , address _paymentAddress) external {
        require(isTokenAcceptable(_paymentAddress),"Given Address Is Not An Acceptable Token ");
        require(presaleActive, "Presale is not active!");
        require(_amount >= 0, "Please enter minimum token!");
        uint256 _id = getCurrentStageIdActive();
        require(_id > 0, "Stage info not available!");
        uint256 _start = stages[_id].start;
        uint256 _end = stages[_id].end;
        require(_start <= block.timestamp, "Presale comming soon!");
        require(_end >= block.timestamp, "Presale end!");
        IERC20 paymentToken = IERC20(_paymentAddress);
       (, uint256 exPrice,,) = getAcceptableTokenDataByAddress(_paymentAddress);
        uint256 tpaterfpt = exPrice; // Token Price According to Exchange Rate For Payment Token 
        uint256 amountToReceive = _amount * tpaterfpt;
        uint256 _weiAmount = amountToReceive * 1 ether;
        uint256 _totalAmount = _weiAmount ;
        require(
            (totalSold + _totalAmount) <= presaleTokenAmount,
            "Presale token amount exceeds!"
        );
        require(
            _totalAmount <= (maxTxAmount * 1 ether),
            "Maximum transaction limit excceds!"
        );
        // Transfer USDT from buyer to contract
        require(
            paymentToken.transferFrom(msg.sender, address(this), _amount),
            "Transfer failed"
        );
        require(
            (_totalAmount + paymentToken.balanceOf(msg.sender)) <=
                (maxWalletAmount * 1 ether),
            "Maximum wallet token limit excceds!"
        );
        bool success = paymentToken.transferFrom(
            sellerAddress,
            msg.sender,
            _totalAmount
        );
        require(success, "Failed to transfer token!");
        totalSold += _totalAmount;
        totalFund += _amount;
    }


//END: Buy Tokens

//Start: Acceptable Tokens

    /**
        * @dev Check if a token is in the list of acceptable tokens for purchase.
        * @param token The address of the token to be checked.
        * @return A boolean indicating whether the token is acceptable or not.
        * @notice This function is read-only and does not modify contract state.
    */
    function isTokenAcceptable(address token) public view returns (bool) {
        for (uint256 i = 1; i <= acceptableTokensLastId; i++) {
            if (acceptableToken[i].token == token) {
                return true;
            }
        }
        return false;
    }

    /**
        * @dev Add a new BEP-20 token to the list of acceptable tokens for purchase.
        * @param token The address of the token to be added.
        * @notice Only the contract owner can call this function.
    */
    function addAcceptableToken(address token, uint256 exPrice) public onlyOwner {
        require(token != address(0), "Invalid token address");
        require(exPrice > 0, "Invalid exchange price");
        
        // Check for duplicate token addresses
        for (uint256 i = 1; i <= acceptableTokensLastId; i++) {
            require(acceptableToken[i].token != token, "Token already added");
        }
        
        uint256 _id = acceptableTokensLastId + 1;
        acceptableToken[_id].id = _id;
        acceptableToken[_id].token = token;
        acceptableToken[_id].exPrice = exPrice;
        acceptableToken[_id].soldAmount = 0;
        acceptableToken[_id].fundsAmount = 0;
        acceptableTokensLastId += 1;
    }

    /**
        * @dev Get the data of a specific BEP-20 token based on its token ID.
        * @param tokenId The ID of the token.
        * @return token The token address.
        * @return exPrice The exchange price of the token.
        * @return soldAmount The amount of tokens sold.
        * @return fundsAmount The amount of funds collected for the token.
        * @notice This function is read-only and retrieves data from the contract state.
    */
    function getAcceptableTokenData(uint256 tokenId) public view returns (address token, uint256 exPrice, uint256 soldAmount, uint256 fundsAmount) {
        require(tokenId <= acceptableTokensLastId, "Invalid token ID");
        
        token = acceptableToken[tokenId].token;
        exPrice = acceptableToken[tokenId].exPrice;
        soldAmount = acceptableToken[tokenId].soldAmount;
        fundsAmount = acceptableToken[tokenId].fundsAmount;
    }

    function getAcceptableTokenDataByAddress(address _token) public view returns (address token, uint256 exPrice, uint256 soldAmount, uint256 fundsAmount) {
        require(isTokenAcceptable(_token),"Given Address Is Not An Acceptable Token ");
        for (uint256 i = 1; i <= acceptableTokensLastId; i++) {
            if (acceptableToken[i].token == token) {
                token = acceptableToken[i].token;
                exPrice = acceptableToken[i].exPrice;
                soldAmount = acceptableToken[i].soldAmount;
                fundsAmount = acceptableToken[i].fundsAmount;
            }
        }
        
    }

    /**
        * @dev Remove a specified BEP-20 token from the list of acceptable tokens for purchase.
        * @param token The address of the token to be removed.
        * @notice Only the contract owner can call this function.
        * @notice The removed token is replaced by the last token in the list to maintain order.
        * @return A boolean indicating the success of the removal.
    */
    function removeToken(address token) public onlyOwner returns (bool) {
        for (uint256 i = 1; i <= acceptableTokensLastId; i++) {
            if (acceptableToken[i].token == token) {
                acceptableToken[i] = acceptableToken[acceptableTokensLastId];
                delete acceptableToken[acceptableTokensLastId];
                acceptableTokensLastId -= 1;
                return true;
            }
        }
        return false;
    }
    
    /**
     * @dev Update the list of acceptable tokens.
     * @param _tokens The new list of acceptable tokens.
     * @param _prices The new list of acceptable tokens prices.
     * @notice Only the contract owner can call this function.
     
     */
    function updateTokenPrices(address[] memory _tokens, uint256[] memory _prices) external onlyOwner {
        require(_tokens.length == _prices.length, "Arrays length mismatch");
        
        for (uint256 i = 0; i < _tokens.length; i++) {
            acceptableToken[i].exPrice = _prices[i];
        }
    }

//END: Acceptable Tokens


//Start: Stage Informations 

    /**
        * @dev Update the maximum number of stages in the ICO.
        * @param _maxStage The new maximum stage value.
        * @notice Only the contract owner can call this function.
    */
    function setMaxStage(uint256 _maxStage) public onlyOwner {
        maxStage = _maxStage;
    }

    /**
        * @dev Add a new stage to the ICO with a specified price and timeframe.
        * @param _price The token price for the stage.
        * @param _start The start timestamp of the stage.
        * @param _end The end timestamp of the stage.
        * @notice Only the contract owner can call this function.
        * @notice The maximum number of stages should not be exceeded.
        * @notice Start and end dates must be valid and in the correct order.
    */
    function addStage(
        uint256 _price,
        uint256 _start,
        uint256 _end
    ) public onlyOwner {
        uint256 _id = currentStageId + 1;
        require(_id <= maxStage, "Maximum stage exceeds limit");
        require(_start > 0 && _end > 0, "Invalid date");
        require(_start < _end, "End date should be greater than start");
        currentStageId += 1;
        stages[_id].id = _id;
        stages[_id].price = _price;
        stages[_id].start = _start;
        stages[_id].end = _end;
    }

    /**
        * @dev Update an existing ICO stage with new details.
        * @param _id The ID of the stage to be updated.
        * @param _price The new token price for the stage.
        * @param _start The new start timestamp of the stage.
        * @param _end The new end timestamp of the stage.
        * @notice Only the contract owner can call this function.
        * @notice The stage with the specified ID must exist.
        * @notice Start and end dates must be valid and in the correct order.
    */
    function setStage(
        uint256 _id,
        uint256 _price,
        uint256 _start,
        uint256 _end
    ) public onlyOwner {
        require(stages[_id].id == _id, "ID doesn't exist");
        require(_start > 0 && _end > 0, "Invalid date");
        require(_start < _end, "End date should be greater than start");
        stages[_id].price = _price;
        stages[_id].start = _start;
        stages[_id].end = _end;
    }

    /**
        * @dev Get the ID of the currently active ICO stage based on the current block timestamp.
        * @return The ID of the active stage. Returns 0 if no stage is currently active.
    */
    function getCurrentStageIdActive() public view returns (uint256) {
        uint256 _id = 0;

        if (currentStageId == 0) {
            _id = 0;
        } else {
            for (uint256 i = 1; i <= currentStageId; i++) {
                if (
                    (block.timestamp >= stages[i].start) &&
                    (block.timestamp <= stages[i].end)
                ) {
                    _id = i;
                }
            }
            if (_id == 0) {
                _id = currentStageId;
            }
        }

        return _id;
    }

//END: Stages Infomations






}