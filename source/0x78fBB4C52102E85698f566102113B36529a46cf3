{"2_Owner.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity \u003e=0.7.0 \u003c0.9.0;\n\n/**\n * @title Owner\n * @dev Set \u0026 change owner\n */\ncontract Owner {\n\n    address private owner;\n    \n    // event for EVM logging\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\n    \n    // modifier to check if caller is owner\n    modifier isOwner() {\n        // If the first argument of \u0027require\u0027 evaluates to \u0027false\u0027, execution terminates and all\n        // changes to the state and to Ether balances are reverted.\n        // This used to consume all gas in old EVM versions, but not anymore.\n        // It is often a good idea to use \u0027require\u0027 to check if functions are called correctly.\n        // As a second argument, you can also provide an explanation about what went wrong.\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n    \n    /**\n     * @dev Set contract deployer as owner\n     */\n    constructor() {\n        owner = msg.sender; // \u0027msg.sender\u0027 is sender of current call, contract deployer for a constructor\n        emit OwnerSet(address(0), owner);\n    }\n\n    /**\n     * @dev Change owner\n     * @param newOwner address of new owner\n     */\n    function changeOwner(address newOwner) public isOwner {\n        emit OwnerSet(owner, newOwner);\n        owner = newOwner;\n    }\n\n    /**\n     * @dev Return owner address \n     * @return address of owner\n     */\n    function getOwner() public view returns (address) {\n        return owner;\n    }\n}"},"ERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity \u003e=0.7.0 \u003c0.9.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n\n\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn\u0027t required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping (address =\u003e uint256) private _balances;\n\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The defaut value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``\u0027s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance \u003e= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, _msgSender(), currentAllowance - amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance \u003e= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance \u003e= amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance \u003e= amount, \"ERC20: burn amount exceeds balance\");\n        _balances[account] = accountBalance - amount;\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\u0027s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\u0027s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}"},"ReentrancyGuard.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity \u003e=0.7.0 \u003c0.9.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\u0027s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\u0027s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\u0027s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}"},"Stake.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.8;\n\nimport \"./2_Owner.sol\";\nimport \"./ERC20.sol\";\nimport \"./ReentrancyGuard.sol\";\n\ninterface Params {\n    struct Type {\n        uint256 tier;\n        uint256 count;\n        uint256 generation;\n        bytes data;\n    }\n}\n\ninterface IERC1155 is Params {\n    function balanceOf(address account, uint256 id)\n        external\n        view\n        returns (uint256);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    function getTypeOf(uint256 _id) external view returns (Type memory);\n}\n\n/**\n * @dev Contract for Staking ERC-20 Tokens and pay interest on real time\n */\ncontract StakeContract is Owner, ReentrancyGuard, Params {\n    address[] public NFT_contracts;\n\n    address public feeWallet;\n    address public rewardWallet;\n\n    ERC20 public feeToken;\n    ERC20 public rewardToken;\n\n    uint256 private feeMul; // example: x5 = 500 // = 100 if both tokens are the same\n\n    // Annual Percentage Yield\n    uint8 private APY;\n\n    // minimum stake time in seconds\n    uint256 public constant minimumStakeTime_1 = 2592000; // 30 days in seconds\n    uint256 public constant minimumStakeTime_2 = 5184000; // 60 days in seconds\n    uint256 public constant minimumStakeTime_3 = 7776000; // 90 days in seconds\n\n    // properties used to get fee\n    uint256 private feePercentage = 2000; // 2000 = 20%\n    uint256 private constant amountDivToGetFee = 10**4;\n\n    // Vulc token price relative to 100 USD\n    uint256 private tokenPrice; // example for 0.1 USD/$VULC = 1000\n\n    // the Stake\n    struct Stake {\n        // opening timestamp\n        uint256 startDate;\n        // amount staked\n        uint256 amount;\n        // stake type (1 = character+weapon), (2 = land)\n        uint256 stakeType;\n        // mst = minimun stake time\n        uint256 mst;\n        uint256 characterId;\n        uint256 weaponId;\n        uint256 landId;\n        // is active or not\n        bool active;\n        address characterAddress;\n        address weaponAddress;\n        address landAddress;\n    }\n\n    // NFT characters price in USD\n    uint256 private constant CommonCharacterPrice = 40 * 10**18;\n    uint256 private constant rareCharacterPrice = 80 * 10**18;\n    uint256 private constant legendaryCharacterPrice = 400 * 10**18;\n    uint256 private constant mythicalCharacterPrice = 2000 * 10**18;\n\n    // NFT weapons price in USD\n    uint256 private constant CommonWeaponPrice = 20 * 10**18;\n    uint256 private constant rareWeaponPrice = 40 * 10**18;\n    uint256 private constant legendaryWeaponPrice = 200 * 10**18;\n    uint256 private constant mythicalWeaponPrice = 1000 * 10**18;\n\n    // NFT lands price in USD\n    uint256 private constant CommonLandPrice = 1000 * 10**18;\n    uint256 private constant rareLandPrice = 1400 * 10**18;\n    uint256 private constant legendaryLandPrice = 2000 * 10**18;\n    uint256 private constant mythicalLandPrice = 3000 * 10**18;\n\n    // stakes that the owner have\n    mapping(address =\u003e Stake[10]) public stakesOfOwner;\n\n    constructor(\n        uint8 _apy,\n        ERC20 _rewardToken,\n        ERC20 _feeToken,\n        uint256 _feeMul,\n        uint256 _tokenPrice\n    ) {\n        APY = _apy;\n        rewardToken = _rewardToken;\n        feeToken = _feeToken;\n        feeMul = _feeMul;\n        tokenPrice = _tokenPrice;\n\n        feeWallet = getOwner();\n        rewardWallet = getOwner();\n    }\n\n    function addNFTContracts(address[] memory _contracts) external isOwner {\n        for (uint256 i = 0; i \u003c _contracts.length; i++) {\n            NFT_contracts.push(_contracts[i]);\n        }\n    }\n\n    function modifyNFTContracts(uint256 index, address _contract)\n        external\n        isOwner\n    {\n        NFT_contracts[index] = _contract;\n    }\n\n    function checkContractAddress(address _contractAddress)\n        private\n        view\n        returns (bool)\n    {\n        bool checkedIn = false;\n        for (uint256 i = 0; i \u003c NFT_contracts.length; i++) {\n            if (\n                NFT_contracts[i] == _contractAddress \u0026\u0026\n                _contractAddress != address(0)\n            ) {\n                checkedIn = true;\n                break;\n            }\n        }\n        return checkedIn;\n    }\n\n    // owner can change the basic parameters of the contract\n    // interest will be recalculated in real time for all accounts if changed\n    function modifyAnnualInterestRatePercentage(uint8 _newVal)\n        external\n        isOwner\n    {\n        APY = _newVal;\n    }\n\n    function modifyFeePercentage(uint256 _newVal) external isOwner {\n        require(_newVal \u003c= 9000, \"the new value should range from 0 to 9000\");\n        feePercentage = _newVal;\n    }\n\n    function modifyFeeWallet(address _newVal) external isOwner {\n        feeWallet = _newVal;\n    }\n\n    function modifyRewardWallet(address _newVal) external isOwner {\n        rewardWallet = _newVal;\n    }\n\n    function modifyTokens(ERC20 _rewardToken, ERC20 _feeToken)\n        external\n        isOwner\n    {\n        rewardToken = _rewardToken;\n        feeToken = _feeToken;\n    }\n\n    function modifyFeeMul(uint256 _newVal) external isOwner {\n        feeMul = _newVal;\n    }\n\n    function setTokenPrice(uint256 _price) external isOwner {\n        require(_price \u003e 0, \"price can\u0027t be 0\");\n        tokenPrice = _price;\n    }\n\n    function getMinimunStakeTime(uint256 _mstType)\n        private\n        pure\n        returns (uint256)\n    {\n        require(_mstType \u003e= 1 \u0026\u0026 _mstType \u003c= 3, \"invalid _mstType\");\n        uint256 mst;\n        if (_mstType == 1) {\n            mst = minimumStakeTime_1;\n        } else if (_mstType == 2) {\n            mst = minimumStakeTime_2;\n        } else if (_mstType == 3) {\n            mst = minimumStakeTime_3;\n        }\n        return mst;\n    }\n\n    function getMstType(uint256 _mst) private pure returns (uint256) {\n        uint256 mstType = 1;\n        if (_mst \u003e= minimumStakeTime_2) {\n            mstType = 2;\n        }\n        if (_mst \u003e= minimumStakeTime_3) {\n            mstType = 3;\n        }\n        return mstType;\n    }\n\n    function calculateInterest(uint256 _stakeAmount, uint256 _mstType)\n        private\n        view\n        returns (uint256)\n    {\n        uint256 mst = getMinimunStakeTime(_mstType);\n\n        // APY per year = amount * APY / 100 / seconds of the year\n        uint256 interest_per_year = (_stakeAmount * APY) / 100;\n\n        // number of seconds since opening date\n        // uint256 num_seconds = block.timestamp - stakesOfOwner[_ownerAccount][i].startDate;\n        uint256 num_seconds = mst;\n\n        // calculate interest by a rule of three\n        //  seconds of the year: 31536000 = 365*24*60*60\n        //  interest_per_year   -   31536000\n        //  interest            -   num_seconds\n        //  interest = num_seconds * interest_per_year / 31536000\n        return (num_seconds * interest_per_year) / 31536000;\n    }\n\n    function getIndexToCreateStake(address _account)\n        private\n        view\n        returns (uint256)\n    {\n        uint256 index = 10;\n        for (uint256 i = 0; i \u003c stakesOfOwner[_account].length; i++) {\n            if (!stakesOfOwner[_account][i].active) {\n                index = i;\n            }\n        }\n        // if (index \u003c 10)  = limit not reached\n        // if (index == 10) = limit reached\n        return index;\n    }\n\n    function getNFTPrice(\n        uint256 _type_nft,\n        uint256 _tokenId,\n        address _contractAddress\n    ) private view returns (uint256) {\n        require(_type_nft \u003e= 1 \u0026\u0026 _type_nft \u003c= 3, \"invalid _type_nft\");\n        Type memory t = IERC1155(_contractAddress).getTypeOf(_tokenId);\n        uint256 price = 0;\n        if (_type_nft == 1) {\n            if (t.tier == 1) {\n                price = CommonCharacterPrice;\n            } else if (t.tier == 2) {\n                price = rareCharacterPrice;\n            } else if (t.tier == 3) {\n                price = legendaryCharacterPrice;\n            } else if (t.tier == 4) {\n                price = mythicalCharacterPrice;\n            }\n        } else if (_type_nft == 2) {\n            if (t.tier == 1) {\n                price = CommonWeaponPrice;\n            } else if (t.tier == 2) {\n                price = rareWeaponPrice;\n            } else if (t.tier == 3) {\n                price = legendaryWeaponPrice;\n            } else if (t.tier == 4) {\n                price = mythicalWeaponPrice;\n            }\n        } else if (_type_nft == 3) {\n            if (t.tier == 1) {\n                price = CommonLandPrice;\n            } else if (t.tier == 2) {\n                price = rareLandPrice;\n            } else if (t.tier == 3) {\n                price = legendaryLandPrice;\n            } else if (t.tier == 4) {\n                price = mythicalLandPrice;\n            }\n        }\n        return (price * tokenPrice) / 100;\n    }\n\n    function getMulFee(uint256 _amount) public view returns (uint256) {\n        return (_amount * feeMul) / (100);\n    }\n\n    function calculateFee(uint256 _amount, uint256 _mstType)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 interest = calculateInterest(_amount, _mstType);\n        return (interest * feePercentage) / amountDivToGetFee;\n    }\n\n    // anyone can create a stake\n    function createStake(\n        uint256 _stakeType,\n        uint256 _mstType,\n        uint256 _characterId,\n        uint256 _weaponId,\n        uint256 _landId,\n        address _characterAddress,\n        address _weaponAddress,\n        address _landAddress\n    ) external {\n        require(_stakeType \u003e= 1 \u0026\u0026 _stakeType \u003c= 2, \"invalid _stakeType\");\n        uint256 index = getIndexToCreateStake(msg.sender);\n        require(index \u003c 10, \"stakes limit reached\");\n        uint256 mst = getMinimunStakeTime(_mstType);\n        uint256 stakeAmount = 0;\n        // store the tokens of the user in the contract\n        // requires approve\n        if (_stakeType == 1) {\n            require(\n                checkContractAddress(_characterAddress),\n                \"_characterAddress not valid\"\n            );\n            require(\n                checkContractAddress(_weaponAddress),\n                \"_weaponAddress not valid\"\n            );\n            IERC1155(_characterAddress).safeTransferFrom(\n                msg.sender,\n                address(this),\n                _characterId,\n                1,\n                \"\"\n            );\n            IERC1155(_weaponAddress).safeTransferFrom(\n                msg.sender,\n                address(this),\n                _weaponId,\n                1,\n                \"\"\n            );\n            stakeAmount = getNFTPrice(1, _characterId, _characterAddress);\n            stakeAmount += getNFTPrice(2, _weaponId, _weaponAddress);\n        } else if (_stakeType == 2) {\n            require(\n                checkContractAddress(_landAddress),\n                \"_landAddress not valid\"\n            );\n            IERC1155(_landAddress).safeTransferFrom(\n                msg.sender,\n                address(this),\n                _landId,\n                1,\n                \"\"\n            );\n            stakeAmount = getNFTPrice(3, _landId, _landAddress);\n        }\n        uint256 fee = getMulFee(calculateFee(stakeAmount, _mstType));\n        feeToken.transferFrom(msg.sender, feeWallet, fee);\n\n        // create the stake\n        stakesOfOwner[msg.sender][index] = Stake(\n            block.timestamp,\n            stakeAmount,\n            _stakeType,\n            mst,\n            _characterId,\n            _weaponId,\n            _landId,\n            true,\n            _characterAddress,\n            _weaponAddress,\n            _landAddress\n        );\n    }\n\n    // finalize the stake and pay interest accordingly\n    // arrayIndex: is the id of the stake to be finalized\n    function withdrawStake(uint256 arrayIndex) external nonReentrant {\n        // Stake should exists and opened\n        require(\n            arrayIndex \u003c stakesOfOwner[msg.sender].length,\n            \"Stake does not exist\"\n        );\n        require(\n            stakesOfOwner[msg.sender][arrayIndex].active == true,\n            \"This stake is not active\"\n        );\n        require(\n            (block.timestamp -\n                stakesOfOwner[msg.sender][arrayIndex].startDate) \u003e=\n                stakesOfOwner[msg.sender][arrayIndex].mst,\n            \"the minimum stake time has not been completed yet\"\n        );\n\n        // get the interest\n        uint256 mstType = getMstType(stakesOfOwner[msg.sender][arrayIndex].mst);\n        uint256 interest = calculateInterest(\n            stakesOfOwner[msg.sender][arrayIndex].amount,\n            mstType\n        );\n\n        // transfer the interes from owner account, it has to have enough funds approved\n        rewardToken.transferFrom(rewardWallet, msg.sender, interest);\n\n        // transfer the NFTs from the contract itself\n        if (stakesOfOwner[msg.sender][arrayIndex].stakeType == 1) {\n            IERC1155(stakesOfOwner[msg.sender][arrayIndex].characterAddress)\n                .safeTransferFrom(\n                    address(this),\n                    msg.sender,\n                    stakesOfOwner[msg.sender][arrayIndex].characterId,\n                    1,\n                    \"\"\n                );\n            IERC1155(stakesOfOwner[msg.sender][arrayIndex].weaponAddress)\n                .safeTransferFrom(\n                    address(this),\n                    msg.sender,\n                    stakesOfOwner[msg.sender][arrayIndex].weaponId,\n                    1,\n                    \"\"\n                );\n        } else if (stakesOfOwner[msg.sender][arrayIndex].stakeType == 2) {\n            IERC1155(stakesOfOwner[msg.sender][arrayIndex].landAddress)\n                .safeTransferFrom(\n                    address(this),\n                    msg.sender,\n                    stakesOfOwner[msg.sender][arrayIndex].landId,\n                    1,\n                    \"\"\n                );\n        }\n\n        // stake closing\n        stakesOfOwner[msg.sender][arrayIndex].active = false;\n    }\n\n    function cancelStake(uint256 arrayIndex) external nonReentrant {\n        // Stake should exists and opened\n        require(\n            arrayIndex \u003c stakesOfOwner[msg.sender].length,\n            \"Stake does not exist\"\n        );\n        require(\n            stakesOfOwner[msg.sender][arrayIndex].active == true,\n            \"This stake is not active\"\n        );\n\n        // transfer the NFTs from the contract itself\n        if (stakesOfOwner[msg.sender][arrayIndex].stakeType == 1) {\n            IERC1155(stakesOfOwner[msg.sender][arrayIndex].characterAddress)\n                .safeTransferFrom(\n                    address(this),\n                    msg.sender,\n                    stakesOfOwner[msg.sender][arrayIndex].characterId,\n                    1,\n                    \"\"\n                );\n            IERC1155(stakesOfOwner[msg.sender][arrayIndex].weaponAddress)\n                .safeTransferFrom(\n                    address(this),\n                    msg.sender,\n                    stakesOfOwner[msg.sender][arrayIndex].weaponId,\n                    1,\n                    \"\"\n                );\n        } else if (stakesOfOwner[msg.sender][arrayIndex].stakeType == 2) {\n            IERC1155(stakesOfOwner[msg.sender][arrayIndex].landAddress)\n                .safeTransferFrom(\n                    address(this),\n                    msg.sender,\n                    stakesOfOwner[msg.sender][arrayIndex].landId,\n                    1,\n                    \"\"\n                );\n        }\n\n        // stake closing\n        stakesOfOwner[msg.sender][arrayIndex].active = false;\n    }\n}\n"}}