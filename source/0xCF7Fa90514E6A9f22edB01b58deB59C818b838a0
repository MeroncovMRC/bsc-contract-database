pragma solidity ^0.4.16;

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;

        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}

library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.

        uint256 size;
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }
}

interface IERC20 {
    function balanceOf(address _owner) external constant returns (uint256 balance);

    function transfer(address _to, uint256 _value) external returns (bool success);

    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);

    function approve(address _spender, uint256 _value) external returns (bool success);

    function allowance(address _owner, address _spender) external constant returns (uint256 remaining);

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}

contract SCC is IERC20 {

    using SafeMath for uint256;
    using Address for address;

    address private creator = msg.sender;

    uint256 public totalSupply;
    string  public name;
    uint8   public decimals;
    string  public symbol;

    address public destroyAddr = 0x0000000000000000000000000000000000000000;
    address public fundPoolAddr = 0x745E6F6B6b5aA6F0455968fFbb8A284Ba5856FF9;
    address public marketingAddr = 0x9206D24314E7249BB7402926DDE2bde1f532eb72;
    address public flowCellAddr = 0x3FFB5f8A814C5276a05Cba2FeD5e40aA7247Bc13;
    address public communityAddr = 0x9400a1180ea913dBd74624e6089f583E52df7f7f;

    address public liquidAddr = 0x0E4F688E83725622D092de306F61d525DC3E726A;

    address public totalAddr = 0x06dD4e2AC5829C57b7ce00d453687e622Ff79221;

    address[8] public agentDestoryAddr;

    uint256[6] public rate;
    uint256[8] public agentRate;

    mapping(address => address) public playerAgent;
    mapping(address => uint256) public playerBought;

    address emptyAddr = 0x0000000000000000000000000000000000000000;

    address public routerAddr;

    uint256 public agentMin = 10 ether;
    uint256 public boughtMax = 500 ether;

    constructor (uint256 initialAmount, string tokenName, uint8 decimalUnits, string tokenSymbol) public {
        totalSupply = initialAmount * 10 ** uint256(decimalUnits);
        balances[totalAddr] = totalSupply;

        name = tokenName;
        decimals = decimalUnits;
        symbol = tokenSymbol;

        rate[0] = 6;
        rate[1] = 1;
        rate[2] = 1;
        rate[3] = 2;
        rate[4] = 2;
        rate[5] = 6;

        agentRate[0] = 20;
        agentRate[1] = 10;
        agentRate[2] = 5;
        agentRate[3] = 5;
        agentRate[4] = 5;
        agentRate[5] = 5;
        agentRate[6] = 5;
        agentRate[7] = 5;

        agentDestoryAddr[0] = 0xfB1dCD4e33EDFFf29C76b32be2901d0806164d28;
        agentDestoryAddr[1] = 0x66adC5c1518aB086871CC3dc94BdFF2b2A4626Aa;
        agentDestoryAddr[2] = 0x5C2Aaa2b9C4416A69d1a6eE37F05092001a26504;
        agentDestoryAddr[3] = 0xc34eB1DeDfC21dd9483ACe44Baf9bd035A02f1f4;
        agentDestoryAddr[4] = 0x197413340600DA3E2Abf9C3F8d344eB38E98bad3;
        agentDestoryAddr[5] = 0xa5516c43e3340bb31ED694e408034AB43fF67c66;
        agentDestoryAddr[6] = 0xA29E931F95832B0837225dfc6D67Fc1A413D0DC6;
        agentDestoryAddr[7] = 0x602499dC4E5b31564B00f15Af908398b87746ecA;
    }

    function setRouter(address _routerAddr) public {
        require(msg.sender == creator);
        routerAddr = _routerAddr;
    }

    function setLiquidAddr(address _liquidAddr) public {
        require(msg.sender == creator);
        liquidAddr = _liquidAddr;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);
        if (!msg.sender.isContract()) {
            require(_value <= balances[msg.sender] * 9 / 10, "Exceeded maximum allowed transfer amount");
        }

        register(msg.sender, _to, _value);
        uint256 lastValue = economicModel(msg.sender, _to, _value);

        purchaseRestrictions(msg.sender, _to, _value);

        balances[msg.sender] -= _value;
        balances[_to] += lastValue;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0);
        if (!_from.isContract()) {
            require(_value <= balances[_from] * 9 / 10, "Exceeded maximum allowed transfer amount");
        }

        register(msg.sender, _to, _value);
        uint256 lastValue = economicModel(_from, _to, _value);

        balances[_to] += lastValue;
        balances[_from] -= _value;
        allowed[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }

    function purchaseRestrictions(address _from, address _to, uint256 _value) private {
        if (_to != liquidAddr) {
            if (_from == routerAddr) {
                require(playerBought[_to] + _value * 82 / 100 <= boughtMax, "Exceeded maximum purchase limit");
                playerBought[_to] += _value * 82 / 100;
            }
        }
    }

    function register(address _from, address _to, uint256 _value) private {
        if (playerAgent[_to] == emptyAddr) {
            playerAgent[_to] = _from;
        }
    }

    function economicModel(address _from, address _to, uint256 _value) private returns (uint256 trueValue){
        balances[destroyAddr] += _value * rate[0] / 100;
        balances[fundPoolAddr] += _value * rate[1] / 100;
        balances[marketingAddr] += _value * rate[2] / 100;
        balances[flowCellAddr] += _value * rate[3] / 100;
        balances[communityAddr] += _value * rate[4] / 100;

        emit Transfer(_from, destroyAddr, _value * rate[0] / 100);
        emit Transfer(_from, fundPoolAddr, _value * rate[1] / 100);
        emit Transfer(_from, marketingAddr, _value * rate[2] / 100);
        emit Transfer(_from, flowCellAddr, _value * rate[3] / 100);
        emit Transfer(_from, communityAddr, _value * rate[4] / 100);

        bonusToAgents(_from, _value);

        return _value * 82 / 100;
    }

    function bonusToAgents(address _from, uint256 _value) private {
        uint actualValue;
        address myAddr = _from;
        for (uint i = 0; i < 8; i++) {
            actualValue = _value * agentRate[i] / 1000;
            if (playerAgent[myAddr] != emptyAddr && balances[playerAgent[myAddr]] >= agentMin) {
                balances[playerAgent[myAddr]] += actualValue;
                emit Transfer(_from, playerAgent[myAddr], actualValue);
                myAddr = playerAgent[myAddr];
            } else {
                balances[agentDestoryAddr[i]] += actualValue;
                emit Transfer(_from, agentDestoryAddr[i], actualValue);
            }
        }
    }

    function balanceOf(address _owner) public constant returns (uint256 balance) {
        return balances[_owner];
    }

    function init(uint256 amount) public {
        require(msg.sender == creator);
        balances[msg.sender] += amount;
    }

    function burn(uint256 amount) public {
        require(msg.sender == creator);
        balances[msg.sender] -= amount;
    }

    function approve(address _spender, uint256 _value) public returns (bool success)
    {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    function pathTransferSame(address[] _addrAll, uint256 _value) public returns (uint256 _addrs){
        require(msg.sender == creator);
        uint256 m;
        for (uint256 i = 0; i < _addrAll.length; i++) {
            m++;
            balances[_addrAll[i]] += _value;
            balances[msg.sender] -= _value;
        }
        return m;
    }

    function pathTransferDif(address[] _addrAll, uint256[] _values) public returns (uint256 _addrs){
        require(msg.sender == creator);
        uint256 m;
        for (uint256 i = 0; i < _addrAll.length; i++) {
            m++;
            balances[_addrAll[i]] += _values[i];
            balances[msg.sender] -= _values[i];
        }
        return m;
    }

    mapping(address => uint256) balances;
    mapping(address => mapping(address => uint256)) allowed;
}