// SPDX-License-Identifier: Unlicensed

pragma solidity ^0.8.4;

contract Stakeable {
    using SafeMath for uint256;

    //xshare price helper
    uint256 immutable priceHelper = 10;

    //Numbers;
    uint256 PRECISION_RATE = 1E18;
    uint256 public constant DAY_IN_SECONDS = 86400; //Day in seconds

    //Inteface for ERC20 token - bitcoinSigma
    IERC20 public btcSigmacontract;

    //Sigma Halvings
    uint256 public currentHalving;

    //Sigma Day
    uint256 public immutable sigmaLaunchTime; //Launch time in timestamp
    uint256 public currentSigmaDay;


    uint256 public totalStaked;

    //xShare data
    uint256 public xsharePrice;
    uint256 public totalxshares;

    //BitcoinRewards
    uint256 public btcForDividends;

    constructor() {
        stakeholders.push(); //push the list of stake holders (allow staking)
        btcSigmacontract = IERC20(0x972EF3b4F3b6A8Ca06102854dFA911880deb56bC); //Set the Interface for btcSigma ERC20
        currentSigmaDay = 0; //Set the initial Sigma Day to 0. Called at launch
        xsharePrice = 20; //Set the initial xshare price of $20.00
        currentHalving = 0; //Set the initial Sigma Halving to 0
        btcForDividends = 1;
        sigmaLaunchTime = block.timestamp; // Save the deployment block timestamp
    }

    struct StakingInfo {
        uint256 inflationAmount;
        uint256 bitcoinAmount;
        uint256 sharesEnding;
    }

    mapping(uint256 => StakingInfo) public stinfo;

    struct StakingSummary {
        uint256 total_amount;
        Stake[] stakes;
    }

    struct Stake {
        address user;
        uint256 amount;
        string stakename;
        uint256 startDay;
        uint256 endDay;
        uint256 claimable;
        uint256 claimablebitcoin;
        uint256 btcsigmabonus;
        uint256 xShares;
    }

    struct Stakeholder {
        address user;
        Stake[] address_stakes;
    }

    Stakeholder[] internal stakeholders;

    mapping(address => uint256) internal stakes;

    event Staked(
        address indexed user,
        uint256 amount,
        string stakename,
        uint256 startDay,
        uint256 endDay,
        uint256 index,
        uint256 btcsigmabonus,
        uint256 xShares
    );

    function getDayInfo(uint256 _day) public view returns(uint256 day, uint256 sigmarewards, uint256 bitcoinrewards, uint256 expiredShares) {
        StakingInfo storage info = stinfo[_day];
        return (_day, info.inflationAmount, info.bitcoinAmount, info.sharesEnding);
    }

    function getTotalStaked() public view returns (uint256) {
        return totalStaked;
    }

    function getCurrDay() public view returns (uint256) {
        return currentSigmaDay;
    }

    function getCurrentHalving() public view returns (uint256) {
        return currentHalving;
    }

    function getxSharePrice() public view returns (uint256) {
        return xsharePrice;
    }

    function incrementSigmaDay() public {
        require(block.timestamp > (currentSigmaDay + 1) * DAY_IN_SECONDS + sigmaLaunchTime, "24 hours have not passed yet.");
        uint256 _day = currentSigmaDay + 1;
        xsharePrice += 1;
        _calculateInflationAmount(_day);
        _incrementHalving();
    }

    function _addStakeholder(address staker) internal returns (uint256) {
        stakeholders.push();
        uint256 userIndex = stakeholders.length - 1;
        stakeholders[userIndex].user = staker;
        stakes[staker] = userIndex;
        return userIndex;
    }

    function _assignNewBitcoinDividends(uint256 _bitcoinDividends) internal {
        btcForDividends += _bitcoinDividends;
    }

    function _calculateInflationAmount(uint256 _newday) private {
        for (uint256 _day = currentSigmaDay; _day < _newday; _day++) {
            StakingInfo memory stakeinfo = stinfo[_day];
            uint256 totalsigmastaked = getTotalStaked();
            uint256 totalcirculating = IERC20(address(this)).totalSupply();
            uint256 _bitcoinAmount = btcForDividends;
            uint256 sharesToExpire = stinfo[_day].sharesEnding;
            totalxshares = totalxshares > sharesToExpire ? totalxshares - sharesToExpire : 0;
            stakeinfo.inflationAmount = totalxshares.mul(PRECISION_RATE).div(_inflationAmount(totalsigmastaked, totalcirculating));
            stakeinfo.bitcoinAmount = totalxshares.mul(PRECISION_RATE).div(_bitcoinAmount);
            stinfo[_day] = stakeinfo;
            currentSigmaDay ++;
            btcForDividends = 1;
        }
    }

    function _allocateFutureExpiringShares(uint256 _day, uint256 _amount) private {
        stinfo[_day].sharesEnding = stinfo[_day].sharesEnding.add(_amount);
    }

    function _removeFutureExpiringShares(uint256 _day, uint256 _amount) private {
        if (_day >= currentSigmaDay) {
            stinfo[_day].sharesEnding = stinfo[_day].sharesEnding > _amount ? stinfo[_day].sharesEnding.sub(_amount) : 0;
        }
    }

    function _incrementHalving() private {
        if (currentSigmaDay < 10) {
            currentHalving = 0;
        }
        else if (currentSigmaDay >= 10 && currentSigmaDay < 20)
        {
            currentHalving = 1;
        }
        else if (currentSigmaDay >= 20 && currentSigmaDay < 30)
        {
            currentHalving = 2;
        }
        else if (currentSigmaDay >= 30 && currentSigmaDay < 40)
        {
            currentHalving = 3;
        }
        else if (currentSigmaDay >= 40 && currentSigmaDay < 50)
        {
            currentHalving = 4;
        }
        else if (currentSigmaDay >= 50 && currentSigmaDay < 416)
        {
            currentHalving = 5;
        }
        else if (currentSigmaDay >= 416 && currentSigmaDay < 782)
        {
            currentHalving = 6;
        }
        else if (currentSigmaDay >= 782)
        {
            currentHalving = 7;
        }
    }

/**
    12.3% MORE TOKENS PER YEAR = 0.0003164874811 PER DAY
    0.0003164874811 = 3164874811 / 1E13
    8.2% MORE TOKENS PER YEAR = 0.0002186348248 PER DAY
    0.0002186348248 = 2186348248 / 1E13
    4.1% MORE TOKENS PER YEAR = 0.0001090161729 PER DAY
    0.0001090161729 = 1090161729 / 1E13
*/
    function _inflationAmount(uint256 _totalStaked, uint256 _totalCirculating) private view returns (uint256) {
        uint256 amountToBeMinted;
        uint256 initialMintAmount = PRECISION_RATE.mul(1000000);
        if (currentHalving <= 4) {
            amountToBeMinted = initialMintAmount.div(2**currentHalving);
        }
        if (currentHalving == 5)
        amountToBeMinted = (_totalStaked + _totalCirculating).mul(3164874811).div(1E13);
        else if (currentHalving == 6)
        amountToBeMinted = (_totalStaked + _totalCirculating).mul(2186348248).div(1E13);
        else if (currentHalving == 7)
        amountToBeMinted = (_totalStaked + _totalCirculating).mul(1090161729).div(1E13);

        return amountToBeMinted;
    }

    function _calculateDaysMultiplier(uint256 _days) private pure returns (uint256) {
        uint256 stakingdaysMultiplier;
        if (_days == 1460) {
            stakingdaysMultiplier = 50;
        } else if (_days == 730) {
            stakingdaysMultiplier = 30;
        } else if (_days == 360) {
            stakingdaysMultiplier = 20;
        } else if (_days == 180) {
            stakingdaysMultiplier = 15;
        } else if (_days == 90) {
            stakingdaysMultiplier = 12;
        } else if (_days == 30 || _days == 10) {
            stakingdaysMultiplier = 10;
        }
        return stakingdaysMultiplier;
    }

    function _calculatexSharesToReceive(uint256 _amount, uint256 _stakingdays, uint256 _btcsigmabonus) private view returns (uint256) {
        uint256 stakingdaysMultiplier = _calculateDaysMultiplier(_stakingdays);
        uint256 btcsigmabonusNow = _btcsigmabonus.add(10);
        uint256 xShares = _amount.mul(btcsigmabonusNow).mul(stakingdaysMultiplier).div(xsharePrice).div(10);
        return xShares;
    }

    function _stake(uint256 _amount, string memory _stakename, uint256 _stakingdays) internal {
        require(_amount > 0, "Cannot stake nothing");
        require(_stakingdays == 10 || _stakingdays == 30 || _stakingdays == 90 || _stakingdays == 180 || _stakingdays == 360 || _stakingdays == 730 || _stakingdays == 1460, "Staking period not valid.");
        uint256 index = stakes[msg.sender];
        uint256 btcSigmabalance = btcSigmacontract.balanceOf(msg.sender);
        uint256 btcsigmabonus;
        uint256 _startDate = currentSigmaDay;
        uint256 _endDate = _startDate + _stakingdays;
        if (index == 0) {
            index = _addStakeholder(msg.sender);
        }
        if (btcSigmabalance >= 20) {
            btcsigmabonus = 20;
        } else {
            btcsigmabonus = btcSigmabalance;
        }
        uint256 xShares = _calculatexSharesToReceive(_amount, _stakingdays, btcsigmabonus);
        stakeholders[index].address_stakes.push(
            Stake(msg.sender, _amount, _stakename, _startDate, _endDate, 0, 0, btcsigmabonus, xShares)
        );

        totalxshares += xShares;
        totalStaked += _amount;
        _allocateFutureExpiringShares(_endDate, xShares);
        emit Staked(msg.sender, _amount, _stakename, _startDate, _endDate, index, btcsigmabonus, xShares);
    }
    /**
     * @notice
     * calculateStakeReward is used to calculate how much a user should be rewarded for their stakes
     * and the duration the stake has been active
     */
    function calculateStakeReward(Stake memory _current_stake)
        internal
        view
        returns (uint256 _sigmaRewards)
    {
        // First calculate how long the stake has been active
        // Use current seconds since epoch - the seconds since epoch the stake was made
        // The output will be duration in SECONDS ,
        // We will reward the user 0.1% per Hour So thats 0.1% per 3600 seconds
        // the alghoritm is  seconds = block.timestamp - stake seconds (block.timestap - _stake.since)
        // hours = Seconds / 3600 (seconds /3600) 3600 is an variable in Solidity names hours
        // we then multiply each token by the hours staked , then divide by the rewardPerHour rate

        uint256 _startDay = _current_stake.startDay;
        uint256 _endDay = _current_stake.endDay;
        
        if (_startDay == currentSigmaDay) {
            return 0;
        }

        if (_current_stake.amount == 0) {
            return 0;
        }

        uint256 _lastDay;
        if (_endDay > currentSigmaDay) {
            _lastDay = currentSigmaDay;
        } else {
            _lastDay = _endDay;
        }
        uint256 _xShares = _current_stake.xShares;
        for (uint256 _day = _startDay; _day < _lastDay; _day ++) {
            _sigmaRewards += _xShares.mul(PRECISION_RATE).div(stinfo[_day].inflationAmount);
        }

        return _sigmaRewards;
    }

    function calculateStakeRewardBitcoin(Stake memory _current_stake)
        internal
        view
        returns (uint256 _bitcoinRewards)
    {
        uint256 _startDay = _current_stake.startDay;
        uint256 _endDay = _current_stake.endDay;

        if (_startDay == currentSigmaDay) {
            return 0;
        }

        if (_current_stake.amount == 0) {
            return 0;
        }
        
        uint256 _lastDay;
        if (_endDay > currentSigmaDay) {
            _lastDay = currentSigmaDay;
        } else {
            _lastDay = _endDay;
        }
        uint256 _xShares = _current_stake.xShares;
        for (uint256 _day = _startDay; _day < _lastDay; _day ++) {
            _bitcoinRewards += _xShares.mul(PRECISION_RATE).div(stinfo[_day].bitcoinAmount);
        }

        return _bitcoinRewards;
    }


    function _withdrawStake(uint256 _amountToUnstake, uint256 index)
        internal
        returns (uint256, uint256 _bitcoinamount)
    {
        // Grab user_index which is the index to use to grab the Stake[])
        uint256 user_index = stakes[msg.sender];
        Stake memory current_stake = stakeholders[user_index].address_stakes[
            index
        ];
        require(
            current_stake.amount > 0,
            "Staking: The current stake has already been closed."
        );
        uint256 currAmount = current_stake.amount;
        require(_amountToUnstake == 0 || _amountToUnstake == currAmount);
        // Calculate available Reward first before we start modifying data
        uint256 reward = calculateStakeReward(current_stake);
        uint256 bitcoinrewards = calculateStakeRewardBitcoin(current_stake);
        uint256 sharesFee;
        if (_amountToUnstake != 0) {
        totalStaked -= _amountToUnstake;
        sharesFee = current_stake.xShares;
        } else if (_amountToUnstake == 0) {
            sharesFee = current_stake.xShares.mul(20).div(100);
        }
        current_stake.amount = current_stake.amount - _amountToUnstake;
        if (current_stake.endDay <= currentSigmaDay && current_stake.endDay + 20 >= currentSigmaDay) {
            _amountToUnstake = _amountToUnstake; // No fees if the stake is mature
            reward = reward; // No fees if the stake is mature
            bitcoinrewards = bitcoinrewards; // No fees are applied to the Bitcoin rewards
        } else if (current_stake.endDay <= currentSigmaDay && current_stake.endDay + 20 <= currentSigmaDay) {
            _amountToUnstake = _amountToUnstake; // No fees if the stake is mature
            reward = 0; // No fees if the stake is mature
            bitcoinrewards = bitcoinrewards; // No fees are applied to the Bitcoin rewards
        }else if (_amountToUnstake == 0) {
            totalxshares -= sharesFee;
            reward = reward.mul(50).div(100); //burn 50% of the rewards in case the user claim rewards while the stake is active
            bitcoinrewards = bitcoinrewards; // No fees are applied to the Bitcoin rewards
            _removeFutureExpiringShares(current_stake.endDay, sharesFee);
        } else if (_amountToUnstake != 0) {
            totalxshares -= sharesFee;
            _amountToUnstake = _amountToUnstake.mul(10).div(100); //burn 90% of the staked amount in case of withdraw during stake's active phase.
            reward = reward.mul(50).div(100); //burn 90% of all rewards in case user withdraws rewards while the stake is active.
            bitcoinrewards = bitcoinrewards; // No fees are applied to the Bitcoin rewards
            _removeFutureExpiringShares(current_stake.endDay, sharesFee);
        }
        // If stake is empty, 0, then remove it from the array of stakes
        if (current_stake.amount == 0) {
            delete stakeholders[user_index].address_stakes[index];
        } else {
            // Deduct the stake's xshares
            stakeholders[user_index]
                .address_stakes[index]
                .xShares -= sharesFee;
            // Edit the start date
            stakeholders[user_index]
                .address_stakes[index]
                .startDay = currentSigmaDay;
            // If not empty then change the sigma rewards value to 0
            stakeholders[user_index]
                .address_stakes[index]
                .claimable = 0;
            // If not empty then replace the value of it
            stakeholders[user_index]
                .address_stakes[index]
                .amount = current_stake.amount;
            // If not empty then change the bitcoinrewards value to 0
            stakeholders[user_index]
                .address_stakes[index]
                .claimablebitcoin = 0;
        }

        return (_amountToUnstake + reward, bitcoinrewards);
    }

    function hasStake(address _staker)
        public
        view
        returns (StakingSummary memory)
    {
        // totalStakeAmount is used to count total staked amount of the address
        uint256 totalStakeAmount;
        // Keep a summary in memory since we need to calculate this
        StakingSummary memory summary = StakingSummary(
            0,
            stakeholders[stakes[_staker]].address_stakes
        );
        // Itterate all stakes and grab amount of stakes
        for (uint256 s = 0; s < summary.stakes.length; s += 1) {
            if (summary.stakes[s].amount > 0) {
                uint256 availableRewardSigma = calculateStakeReward(summary.stakes[s]);
                uint256 availableRewardBitcoin = calculateStakeRewardBitcoin(summary.stakes[s]);
                summary.stakes[s].claimable = availableRewardSigma;
                summary.stakes[s].claimablebitcoin = availableRewardBitcoin;
                totalStakeAmount = totalStakeAmount + summary.stakes[s].amount;
            }
        }
        // Assign calculate amount to summary
        summary.total_amount = totalStakeAmount;
        return summary;
    }
}

abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return payable(msg.sender);
    }
 
    function _msgData() internal view virtual returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}
 
abstract contract Ownable is Context {
    address private _owner;
 
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
 
    constructor () {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }
 
    function owner() public view virtual returns (address) {
        return _owner;
    }
 
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }
 
    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }
 
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
 
interface IERC20 {
    function totalSupply() external view returns (uint256);
 
    function balanceOf(address account) external view returns (uint256);
 
    function transfer(address recipient, uint256 amount) external returns (bool);
 
    function allowance(address owner, address spender) external view returns (uint256);
 
    function approve(address spender, uint256 amount) external returns (bool);
 
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
 
    event Transfer(address indexed from, address indexed to, uint256 value);
 
    event Approval(address indexed owner, address indexed spender, uint256 value);
}
 
contract ERC20 is Context, IERC20 {
    using SafeMath for uint256;
 
    mapping (address => uint256) private _balances;
 
    mapping (address => mapping (address => uint256)) private _allowances;
 
    uint256 private _totalSupply;
 
    string private _name;
    string private _symbol;
    uint8 private _decimals;
 
    constructor (string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
        _decimals = 18;
    }
 
    function name() public view virtual returns (string memory) {
        return _name;
    }
 
    function symbol() public view virtual returns (string memory) {
        return _symbol;
    }
 
    function decimals() public view virtual returns (uint8) {
        return _decimals;
    }
 
    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }
 
    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }
 
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }
 
    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }
 
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }
 
    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }
 
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }
 
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }
 
    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");
 
        _beforeTokenTransfer(sender, recipient, amount);
 
        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }
 
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: mint to the zero address");
 
        _beforeTokenTransfer(address(0), account, amount);
 
        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }
 
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: burn from the zero address");
 
        _beforeTokenTransfer(account, address(0), amount);
 
        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }
 
    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");
 
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
 
    function _setupDecimals(uint8 decimals_) internal virtual {
        _decimals = decimals_;
    }
 
    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }
}
 
////////////////////////////////
///////// Interfaces ///////////
////////////////////////////////
 
interface IFIP {
    function withdrawBitcoin(uint256 _amount, address _recipient) external;
    function _assignFipDividends(uint256 _amount) external;
}

interface IUniswapV2Factory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);
 
    function feeTo() external view returns (address);
    function feeToSetter() external view returns (address);
 
    function getPair(address tokenA, address tokenB) external view returns (address pair);
    function allPairs(uint) external view returns (address pair);
    function allPairsLength() external view returns (uint);
 
    function createPair(address tokenA, address tokenB) external returns (address pair);
 
    function setFeeTo(address) external;
    function setFeeToSetter(address) external;
}
 
interface IUniswapV2Pair {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);
 
    function name() external pure returns (string memory);
    function symbol() external pure returns (string memory);
    function decimals() external pure returns (uint8);
    function totalSupply() external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);
 
    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);
 
    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function PERMIT_TYPEHASH() external pure returns (bytes32);
    function nonces(address owner) external view returns (uint);
 
    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
 
    event Mint(address indexed sender, uint amount0, uint amount1);
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);
 
    function MINIMUM_LIQUIDITY() external pure returns (uint);
    function factory() external view returns (address);
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function price0CumulativeLast() external view returns (uint);
    function price1CumulativeLast() external view returns (uint);
    function kLast() external view returns (uint);
 
    function mint(address to) external returns (uint liquidity);
    function burn(address to) external returns (uint amount0, uint amount1);
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
    function skim(address to) external;
    function sync() external;
 
    function initialize(address, address) external;
}
 
interface IUniswapV2Router01 {
    function factory() external pure returns (address);
    function WETH() external pure returns (address);
 
    function addLiquidity( address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline ) external returns (uint amountA, uint amountB, uint liquidity); 
    function addLiquidityETH( address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external payable returns (uint amountToken, uint amountETH, uint liquidity); 
    function removeLiquidity( address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline ) external returns (uint amountA, uint amountB); 
    function removeLiquidityETH( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external returns (uint amountToken, uint amountETH); 
    function removeLiquidityWithPermit( address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external returns (uint amountA, uint amountB); 
    function removeLiquidityETHWithPermit( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external returns (uint amountToken, uint amountETH); 
    function swapExactTokensForTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external returns (uint[] memory amounts); 
    function swapTokensForExactTokens( uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline ) external returns (uint[] memory amounts); 
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts); 
    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts); 
    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts); 
    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts); 
 
    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);
    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
}
 
interface IUniswapV2Router02 is IUniswapV2Router01 {
    function removeLiquidityETHSupportingFeeOnTransferTokens( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external returns (uint amountETH); 
    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external returns (uint amountETH);
    function swapExactTokensForTokensSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external; 
    function swapExactETHForTokensSupportingFeeOnTransferTokens( uint amountOutMin, address[] calldata path, address to, uint deadline ) external payable; 
    function swapExactTokensForETHSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external; 
 
}
 
////////////////////////////////
////////// Libraries ///////////
////////////////////////////////
library SafeMath {
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        uint256 c = a + b;
        if (c < a) return (false, 0);
        return (true, c);
    }
 
    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b > a) return (false, 0);
        return (true, a - b);
    }
 
    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) return (true, 0);
        uint256 c = a * b;
        if (c / a != b) return (false, 0);
        return (true, c);
    }
 
    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b == 0) return (false, 0);
        return (true, a / b);
    }
 
    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b == 0) return (false, 0);
        return (true, a % b);
    }
 
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");
        return c;
    }
 
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        return a - b;
    }
 
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) return 0;
        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");
        return c;
    }
 
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "SafeMath: division by zero");
        return a / b;
    }
 
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "SafeMath: modulo by zero");
        return a % b;
    }
 
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        return a - b;
    }
 
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        return a / b;
    }
 
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        return a % b;
    }
}
 
library SafeMathInt {
  function mul(int256 a, int256 b) internal pure returns (int256) {
    // Prevent overflow when multiplying INT256_MIN with -1
    // https://github.com/RequestNetwork/requestNetwork/issues/43
    require(!(a == - 2**255 && b == -1) && !(b == - 2**255 && a == -1));
 
    int256 c = a * b;
    require((b == 0) || (c / b == a));
    return c;
  }
 
  function div(int256 a, int256 b) internal pure returns (int256) {
    // Prevent overflow when dividing INT256_MIN by -1
    // https://github.com/RequestNetwork/requestNetwork/issues/43
    require(!(a == - 2**255 && b == -1) && (b > 0));
 
    return a / b;
  }
 
  function sub(int256 a, int256 b) internal pure returns (int256) {
    require((b >= 0 && a - b <= a) || (b < 0 && a - b > a));
 
    return a - b;
  }
 
  function add(int256 a, int256 b) internal pure returns (int256) {
    int256 c = a + b;
    require((b >= 0 && c >= a) || (b < 0 && c < a));
    return c;
  }
 
  function toUint256Safe(int256 a) internal pure returns (uint256) {
    require(a >= 0);
    return uint256(a);
  }
}
 
library SafeMathUint {
  function toInt256Safe(uint256 a) internal pure returns (int256) {
    int256 b = int256(a);
    require(b >= 0);
    return b;
  }
}

////////////////////////////////
/////////// Tokens /////////////
////////////////////////////////
contract SIGMA is ERC20, Ownable, Stakeable {
    using SafeMath for uint256;
 
    IERC20 public btcsigma;
    IUniswapV2Router02 public uniswapV2Router;
    address public immutable uniswapV2Pair;
    address public btcAddress;
    address public sigmaAddress;
    address public btcSigmaAddress;
    address public fipAddress;
    address public deadWallet;

    bool private swapping;
    bool public tradingIsEnabled = false;
    bool public marketingEnabled = true;
    bool public swapAndLiquifyEnabled = true;
    bool public busdDividendEnabled = true;

    uint256 public swapTokensAtAmount = 500 * 10**18;

    uint256 public burnFee;
    uint256 public btcDividendRewardsFee;
    uint256 public fipFee;
    
    uint256 public btcDividedRewardsInContract;

    //Fees Improvement Proposal (FIP)
    uint256 public currentFee;

    //Number of free stakes
    uint256 public freeStakesAmount = 1000;

    //btcInterface
    IERC20 public bitcoinContract;
    IFIP public fipInterface;
 
    mapping (address => bool) private isExcludedFromFees; 
    mapping (address => bool) public hasClaimedFreeStake;
    // store addresses that a automatic market maker pairs. Any transfer *to* these addresses
    // could be subject to a maximum transfer amount
    mapping (address => bool) public automatedMarketMakerPairs;
    event UpdatebusdDividendTracker(address indexed newAddress, address indexed oldAddress);
    event UpdateUniswapV2Router(address indexed newAddress, address indexed oldAddress);
    event ExcludeFromFees(address indexed account, bool isExcluded);
    event ExcludeMultipleAccountsFromFees(address[] accounts, bool isExcluded);
    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);
 
    constructor(address _btcSigmaAddress, address _fipAddress, address _bitcoinAddress) ERC20("SIGMA", "SGM") {
        fipInterface = IFIP(_fipAddress);
    	btcAddress = _bitcoinAddress;
        sigmaAddress = address(this);
        btcSigmaAddress = _btcSigmaAddress;
        currentFee = 2;
        fipAddress = _fipAddress;
        deadWallet = 0x000000000000000000000000000000000000dEaD;
        bitcoinContract = IERC20(_bitcoinAddress);
        btcsigma = IERC20(_btcSigmaAddress);
    	IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);
         // Create a uniswap pair for this new token
        address _uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())
            .createPair(address(this), btcAddress);
 
        uniswapV2Router = _uniswapV2Router;
        uniswapV2Pair = _uniswapV2Pair;
 
        _setAutomatedMarketMakerPair(_uniswapV2Pair, true);
        // exclude from paying fees or having max transaction amount
        excludeFromFees(address(this), true);
        excludeFromFees(owner(), true);
        excludeFromFees(fipAddress, true);
        _mint(owner(), 10000000 * (10**18));
    }
 
    receive() external payable {
 
  	}

    function getCurrentFee() public view returns (uint256) {
        return currentFee;
    }

    function setTradingIsEnabled(bool _enabled) external onlyOwner {
        tradingIsEnabled = _enabled;
    }

    function updateCurrentFee(uint256 newFee) external {
        require(currentSigmaDay >= 7, "Fees Improvement Proposal has not started yet.");
        require(msg.sender == address(fipAddress), "Only the Fees Improvement (FIP) contract can update the fee.");
        require(newFee == 1 || newFee == 2 || newFee == 5, "Invalid fee value. Must be 1, 2, or 5.");
        currentFee = newFee;
    }

    function updateUniswapV2Router(address newAddress) external onlyOwner {
        require(newAddress != address(uniswapV2Router), "Sigma: The router already has that address");
        emit UpdateUniswapV2Router(newAddress, address(uniswapV2Router));
        uniswapV2Router = IUniswapV2Router02(newAddress);
    }
 
    function excludeFromFees(address account, bool excluded) public onlyOwner {
        require(isExcludedFromFees[account] != excluded, "Sigma: Account is already exluded from fees");
        isExcludedFromFees[account] = excluded;
 
        emit ExcludeFromFees(account, excluded);
    }
 
    function setAutomatedMarketMakerPair(address pair, bool value) public onlyOwner {
        require(pair != uniswapV2Pair, "Sigma: The PancakeSwap pair cannot be removed from automatedMarketMakerPairs");
 
        _setAutomatedMarketMakerPair(pair, value);
    }
 
    function _setAutomatedMarketMakerPair(address pair, bool value) private onlyOwner {
        require(automatedMarketMakerPairs[pair] != value, "Sigma: Automated market maker pair is already set to that value");
        automatedMarketMakerPairs[pair] = value;
        emit SetAutomatedMarketMakerPair(pair, value);
    }

    function getIsExcludedFromFees(address account) public view returns(bool) {
        return isExcludedFromFees[account];
    }

  	function prepareForPartherOrExchangeListing(address _partnerOrExchangeAddress) external onlyOwner {
        excludeFromFees(_partnerOrExchangeAddress, true);
  	}
    
    function _transfer(
        address from,
        address to,
        uint256 amount
    ) internal override {
        require(from != address(0), "ERC20: transfer from the zero address");
        require(to != address(0), "ERC20: transfer to the zero address");

        bool excludedAccount = isExcludedFromFees[from] || isExcludedFromFees[to];
 
        if (
            tradingIsEnabled && !excludedAccount && currentFee == 1
        ) {
            btcDividendRewardsFee = 9;
            fipFee = 1;
            burnFee = 0;
 	    
        } else if (
            tradingIsEnabled && !excludedAccount && currentFee == 2
        ) {
            btcDividendRewardsFee = 16;
            fipFee = 4;
            burnFee = 0;

        } else if (
            tradingIsEnabled && !excludedAccount && currentFee == 5
        ) {
            btcDividendRewardsFee = 30;
            fipFee = 10;
            burnFee = 1;
        }
 
        if (block.timestamp > (currentSigmaDay + 1) * DAY_IN_SECONDS + sigmaLaunchTime) {
            incrementSigmaDay();
        }
        uint256 contractTokenBalance = balanceOf(address(this));
        bool canSwap = contractTokenBalance >= swapTokensAtAmount;

        if (!swapping && canSwap && from != uniswapV2Pair) {
            swapping = true;

            if (busdDividendEnabled) {
                uint256 tokensAmount = btcDividedRewardsInContract;
                swapTokensForBTC(tokensAmount);
                btcDividedRewardsInContract = 0;
            }
 
            swapping = false;
        }
 
        bool takeFee = tradingIsEnabled && !swapping && !excludedAccount;
 
        if(takeFee) {
        	uint256 fees;

            uint256 tmpFIPfee;
            uint256 tmpBtcDividedRewardsInContract;
            uint256 tmpBurnFee;
            uint256 tokensToConvert;

            tmpFIPfee = amount.mul(fipFee).div(1000);
            tmpBtcDividedRewardsInContract = amount.mul(btcDividendRewardsFee).div(1000);
            tmpBurnFee = amount.mul(burnFee).div(100);

            fees = tmpFIPfee.add(tmpBtcDividedRewardsInContract)
                            .add(tmpBurnFee);

            tokensToConvert = tmpFIPfee.add(tmpBtcDividedRewardsInContract);

            btcDividedRewardsInContract = btcDividedRewardsInContract.add(tmpBtcDividedRewardsInContract);

        	amount = amount.sub(fees);
            super._transfer(from, address(this), tokensToConvert);
            if (tmpBurnFee != 0)
            {
            super._transfer(from, deadWallet, tmpBurnFee);
            }
        }
 
        super._transfer(from, to, amount);
    }

    function stake(uint256 _amount, string memory _stakename, uint256 _stakingdays) public {
        // Make sure staker actually is good for it
        uint256 userBalance = balanceOf(msg.sender);
        require(
            _amount < userBalance,
            "DevToken: Cannot stake more than you own"
        );

        _stake(_amount, _stakename, _stakingdays);
        // Burn the amount of tokens on the sender
        _burn(msg.sender, _amount);
    }

    function claimFreeStake() public {
        uint256 userBalance = IERC20(0xb25583E5e2dB32b7FCbffe3f5e8E305C36157E54).balanceOf(msg.sender);
        // Make sure staker actually is good for it
        require(!hasClaimedFreeStake[msg.sender], "You can only claim free stake once");
        require(userBalance >= 10000000000000000000000, "Free Stake: You must hold at least 10,000XRX in order to claim a free stake");
        _stake(1000000000000000000000, "Test", 90);
        // Mark this address as having claimed
        hasClaimedFreeStake[msg.sender] = true;
        // Deduct the free stakes
        freeStakesAmount -= 1;
    }

    /**
     * @notice withdrawStake is used to withdraw stakes from the account holder
     */
    function withdrawStake(uint256 amount, uint256 stake_index) public {
        (uint256 amount_to_mint, uint256 bitcoinToTransfer) = _withdrawStake(amount, stake_index);
        // Return staked tokens to user
        _mint(msg.sender, amount_to_mint);
        if (bitcoinToTransfer != 0) {
        fipInterface.withdrawBitcoin(bitcoinToTransfer, msg.sender);
        }
    }

    /*
    We simply get the needed addreses and swap tokens for bitcoin. After the swap is done, 10
    */

    function swapTokensForBTC(uint256 _tokenAmount) private {
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = btcAddress;
 
        _approve(address(this), address(uniswapV2Router), _tokenAmount);

        // make the swap
        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            _tokenAmount,
            0, // accept any amount of dividend token
            path,
            fipAddress,
            block.timestamp
        );
        
        uint256[] memory amountsOut = uniswapV2Router.getAmountsOut(_tokenAmount, path);
        uint256 receivedAmount = amountsOut[amountsOut.length - 1];
        uint256 fipAmount = receivedAmount.mul(fipFee).div(1000);
        uint256 btcAmount = receivedAmount - fipAmount;
        _assignNewBitcoinDividends(btcAmount);
        fipInterface._assignFipDividends(fipAmount);
    }

    function contributeDividendsToStakers(uint256 _amount) public {
        // Transfer the voter's btcSigma balance to the contract
        require(_amount > 0, "The amount must be greater than zero.");
        bitcoinContract.transferFrom(msg.sender, fipAddress, _amount);
        _assignNewBitcoinDividends(_amount);
    }

    function contributeDividendsToFIP(uint256 _amount) public {
        // Transfer the voter's btcSigma balance to the contract
        require(_amount > 0, "The amount must be greater than zero.");
        bitcoinContract.transferFrom(msg.sender, fipAddress, _amount);
        fipInterface._assignFipDividends(_amount);
    }
}