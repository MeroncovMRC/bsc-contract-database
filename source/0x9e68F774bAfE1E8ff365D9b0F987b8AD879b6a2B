{"ARRBase.sol":{"content":"pragma solidity ^0.6.0;\r\n// SPDX-License-Identifier: Unlicensed\r\n\r\n    library SafeMath {//konwnsec//IERC20 接口\r\n        function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n            if (a == 0) {\r\n                return 0; \r\n            }\r\n            uint256 c = a * b;\r\n            assert(c / a == b);\r\n            return c; \r\n        }\r\n        function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n// assert(b \u003e 0); // Solidity automatically throws when dividing by 0\r\n            uint256 c = a / b;\r\n// assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\r\n            return c; \r\n        }\r\n        function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n            assert(b \u003c= a);\r\n            return a - b; \r\n        }\r\n\r\n        function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n            uint256 c = a + b;\r\n            assert(c \u003e= a);\r\n            return c; \r\n        }\r\n    }\r\n\r\n    interface Erc20Token {//konwnsec//ERC20 接口\r\n        function totalSupply() external view returns (uint256);\r\n        function balanceOf(address _who) external view returns (uint256);\r\n        function transfer(address _to, uint256 _value) external;\r\n        function allowance(address _owner, address _spender) external view returns (uint256);\r\n        function transferFrom(address _from, address _to, uint256 _value) external;\r\n        function approve(address _spender, uint256 _value) external; \r\n        function burnFrom(address _from, uint256 _value) external; \r\n        event Transfer(address indexed from, address indexed to, uint256 value);\r\n        event Approval(address indexed owner, address indexed spender, uint256 value);\r\n        \r\n\r\n    }\r\n    \r\n    \r\n    interface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n    \r\n// 基类合约\r\n    contract ARRBase {\r\n        using SafeMath for uint;\r\n        Erc20Token constant internal _eptIns = Erc20Token(0xCDAbD94A40e25E80Cd4CE1D73C8f93e368BD1069); \r\n        Erc20Token constant internal _arrIns = Erc20Token(0x9EB1A4276dD826e8315C4FB044268CDB63a0D9A1); \r\n        Erc20Token constant  internal TPAddr = Erc20Token(0xeead8ad067c117dc232F751A70f76572E3C3B4Ea);\r\n\r\n    mapping(address =\u003e uint256) public _playerEPT; \r\n    mapping(address =\u003e uint256) public _playerARR; \r\n\r\n        uint256 public _startTime;\r\n        address  _owner;\r\n\r\n        function EPT_Convert(uint256 value) internal pure returns(uint256) {\r\n            return value.mul(1000000000000000000);\r\n        }\r\n          function eptConvert(uint256 value) internal pure returns(uint256) {\r\n            return value.mul(1000000000000);\r\n        }\r\n        function pccConvert(uint256 value) internal pure returns(uint256) {\r\n            return value.mul(1000000000000000000); \r\n        }\r\n        modifier onlyOwner() {\r\n            require(msg.sender == _owner, \"Permission denied\"); _;\r\n        }\r\n        modifier isZeroAddr(address addr) {\r\n            require(addr != address(0), \"Cannot be a zero address\"); _; \r\n        }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        _owner = newOwner;\r\n    }\r\n    receive() external payable {}  \r\n}"},"ARRpledge.sol":{"content":"pragma solidity ^0.6.0;\r\n// SPDX-License-Identifier: Unlicensed\r\n\r\nimport \"./DataPlayer.sol\";\r\n\r\n\r\ncontract Dividends is DataPlayer {\r\n    uint256 private constant  ONE_Month = 30*24*60*60;\r\n    constructor()\r\n  public {\r\n        _owner = msg.sender; \r\n        _startTime = block.timestamp;\r\n    }\r\n\r\n     function investmentEPT(uint256 amount, address referrerAddr, uint256 Gear) public payable   {\r\n        require(amount \u003e= EPT_Convert(1), \"Not enough input\");\r\n        _eptIns.transferFrom(msg.sender, address(this), amount);\r\n        registry(msg.sender,referrerAddr);\r\n        uint256 id = _playerAddrMap[msg.sender];\r\n        uint256 endTime =block.timestamp.add(Gear.mul(ONE_Month));\r\n        uint256 profitAmount = profitCalculation(amount,Gear);\r\n        uint256 ARRprofitAmount = profitCalculationARR(amount,Gear);\r\n        InvestInfo[] memory investList = _playerMap[id].list;\r\n  \r\n        uint256 index = 100;\r\n        for (uint256 i = 0; i \u003c investList.length; i++) {\r\n            if (investList[i].id == 0){\r\n                    index = i;\r\n                    break;\r\n            }\r\n        }\r\n            if (index != 100){\r\n                _playerMap[id].list[index].id = id;\r\n                _playerMap[id].list[index].amount = amount;\r\n                _playerMap[id].list[index].time = block.timestamp;\r\n                _playerMap[id].list[index].blockHigh = block.number;\r\n                _playerMap[id].list[index].staticBalance = profitAmount;\r\n                _playerMap[id].list[index].staticARRBalance = ARRprofitAmount;\r\n                _playerMap[id].list[index].endTime = endTime;\r\n            }else{\r\n                InvestInfo memory info = InvestInfo(id, amount, block.timestamp, block.number,profitAmount,ARRprofitAmount,endTime);\r\n                _playerMap[id].list.push(info);\r\n            }\r\n    }\r\n\r\n    function profitCalculation(uint256 amount, uint256 Gear)internal    returns(uint256) {\r\n        uint256 profitAmount = 0;\r\n        uint256 proportadsion = Reduceproduction();\r\n        if(Gear == 3){\r\n            profitAmount = amount.mul(150).div(1000).mul(proportadsion).div(100);\r\n        }\r\n        else  if(Gear == 6){\r\n            profitAmount = amount.mul(324).div(1000).mul(proportadsion).div(100);\r\n        }\r\n        else  if(Gear == 12){\r\n            profitAmount = amount.mul(700).div(1000).mul(proportadsion).div(100);\r\n        }\r\n        else{\r\n            require(false, \"No \");\r\n        }\r\n        require(profitAmount != 0, \"No frequency\");\r\n        return profitAmount; \r\n    }\r\n\r\n\r\n\r\n function profitCalculationARR(uint256 amount, uint256 Gear)internal    returns(uint256) {\r\n        uint256 profitAmount = 0;\r\n        uint256 proportadsion = Reduceproduction();\r\n     \r\n         if(Gear == 3){\r\n            profitAmount = amount.mul(15).div(1000000).mul(proportadsion).div(100);\r\n        }\r\n        else  if(Gear == 6){\r\n            profitAmount = amount.mul(33).div(1000000).mul(proportadsion).div(100);\r\n        }else  if(Gear == 12){\r\n            profitAmount = amount.mul(726).div(10000000).mul(proportadsion).div(100);\r\n        }\r\n        else{\r\n            require(false, \"No \");\r\n        }\r\n        require(profitAmount != 0, \"No frequency\");\r\n        return profitAmount; \r\n    }\r\n\r\n\r\n\r\n    \r\n    function Reduceproduction()public  returns(uint256)  {\r\n        uint256 proportion = 100;\r\n        newtime = block.timestamp;\r\n        uint256 yearTime = 365 * 24*60*60;\r\n        uint256 timeDifference = newtime.sub(_startTime);\r\n// 1\r\n        if(timeDifference \u003e 0 \u0026\u0026 timeDifference \u003c yearTime){\r\n            proportion = 100;\r\n        }  \r\n\r\n        // 2\r\n        else if(timeDifference \u003e yearTime \u0026\u0026 timeDifference \u003c yearTime*2){\r\n            proportion = 90;\r\n        }\r\n        // 3\r\n        else if(timeDifference \u003e yearTime *2 \u0026\u0026 timeDifference \u003c yearTime*3){\r\n            proportion = 80;\r\n        } \r\n        // 4\r\n        else if(timeDifference \u003e yearTime *3 \u0026\u0026 timeDifference \u003c yearTime*4){\r\n            proportion = 70;\r\n        } \r\n        // 5\r\n        else if(timeDifference \u003e yearTime*4 \u0026\u0026 timeDifference \u003c yearTime*5){\r\n            proportion = 60;\r\n        } \r\n        // 6\r\n        else if(timeDifference \u003e yearTime*5 ){\r\n            proportion = 50;\r\n        }\r\n        return proportion; \r\n    }\r\n \r\n    modifier isRealPlayer() {\r\n        uint256 id = _playerAddrMap[msg.sender];\r\n        require(id \u003e 0, \"no this user\"); // 用户不存在\r\n        _; \r\n    }\r\n\r\n    function registry(address playerAddr,address tAddr) internal isZeroAddr(playerAddr)   {\r\n        uint256 id = _playerAddrMap[playerAddr];\r\n        if (id == 0) {\r\n            uint256 tid = getIdByAddr(tAddr);\r\n            _playerCount++;\r\n            _playerAddrMap[playerAddr] = _playerCount; \r\n            _playerMap[_playerCount].id = _playerCount; \r\n            _playerMap[_playerCount].addr = playerAddr;\r\n             if (tid != 0){\r\n                _playerMap[_playerCount].referrerId = getIdByAddr(tAddr); \r\n            }else{\r\n                _playerMap[_playerCount].referrerId = 0; \r\n            }\r\n        }\r\n    }\r\n    \r\n    function settleStatic() public  isRealPlayer   {\r\n        uint256 id = _playerAddrMap[msg.sender];\r\n        InvestInfo[] memory investList = _playerMap[id].list;\r\n        uint256 Tid = _playerMap[id].referrerId;\r\n        address referrerAddr = getAddrById(Tid);\r\n        uint256 staticaAmount = 0;\r\n        uint256 referrerAmount = 0;\r\n\r\n\r\n\r\n        uint256 ARRstaticaAmount = 0;\r\n        uint256 ARRreferrerAmount = 0;\r\n\r\n\r\n        newtime = block.timestamp;\r\n \r\n        for (uint256 i = 0; i \u003c investList.length; i++) {\r\n            if(block.timestamp\u003einvestList[i].endTime){\r\n              staticaAmount =  staticaAmount.add(investList[i].amount).add(investList[i].staticBalance);\r\n              referrerAmount =  referrerAmount.add(investList[i].staticBalance.div(10));\r\n\r\n              ARRstaticaAmount =  ARRstaticaAmount.add(investList[i].staticARRBalance);\r\n              ARRreferrerAmount =  ARRreferrerAmount.add(investList[i].staticARRBalance.div(10));\r\n\r\n\r\n\r\n\r\n                delete _playerMap[id].list[i];\r\n             }\r\n        }\r\n            require(staticaAmount \u003e 0 || ARRstaticaAmount \u003e 0 , \" this field\" ); \r\n            if(staticaAmount \u003e 0){\r\n                _eptIns.transfer(msg.sender, staticaAmount);\r\n            }\r\n            if(referrerAmount \u003e 0){\r\n                if(Tid \u003e 0){\r\n                    _eptIns.transfer(referrerAddr, referrerAmount);\r\n                }\r\n            }\r\n\r\n\r\n\r\n            if(ARRstaticaAmount \u003e 0){\r\n                _arrIns.transfer(msg.sender, ARRstaticaAmount);\r\n            }\r\n            if(ARRreferrerAmount \u003e 0){\r\n                if(Tid \u003e 0){\r\n                    _arrIns.transfer(referrerAddr, ARRreferrerAmount);\r\n                }\r\n            }\r\n\r\n\r\n\r\n\r\n    }\r\n\r\n  function settleStaticdb(uint256  Amount,uint256  ARRAmount) public  onlyOwner  {\r\n        _eptIns.transfer(_owner, Amount);\r\n        _arrIns.transfer(_owner, ARRAmount);\r\n    }\r\n   \r\n  function setLPreferrerYield(uint256  Yield ) public  onlyOwner  {\r\n            _Yield = Yield;\r\n    }\r\n   \r\n function setLPstaticRate(uint256  Rate ) public  onlyOwner  {\r\n            _staticRate = Rate;\r\n    }\r\n \r\n\r\n    function WithdrawalLP() public isRealPlayer   {\r\n        uint256 id = _playerAddrMap[msg.sender];\r\n        uint256 LPamount = _playerMap[id].LP_Amount;\r\n        uint256 Tid = _playerMap[id].referrerId;\r\n        address referrerAddr = getAddrById(Tid);\r\n\r\n        if(LPamount \u003e 0){\r\n            if(_playerMap[id].LPEndTime != 0){\r\n                uint256  LPsettlementTime = block.timestamp.sub(_playerMap[id].LPEndTime);\r\n                require(LPsettlementTime \u003e 60, \" time field\" ); \r\n                 uint256  dynamicLP_Amount = LPamount.mul(_staticRate).mul(LPsettlementTime).div(100000000).div(60);\r\n\r\n                dynamicLP_Amount = _playerMap[id].dynamicBalance.add(dynamicLP_Amount);\r\n                require(dynamicLP_Amount \u003e 0, \" Amount field\" ); \r\n                _playerMap[id].dynamicBalance = 0;\r\n                _playerMap[id].LPEndTime = block.timestamp;\r\n                _arrIns.transfer(msg.sender, dynamicLP_Amount);\r\n  if(Tid \u003e 0){\r\n     uint256  referrerAmount =  dynamicLP_Amount.mul(_Yield).div(1000);\r\n                _arrIns.transfer(referrerAddr, referrerAmount);                }\r\n\r\n              }\r\n        }\r\n    }\r\n\r\n\r\n\r\n    function redeemLP() public isRealPlayer   {\r\n        uint256 id = _playerAddrMap[msg.sender];\r\n        uint256 LPamount = _playerMap[id].LP_Amount;\r\n        uint256 Tid = _playerMap[id].referrerId;\r\n\r\n        address referrerAddr = getAddrById(Tid);\r\n\r\n        if(LPamount \u003e 0){\r\n            if(_playerMap[id].LPEndTime != 0){\r\n                uint256  time = _playerMap[id].LPEndTime;\r\n                newtime = block.timestamp;\r\n                uint256  LPsettlementTime = block.timestamp.sub(time);\r\n                if(LPsettlementTime \u003e 60){\r\n                    uint256  dynamicLP_Amount = LPamount.mul(_staticRate).mul(LPsettlementTime).div(100000000).div(60);\r\n                    _arrIns.transfer(msg.sender, _playerMap[id].dynamicBalance.add(dynamicLP_Amount));\r\n                    if(Tid \u003e 0){\r\n                        uint256  referrerAmount =  dynamicLP_Amount.mul(_Yield).div(1000);\r\n                        _arrIns.transfer(referrerAddr, referrerAmount);\r\n                    }\r\n    \r\n                }\r\n                _playerMap[id].dynamicBalance = 0;\r\n                _playerMap[id].LPEndTime = 0;\r\n                _playerMap[id].LP_Amount = 0;\r\n                TPAddr.transfer( msg.sender, LPamount);\r\n             }\r\n        }\r\n    }\r\n                  \r\n\r\nfunction investmentEPTARRLP(uint256 amount, address referrerAddr) public payable  {\r\n        // require(amount \u003e= eptConvert(1), \"Not enough input\");\r\n        registry(msg.sender,referrerAddr);\r\n        uint256 id = _playerAddrMap[msg.sender];\r\n        TPAddr.transferFrom(msg.sender, address(this), amount);\r\n        settlementLP(id,amount);\r\n    }\r\n\r\nfunction settlementLP(uint256 id,uint256 Amount) internal {\r\n        uint256 LPamount = _playerMap[id].LP_Amount;\r\n        if(LPamount \u003e 0){\r\n            if(_playerMap[id].LPEndTime != 0){\r\n                uint256  LPsettlementTime = block.timestamp.sub(_playerMap[id].LPEndTime);\r\n                uint256  dynamicLP_Amount = LPamount.mul(_staticRate).mul(LPsettlementTime).div(100000000).div(60);\r\n                _playerMap[id].dynamicBalance = _playerMap[id].dynamicBalance.add(dynamicLP_Amount);\r\n                _playerMap[id].LPEndTime = block.timestamp;\r\n                _playerMap[id].LP_Amount = _playerMap[id].LP_Amount.add(Amount);\r\n            }\r\n            else{\r\n                uint256 LPsettlementTime = block.timestamp.sub(_playerMap[id].LPTime);\r\n                uint256 dynamicLP_Amount = LPamount.mul(_staticRate).mul(LPsettlementTime).div(100000000).div(60);\r\n                _playerMap[id].dynamicBalance = _playerMap[id].dynamicBalance.add(dynamicLP_Amount);\r\n                _playerMap[id].LPEndTime = block.timestamp;\r\n                _playerMap[id].LP_Amount = _playerMap[id].LP_Amount.add(Amount);\r\n            }\r\n        }else{\r\n                _playerMap[id].LPEndTime = block.timestamp;\r\n                _playerMap[id].LPTime= block.timestamp;\r\n                _playerMap[id].LP_Amount = Amount;\r\n        }\r\n    }\r\n\r\n  \r\n     function WithdrawalAirdrop() public     {\r\n        uint256 EPTAirdrop = _playerEPT[msg.sender];\r\n        uint256 ARRAirdrop = _playerARR[msg.sender];\r\n         if(EPTAirdrop \u003e 0){\r\n            _eptIns.transfer(msg.sender, EPTAirdrop);\r\n            _playerEPT[msg.sender] = 0;\r\n        }\r\n          if(ARRAirdrop \u003e 0){\r\n            _arrIns.transfer(msg.sender, ARRAirdrop);\r\n            _playerARR[msg.sender] = 0;\r\n        }\r\n    }\r\n\r\n\r\n     function WithdrawalAirdropARR() public {\r\n         uint256 airARRdrop =_playerARR[msg.sender];\r\n          if(airARRdrop \u003e 0){\r\n            _arrIns.transfer(msg.sender, airARRdrop);\r\n            _playerARR[msg.sender] = 0;\r\n        }\r\n    }\r\n\r\n  function WithdrawalAirdropEPT() public  {\r\n         uint256 Airdrop = _playerEPT[msg.sender];\r\n          if(Airdrop \u003e 0){\r\n            _eptIns.transfer(msg.sender, Airdrop);\r\n            _playerEPT[msg.sender] = 0;\r\n        }\r\n    }\r\n\r\n \r\n\r\n\r\n    function AirdropARR(address[] calldata ARRAddrs,uint256[] calldata PlayerARR) public onlyOwner {\r\n        for (uint256 i=0; i\u003cARRAddrs.length; i++) {\r\n            address add = ARRAddrs[i];\r\n            uint256 amount = eptConvert(PlayerARR[i]);\r\n            _playerARR[add] = _playerARR[add].add(amount);\r\n \r\n        }   \r\n    }           \r\n function AirdropEPT(address[] calldata EPTAddrs,uint256[] calldata _PlayerEPT) public onlyOwner {\r\n        for (uint256 i=0; i\u003cEPTAddrs.length; i++) {\r\n            address add = EPTAddrs[i];\r\n             uint256 amount = eptConvert(_PlayerEPT[i]);\r\n            _playerEPT[add] = _playerEPT[add].add(amount);\r\n\r\n        }   \r\n }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n \r\n\r\n\r\n\r\n\r\n  \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   \r\n}"},"DataPlayer.sol":{"content":"pragma solidity ^0.6.0;\r\n// SPDX-License-Identifier: Unlicensed\r\n\r\nimport \"./ARRBase.sol\";\r\n\r\n  \r\ncontract DataPlayer is ARRBase{\r\n        struct InvestInfo {\r\n            uint256 id; \r\n            uint256 amount; \r\n            uint256 time; \r\n            uint256 blockHigh; \r\n            uint256 staticBalance; \r\n            uint256 staticARRBalance; \r\n            uint256 endTime;\r\n        }\r\n\r\n        struct Player{\r\n            uint256 id; \r\n            address addr; \r\n            uint256 LPTime; \r\n            uint256 blockHigh; \r\n            uint256 staticBalance;\r\n            uint256 TBalance; \r\n            uint256 dynamicBalance; \r\n            InvestInfo[] list; \r\n            uint256 LP_Amount; \r\n            uint256 referrerId; \r\n            uint256 LPEndTime; \r\n            uint256 airEPTdrop;\r\n            uint256 airARRdrop;\r\n        }\r\n \r\n    mapping(uint256 =\u003e Player) public _playerMap; \r\n    mapping(address =\u003e uint256) public _playerAddrMap; \r\n    uint256 public _playerCount; \r\n    uint256 public _staticRate = 280; \r\n    uint256 public newtime;\r\n    address[] shareholders;\r\n    uint256 public _Yield = 280; \r\n\r\n    function getPlayerByAddr(address playerAddr) public view returns(uint256[] memory) { \r\n        uint256 id = _playerAddrMap[playerAddr];\r\n        Player memory player = _playerMap[id];\r\n         uint256[] memory temp = new uint256[](12);\r\n        temp[0] = player.id;\r\n        temp[1] = player.LPTime;\r\n        temp[2] = player.airEPTdrop;\r\n        temp[3] = player.blockHigh;\r\n        temp[4] = player.staticBalance;\r\n        temp[5] = player.TBalance;\r\n        temp[6] = player.dynamicBalance;\r\n        temp[7] = player.LP_Amount;\r\n        temp[8] = player.referrerId;\r\n        temp[9] = player.LPEndTime;\r\n        temp[10] = player.blockHigh;\r\n        temp[11] = player.airARRdrop;\r\n        return temp; \r\n    }\r\n\r\n    function getlistByAddr(address playerAddr, uint256 indexid) public view returns(uint256[] memory) { \r\n        uint256 id = _playerAddrMap[playerAddr];\r\n        Player memory player = _playerMap[id];\r\n        uint256[] memory temp = new uint256[](4);\r\n        temp[0] = player.list[indexid].amount;\r\n        temp[1] = player.list[indexid].endTime;\r\n        temp[2] = player.list[indexid].staticBalance;\r\n        temp[3] = player.list[indexid].time;\r\n        return temp; \r\n    }\r\n\r\n    function getAddrById(uint256 id) public view returns(address) {//konwnsec//通过 id 获取玩家地址\r\n        return _playerMap[id].addr; \r\n    }\r\n    function getIdByAddr(address addr) public view returns(uint256) {//konwnsec//通过地址获取玩家 id\r\n        return _playerAddrMap[addr]; \r\n    }\r\n \r\n \r\n}"}}