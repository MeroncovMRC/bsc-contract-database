{"ERC20StandardToken.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract ERC20StandardToken is IERC20 {\n    mapping(address =\u003e uint256) private _balances;\n    mapping(address =\u003e mapping(address =\u003e uint256)) private _allowances;\n\n    string private _symbol;\n    string private _name;\n    uint8 private immutable _decimals;\n    uint256 private _totalSupply;\n    \n    constructor(string memory symbol_, string memory name_, uint8 decimals_, uint256 totalSupply_) {\n        _symbol = symbol_;\n        _name = name_;\n        _decimals = decimals_;\n        _mint(msg.sender, totalSupply_);\n    }\n\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        _spendAllowance(from, msg.sender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        uint256 fromBalance = _balances[from];\n        require(fromBalance \u003e= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n    }\n\n    function _addSenderBalance(address from, uint256 amount) internal virtual {\n        _balances[from] += amount;\n    }\n\n    function _subSenderBalance(address from, uint256 amount) internal virtual {\n        uint256 fromBalance = _balances[from];\n        require(fromBalance \u003e= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n    }\n\n    function _addReceiverBalance(address from, address to, uint256 amount) internal virtual {\n        unchecked {\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n    }\n\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = _allowances[owner][spender];\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance \u003e= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        uint256 accountBalance = _balances[account];\n        require(accountBalance \u003e= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n    }\n}"},"IPancake.sol":{"content":"pragma solidity ^0.8.0;\r\n\r\ninterface IPancakeRouter01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IPancakeRouter02 is IPancakeRouter01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface IPancakeFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n\r\n    function INIT_CODE_PAIR_HASH() external view returns (bytes32);\r\n}\r\n\r\ninterface IPancakePair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}"},"JX.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./ERC20StandardToken.sol\";\nimport \"./Ownable.sol\";\nimport \"./IPancake.sol\";\n\ninterface IDividendPayingToken {\n    function distributeDividends(uint256 amount) external;\n}\ninterface IERC721 {\n    function totalSupply() external view returns (uint256);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function balanceOf(address owner) external view returns (uint256 balance);\n}\n\nlibrary Math {\n    function min(uint x, uint y) internal pure returns (uint z) {\n        z = x \u003c y ? x : y;\n    }\n\n    function sqrt(uint y) internal pure returns (uint z) {\n        if (y \u003e 3) {\n            z = y;\n            uint x = y / 2 + 1;\n            while (x \u003c z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}\n\ncontract TempUSDTPool is Ownable {\n\n    IERC20 public c_usdt;\n\n    function initial(IERC20 c) external onlyOwner {\n        c_usdt = c;\n        c.approve(owner(), type(uint256).max);\n    }\n\n    function updateUSDTallowance() external {\n        c_usdt.approve(owner(), type(uint256).max);\n    }\n}\n\ncontract JX is ERC20StandardToken, Ownable {\n    IPancakeRouter02 public immutable uniswapV2Router = IPancakeRouter02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    address private constant usdt = 0x55d398326f99059fF775485246999027B3197955;\n    address public immutable usdtPair;\n    uint256 public minRemainAmount = 10**12;\n\n    struct UserLPInfo {\n        uint256 lpAmountTotalRecord;\n        uint256 lpAmountLocked;\n    }\n    mapping(address =\u003e UserLPInfo) private userLPInfos;\n    uint256 public immutable startReleaseTime = block.timestamp;\n    uint256 public constant oneDaySeconds = 86400;\n    uint256 public constant releaseRate = 100;\n\n    mapping (address =\u003e bool) public isExcludedFromFees;\n    uint256 public constant tradingEnabledTimestampWhiteList = 1679401800;\n    uint256 public constant tradingEnabledTimestampNormal = 1679401851;\n    address public constant deadAddress = 0x000000000000000000000000000000000000dEaD;\n    address public lpPool;\n    IDividendPayingToken public c_jx;\n    IDividendPayingToken public c_lp;\n\n    TempUSDTPool public tempUSDTPool;\n    uint256 public constant maxHoldAmount = 10*10**18;\n\n    uint256 public currentIndex;\n    uint256 public minPeriod = 600;\n    uint256 public dividendAtAmount = 10**18;\n    uint256 public lastTimeDividend;\n    uint256 public distributorGas = 500000;\n    IERC721 public constant c_nft = IERC721(0xAf725aB87a3bF510A4F32BE0bDa6ae53E28E1910);\n    uint256 public constant minHoldLP1500 = 1500*10**18;\n\n    mapping(address =\u003e uint256) public nftReward;\n\n    constructor(string memory symbol_, string memory name_, uint8 decimals_, uint256 totalSupply_) ERC20StandardToken(symbol_, name_, decimals_, totalSupply_) {\n        usdtPair = IPancakeFactory(uniswapV2Router.factory()).createPair(address(this), usdt);\n        _approve(address(this), address(uniswapV2Router), type(uint256).max);\n        IERC20(usdt).approve(address(uniswapV2Router), type(uint256).max);\n        tempUSDTPool = new TempUSDTPool();\n        tempUSDTPool.initial(IERC20(usdt));\n        isExcludedFromFees[address(0)] = true;\n        isExcludedFromFees[address(0x000000000000000000000000000000000000dEaD)] = true;\n    }\n\n    function setMP(uint256 mp) external onlyOwner {\n        minPeriod = mp;\n    }\n    function setDA(uint256 da) external onlyOwner {\n        dividendAtAmount = da;\n    }\n    function setDG(uint256 dg) external onlyOwner {\n        distributorGas = dg;\n    }\n    function setExcludeFee(address a, bool b) external onlyOwner {\n        isExcludedFromFees[a] = b;\n    }\n    function setlpPool(address p, address jxd, address lpd) external onlyOwner {\n        lpPool = p;\n        c_jx = IDividendPayingToken(jxd);\n        c_lp = IDividendPayingToken(lpd);\n        isExcludedFromFees[jxd] = true;\n        isExcludedFromFees[p] = true;\n    }\n\n    function initLPAmount(address[] calldata addrs, uint256 lpAmount) external onlyOwner {\n        uint256 len = addrs.length;\n        for(uint256 i; i \u003c len; ++i) {\n            userLPInfos[addrs[i]].lpAmountTotalRecord = lpAmount;\n            userLPInfos[addrs[i]].lpAmountLocked = lpAmount;\n        }\n    }\n    function updateLPAmount(address addr, uint256 lpAmountTotalRecord, uint256 lpAmountLocked) external onlyOwner {\n        userLPInfos[addr].lpAmountTotalRecord = lpAmountTotalRecord;\n        userLPInfos[addr].lpAmountLocked = lpAmountLocked;\n    }\n    function addLPAmount(address addr, uint256 amount) external {\n        require(lpPool == msg.sender, \"invalid msgsender\");\n        userLPInfos[addr].lpAmountTotalRecord += amount;\n    }\n\n    function subLPAmount(address addr, uint256 amount) external {\n        require(lpPool == msg.sender, \"invalid msgsender\");\n        checkUserLPinfo(addr, amount);\n        userLPInfos[addr].lpAmountTotalRecord -= amount;\n    }\n\n    function getRealTransferAmount(address from, uint256 amount) public view returns(uint256) {\n        uint256 balance = balanceOf(from);\n        uint256 maxTransferAmount;\n\n        if (balance \u003e minRemainAmount) {\n            maxTransferAmount = balance - minRemainAmount;\n        }else{\n            return 0;\n        }\n\n        if (maxTransferAmount \u003e amount) {\n            return amount;\n        }else{\n            return maxTransferAmount;\n        }\n    }\n\n    function _transfer(address from, address to, uint256 amount) internal override {\n        if(from == address(this) || to == address(this)) {\n            super._transfer(from, to, amount);\n            return;\n        }\n        uint256 realTransferAmount = getRealTransferAmount(from, amount);\n\n        bool takeFee = false;\n        if(from == usdtPair){\n            uint256 lr = irl(realTransferAmount);\n            if (lr \u003e 0) {\n                checkUserLPinfo(to, lr);\n                userLPInfos[to].lpAmountTotalRecord -= lr;\n            }else{\n                require(block.timestamp \u003e= tradingEnabledTimestampWhiteList, \"not open w\");\n                takeFee = true;\n            }\n        }else if(to == usdtPair){\n            uint256 la = ial(realTransferAmount);\n            if (la \u003e 0) {\n                userLPInfos[from].lpAmountTotalRecord += la;\n            }else{\n                require(block.timestamp \u003e= tradingEnabledTimestampWhiteList, \"not open w\");\n                takeFee = true;\n            }\n        }\n\n        if(isExcludedFromFees[from] || isExcludedFromFees[to]) {\n            takeFee = false;\n        }\n\n        if(takeFee){\n            pba(from, to, realTransferAmount);\n        }else{\n            super._transfer(from, to, realTransferAmount);\n        }\n\n        if(!isExcludedFromFees[to] \u0026\u0026 to != usdtPair){\n            require(maxHoldAmount \u003e= balanceOf(to), \"max hold\");\n        }\n\n        if (balanceOf(address(this)) \u003e= dividendAtAmount \u0026\u0026 lastTimeDividend+minPeriod \u003c= block.timestamp) {\n            distribute(distributorGas);\n        }\n    }\n\n    function distribute(uint256 gas) public {\n        uint256 contractBalance = balanceOf(address(this));\n        uint256 holderCount = c_nft.totalSupply();\n        if (holderCount \u003c 3) return;\n\n        uint256 gasUsed;\n        uint256 gasLeft = gasleft();\n        uint256 iterations;\n        uint256 totalPoint = 57+holderCount;\n        uint256 ci = currentIndex;\n\n        while (gasUsed \u003c gas \u0026\u0026 iterations \u003c holderCount) {\n            if (ci \u003e= holderCount) {\n                ci = 0;\n            }\n\n            address curAddr = c_nft.ownerOf(ci);\n            uint256 point = 1;\n            if(ci \u003c 3){\n                point = 20;\n            }else if(!holdEnoughLP(curAddr)) {\n                point = 0;\n            }\n\n            if(point != 0) {\n                uint256 amount = contractBalance * point/totalPoint;\n                if(maxHoldAmount \u003e= balanceOf(curAddr) + amount ) {\n                    super._transfer(address(this), curAddr, amount);\n                    nftReward[curAddr] += amount;\n                }\n            }\n            \n            gasUsed += gasLeft - gasleft();\n            gasLeft = gasleft();\n            ++ci;\n            ++iterations;\n        }\n        currentIndex = ci;\n        lastTimeDividend = block.timestamp;\n    }\n\n    function holdEnoughLP(address addr) public view returns(bool) {\n        uint256 lpBalance = IPancakePair(usdtPair).balanceOf(addr);\n        (uint256 rOther, , ) = getReserves();\n\n        uint256 t = IPancakePair(usdtPair).totalSupply();\n        return lpBalance*rOther \u003e= t*minHoldLP1500;\n    }\n\n    function pba(address from, address to, uint256 realTransferAmount) private {\n        _subSenderBalance(from, realTransferAmount);\n        require(block.timestamp \u003e tradingEnabledTimestampNormal, \"not open\");\n        if(block.timestamp \u003c= tradingEnabledTimestampNormal + 9){\n            unchecked{\n                uint256 feeAmount = realTransferAmount*99/100;\n                _addReceiverBalance(from, deadAddress, feeAmount);\n                _addReceiverBalance(from, to, realTransferAmount - feeAmount);\n            }\n            return;\n        }\n        if(from == usdtPair){\n            uint256 feeAmount = realTransferAmount/100;\n            _addReceiverBalance(from, address(c_jx), feeAmount);\n            c_jx.distributeDividends(feeAmount);\n            _addReceiverBalance(from, address(this), feeAmount);\n            _addReceiverBalance(from, to, realTransferAmount - 2*feeAmount);\n            return;\n        }\n        uint256 feeAmount = realTransferAmount/50;\n        _addReceiverBalance(from, address(this), feeAmount);\n        uint256 liquidity = swapAndLiquify(feeAmount);\n        c_lp.distributeDividends(liquidity);\n        _addReceiverBalance(from, to, realTransferAmount - feeAmount);\n    }\n\n    function swapAndLiquify(uint256 contractTokenBalance) private returns(uint256) {\n        uint256 half = contractTokenBalance/2;\n        uint256 otherHalf = contractTokenBalance - half;\n        uint256 usdtAmount = swapTokensForUSDT(half);\n        return addLiquidity(otherHalf, usdtAmount);\n    }\n\n    function swapTokensForUSDT(uint256 tokenAmount) private returns(uint256) {\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = usdt;\n\n        uint256[] memory amounts = uniswapV2Router.swapExactTokensForTokens(\n            tokenAmount,\n            0,\n            path,\n            address(tempUSDTPool),\n            block.timestamp\n        );\n        IERC20(usdt).transferFrom(address(tempUSDTPool), address(this), amounts[1]);\n        return amounts[1];\n    }\n\n    function addLiquidity(uint256 token0Amount, uint256 token1Amount) private returns(uint256 liquidity){\n        (, , liquidity) = uniswapV2Router.addLiquidity(\n            address(this),\n            usdt,\n            token0Amount,\n            token1Amount,\n            0,\n            0,\n            address(c_lp),\n            block.timestamp\n        );\n    }\n    function updateUSDTallowance() external {\n        IERC20(usdt).approve(address(uniswapV2Router), type(uint256).max);\n        tempUSDTPool.updateUSDTallowance();\n    }\n\n    function irl(uint256 amount) public view returns (uint256 liquidity){\n        (uint256 rOther, , uint256 balanceOther) = getReserves();\n        if (balanceOther \u003c= rOther) {\n            liquidity = (amount * IPancakePair(usdtPair).totalSupply())/(balanceOf(usdtPair) - amount);\n        }\n    }\n\n    function checkUserLPinfo(address to, uint256 liquidityRemoved) private view{\n        (uint256 lpAmountTotalRecord, uint256 lpAmountLocked, uint256 lpAmountReleased, uint256 lpBalance) = getUserLPInfo(to);\n        if (lpAmountLocked \u003e 0) {\n            require(lpAmountLocked \u003c= lpBalance + lpAmountReleased, \"lock lp\");\n        }\n        require(lpAmountTotalRecord \u003e= liquidityRemoved, \"remove other lp\");\n    }\n\n    function getUserLPInfo(address addr) public view returns(uint256 lpAmountTotalRecord, uint256 lpAmountLocked, uint256 lpAmountReleased, uint256 lpBalance) {\n        lpAmountTotalRecord = userLPInfos[addr].lpAmountTotalRecord;\n        lpAmountLocked = userLPInfos[addr].lpAmountLocked;\n        \n        uint256 daysAfterStart = (block.timestamp - startReleaseTime) / oneDaySeconds;\n        lpAmountReleased = lpAmountLocked * (1 + daysAfterStart) * releaseRate / 10000;\n        if(lpAmountReleased \u003e lpAmountLocked) {\n            lpAmountReleased = lpAmountLocked;\n        }\n        lpBalance = IERC20(usdtPair).balanceOf(addr);\n    }\n\n    function ial(uint256 amount) public view returns (uint256 liquidity){\n        (uint256 rOther, uint256 rThis, uint256 balanceOther) = getReserves();\n        uint256 amountOther;\n        if (rOther \u003e 0 \u0026\u0026 rThis \u003e 0) {\n            amountOther = amount * rOther / rThis;\n        }\n        if (balanceOther \u003e= rOther + amountOther) {\n            amountOther = balanceOther - rOther;\n            liquidity = calLiquidity(amountOther, amount, rOther, rThis);\n        }\n    }\n\n    function calLiquidity(uint256 amountOther, uint256 amountThis, uint256 rOther, uint256 rThis) public view returns (uint256 liquidity) {\n        uint256 t = IPancakePair(usdtPair).totalSupply();\n        if (t == 0) {\n            liquidity = Math.sqrt(amountOther * amountThis) - 1000;\n        } else {\n            liquidity = Math.min( (amountOther*t)/rOther, (amountThis*t)/rThis );\n        }\n    }\n\n    function getReserves() public view returns (uint256 rOther, uint256 rThis, uint256 balanceOther){\n        (uint256 r0, uint256 r1,) = IPancakePair(usdtPair).getReserves();\n        if (usdt \u003c address(this)) {\n            rOther = r0;\n            rThis = r1;\n        } else {\n            rOther = r1;\n            rThis = r0;\n        }\n        balanceOther = IERC20(usdt).balanceOf(usdtPair);\n    }\n}"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Ownable {\n    address private _owner;\n\n    constructor () {\n        _owner = msg.sender;\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        _owner = newOwner;\n    }\n}"}}