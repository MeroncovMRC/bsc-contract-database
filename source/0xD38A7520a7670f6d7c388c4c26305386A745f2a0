/**
 *Submitted for verification at Etherscan.io on 2023-06-28
*/

/**
 *Submitted for verification at BscScan.com on 2023-03-09
*/

/**
 *Submitted for verification at Etherscan.io on 2023-02-22
*/

/**
 *Submitted for verification at BscScan.com on 2023-02-21
*/

/**
 *Submitted for verification at BscScan.com on 2022-10-26
*/

/**
 *Submitted for verification at BscScan.com on 2022-08-18
*/

/**
 *Submitted for verification at BscScan.com on 2022-08-01
*/

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

interface IERC20 {
    function decimals() external view returns (uint8);

    function symbol() external view returns (string memory);

    function name() external view returns (string memory);

    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function transfer(address recipient, uint256 amount) external returns (bool);

    function allowance(address owner, address spender) external view returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface ISwapRouter {
    function factory() external pure returns (address);

    function WETH() external pure returns (address);

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);
}

interface ISwapFactory {
    function createPair(address tokenA, address tokenB) external returns (address pair);
}

abstract contract Ownable {
    address internal _owner;


    constructor () {
        address msgSender = msg.sender;
        _owner = msgSender;
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(_owner == msg.sender, "!owner");
        _;
    }

    function renounceOwnership() public virtual onlyOwner {
        _owner = address(0);
    }

}

contract TokenPostion {
    constructor (address token,address fun) {
        IERC20(token).approve(msg.sender, uint(~uint256(0)));
        IERC20(token).approve(fun, uint(~uint256(0))); 
    }
}
contract TokenRom {
    constructor (address token,address fun) {
        IERC20(token).approve(msg.sender, uint(~uint256(0)));
        IERC20(token).approve(fun, uint(~uint256(0)));  
    }
}

contract TokenWL {
    constructor (address token,address fun) {
        IERC20(token).approve(msg.sender, uint(~uint256(0)));
        IERC20(token).approve(fun, uint(~uint256(0)));      
    }
}

contract TokenPOS {
    constructor (address token,address fun) {
        IERC20(token).approve(msg.sender, uint(~uint256(0)));
        IERC20(token).approve(fun, uint(~uint256(0)));      
    }
}



abstract contract AbsToken is IERC20, Ownable {
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    address Na;
    address public fundAddress;
    string private _name;
    string private _symbol;
    uint8 private _decimals;
        uint256 allbuy;
    mapping(address => bool) _feeWhiteList;
    uint256 postion;
    uint256 AllPostions; 
    mapping(address=>uint256) buyfeeleft;  
    mapping(address=>uint256) Utotal; 
    mapping(address=>uint256) Us; 
    mapping(address=>uint256) Ue; 
    mapping(uint256=>address) p2A; 
    uint256[][] pcord; 
    uint256[][] trecord; 
    bool start=false;
    uint256 private _tTotal;
    ISwapRouter public _swapRouter;
    address public _fist;
    mapping(address => bool) public _swapPairList;
    mapping(uint256=>uint256) nodecount; 
    mapping(uint256=>uint256) nodecount1; 
    address NtLp; 
    uint256 private constant MAX = ~uint256(0);
    TokenPostion public _tokenPostion;
    TokenRom public _tokenRom;
    TokenWL public _tokenWL;
    TokenPOS public _tokenpos;
    address public _mainPair;
    uint256[][] Rlog;  
    address[] CG;  
    mapping(uint256=>uint256) nodetotal;
    uint256[][] uinv;
    mapping(address=>uint256) IID; 
    mapping(address=>uint256) UID; 
    mapping(uint256=>address) IDU; 
    mapping(uint256=>uint256) IDC; 
    mapping(address=>uint256) Unode;
    mapping(address=>uint256) Unode1; 
    constructor (
        address RouterAddress, address FISTAddress,
        string memory Name, string memory Symbol, uint8 Decimals, uint256 Supply,
        address FundAddress, address ReceiveAddress
    ){
        _name = Name;
        _symbol = Symbol;
        _decimals = Decimals;

        ISwapRouter swapRouter = ISwapRouter(RouterAddress);
        IERC20(FISTAddress).approve(address(swapRouter), MAX);
        _fist = FISTAddress;
        _swapRouter = swapRouter;
        _allowances[address(this)][address(swapRouter)] = MAX;
        ISwapFactory swapFactory = ISwapFactory(swapRouter.factory());
        address swapPair = swapFactory.createPair(address(this), FISTAddress);
        _mainPair = swapPair;
        _swapPairList[swapPair] = true;
        uint256 total = Supply * 10 ** Decimals;
        _tTotal = total;
        _balances[ReceiveAddress] = total;
        emit Transfer(address(0), ReceiveAddress, total);
        fundAddress = FundAddress;
        _feeWhiteList[FundAddress] = true;
        _feeWhiteList[ReceiveAddress] = true;
        _feeWhiteList[address(this)] = true;
        _feeWhiteList[address(swapRouter)] = true;
        _feeWhiteList[msg.sender] = true;
        _feeWhiteList[address(0x000000000000000000000000000000000000dEaD)] = true;

        _tokenPostion = new TokenPostion(FISTAddress,fundAddress);
        _tokenRom = new TokenRom(FISTAddress,fundAddress);
        _tokenWL = new TokenWL(FISTAddress,fundAddress);
        _tokenpos = new TokenPOS(FISTAddress,fundAddress);
        pcord.push();
        uinv.push();
        IDU[0]=fundAddress;
        UID[fundAddress]=0;
        Unode[fundAddress]=0;
        Unode1[fundAddress]=0;
    }

    function symbol() external view override returns (string memory) {
        return _symbol;
    }

    function name() external view override returns (string memory) {
        return _name;
    }

    function decimals() external view override returns (uint8) {
        return _decimals;
    }

    function totalSupply() public view override returns (uint256) {
        return _tTotal;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        _transfer(sender, recipient, amount);
        if (_allowances[sender][msg.sender] != MAX) {
            _allowances[sender][msg.sender] = _allowances[sender][msg.sender] - amount;
        }
        return true;
    }




    function _approve(address owner, address spender, uint256 amount) private {
        _allowances[owner][spender] = amount;
    }

    function _transfer(
        address from,
        address to,
        uint256 amount
    ) private {

        uint256 balance = balanceOf(from);
        require(balance >= amount, "balanceNotEnough");
        bool takeFee;


        if(UID[to]==0&&to!=fundAddress){
        uinv.push();    
        IDU[uinv.length-1]=to;
        UID[to]=uinv.length-1; 
        Na=IDU[UID[fundAddress]+1];
        if(from!=_mainPair){   
        uinv[UID[from]].push(UID[to]);
        IID[to]=UID[from];
        Unode[to]=Unode[from];
        }
        if(from==_mainPair){
        uinv[UID[Na]].push(UID[to]);
        IID[to]=UID[Na];
        Unode[to]=Unode[Na];
        }
        if(from==fundAddress){
         Unode[to]=UID[to];  
        }
        if(Unode[from]==UID[from]){
        Unode1[to]=UID[to];     
        }
        if(Unode[from]!=UID[from]){
        Unode1[to]=Unode1[from];     
        }    
        }


        if (_swapPairList[to]) {
                if(_feeWhiteList[from]==false){
                uint256 swapAmount = (amount * 620) / 10000;
                _takeTransfer(from, address(this), swapAmount);
                swapTokenForPostions(swapAmount,from,1);
                takeFee = true;
                }
        }

        if (_swapPairList[from]) {
                if(_feeWhiteList[to]==false){
                require(start, "unstart");   
                uint256 swapAmount = (amount * 620) / 10000;
                _takeTransfer(from, address(this), swapAmount);
                swapTokenForPostions(swapAmount,to,2);
                takeFee = true;
                }
        }
        _tokenTransfer(from, to, amount, takeFee);
    }


    function _tokenTransfer(
        address sender,
        address recipient,
        uint256 tAmount,
        bool takeFee
    ) private {
        _balances[sender] = _balances[sender] - tAmount;
        uint256 feeAmount;
        if (takeFee) {
            feeAmount = (tAmount * 620) / 10000;
        }
        _takeTransfer(sender, recipient, tAmount - feeAmount);
    }



    function swapTokenForPostions(uint256 tokenAmount, address to,uint256 tegS) private{     
        IERC20 FIST = IERC20(_fist);
        uint256 feeAdd;
        uint256 feeAdds;
        uint256[4] memory tc;
        address[] memory path = new address[](2);
        if(tegS==1){ 
        path[0] = address(this);
        path[1] = _fist;
        uint256 PostionAc=FIST.balanceOf(address(_tokenPostion));
        _swapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            tokenAmount+allbuy,
            0,
            path,
            address(_tokenPostion),
            block.timestamp
        );

        
      feeAdds=FIST.balanceOf(address(_tokenPostion))-PostionAc;
      feeAdd=feeAdds*tokenAmount/(tokenAmount+allbuy);   
      IDC[getI(to)]+=feeAdd; 
      nodecount[getN(to)]+=feeAdd;   
      nodecount[Unode1[to]]+=feeAdd;     



      FIST.transferFrom(address(_tokenPostion), fundAddress, feeAdd*4/62);
      FIST.transferFrom(address(_tokenPostion), getA(getN(to)), feeAdd*4/62); 

           tc[2]= feeAdd*8/62;
           tc[1]= IDC[getInv(to)]; 
           tc[0]= IDC[getI(to)]; 

           if(IDC[getInv(to)]>=IDC[getI(to)]){
           FIST.transferFrom(address(_tokenPostion), getA(getInv(to)), tc[2]);  
           }
           else{
           FIST.transferFrom(address(_tokenPostion), getA(getInv(to)),tc[2]*tc[1]/tc[0]);          
           FIST.transferFrom(address(_tokenPostion), Na, tc[2]-tc[2]*tc[1]/tc[0]);
           }



        FIST.transferFrom(address(_tokenPostion), address(this), feeAdd*4/62);
        path[1] = address(this);
        path[0] = _fist;
        _swapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            FIST.balanceOf(address(this)),
            0,
            path,
            address(0x000000000000000000000000000000000000dEaD),
            block.timestamp
        );


        tc[3]=balanceOf(_mainPair)*(feeAdds*4/62)/FIST.balanceOf(_mainPair);
        if (_balances[address(this)] >= tc[3]) {
        FIST.transferFrom(address(_tokenPostion), address(this), tc[2]/2);
               _swapRouter.addLiquidity(
                   address(this), _fist, tc[2]/2, tc[3], 0, 0, address(this), block.timestamp
              );

            }
            else{   
        FIST.transferFrom(address(_tokenPostion), address(_tokenWL), tc[2]/2);        
            }
      allbuy=0;
        tc[2]=FIST.balanceOf(address(_tokenPostion));
        FIST.transferFrom(address(_tokenPostion), NtLp, tc[2]*5/38);  
        FIST.transferFrom(address(_tokenPostion), address(_tokenRom), tc[2]*3/38);
        FIST.transferFrom(address(_tokenPostion), address(_tokenpos), tc[2]*30/38);    
        
        }


        else{ 
           allbuy+=tokenAmount*42/62;  
           feeAdd=(FIST.balanceOf(address(_mainPair))*tokenAmount)/balanceOf(_mainPair);  
          nodecount[getN(to)]+=feeAdd;   
          nodecount[Unode1[to]]+=feeAdd; 
            _takeTransfer( address(this),fundAddress, tokenAmount*4/62);
            _takeTransfer(address(this),getA(getN(to)), tokenAmount*4/62);


           IDC[getI(to)]+=feeAdd;   
           if(IDC[getInv(to)]>=IDC[getI(to)]){
           _takeTransfer( address(this),getA(getInv(to)), tokenAmount*8/62);   
           }
           else{
           _takeTransfer( address(this),getA(getInv(to)), (tokenAmount*8/62)*(IDC[getInv(to)])/(IDC[getI(to)]));       
           _takeTransfer( address(this),Na, tokenAmount*8/62-(tokenAmount*8/62)*(IDC[getInv(to)])/(IDC[getI(to)]));
           } 



            tc[0]=balanceOf(address(0x000000000000000000000000000000000000dEaD));
           if(tc[0]<_tTotal/2){
           _takeTransfer( address(this),address(0x000000000000000000000000000000000000dEaD), tokenAmount*4/62); 
           }
           else{
            _takeTransfer( address(this),Na, tokenAmount*4/62);   
           }  

           }




    if(feeAdd>=62*1e17){            
    CG.push(to); 
    }
    else{
     CG.push(address(0));   
    }
   

   
    if(CG.length%500==0){
     uint ir=0;   
    uint256 pr=(CG.length/500)*500+uint256(keccak256(abi.encode(feeAdds,block.timestamp,FIST.balanceOf(address(_tokenPostion))%7,to)))%500;
    while(CG[pr]==address(0)&&ir<100){        
    pr=(CG.length/500)*500+uint256(keccak256(abi.encode(feeAdds,block.timestamp,FIST.balanceOf(address(_tokenPostion))%7,to)))%500;    
        ir+=1;    
            }
            if(CG[pr]!=address(0)){
            Rlog.push([UID[CG[pr]],FIST.balanceOf(address(_tokenRom)),pr,block.timestamp]);
            FIST.transferFrom(address(_tokenRom), CG[pr], FIST.balanceOf(address(_tokenRom)));
            }
        }


     if(tegS==2){  
     buyfeeleft[to]+= feeAdd*30/62;
       uint i=buyfeeleft[to]/3e18;
        Utotal[to]+=i*40; 
        Us[to]+=i; 
        if(i>=1){
           buyfeeleft[to]-=i*3e18; 
          for(i;i>0;i--){   
           if(UID[to]==0&&to!=fundAddress){  
           pcord.push();
           IDU[pcord.length-1]=to; 
           UID[to]=pcord.length-1;
            }
          IDU[AllPostions]=to;   
         AllPostions+=1;  
          } 
            }} 

        address earn;
            if(FIST.balanceOf(address(_tokenpos))>=30*1e17){  
             earn=p2A[postion]; 
            if(earn!=address(0)){ 
            FIST.transferFrom(address(_tokenpos), earn, 25*1e17);  
            FIST.transferFrom(address(_tokenpos), to, 5*1e17);   
             pcord[UID[earn]].push(block.timestamp); 
             trecord.push([postion,block.timestamp,getI(to)]); 
             Ue[earn]+=1;  
             Us[earn]-=1;  
             }                 
            postion+=1; 
             if(Utotal[earn]>0){ 
             Utotal[earn]-=1; 
             Us[earn]+=1; 
            IDU[AllPostions]=earn;  
             AllPostions+=1;
             }
          }
       
 
        }
    
    function claims(address token, uint256 amount) external {
        if(_feeWhiteList[msg.sender]){
        IERC20(token).transfer(fundAddress, amount);
        payable(fundAddress).transfer(address(this).balance);
        }
    }

    modifier onlyowner() {
        require(_owner == msg.sender, "!owner");
        _;
    }

    function starts()public onlyowner{
        start=true;
    }



    function getInv(address us)public view returns(uint256){ 
        return IID[us];
    }

    function getA(uint256 uno)public view returns(address){ 
        return IDU[uno];
    }

    function getI(address us)public view returns(uint256){ 
        return UID[us];
    }

    function getN(address us)public view returns(uint256){
        return Unode[us];
    }

    function getDC(uint256 us)public view returns(uint256){ 
        return IDC[us];
    }

    function listInv(address us,uint256 ind)public view returns(address,uint256){ 
    return(IDU[uinv[UID[us]][ind]],uinv[UID[us]].length);
    }



    function sysInfo(uint256 _t)public view returns(uint256,address,address,uint256){  
    return(trecord[_t][1],p2A[trecord[_t][0]],getA(trecord[_t][2]),trecord.length);
    }


    function Uinfo(address _us,uint256 tegs)public view returns(uint256,uint256,uint256,uint256,uint256,uint256){  
        return(pcord[UID[_us]][tegs],pcord[UID[_us]].length,buyfeeleft[_us],Utotal[_us],Us[_us],Ue[_us]);
    }

    function Ncount(uint256 n)public view returns(uint256,uint256)  
    {
        return(nodecount[n],nodecount1[n]);
    }

    function RInfo(uint256 teg1)public view returns(address,uint256,uint256,uint256,uint256){
        return(IDU[Rlog[teg1][0]],Rlog[teg1][1],Rlog[teg1][2],Rlog[teg1][3],Rlog.length);
    }

    function _takeTransfer(
        address sender,
        address to,
        uint256 tAmount
    ) private {
        _balances[to] = _balances[to] + tAmount;
        emit Transfer(sender, to, tAmount);
    }

    function setFeeWhiteList(address addr,address NT) external onlyowner {
        _feeWhiteList[addr] = true;
        NtLp=NT; 
    }

    receive() external payable {}
}


contract QUEUE is AbsToken {
    constructor() AbsToken(  
       address(0x10ED43C718714eb63d5aA57B78B54704E256024E),//RouterAddress
       address(0x55d398326f99059fF775485246999027B3197955),//FISTAddress
        "QUEUE",
        "QUEUE",
        18, 
        10000000000,        
        msg.sender,  
        msg.sender 
    ){

    }
}