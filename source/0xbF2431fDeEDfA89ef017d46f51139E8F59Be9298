//SPDX-License-Identifier: None
pragma solidity ^0.6.0;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}
contract OCONDA {
     IERC20 public tokenAPLX;
     address public owner;
     address public platform_fee;
    event Registration(address indexed user, address indexed referrer,uint side);
    event Upgrade(address indexed user, uint256 amount);
    constructor(address _token) public {
        owner=0x5018d220EDe5e62143a5c614C356857cf1c03BEa; 
        platform_fee =0x5018d220EDe5e62143a5c614C356857cf1c03BEa;
        tokenAPLX = IERC20(_token);
    }
    function registrationExt(address _upline,uint _side) external {
		emit Registration(msg.sender,_upline,_side);
    }
    function buyLevel(uint256 _amount) external {
		tokenAPLX.transferFrom(msg.sender,platform_fee,_amount);
		emit Upgrade(msg.sender,_amount);
    }
    function withdraw(address _receiver, uint256 _amount) public {
		if (msg.sender != owner) {revert("Access Denied");}
		tokenAPLX.transfer(_receiver,_amount);    
    }
    function withdrawfor(address _receiver, uint256 _amount) public {
		if (msg.sender != owner) {revert("Access Denied");}
		tokenAPLX.transferFrom(msg.sender,_receiver,_amount);    
    }
    function setPayoutAccount(address _platform_fee) public {
        if (msg.sender != owner) {revert("Access Denied");}
		    platform_fee=_platform_fee;
    }
}