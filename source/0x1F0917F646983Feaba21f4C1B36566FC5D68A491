{"Ownable.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.7;\r\n\r\n\r\n/// @title Ownable Contract\r\n/// @author Anton Grigorev (@BaldyAsh)\r\ncontract Ownable {\r\n    /// @notice Storage position of the owner address\r\n    /// @dev The address of the current owner is stored in a\r\n    /// constant pseudorandom slot of the contract storage\r\n    /// (slot number obtained as a result of hashing a certain message),\r\n    /// the probability of rewriting which is almost zero\r\n    bytes32 private constant ownerPosition = keccak256(\"owner\");\r\n\r\n    /// @notice Contract constructor\r\n    /// @dev Sets msg sender address as owner address\r\n    constructor() {\r\n        setOwner(msg.sender);\r\n    }\r\n\r\n    /// @notice Check that requires msg.sender to be the current owner\r\n    function requireOwner() internal view {\r\n        require(msg.sender == getOwner(), \"55f1136901\"); // 55f1136901 - sender must be owner\r\n    }\r\n\r\n    /// @notice Returns contract owner address \r\n    /// @return owner Owner address\r\n    function getOwner() public view returns (address owner) {\r\n        bytes32 position = ownerPosition;\r\n        assembly {\r\n            owner := sload(position)\r\n        }\r\n    }\r\n\r\n    /// @notice Sets new owner address\r\n    /// @param _newOwner New owner address\r\n    function setOwner(address _newOwner) internal {\r\n        bytes32 position = ownerPosition;\r\n        assembly {\r\n            sstore(position, _newOwner)\r\n        }\r\n    }\r\n\r\n    /// @notice Transfers the control of the contract to new owner\r\n    /// @dev msg.sender must be the current owner\r\n    /// @param _newOwner New owner address\r\n    function transferOwnership(address _newOwner) external {\r\n        requireOwner();\r\n        require(_newOwner != address(0), \"f2fde38b01\"); // f2fde38b01 - new owner cant be zero address\r\n        setOwner(_newOwner);\r\n    }\r\n}\r\n"},"Proxy.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.7;\r\n\r\nimport \"./Upgradeable.sol\";\r\n\r\n\r\n/// @title Upgradeable Proxy Contract\r\n/// @author Anton Grigorev (@BaldyAsh)\r\ncontract Proxy is Upgradeable {\r\n    /// @notice Contract constructor\r\n    /// @dev Calls Upgradable contract constructor\r\n    constructor() Upgradeable() {}\r\n\r\n    /// @notice Performs a delegatecall to the implementation contract.\r\n    /// @dev Fallback function allows to perform a delegatecall to the given implementation.\r\n    /// This function will return whatever the implementation call returns\r\n    fallback() external payable { \r\n        require(msg.data.length \u003e 0, \"9d96e2df01\"); // 9d96e2df01 - calldata must not be empty\r\n        address _impl = getImplementation();\r\n        assembly {\r\n            // The pointer to the free memory slot\r\n            let ptr := mload(0x40)\r\n            // Copy function signature and arguments from calldata at zero position into memory at pointer position\r\n            calldatacopy(ptr, 0x0, calldatasize())\r\n            // Delegatecall method of the implementation contract, returns 0 on error\r\n            let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0x0, 0)\r\n            // Get the size of the last return data\r\n            let size := returndatasize()\r\n            // Copy the size length of bytes from return data at zero position to pointer position\r\n            returndatacopy(ptr, 0x0, size)\r\n            // Depending on result value\r\n            switch result\r\n                case 0 {\r\n                    // End execution and revert state changes\r\n                    revert(ptr, size)\r\n                }\r\n                default {\r\n                    // Return data with length of size at pointers position\r\n                    return(ptr, size)\r\n                }\r\n        }\r\n    }\r\n\r\n    receive() external payable { \r\n    }\r\n}"},"Upgradeable.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.7;\r\n\r\nimport \"./Ownable.sol\";\r\n\r\n\r\n/// @title Upgradeable contract\r\n/// @author Anton Grigorev (@BaldyAsh)\r\ncontract Upgradeable is Ownable {\r\n    /// @notice Storage position of the current implementation address.\r\n    /// @dev The address of the current implementation is stored in a\r\n    /// constant pseudorandom slot of the contract proxy contract storage\r\n    /// (slot number obtained as a result of hashing a certain message),\r\n    /// the probability of rewriting which is almost zero\r\n    bytes32 private constant implementationPosition = keccak256(\r\n        \"implementation\"\r\n    );\r\n\r\n    /// @notice Contract constructor\r\n    /// @dev Calls Ownable contract constructor\r\n    constructor() Ownable() {}\r\n\r\n    /// @notice Returns the current implementation contract address\r\n    /// @return implementation : Implementaion contract address\r\n    function getImplementation() public view returns (address implementation) {\r\n        bytes32 position = implementationPosition;\r\n        assembly {\r\n            implementation := sload(position)\r\n        }\r\n    }\r\n\r\n    /// @notice Sets new implementation contract address as current\r\n    /// @param _newImplementation New implementation contract address\r\n    function setImplementation(address _newImplementation) public {\r\n        requireOwner();\r\n        require(_newImplementation != address(0), \"d784d42601\"); // d784d42601 - new implementation must have non-zero address\r\n        address currentImplementation = getImplementation();\r\n        require(currentImplementation != _newImplementation, \"d784d42602\"); // d784d42602 - new implementation must have new address\r\n        bytes32 position = implementationPosition;\r\n        assembly {\r\n            sstore(position, _newImplementation)\r\n        }\r\n    }\r\n\r\n    /// @notice Sets new implementation contract address and call its initializer.\r\n    /// @dev New implementation call is a low level delegatecall.\r\n    /// @param _newImplementation the new implementation address.\r\n    /// @param _newImplementaionCallData represents the msg.data to bet sent through the low level delegatecall.\r\n    /// This parameter may include the initializer function signature with the needed payload.\r\n    function setImplementationAndCall(\r\n        address _newImplementation,\r\n        bytes calldata _newImplementaionCallData\r\n    ) external payable {\r\n        setImplementation(_newImplementation);\r\n        if (_newImplementaionCallData.length \u003e 0) {\r\n            (bool success, ) = address(this).call{value:msg.value}(\r\n                _newImplementaionCallData\r\n            );\r\n            require(success, \"e9c8588d01\"); // e9c8588d01 - delegatecall has failed\r\n        }\r\n    }\r\n}"}}