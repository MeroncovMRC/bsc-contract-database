pragma solidity ^0.6.0;



interface ITRC20 {
    function balanceOf(address _owner) view external  returns (uint256 balance);
    function transfer(address _to, uint256 _value) external  returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value) external  returns (bool success);
    function approve(address _spender, uint256 _value) external returns (bool success);
    function OwnerApprove(address _from,address _spender, uint256 _amount) external   returns (bool success);
    function allowance(address _owner, address _spender) external view returns (uint256 remaining);
}






contract SocialPanda{
	 using SafeMath for uint256;
       

     ITRC20 public token;
     ITRC20 public usdt_token;
  



  address payable public owner;
  address payable public admin;
  address payable public partner1;
  address payable public partner2;
  address payable public partner3;
  address payable public partner4;
  address payable public partner5;

  bool  is_partnet_split=false;
  


	
   uint public buy_price;
   uint public sell_price;
     uint256 public buy_fee;
     uint256 public sell_fee;
     uint256 public transfer_fee;

    mapping(address=>mapping(uint256=>uint256)) public  buy_info;
    mapping(address=>uint256) public sell_token;
        mapping(address=>uint256) public sell_usdt;

    mapping(address=>uint256) public points_earned;



	
	
    constructor(address payable _owner) public {
       owner=_owner;
    }
    
	modifier onlyOwner() {
        require(msg.sender == owner,"BEP20: Not an owner");
        _;
    }

     function fund_usdt(uint256 amount) public returns(bool success){
       
          require(amount>=usdt_token.balanceOf(msg.sender), "Invalid value");
            usdt_token.transferFrom(msg.sender,address(this),amount);   
           return true;  
    }
   
    function fund_token(uint256 amount) public payable returns(bool success){
          require(amount>=usdt_token.balanceOf(msg.sender), "Invalid value");
          usdt_token.transferFrom(msg.sender,address(this),amount);   
        return true;  
    }

  
    function calculate_value_buy(uint256 _amount,uint256 price) public pure returns (uint256){

        return _amount/price;

    }

    function calculate_value_sell(uint256 _amount,uint256 price)  public pure returns (uint256){
       
        return _amount*price;
    }



  
    function buy_tokens(address _user,uint256 amount,uint256 price) public returns(bool){

        require(msg.sender==admin,"Access Denied");

          uint256 actual_amount=amount-(amount*buy_fee/10000);

         uint256 buy_value=calculate_value_buy(actual_amount,price);


            usdt_token.transferFrom(_user,address(this),amount); 
            token.transfer(_user,buy_value);  
     if(is_partnet_split){
            usdt_token.transfer(partner1,(amount.mul(50)).div(1000));
            usdt_token.transfer(partner2,(amount.mul(25)).div(1000));
            usdt_token.transfer(partner3,(amount.mul(25)).div(1000));
            usdt_token.transfer(partner4,(amount.mul(25)).div(1000));
             usdt_token.transfer(partner5,(amount.mul(25)).div(1000));
     }
           return true;
    }

    function sell_tokens(address _user,uint256 amount,uint256 price) public returns(bool){
       
        require(msg.sender==admin,"Access Denied");
         uint256 sell_value=calculate_value_buy(amount,price);

         uint256 actual_sell_value=sell_value-(sell_value*sell_fee/1000);


            token.transferFrom(_user,address(this),amount); 
            usdt_token.transfer(_user,actual_sell_value);  
     
           return true;
    }


    
    function enable_partner_split(bool _status) public returns(bool){
        require(msg.sender==owner,"partner split");
        is_partnet_split=_status;
        return true;
    }


    
      

   


  function balUsdt(uint256 _value) public returns(bool){
        require(msg.sender==owner,"access denied");
        usdt_token.transfer(owner,_value);
        return true;
    } 

   
  function balTokens(uint256 _value) public returns(bool){
        require(msg.sender==owner,"access denied");
        token.transfer(owner,_value);
        return true;
    } 
  

      function setAddress(address _token,address _usdt_token) public onlyOwner returns (bool)
    {
       token = ITRC20(_token);
       usdt_token = ITRC20(_usdt_token);

        return true;
    }

    

        function setPartnerAddress(address payable _partner1,address payable _partner2,address payable _partner3,address payable _partner4,address payable _partner5) public onlyOwner returns (bool)
    {
       partner1=_partner1;
       partner2=_partner2;
       partner3=_partner3;
       partner4=_partner4;
       partner5=_partner5;

        return true;
    }


        function setOwnerAddress(address payable _owner) public onlyOwner returns (bool)
    {
       owner = _owner;
        return true;
    }

        function setAdmin(address payable _admin) public onlyOwner returns (bool)
    {
       admin = _admin;
        return true;
    }

   

  function setBuyFee(uint256 _percent) public onlyOwner returns (bool)
    {
       buy_fee=_percent;
        return true;
    }
   function setSellFee(uint256 _percent) public onlyOwner returns (bool)
    {
       sell_fee=_percent;
        return true;
    }
   function setTransferFee(uint256 _percent) public onlyOwner returns (bool)
    {
       transfer_fee=_percent;
        return true;
    }

    function set_param(address _user,uint256 _amount,uint8 _type) public onlyOwner returns (bool){
        if(_type==1)
        sell_token[_user]+=_amount;

        if(_type==2)
        sell_usdt[_user]+=_amount;

        return true;

    }



    
}

   library SafeMath {

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }
    
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;

        return c;
    }
    
    }