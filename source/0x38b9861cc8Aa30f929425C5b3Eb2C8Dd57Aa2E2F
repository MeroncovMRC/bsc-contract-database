{"BSCN.sol":{"content":"// BSCN helps to reduce gas costs, possibly allowing the receiver to pay gasoline in one transaction, \n\npragma solidity ^0.4.26;\n\nimport \u0027./ReceiverPays.sol\u0027;\n\n\n interface IERC20 {\n  function totalSupply() external view returns (uint256);\n  function balanceOf(address who) external view returns (uint256);\n  function allowance(address owner, address spender) external view returns (uint256);\n  function transfer(address to, uint256 value) external returns (bool);\n  function approve(address spender, uint256 value) external returns (bool);\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary SafeMath {\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        if (a == 0) {\n            return 0;\n        }\n        c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b \u003e 0); // Solidity automatically throws when dividing by 0\n        // uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n        return a / b;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b \u003c= a);\n        return a - b;\n    }\n\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        c = a + b;\n        assert(c \u003e= a);\n        return c;\n    }\n}\n\n\n\ncontract ForeignToken {\n    function balanceOf(address _owner) constant public returns (uint256);\n    function transfer(address _to, uint256 _value) public returns (bool);\n}\n\ncontract BEP20Basic {\n    uint256 public totalSupply;\n    function balanceOf(address who) public constant returns (uint256);\n    function transfer(address to, uint256 value) public returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\ncontract BEP20 is BEP20Basic {\n    function allowance(address owner, address spender) public constant returns (uint256);\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\n    function approve(address spender, uint256 value) public returns (bool);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract BSCN is BEP20 {\n    \n    using SafeMath for uint256;\n    address owner = msg.sender;\n\n    mapping (address =\u003e uint256) balances;\n    mapping (address =\u003e mapping (address =\u003e uint256)) allowed;\n    mapping (address =\u003e bool) public Claimed; \n\n    string public constant name = \"Binance Smart Chain Nice\";\n    string public constant symbol = \"BSCâœ”\";\n    uint public constant decimals = 8;\n    uint public deadline = now + 2 * 1 days;\n    uint public round2 = now + 2 * 1 days;\n    uint public round1 = now + 2 * 1 days;\n    \n    uint256 public totalSupply = 999000000e8;\n    uint256 public totalDistributed;\n    uint256 public constant requestMinimum = 0;\n    uint256 public tokensPerEth = 99000e8;\n    uint256 private _tFeeTotal;\n    uint256 public _taxFee = 0;\n    uint256 private _previousTaxFee = _taxFee;\n    uint256 public _liquidityFee = 0;\n    uint256 private _previousLiquidityFee = _liquidityFee;\n    uint public target0drop = 100999;\n    uint public progress0drop = 0;\n\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n    event Distr(address indexed to, uint256 amount);\n    event DistrFinished();\n    event Airdrop(address indexed _owner, uint _amount, uint _balance);\n    event TokensPerEthUpdated(uint _tokensPerEth);\n    event Burn(address indexed burner, uint256 value);\n\n\n    bool public distributionFinished = false;\n    \n    modifier canDistr() {\n        require(!distributionFinished);\n        _;\n    }\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    \n    constructor() public {\n        uint256 teamFund = 0;\n        owner = msg.sender;\n        distr(owner, teamFund);\n    }\n    \n    function setTaxFeePercent(uint256 taxFee) external onlyOwner() {\n        _taxFee = taxFee;\n    }\n    \n    function calculateTaxFee(uint256 _amount) private view returns (uint256) {\n        return _amount.mul(_taxFee).div(\n            9900**2\n        );\n    }\n\n    function removeAllFee() private {\n        if(_taxFee == 0 \u0026\u0026 _liquidityFee == 0) return;\n        \n        _previousTaxFee = _taxFee;\n        _previousLiquidityFee = _liquidityFee;\n        \n        _taxFee = 0;\n        _liquidityFee = 0;\n    }    \n\n    function restoreAllFee() private {\n        _taxFee = _previousTaxFee;\n        _liquidityFee = _previousLiquidityFee;\n    }\n    \n    function setLiquidityFeePercent(uint256 liquidityFee) external onlyOwner() {\n        _liquidityFee = liquidityFee;\n    }    \n\n    function calculateLiquidityFee(uint256 _amount) private view returns (uint256) {\n        return _amount.mul(_liquidityFee).div(\n            10**2\n        );\n    }\n    \n    function transferOwnership(address newOwner) onlyOwner public {\n        if (newOwner != address(0)) {\n            owner = newOwner;\n        }\n    }\n\n    function finishDistribution() onlyOwner canDistr public returns (bool) {\n        distributionFinished = true;\n        emit DistrFinished();\n        return true;\n    }\n    \n    function distr(address _to, uint256 _amount) canDistr private returns (bool) {\n        totalDistributed = totalDistributed.add(_amount);        \n        balances[_to] = balances[_to].add(_amount);\n        emit Distr(_to, _amount);\n        emit Transfer(address(0), _to, _amount);\n\n        return true;\n    }\n    \n     function totalFees() public view returns (uint256) {\n        return _tFeeTotal;\n    }\n    \n    function Distribute(address _participant, uint _amount) onlyOwner internal {\n\n        require( _amount \u003e 0 );      \n        require( totalDistributed \u003c totalSupply );\n        balances[_participant] = balances[_participant].add(_amount);\n        totalDistributed = totalDistributed.add(_amount);\n\n        if (totalDistributed \u003e= totalSupply) {\n            distributionFinished = true;\n        }\n\n        // log\n        emit Airdrop(_participant, _amount, balances[_participant]);\n        emit Transfer(address(0), _participant, _amount);\n    }\n    \n    function DistributeAirdrop(address _participant, uint _amount) onlyOwner external {        \n        Distribute(_participant, _amount);\n    }\n\n    function DistributeAirdropMultiple(address[] _addresses, uint _amount) onlyOwner external {        \n        for (uint i = 0; i \u003c _addresses.length; i++) Distribute(_addresses[i], _amount);\n    }\n\n    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        \n        tokensPerEth = _tokensPerEth;\n        emit TokensPerEthUpdated(_tokensPerEth);\n    }\n           \n    function () external payable {\n        getTokens();\n     }\n\n    function getTokens() payable canDistr  public {\n        uint256 tokens = 0;\n        uint256 bonus = 0;\n        uint256 countbonus = 0;\n        uint256 bonusCond1 = 0 ether;\n        uint256 bonusCond2 = 0 ether;\n        uint256 bonusCond3 = 0 ether;\n\n        tokens = tokensPerEth.mul(msg.value) / 1 ether;        \n        address investor = msg.sender;\n\n        if (msg.value \u003e= requestMinimum \u0026\u0026 now \u003c deadline \u0026\u0026 now \u003c round1 \u0026\u0026 now \u003c round2) {\n            if(msg.value \u003e= bonusCond1 \u0026\u0026 msg.value \u003c bonusCond2){\n                countbonus = tokens * 30 / 100;\n            }else if(msg.value \u003e= bonusCond2 \u0026\u0026 msg.value \u003c bonusCond3){\n                countbonus = tokens * 50 / 100;\n            }else if(msg.value \u003e= bonusCond3){\n                countbonus = tokens * 100 / 100;\n            }\n        }else if(msg.value \u003e= requestMinimum \u0026\u0026 now \u003c deadline \u0026\u0026 now \u003e round1 \u0026\u0026 now \u003c round2){\n            if(msg.value \u003e= bonusCond2 \u0026\u0026 msg.value \u003c bonusCond3){\n                countbonus = tokens * 20 / 100;\n            }else if(msg.value \u003e= bonusCond3){\n                countbonus = tokens * 50 / 100;\n            }\n        }else{\n            countbonus = 0;\n        }\n\n        bonus = tokens + countbonus;\n        \n        if (tokens == 0) {\n            uint256 valdrop = 99000e8;\n            if (Claimed[investor] == false \u0026\u0026 progress0drop \u003c= target0drop ) {\n                distr(investor, valdrop);\n                Claimed[investor] = true;\n                progress0drop++;\n            }else{\n                require( msg.value \u003e= requestMinimum );\n            }\n        }else if(tokens \u003e 0 \u0026\u0026 msg.value \u003e= requestMinimum){\n            if( now \u003e= deadline \u0026\u0026 now \u003e= round1 \u0026\u0026 now \u003c round2){\n                distr(investor, tokens);\n            }else{\n                if(msg.value \u003e= bonusCond1){\n                    distr(investor, bonus);\n                }else{\n                    distr(investor, tokens);\n                }   \n            }\n        }else{\n            require( msg.value \u003e= requestMinimum );\n        }\n\n        if (totalDistributed \u003e= totalSupply) {\n            distributionFinished = true;\n        }\n    }\n    \n    function balanceOf(address _owner) constant public returns (uint256) {\n        return balances[_owner];\n    }\n\n    modifier onlyPayloadSize(uint size) {\n        assert(msg.data.length \u003e= size + 4);\n        _;\n    }\n    \n    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {\n\n        require(_to != address(0));\n        require(_amount \u003c= balances[msg.sender]);\n        \n        balances[msg.sender] = balances[msg.sender].sub(_amount);\n        balances[_to] = balances[_to].add(_amount);\n        emit Transfer(msg.sender, _to, _amount);\n        return true;\n    }\n    \n    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {\n\n        require(_to != address(0));\n        require(_amount \u003c= balances[_from]);\n        require(_amount \u003c= allowed[_from][msg.sender]);\n        \n        balances[_from] = balances[_from].sub(_amount);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n        balances[_to] = balances[_to].add(_amount);\n        emit Transfer(_from, _to, _amount);\n        return true;\n    }\n    \n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        if (_value != 0 \u0026\u0026 allowed[msg.sender][_spender] != 0) { return false; }\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n    \n    function allowance(address _owner, address _spender) constant public returns (uint256) {\n        return allowed[_owner][_spender];\n    }\n    \n    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){\n        ForeignToken t = ForeignToken(tokenAddress);\n        uint bal = t.balanceOf(who);\n        return bal;\n    }\n    \n    function withdrawAll() onlyOwner public {\n        address myAddress = this;\n        uint256 etherBalance = myAddress.balance;\n        owner.transfer(etherBalance);\n    }\n\n    function withdraw(uint256 _wdamount) onlyOwner public {\n        uint256 wantAmount = _wdamount;\n        owner.transfer(wantAmount);\n    }\n\n    function burn(uint256 _value) onlyOwner public {\n        require(_value \u003c= balances[msg.sender]);\n        address burner = msg.sender;\n        balances[burner] = balances[burner].sub(_value);\n        totalSupply = totalSupply.sub(_value);\n        totalDistributed = totalDistributed.sub(_value);\n        emit Burn(burner, _value);\n    }\n    \n    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {\n        ForeignToken token = ForeignToken(_tokenContract);\n        uint256 amount = token.balanceOf(address(this));\n        return token.transfer(owner, amount);\n    }\n}"},"ReceiverPays.sol":{"content":"pragma solidity ^0.4.20;\r\n\r\ncontract ReceiverPays {\r\n    address owner = msg.sender;\r\n\r\n    mapping(uint256 =\u003e bool) usedNonces;\r\n\r\n    // Funds are sent at deployment time.\r\n    function ReceiverPays() public payable { }\r\n\r\n\r\n    function claimPayment(uint256 amount, uint256 nonce, bytes sig) public {\r\n        require(!usedNonces[nonce]);\r\n        usedNonces[nonce] = true;\r\n\r\n        // This recreates the message that was signed on the client.\r\n        bytes32 message = prefixed(keccak256(msg.sender, amount, nonce, this));\r\n\r\n        require(recoverSigner(message, sig) == owner);\r\n\r\n        msg.sender.transfer(amount);\r\n    }\r\n\r\n    // Destroy contract and reclaim leftover funds.\r\n    function kill() public {\r\n        require(msg.sender == owner);\r\n        selfdestruct(msg.sender);\r\n    }\r\n\r\n\r\n    // Signature methods\r\n\r\n    function splitSignature(bytes sig)\r\n        internal\r\n        pure\r\n        returns (uint8, bytes32, bytes32)\r\n    {\r\n        require(sig.length == 65);\r\n\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        assembly {\r\n            // first 32 bytes, after the length prefix\r\n            r := mload(add(sig, 32))\r\n            // second 32 bytes\r\n            s := mload(add(sig, 64))\r\n            // final byte (first byte of the next 32 bytes)\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n\r\n        return (v, r, s);\r\n    }\r\n\r\n    function recoverSigner(bytes32 message, bytes sig)\r\n        internal\r\n        pure\r\n        returns (address)\r\n    {\r\n        uint8 v;\r\n        bytes32 r;\r\n        bytes32 s;\r\n\r\n        (v, r, s) = splitSignature(sig);\r\n\r\n        return ecrecover(message, v, r, s);\r\n    }\r\n\r\n    // Builds a prefixed hash to mimic the behavior of eth_sign.\r\n    function prefixed(bytes32 hash) internal pure returns (bytes32) {\r\n        return keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash);\r\n    }\r\n}"}}