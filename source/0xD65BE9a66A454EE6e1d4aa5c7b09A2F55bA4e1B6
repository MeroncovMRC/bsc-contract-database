
// File: src/Jiaoyisuo.sol
// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.8.2 <0.9.0;

import "openzeppelin-contracts/access/Ownable.sol";

interface SwapRouterService {
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);

    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
}

interface Erc20Service {
    function balanceOf(address account) external view returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    function transfer(address recipient, uint256 amount) external returns (bool);

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    function burn(uint256 amount) external returns (bool);
}

contract Jiaoyisuo is Ownable {

    mapping(uint256 => uint256) orderMapping;
    mapping(address => uint256) noNeedQuotaAddress;

    struct reduceConfig {
        uint256 timer;
        uint256 reducePoint;
        uint256 divideNum;
        uint256 startTimer;
    }

    reduceConfig reduceInitConfig;

    struct addconfig {
        address usdtAdd;
        address httAdd;
        address htcAdd;
        address[] getUsdtPath;
        address[] getHttPath;
        address[] getHtcPath;
        Erc20Service erc20Service;
        Erc20Service erc20HttService;
        Erc20Service erc20HtcService;
        SwapRouterService swapRouterService;
        address nodeRedAdd; // 节点分红地址
        address levelRedAdd; // 等级分红地址
        address htCPoolAdd; // HTC底池地址
        address swapRouterAdd;
    }

    address signAccount;

    addconfig initconfig;


    constructor(){
        signAccount = msg.sender;
        initconfig.usdtAdd = 0x55d398326f99059fF775485246999027B3197955;
        initconfig.httAdd = 0x2CFFDa1B2f74a107F8Ac765D1d9D259908e92008;
        initconfig.swapRouterAdd = 0xD99D1c33F9fC3444f8101754aBC46c52416550D1;
        initconfig.getUsdtPath = [initconfig.httAdd, initconfig.usdtAdd];
        initconfig.getHttPath = [initconfig.usdtAdd, initconfig.httAdd];
        initconfig.getHtcPath = [initconfig.usdtAdd, initconfig.htcAdd];
        initconfig.erc20Service = Erc20Service(initconfig.usdtAdd);
        initconfig.erc20HttService = Erc20Service(initconfig.httAdd);
        initconfig.swapRouterService = SwapRouterService(initconfig.swapRouterAdd);
        initconfig.nodeRedAdd = 0x852826e56fb77333bd34678FEa66FC279ce139C4; // 节点分红地址
        initconfig.levelRedAdd = 0x70682dE6ad3ABf0D1814B7f81c6e9eE409Baf2fA; // 等级分红地址
        initconfig.htCPoolAdd = 0x1663c8fBB2A1FACEBcD00723E0EBd88fF42d49B4; // HTC底池地址

        reduceInitConfig.timer = 1000 * 60 * 60;
        reduceInitConfig.reducePoint = 1;
        reduceInitConfig.divideNum = 100;
        reduceInitConfig.startTimer = block.timestamp * 1000;
    }

    function init(address httAddress, address htcAddress) public onlyOwner {
        initconfig.httAdd = httAddress;
        initconfig.erc20HttService = Erc20Service(initconfig.httAdd);
        initconfig.getUsdtPath = [initconfig.httAdd, initconfig.usdtAdd];
        initconfig.getHttPath = [initconfig.usdtAdd, initconfig.httAdd];

        initconfig.htcAdd = htcAddress;
        initconfig.erc20HtcService = Erc20Service(initconfig.htcAdd);
    }

    function swapHtt(uint256 orderNo, uint256 amountIn, uint256 amountOut, uint256 expireTimer,
        bytes32 r, bytes32 s, bytes1 v) public {

        require(orderMapping[orderNo] == 0, "Exist Swap");
        uint256 nowTimer = block.timestamp * 1000;
        require(expireTimer > nowTimer, "More Than Time");
        require(recoverSigner(genMsg(orderNo, amountOut, amountIn, expireTimer, msg.sender, address(this)), r, s, v) == signAccount, "Sign Not Pass");

        //        uint256 finalIn = (amountIn * 98) / reduceInitConfig.divideNum;
        //        uint256 part2 = (amountIn * 5) / 1000;


        amountOut = getAmountsOut(amountIn, initconfig.getHttPath);
        emit AmountOut(initconfig.getHttPath[0], initconfig.getHttPath[1], amountOut);
        initconfig.erc20Service.transferFrom(msg.sender, address(this), amountIn);


        uint256 finalOut = (amountOut * 98) / reduceInitConfig.divideNum;
        uint256 burnNum = (amountOut * 2) / reduceInitConfig.divideNum;

        initconfig.erc20HttService.transfer(msg.sender, finalOut);

        initconfig.erc20HttService.burn(burnNum);
        orderMapping[orderNo] = amountOut;
        reduceSwap();
    }

    function swapHttAndBurn(uint256 amountIn) public returns (uint256){
        require(noNeedQuotaAddress[msg.sender] > 0 || msg.sender == initconfig.htcAdd, "No Authority");
        uint256 amountOut = getAmountsOut(amountIn, initconfig.getHttPath);
        initconfig.erc20HttService.burn(amountOut);
        reduceSwap();
        return amountOut;
    }


    function swapUsdt(uint256 orderNo, uint256 amountIn, uint256 amountOut, uint256 expireTimer) public {

        require(orderMapping[orderNo] == 0, "Exist Swap");
        uint256 nowTimer = block.timestamp * 1000;
        require(expireTimer > nowTimer, "More Than Time");

        //        uint256 finalIn = (amountIn * 98) / reduceInitConfig.divideNum;
        //        uint256 burnNum = (amountIn * 2) / reduceInitConfig.divideNum;

        initconfig.erc20HttService.transferFrom(msg.sender, address(this), amountIn);
        //        initconfig.erc20HttService.burn(burnNum);

        amountOut = getAmountsOut(amountIn, initconfig.getUsdtPath);

        uint256 finalOut = (amountOut * 98) / reduceInitConfig.divideNum;
        uint256 part2 = (amountOut * 5) / 1000;


        initconfig.erc20Service.transfer(msg.sender, finalOut);
        //        initconfig.erc20Service.transfer(address(this), part2);//jiaoyisuo合约底池地址
        initconfig.erc20Service.transfer(initconfig.nodeRedAdd, part2); // 节点分红地址
        initconfig.erc20Service.transfer(initconfig.levelRedAdd, part2); // 等级分红地址
        uint[] memory amounts = initconfig.swapRouterService.swapExactTokensForTokens(part2, 0, initconfig.getHtcPath, address(this), block.timestamp + 60 * 5); //servicefee
        initconfig.erc20HtcService.burn(amounts[1]); // HTC销毁

        orderMapping[orderNo] = amountOut;
        reduceSwap();
    }

    function inSwap(uint256 amountIn, address tokenAddress) public {
        Erc20Service(tokenAddress).transferFrom(msg.sender, address(this), amountIn);
    }

    function inTrimSwap(uint256 amountInA, uint256 amountInB, address tokenA, address tokenB) public {
        Erc20Service(tokenA).transferFrom(msg.sender, address(this), amountInA);
        Erc20Service(tokenB).transferFrom(msg.sender, address(this), amountInB);
    }

    function getBalance(address tokenAddress) public view returns (uint){
        return Erc20Service(tokenAddress).balanceOf(address(this));
    }

    function setSignAccount(address changeAddress) public {
        require(msg.sender == signAccount, "You are not has permisson");
        signAccount = changeAddress;
    }


    function withdraw(address to, uint256 num, address tokenAddress) public onlyOwner {
        Erc20Service(tokenAddress).transfer(to, num);
    }

    function reduceSwap() public {
        uint256 nowTimer = block.timestamp * 1000;
        uint256 expireTimer = reduceInitConfig.startTimer + reduceInitConfig.timer;
        if (expireTimer < nowTimer) {
            uint256 httNum = initconfig.erc20HttService.balanceOf(address(this));
            uint256 burnNum = reduceInitConfig.reducePoint * httNum / reduceInitConfig.divideNum;
            initconfig.erc20HttService.burn(burnNum);
            reduceInitConfig.startTimer = nowTimer;
        }
    }


    function setReduceConfig(uint256 timer, uint256 reducePoint, uint256 divideNum) public onlyOwner {
        reduceInitConfig.timer = timer;
        reduceInitConfig.reducePoint = reducePoint;
        reduceInitConfig.divideNum = divideNum;
    }

    function getCanReduce() public view returns (uint256){
        uint256 nowTimer = block.timestamp * 1000;
        uint256 expireTimer = reduceInitConfig.startTimer + reduceInitConfig.timer;
        if (expireTimer < nowTimer) {
            return 1;
        }
        return 0;
    }


    function getOrderStatus(uint256 orderNo) public view returns (uint256){
        return orderMapping[orderNo];
    }

    function genMsg(
        uint256 orderNo,
        uint256 amountOut, uint256 amountIn, uint256 expireTimer,
        address _address,
        address contractAddress
    ) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(orderNo, amountOut, amountIn, expireTimer, _address, contractAddress));
    }

    function getAmountsOut(uint256 amountIn, address[] memory path) internal view returns (uint256) {
        require(path.length >= 2, 'PancakeLibrary: INVALID_PATH');
        address tokenA = path[0];
        address tokenB = path[1];
        uint256 tokenANum = Erc20Service(tokenA).balanceOf(address(this));
        if (tokenANum == 0) {
            return 0;
        }
        uint256 tokenBNum = Erc20Service(tokenB).balanceOf(address(this));
        if (tokenBNum == 0) {
            return 0;
        }

        uint256 k = tokenANum * tokenBNum;
        tokenANum = tokenANum + amountIn;
        tokenBNum = tokenBNum - k / tokenANum;

        return tokenBNum;
    }

    function getAmountsIn(uint256 amountOut, address[] memory path) internal view returns (uint256) {
        require(path.length >= 2, 'PancakeLibrary: INVALID_PATH');
        address tokenA = path[0];
        address tokenB = path[1];
        uint256 tokenANum = Erc20Service(tokenA).balanceOf(address(this));
        if (tokenANum == 0) {
            return 0;
        }
        uint256 tokenBNum = Erc20Service(tokenB).balanceOf(address(this));
        if (tokenBNum == 0) {
            return 0;
        }
        uint256 k = tokenANum * tokenBNum;
        tokenBNum = tokenBNum - amountOut;
        tokenANum = k / tokenBNum - tokenANum;
        return tokenANum;
    }

    function setNoNeedQuotaAddress(address changeAddress) public onlyOwner {
        noNeedQuotaAddress[changeAddress] = 1;
    }

    function setHtcAddress(address changeAddress) public onlyOwner {
        initconfig.htcAdd = changeAddress;
    }

    function recoverSigner(bytes32 message, bytes32 r,
        bytes32 s,
        bytes1 v)
    internal
    pure
    returns (address)
    {
        uint8 vu = uint8(v[0]) * (2 ** (8 * (0)));
        return ecrecover(message, vu, r, s);
    }

    receive() external payable {

    }


    fallback() external payable {

    }

    event AmountOut(address indexed tokenAddress, address indexed tokenBddress, uint256 indexed tokenBNum);
}

// File: lib/openzeppelin-contracts/contracts/access/Ownable.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)

pragma solidity ^0.8.0;

import "../utils/Context.sol";

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _transferOwnership(_msgSender());
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if the sender is not the owner.
     */
    function _checkOwner() internal view virtual {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Internal function without access restriction.
     */
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}


// File: lib/openzeppelin-contracts/contracts/utils/Context.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)

pragma solidity ^0.8.0;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

