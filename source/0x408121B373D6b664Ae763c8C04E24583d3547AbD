
// File: @openzeppelin/contracts/access/Ownable.sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "../utils/Context.sol";

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _setOwner(_msgSender());
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}


// File: @openzeppelin/contracts/token/ERC20/IERC20.sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}


// File: @openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "../IERC20.sol";
import "../../../utils/Address.sol";

/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
    using Address for address;

    function safeTransfer(
        IERC20 token,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(
        IERC20 token,
        address from,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    /**
     * @dev Deprecated. This function has issues similar to the ones found in
     * {IERC20-approve}, and its usage is discouraged.
     *
     * Whenever possible, use {safeIncreaseAllowance} and
     * {safeDecreaseAllowance} instead.
     */
    function safeApprove(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        require(
            (value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance = token.allowance(address(this), spender) + value;
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        unchecked {
            uint256 oldAllowance = token.allowance(address(this), spender);
            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");
            uint256 newAllowance = oldAllowance - value;
            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
        }
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
        if (returndata.length > 0) {
            // Return data is optional
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}


// File: @openzeppelin/contracts/utils/Address.sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.

        uint256 size;
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain `call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCall(target, data, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");

        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");

        (bool success, bytes memory returndata) = target.staticcall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(isContract(target), "Address: delegate call to non-contract");

        (bool success, bytes memory returndata) = target.delegatecall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function _verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) private pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length > 0) {
                // The easiest way to bubble the revert reason is using memory via assembly

                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}


// File: @openzeppelin/contracts/utils/Context.sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}


// File: contracts/Launchpad/Extension/FeeCollector.sol
// SPDX-License-Identifier: MIT

pragma solidity =0.8.19;

import "@openzeppelin/contracts/access/Ownable.sol";
import '@openzeppelin/contracts/utils/Address.sol';

contract FeeCollector is Ownable {
    using Address for address;

    mapping(string => uint256) public configureFees;
    uint256 public collectedFees;
    uint256 public withdrawnFees;

    event FeeConfigureChanged(string method, uint256 fee);
    event FeeWithdrawn(address indexed user, uint256 amount);

    function setFeesConfiguration(string[] memory methods, uint256[] memory fees) public onlyOwner {
        require(methods.length == fees.length, 'FeeCollector: invalid set of configuration provided');
        for (uint i=0; i<methods.length; i++) {
            configureFees[methods[i]] = fees[i];
            emit FeeConfigureChanged(methods[i], fees[i]);
        }
    }

    function withdrawCollectedFees(address addr, uint256 amount) public onlyOwner {
        require(addr != address(0), 'FeeCollector: address needs to be different than zero!');
        require(collectedFees >= amount, 'FeeCollector: not enough fees to withdraw!');
        collectedFees = collectedFees - amount;
        withdrawnFees = withdrawnFees + amount;
        Address.sendValue(payable(addr), amount);
        emit FeeWithdrawn(addr, amount);
    }

    modifier collectFee(string memory method) {
        require(msg.value > 0 || configureFees[method] == 0, 'FeeCollector: this method requires fee');
        require(msg.value == configureFees[method], 'FeeCollector: wrong fee amount provided');
        collectedFees = collectedFees + msg.value;
        _;
    }
}


// File: contracts/Launchpad/Extension/ILaunchpadVault.sol
// SPDX-License-Identifier: MIT

pragma solidity =0.8.19;

interface ILaunchpadVault {
    function currentUserInfoAt(address addr, uint256 index) external view returns (uint256);

    function increasePeggedAmount(address addr, uint256 amount) external returns (uint256);

    function decreasePeggedAmount(address addr, uint256 amount) external returns (uint256);
}


// File: contracts/Launchpad/LaunchpadPresale.sol
// SPDX-License-Identifier: MIT

pragma solidity =0.8.19;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "./Extension/ILaunchpadVault.sol";
import "./Extension/FeeCollector.sol";
import "../Token/IERC20Delegated.sol";

contract LaunchpadPresale is Ownable, FeeCollector {
    using SafeERC20 for IERC20;

    uint256 public minAllocate;
    uint256 public maxAllocate;
    uint256 public targetAmount;
    uint256 public remainAmount;
    uint256 public raisedAmount;
    uint256 public secureAmount;
    uint256 public freezeAmount;
    uint256 public sumAllocates;
    uint256 public startBlock;
    uint256 public pivotBlock;
    uint256 public closeBlock;
    uint256 public realStartBlock;
    uint256 public realPivotBlock;
    uint256 public realCloseBlock;
    uint256 public iniDeposit;
    uint256 public sumDeposit;

    mapping(address => uint256) internal deposits;
    mapping(address => uint256) internal withdraws;
    mapping(address => uint256) internal allocates;
    mapping(address => uint256) internal releases;

    IERC20Delegated public depoToken;
    IERC20 public saleToken;
    ILaunchpadVault public vault;

    uint256 public stage;
    uint256 public setupFlag;
    uint256 public fine;
    uint256 public fineDivisor;
    uint256 public multiply;

    bool private startInProgress;
    bool private closeInProgress;
    bool private salePremature;
    bool private saleSucceeded;
    uint256 private presaleAmount;
    uint256 private pubsaleAmount;

    event ConstraintChanged(uint256 minAllocate, uint256 maxAllocate, uint256 targetAmount, uint256 remainAmount);
    event StartBlockChanged(uint256 block);
    event PivotBlockChanged(uint256 block);
    event CloseBlockChanged(uint256 block);
    event TokenAddressChanged(address indexed depoToken, address indexed saleToken);
    event VaultAddressChanged(address indexed addr);
    event SaleStarted(uint256 block);
    event SaleStopped(uint256 block);
    event StagePushed(uint256 block, uint256 stage);
    event Deposited(address indexed user, uint256 amount);
    event Withdrawn(address indexed user, uint256 amount);
    event Allocated(address indexed user, uint256 amount);
    event Delivered(address indexed user, uint256 amount);
    event Released(address indexed user, uint256 amount);
    event WithdrawFineChanged(uint256 fine, uint256 divisor);

    function startSale() external onlyOwner {
        require(stage == 0, 'Presale: already started');
        require(!startInProgress && stage == 0, 'Presale: not ready to be started');
        require(setupFlag == 63, 'Presale: constraints have not been set');
        startInProgress = true;
        raisedAmount = 0; // fix for non-allocation start
        updateState();
    }

    function closeSale() external onlyOwner {
        require(stage <= 3, 'Presale: already stopped');
        require(!closeInProgress && stage == 3, 'Presale: not ready to be stopped');
        require(startInProgress, 'Presale: start of sale needs to be triggered before close');
        closeInProgress = true;
        raisedAmount = saleToken.balanceOf(address(this)); // fix for non-allocation close
        updateState();
    }

    function setConstraint(uint256 minAllocate_, uint256 maxAllocate_, uint256 targetAmount_, uint256 remainAmount_) public onlyOwner {
        require(maxAllocate_ >= minAllocate_, 'Presale: max allocation needs to be higher or equal to min allocation');
        require(targetAmount_ >= maxAllocate_, 'Presale: presale target needs to be higher or equal to max allocation');
        require(targetAmount_ >= remainAmount_, 'Presale: presale target needs to be higher or equal to remain amount');
        require(targetAmount_ > 0, 'Presale: presale target needs to be higher than zero');

        require(minAllocate == 0 && maxAllocate == 0 && targetAmount == 0 && remainAmount == 0,
            'Presale: constraints already set');

        minAllocate = minAllocate_;
        maxAllocate = maxAllocate_;
        targetAmount = targetAmount_;
        remainAmount = remainAmount_;

        setupFlag = setupFlag | 1;
        emit ConstraintChanged(minAllocate, maxAllocate, targetAmount, remainAmount);
    }

    function setTokenAddress(IERC20Delegated _depoToken, IERC20 _saleToken) public onlyOwner {
        require(address(_depoToken) != address(0), 'Presale: token address needs to be different than zero!');
        require(address(_saleToken) != address(0), 'Presale: token address needs to be different than zero!');
        require(address(depoToken) == address(0), 'Presale: token already set!');
        require(address(saleToken) == address(0), 'Presale: token already set!');

        depoToken = _depoToken;
        saleToken = _saleToken;

        setupFlag = setupFlag | 2;
        emit TokenAddressChanged(address(depoToken), address(saleToken));
    }

    function setVaultAddress(ILaunchpadVault _vault) public onlyOwner {
        require(address(_vault) != address(0), 'Presale: vault address needs to be different than zero!');
        require(address(vault) == address(0), 'Presale: vault already set!');
        vault = _vault;

        setupFlag = setupFlag | 4;
        emit VaultAddressChanged(address(vault));
    }

    function setStartBlock(uint256 _startBlock) public onlyOwner {
        require(startBlock == 0, 'Presale: start block already set');
        require(_startBlock > 0, 'Presale: start block needs to be higher than zero!');
        startBlock = _startBlock;

        setupFlag = setupFlag | 8;
        emit StartBlockChanged(startBlock);
    }

    function setPivotBlock(uint256 _pivotBlock) public onlyOwner {
        require(startBlock != 0, 'Presale: start block needs to be set first');
        require(pivotBlock == 0, 'Presale: pivot block already set');
        require(_pivotBlock > startBlock, 'Presale: pivot block needs to be higher than start one!');
        pivotBlock = _pivotBlock;

        setupFlag = setupFlag | 16;
        emit PivotBlockChanged(pivotBlock);
    }

    function setCloseBlock(uint256 _closeBlock) public onlyOwner {
        require(pivotBlock != 0, 'Presale: pivot block needs to be set first');
        require(closeBlock == 0, 'Presale: close block already set');
        require(_closeBlock > pivotBlock, 'Presale: close block needs to be higher than pivot one!');
        closeBlock = _closeBlock;

        setupFlag = setupFlag | 32;
        emit CloseBlockChanged(closeBlock);
    }

    function setWithdrawFine(uint256 _fine, uint256 _divisor) public onlyOwner {
        require(_divisor > 0, 'Presale: fine divisor needs to be higher than zero!');
        fine = _fine;
        fineDivisor = _divisor;
        emit WithdrawFineChanged(_fine, _divisor);
    }

    function isDepositAccepted() public view returns (bool) {
        return stage == 1;
    }

    function isAllocateAccepted() public view returns (bool) {
        return stage == 1 || stage == 2 || stage == 3;
    }

    function isWithdrawAccepted() public view returns (bool) {
        return stage == 4;
    }

    function isReleaseAccepted() public view returns (bool) {
        return stage == 4;
    }

    function isInvestorAllowed(address addr) public view returns (bool) {
        return allowedAllocation(addr) > 0;
    }

    function isPreCloseAllowed() public view returns (bool) {
        return stage == 2;
    }

    function isCountingAllowed() public view returns (bool) {
        return stage == 2 || stage == 3 || stage == 4;
    }

    function isEveryoneAllowed() public view returns (bool) {
        return stage == 3 || (stage == 2 && sumDeposit == 0);
    }

    function depositToAllocation(uint256 amount, uint256 target) public view returns (uint256) {
        return (sumDeposit == 0) ? 0 : amount * target / sumDeposit;
    }

    function currentDeposit(address addr) public view returns (uint256) {
        return deposits[addr];
    }

    function allowedAllocation(address addr) public view returns (uint256) {
        return depositToAllocation(currentDeposit(addr), targetAmount);
    }

    function securedAllocation(address addr) public view returns (uint256) {
        return allowedAllocation(addr) - missingAllocation(addr);
    }

    function currentAllocation(address addr) public view returns (uint256) {
        return allocates[addr];
    }

    function missingAllocation(address addr) public view returns (uint256) {
        uint256 allowed = allowedAllocation(addr);
        uint256 current = currentAllocation(addr);
        return (allowed >= current) ? allowed - current : 0;
    }

    function deposit(uint256 amount) external payable collectFee('deposit') {
        updateState();
        // zero amount is required to be allowed!
        require(isDepositAccepted(), 'Presale: deposits are not accepted at this time!');

        // check expiration of provided tokens
        uint256 expiry = vault.currentUserInfoAt(msg.sender, 4); // expiration is at index=4
        require(expiry >= block.timestamp, 'Presale: your tokens have expired, please re-issue them');

        deposits[msg.sender] = deposits[msg.sender] + amount;
        sumDeposit = sumDeposit + amount;

        // if user allocated on deposit phase already, increase his deposit, ignore otherwise
        if (isDepositAccepted() && currentAllocation(msg.sender) != 0) {
            iniDeposit = iniDeposit + amount;
        }

        IERC20(depoToken).safeTransferFrom(address(msg.sender), address(this), amount);
        emit Deposited(msg.sender, amount);
    }

    function allocate(uint256 amount) external payable collectFee('allocate') {
        updateState();
        // zero amount is required to be allowed!
        require(isAllocateAccepted(), 'Presale: allocations are not accepted at this time!');

        bool isInvestor = isInvestorAllowed(msg.sender);
        bool isEveryone = isEveryoneAllowed();
        require(isInvestor || isEveryone, 'Presale: you are not allowed to participate at this time!');
        bool targetReached = raisedAmount + remainAmount >= targetAmount;
        uint256 balance = saleToken.balanceOf(address(this));

        // if user allocated on deposit phase for the first time, count and add his deposit tokens
        if (isDepositAccepted() && currentAllocation(msg.sender) == 0 && amount > 0) {
            iniDeposit = iniDeposit + currentDeposit(msg.sender);
        }
        // if counter phase is active and raisedAmount from previous phase is yet to be determined - count it
        if (isCountingAllowed() && presaleAmount == 0 && !targetReached) {
            balance = balance < targetAmount ? balance : targetAmount;
            balance = depositToAllocation(iniDeposit, balance);
            raisedAmount = raisedAmount + balance;
            if (raisedAmount > targetAmount) raisedAmount = targetAmount;
            secureAmount = secureAmount + balance;
            if (secureAmount > targetAmount) secureAmount = targetAmount;
            presaleAmount = raisedAmount;
        }
        if (isEveryoneAllowed() && pubsaleAmount == 0 && !targetReached) {
            raisedAmount = balance;
            if (raisedAmount > targetAmount) raisedAmount = targetAmount;
            pubsaleAmount = raisedAmount;
        }

        // compute secure allocation allowed
        uint256 newAmount = computeAllocation(msg.sender, amount);
        require(newAmount > 0 || isInvestor, 'Presale: unable to allocate that amount at this time!');

        allocates[msg.sender] = allocates[msg.sender] + amount;
        sumAllocates = saleToken.balanceOf(address(this)) + amount;

        // if counter phase is active, increase raisedAmount by allowed amount
        if (!isDepositAccepted() && isAllocateAccepted()) {
            if (isInvestor) secureAmount = secureAmount + newAmount; // secured amount is a feature available only for investors
            raisedAmount = raisedAmount + newAmount;
        }

        targetReached = raisedAmount + remainAmount >= targetAmount;
        // if everyone is already accepted and real balance is higher than target, accept overbalance and succeed
        if (!targetReached && isEveryone) {
            uint256 actualAmount = sumAllocates;
            if (actualAmount + remainAmount >= targetAmount) {
                raisedAmount = actualAmount <= targetAmount ? actualAmount : targetAmount;
                targetReached = true;
            }
        }
        // if preclose phase is active and only remainAmount is missing treat sale as prematurely succeeded
        if ( targetReached && isPreCloseAllowed()) {
            salePremature = true;
        }
        // if counting phase is active and only remainAmount is missing treat sale as succeeded
        if ( targetReached && isCountingAllowed()) {
            saleSucceeded = true;
        }
        if ( targetReached) {
            updateState(); // stop presale and update state if sale succeeded
        }

        saleToken.safeTransferFrom(address(msg.sender), address(this), amount);
        emit Allocated(msg.sender, amount);
    }

    function withdraw() external payable collectFee('withdraw') {
        updateState();
        require(isWithdrawAccepted(), 'Presale: withdraws are not accepted at this time!');

        uint256 amount = currentDeposit(msg.sender) - withdraws[msg.sender];
        require(amount > 0, 'Presale: unable to withdraw that amount at this time!');

        withdraws[msg.sender] = withdraws[msg.sender] + amount;

        uint256 burned = 0;
        uint256 maxAlloc = allowedAllocation(msg.sender);
        uint256 curAlloc = securedAllocation(msg.sender);

        if (!salePremature && maxAlloc > curAlloc && fine > 0 && fineDivisor > 0) {
            burned = amount * fine / fineDivisor;
            amount = amount - burned;
        }
        if (amount != 0) {
            IERC20(depoToken).safeTransfer(address(msg.sender), amount);
            emit Withdrawn(msg.sender, amount);
        }
        if (burned != 0) {
            depoToken.burn(burned);
            uint256 newBurned = vault.decreasePeggedAmount(address(msg.sender), burned);
            require(newBurned == burned, 'Presale: unable to burn that number of funds');
            emit Withdrawn(address(0), burned);
        }
    }

    function release() external payable collectFee('release') {
        updateState();
        require(isReleaseAccepted(), 'Presale: unable to release yet!');

        uint256 securedAlloc = securedAllocation(msg.sender);
        uint256 currentAlloc = currentAllocation(msg.sender);

        uint256 unlockAmount = ((currentAlloc - securedAlloc) * multiply / 1000) - releases[msg.sender];
        require(releases[msg.sender] == 0, 'Presale: funds were already released!');
        require(unlockAmount > 0, 'Presale: no overbalance found');

        uint256 actualAmount = saleToken.balanceOf(address(this));
        if (unlockAmount > actualAmount) {
            unlockAmount = actualAmount;
        }

        uint256 lockedAmount = raisedAmount - freezeAmount;
        if (unlockAmount > actualAmount - lockedAmount) {
            unlockAmount = actualAmount - lockedAmount;
        }
        require(unlockAmount > 0, 'Presale: no funds available for release!');
        releases[msg.sender] = releases[msg.sender] + unlockAmount;

        saleToken.safeTransfer(address(msg.sender), unlockAmount);
        emit Released(msg.sender, unlockAmount);
    }

    function deliver(address addr, uint256 amount) external payable collectFee('deliver') onlyOwner {
        updateState();
        require(isReleaseAccepted(), 'Presale: unable to release yet!');

        uint256 unlockAmount = amount;
        uint256 queuedAmount = raisedAmount - freezeAmount;
        if (unlockAmount > queuedAmount) {
            unlockAmount = queuedAmount;
        }
        require(unlockAmount > 0, 'Presale: funds were already delivered!');

        uint256 actualAmount = saleToken.balanceOf(address(this));
        if (unlockAmount > actualAmount) {
            unlockAmount = actualAmount;
        }
        require(unlockAmount > 0, 'Presale: funds were already delivered!');
        freezeAmount = freezeAmount + unlockAmount;

        saleToken.safeTransfer(addr, unlockAmount);
        emit Delivered(msg.sender, unlockAmount);
    }

    function computeAllocation(address addr, uint256 amount) private view returns (uint256) {
        uint256 newAmount = amount;
        bool isInvestor = isInvestorAllowed(addr);
        bool isEveryone = isEveryoneAllowed();
        if (raisedAmount + newAmount > targetAmount) {
            newAmount = targetAmount - raisedAmount;
        }
        if (isInvestor) {
            uint256 misAmount = missingAllocation(addr);
            if (newAmount > misAmount) {
                newAmount = misAmount;
            }
            return newAmount;
        }
        if (isEveryone) {
            uint256 curAmount = currentAllocation(addr);
            if (minAllocate != 0 && curAmount + newAmount < minAllocate) {
                newAmount = 0;
            }
            if (maxAllocate != 0 && curAmount > maxAllocate) {
                newAmount = 0;
            }
            if (maxAllocate != 0 && curAmount + newAmount > maxAllocate) {
                newAmount = maxAllocate - curAmount;
            }
            return newAmount;
        }
        return 0;
    }

    function updateState() private {
        if (stage == 0) {
            if (!startInProgress) {
                return;
            }
            if (realStartBlock == 0 && startBlock > 0 && block.number >= startBlock) {
                updateStage(1);
                return updateState();
            }
        }
        if (stage == 1) {
            if (realStartBlock == 0) {
                realStartBlock = block.number;
            }
            if (realPivotBlock == 0 && pivotBlock > 0 && block.number >= pivotBlock) {
                updateStage(2);
                return updateState();
            }
        }
        if (stage == 2) {
            if (realPivotBlock == 0) {
                realPivotBlock = block.number;
            }
            if (realCloseBlock == 0 && raisedAmount + remainAmount >= targetAmount) {
                updateStage(3);
                return updateState();
            }
            if (realCloseBlock == 0 && closeBlock > 0 && block.number >= closeBlock) {
                updateStage(3);
                return updateState();
            }
        }
        if (stage == 3) {
            if (realCloseBlock == 0 && raisedAmount + remainAmount >= targetAmount) {
                updateStage(4);
                return updateState();
            }
            if (realCloseBlock == 0 && closeInProgress) {
                updateStage(4);
                return updateState();
            }
        }
        if (stage == 4) {
            if (realCloseBlock == 0) {
                realCloseBlock = block.number;
                exitPresale(); // close for good
            }
        }
    }

    function updateStage(uint256 _stage) private {
        stage = _stage;
        emit StagePushed(block.number, stage);
    }

    function exitPresale() private {
        uint256 one = 1000;
        uint256 currentBalance = sumAllocates;
        multiply = one;
        if (currentBalance > secureAmount) {
            multiply = one * (raisedAmount - secureAmount) / (currentBalance - secureAmount);
        }
        if (multiply > one) {
            multiply = one;
        }
        multiply = one - multiply;
    }
}


// File: contracts/Token/IERC20Delegated.sol
// SPDX-License-Identifier: MIT

pragma solidity =0.8.19;

import "./IERC20DelegatedBurn.sol";
import "./IERC20DelegatedMint.sol";

interface IERC20Delegated is IERC20DelegatedBurn, IERC20DelegatedMint {}


// File: contracts/Token/IERC20DelegatedBurn.sol
// SPDX-License-Identifier: MIT

pragma solidity =0.8.19;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IERC20DelegatedBurn is IERC20 {

    function burn(uint256 amount) external;

    function burnFor(address addr, uint256 amount) external;
}


// File: contracts/Token/IERC20DelegatedMint.sol
// SPDX-License-Identifier: MIT

pragma solidity =0.8.19;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IERC20DelegatedMint is IERC20 {

    function mint(uint256 amount) external;

    function mintFor(address addr, uint256 amount) external;
}

