// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), msg.sender);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(msg.sender == _owner, "Ownable: caller is not the owner");
        _;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

contract NFTCollector is Ownable {
    uint256 public constant MAX_DEPOSITS = 100;
    uint256 public constant PRICE_INCREMENT_PERCENT = 1;
    uint256 public constant INITIAL_PRICE = 0.01 ether;
    uint256 public constant INITIAL_DEPOSITS = 61; // Hard coded initial deposits

    uint256 public depositCount;
    uint256 public price;

    mapping(address => bool) private depositors; // Track addresses that have made deposits
    address[] private depositorsList;

    event Deposit(address indexed account, uint256 indexed depositCount, uint256 price);
    event Withdrawal(address indexed account, uint256 amount);

    modifier canDeposit() {
        require(depositCount < MAX_DEPOSITS, "Maximum number of deposits reached.");
        _;
    }

    constructor() {
        require(INITIAL_DEPOSITS <= MAX_DEPOSITS, "Initial deposits cannot exceed MAX_DEPOSITS");
        depositCount = 0;
        price = INITIAL_PRICE;
    }

    function deposit() external payable canDeposit {
        require(msg.value >= price, "Insufficient BNB to make a deposit.");

        depositCount++;
        emit Deposit(msg.sender, depositCount, price);

        // Increase the price for the next deposit
        if (depositCount >= INITIAL_DEPOSITS) {
            price = price + (price * PRICE_INCREMENT_PERCENT / 100);
        }

        depositors[msg.sender] = true; // Mark the sender as a depositor
        depositorsList.push(msg.sender); // Add the sender to the depositors list
    }

    function getCurrentPrice() external view returns (uint256) {
        return price;
    }

    function getTotalDeposits() external view returns (uint256) {
        return depositCount;
    }

    function getDepositors() external view returns (address[] memory) {
        return depositorsList;
    }

    function withdrawBalance() external onlyOwner {
        uint256 balance = address(this).balance;
        require(balance > 0, "Contract has no balance to withdraw.");
        payable(owner()).transfer(balance);
        emit Withdrawal(owner(), balance);
    }
}