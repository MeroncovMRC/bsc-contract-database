
// File: contracts/contracts/storages/EventEmitter.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.12;

import "../interfaces/storages/IEventEmitter.sol";
import "../interfaces/ContractOwnerV2.sol";

contract EventEmitter is IEventEmitter, ContractOwnerV2 {
    
    event Deposite(address indexed user, uint amount);
    event Register(address indexed user, uint referal);
    event Claim(address indexed user, uint profit);
    event Reinvest(address indexed user, uint profit, uint newDep);
    event LevelUp(address indexed user);
    event Guilder(address indexed user);
    event Withdraw (address indexed user, uint deposite);

    function onDeposite (address user, uint amount) isContractOwner public {
        emit Deposite(user, amount);
    }
    function onRegister (address user, uint referal)  isContractOwner public {
        emit Register(user, referal);
    }

    function onClaim (address user, uint profit) isContractOwner public {
        emit Claim(user, profit);
    }

    function onReinvest (address user, uint profit, uint newDep) isContractOwner public {
        emit Reinvest(user, profit, newDep);
    }

    function onLevelUp (address user) isContractOwner public{
        emit LevelUp(user);
    }
    function onWithdraw(address user, uint deposite) isContractOwner public {
        emit Withdraw(user, deposite);
    }
    function onGuilder (address user) public {
        emit Guilder(user);
    }
    
}

// File: contracts/contracts/interfaces/ContractOwnerV2.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.12;

import "./OwnableV2.sol";

abstract contract ContractOwnerV2 is OwnableV2
{
    address _contractOwner;

    modifier isContractOwner()
    {
        require(msg.sender == _contractOwner, "no access");
        _;
    }
    function setContractOwner(address contractOwner) onlyOwner public 
    {
        _contractOwner = contractOwner;
    }
}

// File: contracts/contracts/interfaces/storages/IEventEmitter.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.12;

interface  IEventEmitter {
    function onDeposite (address user, uint amount) external;
    function onRegister (address user, uint referal) external;
    function onClaim (address user, uint profit) external;
    function onReinvest (address user, uint profit, uint newDep) external;
    function onLevelUp (address user) external;
    function onWithdraw(address user, uint deposite) external;
    function onGuilder (address user) external;

}


// File: contracts/contracts/interfaces/OwnableV2.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import "./Context.sol";

abstract contract OwnableV2 is Context
{
    address _owner;
    address public _newOwner;
    constructor()  
    {
        _owner = payable(msg.sender);
    }

    modifier onlyOwner() 
    {
        require(_msgSender() == _owner, "Only owner");
        _;
    }

    function changeOwner(address newOwner) onlyOwner public
    {
        _newOwner = newOwner;
    }
    function confirm() public
    {
        require(_newOwner == msg.sender);
        _owner = _newOwner;
    }
}



// File: contracts/contracts/interfaces/Context.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

abstract contract Context 
{
    function _msgSender() internal view virtual returns (address) 
    {
        return msg.sender;
    }
    function _msgData() internal view virtual returns (bytes calldata) 
    {
        this; 
        return msg.data;
    }
}

