// File: @chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol


pragma solidity ^0.8.0;

interface AggregatorV3Interface {
    function decimals() external view returns (uint8);

    function description() external view returns (string memory);

    function version() external view returns (uint256);

    function getRoundData(uint80 _roundId)
    external
    view
    returns (
        uint80 roundId,
        int256 answer,
        uint256 startedAt,
        uint256 updatedAt,
        uint80 answeredInRound
    );

    function latestRoundData()
    external
    view
    returns (
        uint80 roundId,
        int256 answer,
        uint256 startedAt,
        uint256 updatedAt,
        uint80 answeredInRound
    );
}

// File: contracts/getprice.sol


pragma solidity ^0.8.0;


/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */

abstract contract Context {

    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        this;
        // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}

abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor () {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, reverting on
   * overflow.
   *
   * Counterpart to Solidity's `+` operator.
   *
   * Requirements:
   * - Addition cannot overflow.
   */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
   * overflow (when the result is negative).
   *
   * Counterpart to Solidity's `-` operator.
   *
   * Requirements:
   * - Subtraction cannot overflow.
   */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
   * overflow (when the result is negative).
   *
   * Counterpart to Solidity's `-` operator.
   *
   * Requirements:
   * - Subtraction cannot overflow.
   */
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
   * overflow.
   *
   * Counterpart to Solidity's `*` operator.
   *
   * Requirements:
   * - Multiplication cannot overflow.
   */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
   * division by zero. The result is rounded towards zero.
   *
   * Counterpart to Solidity's `/` operator. Note: this function uses a
   * `revert` opcode (which leaves remaining gas untouched) while Solidity
   * uses an invalid opcode to revert (consuming all remaining gas).
   *
   * Requirements:
   * - The divisor cannot be zero.
   */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
   * division by zero. The result is rounded towards zero.
   *
   * Counterpart to Solidity's `/` operator. Note: this function uses a
   * `revert` opcode (which leaves remaining gas untouched) while Solidity
   * uses an invalid opcode to revert (consuming all remaining gas).
   *
   * Requirements:
   * - The divisor cannot be zero.
   */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
   * Reverts when dividing by zero.
   *
   * Counterpart to Solidity's `%` operator. This function uses a `revert`
   * opcode (which leaves remaining gas untouched) while Solidity uses an
   * invalid opcode to revert (consuming all remaining gas).
   *
   * Requirements:
   * - The divisor cannot be zero.
   */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
   * Reverts with custom message when dividing by zero.
   *
   * Counterpart to Solidity's `%` operator. This function uses a `revert`
   * opcode (which leaves remaining gas untouched) while Solidity uses an
   * invalid opcode to revert (consuming all remaining gas).
   *
   * Requirements:
   * - The divisor cannot be zero.
   */
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}

interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract Reward is Context, Ownable {


    // power by cash team https://t.me/ferc_cash
    AggregatorV3Interface internal priceFeed;
    uint256 periodNumber; //
    address asset;//ferc
    address asset2;//cash
    uint256 fee;
    uint256 fee1;
    uint256 fee2;
    uint256 fee3;
    uint256 fee4;
    uint256 feeClaim;
    uint256 times5;
    uint256 times3;
    uint256 times2;
    uint256 times1;
    uint256 base5;
    uint256 baseFee;
    uint256 baseTimeOut;
    uint256 public limitAmount;
    uint256 public limitAmountU;
    uint256 public basePay;

    bool public isSale;
    bool public isSaleActive;
    bool public isSaleActiveFree;


    mapping(address => uint256) private newstId; //
    mapping(address => uint256) private balanceShareholderFerc; //
    mapping(address => uint256) private balanceShareholderCash; //
    mapping(address => uint256) private ProfitforacertainperiodoftimeFerc; //
    mapping(address => uint256) private ProfitforacertainperiodoftimeCash; //
    uint256 private ShareholderTotalFerc; //
    uint256 private ShareholderTotalCash; //
    uint256 private profitFerc; //total reward
    uint256 private profitCash; //

    mapping(address => uint256[]) private personHistory;//
    mapping(uint256 => uint256) private rewardHistoryTime;//
    mapping(uint256 => mapping(address => uint256)) private maxPerson; //
    //
    mapping(uint256 => uint256[]) private rewardHistory;                     //
    //
    mapping(address => mapping(uint256 => uint256[])) private SeveralIssues; //
    /**
     * @dev Sets the values for {name} and {symbol}.
     *
     * The defaut value of {decimals} is 18. To select a different value for
     * {decimals} you should overload it.
     *
     * All three of these values are immutable: they can only be set once during
     * construction.
     */
    constructor () {
        priceFeed = AggregatorV3Interface(0x264990fbd0A4796A3E3d8E37C4d5F87a3aCa5Ebf);
        asset = 0xC365B8Cbde40cB902CaE1BDDf425a4c9E1f60d3f;
        asset2 = 0xC78A2bF534110383876d05d59625Dae0a0c5643f;
        periodNumber = 1;
        fee = 90;
        //1 to add reward
        // to
        fee1 = 99;
        // 97 to reward
        fee2 = 1;
        // 1 to jack-gu
        fee3 = 1;
        // 1 to burn
        fee4 = 1;
        // 1 to found
        // to burn
        feeClaim = 70;
        baseFee = 100;
        times5 = 100;
        times3 = 15;
        times2 = 4;
        times1 = 2;
        base5 = 5;
        baseTimeOut = 180;
        limitAmount = 10;
        limitAmountU = 100000;
        basePay = 1 * 10 ** 15;
        isSaleActive = true;
        isSale = true;
    }
    //
    function flipSaleState() public onlyOwner {
        isSaleActive = !isSaleActive;
    }

    function flipSale() public onlyOwner {
        isSale = !isSale;
    }


    function flipSaleStateFree() public onlyOwner {
        isSaleActiveFree = !isSaleActiveFree;
    }

    function getFlipSaleState() public view returns (bool) {
        return isSaleActive;
    }

    function getFlipSaleStateFree() public view returns (bool) {
        return isSaleActiveFree;
    }

    function setFee(uint256 fe, uint256 fe1, uint256 fe2, uint256 fe3, uint256 fe4, uint256 time5, uint256 time3, uint256 time2) public onlyOwner() {
        if (fe != 0) {
            fee = fe;
        }
        if (fe1 != 0) {
            fee1 = fe1;
        }
        if (fe2 != 0) {
            fee2 = fe2;
        }
        if (fe3 != 0) {
            fee3 = fe3;
        }
        if (fe4 != 0) {
            fee4 = fe4;
        }
        if (time5 != 0) {
            times5 = time5;
        }
        if (time3 != 0) {
            times3 = time3;
        }
        if (time2 != 0) {
            times2 = time2;
        }
    }


    function setBasePay(uint256 basePayOne) public onlyOwner() {
        basePay = basePayOne * 10 ** 14;
    }

    function setAsset(address assetOne) public onlyOwner() {
        asset = assetOne;
    }

    function setLimit(uint256 limitOne) public onlyOwner() {
        limitAmount = limitOne;
    }

    function setLimitU(uint256 limitOne) public onlyOwner() {
        limitAmountU = limitOne;
    }


    function setBase5(uint256 base5One) public onlyOwner() {
        base5 = base5One;
    }


    function setFeeClaim(uint256 feeOne) public onlyOwner() {
        feeClaim = feeOne;
    }


    function setBaseTimeOut(uint256 baseTimeOutOne) public onlyOwner() {
        baseTimeOut = baseTimeOutOne;
    }


    function getRewardHistoryTime(uint256 indexOne) public view returns (uint256){
        return rewardHistoryTime[indexOne];
    }

    function doNext() public onlyOwner() returns (uint256[] memory) {
        require(isSale, "Sale is not active");
        (
        /*uint80 roundID*/,
        int price,
        /*uint startedAt*/,
        /*uint timeStamp*/,
        /*uint80 answeredInRound*/
        ) = priceFeed.latestRoundData();

        // :

        //uint256[] ls = new uint256[](5);
        for (uint i = periodNumber; i < periodNumber + 5; i++) {
            uint random = uint(keccak256(abi.encode(block.timestamp, msg.sender, i, price))) % 10;
            //ls.push(random);
            rewardHistory[periodNumber].push(random);
        }
        rewardHistoryTime[periodNumber] = block.timestamp;
        periodNumber += 1;
        return rewardHistory[periodNumber - 1];
    }

    function getRewardHistory(uint256 i) public view returns (uint256[] memory) {
        return rewardHistory[i];
    }

    function getSeveralIssues(address addr, uint256 i) public view returns (uint256[] memory) {
        return SeveralIssues[addr][i];
    }


    function getPersonHistoryAll(address addr) public view returns (uint256[] memory) {
        return personHistory[addr];
    }

    function getPersonHistoryAllLength(address addr) public view returns (uint256) {
        return personHistory[addr].length;
    }

    function getPersonHistoryIndex(address addr, uint256 begin, uint256 end) public view returns (uint256[] memory) {
        uint256 sizeA = end - begin + 1;
        uint256[] memory indexH = new uint256[](sizeA);
        uint256 i = 0;
        for (uint256 i = begin; i <= end; i++) {
            indexH[i] = personHistory[addr][i];
            i++;
        }
        return indexH;
    }


    function getPeriodNumber() public view returns (uint256) {
        return periodNumber;
    }

    //
    function balanceOfTotal(uint256 atype) public view returns (uint256){
        IERC20 token;
        if (atype == 1) {
            token = IERC20(asset);
        } else {
            token = IERC20(asset2);
        }
        return token.balanceOf(address(this));
    }




    //
    function inClude(uint256 atyp, uint256 aAmount) public {
        if (atyp == 1) {
            require(balanceShareholderFerc[msg.sender] == 0, "not zero");
            IERC20 token = IERC20(asset);
            token.transferFrom(msg.sender, address(this), aAmount * 10 ** 18);
            balanceShareholderFerc[msg.sender] += aAmount * 10 ** 18;
            ShareholderTotalFerc += aAmount * 10 ** 18;
            ProfitforacertainperiodoftimeFerc[msg.sender] = profitFerc;
        } else {
            IERC20 token = IERC20(asset2);
            require(balanceShareholderCash[msg.sender] == 0, "not zero");
            token.transferFrom(msg.sender, address(this), aAmount * 10 ** 18);
            balanceShareholderCash[msg.sender] += aAmount * 10 ** 18;
            ShareholderTotalCash += aAmount * 10 ** 18;
            ProfitforacertainperiodoftimeCash[msg.sender] = profitCash;
        }
    }


    //
    function bonus(uint256 atype) public {
        IERC20 token;
        if (atype == 1) {
            token = IERC20(asset);
            uint256 preBalance = balanceShareholderFerc[msg.sender];
            require(preBalance >= 0, "balance must >0");
            uint256 profitOne = preBalance * (profitFerc - ProfitforacertainperiodoftimeFerc[msg.sender]) / ShareholderTotalFerc;
            token.transfer(msg.sender, profitOne);
            profitFerc -= profitOne;
            ProfitforacertainperiodoftimeFerc[msg.sender] = profitFerc;
        } else {
            token = IERC20(asset2);
            uint256 preBalance = balanceShareholderCash[msg.sender];
            require(preBalance >= 0, "balance must >0");
            uint256 profitOne = preBalance * (profitCash - ProfitforacertainperiodoftimeCash[msg.sender]) / ShareholderTotalCash;
            token.transfer(msg.sender, preBalance + profitOne);
            profitCash -= profitOne;
            ProfitforacertainperiodoftimeCash[msg.sender] = profitCash;
        }
    }

    //
    function outClude(uint256 atype) public {
        IERC20 token;
        if (atype == 1) {
            token = IERC20(asset);
            uint256 totalBala = token.balanceOf(address(this));
            uint256 preBalance = balanceShareholderFerc[msg.sender];
            uint256 profitOne = preBalance * (profitFerc - ProfitforacertainperiodoftimeFerc[msg.sender]) / ShareholderTotalFerc;
            require(preBalance >= 0, "balance must >0");
            if (ShareholderTotalFerc >= totalBala) {//loss
                token.transfer(msg.sender, preBalance * totalBala / ShareholderTotalFerc);
            }

            if ((ShareholderTotalFerc < totalBala) && (totalBala <= (preBalance + profitOne))) {
                token.transfer(msg.sender, totalBala);
            }
            if (totalBala > (preBalance + profitOne)) {
                token.transfer(msg.sender, preBalance + profitOne);
            }
            balanceShareholderFerc[msg.sender] = 0;
            ShareholderTotalFerc -= preBalance;
            profitFerc -= profitOne;
        } else {
            token = IERC20(asset2);
            uint256 preBalance = balanceShareholderCash[msg.sender];
            require(preBalance >= 0, "balance must >0");
            uint256 profitOne = preBalance * (profitCash - ProfitforacertainperiodoftimeCash[msg.sender]) / ShareholderTotalCash;
            uint256 totalBala = token.balanceOf(address(this));

            if (ShareholderTotalCash >= totalBala) {//loss
                token.transfer(msg.sender, preBalance * totalBala / ShareholderTotalCash);
            }

            if ((ShareholderTotalCash < totalBala) && (totalBala <= (preBalance + profitOne))) {
                token.transfer(msg.sender, totalBala);
            }
            if (totalBala > (preBalance + profitOne)) {
                token.transfer(msg.sender, preBalance + profitOne);
            }
            balanceShareholderCash[msg.sender] = 0;
            ShareholderTotalCash -= preBalance;
            profitCash -= profitOne;
        }
    }

    //only  after make added  .can do this
    function doClaimAdditional(uint256 atype) public onlyOwner() {
        IERC20 token;
        if (atype == 1) {
            token = IERC20(asset);
            uint256 totalBala = token.balanceOf(address(this));
            require(totalBala >= (ShareholderTotalFerc + profitFerc), "no more bala");
            uint256 profitOne = totalBala - ShareholderTotalFerc - profitFerc;
            token.transfer(msg.sender, profitOne);
        } else {
            token = IERC20(asset2);
            uint256 totalBala = token.balanceOf(address(this));
            require(totalBala >= (ShareholderTotalCash + profitCash), "no more bala");
            uint256 profitOne = totalBala - ShareholderTotalCash - profitCash;
            token.transfer(msg.sender, profitOne);
        }
    }

    function getData(address addr) public view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256){
        uint256 preBalanceFerc = balanceShareholderFerc[addr];
        uint256 preBalanceCash = balanceShareholderCash[addr];
        IERC20 token = IERC20(asset);
        IERC20 token2 = IERC20(asset2);
        uint256 totalFerc = token.balanceOf(address(this));
        uint256 totalCash = token2.balanceOf(address(this));
        return (preBalanceFerc, ShareholderTotalFerc, profitFerc, preBalanceCash, ShareholderTotalCash, profitCash,totalFerc,totalCash);
    }



    //
    function doPer(uint256 aType, uint256 aAmount, uint256 a, uint256 b, uint256 c, uint256 d, uint256 e, uint256 assetType) public {
        require(aAmount >= limitAmount, "aAmount less than limitAmount");
        require(aAmount <= limitAmountU, "aAmount more than limitAmount");

        IERC20 token;
        if (assetType == 1) {
            token = IERC20(asset);
        } else {
            token = IERC20(asset2);
        }
        require(isSaleActive, "Sale is not active");

        if (periodNumber != 1) {
            require(block.timestamp >= rewardHistoryTime[periodNumber - 1] && block.timestamp <= rewardHistoryTime[periodNumber - 1] + baseTimeOut, "time out");
        }
        if (balanceOfOne(msg.sender, 1) > 0) {
            doClaim(1);
        }
        if (balanceOfOne(msg.sender, 2) > 0) {
            doClaim(2);
        }

        require(getIsPle(msg.sender), "already ple");
        token.transferFrom(msg.sender, address(this), aAmount * 10 ** 18);
        SeveralIssues[msg.sender][periodNumber] = [aType, aAmount, a, b, c, d, e, 0, assetType];
        newstId[msg.sender] = periodNumber;
        personHistory[msg.sender].push(periodNumber);
    }


    //
    function getNewsId(address addr) public view returns (uint256){
        return newstId[addr];
    }


    // true  can buy ; false not can buy
    function getIsPle(address addr) public view returns (bool){
        return newstId[addr] != periodNumber;
    }

    //
    function doClaim(uint256 atype) public {
        IERC20 token;
        if (atype == 1) {
            token = IERC20(asset);
        } else {
            token = IERC20(asset2);
        }

        uint256 reward = balanceOfOne(msg.sender, atype);
        uint256 rewardPre = balanceOfPre(msg.sender, atype);
        require(reward != 0, "reward is 0");
        uint256 toTalBalance = token.balanceOf(address(this));
        if (reward * 10 ** 18 >= toTalBalance) {
            token.transfer(msg.sender, toTalBalance * feeClaim / baseFee);
        } else {
            token.transfer(msg.sender, reward * 10 ** 18);
            if (atype == 1 && ShareholderTotalFerc > 0) {
                profitFerc += rewardPre * 10 ** 18 * 10 / 100;
            }
            if (atype == 2 && ShareholderTotalCash > 0) {
                profitCash += rewardPre * 10 ** 18 * 10 / 100;
            }
            if (isSaleActiveFree) {
                token.transfer(0x8844A26344C97134B0D5bd8B8493C5Ab10799843, reward * 10 ** 18 * fee2 / 100);
            }
        }
        uint256 iss = newstId[msg.sender];

        SeveralIssues[msg.sender][iss][7] = 1;
        //
    }

    // whithdraw owner
    function withDraw(uint256 amount, uint256 atype) public onlyOwner {
        if (atype == 1) {
            IERC20 token = IERC20(asset);
            token.transfer(owner(), amount * 10 ** 18);
        } else {
            IERC20 token = IERC20(asset2);
            token.transfer(owner(), amount * 10 ** 18);
        }
    }

    //
    function balanceOfOne(address addr, uint256 assetType) public view returns (uint256){
        uint256 iss = newstId[addr];
        if (iss == 0) {
            return 0;
        }
        uint256[] memory pushOne = SeveralIssues[addr][iss];
        uint256[] memory nums = rewardHistory[iss];
        if (newstId[addr] == periodNumber) {//
            return 0;
        }
        if (assetType != pushOne[8]) {
            return 0;
        }
        uint sig;
        uint dou;
        for (uint i = 0; i < 5; i++) {
            uint numone = rewardHistory[iss][i];
            if (numone == 0 || numone == 2 || numone == 4 || numone == 6 || numone == 8) {
                dou++;
            } else {
                sig++;
            }
        }
        if (pushOne[7] == 1) {//
            return 0;
        } else {//
            if (pushOne[0] == 0) {//
                if (sig > dou) {//
                    return pushOne[1] * 2 * fee / baseFee;
                } else {
                    return 0;
                }

            } else if (pushOne[0] == 1) {//
                if (dou > sig) {//
                    return pushOne[1] * 2 * fee / baseFee;
                } else {
                    return 0;
                }

            } else if (pushOne[0] == 2) {//
                //uint256[] memory numsls = pushOne[2];
                if (pushOne[2] == rewardHistory[iss][0] && pushOne[3] == rewardHistory[iss][1] && pushOne[4] == rewardHistory[iss][2] && pushOne[5] == rewardHistory[iss][3] && pushOne[6] == rewardHistory[iss][4]) {
                    return pushOne[1] * times5 * fee / baseFee;
                } else if ((pushOne[2] == rewardHistory[iss][0] && pushOne[3] == rewardHistory[iss][1] && pushOne[4] == rewardHistory[iss][2]) || (pushOne[4] == rewardHistory[iss][2] && pushOne[5] == rewardHistory[iss][3] && pushOne[6] == rewardHistory[iss][4])) {
                    return pushOne[1] * times3 * fee / baseFee;
                } else if ((pushOne[2] == rewardHistory[iss][0] && pushOne[3] == rewardHistory[iss][1]) || (pushOne[5] == rewardHistory[iss][3] && pushOne[6] == rewardHistory[iss][4])) {
                    return pushOne[1] * times2 * fee / baseFee;
                } else if ((pushOne[2] == rewardHistory[iss][0] || pushOne[6] == rewardHistory[iss][4])) {
                    return pushOne[1] * times1 * fee / baseFee;
                } else {
                    return 0;
                }
            }
        }
        return 0;
    }

    //
    function balanceOfPre(address addr, uint256 assetType) public view returns (uint256){
        uint256 iss = newstId[addr];
        if (iss == 0) {
            return 0;
        }
        uint256[] memory pushOne = SeveralIssues[addr][iss];
        uint256[] memory nums = rewardHistory[iss];
        if (newstId[addr] == periodNumber) {//
            return 0;
        }
        if (assetType != pushOne[8]) {
            return 0;
        }
        uint sig;
        uint dou;
        for (uint i = 0; i < 5; i++) {
            uint numone = rewardHistory[iss][i];
            if (numone == 0 || numone == 2 || numone == 4 || numone == 6 || numone == 8) {
                dou++;
            } else {
                sig++;
            }
        }
        if (pushOne[7] == 1) {//
            return 0;
        } else {//
            if (pushOne[0] == 0) {//
                if (sig > dou) {//
                    return pushOne[1] * 2;
                } else {
                    return 0;
                }

            } else if (pushOne[0] == 1) {//
                if (dou > sig) {//
                    return pushOne[1] * 2;
                } else {
                    return 0;
                }

            } else if (pushOne[0] == 2) {//
                //uint256[] memory numsls = pushOne[2];
                if (pushOne[2] == rewardHistory[iss][0] && pushOne[3] == rewardHistory[iss][1] && pushOne[4] == rewardHistory[iss][2] && pushOne[5] == rewardHistory[iss][3] && pushOne[6] == rewardHistory[iss][4]) {
                    return pushOne[1] * times5;
                } else if ((pushOne[2] == rewardHistory[iss][0] && pushOne[3] == rewardHistory[iss][1] && pushOne[4] == rewardHistory[iss][2]) || (pushOne[4] == rewardHistory[iss][2] && pushOne[5] == rewardHistory[iss][3] && pushOne[6] == rewardHistory[iss][4])) {
                    return pushOne[1] * times3;
                } else if ((pushOne[2] == rewardHistory[iss][0] && pushOne[3] == rewardHistory[iss][1]) || (pushOne[5] == rewardHistory[iss][3] && pushOne[6] == rewardHistory[iss][4])) {
                    return pushOne[1] * times2;
                } else if ((pushOne[2] == rewardHistory[iss][0] || pushOne[6] == rewardHistory[iss][4])) {
                    return pushOne[1] * times1 * fee / baseFee;
                } else {
                    return 0;
                }
            }
        }
        return 0;
    }
}