{"M0.sol":{"content":"// SPDX-License-Identifier: Unlicensed\r\npragma solidity \u003e=0.4.22 \u003c0.9.0;\r\nimport \"./Smart_Binance.sol\";\r\nimport \"./M1.sol\";\r\ncontract Smart_Binance_Base { struct Node {\r\n        uint32 id;\r\n        uint32 AL;\r\n        uint32 AR;\r\n        uint24 LT;\r\n        uint24 RT;\r\n        uint8 XI;\r\n        bool YY;\r\n        address UP;\r\n        address PO;\r\n        address QO; }\r\n    mapping(address =\u003e Node) internal KW;\r\n    mapping(address =\u003e uint8) internal EE;\r\n    mapping(uint32 =\u003e address) internal VV;\r\n    mapping(uint256 =\u003e address) internal JJ;\r\n    mapping(uint24 =\u003e address) internal JL;\r\n    mapping(uint24 =\u003e address) internal JO;\r\n    mapping(uint16 =\u003e address) internal LM;\r\n    mapping(uint8 =\u003e address) internal UM;\r\n    address internal R_S;\r\n    address internal SBT;\r\n    address internal OP;\r\n    address internal JY;\r\n    IERC20 internal SC;\r\n    uint32 internal JK;\r\n    uint32 internal JP;\r\n    uint24 internal DJ;\r\n    uint24 internal DW;\r\n    uint24 internal ZL;\r\n    uint16 internal DS;\r\n    uint256 internal ZS;\r\n    uint256 internal ZM;\r\n    uint256 internal DZ;\r\n    uint8 internal LK;\r\n    uint8 internal DF;\r\n    Smart_Binance internal NBJ;\r\n    M1 internal NBJ2;\r\n    string internal Note;\r\n    string internal IPFS; }"},"M1.sol":{"content":"\r\n// SPDX-License-Identifier: Unlicensed\r\n\r\npragma solidity \u003e=0.4.22 \u003c0.9.0;\r\n\r\ncontract M1{ \r\n    address[] internal ZA1;\r\n\r\n    constructor(){ ZA1 = [ \r\n \r\n0x229F41B26259f788404326CD6f5b5440436f1E6F,\r\n0x8036f0E62F59F96e3d8bdc6524B61F670BB71368,\r\n0x741F8dd63364213b74eE3f6b9b8A87Ca4AC10Bd8,\r\n0xA86E5bc348827dEa632e3e678fc434E4Ae5eE0e7,\r\n0xFDc61645F8Da51cD55BAa4AA1BfEAEC715273cA8,\r\n0x52C5190bc9cA25b164b24adf1DE618D056F548C8,\r\n0xd5eabC219677b0290d0c1679eA491a8b1c3F4388,\r\n0xB34e76aEeeBb2fBDFd4F79B44b0456C35692cf2b,\r\n0x109dB8B9E2B7849ce8CA5688e9c0d7Ea6063796e,\r\n0xc6B1D663a3A896A4bcBB13E47b1C5f463d157Fa7,\r\n0x2323d3046dd40C3FEEe313632028c5871235070A,\r\n0xc358a510198c96dE580dF0a025575438cdD0AdbC,\r\n0x41a3c175296eace8d6CfD04Ae118EA1b0002b5c3,\r\n0x640F3438fc74220C6576bBAab75A89449dC8Ac08,\r\n0x3dc744F949e636C689f01A673B70ecDAd607AC3D,\r\n0x016B3EDFA1E94123cF17A4Af8fCb8F7A9c0a6169,\r\n0x968E79FE717F0D0ddac4a52E855841dF540503bA,\r\n0xBB88d860D5AB53Be61f6d6dfD6cB9Ef278cc8377,\r\n0xf19A7b8c8f3e65E0422D019d50493A8E94115f1B,\r\n0x5821516eee888B9d800C0B630041aaA121c5821D,\r\n0x35b27097176cD1DEA0e1Ed295047093C75421616,\r\n0xa5651b6Ffee6B69D90C89EB0Ca6c5322a08c771B,\r\n0x83004A2F71F3A8E403A6F646472827C26C49EA0A,\r\n0x9D82c460dEb9491cBB0f238bacE88E1F36F93C03,\r\n0x9bA2C7DFaE04453891C31e326A84eDD3B8e35E58,\r\n0xb28a5CdD057C84339aeBFeC1C02583e8BD652436,\r\n0x8268B143804EFb6Ab3E12d16a6872B894EAa3b12,\r\n0x4e602942613533DDd27BdeeB090c07bE94a6eF21,\r\n0xBDC20109a81F3B892144e6Ad22478B6a4f210aa6,\r\n0x47A48cd9dDAA7ac8e855b5C36fBde0b928F66Fe6,\r\n0x0508A18e825900886505486082894138144b4461,\r\n0xd57b7751Ec93A431A3dB14892dD67f8e638077d5,\r\n0x8513844e9cf778451429Efb055F59bdf2E8A84e5,\r\n0x10798f8fD33F8DA701d59ddD973bFF5Fd76545DC,\r\n0xf6132D3bc9CA091189aEEBc0f6a60dAB82E54788,\r\n0xCf438Ad92D193374CF589d4F5Db54F46ea6f711d,\r\n0x89Cde2C2814f780D2024490102F698D414fd3491,\r\n0x03805C7f530d3f33227D993Efc9913232Ed22D72,\r\n0xb04b2bD517826d47efd5f41979B0012923E3D3Ac,\r\n0x8a9a0165E0EFFaEE8AdA17843e092C737aF06125,\r\n0xAB6E0552Fc461dA53bA4E1297f9eAeF415fCaa29,\r\n0xF7Dd9589525e7169504D2D52C62442Ca6cecC2f0,\r\n0xF495551b8872267f1bE20fe08c615B4197466b60,\r\n0x2AAb2899815e405022b27E2d8cEF0AeDc4D4D8af,\r\n0x21447a36CDB8d226d60C92728C4cb48E238F27e9,\r\n0xA727FdB45Ece340FBD464b0045E0B43Bfc8e60da,\r\n0xD2986B8d049fD8395a2be92E8bC657EdBC615D46,\r\n0x4bE69E87f133003B762E004419578FDDFd5Bf58b,\r\n0x5dD246E2e1E4791378bdfB0eAc4A9CDA564F645b,\r\n0xBC3d7921Ca4c011F4E89639Fc13e6a17C0F90702,\r\n0xD664D9B52C3a2Bc63DBe0F3f4898E1C60B05D230,\r\n0xB4DEF4C5BB93b218F5533e650Ff1bC393c7e5256,\r\n0xeA67da11956b473B89ead7B8e72bCCeBde6722a5,\r\n0x22994cCaFEE7541db1bA6E7Fe9Bec815A6321d08,\r\n0x49760277c7AeDcC7C83E171f0ADf972A7235b8b6,\r\n0xeEEe1B500Ba97b9806FA6DFeaC1FCb6d5666e139,\r\n0x2A64F9E9796D6235D72BdF33Cde4633f60cb871D,\r\n0xF9b2B8bdD755e8DA29c6481Ef4F3BE287Bb16009,\r\n0x1435C3a8303B5d6BCE56298500882F6D9e4dBd96,\r\n0xfe8b395659F09637a27aFA277a4DEcCe8f13Fb20,\r\n0xdb44Cd96d11e01C93BCf1b688929BCd947ab673C,\r\n0x209A0BDDa602A6027124580F41Fec85F14e70768,\r\n0x25f0cBA97082CF3eCfBB9F27193806a312E984E5,\r\n0xc9f036022587E6F5F24234ebe7b7b832644B6cf1,\r\n0x630F7D376b78d73451339e6dB454aA8084e66Fd5,\r\n0x6b8410eE4723885258fE99321fB485c2EFAD057f,\r\n0x567b12c3dC373fBDAd54b46bA1Bc12f2A58fAd4c,\r\n0x80b41BD9330ebB9FE309E17B02a46319b072CA0C,\r\n0x8Da33f6883a2230608b59cc0505A82BA986d972E,\r\n0x8BEc655F41B1E29451Dc539bfDc7b51287Ab44AC,\r\n0xC63c54ccf82eC0d80D19AE6bA210fD45704F6bA9,\r\n0x657a0989a556955D8b47545B338db2C2Cbd693A1,\r\n0x1d081EBA065D2F374F4C03B9A1A80c698bca5BeB,\r\n0x7Dc9C5BFC9bBb36C3A0ccddc41020bDdb1896730,\r\n0xF3dAD4020000574ea1d2B28992C84Da3cb41dbDf,\r\n0xa9a556F1eD3F1bAf11F738891Fa163A981506Bfa,\r\n0x27F69162Cc71E544ba1f79d605571dd39669026A,\r\n0xe32640B5618d1B28167cFFdcd2A02Ccf8Df26d92,\r\n0xf7604712Fca81D7A68a212E4d941ea0fb1c386B6,\r\n0xE4010c88f5BF564E5F74425f8C3a1f659Cf262F8,\r\n0x07d2476A3540986c9c7F94319D9883C7938A8ba8,\r\n0x59896bc359AC2F68Ce50b571C7D3d581B823E82F,\r\n0x584Ec2dda41af732e7065ad038a94e81215312A3,\r\n0xBE3499298Eb20E24C72bf71D20EEdB4D6c29bF6C,\r\n0xBDcf1EDF24af2900aA44610669671922ad0dd473,\r\n0x9ebc410ea1b2742d33D7697E9a514FF2197B3887,\r\n0x1423391e41D559eC20f30150412f567d8505f346,\r\n0x4473d67e673D751fE9D982eA8e9888B3b28ef830,\r\n0xE2615BEDdAEc4dfF0ABABC5aA2192146E247b9a7,\r\n0x6E8312907290b7da564643559aa7450Ade70E930,\r\n0xECCd4D30C3DD376B63725b2d8035468517358581,\r\n0x527D8B18C08430cA36cB7e35792Bd2C3304b0bed,\r\n0x67A812ce5a4671bBA71F769834BdEb3358665e3B,\r\n0x06799285C246f702A51717EAb5Fd7ded26b5FDE8,\r\n0xfcE1B97dE5bb7d219a9F381fc0e61c6C71391e9c,\r\n0xB6480c05D9901280d364738Ac8f4039ded148aDf,\r\n0xE9135a55075Fd1967e58D61978F6545b2830717D,\r\n0xcC48a06Ab93bb1d863423dd061279F8de252F637,\r\n0xba5afcef66960Aa0Ba49ED216ACAd1AD0AdA96F6,\r\n0x48ab47B53924Ee8FFef569E4aD7B54518771187c\r\n\r\n ];} function GetAddress() public view \r\n     returns(address[] memory){ return ZA1; } }"},"Smart_Binance.sol":{"content":"// SPDX-License-Identifier: Unlicensed\r\npragma solidity \u003e=0.4.22 \u003c0.9.0;\r\nimport \"./Smart_Binary.sol\";\r\ncontract Smart_Binance is Context {\r\n    using SafeERC20 for IERC20; struct SEP { uint24 LD; uint24 RD; uint8 TCP; uint16 DP; uint8 CH; uint8 OR; address UPA; address LDA; address RDA;}\r\n    mapping(address =\u003e SEP) private _XB; mapping(uint128 =\u003e address) private JK; mapping(uint16 =\u003e address) private _DUP;\r\n    address[] private EW; address[] private _PY; address[] private _X_N; uint32[] private _RNN; uint256 private LSR;\r\n    uint256 private LRF; uint256 private V_F; uint128 private _U_Z; uint128 private ZA_D; uint64 private _CF; uint64 private _CU_PY;\r\n    uint16 private _DUPId; uint8 private Lk; uint8 private Count_Upload; uint8 C_G; address private R_S; address private _SBT; address private Operator;\r\n    IERC20 private S_Coin; string private Note; string private IPFS; Smart_Binary private NBJ;\r\n    constructor() {R_S = _msgSender(); LSR = block.timestamp;\r\n        S_Coin = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\r\n        _SBT = 0x52B5BD79C5B56B52747d735809177d9ee686E48e;\r\n        Operator = 0xF9B29B8853c98B68c19f53F5b39e69eF6eAF1e2c;\r\n        NBJ = Smart_Binary(0x3164B3841D2b603ddB43C909C7f6Efd787058541);}\r\n    function Reward_12() public {require(Lk == 0, \"Proccesing\");\r\n        require(_XB[_msgSender()].TCP \u003e 0, \"You dont have point\" );\r\n        require(block.timestamp \u003e LSR + 12 hours, \"Reward_12 time has not come\");\r\n        Lk = 1; uint256 ZZ = (PRP() * 90) - (Total_Point() * 10**18); V_F = (PRP() * 10);\r\n        uint256 QA = ((ZZ)) / Total_Point(); uint128 R_C = (Total_Point()) * 10**18;\r\n        for(uint128 i = 0; i \u003c= _U_Z; i = unsafe_inc(i)) {SEP memory T_DE = _XB[JK[i]];\r\n        uint24 Pnt; uint24 RLT = T_DE.LD \u003c= T_DE.RD ? T_DE.LD : T_DE.RD;\r\n        if (RLT \u003e 0) {if (RLT \u003e 25) {Pnt = 25; if (T_DE.LD \u003c RLT) { T_DE.LD = 0; T_DE.RD -= RLT;} \r\n        else if (T_DE.RD \u003c RLT) {T_DE.LD -= RLT; T_DE.RD = 0;} else {T_DE.LD -= RLT; T_DE.RD -= RLT;}} else {Pnt = RLT; \r\n        if (T_DE.LD \u003c Pnt) {T_DE.LD = 0; T_DE.RD -= Pnt;} else if (T_DE.RD \u003c Pnt) { T_DE.LD -= Pnt; T_DE.RD = 0;} \r\n        else {T_DE.LD -= Pnt; T_DE.RD -= Pnt;}} T_DE.TCP = 0; _XB[JK[i]] = T_DE;\r\n        if (Pnt * QA \u003e S_Coin.balanceOf(address(this))) {S_Coin.safeTransfer(JK[i],S_Coin.balanceOf(address(this)));} \r\n        else {S_Coin.safeTransfer( JK[i], Pnt * QA);}_PY.push(JK[i]); _CU_PY++;}} LSR = block.timestamp;\r\n        if (R_C \u003c= S_Coin.balanceOf(address(this))) {S_Coin.safeTransfer(_msgSender(), R_C);} Lk = 0; C_G = 1; LRF = block.timestamp;}\r\n    function Register(address upline) public {require(_XB[upline].CH != 2,\"Upline has two directs!\");\r\n        require(_msgSender() != upline, \"You can not enter your address!\");\r\n        bool UU = false; for(uint128 i = 0; i \u003c= _U_Z; i = unsafe_inc(i)) {if (JK[i] == _msgSender()) {UU = true; break;}} require(UU == false, \"You were registered!\");\r\n        bool WH = false; for(uint128 i = 0; i \u003c= _U_Z; i = unsafe_inc(i)) {if (JK[i] == upline) { WH = true; break;}} require(WH == true, \"Upline is not exist!\");\r\n        S_Coin.safeTransferFrom(_msgSender(), address(this), 100 * 10**18 ); JK[_U_Z] = _msgSender(); _U_Z++;\r\n        uint16 D_X = _XB[upline].DP + 1; _XB[_msgSender()] = SEP(0,0,0,D_X,0,_XB[upline].CH, upline, address(0), address(0));\r\n        if (_XB[upline].CH == 0) { _XB[upline].LD++; _XB[upline].LDA = _msgSender();} else {_XB[upline].RD++; _XB[upline].RDA = _msgSender(); } _XB[upline].CH++; setTDP(upline);\r\n        address UPN = _XB[upline].UPA; address ChNde = upline; for( uint128 j = 0; j \u003c _XB[upline].DP; j = unsafe_inc(j)){ \r\n        if (_XB[ChNde].OR == 0) {_XB[UPN].LD++; } else {_XB[UPN].RD++; } setTDP(UPN); ChNde = UPN; UPN = _XB[UPN].UPA;}}\r\n    function Gift_3() public {require(C_G == 1,\"Gift_3 time has not come!\");\r\n        require(block.timestamp \u003e LRF + 3 hours, \"Gift_3 time has not come\");\r\n        require(V_F \u003e 20*10**18, \"Gift balance is not enough!\" );\r\n        require(_CF \u003e 0, \"There is no candidate!\" );\r\n        bool II = false; for(uint128 i = 0; i \u003c _CF; i = unsafe_inc(i)) {if (EW[i] == _msgSender()) {II = true; break;}}\r\n        require(II == true, \"You are not candidated!\"); S_Coin.safeTransfer(_msgSender(),10 * 10**18);\r\n        uint256 NW = ((V_F - 10*10**18) / 10**18) / 10; if (NW != 0 \u0026\u0026 _CF != 0) {if (_CF \u003e NW) {\r\n        for(uint32 i = 1; i \u003c= _CF; i++ ) {_RNN.push(i);} for(uint128 i = 1; i \u003c= NW; i = unsafe_inc(i)){\r\n        uint256 randomIndex = uint256(keccak256(abi.encodePacked(block.timestamp, msg.sender, i))) % _CF;\r\n        uint128 RSN = _RNN[randomIndex]; _RNN[randomIndex] = _RNN[ _RNN.length - 1 ]; _RNN.pop();\r\n        if(_XB[EW[RSN - 1]].TCP == 0){ S_Coin.safeTransfer(EW[RSN - 1], 10 * 10**18 );}}\r\n        for(uint128 i = 0; i \u003c (_CF - NW); i = unsafe_inc(i)) {_RNN.pop();}} else {for (uint128 i = 0; i \u003c _CF; i = unsafe_inc(i))\r\n        {S_Coin.safeTransfer(EW[i], 10 * 10**18 );}}} delete EW; _CF = 0; V_F = 0; C_G = 0; delete _PY; _CU_PY=0;}\r\n    function Smart_Gift() public { require(C_G == 1,\"Smart_Gift time has not come!\");\r\n        bool UPY = false; for(uint128 i = 0; i \u003c _CU_PY; i = unsafe_inc(i)) {if (_PY[i] == _msgSender()) { UPY = true; break;}}  require(UPY == false, \"You have point!\");\r\n        bool UU = false; for(uint128 i = 0; i \u003c= _U_Z; i = unsafe_inc(i)) {if (JK[i] == _msgSender()) { UU = true; break;}}\r\n        require(UU == true, \"You are not registered!\");\r\n        bool II = false; for(uint128 i = 0; i \u003c _CF; i = unsafe_inc(i)) {if (EW[i] == _msgSender()) { II = true; break;}}\r\n        require(II == false, \"You were candidated!\");\r\n        require(((((V_F - 10*10**18) / 10**18) / 10)*2) \u003e (_CF), \"Capacity is completed!\"); EW.push(_msgSender()); _CF++;}\r\n    function Emergency_72() public {require(_msgSender() == Operator, \"Just operator can write!\");\r\n        require(block.timestamp \u003e LSR + 72 hours, \"Emergency_72 time has not come\");\r\n        S_Coin.safeTransfer(R_S, S_Coin.balanceOf(address(this)) );}\r\n    function Buy_SBT() public {require(S_Coin.balanceOf(_msgSender()) \u003e= (10 * 10**18), \"You dont have enough S_Coin!\");\r\n        S_Coin.safeTransferFrom(_msgSender(),address(this), 10 * 10**18 ); IERC20(_SBT).transfer(_msgSender(), 100 * 10**18);}\r\n    function Get_SBT() public {bool CC = false; for (uint128 i = 0; i \u003c= _U_Z; i = unsafe_inc(i)) {if (JK[i] == _msgSender()) {CC = true; break;}}\r\n        require(CC == true, \"You are not registered!\" );\r\n        bool TAU = false; for (uint128 i = 0; i \u003c ZA_D; i = unsafe_inc(i)) {if (_X_N[i] == _msgSender()) {TAU = true; break;}}\r\n        require(TAU == false,\"You can not receive SBT again!\"); IERC20(_SBT).transfer(_msgSender(), 100 * 10**18); _X_N.push(_msgSender()); ZA_D++;}\r\n    function Import (address User) public {\r\n        bool UU = false; for(uint128 i = 0; i \u003c= _U_Z; i = unsafe_inc(i)) {if (JK[i] == User) {UU = true; break;}} require(UU == false, \"You were registered!\");\r\n        bool TDUP = false; for(uint16 i = 0; i \u003c= _DUPId; i++) {if (_DUP[i] == User) {TDUP = true; break;}} require(TDUP == false, \"You were uploaded!\");\r\n        require(NBJ.User_Information(User).UplineAddress != address(0), \"You were not in Smart Binary\");\r\n        JK[_U_Z] = User; _XB[JK[_U_Z]] = SEP( \r\n          uint24(NBJ.User_Information(User).leftDirect),\r\n          uint24(NBJ.User_Information(User).rightDirect), 0,\r\n          uint16(NBJ.User_Information(User).depth),\r\n          uint8(NBJ.User_Information(User).childs),\r\n          uint8(NBJ.User_Information(User).leftOrrightUpline),\r\n        NBJ.User_Information(User).UplineAddress,\r\n        NBJ.User_Information(User).leftDirectAddress,\r\n        NBJ.User_Information(User).rightDirectAddress); _U_Z++;}\r\n    function Upload (address User, uint24 L, uint24 R, uint16 D, uint8 C, uint8 LR, address UA, address LA, address RA) \r\n    public {require(_msgSender() == Operator, \"Just operator can write!\");\r\n    require(Count_Upload \u003c= 60, \"Its over!\"); JK[_U_Z] = User; _XB[JK[_U_Z]] = SEP(L,R,0,D,C,LR,UA,LA,RA); _U_Z++; Count_Upload++;}\r\n    function Stable_Coin(address add) public{ require(_msgSender() == Operator, \"Just operator can write!\"); S_Coin = IERC20(add);}\r\n    function PRP() private view returns (uint256) { return (S_Coin.balanceOf(address(this))) / 100;}\r\n    function setTDP(address Q) private {uint24 min = _XB[Q].LD \u003c= _XB[Q].RD ? _XB[Q].LD : _XB[Q].RD; if (min \u003e 0) {_XB[Q].TCP = uint8(min);}}\r\n    function unsafe_inc(uint128 x) private pure returns (uint128) { unchecked { return x + 1;}}\r\n    function Add_DUP(address add) public {require(_msgSender() == Operator, \"Just operator can write!\"); _DUP[_DUPId] = add; _DUPId++;}\r\n    function Write_Note(string memory N) public {require(_msgSender() == Operator, \"Just operator can write!\"); Note = N;}\r\n    function Write_IPFS(string memory I) public {require(_msgSender() == Operator, \"Just operator can write!\"); IPFS = I;}\r\n    function User_Info(address User) public view returns (SEP memory) {return _XB[User];}\r\n    function Contract_Balance() public view returns (uint256) {return (S_Coin.balanceOf(address(this)) - V_F) / 10**18;}\r\n    function Reward_12_Writer () public view returns (uint256) {return Total_Point();}\r\n    function Reward_Balance () public view returns (uint256) {if(C_G == 1){return (((S_Coin.balanceOf(address(this)) - V_F)/100)*90) / 10**18; } else{ return (PRP() * 90) / 10**18;}}\r\n    function Gift_Balance() public view returns (uint256) {if(C_G == 1){return V_F / 10**18; } else{ return (PRP() * 10) / 10**18;}}\r\n    function Gift_Candidate() public view returns (uint256) {return _CF;}\r\n    function All_Register() public view returns (uint256) {return _U_Z;}\r\n    function User_Upline(address User) public view returns (address) {return _XB[User].UPA;}\r\n    function User_Directs(address User) public view returns (address, address) {return (_XB[User].LDA, _XB[User].RDA );}\r\n    function User_Left_Right(address User) public view returns (uint256, uint256) {return ( _XB[User].LD, _XB[User].RD );}\r\n    function Total_Point () public view returns (uint128) { uint128 TPnt; for (uint128 i = 0; i \u003c= _U_Z; i = unsafe_inc(i)){\r\n    uint32 min = _XB[JK[i]].LD \u003c= _XB[JK[i]].RD ? _XB[JK[i]].LD : _XB[JK[i]].RD; if (min \u003e 25) {min = 25;} TPnt += min;} return TPnt;}\r\n    function Value_Point() public view returns (uint256) {if (Total_Point() == 0) {return Reward_Balance();} else {return ((Reward_Balance ()) - (Total_Point())) / (Total_Point());}}\r\n    function Read_Note() public view returns (string memory) {return Note;}\r\n    function Read_IPFS() public view returns (string memory) {return IPFS;} \r\n    function Gift_3_Writer() public view returns (uint256){ if(V_F \u003e 20*10**18){return 10; } else{return 0;}}\r\n    function SBT () public view returns (address) {return _SBT;}}\r\n"},"Smart_Binance_Pro.sol":{"content":"// SPDX-License-Identifier: Unlicensed\r\npragma solidity \u003e=0.4.22 \u003c0.9.0;\r\nimport \"./M0.sol\";\r\ncontract Smart_Binance_Pro is Context,Smart_Binance_Base{\r\n    using SafeERC20 for IERC20;\r\n    constructor(){\r\n        R_S = _msgSender();\r\n        SC = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\r\n        SBT = 0x4DB1B84d1aFcc9c6917B5d5cF30421a2f2Cab4cf;\r\n        OP = 0xF9B29B8853c98B68c19f53F5b39e69eF6eAF1e2c;\r\n        NBJ = Smart_Binance(0x5741da6D2937E5896e68B1604E25972a4834C701);\r\n        NBJ2 = M1(0xE7118092f193A88c85BCFe99dB8Fc104c702E486);\r\n        ZS = block.timestamp;}\r\n    function Register(address Up) external {DC(Up);}\r\n    function DC(address Up) private {\r\n        require(KW[Up].XI != 2, \" Upline Has 2 directs \");\r\n        require(_msgSender() != Up, \" Dont enter your address \" );\r\n        require(!DX(_msgSender()), \" You Are registered \");\r\n        require(DX(Up), \" Upline is Not Exist \");\r\n        SC.safeTransferFrom(_msgSender(), address(this), 100 * 10**18);\r\n        VV[JK] = _msgSender(); JK++;\r\n        Node memory user = Node({ id: JK, AL: 0, AR: 0, LT: 0, RT: 0, XI: 0, YY: KW[Up].XI == 0 ? false : true,\r\n        UP: Up, PO: address(0), QO: address(0) });\r\n        KW[_msgSender()] = user;  JJ[DZ] = _msgSender(); DZ++;\r\n        if (KW[Up].XI == 0) {KW[Up].LT++; KW[Up].AL++; KW[Up].PO = _msgSender();} \r\n        else {KW[Up].RT++; KW[Up].AR++; KW[Up].QO = _msgSender();}\r\n        KW[Up].XI++; IERC20(SBT).transfer(_msgSender(), 100 * 10**18);}\r\n    function Reward_12_Report() external {DH();}\r\n    function DH() private {require(LK == 0, \" Proccesing \");\r\n        require(block.timestamp \u003e ZS + 12 hours, \" Reward_12_Report Time Has Not Come \");\r\n        ZB(); require(ZI() \u003e 0, \" Total Point Is 0 \");\r\n        LK = 1; ZL = ZI(); JY = _msgSender();\r\n        uint256 ZO = ZK(); ZM = ZO; uint256 D_T = (DZ * 10 ** 18 );\r\n       for (uint24 i = 0; i \u003c DJ; i++) { Node memory ZN = KW[JL[i]]; uint24 UT = ZH(JL[i]);\r\n            if (ZN.LT == UT) {ZN.LT = 0; ZN.RT -= UT;} \r\n            else if (ZN.RT == UT) {ZN.LT -= UT; ZN.RT = 0;} \r\n            else { if (ZN.LT \u003c ZN.RT) {ZN.RT -= ZN.LT; ZN.LT = 0;} \r\n            else {ZN.LT -= ZN.RT; ZN.RT = 0;}}  KW[JL[i]] = ZN;\r\n            if (UT * ZO \u003e SC.balanceOf(address(this))) \r\n            {SC.safeTransfer(JL[i], SC.balanceOf(address(this)));} \r\n            else {SC.safeTransfer(JL[i], UT * ZO);}}\r\n        if (D_T \u003c= SC.balanceOf(address(this))) {SC.safeTransfer(_msgSender(), D_T);}\r\n        ZS = block.timestamp; DZ = 0; DJ = 0; DW = 0; DS = 0; LK = 0;}\r\n    function ZB() private {address ZC; address ZD;\r\n        for (uint256 k = 0; k \u003c DZ; k++) {ZC = KW[KW[JJ[k]].UP] .UP; ZD = KW[JJ[k]].UP;\r\n            if (ZE(ZD) == true) { JL[DJ] = ZD; DJ++; }\r\n            while (ZC != address(0)) { if (KW[ZD].YY == false) { KW[ZC].LT++; KW[ZC].AL++;} \r\n            else { KW[ZC].RT++; KW[ZC].AR++;} \r\n            if (ZE(ZC) == true) { JL[DJ] = ZC; DJ++;} ZD = ZC; ZC = KW[ZC].UP;}}}\r\n    function Smart_Gift(uint8 YourNumber) external {\r\n        require(LK == 0, \"Proccesing\");\r\n        require(YourNumber \u003c 6 \u0026\u0026 YourNumber \u003e 0, \" Just : 1,2,3,4,5 \" );\r\n        require(DX(_msgSender()), \" User is Not Exist \");\r\n        require(User_All_Time_Point(_msgSender()) \u003c 1, \" Just All Time 0 Point \");\r\n        require(Just_Gift_Balance() \u003e 0, \" Smart_Gift Balance Is 0 \");\r\n        require(ZF(_msgSender()), \" You Did Smart_Gift Today \");\r\n        JO[DW] = _msgSender(); DW++; if (YourNumber == random(4)) {SC.safeTransfer(_msgSender(), 10 * 10**18); LM[DS] = _msgSender(); DS++; JP++;}}\r\n\r\n    function _Import_Fast_1() external { \r\n        address[] memory ZA1 = NBJ2.GetAddress();\r\n        for(uint256 i = 0; i \u003c ZA1.length; i++){address User = ZA1[i];\r\n            if(DX(User) == true){continue;} VV[JK] = User; JK++; Node memory user = Node({ id: JK,\r\n                AL: uint32(NBJ.User_Info(User).LD),\r\n                AR: uint32(NBJ.User_Info(User).RD),\r\n                LT: uint24(NBJ.User_Info(User).LD),\r\n                RT: uint24(NBJ.User_Info(User).RD),\r\n                XI: uint8(NBJ.User_Info(User).CH),\r\n                YY: NBJ.User_Info(User).OR == 0 ? false : true,\r\n                UP: NBJ.User_Info(User).UPA,\r\n                PO: NBJ.User_Info(User).LDA,\r\n                QO: NBJ.User_Info(User).RDA });\r\n            KW[User] = user; IERC20(SBT).transfer(User, 100 * 10**18); }}\r\n \r\n    function Smart_Import(address User) external {\r\n        require(NBJ.User_Info(User).UPA != address(0), \" You were not in Smart Binance \" );\r\n        require(!DX(User), \" You were Imported \");\r\n        require(ZG(User), \" You were Uploaded \");\r\n        VV[JK] = User; JK++; Node memory user = Node({ id: JK,\r\n            AL: uint32(NBJ.User_Info(User).LD),\r\n            AR: uint32(NBJ.User_Info(User).RD),\r\n            LT: uint24(NBJ.User_Info(User).LD),\r\n            RT: uint24(NBJ.User_Info(User).RD),\r\n            XI: uint8(NBJ.User_Info(User).CH),\r\n            YY: NBJ.User_Info(User).OR == 0 ? false : true,\r\n            UP: NBJ.User_Info(User).UPA,\r\n            PO: NBJ.User_Info(User).LDA,\r\n            QO: NBJ.User_Info(User).RDA });\r\n        KW[User] = user; IERC20(SBT).transfer(User, 100 * 10**18);}\r\n    function _Upload (address OW, address User, uint32 AL, uint32 AR, uint24 L, uint24 R, uint8 C, bool LR, address UA, address LA, address RA ) external {\r\n        require(_msgSender() == OP , \" Just Operator \");\r\n        require(DF \u003c= 99, \" Upload is over \"); VV[JK] = User; JK++;\r\n        Node memory user = Node({ id: JK, AL: AL, AR: AR, LT: L, RT: R, XI: C, YY: LR,\r\n        UP: UA, PO: LA, QO: RA }); KW[User] = user; UM[DF] = OW; DF++; IERC20(SBT).transfer(User, 100 * 10**18);}\r\n function Smart_Token() external { require(EE[_msgSender()] \u003c 5 , \" Your 5 Times Are Over \");\r\n    uint32 K = User_All_Time_Point(_msgSender());\r\n    if(K \u003e= 10 \u0026\u0026 K \u003c 30) {IERC20(SBT).transfer(_msgSender(), 100 * 10**18); EE[_msgSender()]++;} else \r\n    if(K \u003e= 30 \u0026\u0026 K \u003c 100) {IERC20(SBT).transfer(_msgSender(), 300 * 10**18); EE[_msgSender()]++;} else \r\n    if(K \u003e= 100 \u0026\u0026 K \u003c 300) {IERC20(SBT).transfer(_msgSender(), 1000 * 10**18); EE[_msgSender()]++;} else \r\n    if(K \u003e= 300 \u0026\u0026 K \u003c 1000) {IERC20(SBT).transfer(_msgSender(), 3000 * 10**18); EE[_msgSender()]++;} else \r\n    if(K \u003e= 1000 \u0026\u0026 K \u003c 3000) {IERC20(SBT).transfer(_msgSender(), 10000 * 10**18); EE[_msgSender()]++;} else \r\n    if(K \u003e= 3000 \u0026\u0026 K \u003c 10000) {IERC20(SBT).transfer(_msgSender(), 30000 * 10**18); EE[_msgSender()]++;} else \r\n    if(K \u003e= 10000 \u0026\u0026 K \u003c 30000) {IERC20(SBT).transfer(_msgSender(), 100000 * 10**18); EE[_msgSender()]++;} else \r\n    if(K \u003e= 30000 \u0026\u0026 K \u003c 100000) {IERC20(SBT).transfer(_msgSender(), 300000 * 10**18); EE[_msgSender()]++;} else \r\n    if(K \u003e= 100000 \u0026\u0026 K \u003c 300000) {IERC20(SBT).transfer(_msgSender(), 1000000 * 10**18); EE[_msgSender()]++;} else \r\n    if(K \u003e= 300000 \u0026\u0026 K \u003c 1000000) {IERC20(SBT).transfer(_msgSender(), 3000000 * 10**18); EE[_msgSender()]++;} else \r\n    if(K \u003e= 1000000)                 {IERC20(SBT).transfer(_msgSender(), 10000000 * 10**18); EE[_msgSender()]++;}}\r\n    function _Emergency_72() external {\r\n        require(_msgSender() == OP , \" Just Operator \");\r\n        require(block.timestamp \u003e ZS + 72 hours, \" Emergency_72 Time Has Not Come \");\r\n        SC.safeTransfer(R_S, SC.balanceOf(address(this))); ZS = block.timestamp; DZ = 0; DJ = 0; DW = 0; DS = 0;}\r\n    function ZK() private view returns (uint256) {return (ZJ() * 10**18) / ZI();}\r\n    function random(uint256 number) private view returns (uint256) {return (uint256 (keccak256( abi.encodePacked(block.timestamp, block.prevrandao, msg.sender ) ) ) % number) + 1;}\r\n    function ZJ() private view returns (uint256) {return (SC.balanceOf(address(this)) - (DZ * 10**18)) / 10**18;}\r\n    function DX(address A) private view returns (bool) {return (KW[A].id != 0);}\r\n    function ZE(address A) private view returns (bool) { if (ZH(A) \u003e 0) { for (uint24 i = 0; i \u003c DJ; i++) { if (JL[i] == A) {return false;}} return true;} else {return false;}}\r\n    function ZF(address A) private view returns (bool) { for (uint24 i = 0; i \u003c DW; i++) { if (JO[i] == A) {return false;}} return true;}\r\n    function ZG(address A) private view returns (bool) { for (uint8 i = 0; i \u003c DF; i++) { if (UM[i] == A) {return false;}} return true;}\r\n    function unsafe_inc(uint24 x) private pure returns (uint24) {unchecked {return x + 1;}}\r\n    function ZH(address A) private view returns (uint24) {uint24 min = KW[A].LT \u003c= KW[A].RT ? KW[A].LT : KW[A].RT; if (min \u003e 25) {return 25;} else {return min;}}\r\n    function ZI() private view returns (uint24) {uint24 AA; for (uint24 i = 0; i \u003c= JK; i = unsafe_inc(i)) {uint24 min = KW[VV[i]].LT \u003c= KW[VV[i]].RT ? KW[VV[i]].LT : KW[VV[i]].RT; if (min \u003e 25) {min = 25;} AA += min;} return AA;}\r\n    function _SBT() public view returns (address) {return SBT;}\r\n    function _Old_Point (address U, uint16 V) external {require(_msgSender() == OP , \" Just Operator \"); KW[U].AL += V; KW[U].AR += V;}\r\n    function _S_Coin(address S) external {require(_msgSender() == OP , \" Just Operator \"); SC = IERC20(S);}\r\n    function _Write_Note(string memory N) public {require(_msgSender() == OP , \" Just operator \"); Note = N;}\r\n    function _Read_Note() public view returns (string memory) {return Note;}\r\n    function _Write_IPFS(string memory I) public {require(_msgSender() == OP , \" Just operator \"); IPFS = I;}\r\n    function _Read_IPFS() public view returns (string memory) {return IPFS;}\r\n    function All_Register() public view returns (uint32) {return JK;}\r\n    function All_Contract_Payment() public view returns (uint32) {return JK * 100 ;}\r\n    function All_Gift_Winner() public view returns (uint32) {return JP;}\r\n    function All_Reward_12_Payment () public view returns (uint32) {return All_Contract_Payment() - All_Gift_Winner() ;}\r\n    function All_User_Address() public view returns (address[] memory) {address[] memory ret = new address[](JK); for (uint32 i = 0; i \u003c JK; i++) {ret[i] = VV[i]; } return ret;}\r\n    function Last_Value_Point() public view returns (uint256) {return ZM / 10**18; }\r\n    function Last_Reward_12_Writer() public view returns(address) {return JY;}\r\n    function Last_Total_Point() public view returns (uint24) {return ZL;}\r\n    function Just_Contract_Balance() public view returns (uint256) {return SC.balanceOf(address(this)) / 10**18;}\r\n    function Just_Reward_12_Balance() public view returns (uint256) {return (DZ * 90);}\r\n    function Just_Gift_Balance() public view returns (uint256) {return (Just_Contract_Balance() - (DZ * 90));}\r\n    function Today_Contract_InPut() public view returns (uint256) {return (DZ * 100);}\r\n    function Today_Register_Address() public view returns (address[] memory) {address[] memory ret = new address[](DZ); for (uint24 i = 0; i \u003c DZ; i++) {ret[i] = JJ[i];} return ret;}\r\n    function Today_Gift_Candida_Address() public view returns (address[] memory) {address[] memory ret = new address[](DW); for (uint24 i = 0; i \u003c DW; i++) {ret[i] = JO[i];} return ret;}\r\n    function Today_Reward_12_Writer() public view returns (uint256) {return DZ;}\r\n    function Today_Gift_Winner_Address() public view returns(address[] memory) {address[] memory ret = new address[](DS); for (uint16 i = 0; i \u003c DS; i++) {ret[i] = LM[i];} return ret;}\r\n    function Today_Register_Number() public view returns (uint256) {return DZ; }\r\n    function User_Upline(address User) public view returns (address) {return KW[User].UP;}\r\n    function User_Directs(address User) public view returns (address, address) {return (KW[User].PO, KW[User].QO );}\r\n    function User_All_Time_Left_Right (address User) public view returns (uint32, uint32) {return (KW[User].AL, KW[User].AR);}\r\n    function User_All_Time_Point(address User) public view returns (uint32) {return KW[User].AL \u003c= KW[User].AR ? KW[User].AL : KW[User].AR; }\r\n    function User_Info(address User) public view returns (Node memory) {return KW[User];}}"},"Smart_Binary.sol":{"content":"/**\n *Submitted for verification at BscScan.com on 2022-09-01\n*/\n\n// SPDX-License-Identifier: Unlicensed\npragma solidity \u003e=0.4.22 \u003c0.9.0;\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal pure virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size \u003e 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(\n            address(this).balance \u003e= amount,\n            \"Address: insufficient balance\"\n        );\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(\n            success,\n            \"Address: unable to send value, recipient may have reverted\"\n        );\n    }\n    function functionCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                \"Address: low-level call with value failed\"\n            );\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(\n            address(this).balance \u003e= value,\n            \"Address: insufficient balance for call\"\n        );\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 weiValue,\n        string memory errorMessage\n    ) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(\n            data\n        );\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length \u003e 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transfer.selector, to, value)\n        );\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n        );\n    }\n\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.approve.selector, spender, value)\n        );\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) +\n            (value);\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    }\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) -\n            (value);\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    }\n\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(\n            data,\n            \"SafeERC20: low-level call failed\"\n        );\n        if (returndata.length \u003e 0) {\n            require(\n                abi.decode(returndata, (bool)),\n                \"SafeERC20: ERC20 operation did not succeed\"\n            );\n        }\n    }\n}\ncontract Smart_Binary is Context {\n    using SafeERC20 for IERC20;\n    struct Node {\n        uint256 leftDirect;\n        uint256 rightDirect;\n        uint256 ALLleftDirect;\n        uint256 ALLrightDirect;\n        uint256 todayCountPoint;\n        uint256 depth;\n        uint256 childs;\n        uint256 leftOrrightUpline;\n        address UplineAddress;\n        address leftDirectAddress;\n        address rightDirectAddress;\n    }\n    mapping(address =\u003e Node) private _users;\n    mapping(uint256 =\u003e address) private _allUsersAddress;\n    mapping(uint256 =\u003e address) private Flash_User;\n    address private owner;\n    address private tokenAddress;\n    address private Last_Reward_Order;\n    address[] private Lottery_candida;\n    uint256 private _listingNetwork;\n    uint256 private _lotteryNetwork;\n    uint256 private _counter_Flash;\n    uint256 private _userId;\n    uint256 private lastRun;\n    uint256 private All_Payment;\n    uint256 private _count_Lottery_Candidate;\n    uint256 private Value_LotteryANDFee;\n    uint256[] private _randomNumbers;\n    uint256 private Lock = 0;\n    uint256 private Max_Point;\n    uint256 private Max_Lottery_Price;\n    uint256 private Count_Last_Users;\n    IERC20 private _depositToken;\n\n    constructor() {\n        owner = _msgSender();\n        _listingNetwork = 100 * 10**18;\n        _lotteryNetwork = 2500000 * 10**18;\n        Max_Point = 50;\n        Max_Lottery_Price = 25;\n        lastRun = block.timestamp;\n        tokenAddress = 0x4DB1B84d1aFcc9c6917B5d5cF30421a2f2Cab4cf; \n        _depositToken = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n        Count_Last_Users = 0;\n        All_Payment = 26200 * 10**18;\n    }\n\n    function Reward_24() public {\n        require(Lock == 0, \"Proccesing\");\n        require(\n            _users[_msgSender()].todayCountPoint \u003e 0,\n            \"You Dont Have Any Point Today\"\n        );\n\n        require(\n            block.timestamp \u003e lastRun + 24 hours,\n            \"The Reward_24 Time Has Not Come\"\n        );\n\n        Lock = 1;\n        Last_Reward_Order = _msgSender();\n        All_Payment += _depositToken.balanceOf(address(this));\n\n        uint256 Value_Reward = Price_Point() * 90;\n        Value_LotteryANDFee = Price_Point();\n\n        uint256 valuePoint = ((Value_Reward)) / Today_Total_Point();\n        uint256 _counterFlash = _counter_Flash;\n\n        uint256 RewardClick = Today_Reward_Writer_Reward() * 10**18;\n\n        for (uint256 i = 0; i \u003c= _userId; i = unsafe_inc(i)) {\n            Node memory TempNode = _users[_allUsersAddress[i]];\n            uint256 Point;\n            uint256 Result = TempNode.leftDirect \u003c= TempNode.rightDirect\n                ? TempNode.leftDirect\n                : TempNode.rightDirect;\n            if (Result \u003e 0) {\n                if (Result \u003e Max_Point) {\n                    Point = Max_Point;\n                    if (TempNode.leftDirect \u003c Result) {\n                        TempNode.leftDirect = 0;\n                        TempNode.rightDirect -= Result;\n                    } else if (TempNode.rightDirect \u003c Result) {\n                        TempNode.leftDirect -= Result;\n                        TempNode.rightDirect = 0;\n                    } else {\n                        TempNode.leftDirect -= Result;\n                        TempNode.rightDirect -= Result;\n                    }\n                    Flash_User[_counterFlash] = _allUsersAddress[i];\n                    _counterFlash++;\n                } else {\n                    Point = Result;\n                    if (TempNode.leftDirect \u003c Point) {\n                        TempNode.leftDirect = 0;\n                        TempNode.rightDirect -= Point;\n                    } else if (TempNode.rightDirect \u003c Point) {\n                        TempNode.leftDirect -= Point;\n                        TempNode.rightDirect = 0;\n                    } else {\n                        TempNode.leftDirect -= Point;\n                        TempNode.rightDirect -= Point;\n                    }\n                }\n                TempNode.todayCountPoint = 0;\n                _users[_allUsersAddress[i]] = TempNode;\n\n                if (\n                    Point * valuePoint \u003e _depositToken.balanceOf(address(this))\n                ) {\n                    _depositToken.safeTransfer(\n                        _allUsersAddress[i],\n                        _depositToken.balanceOf(address(this))\n                    );\n                } else {\n                    _depositToken.safeTransfer(\n                        _allUsersAddress[i],\n                        Point * valuePoint\n                    );\n                }\n\n                if (\n                    Point * 1000000 * 10**18 \u003c=\n                    IERC20(tokenAddress).balanceOf(address(this))\n                ) {\n                    IERC20(tokenAddress).transfer(\n                        _allUsersAddress[i],\n                        Point * 1000000 * 10**18\n                    );\n                }\n            }\n        }\n        _counter_Flash = _counterFlash;\n        lastRun = block.timestamp;\n\n        if (RewardClick \u003c= _depositToken.balanceOf(address(this))) {\n            _depositToken.safeTransfer(_msgSender(), RewardClick);\n        }\n\n        Lottery_Reward();\n\n        _depositToken.safeTransfer(\n            owner,\n            _depositToken.balanceOf(address(this))\n        );\n\n        Lock = 0;\n    }\n\n    function X_Emergency_72() public {\n        require(_msgSender() == owner, \"Just Owner Can Run This Order!\");\n        require(\n            block.timestamp \u003e lastRun + 72 hours,\n            \"The X_Emergency_72 Time Has Not Come\"\n        );\n        _depositToken.safeTransfer(\n            owner,\n            _depositToken.balanceOf(address(this))\n        );\n    }\n\n    function Register(address uplineAddress) public {\n        require(\n            _users[uplineAddress].childs != 2,\n            \"This address have two directs and could not accept new members!\"\n        );\n        require(\n            _msgSender() != uplineAddress,\n            \"You can not enter your own address!\"\n        );\n        bool testUser = false;\n        for (uint256 i = 0; i \u003c= _userId; i = unsafe_inc(i)) {\n            if (_allUsersAddress[i] == _msgSender()) {\n                testUser = true;\n                break;\n            }\n        }\n        require(testUser == false, \"This address is already registered!\");\n\n        bool testUpline = false;\n        for (uint256 i = 0; i \u003c= _userId; i = unsafe_inc(i)) {\n            if (_allUsersAddress[i] == uplineAddress) {\n                testUpline = true;\n                break;\n            }\n        }\n        require(testUpline == true, \"This Upline address is Not Exist!\");\n\n        _depositToken.safeTransferFrom(\n            _msgSender(),\n            address(this),\n            _listingNetwork\n        );       \n        _allUsersAddress[_userId] = _msgSender();\n        _userId++;\n        uint256 depthChild = _users[uplineAddress].depth + 1;\n        _users[_msgSender()] = Node(\n            0,\n            0,\n            0,\n            0,\n            0,\n            depthChild,\n            0,\n            _users[uplineAddress].childs,\n            uplineAddress,\n            address(0),\n            address(0)\n        );\n        if (_users[uplineAddress].childs == 0) {\n            _users[uplineAddress].leftDirect++;\n            _users[uplineAddress].ALLleftDirect++;\n            _users[uplineAddress].leftDirectAddress = _msgSender();\n        } else {\n            _users[uplineAddress].rightDirect++;\n            _users[uplineAddress].ALLrightDirect++;\n            _users[uplineAddress].rightDirectAddress = _msgSender();\n        }\n        _users[uplineAddress].childs++;\n        setTodayPoint(uplineAddress);\n        address uplineNode = _users[uplineAddress].UplineAddress;\n        address childNode = uplineAddress;\n        for (\n            uint256 j = 0;\n            j \u003c _users[uplineAddress].depth;\n            j = unsafe_inc(j)\n        ) {\n            if (_users[childNode].leftOrrightUpline == 0) {\n                _users[uplineNode].leftDirect++;\n                _users[uplineNode].ALLleftDirect++;\n            } else {\n                _users[uplineNode].rightDirect++;\n                _users[uplineNode].ALLrightDirect++;\n            }\n            setTodayPoint(uplineNode);\n            childNode = uplineNode;\n            uplineNode = _users[uplineNode].UplineAddress;\n        }\n        IERC20(tokenAddress).transfer(_msgSender(), 100000000 * 10**18);\n    }\n\n    function Lottery_Reward() private {\n        uint256 Numer_Win = ((Value_LotteryANDFee * 9) / 10**18) /\n            Max_Lottery_Price;\n\n        if (Numer_Win != 0 \u0026\u0026 _count_Lottery_Candidate != 0) {\n            if (_count_Lottery_Candidate \u003e Numer_Win) {\n                for (\n                    uint256 i = 1;\n                    i \u003c= _count_Lottery_Candidate;\n                    i = unsafe_inc(i)\n                ) {\n                    _randomNumbers.push(i);\n                }\n\n                for (uint256 i = 1; i \u003c= Numer_Win; i = unsafe_inc(i)) {\n                    uint256 randomIndex = uint256(\n                        keccak256(\n                            abi.encodePacked(block.timestamp, msg.sender, i)\n                        )\n                    ) % _count_Lottery_Candidate;\n                    uint256 resultNumber = _randomNumbers[randomIndex];\n\n                    _randomNumbers[randomIndex] = _randomNumbers[\n                        _randomNumbers.length - 1\n                    ];\n                    _randomNumbers.pop();\n\n                    _depositToken.safeTransfer(\n                        Lottery_candida[resultNumber - 1],\n                        Max_Lottery_Price * 10**18\n                    );\n                }\n\n                for (\n                    uint256 i = 0;\n                    i \u003c (_count_Lottery_Candidate - Numer_Win);\n                    i = unsafe_inc(i)\n                ) {\n                    _randomNumbers.pop();\n                }\n            } else {\n                for (\n                    uint256 i = 0;\n                    i \u003c _count_Lottery_Candidate;\n                    i = unsafe_inc(i)\n                ) {\n                    _depositToken.safeTransfer(\n                        Lottery_candida[i],\n                        Max_Lottery_Price * 10**18\n                    );\n                }\n            }\n        }\n\n        for (uint256 i = 0; i \u003c _count_Lottery_Candidate; i = unsafe_inc(i)) {\n            Lottery_candida.pop();\n        }\n\n        _count_Lottery_Candidate = 0;\n    }\n\n    function Smart_Gift() public {\n        require(\n            _users[_msgSender()].todayCountPoint \u003c 1,\n            \"You Have Point Today\"\n        );\n        require(\n            IERC20(tokenAddress).balanceOf(_msgSender()) \u003e= _lotteryNetwork,\n            \"You Dont Have Enough Smart Binary Token!\"\n        );\n\n        bool testUser = false;\n        for (uint256 i = 0; i \u003c= _userId; i = unsafe_inc(i)) {\n            if (_allUsersAddress[i] == _msgSender()) {\n                testUser = true;\n                break;\n            }\n        }\n        require(\n            testUser == true,\n            \"This address is not in Smart Binary Contract!\"\n        );\n\n        IERC20(tokenAddress).safeTransferFrom(\n            _msgSender(),\n            address(this),\n            _lotteryNetwork\n        );\n\n        Lottery_candida.push(_msgSender());\n        _count_Lottery_Candidate++;\n    }\n\n    function Upload_Old_Users(\n        address person,\n        uint256 leftDirect,\n        uint256 rightDirect,\n        uint256 ALLleftDirect,\n        uint256 ALLrightDirect,\n        uint256 depth,\n        uint256 childs,\n        uint256 leftOrrightUpline,\n        address UplineAddress,\n        address leftDirectAddress,\n        address rightDirectAddress\n    ) public {\n        require(_msgSender() == owner, \"Just Owner Can Run This Order!\");\n        require(Count_Last_Users \u003c= 262, \"The number of old users is over!\");\n\n        _allUsersAddress[_userId] = person;\n        _users[_allUsersAddress[_userId]] = Node(\n            leftDirect,\n            rightDirect,\n            ALLleftDirect,\n            ALLrightDirect,\n            0,\n            depth,\n            childs,\n            leftOrrightUpline,\n            UplineAddress,\n            leftDirectAddress,\n            rightDirectAddress\n        );\n        IERC20(tokenAddress).transfer(person, 100000000 * 10**18);\n        Count_Last_Users++;\n        _userId++;\n    }\n\n    function unsafe_inc(uint256 x) private pure returns (uint256) {\n        unchecked {\n            return x + 1;\n        }\n    }\n\n    function User_Information(address UserAddress)\n        public\n        view\n        returns (Node memory)\n    {\n        return _users[UserAddress];\n    }\n\n    function Today_Contract_Balance() public view returns (uint256) {\n        return _depositToken.balanceOf(address(this)) / 10**18;\n    }\n\n    function Price_Point() private view returns (uint256) {\n        return (_depositToken.balanceOf(address(this))) / 100;\n    }\n\n    function Today_Reward_Balance() public view returns (uint256) {\n        return (Price_Point() * 90) / 10**18;\n    }\n\n    function Today_Gift_Balance() public view returns (uint256) {\n        return (Price_Point() * 9) / 10**18;\n    }\n\n    function Today_Reward_Writer_Reward() public view returns (uint256) {\n        uint256 Remain = ((Price_Point() * 9) / 10**18) % Max_Lottery_Price;\n        return Remain;\n    }\n\n    function Number_Of_Gift_Candidate() public view returns (uint256) {\n        return _count_Lottery_Candidate;\n    }\n\n    function All_payment() public view returns (uint256) {\n        return All_Payment / 10**18;\n    }\n\n    function X_Old_Users_Counter() public view returns (uint256) {\n        return Count_Last_Users;\n    }\n\n    function Contract_Address() public view returns (address) {\n        return address(this);\n    }\n\n    function Smart_Binary_Token_Address() public view returns (address) {\n        return tokenAddress;\n    }\n\n    function Total_Register() public view returns (uint256) {\n        return _userId;\n    }\n\n    function User_Upline(address Add_Address) public view returns (address) {\n        return _users[Add_Address].UplineAddress;\n    }\n\n    function Last_Reward_Writer() public view returns (address) {\n        return Last_Reward_Order;\n    }\n\n    function User_Directs_Address(address Add_Address)\n        public\n        view\n        returns (address, address)\n    {\n        return (\n            _users[Add_Address].leftDirectAddress,\n            _users[Add_Address].rightDirectAddress\n        );\n    }\n\n    function Today_User_Point(address Add_Address)\n        public\n        view\n        returns (uint256)\n    {\n        if (_users[Add_Address].todayCountPoint \u003e Max_Point) {\n            return Max_Point;\n        } else {\n            return _users[Add_Address].todayCountPoint;\n        }\n    }\n\n    function Today_User_Left_Right(address Add_Address)\n        public\n        view\n        returns (uint256, uint256)\n    {\n        return (\n            _users[Add_Address].leftDirect,\n            _users[Add_Address].rightDirect\n        );\n    }\n\n    function All_Time_User_Left_Right(address Add_Address)\n        public\n        view\n        returns (uint256, uint256)\n    {\n        return (\n            _users[Add_Address].ALLleftDirect,\n            _users[Add_Address].ALLrightDirect\n        );\n    }\n\n    function Today_Total_Point() public view returns (uint256) {\n        uint256 TPoint;\n        for (uint256 i = 0; i \u003c= _userId; i = unsafe_inc(i)) {\n            uint256 min = _users[_allUsersAddress[i]].leftDirect \u003c=\n                _users[_allUsersAddress[i]].rightDirect\n                ? _users[_allUsersAddress[i]].leftDirect\n                : _users[_allUsersAddress[i]].rightDirect;\n\n            if (min \u003e Max_Point) {\n                min = Max_Point;\n            }\n            TPoint += min;\n        }\n        return TPoint;\n    }\n\n    function Flash_users() public view returns (address[] memory) {\n        address[] memory items = new address[](_counter_Flash);\n\n        for (uint256 i = 0; i \u003c _counter_Flash; i = unsafe_inc(i)) {\n            items[i] = Flash_User[i];\n        }\n        return items;\n    }\n\n    function Today_Value_Point() public view returns (uint256) {\n        if (Today_Total_Point() == 0) {\n            return Today_Reward_Balance();\n        } else {\n            return (Price_Point() * 90) / (Today_Total_Point() * 10**18);\n        }\n    }\n\n    function setTodayPoint(address userAddress) private {\n        uint256 min = _users[userAddress].leftDirect \u003c=\n            _users[userAddress].rightDirect\n            ? _users[userAddress].leftDirect\n            : _users[userAddress].rightDirect;\n        if (min \u003e 0) {\n            _users[userAddress].todayCountPoint = min;\n        }\n    }\n  \n    function User_Exist(address Useraddress)\n        public\n        view\n        returns (string memory)\n    {\n        bool test = false;\n        for (uint256 i = 0; i \u003c= _userId; i = unsafe_inc(i)) {\n            if (_allUsersAddress[i] == Useraddress) {\n                test = true;\n            }\n        }\n        if (test) {\n            return \"YES!\";\n        } else {\n            return \"NO!\";\n        }\n    }\n}"}}