{"Base.sol":{"content":"pragma solidity ^0.8.0;\r\n// SPDX-License-Identifier: Unlicensed\r\n\r\n    library SafeMath {//konwnsec//IERC20 接口\r\n        function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n            if (a == 0) {\r\n                return 0; \r\n            }\r\n            uint256 c = a * b;\r\n            assert(c / a == b);\r\n            return c; \r\n        }\r\n        function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n// assert(b \u003e 0); // Solidity automatically throws when dividing by 0\r\n            uint256 c = a / b;\r\n// assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\r\n            return c; \r\n        }\r\n        function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n            assert(b \u003c= a);\r\n            return a - b; \r\n        }\r\n\r\n        function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n            uint256 c = a + b;\r\n            assert(c \u003e= a);\r\n            return c; \r\n        }\r\n    }\r\n\r\n    interface Erc20Token {//konwnsec//ERC20 接口\r\n        function totalSupply() external view returns (uint256);\r\n        function balanceOf(address _who) external view returns (uint256);\r\n        function transfer(address _to, uint256 _value) external;\r\n        function allowance(address _owner, address _spender) external view returns (uint256);\r\n        function transferFrom(address _from, address _to, uint256 _value) external;\r\n        function approve(address _spender, uint256 _value) external; \r\n        function burnFrom(address _from, uint256 _value) external; \r\n            function mint(uint256 amount) external  returns (bool);\r\n\r\n        event Transfer(address indexed from, address indexed to, uint256 value);\r\n        event Approval(address indexed owner, address indexed spender, uint256 value);\r\n        \r\n\r\n    }\r\n    \r\n \r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n}\r\n\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n  \r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n}\r\n    \r\n\r\n    contract Base {\r\n        using SafeMath for uint;\r\n\r\n\r\n        Erc20Token constant internal _USDTIns = Erc20Token(0x55d398326f99059fF775485246999027B3197955); \r\n        Erc20Token constant internal _PICCIns = Erc20Token(0x63714C713bF14de1bF1CC9503a8b8Bae8071169A); \r\n        Erc20Token constant internal uniswapV2Pair = Erc20Token(0x45ef0b10E8bCf16d608cb306e00a9E53747d9DED); \r\n\r\n        address  _owner;\r\n        address  _operator;\r\n\r\n        function AMA_Convert(uint256 value) internal pure returns(uint256) {\r\n            return value.mul(1000000000000000000);\r\n        }\r\n        \r\n        modifier onlyOwner() {\r\n            require(msg.sender == _owner, \"Permission denied\"); _;\r\n        }\r\n        modifier isZeroAddr(address addr) {\r\n            require(addr != address(0), \"Cannot be a zero address\"); _; \r\n        }\r\n\r\n\r\n        modifier only_operator() {\r\n            require(msg.sender == _operator, \"Permission denied\"); _;\r\n        }\r\n\r\n        function transferOwnership(address newOwner) public onlyOwner {\r\n            require(newOwner != address(0));\r\n            _owner = newOwner;\r\n        }\r\n\r\n\r\n        function transferOperatorship(address newOperator) public onlyOwner {\r\n            require(newOperator != address(0));\r\n            _operator = newOperator;\r\n        }\r\n\r\n        receive() external payable {}  \r\n}"},"DataPlayer.sol":{"content":"pragma solidity ^0.8.0;\r\n// SPDX-License-Identifier: Unlicensed\r\n\r\nimport \"./Base.sol\";\r\n\r\n    using SafeMath for uint;\r\n\r\ncontract DataPlayer is Base{\r\n        struct InvestInfo {\r\n            uint256 id; \r\n            uint256 amount; \r\n            uint256 settlementTime; \r\n             uint256 endTime;\r\n        }\r\n\r\n        struct Player{\r\n            uint256 id; \r\n            address addr; \r\n            uint256 MiningIncome; \r\n            InvestInfo[] list; \r\n            uint256 AllInvestInfo; \r\n\r\n        }\r\n\r\n\r\n\r\n \r\n\r\n\r\n    mapping(address =\u003e mapping(uint256 =\u003e uint256)) public PlayerPackage; \r\n\r\n\r\n    mapping(uint256 =\u003e uint256)  public PackagePrice;\r\n    mapping(uint256 =\u003e uint256)  public Packageshare;\r\n\r\n\r\n\r\n    mapping(uint256 =\u003e uint256)  public PackagePI_Limit;\r\n\r\n\r\n    mapping(uint256 =\u003e uint256)  public PackageCC_Limit;\r\n\r\n\r\n    uint256 public PICC_Limit; \r\n    uint256 public PI_Limit; \r\n    uint256 public CC_Limit; \r\n\r\n    uint256 public PICCLimitAll; \r\n\r\n\r\n \r\n     mapping(address =\u003e Player) public _player; \r\n\r\n\r\n    address public ProjectPartyWallet = 0x56fb9f39A9bD281CA216105ac40B99D4D7f3FcB8; \r\n\r\n    address public RewardWallet = 0xe12a94aCBbDd51891ED10dd49e2A556B7678429F;\r\n\r\n    address public ProtectiveWallet = 0xfcE22aF32eb862094A17bA5CDe70A34332f4984e; \r\n\r\n     address public USDTRewardWallet = 0xe12a94aCBbDd51891ED10dd49e2A556B7678429F;\r\n\r\n     address public PICCRewardWallet = 0x4fd5820BE76d43BdDEf208f79a56D85BDEaDAa83; \r\n\r\n     address public USDTExchangeWallet = 0xd31AffD6406e1f705E0F8f5F2E365bFe288cA629;\r\n\r\n     address public PICCServiceChargeWallet = 0xA0aBA006c11474b143aaCc5D944FeAE92C9180A3; \r\n \r\n    function setaddress(address addr,uint256 WalletType) public onlyOwner  { \r\n         if(WalletType == 1){\r\n            ProjectPartyWallet = addr;\r\n        }else if(WalletType == 2){\r\n            RewardWallet = addr;\r\n        }\r\n        else if(WalletType == 3){\r\n            ProtectiveWallet = addr;\r\n        }\r\n        else if(WalletType == 4){\r\n            USDTRewardWallet = addr;\r\n        }\r\n        else if(WalletType == 5){\r\n            PICCRewardWallet = addr;\r\n        }\r\n        else if(WalletType == 6){\r\n            USDTExchangeWallet = addr;\r\n        }\r\n         else if(WalletType == 7){\r\n            PICCServiceChargeWallet = addr;\r\n        }\r\n        \r\n\r\n\r\n \r\n\r\n    }\r\n\r\n\r\n    function setPackagelimit( uint256 limit) public only_operator  { \r\n        PICC_Limit = limit;\r\n        PICCLimitAll = limit;\r\n        PI_Limit = limit;\r\n        CC_Limit = limit;\r\n    }\r\n\r\n\r\n       function setAllPackagelimit( uint256 limit) public only_operator  { \r\n           if(PICCLimitAll\u003climit){\r\n             uint256 ls =   limit.sub(PICCLimitAll);\r\n             PICC_Limit = PICC_Limit.add(ls);\r\n            PI_Limit = PI_Limit.add(ls);\r\n            CC_Limit = CC_Limit.add(ls);\r\n\r\n           }else{\r\n                uint256 ls =   PICCLimitAll.sub(limit);\r\n                if(PICC_Limit \u003e ls){\r\n                    PICC_Limit = PICC_Limit.sub(ls);\r\n                }else{\r\n                    PICC_Limit = 0;\r\n \r\n                }\r\n\r\n                 if(PI_Limit \u003e ls){\r\n                    PI_Limit = PI_Limit.sub(ls);\r\n                }else{\r\n                    PI_Limit = 0;\r\n \r\n                }\r\n\r\n                 if(CC_Limit \u003e ls){\r\n                    CC_Limit = CC_Limit.sub(ls);\r\n                }else{\r\n                    CC_Limit = 0;\r\n \r\n                }\r\n           }\r\n\r\n\r\n       \r\n    }\r\n\r\n    function setPackagePrice(uint256 PackageType,uint256 Price,uint256 share) public only_operator  { \r\n        PackagePrice[PackageType] = Price;\r\n        Packageshare[PackageType] = share;\r\n\r\n        \r\n    }\r\n\r\n    function setPlayerPackage(address PCplayerAddress,uint256 PackageType,uint256 PackageQuantity) public only_operator  { \r\n        PlayerPackage[PCplayerAddress][PackageType] =  PlayerPackage[PCplayerAddress][PackageType].add(PackageQuantity);\r\n    }\r\n\r\n     function priceAndBlance() public view returns(uint256,uint256,uint256)   {\r\n       \r\n\r\n        uint256 PICCBalance = _PICCIns.balanceOf(address(uniswapV2Pair));\r\n        uint256 USDTBalance = _USDTIns.balanceOf(address(uniswapV2Pair));\r\n        uint256 hBalance = _PICCIns.balanceOf(address(1));\r\n        if(USDTBalance == 0){\r\n            return  (0,0,hBalance);\r\n        }else{\r\n            \r\n            return  (PICCBalance.mul(10000000).div(USDTBalance),PICCBalance,hBalance);\r\n        }\r\n    }\r\n \r\n\r\n \r\n}"},"pledge.sol":{"content":"pragma solidity ^0.8.0;\r\n// SPDX-License-Identifier: Unlicensed\r\n\r\nimport \"./DataPlayer.sol\";\r\n \r\ncontract PICCPackage is DataPlayer {\r\n    using SafeMath for uint;\r\n   IUniswapV2Router02 public immutable uniswapV2Router;\r\n    constructor()\r\n     {\r\n        _owner = msg.sender; \r\n        _operator = msg.sender; \r\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n        uniswapV2Router = _uniswapV2Router;\r\n        _USDTIns.approve(address(0x10ED43C718714eb63d5aA57B78B54704E256024E), 10000000000000000000000000000000000000000000000000000);\r\n        setPackagelimit( 1000000000);\r\n    }\r\n\r\n\r\n \r\n// 购买套餐\r\n    function BUYPackage(uint256 PackageType,uint256 PackagePartition ) public{\r\n \r\n        require(PICC_Limit \u003e 0, \"Package sell out\");  \r\n        require(PackageType \u003e 0, \"Package sell out\");  \r\n        require( PackagePrice[PackageType] \u003e 0, \"Package sell out\");  \r\n        uint256 share =  Packageshare[PackageType];\r\n        require( share \u003c PICC_Limit, \"Package sell out\");  \r\n\r\n  \r\n\r\n        uint256 USDTBalance = 0;\r\n \r\n        if(PackagePartition == 0){\r\n            uint256   Price =  PackagePrice[PackageType].mul(2).div(10);\r\n            USDTBalance =   Price;\r\n            _USDTIns.transferFrom(msg.sender, address(this),USDTBalance);\r\n            require( share \u003c= PI_Limit, \"Package sell out\");  \r\n            PI_Limit = PI_Limit.sub(share);\r\n            if(PackageCC_Limit[PackageType]\u003e= share){\r\n                PICC_Limit = PICC_Limit.sub(share);\r\n                PackageCC_Limit[PackageType] = PackageCC_Limit[PackageType].sub(share);\r\n            }else{\r\n                PackagePI_Limit[PackageType] = PackagePI_Limit[PackageType].add(share);\r\n            }\r\n\r\n\r\n \r\n\r\n\r\n \r\n        }else if(PackagePartition == 1)\r\n        {\r\n            uint256   Price =  PackagePrice[PackageType].mul(8).div(10);\r\n             USDTBalance = PackagePrice[PackageType];\r\n            _USDTIns.transferFrom(msg.sender, address(this),Price);\r\n            require( share \u003c= CC_Limit, \"Package sell out\");  \r\n\r\n       \r\n\r\n\r\n \r\n  \r\n            CC_Limit = CC_Limit.sub(share);\r\n \r\n\r\n            if(PackagePI_Limit[PackageType]\u003e= share){\r\n                PICC_Limit = PICC_Limit.sub(share);\r\n                PackagePI_Limit[PackageType] = PackagePI_Limit[PackageType].sub(share);\r\n\r\n            }else{\r\n                PackageCC_Limit[PackageType] = PackageCC_Limit[PackageType].add(share);\r\n            }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        }else  \r\n        {\r\n            uint256   Price =  PackagePrice[PackageType];\r\n             USDTBalance =   Price;\r\n\r\n            _USDTIns.transferFrom(msg.sender, address(this),USDTBalance);\r\n            _USDTIns.transfer(ProjectPartyWallet, USDTBalance.mul(2).div(10));\r\n\r\n            PICC_Limit = PICC_Limit.sub(share);\r\n            CC_Limit = CC_Limit.sub(share);\r\n            PI_Limit = PI_Limit.sub(share);\r\n        }\r\n\r\n        if(PackagePartition \u003e 0){\r\n\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(_USDTIns);\r\n        path[1] = address(_PICCIns);\r\n        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            USDTBalance.mul(6).div(10),\r\n            0,  \r\n            path,\r\n            address(1),\r\n            block.timestamp\r\n        );\r\n\r\n            _USDTIns.transfer(RewardWallet, USDTBalance.mul(15).div(100));\r\n            _USDTIns.transfer(ProtectiveWallet, USDTBalance.mul(5).div(100));\r\n        }else {\r\n            _USDTIns.transfer(ProjectPartyWallet, USDTBalance );\r\n\r\n        }\r\n    }\r\n\r\n   function activation(uint256 PackageType ,uint256 ID  ) public payable   {\r\n \r\n        require(PICC_Limit \u003e 0, \"Package sell out\");  \r\n        require(PackageType \u003e 0, \"Package sell out\");  \r\n \r\n        uint256 USDTBalance = 0;\r\n        uint256  allowance  = PlayerPackage[msg.sender][PackageType];\r\n        require(allowance \u003e 0, \"allowance is 0\");  \r\n  \r\n        USDTBalance =  PackagePrice[PackageType] ;\r\n\r\n        uint256   share =  Packageshare[PackageType];\r\n\r\n \r\n        PICC_Limit = PICC_Limit.sub(share);\r\n        CC_Limit = CC_Limit.sub(share);\r\n        PI_Limit = PI_Limit.sub(share);\r\n\r\n        _USDTIns.transferFrom(USDTExchangeWallet, address(this),USDTBalance);\r\n\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(_USDTIns);\r\n        path[1] = address(_PICCIns);\r\n        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            USDTBalance.mul(6).div(10),\r\n            0,  \r\n            path,\r\n            address(1),\r\n            block.timestamp\r\n        );\r\n\r\n        _USDTIns.transfer(ProjectPartyWallet, USDTBalance.mul(2).div(10));\r\n        _USDTIns.transfer(RewardWallet, USDTBalance.mul(15).div(100));\r\n        _USDTIns.transfer(ProtectiveWallet, USDTBalance.mul(5).div(100));\r\n        PlayerPackage[msg.sender][PackageType] = PlayerPackage[msg.sender][PackageType].sub(1);\r\n\r\n    }   \r\n \r\n\r\n\r\n  \r\n\r\n  \r\n// PICC合成\r\n    function PICCsynthesis(uint256 ID,uint256 ID1 )  public{   \r\n    }\r\n\r\n// PI，CC卡转让\r\n    function PICCturn(uint256 ID,uint256 Packagetype,address playAddress)  public{  \r\n    }\r\n\r\n// PICC激活 \r\n    function PICCactivation(uint256 ID)  public{       \r\n    }\r\n\r\n    // PICC提现\r\n    function Withdrawal(uint256  Balance)  public{       \r\n    }\r\n\r\n    // PC兑换\r\n    function PCexchange(uint256  ID)  public{       \r\n    }\r\n\r\n// USDT奖励\r\n    function USDTReward (uint256 USDTBalance,address playAddress)  public only_operator{\r\n        _USDTIns.transferFrom(USDTRewardWallet, address(playAddress),USDTBalance);     \r\n    }\r\n\r\n// PICC奖励\r\n    function PICCReward (uint256 PICCBalance,address playAddress)  public only_operator{\r\n         _PICCIns.transferFrom(PICCRewardWallet, address(playAddress),PICCBalance.mul(95).div(100));\r\n         _PICCIns.transferFrom(PICCRewardWallet, address(PICCServiceChargeWallet),PICCBalance.div(20));\r\n    }\r\n  \r\n}"}}