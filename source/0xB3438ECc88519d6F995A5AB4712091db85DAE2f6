// SPDX-License-Identifier: Unlicensed

pragma solidity ^0.6.12;
interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}
interface IDividendTracker{
    function dividendOf(address _owner) external view returns (uint256);
    function withdrawDividend() external;
    event DividendsDistributed(address indexed from, uint256 weiAmount);
    event DividendWithdrawn(address indexed to, uint256 weiAmount);
    function withdrawableDividendOf(address _owner) external view returns (uint256);
    function withdrawnDividendOf(address _owner) external view returns (uint256);
    function accumulativeDividendOf(address _owner) external view returns (uint256);
    function setBalance(address payable account, uint256 newBalance) external;
    function updateMinimumTokenBalanceForDividends(uint256 amount) external;
    function excludeFromDividends(address account) external;
    function initialize( address rewardToken_,address tokenB_,address pair_,uint256 minimumTokenBalanceForDividends_) external;
    function distributeDividends(uint256 amount) external;
    function getLastProcessedIndex() external view returns (uint256);
   
    function process(uint256 gas) external returns (uint256, uint256, uint256 );
    function updateClaimWait(uint256 newClaimWait) external;
}
abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return payable(msg.sender);
    }
    function _msgData() internal view virtual returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}
 contract Ownable is Context {
    address  private  _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor () internal {
        address  msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(_owner == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }
}

library SafeMath {
    
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

   
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
      
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}




/**
 * @dev Collection of functions related to the address type
 */
library Address {
  
    function isContract(address account) internal view returns (bool) {
      
        bytes32 codehash;
        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        // solhint-disable-next-line no-inline-assembly
        assembly { codehash := extcodehash(account) }
        return (codehash != accountHash && codehash != 0x0);
    }

 
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value
        (bool success, ) = recipient.call{ value: amount }("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
      return functionCall(target, data, "Address: low-level call failed");
    }

    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        return _functionCallWithValue(target, data, 0, errorMessage);
    }

    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        return _functionCallWithValue(target, data, value, errorMessage);
    }

    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {
        require(isContract(target), "Address: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length > 0) {
                // The easiest way to bubble the revert reason is using memory via assembly

                // solhint-disable-next-line no-inline-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    
    }
}



// pragma solidity >=0.5.0;

interface IUniswapV2Factory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);

    function feeTo() external view returns (address);
    function feeToSetter() external view returns (address);

    function getPair(address tokenA, address tokenB) external view returns (address pair);
    function allPairs(uint) external view returns (address pair);
    function allPairsLength() external view returns (uint);

    function createPair(address tokenA, address tokenB) external returns (address pair);

    function setFeeTo(address) external;
    function setFeeToSetter(address) external;
}


// pragma solidity >=0.5.0;

interface IUniswapV2Pair {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);

    function name() external pure returns (string memory);
    function symbol() external pure returns (string memory);
    function decimals() external pure returns (uint8);
    function totalSupply() external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);

    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);

    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function PERMIT_TYPEHASH() external pure returns (bytes32);
    function nonces(address owner) external view returns (uint);

    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;

    event Mint(address indexed sender, uint amount0, uint amount1);
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);

    function MINIMUM_LIQUIDITY() external pure returns (uint);
    function factory() external view returns (address);
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function price0CumulativeLast() external view returns (uint);
    function price1CumulativeLast() external view returns (uint);
    function kLast() external view returns (uint);

    function mint(address to) external returns (uint liquidity);
    function burn(address to) external returns (uint amount0, uint amount1);
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
    function skim(address to) external;
    function sync() external;

    function initialize(address, address) external;
}

// pragma solidity >=0.6.2;

interface IUniswapV2Router01 {
    function factory() external pure returns (address);
    function WETH() external pure returns (address);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETH(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountToken, uint amountETH);
    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETHWithPermit(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountToken, uint amountETH);
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);
    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);

    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);
    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
}



// pragma solidity >=0.6.2;

interface IUniswapV2Router02 is IUniswapV2Router01 {
    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountETH);
    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountETH);

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable;
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
}


contract LOH is Context, IERC20, Ownable {
    using SafeMath for uint256;
    using Address for address;

    mapping (address => uint256) private _rOwned;
    mapping (address => uint256) private _tOwned;
    mapping (address => mapping (address => uint256)) private _allowances;

    mapping (address => bool) private _isExcludedFromFee;

    mapping (address => bool) private _isExcluded;
    address[] private _excluded;
   
    uint256 private constant MAX = ~uint256(0);

    uint256 private _tTotal = 10000000  * 10**9;
    uint256 private _rTotal = (MAX - (MAX % _tTotal));
    uint256 private _tFeeTotal;
    uint256 private swapTokensAtAmount = 5000  * 10**9;
    uint256 public _maxTxAmount = 200000  * 10**9;
    uint256 public _validTradeNum =  190 *  10**18;
    uint256 public _validliquidityNum = 190 * 10**18;
    uint256 public gasForProcessing =  300000;

    
    address private _burnAddress = 0x000000000000000000000000000000000000dEaD;
    address private _holderAddress;
    string private _name = "League of Heroes";
    string private _symbol = "LOH";
    uint8 private _decimals = 9;

    uint256 public _taxFee = 10;
    uint256 public _liquidityFee = 10;
    uint256 public _dividendFee = 40;
    uint256 public _burnFee = 10;
    

    uint256[] public _sharePercentMapping=[30];
    

   mapping (address => address) private _shareMapping;
   mapping (address => uint256) private _tierMapping;


   mapping (address => uint256) private _tradeTokenNum;

    IUniswapV2Router02 public   uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);
    
   address public  uniswapV2Pair;
    IDividendTracker public  dividendTracker;
   address public  _tokenAddress = 0x55d398326f99059fF775485246999027B3197955;
  
 
    struct AccountValue {
       uint256 rAmount;
       uint256 rTransferAmount;
       uint256 rFee;
       uint256 tTransferAmount;
       uint256 tFee;
       uint256 tLiquidity;
       uint256 rLiquidity;
       uint256 tDividendFee;
       uint256 rDividendFee;
       uint256 tShareFee;
       uint256 tBurnFee;
       uint256 rShareFee;
       uint256 rBurnFee;
       address[]  fathers;
       uint256 currentRate;
    }


    bool swapping;
    bool public swapAndLiquifyEnabled = true;
    bool public enabledTrade = true;
    bool public enabledDividend = true;
    bool public enabledReward = true;
    uint256 public swap_starttime;

    

   
    event MinTokensBeforeSwapUpdated(uint256 minTokensBeforeSwap);
    event SwapAndLiquifyEnabledUpdated(bool enabled);
    event SwapAndLiquify( uint256 tokensSwapped, uint256 usdtReceived,uint256 tokensIntoLiqudity);
    event UpdateDividendTracker( address indexed newAddress, address indexed oldAddress);
    event UpdateUniswapV2Router( address indexed newAddress, address indexed oldAddress);
    event GasForProcessingUpdated( uint256 indexed newValue, uint256 indexed oldValue);
    event ProcessedDividendTracker(uint256 iterations,uint256 claims, uint256 lastProcessedIndex,bool indexed automatic, uint256 gas, address indexed processor);
    event SendDividends(uint256 tokenAmount);
 
    
      constructor () public  {
         address holdAddress = _msgSender();
        _rOwned[holdAddress] = _rTotal;
        uniswapV2Pair =  IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this),_tokenAddress);
        _isExcludedFromFee[address(this)] = true;
        _isExcludedFromFee[address(uniswapV2Router)] = true;
        _isExcludedFromFee[address(_burnAddress)] = true;
        _isExcludedFromFee[holdAddress] = true;
        _holderAddress =  holdAddress;
        _shareMapping[address(this)] = address(_burnAddress);
        _tierMapping[address(this)] = 1;
        _shareMapping[holdAddress] = address(this);
        _tierMapping[holdAddress] = 2;

 
        emit Transfer(address(0), holdAddress, _tTotal);
       
    } 
    function setDividendTracker(address dividendAddress) public  onlyOwner{
       
        require(dividendAddress!=address(dividendTracker) ,"can not set same dividendAddress");
        dividendTracker = IDividendTracker(dividendAddress);
        dividendTracker.initialize(address(this),_tokenAddress,uniswapV2Pair,10000);
        dividendTracker.excludeFromDividends(address(dividendTracker));
        dividendTracker.excludeFromDividends(address(this));
        dividendTracker.excludeFromDividends(address(0));
        dividendTracker.excludeFromDividends(_holderAddress);
        dividendTracker.excludeFromDividends(address(_burnAddress));
        dividendTracker.excludeFromDividends(address(uniswapV2Router));
        dividendTracker.excludeFromDividends(address(uniswapV2Pair));

        _isExcludedFromFee[address(dividendTracker)] = true;

    }
    function excludeFromDividends(address _address) public{
        dividendTracker.excludeFromDividends(_address);
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function totalSupply() public view override returns (uint256) {
        return _tTotal;
    }

    function balanceOf(address account) public view override returns (uint256) {
        if (_isExcluded[account]) return _tOwned[account];
        return tokenFromReflection(_rOwned[account]);
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    function isExcludedFromReward(address account) public view returns (bool) {
        return _isExcluded[account];
    }

    function totalFees() public view returns (uint256) {
        return _tFeeTotal;
    }

    function deliver(uint256 tAmount) public {
        address sender = _msgSender();
        require(!_isExcluded[sender], "Excluded addresses cannot call this function");
         AccountValue memory params = _getValues(tAmount,false,address(0));
        _rOwned[sender] = _rOwned[sender].sub(params.rAmount);
        _rTotal = _rTotal.sub(params.rAmount);
        _tFeeTotal = _tFeeTotal.add(tAmount);
    }

    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {
        require(tAmount <= _tTotal, "Amount must be less than supply");
        if (!deductTransferFee) {
            AccountValue memory params = _getValues(tAmount,false,address(0));
            return params.rAmount;
        } else {
            AccountValue memory params  = _getValues(tAmount,false,address(0));
            return params.rTransferAmount;
        }
    }

    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {
        require(rAmount <= _rTotal, "Amount must be less than total reflections");
        uint256 currentRate =  _getRate();
        return rAmount.div(currentRate);
    }

    function excludeFromReward(address account) public onlyOwner() {
        // require(account != 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D, 'We can not exclude Uniswap router.');
        require(!_isExcluded[account], "Account is already excluded");
        if(_rOwned[account] > 0) {
            _tOwned[account] = tokenFromReflection(_rOwned[account]);
        }
        _isExcluded[account] = true;
        _excluded.push(account);
    }

    function includeInReward(address account) external onlyOwner() {
        require(_isExcluded[account], "Account is already excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _tOwned[account] = 0;
                _isExcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }
       
    
   function excludeFromFee(address account) public onlyOwner {
       require(!account.isContract(),"The contract address cannot be");
        _isExcludedFromFee[account] = true;
    }
    
    function includeInFee(address account) public onlyOwner {
        require(!account.isContract(),"The contract address cannot be");
        _isExcludedFromFee[account] = false;
    }
    
    function setTaxFeePercent(uint256 taxFee) external onlyOwner() {
        _taxFee = taxFee;
    }
    function setLiquidityFeePercent(uint256 liquidityFee) external onlyOwner() {
        _liquidityFee = liquidityFee;
    }
   
    function setDividendFeePercent(uint256 dividendFee) external onlyOwner() {
        _dividendFee = dividendFee;
    }
    function setValideTradeNum(uint256 tradeNum,uint256 liquidityNum) external onlyOwner(){
        _validTradeNum = tradeNum * 10**18;
        _validliquidityNum =  liquidityNum * 10**18;
    }
    function setMaxTxAmount(uint256 maxTxNum) external onlyOwner() {
        _maxTxAmount = maxTxNum *  10** uint256 (_decimals);
    }
    function setSwapTokensAtAmount(uint256 amount) external onlyOwner {
        swapTokensAtAmount = amount *  10** uint256 (_decimals);
    }
    function setSwapAndLiquifyEnabled(bool _enabled) public onlyOwner {
        swapAndLiquifyEnabled = _enabled;
        emit SwapAndLiquifyEnabledUpdated(_enabled);
    }
    function setEnabledTrade(bool _enabled) public onlyOwner {
        enabledTrade = _enabled;
    }
    function setEnabledDividend(bool _enabled) public onlyOwner {
        enabledDividend = _enabled;
    }
    function setEnabledReward(bool _enabled) public onlyOwner{
        enabledReward = _enabled;
    }
    function setSwapStarttime(uint256 time) public onlyOwner{
        swap_starttime = time;
    }
    function dividendOf(address _owner) external view returns(uint256){
        return dividendTracker.dividendOf(_owner);
    }
    function updateClaimWait(uint256 newClaimWait) public onlyOwner{
         dividendTracker.updateClaimWait(newClaimWait);
    }
    function updategasForProcessing(uint256 gas) public onlyOwner{
        require(gas >= 300000,"gas value is invalid");
        emit GasForProcessingUpdated(gas, gasForProcessing);
        gasForProcessing = gas;
    }
    
    receive() external payable {}
    
    function _reflectFee(uint256 rFee, uint256 tFee) private {
        _rTotal = _rTotal.sub(rFee);
        _tFeeTotal = _tFeeTotal.add(tFee);
        
    }

    function _getValues(uint256 tAmount,bool takeFee,address user) private view returns (AccountValue memory params) {
        params = _getTValues(tAmount, takeFee, user);
        params.currentRate = _getRate();
        params.rAmount = tAmount.mul(params.currentRate);
        params.rFee = params.tFee.mul(params.currentRate);
        params.rLiquidity = params.tLiquidity.mul(params.currentRate);
        params.rDividendFee = params.tDividendFee.mul(params.currentRate);
       
        params.rShareFee = params.tShareFee.mul(params.currentRate);
        params.rBurnFee = params.tBurnFee.mul(params.currentRate);
        
        params.rTransferAmount = params.rAmount.sub(params.rFee).sub(params.rLiquidity).sub(params.rShareFee).sub(params.rBurnFee);
        params.rTransferAmount = params.rTransferAmount.sub(params.rDividendFee);
        return (params);
    }
   
    function _getTValues(uint256 tAmount,bool takeFee,address user) private view returns (AccountValue memory params) {
        if(takeFee){
            params.tFee = calculateTaxFee(tAmount);
            params.tLiquidity = calculateLiquidityFee(tAmount);
            params.tDividendFee = calculateDividendFee(tAmount);
           if(_shareMapping[user] !=address(0)){
           params.fathers = getFathers(user);
          for( uint i = 0; i < params.fathers.length; i++ ){
              if(params.fathers[i] !=address(0)){
                 params.tShareFee =  params.tShareFee.add(calculateShareFee(tAmount,_sharePercentMapping[i]));
              }
          }
           }
            params.tBurnFee = calculateBurnFee(tAmount);
            params.tTransferAmount = tAmount.sub(params.tFee).sub(params.tLiquidity).sub(params.tShareFee).sub(params.tBurnFee);
            params.tTransferAmount = params.tTransferAmount.sub(params.tDividendFee);
        }else{
            params.tTransferAmount = tAmount; 
        }
        return params;
    }
    function _getRate() private view returns(uint256) {
        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();
        return rSupply.div(tSupply);
    }

    function _getCurrentSupply() private view returns(uint256, uint256) {
        uint256 rSupply = _rTotal;
        uint256 tSupply = _tTotal;      
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);
            rSupply = rSupply.sub(_rOwned[_excluded[i]]);
            tSupply = tSupply.sub(_tOwned[_excluded[i]]);
        }
        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);
        return (rSupply, tSupply);
    }
    function calculateTaxFee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_taxFee).div(1000);
    }
    function calculateLiquidityFee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_liquidityFee).div(1000);
    }
    function calculateDividendFee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_dividendFee).div(1000);
    }
    
    function calculateBurnFee(uint256 _amount) private view returns (uint256) {
      
        return _amount.mul(_burnFee).div(1000);
    }
     function calculateShareFee(uint256 _amount,uint256 fee) private pure returns (uint256) {
        return _amount.mul(fee).div(1000);
    }
 
    function isExcludedFromFee(address account) public view returns(bool) {
        return _isExcludedFromFee[account];
    }

    function _approve(address owner, address spender, uint256 amount) private {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function setSourceFrom(address sourceFrom,address user) internal {
        if(  sourceFrom != user && _shareMapping[user] == address(0) && _shareMapping[sourceFrom] !=address(0)){
                _shareMapping[user] = sourceFrom;
                _tierMapping[user] = _tierMapping[sourceFrom] + 1;
        }       
    }
   
    function _transfer(
        address from,
        address to,
        uint256 amount
    ) private {
        require(from != address(0), "ERC20: transfer from the zero address");
        require(to != address(0), "ERC20: transfer to the zero address");
        require(amount > 0, "Transfer amount must be greater than zero");
        if(from != owner() && to != owner())
            require(amount <= _maxTxAmount, "Transfer amount exceeds the maxTxAmount.");
       if(!to.isContract() && _shareMapping[to] == address(0) ){
           if(!from.isContract()){
               setSourceFrom(from,to);
            }else{
               setSourceFrom(address(this),to);
            }
        }
        if(!enabledTrade|| block.timestamp<swap_starttime){
            if(!_isExcludedFromFee[from] && !_isExcludedFromFee[to]){
                require(from != address(uniswapV2Pair),"swaping is disabled");
                require(to != address(uniswapV2Pair),"swaping is disabled");
            }
        }
        
             syncLiquifyTodividendPool(from ,to);
        
       

        uint256 contractTokenBalance = balanceOf(address(this));
        if(contractTokenBalance >= _maxTxAmount){
            contractTokenBalance = _maxTxAmount;
        }
        bool overMinTokenBalance = contractTokenBalance >= swapTokensAtAmount;
        if (
            enabledTrade && 
            overMinTokenBalance &&
            !swapping &&
            from != uniswapV2Pair &&
            from != address(this) && 
            from != address(dividendTracker) && 
            
            swapAndLiquifyEnabled
        ) {
            swapping = true;
            uint256 _allFee = _liquidityFee.add(_dividendFee);
            uint256 swapTokens = contractTokenBalance.mul(_liquidityFee).div(_allFee);
            swapAndLiquify(swapTokens);
            uint256 sellTokens = balanceOf(address(this));
            if(enabledDividend){
             swapAndSendDividends(sellTokens);
            }
             
             swapping = false;
        }
        bool takeFee = true;
        address user = address(0);

      
        if(_isExcludedFromFee[from] || _isExcludedFromFee[to]|| !enabledReward){
            takeFee = false;
        }
          if(takeFee && from == uniswapV2Pair ){
           user = to;
          }else {
           user = from; 
          }
          
         
          
        _tokenTransfer(from,to,amount,takeFee,user);
        
        
          syncSwapingTokenNum(to,amount);
    
        if (!swapping && from != address(dividendTracker) && enabledDividend) {
        try dividendTracker.process(gasForProcessing) returns (uint256 iterations,uint256 claims, uint256 lastProcessedIndex) {
                emit ProcessedDividendTracker(
                    iterations,
                    claims,
                    lastProcessedIndex,
                    true,
                    gasForProcessing,
                    tx.origin
                );
            } catch {}
            
            
           
            
        }
    }
     address[]  public swapingList;

     function syncSwapingTokenNum(address to,uint256 amount) internal{
          if(!swapping && !to.isContract() && _tradeTokenNum[to]<_validTradeNum){//buy token
                _tradeTokenNum[to] = _tradeTokenNum[to].add(getTokenNum(amount));
             }
     }
     function syncLiquifyTodividendPool(address from,address to) internal{
         if (!swapping && from != address(dividendTracker) && enabledDividend) {
             
        
          uint256 listSize = swapingList.length;
         if(!swapping && listSize>1){
             for(uint256 i=0;i< listSize-1;i++){
                 address lastAddress = swapingList[i];
                try dividendTracker.setBalance(payable(lastAddress),IUniswapV2Pair(uniswapV2Pair).balanceOf(lastAddress)){} catch {}
             }
             swapingList[0] = swapingList[listSize-1];
             for(uint256 i=0;i<listSize-1;i++){
                 swapingList.pop();
             }
         }
         if(from == uniswapV2Pair && !to.isContract()){
            swapingList.push(to);
          }else if(to == uniswapV2Pair && !from.isContract()){
            swapingList.push(from);
          }
          
         }
     }

    function swapAndLiquify(uint256 tokenAmount) internal  {
        uint256 half = tokenAmount.div(2);
        uint256 otherHalf = tokenAmount.sub(half);
        uint256 initialBalance = IERC20(_tokenAddress).balanceOf(address(dividendTracker));
        swapTokensForNewToken(half); 
        uint256 newBalance = IERC20(_tokenAddress).balanceOf(address(dividendTracker)).sub(initialBalance);
        IERC20(_tokenAddress).transferFrom(address(dividendTracker),address(this),newBalance);
        addLiquidity(otherHalf, newBalance);
        emit SwapAndLiquify(half, newBalance, otherHalf);
    }
    function swapAndSendDividends(uint256 tokens) internal {
           _transfer(address(this),address(dividendTracker),tokens );
           dividendTracker.distributeDividends(tokens);
           emit SendDividends(tokens);
    }
    
    function swapTokensForNewToken(uint256 tokenAmount) internal {
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = address(_tokenAddress);
        _approve(address(this), address(uniswapV2Router), tokenAmount);
        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            tokenAmount,
            0,
            path,
            address(dividendTracker),//can not set the current contract address
            block.timestamp
        );
    }
    function addLiquidity(uint256 tokenAmount, uint256 usdtAmount) internal {
         _approve(address(this), address(uniswapV2Router), tokenAmount);
         IERC20(_tokenAddress).approve(address(uniswapV2Router),usdtAmount);
        uniswapV2Router.addLiquidity(
            address(this),
            address(_tokenAddress),
            tokenAmount,
            usdtAmount,
            0, // slippage is unavoidable
            0, // slippage is unavoidable
            address(0),
            block.timestamp
        );
    }

    //this method is responsible for taking all fee, if takeFee is true
    function _tokenTransfer(address sender, address recipient, uint256 amount,bool takeFee,address user) private {
        if (_isExcluded[sender] && !_isExcluded[recipient]) {
            _transferFromExcluded(sender, recipient, amount,takeFee,user);
        } else if (!_isExcluded[sender] && _isExcluded[recipient]) {
            _transferToExcluded(sender, recipient, amount,takeFee,user);
        } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {
            _transferStandard(sender, recipient, amount,takeFee,user);
        } else if (_isExcluded[sender] && _isExcluded[recipient]) {
            _transferBothExcluded(sender, recipient, amount,takeFee,user);
        } else {
            _transferStandard(sender, recipient, amount,takeFee,user);
        }
    }
    
    function _transferStandard(address sender, address recipient, uint256 tAmount,bool takeFee,address user ) private {
        AccountValue memory params = _getValues(tAmount, takeFee, user);
        _rOwned[sender] = _rOwned[sender].sub(params.rAmount);
        _rOwned[recipient] = _rOwned[recipient].add(params.rTransferAmount);
      
        emit Transfer(sender, recipient, params.tTransferAmount);
         _takeAllFees(tAmount,user,params);
    }
    function _transferToExcluded(address sender, address recipient, uint256 tAmount,bool takeFee,address user ) private {
         AccountValue memory params = _getValues(tAmount, takeFee, user);
        _rOwned[sender] = _rOwned[sender].sub(params.rAmount);
        _tOwned[recipient] = _tOwned[recipient].add(params.tTransferAmount);
        _rOwned[recipient] = _rOwned[recipient].add(params.rTransferAmount);           
       
        emit Transfer(sender, recipient, params.tTransferAmount);
         _takeAllFees(tAmount,user,params);
    }

    function _transferFromExcluded(address sender, address recipient, uint256 tAmount,bool takeFee,address user ) private {
         AccountValue memory params = _getValues(tAmount, takeFee, user);
        _tOwned[sender] = _tOwned[sender].sub(tAmount);
        _rOwned[sender] = _rOwned[sender].sub(params.rAmount);
        _rOwned[recipient] = _rOwned[recipient].add(params.rTransferAmount);   
        
        emit Transfer(sender, recipient, params.tTransferAmount);
         _takeAllFees(tAmount,user,params);
    }

     function _transferBothExcluded(address sender, address recipient, uint256 tAmount,bool takeFee,address user ) private {
         AccountValue memory params = _getValues(tAmount, takeFee, user);
        _tOwned[sender] = _tOwned[sender].sub(tAmount);
        _rOwned[sender] = _rOwned[sender].sub(params.rAmount);
        _tOwned[recipient] = _tOwned[recipient].add(params.tTransferAmount);
        _rOwned[recipient] = _rOwned[recipient].add(params.rTransferAmount);        
        
        emit Transfer(sender, recipient, params.tTransferAmount);
        _takeAllFees(tAmount,user,params);
    }
    function _takeAllFees(uint256 tAmount,address user,AccountValue memory params)private{
          if(params.tFee>0){
          _reflectFee(params.rFee, params.tFee);
           emit Transfer(user, address(0), params.tFee);
          }
          _takeLiquidity(user,params.tLiquidity,params.rLiquidity);
          _takeDividend(user,params.tDividendFee,params.rDividendFee);
    
          _takeShare(user,tAmount,params);
          _takeBurn(user,params.tBurnFee,params.rBurnFee);
    }
    function _takeLiquidity(address user,uint256 tLiquidity,uint256 rLiquidity) private {
          if(tLiquidity==0) return ;
        _rOwned[address(this)] = _rOwned[address(this)].add(rLiquidity);
        if(_isExcluded[address(this)])
            _tOwned[address(this)] = _tOwned[address(this)].add(tLiquidity);

        emit Transfer(user, address(this), tLiquidity);
    }
    function _takeDividend(address user,uint256 tDividendFee,uint256 rDividendFee) private{
        if(tDividendFee==0) return ;
        _rOwned[address(this)] = _rOwned[address(this)].add(rDividendFee);
        if(_isExcluded[address(this)])
            _tOwned[address(this)] = _tOwned[address(this)].add(tDividendFee);

        emit Transfer(user, address(this), tDividendFee);
    }
   
    function getFathers(address user) internal view returns(address[] memory fathers){
       uint tier = _tierMapping[user];
       
        if( tier > 1 ){
          uint size = tier - 1;
          size = size > _sharePercentMapping.length ? _sharePercentMapping.length : size;
          fathers = new address[](size);
           address parent  = user;
          for( uint i = 0; i < size; i++){
            parent = _shareMapping[parent];
            if( parent == address(0) ) {
                fathers[i] = address(this);
                continue;
            }
             if(_tradeTokenNum[parent]>=_validTradeNum|| liquidityTokenNum(parent) >= _validliquidityNum  ){
               fathers[i] = parent;
             }else{
               fathers[i] = address(this);
             }
        }
     }
    }
    function getTokenNum(uint256 tokenAmount) public view returns(uint256){
         (uint256 reserveToken,uint256 reserveU ) =  getReserves();
         if(reserveToken==0||reserveU==0){
            return 0;
         }
       return reserveU.mul(tokenAmount).div(reserveToken);
    }
    function getTokenPrice() public view returns(uint256){
       (uint256 reserveToken,uint256 reserveU ) =  getReserves();
        if(reserveToken==0) return 0;
        return reserveU.div(reserveToken);
    }
    function getReserves() public view returns(uint reserveToken, uint reserveU){
         (uint reserve0, uint reserve1,) = IUniswapV2Pair(uniswapV2Pair).getReserves();
        address token0 = IUniswapV2Pair(uniswapV2Pair).token0();
        ( reserveToken,  reserveU) = address(this) == token0 ? (reserve0, reserve1) : (reserve1, reserve0);
        return (reserveToken,reserveU);
    }
    function liquidityTokenNum (address parent) public view returns(uint256){
         uint256 parnet_liquidity =  IUniswapV2Pair(uniswapV2Pair).balanceOf(parent);
         uint256 total_liquidity =  IUniswapV2Pair(uniswapV2Pair).totalSupply();
         if(total_liquidity==0){
             return 0;
         }
         (,uint256 reserveU ) =  getReserves();
         return  reserveU.mul(parnet_liquidity).div(total_liquidity);
    }
    function _takeShare(address user,uint256 tAmount, AccountValue memory params) private {
          if(params.fathers.length ==0) return ;
                for( uint i = 0; i < params.fathers.length; i++ ){
                      address parent = params.fathers[i];
                    if( parent == address(0)) continue;
                    uint256 tv  = calculateShareFee(tAmount,_sharePercentMapping[i]);
                    if(tv==0){
                        continue;
                    }
                    _rOwned[parent] = _rOwned[parent].add(tv.mul(params.currentRate));
                    if(_isExcluded[parent]){
                        _tOwned[parent] = _tOwned[parent].add(tv);
                    }
                   
                       emit Transfer(user, parent, tv);
                    
                }
            
    }
    function _takeBurn(address user,uint256 tBurnFee,uint256 rBurnFee) private {
          if(tBurnFee==0) return ;
        _rOwned[_burnAddress] = _rOwned[_burnAddress].add(rBurnFee);
        if(_isExcluded[_burnAddress])
            _tOwned[_burnAddress] = _tOwned[_burnAddress].add(tBurnFee);
         emit Transfer(user, _burnAddress, tBurnFee);
    }
    
   function burn(uint256 amount) public  returns (bool) {
        _burn(_msgSender(), amount);
        return true;
    }
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: burn from the zero address");
         uint256 rAmount = amount.mul(_getRate());
        _rOwned[account] = _rOwned[account].add(rAmount);
         if(_isExcluded[account]){
           _tOwned[account] = _tOwned[account].sub(amount);
       }
          _rTotal = _rTotal.sub(rAmount);
          _tTotal = _tTotal.sub(amount);
        emit Transfer(account, address(0), amount);
    }
}