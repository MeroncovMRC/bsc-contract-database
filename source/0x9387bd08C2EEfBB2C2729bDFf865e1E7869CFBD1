{"Auth.sol":{"content":"// SPDX-License-Identifier: unlicensed\n\npragma solidity ^0.7.4;\n\nabstract contract Auth {\n    address internal owner;\n    mapping (address =\u003e bool) internal authorizations;\n\n    constructor(address _owner) {\n        owner = _owner;\n        authorizations[_owner] = true;\n    }\n\n    modifier onlyOwner() {\n        require(isOwner(msg.sender), \"!OWNER\"); _;\n    }\n\n    modifier authorized() {\n        require(isAuthorized(msg.sender), \"!AUTHORIZED\"); _;\n    }\n\n    function authorize(address adr) public onlyOwner {\n        authorizations[adr] = true;\n    }\n\n    function unauthorize(address adr) public onlyOwner {\n        authorizations[adr] = false;\n    }\n\n    function isOwner(address account) public view returns (bool) {\n        return account == owner;\n    }\n\n    function isAuthorized(address adr) public view returns (bool) {\n        return authorizations[adr];\n    }\n\n    function transferOwnership(address payable adr) public onlyOwner {\n        owner = adr;\n        authorizations[adr] = true;\n        emit OwnershipTransferred(adr);\n    }\n\n    event OwnershipTransferred(address owner);\n}"},"DividendDistributor.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\"\npragma solidity ^0.7.4;\n\nimport \"./SafeMath.sol\";\nimport \"./IDEXRouter.sol\";\nimport \"./IDividendDistributor.sol\";\nimport \"./IBEP20.sol\";\ncontract DividendDistributor is IDividendDistributor {\n    using SafeMath for uint256;\n\n    address _token;\n\n    struct Share {\n        uint256 amount;\n        uint256 totalExcluded;\n        uint256 totalRealised;\n    }\n\n    IBEP20 RWRD = IBEP20(0x2859e4544C4bB03966803b044A93563Bd2D0DD4D);\n    address WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\n    IDEXRouter router;\n\n    address[] shareholders;\n    mapping (address =\u003e uint256) shareholderIndexes;\n    mapping (address =\u003e uint256) shareholderClaims;\n\n    mapping (address =\u003e Share) public shares;\n\n    uint256 public totalShares;\n    uint256 public totalDividends;\n    uint256 public totalDistributed;\n    uint256 public dividendsPerShare;\n    uint256 public dividendsPerShareAccuracyFactor = 10 ** 36;\n\n    uint256 public minPeriod = 45 * 60;\n    uint256 public minDistribution = 1 * (10 ** 12);\n\n    uint256 currentIndex;\n\n    bool initialized;\n    modifier initialization() {\n        require(!initialized);\n        _;\n        initialized = true;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == _token); _;\n    }\n\n    constructor (address _router) {\n        router = _router != address(0)\n            ? IDEXRouter(_router)\n            : IDEXRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n        _token = msg.sender;\n    }\n\n    function setDistributionCriteria(uint256 _minPeriod, uint256 _minDistribution) external override onlyToken {\n        minPeriod = _minPeriod;\n        minDistribution = _minDistribution;\n    }\n\n    function setShare(address shareholder, uint256 amount) external override onlyToken {\n        if(shares[shareholder].amount \u003e 0){\n            distributeDividend(shareholder);\n        }\n\n        if(amount \u003e 0 \u0026\u0026 shares[shareholder].amount == 0){\n            addShareholder(shareholder);\n        }else if(amount == 0 \u0026\u0026 shares[shareholder].amount \u003e 0){\n            removeShareholder(shareholder);\n        }\n\n        totalShares = totalShares.sub(shares[shareholder].amount).add(amount);\n        shares[shareholder].amount = amount;\n        shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);\n    }\n\n    function deposit() external payable override onlyToken {\n        uint256 balanceBefore = RWRD.balanceOf(address(this));\n\n        address[] memory path = new address[](2);\n        path[0] = WBNB;\n        path[1] = address(RWRD);\n\n        router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: msg.value}(\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n\n        uint256 amount = RWRD.balanceOf(address(this)).sub(balanceBefore);\n\n        totalDividends = totalDividends.add(amount);\n        dividendsPerShare = dividendsPerShare.add(dividendsPerShareAccuracyFactor.mul(amount).div(totalShares));\n    }\n\n    function process(uint256 gas) external override onlyToken {\n        uint256 shareholderCount = shareholders.length;\n\n        if(shareholderCount == 0) { return; }\n\n        uint256 gasUsed = 0;\n        uint256 gasLeft = gasleft();\n\n        uint256 iterations = 0;\n\n        while(gasUsed \u003c gas \u0026\u0026 iterations \u003c shareholderCount) {\n            if(currentIndex \u003e= shareholderCount){\n                currentIndex = 0;\n            }\n\n            if(shouldDistribute(shareholders[currentIndex])){\n                distributeDividend(shareholders[currentIndex]);\n            }\n\n            gasUsed = gasUsed.add(gasLeft.sub(gasleft()));\n            gasLeft = gasleft();\n            currentIndex++;\n            iterations++;\n        }\n    }\n    \n    function shouldDistribute(address shareholder) internal view returns (bool) {\n        return shareholderClaims[shareholder] + minPeriod \u003c block.timestamp\n                \u0026\u0026 getUnpaidEarnings(shareholder) \u003e minDistribution;\n    }\n\n    function distributeDividend(address shareholder) internal {\n        if(shares[shareholder].amount == 0){ return; }\n\n        uint256 amount = getUnpaidEarnings(shareholder);\n        if(amount \u003e 0){\n            totalDistributed = totalDistributed.add(amount);\n            RWRD.transfer(shareholder, amount);\n            shareholderClaims[shareholder] = block.timestamp;\n            shares[shareholder].totalRealised = shares[shareholder].totalRealised.add(amount);\n            shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);\n        }\n    }\n    \n    function claimDividend() external {\n        distributeDividend(msg.sender);\n    }\n\n    function getUnpaidEarnings(address shareholder) public view returns (uint256) {\n        if(shares[shareholder].amount == 0){ return 0; }\n\n        uint256 shareholderTotalDividends = getCumulativeDividends(shares[shareholder].amount);\n        uint256 shareholderTotalExcluded = shares[shareholder].totalExcluded;\n\n        if(shareholderTotalDividends \u003c= shareholderTotalExcluded){ return 0; }\n\n        return shareholderTotalDividends.sub(shareholderTotalExcluded);\n    }\n\n    function getCumulativeDividends(uint256 share) internal view returns (uint256) {\n        return share.mul(dividendsPerShare).div(dividendsPerShareAccuracyFactor);\n    }\n\n    function addShareholder(address shareholder) internal {\n        shareholderIndexes[shareholder] = shareholders.length;\n        shareholders.push(shareholder);\n    }\n\n    function removeShareholder(address shareholder) internal {\n        shareholders[shareholderIndexes[shareholder]] = shareholders[shareholders.length-1];\n        shareholderIndexes[shareholders[shareholders.length-1]] = shareholderIndexes[shareholder];\n        shareholders.pop();\n    }\n}"},"ERC20Detailed.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\"\npragma solidity ^0.7.4;\n\nimport \"./IERC20.sol\";\nabstract contract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    constructor(\n        string memory ERCname,\n        string memory ERCsymbol,\n        uint8 ERCdecimals\n    ) {\n        _name = ERCname;\n        _symbol = ERCsymbol;\n        _decimals = ERCdecimals;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}"},"IBEP20.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\"\npragma solidity ^0.7.4;\n/**\n * BEP20 standard interface.\n */\ninterface IBEP20 {\n    function totalSupply() external view returns (uint256);\n    function decimals() external view returns (uint8);\n    function symbol() external view returns (string memory);\n    function name() external view returns (string memory);\n    function getOwner() external view returns (address);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address _owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"},"IDexFactory.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\"\npragma solidity ^0.7.4;\ninterface IDEXFactory {\n    function createPair(address tokenA, address tokenB)\n        external\n        returns (address pair);\n}"},"IDEXRouter.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\"\npragma solidity ^0.7.4;\ninterface IDEXRouter {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        );\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n}"},"IDividendDistributor.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\"\npragma solidity ^0.7.4;\n\ninterface IDividendDistributor {\n    function setDistributionCriteria(uint256 _minPeriod, uint256 _minDistribution) external;\n    function setShare(address shareholder, uint256 amount) external;\n    function deposit() external payable;\n    function process(uint256 gas) external;\n}"},"IERC20.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\"\npragma solidity ^0.7.4;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}"},"InterfaceLP.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\"\npragma solidity ^0.7.4;\ninterface InterfaceLP {\n    function sync() external;\n}"},"MetaZilla.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\"\n\n/*\n\n\nBuy / Sell: 13% Tax\n+ 4% Shiba Inu\n+ 3% Liquidity\n+ 6% Marketing\n \n\nTelegram: \n*/\n\nimport \"./ERC20Detailed.sol\";\nimport \"./Ownable.sol\";\nimport \"./SafeMath.sol\";\nimport \"./SafeMathInt.sol\";\nimport \"./InterfaceLP.sol\";\nimport \"./IDexFactory.sol\";\nimport \"./IDEXRouter.sol\";\nimport \"./IBEP20.sol\";\nimport \"./Auth.sol\";\nimport \"./DividendDistributor.sol\";\n\npragma solidity ^0.7.4;\n\ncontract MetaZilla is IBEP20, Auth {\n    using SafeMath for uint256;\n    using SafeMathInt for int256;\n\n    address WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\n    address DEAD = 0x000000000000000000000000000000000000dEaD;\n    address ZERO = 0x0000000000000000000000000000000000000000;\n\n    string constant _name = \"MetaZilla\";\n    string constant _symbol = \"META\";\n    uint8 constant _decimals = 4;\n\n\n    //mapping (address =\u003e uint256) _balances;\n    mapping (address =\u003e uint256) _rBalance;\n    mapping (address =\u003e mapping (address =\u003e uint256)) _allowances;\n\n    mapping (address =\u003e bool) public isFeeExempt;\n    mapping (address =\u003e bool) public isTxLimitExempt;\n    mapping (address =\u003e bool) public isTimelockExempt;\n    mapping (address =\u003e bool) public isDividendExempt;\n\n    uint256 public liquidityFee    = 3;\n    uint256 public reflectionFee   = 4;\n    uint256 public marketingFee    = 6;\n    uint256 public devFee          = 0;\n    uint256 public buyBackFee      = 0;\n    uint256 public totalFee        = marketingFee + reflectionFee + liquidityFee + devFee + buyBackFee;\n    uint256 public feeDenominator  = 100;\n\n    // Anti-Bot v2\n    uint256 public maxRoomRent = 8000000000;\n    bool public hotelCaliforniaMode = false;\n    mapping (address =\u003e bool) public isHouseguest;\n\n    uint256 public deadBlocks = 0;\n    uint256 public launchedAt = 0;\n\n    uint256 public sellMultiplier  = 100;\n\n    address public autoLiquidityReceiver;\n    address public marketingFeeReceiver;\n    address public devFeeReceiver;\n    address public buyBackFeeReceiver;\n\n    uint256 targetLiquidity = 20;\n    uint256 targetLiquidityDenominator = 100;\n\n    IDEXRouter public router;\n    address public pair;\n    InterfaceLP public pairContract; \n\n    bool public tradingOpen = false;\n\n    DividendDistributor public distributor;\n    uint256 distributorGas = 500000;\n\n    bool public buyCooldownEnabled = false;\n    uint8 public cooldownTimerInterval = 5;\n    mapping (address =\u003e uint) private cooldownTimer;\n\n    bool public swapEnabled = false;\n    bool inSwap;\n    modifier swapping() { inSwap = true; _; inSwap = false; }\n\n    address public master;\n    modifier onlyMaster() {\n        require(msg.sender == master || isOwner(msg.sender));\n        _;\n    }\n\n    event LogRebase(uint256 indexed epoch, uint256 totalSupply);\n    event CaliforniaCheckin(address guest, uint256 rentPaid);\n\n    uint256 private constant INITIAL_FRAGMENTS_SUPPLY = 10**15 * 10**_decimals;\n    uint256 public swapThreshold = rSupply * 10 / 10000;\n    uint256 public rebase_count = 0;\n    uint256 public rate;\n    uint256 public _totalSupply;\n    uint256 private constant MAX_UINT256 = ~uint256(0);\n    uint256 private constant MAX_SUPPLY = ~uint128(0);\n    uint256 private constant rSupply = MAX_UINT256 - (MAX_UINT256 % INITIAL_FRAGMENTS_SUPPLY);\n\n    // Max wallet \u0026 Transaction\n    uint256 public _maxWalletToken = rSupply.div(100).mul(3);\n\n    function rebase_percentage(uint256 _percentage_base1000, bool reduce) public onlyOwner returns (uint256 newSupply){\n\n        if(reduce){\n            newSupply = rebase(0,int(_totalSupply.div(1000).mul(_percentage_base1000)).mul(-1));\n        } else{\n            newSupply = rebase(0,int(_totalSupply.div(1000).mul(_percentage_base1000)));\n        }\n        rate = rSupply.div(_totalSupply);\n        pairContract.sync();\n    }\n\n    // Sauce\n    function rebase(uint256 epoch, int256 supplyDelta) public onlyMaster returns (uint256) {\n        rebase_count++;\n        if(epoch == 0){\n            epoch = rebase_count;\n        }\n\n        require(!inSwap, \"Try again\");\n\n        if (supplyDelta == 0) {\n            emit LogRebase(epoch, _totalSupply);\n            return _totalSupply;\n        }\n\n        if (supplyDelta \u003c 0) {\n            _totalSupply = _totalSupply.sub(uint256(-supplyDelta));\n        } else {\n            _totalSupply = _totalSupply.add(uint256(supplyDelta));\n        }\n\n        if (_totalSupply \u003e MAX_SUPPLY) {\n            _totalSupply = MAX_SUPPLY;\n        }\n\n        rate = rSupply.div(_totalSupply);\n        pairContract.sync();\n\n        emit LogRebase(epoch, _totalSupply);\n        return _totalSupply;\n    }\n\n\n\n    constructor () Auth(msg.sender) {\n        router = IDEXRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n        pair = IDEXFactory(router.factory()).createPair(WBNB, address(this));\n        _allowances[address(this)][address(router)] = uint256(-1);\n\n        \n        pairContract = InterfaceLP(pair);\n        _totalSupply = INITIAL_FRAGMENTS_SUPPLY;\n        rate = rSupply.div(_totalSupply);\n\n\n        distributor = new DividendDistributor(address(router));\n\n        isFeeExempt[msg.sender] = true;\n        isTxLimitExempt[msg.sender] = true;\n\n        isTimelockExempt[msg.sender] = true;\n        isTimelockExempt[DEAD] = true;\n        isTimelockExempt[address(this)] = true;\n\n        isDividendExempt[pair] = true;\n        isDividendExempt[address(this)] = true;\n        isDividendExempt[DEAD] = true;\n\n        autoLiquidityReceiver = DEAD;\n        marketingFeeReceiver = 0x701af5C8aa4ded320491F4E1606C8A9297a15B23;\n        devFeeReceiver = 0x701af5C8aa4ded320491F4E1606C8A9297a15B23;\n        buyBackFeeReceiver = 0x701af5C8aa4ded320491F4E1606C8A9297a15B23;\n\n        _rBalance[msg.sender] = rSupply;\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n\n    receive() external payable { }\n\n    \n    \n    function totalSupply() external view override returns (uint256) { return _totalSupply; }\n    function decimals() external pure override returns (uint8) { return _decimals; }\n    function symbol() external pure override returns (string memory) { return _symbol; }\n    function name() external pure override returns (string memory) { return _name; }\n    function getOwner() external view override returns (address) { return owner; }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _rBalance[account].div(rate);\n    }\n    \n    function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    \n    \n    function approveMax(address spender) external returns (bool) {\n        return approve(spender, uint256(-1));\n    }\n\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\n        return _transferFrom(msg.sender, recipient, amount);\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\n        if(_allowances[sender][msg.sender] != uint256(-1)){\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount, \"Insufficient Allowance\");\n        }\n\n        return _transferFrom(sender, recipient, amount);\n    }\n\n    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\n        if(inSwap){ return _basicTransfer(sender, recipient, amount); }\n\n        if(!authorizations[sender] \u0026\u0026 !authorizations[recipient]){\n            require(tradingOpen,\"Trading not open yet\");\n        }\n\n        uint256 rAmount = amount.mul(rate);\n\n        if (!authorizations[sender] \u0026\u0026 recipient != address(this)  \u0026\u0026 recipient != address(DEAD) \u0026\u0026 recipient != pair \u0026\u0026 recipient != marketingFeeReceiver \u0026\u0026 recipient != devFeeReceiver  \u0026\u0026 recipient != autoLiquidityReceiver \u0026\u0026 recipient != buyBackFeeReceiver){\n            uint256 heldTokens = balanceOf(recipient);\n            require((heldTokens + rAmount) \u003c= _maxWalletToken,\"Total Holding is currently limited, you can not buy that much.\");}\n        \n        if (sender == pair \u0026\u0026\n            buyCooldownEnabled \u0026\u0026\n            !isTimelockExempt[recipient]) {\n            require(cooldownTimer[recipient] \u003c block.timestamp,\"buy Cooldown exists\");\n            cooldownTimer[recipient] = block.timestamp + cooldownTimerInterval;\n        }\n\n    // plz ser, dont snipe with a bot\n        if(hotelCaliforniaMode){\n            require(!isHouseguest[sender],\"Bots cant sell\");\n            if(tx.gasprice \u003e maxRoomRent \u0026\u0026 sender == pair){\n                isHouseguest[recipient] = true;\n                emit CaliforniaCheckin(recipient, tx.gasprice);\n            }\n        }\n\n        if(shouldSwapBack()){ swapBack(); }\n\n        //Exchange tokens\n        _rBalance[sender] = _rBalance[sender].sub(rAmount, \"Insufficient Balance\");\n\n        uint256 amountReceived = (!shouldTakeFee(sender) || !shouldTakeFee(recipient)) ? rAmount : takeFee(sender, rAmount,(recipient == pair));\n        _rBalance[recipient] = _rBalance[recipient].add(amountReceived);\n\n        // Dividend tracker\n        if(!isDividendExempt[sender]) {\n            try distributor.setShare(sender, balanceOf(sender)) {} catch {}\n        }\n\n        if(!isDividendExempt[recipient]) {\n            try distributor.setShare(recipient, balanceOf(recipient)) {} catch {} \n        }\n\n        try distributor.process(distributorGas) {} catch {}\n\n        emit Transfer(sender, recipient, amountReceived.div(rate));\n        return true;\n    }\n    \n    // Changed\n    \n    function _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\n        uint256 rAmount = amount.mul(rate);\n        _rBalance[sender] = _rBalance[sender].sub(rAmount, \"Insufficient Balance\");\n        _rBalance[recipient] = _rBalance[recipient].add(rAmount);\n        emit Transfer(sender, recipient, rAmount.div(rate));\n        return true;\n    }\n\n    function shouldTakeFee(address sender) internal view returns (bool) {\n        return !isFeeExempt[sender];\n    }\n\n\n    function takeFee(address sender, uint256 rAmount, bool isSell) internal returns (uint256) {\n        \n        uint256 multiplier = 100;\n        if(isSell){\n            multiplier = sellMultiplier;\n        } \n\n        uint256 feeAmount = rAmount.div(feeDenominator * 100).mul(totalFee).mul(multiplier);\n\n        if(!isSell \u0026\u0026 (launchedAt + deadBlocks) \u003e block.number){\n            feeAmount = rAmount.div(100).mul(99);\n        }\n\n        _rBalance[address(this)] = _rBalance[address(this)].add(feeAmount);\n        emit Transfer(sender, address(this), feeAmount.div(rate));\n\n        return rAmount.sub(feeAmount);\n    }\n\n  \n    function shouldSwapBack() internal view returns (bool) {\n        return msg.sender != pair\n        \u0026\u0026 !inSwap\n        \u0026\u0026 swapEnabled\n        \u0026\u0026 _rBalance[address(this)] \u003e= swapThreshold;\n    }\n\n\n    function clearStuckBalance(uint256 amountPercentage) external authorized {\n        uint256 amountBNB = address(this).balance;\n        payable(marketingFeeReceiver).transfer(amountBNB * amountPercentage / 100);\n    }\n\n    \n    \n    function clearStuckBalance_sender(uint256 amountPercentage) external authorized {\n        uint256 amountBNB = address(this).balance;\n        payable(msg.sender).transfer(amountBNB * amountPercentage / 100);\n    }\n\n    \n    \n    function set_sell_multiplier(uint256 Multiplier) external onlyOwner{\n        sellMultiplier = Multiplier;        \n    }\n\n    // switch Trading\n    \n    function tradingStatus(bool _status, uint256 _deadBlocks) public onlyOwner {\n        tradingOpen = _status;\n        if(tradingOpen \u0026\u0026 launchedAt == 0){\n            launchedAt = block.number;\n            deadBlocks = _deadBlocks;\n        }\n    }\n\n    function launchStatus(uint256 _launchblock) public onlyOwner {\n        launchedAt = _launchblock;\n    }\n\n    // lobby manager\n    function enable_hotel_CaliforniaMode(bool _status) public onlyOwner {\n        hotelCaliforniaMode = _status;\n    }\n\n    function set_max_roomrent(uint256 _rent_withoutdecimal) public onlyOwner {\n        maxRoomRent = _rent_withoutdecimal * 10**9;\n    }\n\n    function manage_houseguests(address[] calldata addresses, bool status) public onlyOwner {\n        for (uint256 i; i \u003c addresses.length; ++i) {\n            isHouseguest[addresses[i]] = status;\n        }\n    }\n\n    function cooldownEnabled(bool _status, uint8 _interval) public onlyOwner {\n        buyCooldownEnabled = _status;\n        cooldownTimerInterval = _interval;\n    }\n\n    // OK, check 3\n    function swapBack() internal swapping {\n        uint256 dynamicLiquidityFee = isOverLiquified(targetLiquidity, targetLiquidityDenominator) ? 0 : liquidityFee;\n        uint256 tokensToSell = swapThreshold.div(rate);\n\n        uint256 amountToLiquify = tokensToSell.div(totalFee).mul(dynamicLiquidityFee).div(2);\n        uint256 amountToSwap = tokensToSell.sub(amountToLiquify);\n\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = WBNB;\n\n        uint256 balanceBefore = address(this).balance;\n\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            amountToSwap,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n\n        uint256 amountBNB = address(this).balance.sub(balanceBefore);\n\n        uint256 totalBNBFee = totalFee.sub(dynamicLiquidityFee.div(2));\n        \n        uint256 amountBNBLiquidity = amountBNB.mul(dynamicLiquidityFee).div(totalBNBFee).div(2);\n        uint256 amountBNBReflection = amountBNB.mul(reflectionFee).div(totalBNBFee);\n        uint256 amountBNBMarketing = amountBNB.mul(marketingFee).div(totalBNBFee);\n        uint256 amountBNBDev = amountBNB.mul(devFee).div(totalBNBFee);\n        uint256 amountBNBBuyback = amountBNB.mul(buyBackFee).div(totalBNBFee);\n\n        try distributor.deposit{value: amountBNBReflection}() {} catch {}\n        (bool tmpSuccess,) = payable(marketingFeeReceiver).call{value: amountBNBMarketing, gas: 30000}(\"\");\n        (tmpSuccess,) = payable(devFeeReceiver).call{value: amountBNBDev, gas: 30000}(\"\");\n        (tmpSuccess,) = payable(buyBackFeeReceiver).call{value: amountBNBBuyback, gas: 30000}(\"\");\n        \n        // only to supress warning msg\n        tmpSuccess = false;\n\n        if(amountToLiquify \u003e 0){\n            router.addLiquidityETH{value: amountBNBLiquidity}(\n                address(this),\n                amountToLiquify,\n                0,\n                0,\n                autoLiquidityReceiver,\n                block.timestamp\n            );\n            emit AutoLiquify(amountBNBLiquidity, amountToLiquify.div(rate));\n        }\n    }\n\n    \n    \n    function setIsDividendExempt(address holder, bool exempt) external authorized {\n        require(holder != address(this) \u0026\u0026 holder != pair);\n        isDividendExempt[holder] = exempt;\n        if(exempt){\n            distributor.setShare(holder, 0);\n        }else{\n            distributor.setShare(holder, balanceOf(holder));\n        }\n    }\n    \n    function setIsFeeExempt(address holder, bool exempt) external authorized {\n        isFeeExempt[holder] = exempt;\n    }\n    \n    function setIsTxLimitExempt(address holder, bool exempt) external authorized {\n        isTxLimitExempt[holder] = exempt;\n    }\n\n    function setIsTimelockExempt(address holder, bool exempt) external authorized {\n        isTimelockExempt[holder] = exempt;\n    }\n\n    function setFees(uint256 _liquidityFee, uint256 _reflectionFee, uint256 _marketingFee, uint256 _devFee, uint256 _buybackFee, uint256 _feeDenominator) external authorized {\n        liquidityFee = _liquidityFee;\n        reflectionFee = _reflectionFee;\n        marketingFee = _marketingFee;\n        devFee = _devFee;\n        buyBackFee = _buybackFee;\n        totalFee = _liquidityFee.add(_reflectionFee).add(_marketingFee).add(_devFee).add(_buybackFee);\n        feeDenominator = _feeDenominator;\n        require(totalFee \u003c feeDenominator);\n    }\n\n    \n    function setFeeReceivers(address _autoLiquidityReceiver, address _marketingFeeReceiver, address _devFeeReceiver, address _buyBackFeeReceiver ) external authorized {\n        autoLiquidityReceiver = _autoLiquidityReceiver;\n        marketingFeeReceiver = _marketingFeeReceiver;\n        devFeeReceiver = _devFeeReceiver;\n        buyBackFeeReceiver = _buyBackFeeReceiver;\n    }\n\n\n    function setSwapBackSettings(bool _enabled, uint256 _percentage_base1000) external authorized {\n        swapEnabled = _enabled;\n        swapThreshold = rSupply.div(1000).mul(_percentage_base1000);\n    }\n\n\n    function setTargetLiquidity(uint256 _target, uint256 _denominator) external authorized {\n        targetLiquidity = _target;\n        targetLiquidityDenominator = _denominator;\n    }\n\n    \n    function manualSync() external {\n        InterfaceLP(pair).sync();\n    }\n    \n    function setLP(address _address) external onlyOwner {\n        pairContract = InterfaceLP(_address);\n        isFeeExempt[_address];\n    }\n\n    \n    \n    function setMaster(address _master) external onlyOwner {\n        master = _master;\n    }\n\n    \n    function isNotInSwap() external view returns (bool) {\n        return !inSwap;\n    }\n\n    \n    \n    function checkSwapThreshold() external view returns (uint256) {\n        return swapThreshold.div(rate);\n    }\n\n\n    \n    function setDistributionCriteria(uint256 _minPeriod, uint256 _minDistribution) external authorized {\n        distributor.setDistributionCriteria(_minPeriod, _minDistribution);\n    }\n\n    \n    \n    function setDistributorSettings(uint256 gas) external authorized {\n        require(gas \u003c 900000);\n        distributorGas = gas;\n    }\n    \n    \n    \n    function rescueToken(address tokenAddress, uint256 tokens) public onlyOwner returns (bool success) {\n        return IBEP20(tokenAddress).transfer(msg.sender, tokens);\n    }\n\n\n    function getCirculatingSupply() public view returns (uint256) {\n        return (rSupply.sub(_rBalance[DEAD]).sub(_rBalance[ZERO])).div(rate);\n    }\n\n\n    function getLiquidityBacking(uint256 accuracy) public view returns (uint256) {\n        return accuracy.mul(balanceOf(pair).mul(2)).div(getCirculatingSupply());\n    }\n\n\n    function isOverLiquified(uint256 target, uint256 accuracy) public view returns (bool) {\n        return getLiquidityBacking(accuracy) \u003e target;\n    }\n\n    function checkMaxWalletToken() external view returns (uint256) {\n        return _maxWalletToken.div(rate);\n    }\n\n    function setMaxWalletPercent_base1000(uint256 maxWallPercent_base1000) external onlyOwner() {\n        _maxWalletToken = rSupply.div(1000).mul(maxWallPercent_base1000);\n    }\n\n    event AutoLiquify(uint256 amountBNB, uint256 amountTokens);\n\n}\n\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\"\npragma solidity ^0.7.4;\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipRenounced(address indexed previousOwner);\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    constructor() {\n        _owner = msg.sender;\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(isOwner());\n        _;\n    }\n\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipRenounced(_owner);\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\"\npragma solidity ^0.7.4;\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}"},"SafeMathInt.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\"\npragma solidity ^0.7.4;\nlibrary SafeMathInt {\n    int256 private constant MIN_INT256 = int256(1) \u003c\u003c 255;\n    int256 private constant MAX_INT256 = ~(int256(1) \u003c\u003c 255);\n\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a * b;\n\n        require(c != MIN_INT256 || (a \u0026 MIN_INT256) != (b \u0026 MIN_INT256));\n        require((b == 0) || (c / b == a));\n        return c;\n    }\n\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != -1 || a != MIN_INT256);\n\n        return a / b;\n    }\n\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b \u003e= 0 \u0026\u0026 c \u003c= a) || (b \u003c 0 \u0026\u0026 c \u003e a));\n        return c;\n    }\n\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b \u003e= 0 \u0026\u0026 c \u003e= a) || (b \u003c 0 \u0026\u0026 c \u003c a));\n        return c;\n    }\n\n    function abs(int256 a) internal pure returns (int256) {\n        require(a != MIN_INT256);\n        return a \u003c 0 ? -a : a;\n    }\n}"}}