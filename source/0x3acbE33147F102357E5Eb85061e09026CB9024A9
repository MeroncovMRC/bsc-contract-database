/**
 *Submitted for verification at BscScan.com on 2021-10-25
*/

// SPDX-License-Identifier: --ðŸŒ²--

pragma solidity ^0.8.0;

// Get a link to treedefi collectibles BEP721 smart contract
interface ITreedefiForest {
    
    // Transfer collectibles
    function transferFrom(
      address _from,
      address _to,
      uint256 _id
    ) external;
    
    // Fetch owner address
    function getOwner() external returns (address);

}

// Get a link to SEED BEP20 smart contract
interface IBEP20Token {
    
    // Transfer tokens on behalf
    function transferFrom(
      address _from,
      address _to,
      uint256 _value
    ) external returns (bool success);
    
    // Transfer token
    function transfer(
      address _to,
      uint256 _value
    ) external returns (bool success);

}

/**
 * @title Treedefi Nftree Pool Version 1.0
 *
 * @author treedefi
 */
contract NftreePool {
    
  // Link to treedefi collectibles
  ITreedefiForest public NFTREE;
  
  // Link to seed token
  IBEP20Token public SEED;
  
  // Address of treedefi owner
  address public owner;
  
  // Assignment index
  uint32 public nextIndex = 1;
  
  // Release time for existing prize pool
  uint64 public releaseTime;
  
  // Status of reward
  bool public isActiveReward;
  
  // Investor count
  uint32 public totalInvestors;
  
  // Total Investment in pool
  uint256 public totalInvestment;
  
  // Minimum amount required to participate
  uint256 public minAmount;
  
  // Token Id of trees in prize pool
  uint32[] public treeId;
  
  // Lucky numbers generated by owner
  uint32[] private _luckyNumbers;
  
  // List of winning addresses in previous round
  address[] public lastWinners;
  
  // Mapping from address to admin role
  mapping(address => bool) private _isAdmin;
  
  // Mapping from address to poolIndex
  mapping(address => uint32) public poolIndex;
  
  // Mapping from index to investorAddress
  mapping(uint32 => address) public investorAddress;
  
  // Mapping from index to poolValue
  mapping(uint32 => uint256) public poolValue;
  
  /**
	 * @dev Fired in updatePrizePool(), distributePrize() and revokePrize() when  
	 *      any execution is triggered to prize pool   
	 *
	 * @param _by address of executor
	 * @param _numberOfRewards number of tree offered as reward
	 * @param _status defines status of prize pool(1 for initialize, 2 for distribute, 0 for revoke)
	 */
  event RewardPool(
      address indexed _by,
      uint8 _numberOfRewards,
      uint8 _status 
  );
  
  /**
	 * @dev Fired in addSeed() and removeSeed() when seed tokens 
	 *      successfully added/removed to/from pool by user   
	 *
	 * @param _by address of user
	 * @param _amount number of seed tokens added/removed
	 * @param _status defines status (1 for addition, 0 for removal)
	 */
  event Investment(
      address indexed _by,
      uint256 _amount,
      uint8 _status
  );
  
  /**
	 * @dev Fired in generateLuckyNumbers() when owner
	 *      attempts to generate lucky numbers
	 *
	 * @param _by address of executor
	 * @param _counter length of lucky numbers after execution
	 */
  event Generated(
    address indexed _by,
    uint8 _counter
  );
  
  // To check if accessed by owner
  modifier onlyOwner() {
    
    require(
      owner == msg.sender,
      "Treedefi: Not an owner"
    );
    
    _;
  
  }
  
  // To check if accessed either by owner or by admin
  modifier hasAccess() {
    
    require(
      owner == msg.sender || _isAdmin[msg.sender],
      "Treedefi: Access denied"
    );
    
    _;
  
  }
  
  /**
	 * @dev Creates/deploys Treedefi Nftree pool Version 1.0
	 *
	 * @param nftree_ address of treedefi collectibles
	 * @param seed_ address of seed tokens
	 * @param minAmount_ minimum staking amount to participate into pool
	 */
  constructor(address nftree_, address seed_, uint256 minAmount_) {
    
    require(
        nftree_ != address(0) && seed_ != address(0),
        "Treedefi: Invalid Input"
    );
    
    //Setup smart contract internal state//
    NFTREE = ITreedefiForest(nftree_);
    
    SEED = IBEP20Token(seed_);
    
    owner = msg.sender;
    
    minAmount = minAmount_;
    
  }
  
  /** 
    * @notice upgrades admin address to existing NFTREE V2 owner
    *        as ownership of NFTREE V2 is transferable
    */
  function upgradeAdminAddress() external {
    
    // Update owner address
    owner = NFTREE.getOwner();

  }
  
  /** 
    * @dev Sets minimum amount required to participate into prize pool
    * 
    * @notice restricted function, should be called by owner only
    * @param amount_ minimum amount
    */
  function setMinAmount(uint256 amount_) external onlyOwner {
      minAmount = amount_;
  }
  
  /** 
    * @dev Sets given address for admin role
    * 
    * @notice restricted function, should be called by owner only
    * @param admin_ admin role will be assigned to this address
    */
  function addAdmin(address admin_) external onlyOwner {
      
      require(admin_ != address(0), "Treedefi: Invalid input");
      
      _isAdmin[admin_] = true;
      
  }
  
  /** 
    * @dev Removes given address from admin role
    * 
    * @notice restricted function, should be called by owner only
    * @param admin_ role will be removed for this address
    */
  function removeAdmin(address admin_) external onlyOwner {
      
      require(_isAdmin[admin_], "Treedefi: Invalid input");
      
      _isAdmin[admin_] = false;
      
  }
  
  /** 
    * @dev Update prize pool
    * 
    * @notice restricted function, should be called by owner only
    * @notice fails if previous prize pool is running
    * @notice owner can assign upto 10 trees(maximum) in prize pool 
    * 
    * @param treeId_ array defines token Id of trees in prize pool
    * @param duration_ defines duration for release
	*/
  function updatePrizePool(
    uint32[] memory treeId_,
    uint64 duration_
  ) 
    external 
    hasAccess
  {
    
    require(!isActiveReward , "Treedefi: Active Reward");
    
    require(
        duration_ > 0 && treeId_.length <= 10,
        "Treedefi: Invalid input"
    );
    
    for(uint8 i; i < treeId_.length ; i++) {
        
        // Transfer trees to pool contract
        NFTREE.transferFrom(msg.sender, address(this), treeId_[i]);        
        
        // Update prize pool
        treeId.push(treeId_[i]);
        
    }
    
    //--Set internal state--//
    
    releaseTime = uint64(block.timestamp) + duration_;
    
    isActiveReward = true;
    
    // Emits an event
    emit RewardPool(msg.sender, uint8(treeId_.length), 1);
    
  }
  
  /** 
    * @dev Declare winners and distribute prizes
    * 
    * @notice fails if called before release time
    * @notice fails if called before generating lucky numbers
    */
  function distributePrize() external {
     
    require(isActiveReward, "Treedefi: No active reward");
    
    require(block.timestamp > releaseTime, "Treedefi: Release time not reached");
    
    require(treeId.length == _luckyNumbers.length, "Treedefi: Insufficient lucky numbers");
    
    // Delete previous winners' addresses
    delete lastWinners;
    
    // Get reward count
    uint8 _length = uint8(treeId.length);
    
    for(uint8 i; i < _length; i++){
        
        // Get a generated lucky numbers
        uint32 _number = _luckyNumbers[i]; 
        
        // Get lucky winner's address
        address _winner = investorAddress[_number];
        
        // Record winner's address
        lastWinners.push(_winner);
        
        // Transfer prize to winner
        NFTREE.transferFrom(address(this), _winner, treeId[i]);
    
    }
    
    //--Unset internal state--//
    delete releaseTime;
    
    delete treeId;
    
    delete _luckyNumbers;
    
    isActiveReward = false;
    
    // Emits an event
    emit RewardPool(msg.sender, _length, 2);
    
  }
  
  /** 
    * @dev Revoke reward event and removes prize pool
    * 
    * @notice restricted function, should be called by owner only
    * @notice fails if reward event is not active
    * @notice ends active reward event without declaring winners
    */
  function revokePrize() external hasAccess {
    
    require(isActiveReward, "Treedefi: No active rewards");
    
    // Get reward count
    uint8 _length = uint8(treeId.length);
    
    for(uint8 i; i < _length; i++){
        
        // Transfer prize to owner
        NFTREE.transferFrom(address(this), owner, treeId[i]);
    
    }
    
    //--Unset internal state--//
    delete releaseTime;
    
    delete treeId;
    
    delete _luckyNumbers;
    
    isActiveReward = false;
    
    // Emits an event
    emit RewardPool(msg.sender, _length, 0);
    
  }
  
  /** 
    * @dev Adds seed tokens to pool
    * 
    * @notice minimum threshold amount set by owner should be maintained
    * @param amount_ unsigned integer defines number of seed tokens to add
    */
  function addSeed(uint256 amount_) external {
    
    // Get pool index of user
    uint32 _index = (poolIndex[msg.sender] == 0) ? nextIndex : poolIndex[msg.sender];
    
    // Check if new user
    if(poolIndex[msg.sender] == 0) {
        
        require(amount_ >= minAmount, "TreeDefi: Amount is not enough");
        
        //-----Set internal state-----// 
        poolIndex[msg.sender] = _index;
        
        investorAddress[_index] = msg.sender;
        
        // Increment next index
        nextIndex++;
        
        // Increment investor count
        totalInvestors++;
        
    }
    
    // Transfer seed tokens from user to pool contract
    SEED.transferFrom(msg.sender, address(this), amount_);
    
    // Increment pool value of user
    poolValue[_index] += amount_;
    
    // Investment total invested amount
    totalInvestment += amount_;
    
    // Emit an event
    emit Investment(msg.sender, amount_, 1);
    
  }
  
  /** 
    * @dev Removes seed tokens from pool
    * 
    * @notice minimum threshold amount set by owner should be maintained
    * @param amount_ unsigned integer defines number of seed tokens to remove
    */
  function removeSeed(uint256 amount_) external {
    
    // Get pool index of user
    uint32 _index = poolIndex[msg.sender];
    
    // Get pool value of user
    uint256 _poolValue = poolValue[_index];
    
    require(amount_ != 0, "TreeDefi: Invalid input");
    
    require(
        (_poolValue == amount_) || (minAmount <= (_poolValue - amount_)),
        "TreeDefi: Invalid amount"
    );
    
    // Transfer seed tokens from pool contract to user
    SEED.transfer(msg.sender, amount_);
    
    // Decrement pool value of user
    poolValue[_index] -= amount_;
    
    // Decrement total invested amount
    totalInvestment -= amount_;
    
    // Check if full withdrawal
    if(_poolValue == amount_) {
        
        // Get last investor address
        address _lastInvestor = investorAddress[totalInvestors];
        
        // Get last investor's pool value
        uint256 _lastPoolValue = poolValue[totalInvestors];
        
        // Check if user is not last investor
        if(_index != totalInvestors) {
            
            // Assign given index to last investor 
            poolIndex[_lastInvestor] = _index;
            
            // Assign last investor's address to given index
            investorAddress[_index] = _lastInvestor;
            
            // Assign last investor's pool value to given index 
            poolValue[_index] = _lastPoolValue;
        
        }
        
        // Delete user's data
        delete poolIndex[msg.sender];
        
        delete investorAddress[totalInvestors];
        
        delete poolValue[totalInvestors];
        
        // Decrement next index
        nextIndex--;
        
        // Decrement total investors count
        totalInvestors--;
        
    }
    
    // Emit an event
    emit Investment(msg.sender, amount_, 0);
    
  }
  
  /**
    * @dev Returns number of lucky numbers generated by owner
    */
  function luckyNumbersLength() 
    external
    view
    returns(uint256)
  {
    return _luckyNumbers.length;
  }
  
  /**
    * @dev Returns number of last winners
    */
  function lastWinnersLength() 
    external
    view
    returns(uint256)
  {
    return lastWinners.length;
  }
  
  /**
    * @dev Returns number of trees offered as reward
    */
  function treeIdLength() 
    external
    view
    returns(uint256)
  {
    return treeId.length;
  }
  
  /** 
    * @dev Generates lucky numbers in batch
    * 
    * @notice restricted function, should be called by owner only
    * @param counter_ length of lucky numbers to be generated
    */
  function generateLuckyNumbersBatch(uint8 counter_)
    external
  {
      
    for(uint8 i; i < counter_; i++) {
        
        generateLuckyNumbers();
        
    }
    
  }
  
  /** 
    * @dev Generate lucky numbers up to prize pool length
    * 
    * @notice restricted function, should be called by owner or drawer only
    * @notice fails if reward event is not active or called before release time
    * @notice try upto 3 (maximum) times to generate lucky number
    * @notice stops execution if required lucky numbers are generated
    */
  function generateLuckyNumbers()
    public
    hasAccess
  {
      
    require(isActiveReward, "Treedefi: No active reward");
    
    require(block.timestamp > releaseTime, "Treedefi: Release time not reached");
    
    require(_luckyNumbers.length < treeId.length, "Treedefi: Lucky numbers generated");
    
    // Get index of highest holder amongst lucky numbers generated
    uint32 _highestHoldingNumber;
    
    for(uint8 i; i <= 3; i++) {
            
        // Get a modified number
        uint256 _salt = i * (i + _luckyNumbers.length); 
            
        // Get a random number 
        uint32 _number = (_getLuckyNumber(_salt) % totalInvestors) + 1; 
            
        // Get average contribution
        uint256 _avg = totalInvestment / totalInvestors;
            
        // Checks if lucky number holds more than average contribution in pool  
        if(poolValue[_number] >= _avg){
                
            // Record lucky number
            _luckyNumbers.push(_number);
                
        } else {
            
            // Record index of highest holder   
            _highestHoldingNumber = (poolValue[_number] > poolValue[_highestHoldingNumber]) ?
                                         _number : _highestHoldingNumber; 
                
        }
        
        // Checks and return if required lucky numbers are generated
        if(treeId.length == _luckyNumbers.length) {
            return;
        }
        
    }
    
    // Record highest holder's index to lucky number   
    _luckyNumbers.push(_highestHoldingNumber);
    
    //emit an event
    emit Generated(msg.sender, uint8(_luckyNumbers.length));
    
  }
  
  /** @dev Called internally to generate random numbers
     * 
     *@param salt_ unsigned integer to add more complexivity in random number generation
     *@return uint256 random number between 0 to 99999
     */
  function _getLuckyNumber(uint256 salt_)
    internal
    view
    returns(uint32)
  {
    // Generates random number
    uint256 seed = uint256(keccak256(abi.encodePacked(
        block.timestamp + block.difficulty + salt_ +
        ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (block.timestamp)) +
        block.gaslimit + 
        ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (block.timestamp)) +
        block.number
    )));
    
    // Returns random number
    return uint32(seed - ((seed / 100000) * 100000));
  
  }
  
}