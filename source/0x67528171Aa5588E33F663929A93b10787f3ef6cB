{"AIOZToken.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \u0027./IERC20.sol\u0027;\r\nimport \u0027./IERC20Metadata.sol\u0027;\r\nimport \u0027./Ownable.sol\u0027;\r\nimport \u0027./TokenTimelock.sol\u0027;\r\n\r\ncontract ERC20 is IERC20, IERC20Metadata {\r\n    mapping (address =\u003e uint256) private _balances;\r\n\r\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    constructor (string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n    \r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        uint256 currentAllowance = _allowances[sender][msg.sender];\r\n        require(currentAllowance \u003e= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        _approve(sender, msg.sender, currentAllowance - amount);\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[msg.sender][spender];\r\n        require(currentAllowance \u003e= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance \u003e= amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[sender] = senderBalance - amount;\r\n        _balances[recipient] += amount;\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance \u003e= amount, \"ERC20: burn amount exceeds balance\");\r\n        _balances[account] = accountBalance - amount;\r\n        _totalSupply -= amount;\r\n\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n}\r\n\r\ncontract AIOZToken is ERC20, Ownable {\r\n    uint256 private _maxTotalSupply;\r\n    \r\n    constructor() ERC20(\"AIOZ Network\", \"AIOZ\") {\r\n        _maxTotalSupply = 1000000000e18;\r\n        \r\n        // init timelock factory\r\n        TimelockFactory timelockFactory = new TimelockFactory();\r\n\r\n        // ERC20\r\n        // // public sales\r\n        // mint(0x076592ad72b79bBaBDD05aDd7d367f44f2CFf658, 10333333e18); // for Paid Ignition\r\n        // // private sales\r\n        // mint(0xF8477220f8375968E38a3B79ECA4343822b53af2, 73000000e18*25/100);\r\n        // address privateSalesLock = timelockFactory.createTimelock(this, 0xF8477220f8375968E38a3B79ECA4343822b53af2, block.timestamp + 30 days, 73000000e18*25/100, 30 days);\r\n        // mint(privateSalesLock, 73000000e18*75/100);\r\n        // // team\r\n        // address teamLock = timelockFactory.createTimelock(this, 0x82E83054CC631C0Da85Ca67087E45ca31b93F29b, block.timestamp + 180 days, 250000000e18*8/100, 30 days);\r\n        // mint(teamLock, 250000000e18);\r\n        // // advisors\r\n        // address advisorsLock = timelockFactory.createTimelock(this, 0xBbf78c2Ee1794229e31af81c83F4d5125F08FE0F, block.timestamp + 90 days, 50000000e18*8/100, 30 days);\r\n        // mint(advisorsLock, 50000000e18);\r\n        // // marketing\r\n        // mint(0x9E2F8e278585CAfD3308E894d2E09ffEc520b1E9, 30000000e18*10/100);\r\n        // address marketingERC20Lock = timelockFactory.createTimelock(this, 0x9E2F8e278585CAfD3308E894d2E09ffEc520b1E9, block.timestamp + 30 days, 30000000e18*5/100, 30 days);\r\n        // mint(marketingERC20Lock, 30000000e18*90/100);\r\n        // // exchange liquidity provision\r\n        // mint(0x6c3D8872002B66C808aE462Db314B87962DCC7aF, 23333333e18);\r\n        // // ecosystem growth\r\n        // address growthLock = timelockFactory.createTimelock(this, 0xCFd6736a11e76c0e3418FEEbb788822211d92F1e, block.timestamp + 90 days, 0, 0);\r\n        // mint(growthLock, 530000000e18);\r\n\r\n        // BEP20\r\n        // public sales\r\n        mint(0xc9Fc843DBAA8ccCcf37E09b67DeEa5f963E3919E, 6666667e18); // for BSCPad\r\n        // marketing\r\n        mint(0x7e318e80EB8e401451334cAa2278E39Da7F6C49B, 20000000e18*10/100);\r\n        address marketingBEP20Lock = timelockFactory.createTimelock(this, 0x7e318e80EB8e401451334cAa2278E39Da7F6C49B, block.timestamp + 30 days, 20000000e18*5/100, 30 days);\r\n        mint(marketingBEP20Lock, 20000000e18*90/100);\r\n        // exchange liquidity provision\r\n        mint(0x0a515Ac284E3c741575A4fd71C27e377a19D5E6D, 6666667e18);\r\n    }\r\n\r\n    function mint(address account, uint256 amount) public onlyOwner returns (bool) {\r\n        require(totalSupply() + amount \u003c= _maxTotalSupply, \"AIOZ Token: mint more than the max total supply\");\r\n        _mint(account, amount);\r\n        return true;\r\n    }\r\n\r\n    function burn(uint256 amount) public onlyOwner returns (bool) {\r\n        _burn(msg.sender, amount);\r\n        return true;\r\n    }\r\n}"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"},"IERC20Metadata.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./IERC20.sol\";\r\n\r\ninterface IERC20Metadata is IERC20 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n}"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () {\r\n        address msgSender = msg.sender;\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}"},"TokenTimelock.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \u0027./IERC20.sol\u0027;\r\n\r\ncontract TokenTimelock {\r\n    IERC20 private _token;\r\n    address private _beneficiary;\r\n    uint256 private _nextReleaseTime;\r\n    uint256 private _releaseAmount;\r\n    uint256 private _releasePeriod;\r\n\r\n    TimelockFactory private _factory;\r\n\r\n    event Released(address indexed beneficiary, uint256 amount);\r\n    event BeneficiaryTransferred(address indexed previousBeneficiary, address indexed newBeneficiary);\r\n\r\n\tconstructor(){\r\n\t\t_token = IERC20(address(1));\r\n\t}\r\n\r\n\tfunction init(IERC20 token_, address beneficiary_, uint256 releaseStart_, uint256 releaseAmount_, uint256 releasePeriod_) external {\r\n\t\trequire(_token == IERC20(address(0)), \"TokenTimelock: already initialized\");\r\n\t\trequire(token_ != IERC20(address(0)), \"TokenTimelock: erc20 token address is zero\");\r\n        require(beneficiary_ != address(0), \"TokenTimelock: beneficiary address is zero\");\r\n        require(releasePeriod_ == 0 || releaseAmount_ != 0, \"TokenTimelock: release amount is zero\");\r\n\r\n        emit BeneficiaryTransferred(address(0), beneficiary_);\r\n\r\n        _token = token_;\r\n        _beneficiary = beneficiary_;\r\n        _nextReleaseTime = releaseStart_;\r\n        _releaseAmount = releaseAmount_;\r\n        _releasePeriod = releasePeriod_;\r\n\r\n        _factory = TimelockFactory(msg.sender);\r\n\t}\r\n\r\n    function token() public view virtual returns (IERC20) {\r\n        return _token;\r\n    }\r\n\r\n    function beneficiary() public view virtual returns (address) {\r\n        return _beneficiary;\r\n    }\r\n\r\n    function nextReleaseTime() public view virtual returns (uint256) {\r\n        return _nextReleaseTime;\r\n    }\r\n\r\n    function releaseAmount() public view virtual returns (uint256) {\r\n        return _releaseAmount;\r\n    }\r\n\r\n    function balance() public view virtual returns (uint256) {\r\n        return token().balanceOf(address(this));\r\n    }\r\n\r\n    function releasableAmount() public view virtual returns (uint256) {\r\n        if (block.timestamp \u003c _nextReleaseTime) return 0;\r\n\r\n        uint256 amount = balance();\r\n        if (amount == 0) return 0;\r\n        if (_releasePeriod == 0) return amount;\r\n\r\n        uint256 passedPeriods = (block.timestamp - _nextReleaseTime) / _releasePeriod;\r\n        uint256 maxReleasableAmount = (passedPeriods + 1) * _releaseAmount;\r\n        \r\n        if (amount \u003c= maxReleasableAmount) return amount;\r\n        return maxReleasableAmount;\r\n    }\r\n\r\n    function releasePeriod() public view virtual returns (uint256) {\r\n        return _releasePeriod;\r\n    }\r\n\r\n    function release() public virtual returns (bool) {\r\n        // solhint-disable-next-line not-rely-on-time\r\n        require(block.timestamp \u003e= nextReleaseTime(), \"TokenTimelock: current time is before release time\");\r\n\r\n        uint256 _releasableAmount = releasableAmount();\r\n        require(_releasableAmount \u003e 0, \"TokenTimelock: no releasable tokens\");\r\n\r\n        emit Released(beneficiary(), _releasableAmount);\r\n        require(token().transfer(beneficiary(), _releasableAmount));\r\n\r\n        if (_releasePeriod != 0) {\r\n            uint256 passedPeriods = (block.timestamp - _nextReleaseTime) / _releasePeriod;\r\n            _nextReleaseTime += (passedPeriods + 1) * _releasePeriod;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferBeneficiary(address newBeneficiary) public virtual returns (bool) {\r\n\t\trequire(msg.sender == beneficiary(), \"TokenTimelock: caller is not the beneficiary\");\r\n\t\trequire(newBeneficiary != address(0), \"TokenTimelock: the new beneficiary is zero address\");\r\n\t\t\r\n        emit BeneficiaryTransferred(beneficiary(), newBeneficiary);\r\n\t\t_beneficiary = newBeneficiary;\r\n\t\treturn true;\r\n\t}\r\n\r\n    function split(address splitBeneficiary, uint256 splitAmount) public virtual returns (bool) {\r\n        uint256 _amount = balance();\r\n\t\trequire(msg.sender == beneficiary(), \"TokenTimelock: caller is not the beneficiary\");\r\n\t\trequire(splitBeneficiary != address(0), \"TokenTimelock: beneficiary address is zero\");\r\n        require(splitAmount \u003e 0, \"TokenTimelock: amount is zero\");\r\n        require(splitAmount \u003c= _amount, \"TokenTimelock: amount exceeds balance\");\r\n\r\n        uint256 splitReleaseAmount;\r\n        if (_releasePeriod \u003e 0) {\r\n            splitReleaseAmount = _releaseAmount * splitAmount / _amount;\r\n        }\r\n\r\n        address newTimelock = _factory.createTimelock(token(), splitBeneficiary, _nextReleaseTime, splitReleaseAmount, _releasePeriod);\r\n\r\n        require(token().transfer(newTimelock, splitAmount));\r\n        _releaseAmount -= splitReleaseAmount;\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\ncontract CloneFactory {\r\n  function createClone(address target) internal returns (address result) {\r\n    bytes20 targetBytes = bytes20(target);\r\n    assembly {\r\n      let clone := mload(0x40)\r\n      mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n      mstore(add(clone, 0x14), targetBytes)\r\n      mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n      result := create(0, clone, 0x37)\r\n    }\r\n  }\r\n}\r\n\r\ncontract TimelockFactory is CloneFactory {\r\n\taddress private _tokenTimelockImpl;\r\n\tevent Timelock(address timelockContract);\r\n\tconstructor() {\r\n\t\t_tokenTimelockImpl = address(new TokenTimelock());\r\n\t}\r\n\tfunction createTimelock(IERC20 token, address to, uint256 releaseTime, uint256 releaseAmount, uint256 period) public returns (address) {\r\n\t\taddress clone = createClone(_tokenTimelockImpl);\r\n\t\tTokenTimelock(clone).init(token, to, releaseTime, releaseAmount, period);\r\n\r\n\t\temit Timelock(clone);\r\n\t\treturn clone;\r\n\t}\r\n}"}}