{"BountySquare.sol":{"content":"/*\r\n    BSC Token developed by Kraitor \u003cTG: kraitordev\u003e\r\n*/\r\n\r\n//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\nimport \"IBEP20.sol\";\r\nimport \"SafeMath.sol\";\r\nimport \"MultiSignAuth.sol\";\r\nimport \"IDEXFactory.sol\";\r\nimport \"IDEXRouter.sol\";\r\n\r\ncontract BountySquare is IBEP20, MultiSignAuth {\r\n    using SafeMath for uint256;\r\n\r\n    address DEAD = 0x000000000000000000000000000000000000dEaD;\r\n    address ZERO = 0x0000000000000000000000000000000000000000;\r\n    address WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\r\n    address PANCAKE_ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\r\n\r\n    string constant _name = \"Bounty Square\";\r\n    string constant _symbol = \"bnsq\";\r\n    uint8 constant _decimals = 18;\r\n\r\n    uint256 public _totalSupply = 10_000_000_000 * (10 ** _decimals);\r\n    uint256 public _maxWalletSize = (_totalSupply * 35) / 1000;  //3.5% max wallet\r\n\r\n    mapping (address =\u003e uint256) _balances;\r\n    mapping (address =\u003e mapping (address =\u003e uint256)) _allowances;\r\n\r\n    mapping (address =\u003e bool) public isFeeExempt;\r\n    mapping (address =\u003e bool) public isWalletLimitExempt;\r\n\r\n    //Open/close trade\r\n    bool public isTradeOpened = false;\r\n\r\n    //Total fee\r\n    uint256 public buySellFee = 100;\r\n    uint256 public feeDenominator = 10000;\r\n\r\n    //Fees, all of them over buySellFee (100)\r\n    uint256 public liquidityFee = 10;\r\n    uint256 public marketingFee = 10;\r\n    uint256 public rewardsFee = 10;\r\n    uint256 public devFee = 70;\r\n\r\n    //Fees receivers, can be set only one time\r\n    address public liquidityFeeReceiver;\r\n    address public marketingFeeReceiver;\r\n    address public rewardsFeeReceiver;\r\n    address public devFeeReceiver;\r\n\r\n    //Wallet to manage project supply, unique wallet that allows burns\r\n    address public supplyWallet;\r\n\r\n    //Liq. pair and router\r\n    IDEXRouter private router;\r\n    address public pair;\r\n\r\n    //Swapback settings\r\n    bool public swapEnabled = true;\r\n    uint256 public swapThreshold = _totalSupply / 1000 * 3; // 0.3%\r\n    uint256 public pcThresholdMaxSell = 100; //Applied over swapThreshold\r\n\r\n    bool inSwap;\r\n    modifier swapping() { inSwap = true; _; inSwap = false; }\r\n\r\n    constructor (address _WBNB, address _PANCAKE_ROUTER) MultiSignAuth(msg.sender) {\r\n        if(_PANCAKE_ROUTER != address(0)){ PANCAKE_ROUTER = _PANCAKE_ROUTER; }\r\n        if(_WBNB != address(0)){ WBNB = _WBNB; }\r\n\r\n        router = IDEXRouter(PANCAKE_ROUTER);\r\n        pair = IDEXFactory(router.factory()).createPair(WBNB, address(this));\r\n        _allowances[address(this)][address(router)] = type(uint256).max;\r\n\r\n        address _owner = getOwners()[0];\r\n        isWalletLimitExempt[pair] = true;\r\n        isWalletLimitExempt[address(this)] = true;\r\n\r\n        _balances[_owner] = _totalSupply;\r\n        emit Transfer(address(0), _owner, _totalSupply);\r\n    }\r\n\r\n    receive() external payable { }\r\n\r\n    function getCirculatingSupply() public view returns (uint256) { return _totalSupply.sub(balanceOf(DEAD)).sub(balanceOf(ZERO)); }\r\n\r\n    function totalSupply() external view override returns (uint256) { return _totalSupply; }\r\n    function decimals() external pure override returns (uint8) { return _decimals; }\r\n    function symbol() external pure override returns (string memory) { return _symbol; }\r\n    function name() external pure override returns (string memory) { return _name; }\r\n    function getOwner() external view override returns (address) { return getOwners()[0]; }\r\n    function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }\r\n    function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }    \r\n\r\n    function approve(address spender, uint256 amount) external override returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function approveMax(address spender) external returns (bool) {\r\n        _allowances[msg.sender][spender] = type(uint256).max;\r\n        emit Approval(msg.sender, spender, type(uint256).max);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        return _transferFrom(msg.sender, recipient, amount);\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        if(_allowances[sender][msg.sender] != type(uint256).max){\r\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount, \"Insufficient Allowance\");\r\n        }\r\n\r\n        return _transferFrom(sender, recipient, amount);\r\n    }\r\n\r\n    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        if(inSwap){ return _basicTransfer(sender, recipient, amount); }\r\n        \r\n        if (recipient != pair \u0026\u0026 recipient != DEAD) {\r\n            require(isWalletLimitExempt[recipient] || isOwner[recipient] || _balances[recipient] + amount \u003c= _maxWalletSize, \"Transfer amount exceeds the bag size.\");\r\n        }\r\n        \r\n        if(shouldSwapBack()){ swapBack(); }\r\n\r\n        require(isTradeOpened || isOwner[sender], \"Trade still not opened\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"Insufficient Balance\");\r\n        \r\n        uint256 amountReceived = (shouldTakeFee(sender) \u0026\u0026 shouldTakeFee(recipient)) ? takeFee(sender, amount) : amount;        \r\n        _balances[recipient] = _balances[recipient].add(amountReceived);\r\n\r\n        emit Transfer(sender, recipient, amountReceived);\r\n        return true;\r\n    }\r\n    \r\n    function _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        _balances[sender] = _balances[sender].sub(amount, \"Insufficient Balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n    \r\n    function shouldTakeFee(address sender) internal view returns (bool) { return !isOwner[sender] \u0026\u0026 !isFeeExempt[sender]; }\r\n\r\n    function takeFee(address sender, uint256 amount) internal returns (uint256) {        \r\n        uint256 feeAmount = amount.mul(buySellFee).div(feeDenominator);        \r\n        _balances[address(this)] = _balances[address(this)].add(feeAmount);        \r\n        emit Transfer(sender, address(this), feeAmount);\r\n        return amount.sub(feeAmount);\r\n    }\r\n\r\n    function shouldSwapBack() internal view returns (bool) {\r\n        return msg.sender != pair\r\n        \u0026\u0026 !inSwap\r\n        \u0026\u0026 swapEnabled\r\n        \u0026\u0026 _balances[address(this)] \u003e= swapThreshold;\r\n    }\r\n\r\n    function swapBack() internal swapping {\r\n        uint256 contractTokenBalance = balanceOf(address(this));\r\n        if(contractTokenBalance \u003e swapThreshold.mul(pcThresholdMaxSell).div(100)){\r\n            contractTokenBalance = swapThreshold.mul(pcThresholdMaxSell).div(100);\r\n        }\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = WBNB;\r\n\r\n        try router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            contractTokenBalance,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        ){}catch{}\r\n\r\n        sendFees();\r\n    }\r\n\r\n    function sendFees() internal {\r\n        uint256 amountBNB = address(this).balance;\r\n        if(amountBNB \u003e 0){\r\n            uint256 amountBNBLiquidity = amountBNB.mul(liquidityFee).div(buySellFee);\r\n            uint256 amountBNBDev = amountBNB.mul(devFee).div(buySellFee);\r\n            uint256 amountBNBMarketing = amountBNB.mul(marketingFee).div(buySellFee);\r\n            uint256 amountBNBRewards = amountBNB.mul(rewardsFee).div(buySellFee);\r\n\r\n            if(marketingFeeReceiver != address(0)){\r\n                payable(marketingFeeReceiver).transfer(amountBNBMarketing);\r\n            }\r\n            if(devFeeReceiver != address(0)){\r\n                payable(devFeeReceiver).transfer(amountBNBDev);\r\n            }\r\n            if(rewardsFeeReceiver != address(0)){\r\n                payable(rewardsFeeReceiver).transfer(amountBNBRewards);\r\n            }\r\n            if(liquidityFeeReceiver != address(0)){\r\n                payable(liquidityFeeReceiver).transfer(amountBNBLiquidity);\r\n            }\r\n        }\r\n    }\r\n\r\n    /* \r\n     * Functions that only can be triggered by owners, after the necessary confirmations\r\n     */\r\n    function openTrade(bool _open) external multiSignReq { \r\n        if(multiSign()){ \r\n            isTradeOpened = _open; \r\n        }\r\n    }\r\n\r\n    function burn(uint256 amount) external override multiSignReq {\r\n        require(_balances[supplyWallet] \u003e= amount, \u0027Not enough tokens to burn\u0027);\r\n\r\n        if(multiSign()){ \r\n            _transferFrom(supplyWallet, DEAD, amount);\r\n        }\r\n    }\r\n\r\n    /* \r\n     * Functions that only can be triggered by owners\r\n     */\r\n    function setIsFeeExempt(address holder, bool exempt) external onlyOwners { \r\n        isFeeExempt[holder] = exempt; \r\n    }\r\n\r\n    function setIsWalletLimitExempt(address holder, bool exempt) external onlyOwners {\r\n        isWalletLimitExempt[holder] = exempt;\r\n    }\r\n\r\n    function setFeesReceivers(address _marketingFeeReceiver, address _devFeeReceiver, address _rewardsFeeReceiver, address _liqFeeReceiver) external onlyOwners {\r\n        require(_marketingFeeReceiver != address(0) \u0026\u0026 _devFeeReceiver != address(0) \u0026\u0026 _rewardsFeeReceiver != address(0) \u0026\u0026 _liqFeeReceiver != address(0), \"Zero address not allowed\");\r\n        require(marketingFeeReceiver == address(0) \u0026\u0026 devFeeReceiver == address(0) \u0026\u0026 rewardsFeeReceiver == address(0) \u0026\u0026 liquidityFeeReceiver == address(0), \"Fees receivers only can be set one time\");                    \r\n\r\n        marketingFeeReceiver = _marketingFeeReceiver;        \r\n        devFeeReceiver = _devFeeReceiver;\r\n        rewardsFeeReceiver = _rewardsFeeReceiver;\r\n        liquidityFeeReceiver = _liqFeeReceiver;\r\n\r\n        isFeeExempt[marketingFeeReceiver] = true;               \r\n        isFeeExempt[devFeeReceiver] = true;        \r\n        isFeeExempt[rewardsFeeReceiver] = true;        \r\n        isFeeExempt[liquidityFeeReceiver] = true;\r\n\r\n        isWalletLimitExempt[marketingFeeReceiver] = true; \r\n        isWalletLimitExempt[devFeeReceiver] = true;   \r\n        isWalletLimitExempt[rewardsFeeReceiver] = true;   \r\n        isWalletLimitExempt[liquidityFeeReceiver] = true;   \r\n    }\r\n\r\n    function setSupplyWallet(address _supplyWallet) external onlyOwners { \r\n        require(_supplyWallet != address(0), \"Zero address not allowed\");\r\n        require(supplyWallet == address(0), \"Supply wallet only can be set one time\");\r\n\r\n        supplyWallet = _supplyWallet; \r\n\r\n        isFeeExempt[supplyWallet] = true;        \r\n        isWalletLimitExempt[supplyWallet] = true;\r\n    }\r\n\r\n    function setSwapBackSettings(bool _enabled, uint256 _threshold, uint256 _pcThresholdMaxSell) external onlyOwners {\r\n        require(pcThresholdMaxSell \u003e= 100, \"The _pcThresholdMaxSell has to be 100 or higher\");\r\n\r\n        swapEnabled = _enabled;\r\n        swapThreshold = _threshold;\r\n        pcThresholdMaxSell = _pcThresholdMaxSell;\r\n    }\r\n\r\n    function forceSwapBack() external onlyOwners { \r\n        swapBack(); \r\n    }\r\n\r\n    function forceSendFees() external onlyOwners { \r\n        sendFees(); \r\n    }\r\n\r\n    function transferForeignToken(address _token) public onlyOwners {\r\n        require(_token != address(this), \"Can\u0027t let you take native tokens\");\r\n\r\n        uint256 _contractBalance = IBEP20(_token).balanceOf(address(this));\r\n        IBEP20(_token).transfer(msg.sender, _contractBalance);\r\n    }\r\n}"},"IBEP20.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\n/**\r\n * BEP20 standard interface.\r\n */\r\ninterface IBEP20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function getOwner() external view returns (address);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function burn(uint256 amount) external;\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);    \r\n}"},"IDEXFactory.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\ninterface IDEXFactory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}"},"IDEXRouter.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\ninterface IDEXRouter {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}"},"MultiSignAuth.sol":{"content":"/*\r\n    MultiSign token class, developed by Kraitor \u003cTG: kraitordev\u003e\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\nabstract contract MultiSignAuth {\r\n    /*\r\n     *  Constants\r\n     */\r\n    uint constant public MAX_OWNER_COUNT = 50;\r\n\r\n    /*\r\n     *  Storage\r\n     */    \r\n    mapping (uint =\u003e Transaction) public transactions;\r\n    mapping (uint =\u003e mapping (address =\u003e bool)) public confirmations;\r\n    mapping (address =\u003e bool) internal isOwner;    \r\n    mapping (bytes =\u003e uint) public transactionsIds;\r\n    address[] internal owners;\r\n    uint public required;\r\n    uint public transactionCount;\r\n\r\n    struct Transaction {\r\n        address destination;\r\n        uint value;\r\n        bytes data;\r\n        bool executed;\r\n    }\r\n\r\n    constructor(address _owner) {\r\n        isOwner[_owner] = true;\r\n        owners.push(_owner);\r\n        required = 1;\r\n    }\r\n\r\n    /*\r\n     *  Events\r\n     */\r\n    event Confirmation(address indexed sender, uint indexed transactionId);\r\n    event Revocation(address indexed sender, uint indexed transactionId);\r\n    event Submission(uint indexed transactionId);\r\n\r\n    /*\r\n     *  Modifiers\r\n     */\r\n    modifier ownerDoesNotExist(address owner) {\r\n        require(!isOwner[owner]);\r\n        _;\r\n    }\r\n\r\n    modifier ownerExists(address owner) {\r\n        require(isOwner[owner]);\r\n        _;\r\n    }\r\n\r\n    modifier transactionExists(uint transactionId) {\r\n        require(transactions[transactionId].destination != address(0));\r\n        _;\r\n    }\r\n\r\n    modifier confirmed(uint transactionId, address owner) {\r\n        require(confirmations[transactionId][owner]);\r\n        _;\r\n    }\r\n\r\n    modifier notConfirmed(uint transactionId, address owner) {\r\n        require(!confirmations[transactionId][owner]);\r\n        _;\r\n    }\r\n\r\n    modifier notExecuted(uint transactionId) {\r\n        require(!transactions[transactionId].executed);\r\n        _;\r\n    }\r\n\r\n    modifier notNull(address _address) {\r\n        require(_address != address(0));\r\n        _;\r\n    }\r\n\r\n    modifier validRequirement(uint ownerCount, uint _required) {\r\n        require(ownerCount \u003c= MAX_OWNER_COUNT\r\n            \u0026\u0026 _required \u003c= ownerCount\r\n            \u0026\u0026 _required != 0\r\n            \u0026\u0026 ownerCount != 0);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwners() {\r\n        require(isOwner[msg.sender], \"!OWNER\"); _;\r\n    }\r\n\r\n    bool multiSignAuthRan;\r\n    modifier multiSignReq() { \r\n        require(isOwner[msg.sender], \"!OWNER\");\r\n        multiSignAuthRan = false; \r\n        _;\r\n        require(multiSignAuthRan, \"This transaction requires multisign\"); \r\n        multiSignAuthRan = false;\r\n    }\r\n\r\n    /*\r\n     * Public functions\r\n     */\r\n    /// @dev Sets initial owners and required number of confirmations.\r\n    /// @param _owners List of owners.\r\n    /// @param _required Number of required confirmations.\r\n    function MultiSignOwners(address[] memory _owners, uint _required)\r\n        public\r\n        multiSignReq\r\n        validRequirement(_owners.length, _required)\r\n    {        \r\n        if(multiSign()){\r\n            for (uint i=0; i\u003cowners.length; i++) {\r\n                isOwner[owners[i]] = false;\r\n            }\r\n            for (uint i=0; i\u003c_owners.length; i++) {\r\n                require(_owners[i] != address(0));\r\n                isOwner[_owners[i]] = true;\r\n            }\r\n            owners = _owners;\r\n            required = _required;\r\n        }\r\n    }\r\n\r\n    /// @dev Allows an owner to revoke a confirmation for a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function revokeConfirmation(uint transactionId)\r\n        public\r\n        ownerExists(msg.sender)\r\n        confirmed(transactionId, msg.sender)\r\n        notExecuted(transactionId)\r\n    {\r\n        confirmations[transactionId][msg.sender] = false;\r\n        emit Revocation(msg.sender, transactionId);\r\n    }\r\n\r\n    /*\r\n     * Internal functions\r\n     */\r\n    /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\r\n    /// @return Returns transaction ID.\r\n    function addTransaction()\r\n        internal\r\n        returns (uint)\r\n    {\r\n        uint transactionId = transactionCount;\r\n        if(!transactions[transactionsIds[msg.data]].executed \u0026\u0026 transactions[transactionsIds[msg.data]].destination != address(0))\r\n        {\r\n            transactionId = transactionsIds[msg.data];\r\n        }\r\n        else\r\n        {\r\n            transactions[transactionId] = Transaction({\r\n                destination: address(this),\r\n                value: msg.value,\r\n                data: msg.data,\r\n                executed: false\r\n            });\r\n            transactionsIds[msg.data] = transactionId;\r\n            transactionCount += 1;            \r\n            emit Submission(transactionId);\r\n        }        \r\n        return transactionId;\r\n    }\r\n\r\n    /// @dev Allows an owner to confirm a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function confirmTransaction(uint transactionId)\r\n        internal\r\n        ownerExists(msg.sender)\r\n        transactionExists(transactionId)\r\n        notConfirmed(transactionId, msg.sender)\r\n    {\r\n        confirmations[transactionId][msg.sender] = true;        \r\n        emit Confirmation(msg.sender, transactionId);\r\n    }\r\n\r\n    /// @dev Allows an owner to submit and confirm a transaction.\r\n    /// @return Returns transaction ID.\r\n    function submitTransaction()\r\n        internal\r\n        returns (uint)\r\n    {\r\n        uint transactionId = addTransaction();        \r\n        require(!transactions[transactionId].executed, \"Transaction already executed\");        \r\n        confirmTransaction(transactionId);\r\n        return transactionId;\r\n    }\r\n\r\n    /// @dev Allows an owner to submit and confirm a transaction.\r\n    /// @return Returns the transaction status\r\n    function multiSign()\r\n        internal\r\n        returns (bool)\r\n    {\r\n        multiSignAuthRan = true;\r\n        uint _transactionId = submitTransaction();\r\n        bool _execute = isConfirmed(_transactionId);\r\n        transactions[_transactionId].executed = _execute;\r\n        return _execute;\r\n    }\r\n\r\n    /*\r\n     * Web3 call functions\r\n     */\r\n    /// @dev Returns number of confirmations of a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Number of confirmations.\r\n    function getConfirmationCount(uint transactionId) \r\n        public view \r\n        returns (uint)\r\n    {\r\n        uint count;\r\n        for (uint i=0; i\u003cowners.length; i++)\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n        return count;\r\n    }\r\n\r\n    /// @dev Returns total number of transactions after filers are applied.\r\n    /// @param pending Include pending transactions.\r\n    /// @param executed Include executed transactions.\r\n    /// @return Total number of transactions after filters are applied.\r\n    function getTransactionCount(bool pending, bool executed)\r\n        public view\r\n        returns (uint)\r\n    {\r\n        uint count;\r\n        for (uint i=0; i\u003ctransactionCount; i++)\r\n            if (   pending \u0026\u0026 !transactions[i].executed\r\n                || executed \u0026\u0026 transactions[i].executed)\r\n                count += 1;\r\n        return count;\r\n    }\r\n\r\n    /// @dev Returns the confirmation status of a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Confirmation status.\r\n    function isConfirmed(uint transactionId)\r\n        public view\r\n        returns (bool)\r\n    {\r\n        uint count = 0;\r\n        for (uint i=0; i\u003cowners.length; i++) {\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n            if (count == required)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /// @dev Returns list of owners.\r\n    /// @return List of owner addresses.\r\n    function getOwners()\r\n        public view\r\n        returns (address[] memory)\r\n    {\r\n        return owners;\r\n    }\r\n\r\n    /// @dev Returns array with owner addresses, which confirmed transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Returns array of owner addresses.\r\n    function getConfirmations(uint transactionId)\r\n        public view\r\n        returns (address[] memory)\r\n    {\r\n        address[] memory confirmationsTemp = new address[](owners.length);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i=0; i\u003cowners.length; i++)\r\n            if (confirmations[transactionId][owners[i]]) {\r\n                confirmationsTemp[count] = owners[i];\r\n                count += 1;\r\n            }\r\n        address[] memory _confirmations = new address[](count);\r\n        for (i=0; i\u003ccount; i++)\r\n            _confirmations[i] = confirmationsTemp[i];\r\n\r\n        return _confirmations;\r\n    }\r\n\r\n    /// @dev Returns list of transaction IDs in defined range.\r\n    /// @param from Index start position of transaction array.\r\n    /// @param to Index end position of transaction array.\r\n    /// @param pending Include pending transactions.\r\n    /// @param executed Include executed transactions.\r\n    /// @return Returns array of transaction IDs.\r\n    function getTransactionIds(uint from, uint to, bool pending, bool executed)\r\n        public view\r\n        returns (uint[] memory)\r\n    {\r\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i=0; i\u003ctransactionCount; i++)\r\n            if (   pending \u0026\u0026 !transactions[i].executed\r\n                || executed \u0026\u0026 transactions[i].executed)\r\n            {\r\n                transactionIdsTemp[count] = i;\r\n                count += 1;\r\n            }\r\n        uint[] memory _transactionIds = new uint[](to - from);\r\n        for (i=from; i\u003cto; i++)\r\n            _transactionIds[i - from] = transactionIdsTemp[i];\r\n\r\n        return _transactionIds;\r\n    }\r\n}"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c \u003c a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b \u003e a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n            // benefit is lost if \u0027b\u0027 is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b \u003c= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b \u003e 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b \u003e 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}"}}