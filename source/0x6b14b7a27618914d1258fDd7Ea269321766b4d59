{"ERC20StandardToken.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract ERC20StandardToken is IERC20 {\n    mapping(address =\u003e uint256) private _balances;\n    mapping(address =\u003e mapping(address =\u003e uint256)) private _allowances;\n\n    string private _symbol;\n    string private _name;\n    uint8 private immutable _decimals;\n    uint256 private _totalSupply;\n    \n    constructor(string memory symbol_, string memory name_, uint8 decimals_, uint256 totalSupply_) {\n        _symbol = symbol_;\n        _name = name_;\n        _decimals = decimals_;\n        _mint(msg.sender, totalSupply_);\n    }\n\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        _spendAllowance(from, msg.sender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        uint256 fromBalance = _balances[from];\n        require(fromBalance \u003e= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n    }\n\n    function _addSenderBalance(address from, uint256 amount) internal virtual {\n        _balances[from] += amount;\n    }\n\n    function _subSenderBalance(address from, uint256 amount) internal virtual {\n        uint256 fromBalance = _balances[from];\n        require(fromBalance \u003e= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n    }\n\n    function _addReceiverBalance(address from, address to, uint256 amount) internal virtual {\n        unchecked {\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n    }\n\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = _allowances[owner][spender];\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance \u003e= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        uint256 accountBalance = _balances[account];\n        require(accountBalance \u003e= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n    }\n}"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Ownable {\n    address private _owner;\n\n    constructor () {\n        _owner = msg.sender;\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        _owner = newOwner;\n    }\n}"},"RY.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./ERC20StandardToken.sol\";\nimport \"./Ownable.sol\";\n\ncontract RY is ERC20StandardToken, Ownable {\n\n    mapping (address =\u003e bool) public isWhitelist;\n    bool isOpen = false;\n\n    constructor(string memory symbol_, string memory name_, uint8 decimals_, uint256 totalSupply_) ERC20StandardToken(symbol_, name_, decimals_, totalSupply_) {\n        \n    }\n\n    function setWhitelist(address a, bool b) external onlyOwner {\n        isWhitelist[a] = b;\n    }\n\n    function open() external onlyOwner {\n        isOpen = true;\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length \u003e 0;\n    }\n\n    function _transfer(address from, address to, uint256 amount) internal override {\n        if(!isOpen \u0026\u0026 balanceOf(to) == 0 \u0026\u0026 isContract(to)) {\n            require(isWhitelist[from], \"invaild\");\n        }\n        super._transfer(from, to, amount);\n    }\n}"}}