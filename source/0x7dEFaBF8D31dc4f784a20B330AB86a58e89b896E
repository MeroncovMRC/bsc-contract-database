{"AddressUtils.sol":{"content":"pragma solidity \u003e=0.4.24;\n\n/**\n * @dev Utility library of inline functions on addresses.\n */\nlibrary AddressUtils {\n  /**\n   * @dev Returns whether the target address is a contract.\n   * @param _addr Address to check.\n   */\n  function isContract(address _addr) internal view returns (bool) {\n    uint256 size;\n\n    /**\n     * XXX Currently there is no better way to check if there is a contract in an address than to\n     * check the size of the code at that address.\n     * See https://ethereum.stackexchange.com/a/14016/36603 for more details about how this works.\n     * TODO: Check this again before the Serenity release, because all addresses will be\n     * contracts then.\n     */\n    assembly {\n      size := extcodesize(_addr)\n    } // solium-disable-line security/no-inline-assembly\n    return size \u003e 0;\n  }\n\n  function isZeroAddress(address _addr) internal pure returns (bool) {\n    return _addr == address(0);\n  }\n\n  // 使用toString，因为js重载导致无法正常执行\n  function getString(address _addr) internal pure returns (string memory) {\n    bytes32 value = bytes32(uint256(_addr));\n    bytes memory alphabet = \"0123456789abcdef\";\n\n    bytes memory str = new bytes(42);\n    str[0] = \"0\";\n    str[1] = \"x\";\n    for (uint256 i = 0; i \u003c 20; i++) {\n      str[2 + i * 2] = alphabet[uint256(uint8(value[i + 12] \u003e\u003e 4))];\n      str[3 + i * 2] = alphabet[uint256(uint8(value[i + 12] \u0026 0x0f))];\n    }\n\n    return string(str);\n  }\n\n  function fromString(address _addr, string memory _str)\n    internal\n    pure\n    returns (address)\n  {\n    bytes memory b = bytes(_str);\n\n    uint256 result = 0;\n    for (uint256 i = 0; i \u003c b.length; i++) {\n      uint256 c = uint256(uint8(b[i]));\n      if (c \u003e= 48 \u0026\u0026 c \u003c= 57) {\n        result = result * 16 + (c - 48);\n      }\n      if (c \u003e= 65 \u0026\u0026 c \u003c= 90) {\n        result = result * 16 + (c - 55);\n      }\n      if (c \u003e= 97 \u0026\u0026 c \u003c= 122) {\n        result = result * 16 + (c - 87);\n      }\n    }\n\n    return address(result);\n  }\n}\n"},"Administrative.sol":{"content":"pragma solidity \u003e=0.4.24;\n\n/**\n@dev Administrative 为合约提供控制权限，可以通过继承该合约的方式获得这些功能\n`onlyOwner` 这样的 modifier 可以在合约中使用，通常用来表达所有权\n`onlyAdministrator` 用来表达运行经营权力，和所有权分开，这样的设计可以满足项目资产拥有者和经营者进行区分的场合\n无论是拥有者还是经营者，都可以是一个多签名的合约钱包，用投票方式决定权利的转移\n建议使用的场景：\n1. 拥有者是最后的裁决者，可以决定经营者和拥有者任免，也能决定合约自杀后的资金转移\n2. 经营者可以就业务中各种情况进行决策，根据授权决定资金转移和经营者变更\n */\ncontract Administrative {\n  address private _owner;\n  address private _admin;\n\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n  event AdministratorTransferred(\n    address indexed previousAdmin,\n    address indexed newAdmin\n  );\n\n  /**\n  @dev 初始化合约时，部署合约的账户自动成为owner\n   */\n  constructor() public {\n    _owner = msg.sender;\n    _admin = msg.sender;\n    emit OwnershipTransferred(address(0), _owner);\n    emit AdministratorTransferred(address(0), _admin);\n  }\n\n  modifier onlyOwner() {\n    require(msg.sender == _owner, \"only owner can modify this\");\n    _;\n  }\n\n  modifier onlyAdministrator {\n    require(msg.sender == _admin, \"only administrator can modify this\");\n    _;\n  }\n\n  modifier onlyPrivileged() {\n    require(\n      (msg.sender == _owner) || (msg.sender == _admin),\n      \"only owner or administrator can modify this\"\n    );\n    _;\n  }\n\n  /**\n  @dev 放弃合约的所有权，注意，合约没有任何人可以拥有了，那么很多拥有者应该有的能力，都不能访问了\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipTransferred(_owner, address(0));\n    _owner = address(0);\n  }\n\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0), \"Can not transfer owner to zero address\");\n    emit OwnershipTransferred(_owner, newOwner);\n    _owner = newOwner;\n  }\n\n  function transferAdministrator(address newAdmin) public onlyPrivileged {\n    require(\n      newAdmin != address(0),\n      \"Can not transfer administrator to zero address\"\n    );\n    emit AdministratorTransferred(_admin, newAdmin);\n    _admin = newAdmin;\n  }\n\n  function owner() public view returns (address) {\n    return _owner;\n  }\n\n  function admin() public view returns (address) {\n    return _admin;\n  }\n}\n"},"ERC20Factory.sol":{"content":"pragma solidity \u003e=0.4.24;\n\nimport \"./SafeMath.sol\";\nimport \"./AddressUtils.sol\";\nimport \"./Payload.sol\";\nimport \"./Administrative.sol\";\nimport \"./IExtendedERC20.sol\";\n\n/**\n * ERC 20 token\n * 通用的ERC20合约，创建时指定通证名称，数量，精度以及是否可铸币\n * 当minable为false, 该合约的总供给量固定不变，不可修改\n * 当minable为true, totalSupply参数为铸币的上限，函数totalSupply返回实际已发行的数量\n * https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20Factory is Administrative, IExtendedERC20, Payload {\n  using SafeMath for uint256;\n  using AddressUtils for address;\n\n  mapping(address =\u003e uint256) _balances;\n\n  mapping(address =\u003e mapping(address =\u003e uint256)) _allowed;\n\n  bool _minable;\n  uint8 private _decimals;\n  uint256 private _totalSupply;\n  uint256 private _maxSupply;\n  string private _name;\n  string private _symbol;\n\n  //constructor\n  constructor(\n    string memory name,\n    string memory symbol,\n    uint8 decimals,\n    uint256 totalSupply,\n    bool minable\n  ) public Administrative() {\n    _name = name;\n    _symbol = symbol;\n    _decimals = decimals;\n    _maxSupply = totalSupply * 10**uint256(decimals);\n    _minable = minable;\n\n    if (_minable) {\n      _totalSupply = 0;\n    } else {\n      // 初始化时所有token都发送到owner\n      _totalSupply = _maxSupply;\n      _balances[owner()] = _totalSupply;\n      emit Transfer(address(0), owner(), _totalSupply);\n    }\n  }\n\n  function name() public view returns (string memory) {\n    return _name;\n  }\n\n  function symbol() public view returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n  不是所有的ERC20都遵循uint8，比如USDT是uint256，对于不同类型，需要做转换\n   */\n  function decimals() public view returns (uint8) {\n    return _decimals;\n  }\n\n  function totalSupply() public view returns (uint256) {\n    return _totalSupply;\n  }\n\n  function balanceOf(address _who) public view returns (uint256) {\n    return _balances[_who];\n  }\n\n  function allowance(address _owner, address _spender)\n    public\n    view\n    returns (uint256)\n  {\n    return _allowed[_owner][_spender];\n  }\n\n  function approve(address _spender, uint256 _value)\n    public\n    onlyPayloadSize(2 * 32)\n    returns (bool)\n  {\n    // 检查设置数量和允许数量，防止重入修改\n    require(\n      (_value == 0) || (_allowed[msg.sender][_spender] == 0),\n      \"check value not equal zero\"\n    );\n\n    /**\n    不检查value和maxSupply是因为可以授权一个很大的数字，用户可以在业务中反复流转多次\n     */\n    _allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n\n    return true;\n  }\n\n  function _transfer(\n    address from,\n    address to,\n    uint256 value\n  ) internal {\n    require(!to.isZeroAddress(), \"can not send to zero account\");\n    require(value \u003c= _maxSupply, \"More than total supply\");\n    require(_balances[from] \u003e= value, \"Not enough value\");\n\n    _balances[from] = _balances[from].sub(value);\n    _balances[to] = _balances[to].add(value);\n\n    emit Transfer(from, to, value);\n  }\n\n  function transfer(address _to, uint256 _value)\n    public\n    onlyPayloadSize(2 * 32)\n    returns (bool)\n  {\n    _transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  ) public onlyPayloadSize(3 * 32) returns (bool) {\n    require(_allowed[_from][msg.sender] \u003e= _value, \"Not enough value\");\n\n    _allowed[_from][msg.sender] = _allowed[_from][msg.sender].sub(_value);\n    _transfer(_from, _to, _value);\n\n    return true;\n  }\n\n  function increaseAllowance(address _spender, uint256 _addedValue)\n    public\n    onlyPayloadSize(2 * 32)\n    returns (bool)\n  {\n    require(!_spender.isZeroAddress(), \"can not send to zero account\");\n\n    _allowed[msg.sender][_spender] = _allowed[msg.sender][_spender].add(\n      _addedValue\n    );\n    emit Approval(msg.sender, _spender, _allowed[msg.sender][_spender]);\n\n    return true;\n  }\n\n  function decreaseAllowance(address _spender, uint256 _subtractedValue)\n    public\n    onlyPayloadSize(2 * 32)\n    returns (bool)\n  {\n    require(!_spender.isZeroAddress(), \"can not send to zero account\");\n\n    _allowed[msg.sender][_spender] = _allowed[msg.sender][_spender].sub(\n      _subtractedValue\n    );\n    emit Approval(msg.sender, _spender, _allowed[msg.sender][_spender]);\n\n    return true;\n  }\n\n  function mint(address account, uint256 value)\n    public\n    onlyPrivileged\n    onlyPayloadSize(2 * 32)\n    returns (bool)\n  {\n    require(!account.isZeroAddress(), \"can not send to zero account\");\n    require(_minable, \"minable must be true\");\n    require(_totalSupply.add(value) \u003c= _maxSupply, \"More than total supply\");\n\n    _totalSupply = _totalSupply.add(value);\n    _balances[account] = _balances[account].add(value);\n\n    emit Mint(account, value);\n    emit Transfer(address(0), account, value);\n\n    return true;\n  }\n\n  function burn(address account, uint256 value)\n    public\n    onlyPrivileged\n    onlyPayloadSize(2 * 32)\n    returns (bool)\n  {\n    require(!account.isZeroAddress(), \"can not send to zero account\");\n    require(_minable, \"minable must be true\");\n    require(_totalSupply \u003e= value, \"More than total supply\");\n\n    _totalSupply = _totalSupply.sub(value);\n    _balances[account] = _balances[account].sub(value);\n\n    emit Burn(account, value);\n    emit Transfer(account, address(0), value);\n\n    return true;\n  }\n\n  // fallback function\n  function() external {\n    require(false, \"never receive fund.\");\n  }\n\n  // only owner can kill\n  function kill() public {\n    if (msg.sender == owner()) selfdestruct(msg.sender);\n  }\n}\n"},"IExtendedERC20.sol":{"content":"pragma solidity \u003e=0.4.24;\n\n/**\nIExtendedERC20 对ERC20标准扩展的一个接口定义\n */\ninterface IExtendedERC20 {\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address who) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n    external\n    view\n    returns (uint256);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n\n  function increaseAllowance(address spender, uint256 addedValue)\n    external\n    returns (bool);\n\n  function decreaseAllowance(address spender, uint256 subtractedValue)\n    external\n    returns (bool);\n\n  function mint(address account, uint256 value) external returns (bool);\n\n  function burn(address account, uint256 value) external returns (bool);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  event Mint(address indexed account, uint256 value);\n\n  event Burn(address indexed account, uint256 value);\n}\n"},"Payload.sol":{"content":"pragma solidity \u003e=0.4.24;\n\n/**\n@dev 检测payload共通\n */\ncontract Payload {\n  modifier onlyPayloadSize(uint256 size) {\n    require(msg.data.length \u003e= size + 4, \"payload size invaild\");\n    _;\n  }\n}\n"},"SafeMath.sol":{"content":"pragma solidity \u003e=0.4.24;\n\n/**\n * @dev Math operations with safety checks that throw on error. This contract is based\n * on the source code at https://goo.gl/iyQsmU.\n */\nlibrary SafeMath {\n  /**\n   * @dev Multiplies two numbers, throws on overflow.\n   * @param _a Factor number.\n   * @param _b Factor number.\n   */\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    if (_a == 0) {\n      return 0;\n    }\n    uint256 c = _a * _b;\n    assert(c / _a == _b);\n    return c;\n  }\n\n  /**\n   * @dev Integer division of two numbers, truncating the quotient.\n   * @param _a Dividend number.\n   * @param _b Divisor number.\n   */\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    uint256 c = _a / _b;\n    // assert(b \u003e 0); // Solidity automatically throws when dividing by 0\n    // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n    return c;\n  }\n\n  /**\n   * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n   * @param _a Minuend number.\n   * @param _b Subtrahend number.\n   */\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    assert(_b \u003c= _a);\n    return _a - _b;\n  }\n\n  /**\n   * @dev Adds two numbers, throws on overflow.\n   * @param _a Number.\n   * @param _b Number.\n   */\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    uint256 c = _a + _b;\n    assert(c \u003e= _a);\n    return c;\n  }\n\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0, \"can not mod zero\");\n    return a % b;\n  }\n}\n"}}