{"library.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.12;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev returns the decimal of this ERC20 contract\n     */\n    function decimals() external view returns (uint8);\n    \n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\u0027s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.3._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.3._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \u0027safeIncreaseAllowance\u0027 and \u0027safeDecreaseAllowance\u0027\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\u0027s return data size checking mechanism, since\n        // we\u0027re implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\nlibrary Strings {\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI\u0027s implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        uint256 index = digits - 1;\n        temp = value;\n        while (temp != 0) {\n            buffer[index--] = byte(uint8(48 + temp % 10));\n            temp /= 10;\n        }\n        return string(buffer);\n    }\n}\n\ninterface AggregatorV3Interface {\n\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n\n\n// CDF data contact interface\nabstract contract CDFDataInterface {\n    mapping (uint =\u003e uint24[]) public CDF;\n    uint16[] public Durations;\n    uint public Amplifier;\n    function numDurations() external view virtual returns (uint);\n}\n\ninterface IOption is IERC20 {\n    function resetOption(uint strikePrice_, uint newSupply) external;\n    function name() external view returns (string memory);\n    // previous rounds\n    function getRoundExpiryDate(uint r) external view returns(uint);\n    function getRoundStrikePrice(uint r) external view returns(uint);\n    function getRoundSettlePrice(uint r) external view returns(uint);\n    function getRoundTotalPremiums(uint r) external view returns(uint);\n    function getRoundAccountPaidPremiums(uint r, address account) external view returns(uint);\n    function getRoundBalanceOf(uint r, address account) external view returns (uint256);\n    function getRoundAccPremiumShare(uint r) external view returns(uint);\n    function setRoundAccPremiumShare(uint r, uint premiumShare) external;\n    function getUnclaimedProfitsRound(address account) external view returns (uint);\n    function setUnclaimedProfitsRound(uint r, address account) external;\n    function getSettledRound(address account) external view returns (uint);\n    function setSettledRound(uint r, address account) external;\n\n    // current round\n    function addPremium(address account, uint256 amountUSDT) external;\n    function totalPremiums() external view returns (uint);\n    function expiryDate() external view returns (uint);\n    function strikePrice() external view returns (uint);\n    function getRound() external view returns (uint);\n    function getDuration() external view returns (uint);\n    function getPool() external view returns (address);\n}\n\n\ninterface IPoolerToken is IERC20 {\n    function mint(address account, uint256 amount) external;\n    function burn(address account, uint256 amount) external;\n    function getPool() external view returns (address);\n}\n\ninterface IOptionPool {\n    function name() external view returns (string memory);\n    function owner() external view returns (address);\n    function transferOwnership(address newOwner) external;\n    function pausePooler() external;\n    function unpausePooler() external;\n    function pauseBuyer() external;\n    function unpauseBuyer() external;\n    function settlePooler(address account) external;\n    function settleBuyer(address account) external;\n    function update() external;\n    function optionsLeft(IOption optionContract) external view returns (uint256 left, uint round);\n    function buy(uint amount, IOption optionContract, uint round) external;\n    function premiumCost(uint amount, IOption optionContract) external view returns(uint);\n    function listOptions() external view returns (IOption []memory);\n    function currentUtilizationRate() external view returns (uint256);\n    function adjustSigma(uint16 newSigma) external;\n    function NWA() external view returns (uint);\n    function claimPremium() external;\n    function claimOPA() external;\n    function claimProfits() external;\n    function checkOPA(address account) external view returns(uint256 opa);\n    function checkPremium(address account) external view returns (uint256 premium);\n    function checkProfits(address account) external view returns (uint256 profits);\n    function setUtilizationRate(uint8 rate) external;\n    function setMaxUtilizationRate(uint8 maxrate) external;\n    function setRefreshPeriod(uint period) external;\n    function getNextUpdateTime() external view returns (uint);\n            \n    /**\n     * @dev deposit event\n     */\n    event Deposit(address indexed account, uint amount);\n    \n    /**\n     * @dev withdraw event\n     */\n    event Withdraw(address indexed account, uint amount);\n    \n    /**\n     * @dev option buy Log\n     */\n    event Buy(address indexed account, address indexed optionContract, uint round, uint amount, uint premiumCost);\n\n    /**\n     * @dev Profits Claiming log\n     */\n    event ProfitsClaim(address indexed account, uint amount);\n     \n    /**\n     * @dev Profits Settle log\n     */\n    event ProfitsSettled(address indexed account, address indexed optionContract, uint round, uint profitsSettled);\n\n    /**\n     * @dev Premium Claiming log\n     */\n    event PremiumClaim(address indexed account, uint amount);\n    \n    /**\n     * @dev OPA Claiming log\n     */\n    event OPAClaimed(address indexed account, uint amount);\n     \n    /**\n     * @dev Premium Settle log\n     */\n    event PremiumSettled(address indexed account, uint accountCollateral, uint premiumSettled);\n    \n    /**\n     * @dev ownership transfer event log\n     */\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n}\n\n\ninterface IPandaFactory {\n    function createOption(uint duration_, uint8 decimals_, IOptionPool poolContract) external returns (IOption option);\n    function createPoolerToken(uint8 decimals_, IOptionPool poolContract) external returns (IPoolerToken poolerToken);\n    function getCDF() external view returns(address);\n    function getUSDTContract() external view returns(address);\n}\n\n\ninterface IVesting {\n    /**\n     * @dev pool contract vest some OPA token for an account\n     */\n    function vest(address account, uint amount) external;\n}"},"staking.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.12;\n\nimport \"library.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n/**\n * @dev Option Panda Staking Contract for LP token \u0026 OPA token\n */\ncontract Staking is Ownable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n    \n    uint256 internal constant SHARE_MULTIPLIER = 1e18; // share multiplier to avert division underflow\n    \n    IERC20 public AssetContract; // the asset to stake\n    IERC20 public OPAContract; // the OPA token contract\n    address public rewardAccount = 0x38A09Ec80aA2c5fc6E92a65E98a4e43e4dAb53b4; // OPA reward account\n\n    mapping (address =\u003e uint256) private _balances; // tracking staker\u0027s value\n    mapping (address =\u003e uint256) internal _opaBalance; // tracking staker\u0027s claimable OPA tokens\n    uint256 private _totalStaked; // track total staked value\n\n    /// @dev initial block reward\n    uint256 public OPABlockReward = 0;\n\n    /// @dev round index mapping to accumulate share.\n    mapping (uint =\u003e uint) private _opaAccShares;\n    /// @dev mark staker\u0027s highest settled OPA round.\n    mapping (address =\u003e uint) private _settledOPARounds;\n    /// @dev a monotonic increasing OPA round index, STARTS FROM 1\n    uint256 private _currentOPARound = 1;\n    // @dev last OPA reward block\n    uint256 private _lastRewardBlock = block.number;\n    \n    constructor(IERC20 opaContract, IERC20 assetContract) public {\n        AssetContract = assetContract; \n        OPAContract = opaContract;\n    }\n    \n    /**\n     * @notice set OPA transfer account\n     */\n    function setOPARewardAccount(address rewardAccount_) external onlyOwner {\n        rewardAccount = rewardAccount_;\n    }\n\n    /**\n     * @dev stake some assets\n     */\n    function stake(uint256 amount) external {\n        // settle previous rewards\n        settleStaker(msg.sender);\n        \n        // transfer asset from AssetContract\n        AssetContract.safeTransferFrom(msg.sender, address(this), amount);\n        _balances[msg.sender] += amount;\n        _totalStaked += amount;\n    }\n    \n    /**\n     * @dev claim rewards only\n     */\n    function claimRewards() external {\n        // settle previous rewards\n        settleStaker(msg.sender);\n        \n        // OPA balance modification\n        uint amountOPA = _opaBalance[msg.sender];\n        delete _opaBalance[msg.sender]; // zero OPA balance\n\n        // transfer OPA to sender\n        OPAContract.safeTransferFrom(rewardAccount, msg.sender, amountOPA);\n    }\n    \n    /**\n     * @dev withdraw the staked assets\n     */\n    function withdraw(uint256 amount) external {\n        require(amount \u003c= _balances[msg.sender], \"balance exceeded\");\n\n        // settle previous rewards\n        settleStaker(msg.sender);\n\n        // modifiy\n        _balances[msg.sender] -= amount;\n        _totalStaked -= amount;\n        \n        // transfer assets back\n        AssetContract.safeTransfer(msg.sender, amount);\n    }\n    \n    /**\n     * @dev return value staked for an account\n     */\n    function numStaked(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev return total staked value\n     */\n    function totalStaked() external view returns (uint256) {\n        return _totalStaked;\n    }\n    \n    /**\n     * @notice sum unclaimed OPA;\n     */\n    function checkReward(address account) external view returns(uint256 opa) {\n        uint accountCollateral = _balances[account];\n        uint lastSettledOPARound = _settledOPARounds[account];\n        \n        // OPA reward = settledOPA + unsettledOPA + newMinedOPA\n        uint unsettledOPAShare = _opaAccShares[_currentOPARound-1].sub(_opaAccShares[lastSettledOPARound]);\n        \n        uint newMinedOPAShare;\n        if (_totalStaked \u003e 0) {\n            uint blocksToReward = block.number.sub(_lastRewardBlock);\n            uint mintedOPA = OPABlockReward.mul(blocksToReward);\n    \n            // OPA share\n            newMinedOPAShare = mintedOPA.mul(SHARE_MULTIPLIER)\n                                        .div(_totalStaked);\n        }\n        \n        return _opaBalance[account] + (unsettledOPAShare + newMinedOPAShare).mul(accountCollateral)\n                                            .div(SHARE_MULTIPLIER);  // remember to div by SHARE_MULTIPLIER;\n    }\n    \n    /**\n     * @dev set OPA reward per height\n     */\n    function setOPAReward(uint256 reward) external onlyOwner {\n        // settle previous rewards\n        updateOPAReward();\n        // set new block reward\n        OPABlockReward = reward;\n    }\n    \n    /**\n     * @dev settle a staker\n     */\n    function settleStaker(address account) internal {\n        // update OPA reward snapshot\n        updateOPAReward();\n        \n        // settle this account\n        uint accountCollateral = _balances[account];\n        uint lastSettledOPARound = _settledOPARounds[account];\n        uint newSettledOPARound = _currentOPARound - 1;\n        \n        // round OPA\n        uint roundOPA = _opaAccShares[newSettledOPARound].sub(_opaAccShares[lastSettledOPARound])\n                                .mul(accountCollateral)\n                                .div(SHARE_MULTIPLIER);  // remember to div by SHARE_MULTIPLIER    \n        \n        // update OPA balance\n        _opaBalance[account] += roundOPA;\n        \n        // mark new settled OPA round\n        _settledOPARounds[account] = newSettledOPARound;\n    }\n     \n     /**\n     * @dev update accumulated OPA block reward until current block\n     */\n    function updateOPAReward() internal {\n        // skip round changing in the same block\n        if (_lastRewardBlock == block.number) {\n            return;\n        }\n    \n        // postpone OPA rewarding if there is none staker\n        if (_totalStaked == 0) {\n            return;\n        }\n\n        // settle OPA share for [_lastRewardBlock, block.number]\n        uint blocksToReward = block.number.sub(_lastRewardBlock);\n        uint mintedOPA = OPABlockReward.mul(blocksToReward);\n\n        // OPA share\n        uint roundOPAShare = mintedOPA.mul(SHARE_MULTIPLIER)\n                                    .div(_totalStaked);\n                                \n        // mark block rewarded;\n        _lastRewardBlock = block.number;\n            \n        // accumulate OPA share\n        _opaAccShares[_currentOPARound] = roundOPAShare.add(_opaAccShares[_currentOPARound-1]); \n       \n        // next round setting                                 \n        _currentOPARound++;\n    }\n}"}}