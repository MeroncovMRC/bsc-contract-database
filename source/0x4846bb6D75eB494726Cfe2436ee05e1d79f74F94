/**
 *Submitted for verification at BscScan.com on 2023-04-10
*/

/**
 *Submitted for verification at BscScan.com on 2023-03-27
*/

// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;
interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);

    function approve(address spender, uint256 value) external returns (bool);

    function transferFrom(address from, address to, uint256 value) external returns (bool);

    function totalSupply() external view returns (uint256);

    function balanceOf(address who) external view returns (uint256);

    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(address indexed owner, address indexed spender, uint256 value);
}

library SafeMath {
    /**

    * @dev Multiplies two unsigned integers, reverts on overflow.

    */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522

        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;

        require(c / a == b);

        return c;
    }

    /**

    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.

    */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0

        require(b > 0);

        uint256 c = a / b;

        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**

    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).

    */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);

        uint256 c = a - b;

        return c;
    }

    /**

    * @dev Adds two unsigned integers, reverts on overflow.

    */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;

        require(c >= a);

        return c;
    }

    /**

    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),

    * reverts when dividing by zero.

    */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);

        return a % b;
    }
}

contract Ownable   {
    address private _owner;

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    /**

     * @dev Initializes the contract setting the deployer as the initial owner.

     */

    constructor()  {
        _owner = msg.sender;

        emit OwnershipTransferred(address(0), _owner);
    }

    /**

     * @dev Returns the address of the current owner.

     */

    function owner() public view returns (address) {
        return _owner;
    }

    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {
        require(_owner == msg.sender, "Ownable: caller is not the owner");

        _;
    }

    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address newOwner) public onlyOwner {
        require(
            newOwner != address(0),
            "Ownable: new owner is the zero address"
        );

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;
    }
}


contract BEPStaking is Ownable{
    using SafeMath for uint256;
     IERC20 public token;
     IERC20 public usdt;
     uint256 year=365;
   

    struct userInfo {
        uint256 DepositeToken;
        uint256 lastUpdated;
        uint256 lockableDays;
        uint256 WithdrawReward;
        uint256 WithdrawAbleReward;
        uint256 depositeTime;
        uint256 WithdrawDepositeAmount;
    }
    
     event Deposite_(address indexed to,address indexed From, uint256 amount, uint256 day,uint256 time);

    
    mapping(uint256 => uint256) public allocation;
    mapping(address => uint256[] ) public depositedARB;
    mapping(address => uint256[] ) public lockabledays;
    mapping(address => uint256[] ) public depositetime;   
    mapping(address =>  userInfo) public Users;
    mapping(address => bool) public refferalStatus;
    address public deadAddress = 0x000000000000000000000000000000000000dEaD;
  
    uint256 public RefferalReward = 5e18;
    uint256 public time = 1 days;

    constructor( IERC20 _usdtAddr,IERC20 _tokenaddr )  {
         token=_tokenaddr;
         usdt = _usdtAddr;
        allocation[45]=986301370000000000; //8 apy %
        allocation[90] = 5e18; //20 apy  %
        allocation[150] = 12328767000000000000; //30 apy %
        allocation[220] = 24109589000000000000; //40 apy %
        allocation[290] = 39726027000000000000; //50 apy %
        allocation[365] = 60e18; //60 apy%
         
    }
    receive() external payable {
     
    }

    function farm( uint256 _lockableDays , address refferal ,uint256 amount ) public  
    {
        if (_lockableDays ==365){
           require(amount>=500e18,"enter minimum amount");
        }
        if (_lockableDays ==290){
           require(amount>=250e18,"enter minimum amount");
        }
        if (_lockableDays ==220){
           require(amount>=100e18,"enter minimum amount");
        }
        if (_lockableDays ==150){
           require(amount>=100e18,"enter minimum amount");
        }
        if (_lockableDays ==90){
           require(amount>=50e18,"enter minimum amount");
        }
        if (_lockableDays ==45){
           require(amount>=10e18,"enter minimum amount");
        }
       
        require(allocation[_lockableDays] > 0, "Invalid day selection");
         if (refferal != deadAddress && _lockableDays >=150) {
            require(
                refferalStatus[refferal] == true,
                "please enter correct refferal"
            );
            token.transfer(refferal, RefferalReward);
        }
        token.transferFrom(msg.sender , address(this), amount);
        refferalStatus[msg.sender] = true;
        depositedARB[msg.sender].push(amount);
        depositetime[msg.sender].push(uint40(block.timestamp));
        Users[msg.sender].DepositeToken += amount;
        lockabledays[msg.sender].push(_lockableDays);
        emit Deposite_(msg.sender,address(this),amount,_lockableDays,block.timestamp);
    }
    



        function pendindRewards(address _add) public view returns(uint256 reward)
    {
        uint256 Reward;
        for(uint256 z=0 ; z< depositedARB[_add].length;z++){
        uint256 lockTime = depositetime[_add][z]+(lockabledays[_add][z]*time);
        if(block.timestamp > lockTime ){
        reward = (allocation[lockabledays[_add][z]].mul(depositedARB[_add][z]).div(100)).div(1e18);
        Reward += reward;
        }
    }
    return Reward;
    }

  
    
    
    function harvest(uint256 [] memory _index) public 
    {
          for(uint256 z=0 ; z< _index.length;z++){
              
        require( Users[msg.sender].DepositeToken > 0, " Deposite not ");
        
        uint256 lockTime =depositetime[msg.sender][_index[z]]+(lockabledays[msg.sender][_index[z]].mul(time));
        require(block.timestamp > lockTime,"unstake time not reached!");
        uint256 reward = (allocation[lockabledays[msg.sender][_index[z]]].mul(depositedARB[msg.sender][_index[z]]).div(100)).div(1e18);
        
        Users[msg.sender].WithdrawAbleReward += reward;
        Users[msg.sender].DepositeToken -= depositedARB[msg.sender][_index[z]];
        Users[msg.sender].WithdrawDepositeAmount += depositedARB[msg.sender][_index[z]];
        depositedARB[msg.sender][_index[z]] = 0;
        lockabledays[msg.sender][_index[z]] = 0;
        depositetime[msg.sender][_index[z]] = 0;
  
    }
            for(uint256 t=0 ; t< _index.length;t++){
            for(uint256 i = _index[t]; i <  depositedARB[msg.sender].length - 1; i++) 
        {
            depositedARB[msg.sender][i] = depositedARB[msg.sender][i + 1];
            lockabledays[msg.sender][i] = lockabledays[msg.sender][i + 1];
            depositetime[msg.sender][i] = depositetime[msg.sender][i + 1];
        }
          depositedARB[msg.sender].pop();
          lockabledays[msg.sender].pop();
          depositetime[msg.sender].pop();
    }
             uint256 totalwithdrawAmount;
             
             totalwithdrawAmount = Users[msg.sender].WithdrawDepositeAmount;
             uint256 totalwithdrawReward=Users[msg.sender].WithdrawAbleReward;
             usdt.transfer(msg.sender,totalwithdrawReward);
             token.transfer(msg.sender,totalwithdrawAmount);
             Users[msg.sender].WithdrawReward =Users[msg.sender].WithdrawReward.add(Users[msg.sender].WithdrawAbleReward );
             Users[msg.sender].WithdrawAbleReward =0;
             Users[msg.sender].WithdrawDepositeAmount = 0;
         
    }
 
    
    function UserInformation(address _add) public view returns(uint256 [] memory , uint256 [] memory,uint256 [] memory){
        return(depositedARB[_add],lockabledays[_add],depositetime[_add]);
    }
 
 
    function emergencyWithdraw(IERC20  _tokenaddr,uint256 _token) external onlyOwner {
         _tokenaddr.transfer(msg.sender, _token);
    }
    function emergencyWithdrawARB(uint256 Amount) external onlyOwner {
        payable(msg.sender).transfer(Amount);
    }

    function changetimeCal(uint256 _time) external onlyOwner{
        time=_time;
    }
    function changePercentages(uint256 _45dayspercent,uint256 _90dayspercent,uint256 _150dayspercent,uint256 _220dayspercent,uint256 _290dayspercent,uint256 _365dayspercent) external onlyOwner{
        allocation[45]=_45dayspercent;
        allocation[90] = _90dayspercent;
        allocation[150] = _150dayspercent;
        allocation[220] = _220dayspercent;
        allocation[290] = _290dayspercent;
        allocation[365] = _365dayspercent;
    }
    

    
}