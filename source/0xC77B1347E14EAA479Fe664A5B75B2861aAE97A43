{"Address.sol":{"content":"pragma solidity ^0.6.12;\n// SPDX-License-Identifier: Unlicensed\n\nlibrary Address {\n\tfunction isContract(address account) internal view returns (bool) {\n\t\t// According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\t\t// and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\t\t// for accounts without code, i.e. `keccak256(\u0027\u0027)`\n\t\tbytes32 codehash;\n\t\tbytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\t\t// solhint-disable-next-line no-inline-assembly\n\t\tassembly { codehash := extcodehash(account) }\n\t\treturn (codehash != accountHash \u0026\u0026 codehash != 0x0);\n\t}\n\n\tfunction sendValue(address payable recipient, uint256 amount) internal {\n\t\trequire(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n \n\t\t// solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n\t\t(bool success, ) = recipient.call{ value: amount }(\"\");\n\t\trequire(success, \"Address: unable to send value, recipient may have reverted\");\n\t}\n\n\tfunction functionCall(address target, bytes memory data) internal returns (bytes memory) {\n\t\treturn functionCall(target, data, \"Address: low-level call failed\");\n\t}\n\n\tfunction functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n\t\treturn _functionCallWithValue(target, data, 0, errorMessage);\n\t}\n\n\tfunction functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n\t\treturn functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n\t}\n\n\tfunction functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n\t\trequire(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n\t\treturn _functionCallWithValue(target, data, value, errorMessage);\n\t}\n\n\tfunction _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n\t\trequire(isContract(target), \"Address: call to non-contract\");\n\n\t\t// solhint-disable-next-line avoid-low-level-calls\n\t\t(bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n\t\tif (success) {\n\t\t\treturn returndata;\n\t\t} else {\n\t\t\t// Look for revert reason and bubble it up if present\n\t\t\tif (returndata.length \u003e 0) {\n\t\t\t\t// The easiest way to bubble the revert reason is using memory via assembly\n\t\t\t\t// solhint-disable-next-line no-inline-assembly\n\t\t\t\tassembly {\n\t\t\t\t\tlet returndata_size := mload(returndata)\n\t\t\t\t\trevert(add(32, returndata), returndata_size)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trevert(errorMessage);\n\t\t\t}\n\t\t}\n\t}\n}\n"},"AutomationCompatibleInterface.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.12;\r\n\r\ninterface AutomationCompatibleInterface {\r\n  /**\r\n   * @notice method that is simulated by the keepers to see if any work actually\r\n   * needs to be performed. This method does does not actually need to be\r\n   * executable, and since it is only ever simulated it can consume lots of gas.\r\n   * @dev To ensure that it is never called, you may want to add the\r\n   * cannotExecute modifier from KeeperBase to your implementation of this\r\n   * method.\r\n   * @param checkData specified in the upkeep registration so it is always the\r\n   * same for a registered upkeep. This can easily be broken down into specific\r\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\r\n   * same contract and easily differentiated by the contract.\r\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\r\n   * performUpkeep or not.\r\n   * @return performData bytes that the keeper should call performUpkeep with, if\r\n   * upkeep is needed. If you would like to encode data to decode later, try\r\n   * `abi.encode`.\r\n   */\r\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\r\n\r\n  /**\r\n   * @notice method that is actually executed by the keepers, via the registry.\r\n   * The data returned by the checkUpkeep simulation will be passed into\r\n   * this method to actually be executed.\r\n   * @dev The input to this method should not be trusted, and the caller of the\r\n   * method should not even be restricted to any single registry. Anyone should\r\n   * be able call it, and the input should be validated, there is no guarantee\r\n   * that the data passed in is the performData returned from checkUpkeep. This\r\n   * could happen due to malicious keepers, racing keepers, or simply a state\r\n   * change while the performUpkeep transaction is waiting for confirmation.\r\n   * Always validate the data passed in.\r\n   * @param performData is the data which was passed back from the checkData\r\n   * simulation. If it is encoded, it can easily be decoded into other types by\r\n   * calling `abi.decode`. This data should not be trusted, and should be\r\n   * validated against the contract\u0027s current state.\r\n   */\r\n  function performUpkeep(bytes calldata performData) external;\r\n}"},"Context.sol":{"content":"pragma solidity ^0.6.12;\n// SPDX-License-Identifier: Unlicensed\n\nabstract contract Context {\n\tfunction _msgSender() internal view virtual returns (address payable) {\n\t\treturn msg.sender;\n\t}\n\n\tfunction _msgData() internal view virtual returns (bytes memory) {\n\t\tthis; // silence state mutability warning without generating bytecode - issue 2691\n\t\treturn msg.data;\n\t}\n}\n"},"Discreet.sol":{"content":"pragma solidity ^0.6.12;\n// SPDX-License-Identifier: Unlicensed\n\nimport {SafeMath} from \"./SafeMath.sol\";\nimport {Address} from \"./Address.sol\";\nimport {Context} from \"./Context.sol\";\nimport {Ownable} from \"./Ownable.sol\";\nimport {IERC20} from \"./IERC20.sol\";\n\ncontract Discreet is Context, IERC20, Ownable {\n\tusing SafeMath for uint256;\n\tusing Address for address;\n\n\tmapping (address =\u003e uint256) private _balances;\n\tmapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\n\n\tmapping (address =\u003e bool) private _functionWhitelist;\n\tmapping (address =\u003e bool) private _transferWhitelist;\n\n\taddress public devlock;\n\tuint256 public _devlockdate;\n\t\n\tuint256 private _total = 90 * 10**6 * 10**18; // 90 million\n\n\tstring private _name = \"Discreet\";\n\tstring private _symbol = \"BDIS\";\n\tuint8 private _decimals = 18;\n\n\tuint256 public preseedTokenSupply = 20 * 10**6 * 10**18;\n\tuint256 public seedTokenSupply = 20 * 10**6 * 10**18;\n\tuint256 public publicTokenSupply = 30 * 10**6 * 10**18;\n\tuint256 public teamTokenSupply = 5 * 10**6 * 10**18;\n\tuint256 public projectTokenSupply = 10 * 10**6 * 10**18;\n\tuint256 public lockedTokenSupply = 5 * 10**6 * 10**18;\n\n\tbool public _seedTokensReleased = false;\n\tbool public _publicTokensReleased = false;\n\tbool public _lockedTokensReleased = false;\n\tbool public _preseedTokensReleased = false;\n\n\taddress public _preseedContract;\t// pressed round contract; facilitate purchases\n\taddress public _seedContract;\n\taddress public _publicContract;\t\t// public round contract\n\n\tuint256 public _maxTxAmount = 10**6 * 10**18;\n\n\tmodifier onlyWhitelist() {\n\t\trequire(_functionWhitelist[_msgSender()] == true, \"Address must be whitelisted to perform this\");\n\t\t_;\n\t}\n\n\tevent Airdrop(address indexed from, uint256 numReceived, uint256 numTokens);\n\n\tconstructor (address _DEVLOCK_, address _TEAM_) public {\n\t\trequire (teamTokenSupply.add(projectTokenSupply.add(lockedTokenSupply.add(preseedTokenSupply.add(seedTokenSupply.add(publicTokenSupply))))) == _total, \"Total tokens doesn\u0027t match!\");\n\t\t_balances[_DEVLOCK_] = lockedTokenSupply;\n\t\t_balances[_TEAM_] = teamTokenSupply.add(projectTokenSupply);\n\t\t_balances[address(this)] = preseedTokenSupply.add(seedTokenSupply.add(publicTokenSupply));\n\n\t\tdevlock = _DEVLOCK_;\n\t\t_transferWhitelist[_msgSender()] = true;\n\t\t_functionWhitelist[_msgSender()] = true;\n\n\t\temit Transfer(address(0), address(this), _balances[address(this)]);\n\t\temit Transfer(address(0), _DEVLOCK_, lockedTokenSupply);\n\t\temit Transfer(address(0), _TEAM_, teamTokenSupply.add(projectTokenSupply));\n\n\t\t_devlockdate = now + 267 days;\n\t}\n\n\tfunction seedTokensReleased() public view returns (bool) {\n\t\treturn _seedTokensReleased;\n\t}\n\n\tfunction publicTokensReleased() public view returns (bool) {\n\t\treturn _publicTokensReleased;\n\t}\n\n\tfunction lockedTokensReleased() public view returns (bool) {\n\t\treturn _lockedTokensReleased;\n\t}\n\n\tfunction preseedTokensReleased() public view returns (bool) {\n\t\treturn _preseedTokensReleased;\n\t}\n\n\tfunction getPreseedTokenSupply() public view returns (uint256) {\n\t\treturn preseedTokenSupply;\n\t}\n\n\tfunction getSeedTokenSupply() public view returns (uint256) {\n\t\treturn seedTokenSupply;\n\t}\n\n\tfunction getPublicTokenSupply() public view returns (uint256) {\n\t\treturn publicTokenSupply;\n\t}\n\n\tfunction name() public view returns (string memory) {\n        return _name;\n    }\n \n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n \n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n \n    function totalSupply() public view override returns (uint256) {\n        return _total;\n    }\n \n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n \n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n \n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n \n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n \n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n \n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n \n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n\tfunction _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n \n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n\tfunction addTransferWhitelist(address addressToWhitelist) public onlyOwner() {\n\t\t_transferWhitelist[addressToWhitelist] = true;\n\t}\n\n\tfunction removeTransferWhitelist(address addressToWhitelist) public onlyOwner() {\n\t\t_transferWhitelist[addressToWhitelist] = false;\n\t}\n\n\tfunction isTransferWhitelisted(address addr) public view returns (bool) {\n\t\treturn _transferWhitelist[addr];\n\t}\n\n\tfunction addFunctionWhitelist(address addressToWhitelist) public onlyOwner() {\n\t\t_functionWhitelist[addressToWhitelist] = true;\n\t}\n\n\tfunction removeFunctionWhitelist(address addressToWhitelist) public onlyOwner() {\n\t\t_functionWhitelist[addressToWhitelist] = false;\n\t}\n\n\tfunction isFunctionWhitelisted(address addr) public view returns (bool) {\n\t\treturn _functionWhitelist[addr];\n\t}\n \n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) private {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(amount \u003e 0, \"Transfer amount must be greater than zero\");\n        if(from != owner() \u0026\u0026 to != owner() \u0026\u0026 from != address(this) \u0026\u0026 !_transferWhitelist[from])\n            require(amount \u003c= _maxTxAmount, \"Transfer amount exceeds the maxTxAmount.\");\n \n        if(from == devlock) \n            require(now \u003e= _devlockdate \u0026\u0026 _lockedTokensReleased, \"This wallet has not been unlocked.\");\n        \n\t      _balances[from] = _balances[from].sub(amount);\n\t      _balances[to] = _balances[to].add(amount);\n \n\t      emit Transfer(from, to, amount);\n    }\n \n    function launchPreseed(address preseedContract) public onlyOwner() {\n\t\trequire(_preseedTokensReleased == false, \"Preseed already launched\");\n\t\t_preseedContract = preseedContract;\n\t\t_preseedTokensReleased = true;\n\t\t_transferWhitelist[preseedContract] = true;\n\t\t_transfer(address(this), _preseedContract, preseedTokenSupply);\n\t}\n\n\tfunction launchSeed(address seedContract) public onlyOwner() {\n\t\trequire(_seedTokensReleased == false, \"Seed already launched\");\n\t\t_seedContract = seedContract;\n\t\t_seedTokensReleased = true;\n\t\t_transferWhitelist[seedContract] = true;\n\t\t_transfer(address(this), _seedContract, seedTokenSupply);\n\t}\n\n\tfunction launchPublic(address publicContract) public onlyOwner() {\n\t\trequire(_publicTokensReleased == false, \"Public already launched\");\n\t\t_publicContract = publicContract;\n\t\t_publicTokensReleased = true;\n\t\t_transferWhitelist[publicContract] = true;\n\t\t_transfer(address(this), _publicContract, publicTokenSupply);\n\t}\n\n\tfunction airdropTokens(address[] memory addresses, uint256 tokenLimit) public onlyWhitelist() {\n\t\trequire(_balances[_msgSender()] \u003e= tokenLimit, \"not enough allocated tokens for airdrop\");\n\t\tuint256 accumulator;\n\t\tfor (uint256 i = 0; i \u003c addresses.length; i++) {\n\t\t\taccumulator = accumulator.add(_balances[addresses[i]]);\n\t\t}\n\n\t\tuint256 tokensLeft = tokenLimit;\n\t\tfor (uint256 i = 0; i \u003c addresses.length; i++) {\n\t\t\tuint256 rcvamt = _balances[addresses[i]].mul(tokenLimit).div(accumulator);\n\t\t\tif (rcvamt \u003e tokensLeft) {\n\t\t\t\trcvamt = tokensLeft;\n\t\t\t}\n\t\t\t\n\t\t\tif (rcvamt == 0) continue;\n\n\t\t\ttransfer(addresses[i], rcvamt);\n\t\t\ttokensLeft = tokensLeft.sub(rcvamt);\n\t\t}\n\n\t\temit Airdrop(_msgSender(), addresses.length, tokenLimit.sub(tokensLeft));\n\t}\n\n\tfunction addToPublic(uint256 numTokens) public onlyWhitelist() {\n\t\trequire(_balances[_msgSender()] \u003e= numTokens, \"insufficient balance\");\n\t\trequire(_publicTokensReleased == false, \"public round has not began\");\n\n\t\ttransfer(address(this), numTokens);\n\t\tpublicTokenSupply = publicTokenSupply.add(numTokens);\n\t}\n\n\tfunction drainTokens() public onlyOwner() {\n\t\t// to prevent any possible issues with token locks\n\t\tif (_balances[address(this)] \u003e 0) {\n\t\t\ttransfer(address(this), _balances[address(this)]);\n\t\t}\n\t\t// just in case there are tokens in this contract\n\t\tif (address(this).balance \u003e 0) {\n\t\t\tpayable(owner()).transfer(address(this).balance);\n\t\t}\n\t}\n}\n"},"DiscreetPresale.sol":{"content":"pragma solidity ^0.6.12;\r\n// SPDX-License-Identifier: Unlicensed\r\n\r\nimport {SafeMath} from \"./SafeMath.sol\";\r\nimport {Address} from \"./Address.sol\";\r\nimport {Context} from \"./Context.sol\";\r\nimport {Ownable} from \"./Ownable.sol\";\r\nimport {Discreet} from \"./Discreet.sol\";\r\nimport {AutomationCompatibleInterface} from \"./AutomationCompatibleInterface.sol\";\r\nimport {ForeignDisTracker} from \"./ForeignDisTracker.sol\";\r\nimport {DiscreetPreseed} from \"./DiscreetPreseed.sol\";\r\n\r\ncontract DiscreetPresale is Context, Ownable, AutomationCompatibleInterface {\r\n\tusing SafeMath for uint256;\r\n\tusing Address for address;\r\n\tmapping (address =\u003e uint256) private _purchases;\r\n\tmapping (address =\u003e bool) private _functionWhitelist;\r\n\r\n\tuint256 public totalPreseedTokensToSell = 0;\r\n\tDiscreet _Discreet;\r\n\r\n\tuint256 private _preseedRate;\r\n\tuint256 public _minTokenBuy = 5 * 10**16;\r\n\tuint256 public _maxTokenBuy = 100 * 10**18;\r\n\r\n\tuint256 public preseedStartDate = 0;\r\n\tuint256 public preseedEndDate = 0;\r\n\tbool public preseedLaunched = false;\r\n\tbool private preemptEndRound = false;\r\n\r\n\tbool public _replicateState = false;\r\n\tForeignDisTracker _ForeignDis;\r\n\r\n\tevent TokenSaleBuy(address indexed buyer, uint256 amount);\r\n\r\n\tmodifier onlyWhitelist() {\r\n\t\trequire(_functionWhitelist[_msgSender()] == true, \"Address must be whitelisted to perform this\");\r\n\t\t_;\r\n\t}\r\n\r\n\tconstructor (address _discreet, address _foreignistracker, address _migrate) public {\r\n\t\t_Discreet = Discreet(_discreet);\r\n\t\t_ForeignDis = ForeignDisTracker(_foreignistracker);\r\n\t\ttotalPreseedTokensToSell = _Discreet.getPreseedTokenSupply();\r\n\t\t_functionWhitelist[_msgSender()] = true;\r\n\r\n\t\tif (_migrate != address(0)) {\r\n\t\t\t// migrate from old contract\r\n\t\t\tDiscreetPreseed _oldContract = DiscreetPreseed(payable(_migrate));\r\n\t\t\t_preseedRate = _oldContract.preseedRate();\r\n\t\t\t_minTokenBuy = _oldContract.minTokenBuy();\r\n\t\t\t_maxTokenBuy = _oldContract.maxTokenBuy();\r\n\t\t\tpreseedLaunched = _oldContract.preseedLaunched();\r\n\t\t\t_replicateState = _oldContract._replicateState();\r\n\t\t\ttotalPreseedTokensToSell = _oldContract.totalPreseedTokensToSell();\r\n\t\t\tpreseedStartDate = _oldContract.preseedStartDate();\r\n\t\t\tpreseedEndDate = _oldContract.preseedEndDate();\r\n\t\t}\r\n\r\n\t\t// ensure tokens from old contract are transferred after construction\r\n\t}\r\n\r\n\tfunction addFunctionWhitelist(address addressToWhitelist) public onlyOwner() {\r\n\t\t_functionWhitelist[addressToWhitelist] = true;\r\n\t}\r\n\r\n\tfunction removeFunctionWhitelist(address addressToWhitelist) public onlyOwner() {\r\n\t\t_functionWhitelist[addressToWhitelist] = false;\r\n\t}\r\n\r\n\tfunction isFunctionWhitelisted(address addr) public view returns (bool) {\r\n\t\treturn _functionWhitelist[addr];\r\n\t}\r\n\r\n\tfunction initReplicateState() public onlyOwner() {\r\n\t\t_replicateState = true;\r\n\t}\r\n\r\n\tfunction endReplicateState() public onlyOwner() {\r\n\t\t_replicateState = false;\r\n\t}\r\n\r\n\tfunction batchReplicateState(address[] memory to, uint256[] memory amount) public onlyWhitelist() {\r\n\t\trequire(preseedLaunched == false, \"Cannot replicate state after preseed launch\");\r\n\t\trequire(_replicateState == true, \"Cannot replicate state without init\");\r\n\t\trequire (to.length == amount.length, \"array length mismatch\");\r\n\t\t\r\n\t\tfor (uint256 i = 0; i \u003c to.length; i++) {\r\n\t\t\trequire(_Discreet.balanceOf(to[i]) == 0, \"State for this address has been replicated\"); \r\n\t\t\t_Discreet.transfer(to[i], amount[i]);\r\n\t\t\ttotalPreseedTokensToSell = totalPreseedTokensToSell.sub(amount[i]);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction beginPreseed(uint256 numDays, uint256 _rate) public onlyOwner() {\r\n\t\trequire(preseedLaunched == false, \"Preseed already began\");\r\n\t\trequire(_replicateState == false, \"Still replicating state\");\r\n\t\tpreseedStartDate = now;\r\n\t\tpreseedEndDate = now + numDays * 1 days;\r\n\t\t_preseedRate = _rate;\r\n\t\tpreseedLaunched = true;\r\n\t}\r\n\r\n\tfunction extendPreseed(uint256 numDays) public onlyWhitelist() {\r\n\t\tpreseedEndDate += numDays * 1 days;\r\n\t}\r\n\r\n\tfunction changePreseedRate(uint256 _rate) public onlyWhitelist() {\r\n\t\t_preseedRate = _rate;\r\n\t}\r\n\r\n\tfunction preseedRate() public view returns (uint256) {\r\n\t\treturn _preseedRate;\r\n\t}\r\n\r\n\tfunction minTokenBuy() public view returns (uint256) {\r\n\t\treturn _minTokenBuy;\r\n\t}\r\n\r\n\tfunction maxTokenBuy() public view returns (uint256) {\r\n\t\treturn _maxTokenBuy;\r\n\t}\r\n\r\n\tfunction changeMinTokenBuy(uint256 newMin) public onlyWhitelist() {\r\n\t\t_minTokenBuy = newMin;\r\n\t}\r\n\r\n\tfunction changeMaxTokenBuy(uint256 newMax) public onlyWhitelist() {\r\n\t\t_maxTokenBuy = newMax;\r\n\t}\r\n\r\n\tfunction tokenSaleBuy() public payable {\r\n\t\trequire(now \u003e= preseedStartDate);\r\n\t\trequire(now \u003c preseedEndDate);\r\n\t\trequire(msg.value \u003e= _minTokenBuy, \"TokenSaleBuy: Value must be at least minimum amount\");\r\n\t\trequire(msg.value \u003c= _maxTokenBuy, \"TokenSaleBuy: Value must be no more than maximum amount\");\r\n\t\trequire(_purchases[_msgSender()] \u003c= _maxTokenBuy, \"TokenSaleBuy: Value and total purchased thus far exceeds maximum\");\r\n\t\t\r\n\t\tuint256 tokensToGive = _preseedRate * msg.value;\r\n\t\tuint256 _val = msg.value;\r\n\r\n\t\tif (_purchases[_msgSender()] + msg.value \u003e _maxTokenBuy) {\r\n\t\t\t_val = _maxTokenBuy - _purchases[_msgSender()];\r\n\t\t\t_msgSender().transfer(msg.value.sub(_val));\r\n\t\t\ttokensToGive = _preseedRate * _val;\r\n\t\t}\r\n\r\n\t\tbool isSoldOut = false;\r\n\r\n\t\tif (tokensToGive \u003e totalPreseedTokensToSell) {\r\n\t\t\t_val = totalPreseedTokensToSell.sub(totalPreseedTokensToSell % _preseedRate).div(_preseedRate);\r\n\t\t\t_msgSender().transfer(msg.value.sub(_val));\r\n\t\t\ttokensToGive = totalPreseedTokensToSell;\r\n\t\t\tisSoldOut = true;\r\n\t\t}\r\n\r\n\t\t_Discreet.transfer(_msgSender(), tokensToGive);\r\n\t\temit TokenSaleBuy(_msgSender(), tokensToGive);\r\n\r\n\t\ttotalPreseedTokensToSell = totalPreseedTokensToSell.sub(tokensToGive);\r\n\r\n\t\tpayable(owner()).transfer(_val);\r\n\t}\r\n\r\n\treceive() external payable {\r\n\t\ttokenSaleBuy();\r\n\t}\r\n\r\n\tfunction drainTokens() public onlyOwner() {\r\n\t\tif (_Discreet.balanceOf(address(this)) \u003e 0) {\r\n\t\t\t_Discreet.transfer(_msgSender(), _Discreet.balanceOf(address(this)));\r\n\t\t}\r\n\t}\r\n\r\n\tfunction endPreseed() public onlyOwner() {\r\n\t\trequire(preseedLaunched == true, \"Preseed hasn\u0027t been launched yet\");\r\n\t\trequire(now \u003e preseedEndDate, \"Preseed hasn\u0027t reached end date\");\r\n\t\tdrainTokens(); // return tokens to owner\r\n\t}\r\n\t\r\n\tfunction preemptEndPreseed(bool capReached) internal {\r\n\t\tif (capReached) {\r\n\t\t\tburnRemainingBalance();\r\n\t\t}\r\n\r\n\t\tpreseedEndDate = now;\r\n\t}\r\n\r\n\t// for now, sends to null address\r\n\tfunction burnRemainingBalance() internal {\r\n\t\t_Discreet.transfer(address(0), _Discreet.balanceOf(address(this)));\r\n\t}\r\n\r\n\tfunction checkUpkeep(bytes calldata checkData) external override returns (bool, bytes memory) {\r\n\t\tif (preemptEndRound || now \u003e preseedEndDate) {\r\n\t\t\treturn (false, bytes(\u0027\u0027));\r\n\t\t}\r\n\t\tuint256 totalSoldTokens = _ForeignDis.GetDisSold() + (_Discreet.getPreseedTokenSupply() - totalPreseedTokensToSell);\r\n\r\n\t\tif (totalSoldTokens \u003e= _Discreet.getPreseedTokenSupply()) {\r\n\t\t\tpreemptEndRound = true;\r\n\t\t\treturn (true, bytes(\u0027\u0027));\r\n\t\t}\r\n\r\n\t\treturn (false, bytes(\u0027\u0027));\r\n\t}\r\n\r\n\tfunction performUpkeep(bytes calldata performData) external override {\r\n\t\tif (preemptEndRound) {\r\n\t\t\tpreemptEndPreseed(true);\r\n\t\t}\r\n\t}\r\n}\r\n"},"DiscreetPreseed.sol":{"content":"pragma solidity ^0.6.12;\r\n// SPDX-License-Identifier: Unlicensed\r\n\r\nimport {SafeMath} from \"./SafeMath.sol\";\r\nimport {Address} from \"./Address.sol\";\r\nimport {Context} from \"./Context.sol\";\r\nimport {Ownable} from \"./Ownable.sol\";\r\nimport {Discreet} from \"./Discreet.sol\";\r\n\r\ncontract DiscreetPreseed is Context, Ownable {\r\n\tusing SafeMath for uint256;\r\n\tusing Address for address;\r\n\tmapping (address =\u003e uint256) private _purchases;\r\n\tmapping (address =\u003e bool) private _functionWhitelist;\r\n\r\n\tuint256 public totalPreseedTokensToSell = 0;\r\n\tDiscreet _Discreet;\r\n\r\n\tuint256 private _preseedRate;\r\n\tuint256 public _minTokenBuy = 5 * 10**16;\r\n\tuint256 public _maxTokenBuy = 100 * 10**18;\r\n\r\n\tuint256 public preseedStartDate = 0;\r\n\tuint256 public preseedEndDate = 0;\r\n\tbool public preseedLaunched = false;\r\n\r\n\tbool public _replicateState = false;\r\n\r\n\tevent TokenSaleBuy(address indexed buyer, uint256 amount);\r\n\r\n\tmodifier onlyWhitelist() {\r\n\t\trequire(_functionWhitelist[_msgSender()] == true, \"Address must be whitelisted to perform this\");\r\n\t\t_;\r\n\t}\r\n\r\n\tconstructor (address _discreet) public {\r\n\t\t_Discreet = Discreet(_discreet);\r\n\t\ttotalPreseedTokensToSell = _Discreet.getPreseedTokenSupply();\r\n\t\t_functionWhitelist[_msgSender()] = true;\r\n\t}\r\n\r\n\tfunction addFunctionWhitelist(address addressToWhitelist) public onlyOwner() {\r\n\t\t_functionWhitelist[addressToWhitelist] = true;\r\n\t}\r\n\r\n\tfunction removeFunctionWhitelist(address addressToWhitelist) public onlyOwner() {\r\n\t\t_functionWhitelist[addressToWhitelist] = false;\r\n\t}\r\n\r\n\tfunction isFunctionWhitelisted(address addr) public view returns (bool) {\r\n\t\treturn _functionWhitelist[addr];\r\n\t}\r\n\r\n\tfunction initReplicateState() public onlyOwner() {\r\n\t\t_replicateState = true;\r\n\t}\r\n\r\n\tfunction endReplicateState() public onlyOwner() {\r\n\t\t_replicateState = false;\r\n\t}\r\n\r\n\tfunction batchReplicateState(address[] memory to, uint256[] memory amount) public onlyWhitelist() {\r\n\t\trequire(preseedLaunched == false, \"Cannot replicate state after preseed launch\");\r\n\t\trequire(_replicateState == true, \"Cannot replicate state without init\");\r\n\t\trequire (to.length == amount.length, \"array length mismatch\");\r\n\t\t\r\n\t\tfor (uint256 i = 0; i \u003c to.length; i++) {\r\n\t\t\trequire(_Discreet.balanceOf(to[i]) == 0, \"State for this address has been replicated\"); \r\n\t\t\t_Discreet.transfer(to[i], amount[i]);\r\n\t\t\ttotalPreseedTokensToSell = totalPreseedTokensToSell.sub(amount[i]);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction beginPreseed(uint256 numDays, uint256 _rate) public onlyOwner() {\r\n\t\trequire(preseedLaunched == false, \"Preseed already began\");\r\n\t\trequire(_replicateState == false, \"Still replicating state\");\r\n\t\tpreseedStartDate = now;\r\n\t\tpreseedEndDate = now + numDays * 1 days;\r\n\t\t_preseedRate = _rate;\r\n\t\tpreseedLaunched = true;\r\n\t}\r\n\r\n\tfunction extendPreseed(uint256 numDays) public onlyWhitelist() {\r\n\t\tpreseedEndDate += numDays * 1 days;\r\n\t}\r\n\r\n\tfunction changePreseedRate(uint256 _rate) public onlyWhitelist() {\r\n\t\t_preseedRate = _rate;\r\n\t}\r\n\r\n\tfunction preseedRate() public view returns (uint256) {\r\n\t\treturn _preseedRate;\r\n\t}\r\n\r\n\tfunction minTokenBuy() public view returns (uint256) {\r\n\t\treturn _minTokenBuy;\r\n\t}\r\n\r\n\tfunction maxTokenBuy() public view returns (uint256) {\r\n\t\treturn _maxTokenBuy;\r\n\t}\r\n\r\n\tfunction changeMinTokenBuy(uint256 newMin) public onlyWhitelist() {\r\n\t\t_minTokenBuy = newMin;\r\n\t}\r\n\r\n\tfunction changeMaxTokenBuy(uint256 newMax) public onlyWhitelist() {\r\n\t\t_maxTokenBuy = newMax;\r\n\t}\r\n\r\n\tfunction tokenSaleBuy() public payable {\r\n\t\trequire(now \u003e= preseedStartDate);\r\n\t\trequire(now \u003c preseedEndDate);\r\n\t\trequire(msg.value \u003e= _minTokenBuy, \"TokenSaleBuy: Value must be at least minimum amount\");\r\n\t\trequire(msg.value \u003c= _maxTokenBuy, \"TokenSaleBuy: Value must be no more than maximum amount\");\r\n\t\trequire(_purchases[_msgSender()] \u003c= _maxTokenBuy, \"TokenSaleBuy: Value and total purchased thus far exceeds maximum\");\r\n\t\t\r\n\t\tuint256 tokensToGive = _preseedRate * msg.value;\r\n\t\tuint256 _val = msg.value;\r\n\r\n\t\tif (_purchases[_msgSender()] + msg.value \u003e _maxTokenBuy) {\r\n\t\t\t_val = _maxTokenBuy - _purchases[_msgSender()];\r\n\t\t\t_msgSender().transfer(msg.value.sub(_val));\r\n\t\t\ttokensToGive = _preseedRate * _val;\r\n\t\t}\r\n\r\n\t\tbool isSoldOut = false;\r\n\r\n\t\tif (tokensToGive \u003e totalPreseedTokensToSell) {\r\n\t\t\t_val = totalPreseedTokensToSell.sub(totalPreseedTokensToSell % _preseedRate).div(_preseedRate);\r\n\t\t\t_msgSender().transfer(msg.value.sub(_val));\r\n\t\t\ttokensToGive = totalPreseedTokensToSell;\r\n\t\t\tisSoldOut = true;\r\n\t\t}\r\n\r\n\t\t_Discreet.transfer(_msgSender(), tokensToGive);\r\n\t\temit TokenSaleBuy(_msgSender(), tokensToGive);\r\n\r\n\t\ttotalPreseedTokensToSell = totalPreseedTokensToSell.sub(tokensToGive);\r\n\r\n\t\tpayable(owner()).transfer(_val);\r\n\t}\r\n\r\n\treceive() external payable {\r\n\t\ttokenSaleBuy();\r\n\t}\r\n\r\n\tfunction drainTokens() public onlyOwner() {\r\n\t\tif (_Discreet.balanceOf(address(this)) \u003e 0) {\r\n\t\t\t_Discreet.transfer(_msgSender(), _Discreet.balanceOf(address(this)));\r\n\t\t}\r\n\t}\r\n\r\n\tfunction endPreseed() public onlyOwner() {\r\n\t\trequire(preseedLaunched == true, \"Preseed hasn\u0027t been launched yet\");\r\n\t\trequire(now \u003e preseedEndDate, \"Preseed hasn\u0027t reached end date\");\r\n\t\tdrainTokens(); // return tokens to owner\r\n\t}\r\n}\r\n"},"ForeignDisTracker.sol":{"content":"pragma solidity ^0.6.12;\r\n// SPDX-License-Identifier: Unlicensed\r\n\r\ncontract ForeignDisTracker {\r\n    uint256 private DisSold;\r\n    mapping (address =\u003e bool) private _functionWhitelist;\r\n\r\n    modifier onlyWhitelist() {\r\n\t\trequire(_functionWhitelist[msg.sender] == true, \"Address must be whitelisted to perform this\");\r\n\t\t_;\r\n\t}\r\n\r\n    constructor () public {\r\n        _functionWhitelist[msg.sender] = true; \r\n    }\r\n\r\n    function addWhitelist(address whitelisted) public onlyWhitelist() {\r\n        _functionWhitelist[whitelisted] = true;\r\n    }\r\n\r\n    function GetDisSold() public view returns (uint256) {\r\n        return DisSold;\r\n    }\r\n\r\n    function SetDisSold(uint256 value) public onlyWhitelist() {\r\n        DisSold = value;\r\n    }\r\n}"},"IERC20.sol":{"content":"pragma solidity ^0.6.12;\n// SPDX-License-Identifier: Unlicensed\n\ninterface IERC20 {\n\tfunction totalSupply() external view returns (uint256);\n\tfunction balanceOf(address account) external view returns (uint256);\n\tfunction transfer(address recipient, uint256 amount) external returns (bool);\n\tfunction allowance(address owner, address spender) external view returns (uint256);\n\tfunction approve(address spender, uint256 amount) external returns (bool);\n\tfunction transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"Ownable.sol":{"content":"pragma solidity ^0.6.12;\n// SPDX-License-Identifier: Unlicensed\n\nimport {Context} from \"./Context.sol\";\n\ncontract Ownable is Context {\n\taddress private _owner;\n\taddress private _previousOwner;\n\taddress private _lockTime;\n\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\tconstructor () internal {\n\t\taddress msgSender = _msgSender();\n\t\t_owner = msgSender;\n\t\temit OwnershipTransferred(address(0), msgSender);\n\t}\n\n\tfunction owner() public view returns (address) {\n\t\treturn _owner;\n\t}\n\n\tmodifier onlyOwner() {\n\t\trequire(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n\t\t_;\n\t}\n\n\tfunction renounceOwnership() public virtual onlyOwner {\n\t\temit OwnershipTransferred(_owner, address(0));\n\t\t_owner = address(0);\n\t}\n\n\tfunction transferOwnership(address newOwner) public virtual onlyOwner {\n\t\trequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\n\t\temit OwnershipTransferred(_owner, newOwner);\n\t\t_owner = newOwner;\n\t}\n}\n"},"SafeMath.sol":{"content":"pragma solidity ^0.6.12;\n// SPDX-License-Identifier: Unlicensed\n\nlibrary SafeMath {\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tuint256 c = a + b;\n\t\trequire(c \u003e= a, \"SafeMath: addition overflow\");\n\t\treturn c;\n\t}\n\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\trequire(b \u003c= a, \"SafeMath: subtraction overflow\");\n\t\tuint256 c = a - b;\n\t\treturn c;\n\t}\n\n\tfunction sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n \n        return c;\n    }\n\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint256 c = a * b;\n\t\trequire(c / a == b, \"SafeMath: multiplication overflow\");\n\t\treturn c;\n\t}\n\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\trequire(b \u003e 0, \"SafeMath: division by zero\");\n\t\tuint256 c = a / b;\n\t\treturn c;\n\t}\n\n\tfunction div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n \n        return c;\n    }\n\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\trequire(b != 0, \"SafeMath: modulo by zero\");\n\t\tuint256 c = a % b;\n\t\treturn c;\n\t}\n}"}}