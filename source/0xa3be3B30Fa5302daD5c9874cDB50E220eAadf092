{"BabyBanana.sol":{"content":"// SPDX-License-Identifier: MIT\n\n/**\n *    ___       __        ___                          \n *   / _ )___ _/ /  __ __/ _ )___ ____  ___ ____  ___ _\n *  / _  / _ `/ _ \\/ // / _  / _ `/ _ \\/ _ `/ _ \\/ _ `/\n * /____/\\_,_/_.__/\\_, /____/\\_,_/_//_/\\_,_/_//_/\\_,_/ \n *                /___/                                \n *\n * Pioneers on the jungle ecosystem!\n *\n * Website     https://babybanana.finance\n * Twitter     https://twitter.com/BabyBananaToken\n * Telegram    https://t.me/BabyBananaOfficial\n * Discord     https://discord.gg/ukuy4TBMJw\n * Reddit      https://www.reddit.com/r/BabyBananaOfficial\n * Instagram   https://www.instagram.com/babybananatoken\n *\n * In memory of Selma\n */\n\npragma solidity ^0.8.0;\n\nimport \"./IBEP20.sol\";\nimport \"./DividendDistributor.sol\";\n\ncontract BabyBanana is IBEP20 {\n    struct TokenLock {\n        uint256 amount;\n        uint256 releaseTime;\n    }\n\n    address constant DEAD = 0x000000000000000000000000000000000000dEaD;\n    address constant ZERO = 0x0000000000000000000000000000000000000000;\n    address constant MULTI_SIG_TEAM_WALLET = 0x48e065F5a65C3Ba5470f75B65a386A2ad6d5ba6b;\n    address constant MARKETING_WALLET = 0x0426760C100E3be682ce36C01D825c2477C47292;\n    address constant PRESALE_CONTRACT = 0xa5707412E6F3e06e932b139C3BCAD26a0734Ab91;\n\n    IBabyBananaNFT public constant BABYBANANA_NFT = IBabyBananaNFT(0x986462937DE0B064364631c9b72A15ac8cc76678);\n    ISelmaNFT public constant SELMA_NFT = ISelmaNFT(0x824Db8c2Cf7eC655De2A7825f8E9311c8e526523);\n\n    bool public autoBuybackEnabled = false;\n    bool public swapEnabled = true;\n    bool _inSwap;\n\n    uint8 constant DECIMALS = 18;\n    uint256 constant TOTAL_SUPPLY = 1 * 10**9 * 10**DECIMALS;\n    uint256 public swapThreshold = 300000 * 10**DECIMALS;\n\n    mapping (address =\u003e uint256) _balances;\n    mapping (address =\u003e mapping (address =\u003e uint256)) _allowances;\n\n    mapping (address =\u003e bool) public isFeeExempt;\n    mapping (address =\u003e bool) public isDividendExempt;\n    mapping (address =\u003e TokenLock) _lockedTokens;\n\n    uint256 public buybackFee = 300;\n    uint256 public rewardFee = 100;\n    uint256 public marketingFee = 100;\n    uint256 _totalFee = 500;\n    uint256 constant FEE_DENOMINATOR = 10000;\n\n    IApeRouter public constant ROUTER = IApeRouter(0xcF0feBd3f17CEf5b47b0cD257aCf6025c5BFf3b7);\n    address public immutable pair;\n    uint256 _launchedAt;\n\n    uint256 public lastNftBuyback;\n    uint256 public nftBuybackCooldown = 3 days;\n    uint256 public lastMarketingBuyback;\n    uint256 constant public marketingBuybackCooldown = 1 days;\n\n    uint256 public autoBuybackCap;\n    uint256 public autoBuybackAccumulator;\n    uint256 public autoBuybackAmount;\n    uint256 public autoBuybackBlockPeriod;\n    uint256 public autoBuybackBlockLast;\n\n    DividendDistributor public immutable distributor;\n    uint256 _marketingTransferGas = 30000;\n\n    event NFTBuyback(address indexed account, uint256 indexed tokenId, uint256 amount);\n    event Launch(uint256 timestamp);\n    event SetMarketingTransferGas(uint256 gas);\n    event SetDividendExempt(address indexed account, bool indexed exempt);\n    event SetFeeExempt(address indexed account, bool indexed exempt);\n    event SetFees(uint256 buyback, uint256 reward, uint256 marketing);\n    event SetSwapBackSettings(bool indexed enabled, uint256 amount);\n    event SetAutoBuybackSettings(bool indexed enabled, uint256 cap, uint256 amount, uint256 period);\n    event SetNFTBuybackCooldown(uint256 cooldown);\n    event TriggerBuyback(uint256 amount);\n    event TriggerSwapBack();\n    event SendLockedTokens(address indexed recipient, uint256 amount, uint256 releaseTime);\n    event UnlockTokens(address indexed account);\n\n    modifier swapping() { \n        _inSwap = true;\n        _;\n        _inSwap = false;\n    }\n\n    modifier onlyTeam() {\n        require(msg.sender == MULTI_SIG_TEAM_WALLET);\n        _;\n    }\n\n    modifier onlyMarketing() {\n        require(msg.sender == MARKETING_WALLET);\n        _;\n    }\n\n    constructor () {\n        pair = IApeFactory(ROUTER.factory()).createPair(ROUTER.WETH(), address(this));\n        _allowances[address(this)][address(ROUTER)] = type(uint256).max;\n\n        distributor = new DividendDistributor();\n        excludeAccounts();\n\n        _balances[MARKETING_WALLET] = TOTAL_SUPPLY;\n        emit Transfer(address(0), MARKETING_WALLET, TOTAL_SUPPLY);\n    }\n\n    // IBEP20\n\n    function totalSupply() external pure override returns (uint256) { return TOTAL_SUPPLY; }\n    function decimals() external pure override returns (uint8) { return DECIMALS; }\n    function symbol() external pure override returns (string memory) { return \"BBNANA\"; }\n    function name() external pure override returns (string memory) { return \"BabyBanana\"; }\n    function getOwner() external pure override returns (address) { return MULTI_SIG_TEAM_WALLET; }\n    function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }\n    function allowance(address _owner, address spender) external view override returns (uint256) { return _allowances[_owner][spender]; }\n\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\n        return _transferFrom(msg.sender, recipient, amount);\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\n        _transferFrom(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        require(currentAllowance \u003e= amount, \"Transfer amount exceeds allowance\");\n\n        _approve(sender, msg.sender, currentAllowance - amount);\n        return true;\n    }\n\n    // IBEP20 Helpers\n\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\n        uint256 currentAllowance = _allowances[msg.sender][spender];\n        require(currentAllowance \u003e= subtractedValue, \"Decreased allowance below zero\");\n\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\n        return true;\n    }\n\n    // Public\n\n    receive() external payable {}\n\n    function lockedAccountInfo(address account) external view returns (TokenLock memory) {\n        return _lockedTokens[account];\n    }\n\n    function getTotalFee() public view returns (uint256) {\n        if(_launchedAt + 1 \u003e= block.number){ return FEE_DENOMINATOR - 100; }\n        return _totalFee;\n    }\n\n    function getCirculatingSupply() external view returns (uint256) {\n        return TOTAL_SUPPLY - _balances[DEAD] - _balances[ZERO];\n    }\n\n    function nftBuyback(uint256 tokenId) external {\n        uint256 buybackAmount = BABYBANANA_NFT.featureValueOf(0, msg.sender);\n        require(buybackAmount \u003e 0 \u0026\u0026 buybackAmount \u003c= 15 ether, \"Invalid amount\");\n        require(address(this).balance \u003e= buybackAmount, \"Insufficient balance\");\n        require(lastNftBuyback + nftBuybackCooldown \u003c= block.timestamp, \"Buyback is cooling down\");\n\n        BABYBANANA_NFT.consume(tokenId, msg.sender);\n        buyTokens(buybackAmount, DEAD);\n        lastNftBuyback = block.timestamp;\n\n        emit NFTBuyback(msg.sender, tokenId, buybackAmount);\n    }\n\n    // Private\n\n    function _approve(address owner, address spender, uint256 amount) private {\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transferFrom(address sender, address recipient, uint256 amount) private returns (bool) {\n        if(_inSwap){ return _basicTransfer(sender, recipient, amount); }\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance \u003e= amount, \"Transfer amount exceeds balance\");\n\n        if (_lockedTokens[sender].releaseTime \u003e block.timestamp) {\n            require(senderBalance - amount \u003e= _lockedTokens[sender].amount, \"Tokens are locked\");\n        }\n\n        if(shouldSwapBack(recipient)){ swapBack(); }\n        if(shouldAutoBuyback(recipient)){ triggerAutoBuyback(); }\n        if(!launched() \u0026\u0026 recipient == pair \u0026\u0026 senderBalance \u003e 0 \u0026\u0026 amount \u003e 0){ launch(); }\n\n        _balances[sender] = senderBalance - amount;\n\n        uint256 amountReceived = shouldTakeFee(sender, recipient) ? takeFee(sender, recipient, amount) : amount;\n        _balances[recipient] += amountReceived;\n\n        if(!isDividendExempt[sender]){ try distributor.setShare(sender, _balances[sender]) {} catch {} }\n        if(!isDividendExempt[recipient]){ try distributor.setShare(recipient, _balances[recipient]) {} catch {} }\n\n        try distributor.process() {} catch {}\n\n        emit Transfer(sender, recipient, amountReceived);\n        return true;\n    }\n\n    function _basicTransfer(address sender, address recipient, uint256 amount) private returns (bool) {\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance \u003e= amount, \"Transfer amount exceeds balance\");\n\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function shouldTakeFee(address sender, address recipient) private view returns (bool) {\n        if (isFeeExempt[sender]) { return false; }\n        bool isSell = recipient == pair;\n        bool isBuy = sender == pair;\n        return isBuy || isSell;\n    }\n\n    function takeFee(address sender, address recipient, uint256 amount) private returns (uint256) {\n        bool isBuy = sender == pair;\n        address initiator = isBuy ? recipient : sender;\n        uint256 discountMultiplier;\n\n        uint256 nftDiscountMultiplier = nftTaxDiscount(initiator);\n        uint256 selmaDiscountMultiplier = selmaTaxDiscount(initiator);\n\n        if (nftDiscountMultiplier \u003e= selmaDiscountMultiplier) {\n            discountMultiplier = nftDiscountMultiplier;\n        } else {\n            discountMultiplier = selmaDiscountMultiplier;\n        }\n\n        uint256 discountedFee = getTotalFee() - getTotalFee() * discountMultiplier / FEE_DENOMINATOR;\n        uint256 feeAmount = amount * discountedFee / FEE_DENOMINATOR;\n\n        _balances[address(this)] += feeAmount;\n        emit Transfer(sender, address(this), feeAmount);\n\n        return amount - feeAmount;\n    }\n\n    function nftTaxDiscount(address account) private view returns (uint256) {\n        try BABYBANANA_NFT.featureValueOf(3, account) returns (uint256 discountMultiplier) {\n            return discountMultiplier \u003e FEE_DENOMINATOR ? FEE_DENOMINATOR : discountMultiplier;\n        } catch {\n            return 0;\n        }\n    }\n\n    function selmaTaxDiscount(address account) private view returns (uint256) {\n        uint256 discountMultiplier;\n\n        try SELMA_NFT.balanceOf(account, 1) returns (uint256 platinumBalance) {\n            if (platinumBalance \u003e 0) { discountMultiplier = 2500; }\n        } catch {}\n\n        try SELMA_NFT.balanceOf(account, 2) returns (uint256 diamondBalance) {\n            if (diamondBalance \u003e 0) { discountMultiplier = 5000; }\n        } catch {}\n\n        return discountMultiplier;\n    }\n\n    function shouldSwapBack(address recipient) private view returns (bool) {\n        return recipient == pair\n        \u0026\u0026 !_inSwap\n        \u0026\u0026 swapEnabled\n        \u0026\u0026 _balances[address(this)] \u003e= swapThreshold;\n    }\n\n    function swapBack() private swapping {\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = ROUTER.WETH();\n\n        uint256 balanceBefore = address(this).balance;\n\n        ROUTER.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            swapThreshold,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n\n        uint256 amountBNB = address(this).balance - balanceBefore;\n        uint256 amountBNBRewards = amountBNB * rewardFee / _totalFee;\n        uint256 amountBNBMarketing = amountBNB * marketingFee / _totalFee;\n\n        try distributor.deposit{value: amountBNBRewards}() {} catch {}\n        payable(MARKETING_WALLET).call{value: amountBNBMarketing, gas: _marketingTransferGas}(\"\");\n    }\n\n    function shouldAutoBuyback(address recipient) private view returns (bool) {\n        return recipient == pair\n            \u0026\u0026 !_inSwap\n            \u0026\u0026 autoBuybackEnabled\n            \u0026\u0026 autoBuybackBlockLast + autoBuybackBlockPeriod \u003c= block.number\n            \u0026\u0026 address(this).balance \u003e= autoBuybackAmount;\n    }\n\n    function triggerAutoBuyback() private {\n        buyTokens(autoBuybackAmount, DEAD);\n        autoBuybackBlockLast = block.number;\n        autoBuybackAccumulator += autoBuybackAmount;\n        if(autoBuybackAccumulator \u003e autoBuybackCap){ autoBuybackEnabled = false; }\n    }\n\n    function buyTokens(uint256 amount, address to) private swapping {\n        address[] memory path = new address[](2);\n        path[0] = ROUTER.WETH();\n        path[1] = address(this);\n\n        ROUTER.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount}(\n            0,\n            path,\n            to,\n            block.timestamp\n        );\n    }\n\n    function launched() private view returns (bool) {\n        return _launchedAt != 0;\n    }\n\n    function launch() private {\n        _launchedAt = block.number;\n        emit Launch(_launchedAt);\n    }\n\n    function excludeAccounts() private {\n        isFeeExempt[MARKETING_WALLET] = true;\n        isDividendExempt[MARKETING_WALLET] = true;\n\n        isFeeExempt[MULTI_SIG_TEAM_WALLET] = true;\n        isDividendExempt[MULTI_SIG_TEAM_WALLET] = true;\n\n        isDividendExempt[PRESALE_CONTRACT] = true;\n\n        isFeeExempt[address(this)] = true;\n        isDividendExempt[address(this)] = true;\n\n        isDividendExempt[pair] = true;\n        isDividendExempt[DEAD] = true;\n        isDividendExempt[ZERO] = true;\n    }\n\n    // Maintenance\n\n    function setMarketingTransferGas(uint256 gas) external onlyTeam {\n        require(gas \u003e= 21000 \u0026\u0026 gas \u003c= 100000);\n        _marketingTransferGas = gas;\n        emit SetMarketingTransferGas(gas);\n    }\n\n    function setIsDividendExempt(address account, bool exempt) external onlyTeam {\n        require(account != address(this) \u0026\u0026 account != pair \u0026\u0026 account != MARKETING_WALLET);\n\n        isDividendExempt[account] = exempt;\n        if (exempt) {\n            distributor.setShare(account, 0);\n        } else {\n            distributor.setShare(account, _balances[account]);\n        }\n\n        emit SetDividendExempt(account, exempt);\n    }\n\n    function setIsFeeExempt(address account, bool exempt) external onlyTeam {\n        require(account != MARKETING_WALLET \u0026\u0026 account != MULTI_SIG_TEAM_WALLET \u0026\u0026 account != address(this));\n        isFeeExempt[account] = exempt;\n        emit SetFeeExempt(account, exempt);\n    }\n\n    function setFees(uint256 _buybackFee, uint256 _rewardFee, uint256 _marketingFee) external onlyTeam {\n        buybackFee = _buybackFee;\n        rewardFee = _rewardFee;\n        marketingFee = _marketingFee;\n        _totalFee = buybackFee + rewardFee + marketingFee;\n        require(_totalFee \u003c= 1500);\n\n        emit SetFees(buybackFee, rewardFee, marketingFee);\n    }\n\n    function setSwapBackSettings(bool enabled, uint256 amount) external onlyTeam {\n        uint256 tokenAmount = amount * 10**DECIMALS;\n        swapEnabled = enabled;\n        swapThreshold = tokenAmount;\n        emit SetSwapBackSettings(enabled, amount);\n    }\n\n    function setAutoBuybackSettings(bool _enabled, uint256 _cap, uint256 _amount, uint256 _period) external onlyTeam {\n        require(_amount \u003c= 10 ether, \"Buyback is capped to 10 BNB\");\n        require(_period \u003e= 100, \"Minimum interval is 5 minutes with average 3s block time\");\n        \n        autoBuybackEnabled = _enabled;\n        autoBuybackCap = _cap;\n        autoBuybackAccumulator = 0;\n        autoBuybackAmount = _amount;\n        autoBuybackBlockPeriod = _period;\n        autoBuybackBlockLast = block.number;\n\n        emit SetAutoBuybackSettings(_enabled, _cap, _amount, _period);\n    }\n\n    function setNftBuybackCooldown(uint256 cooldown) external onlyTeam {\n        require(cooldown \u003c= 1 weeks);\n        nftBuybackCooldown = cooldown;\n        emit SetNFTBuybackCooldown(cooldown);\n    }\n\n    function triggerBuyback(uint256 amount) external onlyMarketing {\n        require(amount \u003c= 30 ether, \"Buyback is capped to 30 BNB\");\n        require(lastMarketingBuyback + marketingBuybackCooldown \u003c= block.timestamp, \"Buyback is cooling down\");\n        \n        buyTokens(amount, DEAD);\n        lastMarketingBuyback = block.timestamp;\n\n        emit TriggerBuyback(amount);\n    }\n\n    function triggerSwapBack() external onlyMarketing {\n        swapBack();\n        emit TriggerSwapBack();\n    }\n\n    function sendLockedTokens(address recipient, uint256 amount, uint256 releaseTime) external onlyMarketing {\n        _lockedTokens[recipient].amount += amount;\n        _lockedTokens[recipient].releaseTime = releaseTime;\n        _transferFrom(msg.sender, recipient, amount);\n\n        emit SendLockedTokens(recipient, amount, releaseTime);\n    }\n\n    function unlockTokens(address account) external onlyTeam {\n        _lockedTokens[account].releaseTime = 0;\n        _lockedTokens[account].amount = 0;\n        emit UnlockTokens(account);\n    }\n}\n"},"DividendDistributor.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IBabyBananaNFT.sol\";\nimport \"./ISelmaNFT.sol\";\nimport \"./IBEP20.sol\";\nimport \"./IApe.sol\";\n\ncontract DividendDistributor {\n    struct Share {\n        uint256 amount;\n        uint256 totalExcluded;\n        uint256 totalRealised;\n    }\n\n    IBEP20 constant BANANA = IBEP20(0x603c7f932ED1fc6575303D8Fb018fDCBb0f39a95);\n    IBEP20 constant GNANA = IBEP20(0xdDb3Bd8645775F59496c821E4F55A7eA6A6dc299);\n    address constant WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\n    address constant MULTI_SIG_TEAM_WALLET = 0x48e065F5a65C3Ba5470f75B65a386A2ad6d5ba6b;\n    address constant MARKETING_WALLET = 0x0426760C100E3be682ce36C01D825c2477C47292;\n\n    IBabyBananaNFT public constant BABYBANANA_NFT = IBabyBananaNFT(0x986462937DE0B064364631c9b72A15ac8cc76678);\n    ISelmaNFT public constant SELMA_NFT = ISelmaNFT(0x824Db8c2Cf7eC655De2A7825f8E9311c8e526523);\n    address public constant MUSEUM = 0x88C16087254824394b64144B51070B2f26e283f5;\n\n    IApeRouter public constant ROUTER = IApeRouter(0xcF0feBd3f17CEf5b47b0cD257aCf6025c5BFf3b7);\n    IApeTreasury public treasury = IApeTreasury(0xec4b9d1fd8A3534E31fcE1636c7479BcD29213aE);\n    uint256 constant treasuryTimelock = 4 weeks;\n    uint256 immutable _deployedAt;\n\n    address immutable token;\n    address[] shareHolders;\n    uint256 currentIndex;\n\n    mapping (address =\u003e Share) public shares;\n    mapping (address =\u003e uint256) public totalDistributed;\n    mapping (address =\u003e uint256) shareholderIndexes;\n    mapping (address =\u003e uint256) shareholderClaims;\n\n    uint256 public totalShares;\n    uint256 public totalDividends;\n    uint256 public dividendsPerShare;\n    uint256 public dividendsPerShareAccuracyFactor = 10**18;\n\n    uint256 public gasLimit = 500000;\n    uint256 public minPeriod = 1 hours;\n    uint256 public minDistribution = 35 * 10**17;\n    \n    event DividendDistributed(address indexed to, uint256 amount);\n    event Deposit(uint256 amount);\n    event SetShare(address indexed account, uint256 amount);\n    event Process();\n    event UpdateTreasury(address treasury);\n    event SetDistributionCriteria(uint256 period, uint256 amount);\n    event SetGasLimit(uint256 gas);\n\n    modifier onlyToken() {\n        require(msg.sender == token);\n        _;\n    }\n\n    modifier onlyTeam() {\n        require(msg.sender == MULTI_SIG_TEAM_WALLET);\n        _;\n    }\n\n    modifier onlyTokenOrMarketing() {\n        require(msg.sender == token || msg.sender == MARKETING_WALLET);\n        _;\n    }\n\n    constructor () {\n        token = msg.sender;\n        _deployedAt = block.timestamp;\n    }\n\n    // IDividendDistributor\n\n    function deposit() external payable onlyTokenOrMarketing {\n        if (msg.value \u003e 0) {\n            uint256 balanceBefore = BANANA.balanceOf(address(this));\n\n            address[] memory path = new address[](2);\n            path[0] = ROUTER.WETH();\n            path[1] = address(BANANA);\n\n            ROUTER.swapExactETHForTokens{value: msg.value}(\n                0,\n                path,\n                address(this),\n                block.timestamp\n            );\n\n            uint256 amount = BANANA.balanceOf(address(this)) - balanceBefore;\n\n            totalDividends += amount;\n            dividendsPerShare += dividendsPerShareAccuracyFactor * amount / totalShares;\n\n            emit Deposit(msg.value);\n        }\n    }\n\n    function setShare(address shareholder, uint256 amount) external onlyToken {\n        if(shares[shareholder].amount \u003e 0){\n            distributeDividend(shareholder);\n        }\n\n        if(amount \u003e 0 \u0026\u0026 shares[shareholder].amount == 0){\n            addShareholder(shareholder);\n        }else if(amount == 0 \u0026\u0026 shares[shareholder].amount \u003e 0){\n            removeShareholder(shareholder);\n        }\n\n        uint256 boostAmount;\n        uint256 nftBoostAmount = nftShareBoost(shareholder, amount);\n        uint256 selmaBoostAmount = selmaShareBoost(shareholder, amount);\n\n        if (nftBoostAmount \u003e= selmaBoostAmount) {\n            boostAmount = nftBoostAmount;\n        } else {\n            boostAmount = selmaBoostAmount;\n        }\n\n        uint256 boostedAmount = amount + boostAmount;\n\n        totalShares = totalShares - shares[shareholder].amount + boostedAmount;\n        shares[shareholder].amount = boostedAmount;\n        shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);\n\n        emit SetShare(shareholder, boostedAmount);\n    }\n\n    function nftShareBoost(address account, uint256 shareAmount) private view returns (uint256) {\n        try BABYBANANA_NFT.featureValueOf(4, account) returns (uint256 rewardMultiplier) {\n            if (rewardMultiplier \u003e 10000) { rewardMultiplier = 10000; }\n            return shareAmount * rewardMultiplier / 10000;\n        } catch {\n            return 0;\n        }\n    }\n\n    function selmaShareBoost(address account, uint256 shareAmount) private view returns (uint256) {\n        uint256 boostAmount;\n\n        try SELMA_NFT.balanceOf(account, 0) returns (uint256 goldBalance) {\n            if (goldBalance \u003e 0) { boostAmount = shareAmount * 5 / 100; }\n        } catch {}\n\n        try SELMA_NFT.balanceOf(account, 2) returns (uint256 diamondBalance) {\n            if (diamondBalance \u003e 0) { boostAmount = shareAmount / 10; }\n        } catch {}\n\n        return boostAmount;\n    }\n\n    function process() external onlyToken {\n        uint256 shareholderCount = shareHolders.length;\n\n        if(shareholderCount == 0) { return; }\n\n        uint256 gasLeft = gasleft();\n        uint256 gasUsed;\n        uint256 avgGasCost;\n        uint256 iterations;\n\n        while(gasUsed + avgGasCost \u003c gasLimit \u0026\u0026 iterations \u003c shareholderCount) {\n            if(currentIndex \u003e= shareholderCount){\n                currentIndex = 0;\n            }\n\n            if(shouldDistribute(shareHolders[currentIndex])){\n                distributeDividend(shareHolders[currentIndex]);\n            }\n\n            gasUsed += gasLeft - gasleft();\n            gasLeft = gasleft();\n            currentIndex++;\n            iterations++;\n            avgGasCost = gasUsed / iterations;\n        }\n\n        emit Process();\n    }\n\n    // Public\n\n    function claimDividend() external {\n        distributeDividend(msg.sender);\n    }\n\n    function getUnpaidEarnings(address shareholder) public view returns (uint256) {\n        if(shares[shareholder].amount == 0){ return 0; }\n\n        uint256 shareholderTotalDividends = getCumulativeDividends(shares[shareholder].amount);\n        uint256 shareholderTotalExcluded = shares[shareholder].totalExcluded;\n\n        if(shareholderTotalDividends \u003c= shareholderTotalExcluded){ return 0; }\n\n        return shareholderTotalDividends - shareholderTotalExcluded;\n    }\n\n    // Private\n    \n    function shouldDistribute(address shareholder) private view returns (bool) {\n        return shareholderClaims[shareholder] + minPeriod \u003c block.timestamp\n                \u0026\u0026 getUnpaidEarnings(shareholder) \u003e minDistribution;\n    }\n\n    function distributeDividend(address shareholder) private {\n        if(shares[shareholder].amount == 0){ return; }\n\n        uint256 amount = getUnpaidEarnings(shareholder);\n        if(amount \u003e 0){\n            shareholderClaims[shareholder] = block.timestamp;\n            shares[shareholder].totalRealised += amount;\n            shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);\n\n            (address rewardAddress, address rewardPair) = rewardTokenFor(shareholder);\n            if (rewardAddress == token) { rewardAddress = address(BANANA); }\n\n            if (shareholder == MUSEUM || rewardAddress == address(GNANA)) {\n                distributeGnana(amount, shareholder);\n            } else if (rewardAddress == address(BANANA)) {\n                totalDistributed[address(BANANA)] += amount;\n                BANANA.transfer(shareholder, amount);\n            } else {\n                distributeReward(rewardAddress, rewardPair, amount, shareholder);\n            }\n\n            emit DividendDistributed(shareholder, amount);\n        }\n    }\n\n    function rewardTokenFor(address account) private view returns (address, address) {\n        try BABYBANANA_NFT.rewardTokenFor(account) returns (address tokenAddress, address pair) {\n            return (tokenAddress, pair);\n        } catch {\n            return (address(BANANA), WBNB);\n        }\n    }\n\n    function distributeGnana(uint256 bananaAmount, address shareholder) private {\n        BANANA.approve(address(treasury), bananaAmount);\n\n        uint256 balanceBefore = GNANA.balanceOf(address(this));\n\n        try treasury.buy(bananaAmount) {\n            uint256 gnanaAmount = GNANA.balanceOf(address(this)) - balanceBefore;\n            if (gnanaAmount \u003e 0) {\n                totalDistributed[address(GNANA)] += gnanaAmount;\n                GNANA.transfer(shareholder, gnanaAmount);\n            }\n        } catch {}\n    }\n\n    function distributeReward(\n        address rewardAddress,\n        address rewardPair,\n        uint256 bananaAmount,\n        address shareholder\n    ) private {\n        BANANA.approve(address(ROUTER), bananaAmount);\n        address[] memory path = getPath(rewardAddress, rewardPair);\n\n        try ROUTER.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            bananaAmount,\n            0,\n            path,\n            shareholder,\n            block.timestamp\n        ) {\n            totalDistributed[rewardAddress] += bananaAmount;\n        } catch {}\n    }\n\n    function getPath(address rewardAddress, address rewardPair) private pure returns (address[] memory) {\n        address[] memory path;\n        \n        if (rewardAddress == ROUTER.WETH()) {\n            path = new address[](2);\n            path[0] = address(BANANA);\n            path[1] = ROUTER.WETH();\n        } else if (rewardPair == ROUTER.WETH()) {\n            path = new address[](3);\n            path[0] = address(BANANA);\n            path[1] = ROUTER.WETH();\n            path[2] = rewardAddress;\n        } else {\n            path = new address[](4);\n            path[0] = address(BANANA);\n            path[1] = ROUTER.WETH();\n            path[2] = rewardPair;\n            path[3] = rewardAddress;\n        }\n\n        return path;\n    }\n\n    function getCumulativeDividends(uint256 share) private view returns (uint256) {\n        return share * dividendsPerShare / dividendsPerShareAccuracyFactor;\n    }\n\n    function addShareholder(address shareholder) private {\n        shareholderIndexes[shareholder] = shareHolders.length;\n        shareHolders.push(shareholder);\n    }\n\n    function removeShareholder(address shareholder) private {\n        shareHolders[shareholderIndexes[shareholder]] = shareHolders[shareHolders.length-1];\n        shareholderIndexes[shareHolders[shareHolders.length-1]] = shareholderIndexes[shareholder];\n        shareHolders.pop();\n    }\n\n    // Maintenance\n\n    function updateTreasury(address _treasury) external onlyTeam {\n        require(_deployedAt + treasuryTimelock \u003c= block.timestamp, \"Function is time locked\");\n        \n        treasury = IApeTreasury(_treasury);\n        emit UpdateTreasury(_treasury);\n    }\n\n    function setDistributionCriteria(uint256 _minPeriod, uint256 _minDistribution) external onlyTeam {\n        require(_minPeriod \u003c= 1 weeks \u0026\u0026 _minDistribution \u003c= 1 ether, \"Invalid parameters\");\n        \n        minPeriod = _minPeriod;\n        minDistribution = _minDistribution;\n        emit SetDistributionCriteria(_minPeriod, _minDistribution);\n    }\n\n    function setGasLimit(uint256 gas) external onlyTeam {\n        require(gas \u003c= 750000 \u0026\u0026 gas \u003e= 100000);\n        \n        gasLimit = gas;\n        emit SetGasLimit(gas);\n    }\n}\n"},"IApe.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IApeTreasury {\n    function buy(uint256 _amount) external;\n}\n\ninterface IApeFactory {\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n}\n\ninterface IApeRouter {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function swapExactETHForTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable returns (uint[] memory amounts);\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"},"IBabyBananaNFT.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IBabyBananaNFT {\n    function consume(uint256 tokenId, address sender) external;\n    function stake(uint256 tokenId, address sender) external;\n    function priceOf(uint256 tokenId) external view returns (uint256);\n    function stakingRewardShareOf(uint256 tokenId, address account) external view returns (uint256);\n    function featureValueOf(uint8 feature, address account) external view returns (uint256);\n    function lotteryTicketsOf(address account) external view returns (uint256);\n    function rewardTokenFor(address account) external view returns (address, address);\n\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) external;\n}\n"},"IBEP20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IBEP20 {\n  function totalSupply() external view returns (uint256);\n  function decimals() external view returns (uint8);\n  function symbol() external view returns (string memory);\n  function name() external view returns (string memory);\n  function getOwner() external view returns (address);\n  function balanceOf(address account) external view returns (uint256);\n  function transfer(address recipient, uint256 amount) external returns (bool);\n  function allowance(address _owner, address spender) external view returns (uint256);\n  function approve(address spender, uint256 amount) external returns (bool);\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"ISelmaNFT.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface ISelmaNFT {\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n}\n"}}