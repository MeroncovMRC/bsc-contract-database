{"AgeOfEmperors.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\n/** Official Links\r\n\r\nWebsite: AgeOfEmperors.com\r\nTelegram: t.me/ageofemperors_chat\r\nGuide: AgeOfEmperors.com/WP.pdf\r\n\r\nAge of Emperors is the first ever strategic P2E game on the Binance Smart Chain Inspired by the world famous PC game: Age of Empires II Â©.\r\nPlayers will build and upgrade the defenses of their own Empire while fighting off an endless onslaught of their empire\u0027s enemies.\r\nWith each horde of enemies defeated, they will drop loot in the form of gold.\r\n\r\n**/\r\n\r\npragma solidity ^0.8.7;\r\npragma experimental ABIEncoderV2;\r\nimport \"./IERC20.sol\";\r\n\r\ncontract AgeOfEmperors {\r\n    struct Tower {\r\n        uint256 crystals;\r\n        uint256 money;\r\n        uint256 money2;\r\n        uint256 yield;\r\n        uint256 timestamp;\r\n        uint256 hrs;\r\n        address ref;\r\n        uint256 refs;\r\n        uint256 refDeps;\r\n        uint8   treasury;\r\n        uint8   market;\r\n        uint8[5] chefs;\r\n        bool[5] bounties;\r\n        bool king;\r\n    }\r\n\r\n    struct Stable {\r\n        uint256 stableBounty;\r\n        uint256 stableTimestamp;\r\n        uint256 stableHrs;\r\n        uint8   stable;\r\n    }\r\n\r\n    mapping(address =\u003e Tower) public towers;\r\n    mapping(address =\u003e Stable) public stables;\r\n\r\n    uint256 public totalChefs;\r\n    uint256 public totalTowers;\r\n    uint256 public totalKings;\r\n    uint256 public totalInvested;\r\n    address public manager;\r\n\r\n    IERC20 constant BUSD_TOKEN = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\r\n\r\n    uint256 immutable public denominator = 10;\r\n    bool public init;\r\n\r\n    modifier initialized {\r\n      require(init, \u0027Not initialized\u0027);\r\n      _;\r\n    }\r\n\r\n    constructor(address manager_) {\r\n       manager = manager_;\r\n    }\r\n\r\n\r\n    function initialize() external {\r\n      require(manager == msg.sender);\r\n      require(!init);\r\n      init = true;\r\n    }\r\n\r\n    function addCrystals(address ref, uint256 value) initialized external {\r\n        uint256 crystals = value / 2e17;\r\n        require(crystals \u003e 0, \"Zero stone\");\r\n        address user = msg.sender;\r\n        totalInvested += value;\r\n        if (towers[user].timestamp == 0) {\r\n            totalTowers++;\r\n            ref = towers[ref].timestamp == 0 ? manager : ref;\r\n            towers[ref].refs++;\r\n            towers[user].ref = ref;\r\n            towers[user].timestamp = block.timestamp;\r\n            towers[user].treasury = 0;\r\n            towers[user].market = 0;\r\n        }\r\n        ref = towers[user].ref;\r\n        uint8 marketId = towers[ref].market;\r\n        (,uint256 refCrystal, uint256 refGold) = getMarket(marketId);\r\n\r\n        towers[ref].crystals += (crystals * refCrystal) / 100;\r\n        towers[ref].money += (crystals * 100 * refGold) / 100;\r\n        towers[ref].refDeps += crystals;\r\n        towers[user].crystals += crystals;\r\n        towers[manager].crystals += (crystals * 5) / 100;\r\n\r\n        uint256 valueToManager = (value * 3) / 100;\r\n        BUSD_TOKEN.transferFrom(msg.sender, manager, valueToManager);\r\n        BUSD_TOKEN.transferFrom(msg.sender, address(this), value - valueToManager);\r\n    }\r\n\r\n    function withdrawMoney(uint256 gold) initialized external {\r\n        address user = msg.sender;\r\n        require(gold \u003c= towers[user].money \u0026\u0026 gold \u003e 0);\r\n        towers[user].money -= gold;\r\n        uint256 amount = gold * 2e15;\r\n        BUSD_TOKEN.transfer(user, BUSD_TOKEN.balanceOf(address(this)) \u003c amount ? BUSD_TOKEN.balanceOf(address(this)) : amount);\r\n    }\r\n\r\n    function kingBounty() initialized external {\r\n        address user = msg.sender;\r\n        require(towers[user].king == false, \"Alread Claimed\");\r\n        require(towers[user].chefs[4] == 6 \u0026\u0026 towers[user].treasury == 4 \u0026\u0026 towers[user].market == 2 \u0026\u0026 stables[user].stable == 3, \"All building must be max level\");\r\n        syncTower(user);\r\n        towers[user].money += 1000000;\r\n        towers[user].king = true;\r\n        totalKings += 1;\r\n    }\r\n\r\n    function collectMoney() public {\r\n        address user = msg.sender;\r\n        syncTower(user);\r\n        towers[user].hrs = 0;\r\n        towers[user].money += towers[user].money2;\r\n        towers[user].money2 = 0;\r\n    }\r\n    \r\n    function collectStableBounty() public {\r\n        address user = msg.sender;\r\n        syncStable(user);\r\n        stables[user].stableHrs = 0;\r\n        towers[user].money += stables[user].stableBounty;\r\n        stables[user].stableBounty = 0;\r\n    }\r\n\r\n    function claimAirdrop(uint256 towerId) initialized external {\r\n        address user = msg.sender;\r\n        syncTower(user);\r\n        require(towers[user].chefs[towerId] == 6, \"Not Max Level\");\r\n        require(towers[user].bounties[towerId] == false, \"Already Claimed\");\r\n        uint256 bounty = getBounty(towerId);\r\n        towers[user].money += bounty;\r\n        towers[user].bounties[towerId] = true;\r\n    }\r\n\r\n    function upgradeTower(uint256 towerId) initialized external {\r\n        require(towerId \u003c 5, \"Max 5 towers\");\r\n        address user = msg.sender;\r\n        if (towerId \u003e 0) {\r\n            require(towers[user].chefs[towerId-1] == 6, \"Prev Tower not upgraded\");\r\n        }\r\n\r\n        syncTower(user);\r\n        towers[user].chefs[towerId]++;\r\n        totalChefs++;\r\n        uint256 chefs = towers[user].chefs[towerId];\r\n        towers[user].crystals -= getUpgradePrice(towerId, chefs) / denominator;\r\n        towers[user].yield += getYield(towerId, chefs);\r\n    }\r\n\r\n    function upgradeTowerMax(uint256 towerId) initialized external {\r\n        require(towerId \u003c 5, \"Max 5 towers\");\r\n        address user = msg.sender;\r\n        if (towerId \u003e 0) {\r\n            require(towers[user].chefs[towerId-1] == 6, \"Prev Tower not upgraded\");\r\n        }\r\n\r\n        syncTower(user);\r\n\r\n        for (uint8 i = towers[user].chefs[towerId]; i \u003c 6; i++) {\r\n            towers[user].chefs[towerId]++;\r\n            totalChefs++;\r\n            uint256 chefs = towers[user].chefs[towerId];\r\n            towers[user].crystals -= getUpgradePrice(towerId, chefs) / denominator;\r\n            towers[user].yield += getYield(towerId, chefs);\r\n        }\r\n    }\r\n\r\n    function upgradeTowncenter() initialized external {\r\n      address user = msg.sender;\r\n      require(towers[user].chefs[0] == 6, \"Tower-1 should be Max Level\");\r\n      uint8 treasuryId = towers[user].treasury + 1;\r\n      syncTower(user);\r\n      require(treasuryId \u003c 5, \"Max 5 treasury\");\r\n      (uint256 price,) = getTreasure(treasuryId);\r\n      towers[user].crystals -= price / denominator; \r\n      towers[user].treasury = treasuryId;\r\n    }\r\n\r\n    function upgradeMarket() initialized external {\r\n      address user = msg.sender;\r\n      require(towers[user].chefs[1] == 6, \"Tower-2 should be Max Level\");\r\n      uint8 marketId = towers[user].market + 1;\r\n      require(marketId \u003c 3, \"Max 2 market\");\r\n      (uint256 price,,) = getMarket(marketId);\r\n      towers[user].crystals -= price / denominator; \r\n      towers[user].market = marketId;\r\n    }\r\n\r\n    function upgradeStable() initialized external {\r\n      address user = msg.sender;\r\n      uint8 stableId = stables[user].stable + 1;\r\n      require(stableId \u003c 4, \"Max 3 stable\");\r\n      (uint256 price,, uint256 towerId) = getStable(stableId);\r\n      require(towers[user].chefs[towerId] == 6, \"Tower should be Max Level\");\r\n      \r\n      towers[user].crystals -= price / denominator; \r\n      stables[user].stable = stableId;\r\n      stables[user].stableTimestamp = block.timestamp;\r\n    }\r\n\r\n    function compound() initialized external {\r\n        address user = msg.sender;\r\n        syncTower(user);\r\n        towers[user].crystals += towers[user].money / 100;\r\n        towers[user].money = 0;\r\n    }\r\n\r\n    function getChefs(address addr) external view returns (uint8[5] memory) {\r\n        return towers[addr].chefs;\r\n    }\r\n    \r\n    function getBounties(address addr) external view returns (bool[5] memory) {\r\n        return towers[addr].bounties;\r\n    }\r\n\r\n    function syncTower(address user) internal {\r\n        require(towers[user].timestamp \u003e 0, \"User is not registered\");\r\n        if (towers[user].yield \u003e 0) {\r\n            (, uint256 treasury) = getTreasure(towers[user].treasury);\r\n            uint256 hrs = block.timestamp / 3600 - towers[user].timestamp / 3600;\r\n            if (hrs + towers[user].hrs \u003e treasury) {\r\n                hrs = treasury - towers[user].hrs;\r\n            }\r\n            towers[user].money2 += hrs * towers[user].yield;\r\n            towers[user].hrs += hrs;\r\n        }\r\n        towers[user].timestamp = block.timestamp;\r\n    }\r\n\r\n    function syncStable(address user) internal {\r\n        require(stables[user].stableTimestamp \u003e 0, \"User Stable is not registered\");\r\n        uint8 stableId = stables[user].stable;\r\n        (,uint256 bounty,) = getStable(stableId);\r\n\r\n        if (bounty \u003e 0) {\r\n            uint256 hrs = block.timestamp / 3600 - stables[user].stableTimestamp / 3600;\r\n            if (hrs + stables[user].stableHrs \u003e 24) {\r\n                hrs = 24 - stables[user].stableHrs;\r\n            }\r\n            stables[user].stableBounty = (hrs + stables[user].stableHrs) / 24 * bounty;\r\n            stables[user].stableHrs += hrs;\r\n        }\r\n        stables[user].stableTimestamp = block.timestamp;\r\n    }\r\n\r\n    function getUpgradePrice(uint256 towerId, uint256 chefId) internal pure returns (uint256) {\r\n        if (chefId == 1) return [600, 3190, 14950, 52500, 150000][towerId];\r\n        if (chefId == 2) return [945, 4025, 20000, 62500, 180000][towerId];\r\n        if (chefId == 3) return [1165, 5900, 27500, 74000, 207500][towerId];\r\n        if (chefId == 4) return [1725, 7600, 37500, 81000, 235000][towerId];\r\n        if (chefId == 5) return [2150, 8350, 41000, 97500, 250000][towerId];\r\n        if (chefId == 6) return [2340, 9050, 47400, 115000, 275000][towerId];\r\n        revert(\"Incorrect chefId\");\r\n    }\r\n\r\n    function getYield(uint256 towerId, uint256 chefId) internal pure returns (uint256) {\r\n        if (chefId == 1) return [5, 29, 147, 555, 1700][towerId];\r\n        if (chefId == 2) return [8, 37, 199, 670, 2060][towerId];\r\n        if (chefId == 3) return [10, 55, 277, 802, 2400][towerId];\r\n        if (chefId == 4) return [15, 72, 383, 889, 2750][towerId];\r\n        if (chefId == 5) return [19, 80, 424, 1080, 3070][towerId];\r\n        if (chefId == 6) return [21, 88, 495, 1290, 3440][towerId];\r\n        revert(\"Incorrect chefId\");\r\n    }\r\n\r\n    function getTreasure(uint256 treasureId) internal pure returns (uint256, uint256) {\r\n      if(treasureId == 0) return (0, 24); // price | hours\r\n      if(treasureId == 1) return (2000, 36);\r\n      if(treasureId == 2) return (2500, 48);\r\n      if(treasureId == 3) return (3000, 60);\r\n      if(treasureId == 4) return (4000, 72);\r\n      revert(\"Incorrect treasureId\");\r\n    }\r\n\r\n    function getMarket(uint256 marketId) internal pure returns (uint256, uint256, uint256) {\r\n      if(marketId == 0) return (0, 4, 2); // price | crystal Ref |  gold Ref\r\n      if(marketId == 1) return (2000, 6, 3);\r\n      if(marketId == 2) return (4000, 8, 4);\r\n      revert(\"Incorrect marketId\");\r\n    }\r\n\r\n    function getBounty(uint256 towerId) internal pure returns (uint256) {\r\n        return [2500, 9500, 50000, 125000, 350000][towerId];\r\n    }\r\n\r\n    function getStable(uint256 stableId) internal pure returns (uint256, uint256, uint256 ) {\r\n        if(stableId == 0) return (0, 0, 0); // price | gold bounty per 24hrs | tower id to max\r\n        if(stableId == 1) return (50000, 25000, 2);\r\n        if(stableId == 2) return (75000, 93750, 3);\r\n        if(stableId == 3) return (100000, 225000, 4);\r\n        revert(\"Incorrect stableId\");\r\n    }\r\n}"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller\u0027s account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}"}}