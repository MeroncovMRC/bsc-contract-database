{"Address.sol":{"content":"pragma solidity ^0.8.1;\n\nlibrary Address {\n\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length \u003e 0;\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}"},"Context.sol":{"content":"pragma solidity ^0.8.0;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}"},"ERC165.sol":{"content":"pragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\nabstract contract ERC165 is IERC165 {\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}"},"ERC721.sol":{"content":"pragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./IERC721Metadata.sol\";\nimport \"./Address.sol\";\nimport \"./Context.sol\";\nimport \"./Strings.sol\";\nimport \"./ERC165.sol\";\n\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    string private _name;\n    string private _symbol;\n\n    // token ID =\u003e owner address\n    mapping(uint256 =\u003e address) private _owners;\n\n    // owner address =\u003e token count\n    mapping(address =\u003e uint256) private _balances;\n\n    // token ID =\u003e approved address  一个tokenId仅能授权一个地址, 后续授权会覆盖\n    mapping(uint256 =\u003e address) private _tokenApprovals;\n\n    // owner operator approvals\n    mapping(address =\u003e mapping(address =\u003e bool)) private _operatorApprovals;\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length \u003e 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    // approve\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()), \"ERC721: approve caller is not owner nor approved for all\");\n        _approve(to, tokenId);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n        return _tokenApprovals[tokenId];\n    }\n\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    // transfer\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _transfer(from, to, tokenId);\n    }\n\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    // mint burn\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 tokenId) internal virtual {}\n}"},"ERC721Burnable.sol":{"content":"pragma solidity ^0.8.0;\n\nimport \"./ERC721.sol\";\nimport \"./Context.sol\";\n\nabstract contract ERC721Burnable is Context, ERC721 {\n    function burn(uint256 tokenId) public virtual {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721Burnable: caller is not owner nor approved\");\n        _burn(tokenId);\n    }\n}"},"ERC721Enumerable.sol":{"content":"pragma solidity ^0.8.0;\n\nimport \"./ERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\n\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // owner  index  tokenId\n    mapping(address =\u003e mapping(uint256 =\u003e uint256)) private _ownedTokens;\n\n    // tokenId   index of the owner tokens list\n    mapping(uint256 =\u003e uint256) private _ownedTokensIndex;\n\n    // Array with all token ids\n    uint256[] private _allTokens;\n\n    // tokenId  position in the allTokens array\n    mapping(uint256 =\u003e uint256) private _allTokensIndex;\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index \u003c ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index \u003c ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // we store the last token in the index of the token to delete, and then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token\u0027s index\n        }\n\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // we store the last token in the index of the token to delete, and then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an \u0027if\u0027 statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token\u0027s index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}"},"ERC721EnumerableURI.sol":{"content":"pragma solidity ^0.8.0;\r\n\r\nimport \"./ERC721Burnable.sol\";\r\nimport \"./ERC721Enumerable.sol\";\r\n\r\nlibrary Math {\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a \u003c b ? a : b;\r\n    }\r\n}\r\n\r\ncontract ERC721EnumerableURI is ERC721Burnable, ERC721Enumerable {\r\n    string private _baseTokenURI;\r\n    \r\n    constructor(string memory _name, string memory _symbol, string memory _initBaseURI) ERC721(_name, _symbol) {\r\n        _setBaseURI(_initBaseURI);\r\n    }\r\n\r\n    function baseTokenURI() public view returns (string memory) {\r\n        return _baseTokenURI;\r\n    }\r\n\r\n    function _baseURI() internal view override returns (string memory) {\r\n        return _baseTokenURI;\r\n    }\r\n\r\n    function _setBaseURI(string memory _newBaseURI) internal virtual {\r\n        _baseTokenURI = _newBaseURI;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return 0;\r\n    }\r\n\r\n    function exists(uint256 tokenId) public view virtual returns (bool) {\r\n        return _exists(tokenId);\r\n    }\r\n\r\n    function tokenOfOwner(address owner, uint256 pageNum, uint256 pageSize) external view returns (uint256[] memory tokenIds, uint256 total) {\r\n        total = balanceOf(owner);\r\n        uint256 from = pageNum*pageSize;\r\n        if (total \u003c= from) {\r\n            return (new uint256[](0), total);\r\n        }\r\n\r\n        uint256 minNum = Math.min(total - from, pageSize);\r\n        tokenIds = new uint256[](minNum);\r\n        \r\n        for(uint256 i = 0; i \u003c minNum; i++){\r\n            tokenIds[i] = tokenOfOwnerByIndex(owner, from++);\r\n        }\r\n    }\r\n\r\n    function tokenOfAll(uint256 pageNum, uint256 pageSize) external view returns (uint256[] memory tokenIds, address[] memory owners, uint256 total) {\r\n        total = totalSupply();\r\n        uint256 from = pageNum*pageSize;\r\n        if (total \u003c= from) {\r\n            return (new uint256[](0), new address[](0), total);\r\n        }\r\n\r\n        uint256 minNum = Math.min(total - from, pageSize);\r\n        tokenIds = new uint256[](minNum);\r\n        owners = new address[](minNum);\r\n\r\n        uint256 tokenId;\r\n        \r\n        for(uint256 i = 0; i \u003c minNum; i++){\r\n            tokenId = tokenByIndex(from++);\r\n            tokenIds[i] = tokenId;\r\n            owners[i] = ownerOf(tokenId);\r\n        }\r\n    }\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override(ERC721, ERC721Enumerable) {\r\n        super._beforeTokenTransfer(from, to, tokenId);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, ERC721Enumerable) returns (bool) {\r\n        return super.supportsInterface(interfaceId);\r\n    }\r\n}"},"ERC721Impl.sol":{"content":"pragma solidity 0.8.17;\r\n\r\nimport \"./ERC721EnumerableURI.sol\";\r\n\r\ncontract Ownable {\r\n    mapping (address =\u003e bool) private ownerShips;\r\n\r\n    constructor () {\r\n        ownerShips[msg.sender] = true;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(ownerShips[msg.sender], \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function addOwnership(address newOwner) public onlyOwner {\r\n        ownerShips[newOwner] = true;\r\n    }\r\n\r\n    function removeOwnership(address oldOwner) public onlyOwner {\r\n        ownerShips[oldOwner] = false;\r\n    }\r\n}\r\n\r\ncontract ERC721Impl is ERC721EnumerableURI, Ownable {\r\n    uint256 public constant maxTotalSupply = 600;\r\n\r\n    string public before3URI;\r\n    string public after3URI;\r\n    \r\n    constructor(string memory _name, string memory _symbol, string memory _initBaseURI) ERC721EnumerableURI(_name, _symbol, _initBaseURI) {\r\n        \r\n    }\r\n\r\n    function setURI(string memory newBefore3URI, string memory newAfter3URI) public onlyOwner {\r\n        before3URI = newBefore3URI;\r\n        after3URI = newAfter3URI;\r\n    }\r\n\r\n    function setBaseURI(string memory _newBaseURI) public onlyOwner {\r\n        _setBaseURI(_newBaseURI);\r\n    }\r\n\r\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\r\n        if(tokenId \u003c 3) {\r\n            return before3URI;\r\n        }\r\n        return after3URI;\r\n    }\r\n\r\n    function multiMint(address[] calldata receiver) external onlyOwner {\r\n        uint256 len = receiver.length;\r\n        uint256 tokenId = totalSupply();\r\n        for(uint256 i; i \u003c len; ++i) {\r\n            _mint(receiver[i], tokenId+i);\r\n        }\r\n        require(totalSupply() \u003c maxTotalSupply, \"max\");\r\n    }\r\n\r\n    function mint(address to, uint256 num) public onlyOwner {\r\n        uint256 tokenId = totalSupply();\r\n        for (uint256 i; i \u003c num; ++i) {\r\n            _mint(to, tokenId+i);\r\n        }\r\n        require(totalSupply() \u003c maxTotalSupply, \"max\");\r\n    }\r\n\r\n    function burn(uint256 tokenId) public pure override {\r\n        require(false, \"no burn\");\r\n    }\r\n}"},"IERC165.sol":{"content":"pragma solidity ^0.8.0;\n\n// Implementers can declare support of contract interfaces, which can then be queried by others ({ERC165Checker}).\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"IERC721.sol":{"content":"pragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\ninterface IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    function approve(address to, uint256 tokenId) external;\n\n    function setApprovalForAll(address operator, bool _approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}"},"IERC721Enumerable.sol":{"content":"pragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\n\ninterface IERC721Enumerable is IERC721 {\n    function totalSupply() external view returns (uint256);\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}"},"IERC721Metadata.sol":{"content":"pragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\n\ninterface IERC721Metadata is IERC721 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}"},"IERC721Receiver.sol":{"content":"pragma solidity ^0.8.0;\n\ninterface IERC721Receiver {\n    // The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}"},"Ownable.sol":{"content":"pragma solidity ^0.8.0;\n\nimport \"./Context.sol\";\n\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}"},"Strings.sol":{"content":"pragma solidity ^0.8.0;\n\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    // Converts a `uint256` to its ASCII `string` decimal representation.\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI\u0027s implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    // Converts a `uint256` to its ASCII `string` hexadecimal representation.\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp \u003e\u003e= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    // Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i \u003e 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value \u0026 0xf];\n            value \u003e\u003e= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}"}}