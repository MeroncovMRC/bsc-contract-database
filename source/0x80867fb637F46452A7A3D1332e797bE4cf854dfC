{"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.3;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() external view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() external virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) external virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}"},"Turus.sol":{"content":"// SPDX-License-Identifier: MIT\n\n/**\n *Submitted for verification at BscScan.com on 2021-04-11\n*/\n\npragma solidity =0.8.3;\n\nimport \u0027Ownable.sol\u0027;\n\ncontract TRS is Ownable {\n    /// @notice EIP-20 token name for this token\n    string public constant name = \"Turus Network\";\n\n    /// @notice EIP-20 token symbol for this token\n    string public constant symbol = \"TRS\";\n\n    /// @notice EIP-20 token decimals for this token\n    uint8 public constant decimals = 18;\n\n    /// @notice Total number of tokens in circulation\n    uint public constant totalSupply = 50000000 * 10**18; // 50 mill TRS\n\n    // @notice Total number of tokens that users in black list own\n    // We need this for correct calculation of fees (to distribute black listed users share)\n    uint public blackListedTokens;\n\n    /// @notice Total number of tokens distributed\n    uint public distributed;\n\n    /// @notice feesPercentage% of each transfer is distributed between all holders of TRS\n    uint8 public feesPercentage = 2; // 2%\n\n    mapping (address =\u003e mapping (address =\u003e uint)) internal allowances;\n\n    mapping (address =\u003e uint) internal balances;\n\n    /// @notice Number of tokens from which user has earned fees\n    mapping (address =\u003e uint) public taxed;\n\n    /// @notice Addresses in this mapping dont receive fees\n    mapping (address =\u003e bool) public feeBlackList;\n\n    /// @notice A record of each accounts delegate\n    mapping (address =\u003e address) public delegates;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint votes;\n    }\n\n    /// @notice A record of votes checkpoints for each account, by index\n    mapping (address =\u003e mapping (uint32 =\u003e Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each account\n    mapping (address =\u003e uint32) public numCheckpoints;\n\n    /// @notice The EIP-712 typehash for the contract\u0027s domain\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    /// @notice A record of states for signing / validating signatures\n    mapping (address =\u003e uint) public nonces;\n\n    /// @notice An event thats emitted when an account changes its delegate\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /// @notice An event thats emitted when a delegate account\u0027s vote balance changes\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\n\n    /// @notice The standard EIP-20 transfer event\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    /// @notice The standard EIP-20 approval event\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /// @notice Emits every time user receive distributed fees\n    event feesAccrued(address indexed account, uint256 amount);\n\n    /// @notice Emits every time user pay fees\n    event feesPaid(address indexed account, uint256 amount);\n\n    /**\n     * @notice Construct a new TRS token\n     */\n    constructor(address[] memory initialFeeBlackList) {\n        balances[msg.sender] = totalSupply;\n        for (uint i = 0; i \u003c initialFeeBlackList.length; i++) {\n            addToFeeBlackList(initialFeeBlackList[i]);\n        }\n\n        emit Transfer(address(0), msg.sender, totalSupply);\n    }\n\n    /**\n     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n     * @param account The address of the account holding the funds\n     * @param spender The address of the account spending the funds\n     * @return The number of tokens approved\n     */\n    function allowance(address account, address spender) external view returns (uint) {\n        return allowances[account][spender];\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (2^256-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint amount) external returns (bool) {\n        // To change the approve amount you first have to reduce the addresses`\n        //  allowance to zero by calling `approve(_spender, 0)` if it is not\n        //  already 0 to mitigate the race condition described here:\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n        require(!((amount != 0) \u0026\u0026 (allowances[msg.sender][spender] != 0)), \"TRS::approve: should set allowance to zero first\");\n\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Get the number of tokens held by the `account`\n     * @param account The address of the account to get the balance of\n     * @return The number of tokens held\n     */\n    function balanceOf(address account) external view returns (uint) {\n        return balances[account] + calculateCollectedFees(account);\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint amount) external returns (bool) {\n        _transferTokens(msg.sender, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(address src, address dst, uint amount) external returns (bool) {\n        _collectFees(msg.sender);\n\n        require(allowances[src][msg.sender] \u003e= amount, \"TRS::transferFrom: transfer amount exceeds spender allowance\");\n\n        uint newAllowance = allowances[src][msg.sender] - amount;\n        allowances[src][msg.sender] = newAllowance;\n\n        emit Approval(src, msg.sender, newAllowance);\n        _transferTokens(src, dst, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {\n        _approve(msg.sender, spender, allowances[msg.sender][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\n        uint currentAllowance = allowances[msg.sender][spender];\n        require(currentAllowance \u003e= subtractedValue, \"TRS::decreaseAllowance: decreased allowance below zero\");\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\n        return true;\n    }\n\n    function addToFeeBlackList(address account) public onlyOwner {\n        require (!feeBlackList[account], \"TRS::addToFeeBlackList: account is already in fee black list\");\n        _collectFees(account);\n        feeBlackList[account] = true;\n        blackListedTokens = blackListedTokens + balances[account];\n    }\n\n    function removeFromBlackList(address account) external onlyOwner {\n        require (feeBlackList[account], \"TRS::removeFromBlackList: account is not in fee black list\");\n        feeBlackList[account] = false;\n        blackListedTokens = blackListedTokens - balances[account];\n    }\n\n    function setFeesPercentage(uint8 number) external onlyOwner {\n        require (number \u003c 100, \"TRS::setFeesPercentage: number should be less than 100\");\n        feesPercentage = number;\n    }\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegatee The address to delegate votes to\n     */\n    function delegate(address delegatee) external {\n        _collectFees(msg.sender);\n        return _delegate(msg.sender, delegatee);\n    }\n\n    /**\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) external {\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"TRS::delegateBySig: invalid signature\");\n        require(nonce == nonces[signatory]++, \"TRS::delegateBySig: invalid nonce\");\n        require(block.timestamp \u003c= expiry, \"TRS::delegateBySig: signature expired\");\n        _collectFees(signatory);\n        return _delegate(signatory, delegatee);\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getCurrentVotes(address account) external view returns (uint) {\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints \u003e 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    }\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(address account, uint blockNumber) external view returns (uint) {\n        require(blockNumber \u003c block.number, \"TRS::getPriorVotes: not yet determined\");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock \u003c= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock \u003e blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper \u003e lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock \u003c blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }\n\n    function _delegate(address delegator, address delegatee) internal {\n        address currentDelegate = delegates[delegator];\n        uint delegatorBalance = balances[delegator];\n        delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function calculateCollectedFees(address account) public view returns (uint256) {\n        if (feeBlackList[account]) {\n            return 0;\n        }\n\n        uint to_tax = distributed - taxed[account];\n        // multiply by 1e12 to avoid zero rounding\n        // we do not count blackListedTokens when calculating share, because black listed users dont receive fees\n        uint user_share = balances[account] * 1e12 / (totalSupply - blackListedTokens);\n        uint accrued_fees = to_tax * user_share / 1e12;\n\n        return accrued_fees;\n    }\n\n    function _collectFees(address account) internal returns (uint256) {\n        uint accrued_fees = calculateCollectedFees(account);\n        balances[account] = balances[account] + accrued_fees;\n        taxed[account] = distributed;\n\n        emit feesAccrued(account, accrued_fees);\n        return accrued_fees;\n    }\n\n    function _calculateFee(uint256 amount) internal view returns (uint256, uint256) {\n        uint fees = amount * feesPercentage / 100;\n        return (amount - fees, fees);\n    }\n\n    function _distribute(uint256 amount) internal {\n        distributed = distributed + amount;\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"TRS::_approve: cannot approve from the zero address\");\n        require(spender != address(0), \"TRS::_approve: cannot approve to the zero address\");\n\n        allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transferTokens(address src, address dst, uint amount) internal {\n        require(src != address(0), \"TRS::_transferTokens: cannot transfer from the zero address\");\n        require(dst != address(0), \"TRS::_transferTokens: cannot transfer to the zero address\");\n\n        // sender collect all fees up to this moment\n        _collectFees(src);\n\n        require(balances[src] \u003e= amount, \"TRS::_transferTokens: transfer amount exceeds balance\");\n\n        (uint clean_amount, uint fees) = _calculateFee(amount);\n\n        balances[src] = balances[src] - amount;\n        if (feeBlackList[src]) {\n            blackListedTokens = blackListedTokens - amount;\n        }\n\n        // receiver get his fee based on his balance before this transfer\n        // sender get his fee based on his balance after this transfer\n        _distribute(fees);\n        _collectFees(dst);\n\n        balances[dst] = balances[dst] + clean_amount;\n        if (feeBlackList[dst]) {\n            blackListedTokens = blackListedTokens + clean_amount;\n        }\n\n        emit feesPaid(src, fees);\n        emit Transfer(src, dst, clean_amount);\n        _moveDelegates(delegates[src], delegates[dst], clean_amount);\n    }\n\n    function _moveDelegates(address srcRep, address dstRep, uint amount) internal {\n        if (srcRep != dstRep \u0026\u0026 amount \u003e 0) {\n            if (srcRep != address(0)) {\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint srcRepOld = srcRepNum \u003e 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint srcRepNew = srcRepOld - amount;\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint dstRepOld = dstRepNum \u003e 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint dstRepNew = dstRepOld + amount;\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\n    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint oldVotes, uint newVotes) internal {\n        if (nCheckpoints \u003e 0 \u0026\u0026 checkpoints[delegatee][nCheckpoints - 1].fromBlock == block.number) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(uint32(block.number), newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\n\n    function getChainId() internal view returns (uint) {\n        uint256 chainId;\n        assembly { chainId := chainid() }\n        return chainId;\n    }\n}"}}