// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

interface IBEP20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 tokens);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract TenWin is IBEP20 {
    string public constant name = "TenWin";
    string public constant symbol = "TWN";
    uint8 public constant decimals = 18;
    uint256 public _initialSupply = 1000000 * 10**18;

    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;
     
    uint256 private constant _maxFees = 10;
    event SetLiquidityFee(uint256 amount);
    event SetMarketingFee(uint256 amount);
    event SetLuckyFee(uint256 amount);
    
    address public _marketingWallet = 0x31a2C52Aa2A137f686Afe34046f619f7Eb9eE7Ed;
    uint256 public _liquidityFee = 2;
    uint256 public _luckyFee = 6;
    uint256 public _marketingFee = 2;
    uint256 public _luckyThreshold = 10;
    address public _luckyFeeAddress = 0xB2A6a547dB215D90d9e68330715009004E47Fa4C; 

    address[] private _recentBuyers;
    uint256 private constant _recentBuyerCount = 10;
    mapping(address => bool) private _isDisqualified;

    constructor() {
        _balances[msg.sender] = _initialSupply;
        emit Transfer(address(0), msg.sender, _initialSupply);
    }

    function totalSupply() public view override returns (uint256) {
        return _initialSupply;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _checkDisqualification(msg.sender);
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function _checkDisqualification(address account) private view {
        require(!_isDisqualified[account], "TWN: Account is disqualified");
    }

    function allowance(address owner, address spender) public view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        _checkDisqualification(sender);
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

        function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] - subtractedValue);
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) private {
        require(sender != address(0), "TWN: transfer from the zero address");
        require(recipient != address(0), "TWN: transfer to the zero address");
        require(_balances[sender] >= amount, "TWN: insufficient balance for transfer");

        uint256 fee = amount * _liquidityFee / 100;
        uint256 luckyAmount = 0;

        if (_luckyFee > 0 && _luckyThreshold > 10) {
            uint256 randomRoll = _getRandomNumber() % _luckyThreshold;

            if (randomRoll == 0) {
                address luckyAddress = _getRandomLuckyAddress();

                luckyAmount = fee * _luckyFee / 100;
                _balances[luckyAddress] += luckyAmount;
                emit Transfer(address(this), luckyAddress, luckyAmount);
            }
        }

        if (_liquidityFee > 2) {
            uint256 marketingFee = fee * _marketingFee / _liquidityFee;
            uint256 luckyFee = fee * _luckyFee / _liquidityFee;

            _balances[_marketingWallet] += marketingFee;
            _balances[_luckyFeeAddress] += luckyFee;

            emit Transfer(sender, _marketingWallet, marketingFee);
            emit Transfer(sender, _luckyFeeAddress, luckyFee);
        }

        uint256 finalAmount = amount - fee - luckyAmount;
        _balances[sender] -= amount;
        _balances[recipient] += finalAmount;

        emit Transfer(sender, recipient, finalAmount);
    }

    function _approve(address owner, address spender, uint256 amount) private {
        require(owner != address(0), "TWN: approve from the zero address");
        require(spender != address(0), "TWN: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _getRandomNumber() private view returns (uint256) {
        uint256 randomNumber = uint256(
            keccak256(abi.encodePacked(block.timestamp, block.number, blockhash(block.number - 1)))
        );
        return randomNumber;
    }
    
    function _getRandomLuckyAddress() private view returns (address) {
        uint256 count = _recentBuyers.length;
        uint256 randomIndex = _getRandomNumber() % count;

        uint256 selectedRandomIndex = randomIndex;

        address luckyAddress = _recentBuyers[selectedRandomIndex];
        return luckyAddress;
    }
    
    function setMarketingWallet(address marketingWallet) external {
        require(marketingWallet != address(0), "TWN: Invalid marketing wallet address");
        require(msg.sender == _marketingWallet, "TWN: Only the current marketing wallet can set a new one");
        _marketingWallet = marketingWallet;
    }
    
    function setLuckyFeeAddress(address luckyFeeAddress) external {
    require(luckyFeeAddress != address(0), "TWN: Invalid lucky fee address");
    require(msg.sender == _luckyFeeAddress, "TWN: Only the current lucky fee address can set a new one");

    _luckyFeeAddress = luckyFeeAddress;
    }

    function setLiquidityFee(uint256 liquidityFee) external {
        require(msg.sender == _marketingWallet, "TWN: Only the current marketing wallet can set the liquidity fee");
        _liquidityFee = liquidityFee;
        emit SetLiquidityFee(liquidityFee);
    }

    function setLuckyFee(uint256 luckyFee) external {
    require(luckyFee <= 10, "TWN: Invalid lucky fee");
    require(msg.sender == _marketingWallet, "TWN: Only the current marketing wallet can set the lucky fee");
    _luckyFee = luckyFee;

    emit SetLuckyFee(luckyFee);
    }


    function setMarketingFee(uint256 marketingFee) external {
        require(marketingFee <= _liquidityFee, "TWN: Invalid marketing fee");
        require(msg.sender == _marketingWallet, "TWN: Only the current marketing wallet can set the marketing fee");
        _marketingFee = marketingFee;
        emit SetMarketingFee(marketingFee);
    }

    function setLuckyThreshold(uint256 luckyThreshold) external {
        require(luckyThreshold >= 10, "TWN: Invalid lucky threshold");
        require(msg.sender == _marketingWallet, "TWN: Only the current marketing wallet can set the lucky threshold");
        _luckyThreshold = luckyThreshold;
    }

    function addRecentBuyer(address buyer) external {
        require(buyer != address(0), "TWN: Invalid buyer address");
        require(msg.sender == _marketingWallet, "TWN: Only the current marketing wallet can add recent buyers");
        
        if (_recentBuyers.length == _recentBuyerCount) {
            // Remove the oldest buyer
            address oldestBuyer = _recentBuyers[0];
            _recentBuyers.pop();
            _isDisqualified[oldestBuyer] = true;
        }
        
        _recentBuyers.push(buyer);
    }
}