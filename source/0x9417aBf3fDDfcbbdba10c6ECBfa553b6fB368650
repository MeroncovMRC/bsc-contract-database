// SPDX-License-Identifier: MIT License
pragma solidity >=0.4.25 <0.9.0;

interface IERC20 {
    function TotalSupply() external view returns (uint256);

    function Decimals() external view returns (uint8);

    function Symbol() external view returns (string memory);

    function Name() external view returns (string memory);

    function GetOwner() external view returns (address);

    function BalanceOf(address account) external view returns (uint256);

    function transfer(
        address recipient,
        uint256 amount
    ) external returns (bool);

    function Allowance(
        address _owner,
        address spender
    ) external view returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
}

library Address {
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }

    function sendValue(address payable recipient, uint256 amount) internal {
        require(
            address(this).balance >= amount, 
            "Address: insufficient balance"
        );
        (bool success, ) = recipient.call{value: amount}("");
        require(
            success, 
            "Address: unable to send value, recipient may have reverted"
        );
    }

    function functionCall(
        address target,
        bytes memory data
    ) internal returns (bytes memory) {
        return functionCall(target, data, "Address: low-level call failed");
    }

    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return
            functionCallWithValue(
                target,
                data,
                value, 
                "Address: low-level call with value failed"
            );
    }

    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(
            address(this).balance >= value, 
            "Address: insufficient balance for call"
        );
        require(isContract(target), "Address: call to non-contract");

        (bool success, bytes memory returndata) = target.call{value: value}(
            data
        );
        return verifyCallResult(success, returndata, errorMessage);
    }

    function functionStaticCall(
        address target,
        bytes memory data
    ) internal view returns (bytes memory) {
        return
            functionStaticCall(
                target,
                data, 
                "Address: low-level static call failed"
            );
    }

    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");

        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    function functionDelegateCall(
        address target,
        bytes memory data
    ) internal returns (bytes memory) {
        return
            functionDelegateCall(
                target,
                data, 
                "Address: low-level delegate call failed"
            );
    }

    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(isContract(target), "Address: delegate call to non-contract");

        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            if (returndata.length > 0) {
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

library SafeERC20 {
    using Address for address;

    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        _callOptionalReturn(
            token,
            abi.encodeWithSelector(token.transfer.selector, to, value)
        );
    }

    function safeTransferFrom(
        IERC20 token,
        address from,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(
            token,
            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)
        );
    }

    function safeApprove(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        require(
            (value == 0) || (token.Allowance(address(this), spender) == 0), 
            "SafeERC20: approve from non-zero to non-zero Allowance"
        );
        _callOptionalReturn(
            token,
            abi.encodeWithSelector(token.approve.selector, spender, value)
        );
    }

    function safeIncreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance = token.Allowance(address(this), spender) + value;
        _callOptionalReturn(
            token,
            abi.encodeWithSelector(
                token.approve.selector,
                spender,
                newAllowance
            )
        );
    }

    function safeDecreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        unchecked {
            uint256 oldAllowance = token.Allowance(address(this), spender);
            require(
                oldAllowance >= value, 
                "SafeERC20: decreased Allowance below zero"
            );
            uint256 newAllowance = oldAllowance - value;
            _callOptionalReturn(
                token,
                abi.encodeWithSelector(
                    token.approve.selector,
                    spender,
                    newAllowance
                )
            );
        }
    }

    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        bytes memory returndata = address(token).functionCall(
            data, 
            "SafeERC20: low-level call failed"
        );
        if (returndata.length > 0) {
            require(
                abi.decode(returndata, (bool)), 
                "SafeERC20: ERC20 operation did not succeed"
            );
        }
    }
}

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(_owner == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    function TransferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) internal {
        require(
            newOwner != address(0), 
            "Ownable: new owner is the zero address"
        );
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

library SafeMath {
    function tryAdd(
        uint256 a,
        uint256 b
    ) internal pure returns (bool, uint256) {
        unchecked {
            uint256 c = a + b;
            if (c < a) return (false, 0);
            return (true, c);
        }
    }

    function trySub(
        uint256 a,
        uint256 b
    ) internal pure returns (bool, uint256) {
        unchecked {
            if (b > a) return (false, 0);
            return (true, a - b);
        }
    }

    function tryMul(
        uint256 a,
        uint256 b
    ) internal pure returns (bool, uint256) {
        unchecked {
            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
            // benefit is lost if 'b' is also tested.
            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
            if (a == 0) return (true, 0);
            uint256 c = a * b;
            if (c / a != b) return (false, 0);
            return (true, c);
        }
    }

    function tryDiv(
        uint256 a,
        uint256 b
    ) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a / b);
        }
    }

    function tryMod(
        uint256 a,
        uint256 b
    ) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a % b);
        }
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return a - b;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        return a * b;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {}
}

contract PeerFinex is Context, Ownable {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    IERC20 public USD;
    address public TokenAddress;

    event _Deposit(address indexed addr, uint256 amount, uint40 tm);
    event _Claim(address indexed addr, uint256 amount);
    event _Refund(address indexed addr, uint256 amount);

    uint8 public IsContractCapped = 0;
    uint8 public IsLeavePFXPaused = 1;

    uint256 private constant DAY = 24 hours;
    uint256 public NumbOfDaysBeforeClaiming = 7;

    uint256 public TotalInvested;
    uint256 public TotalClaimed;
    uint256 public TotalRefunded;
    uint256 public TotalPFXInvests;
    uint256 public TotalPFXProfits;

    struct Tarif {
        uint256 life_days;
        uint256 percent;
    }

    struct Depo {
        uint256 tarif;
        uint256 amount;
        uint40 time;
    }

    struct Player {
        address upline;
        uint256 dividends;
        uint256 user_total_invested;
        uint256 user_total_claimed;
        uint256 user_total_refunded;
        uint40 last_Claimed;
        uint40 last_Deposit;
        Depo[] deposits;
    }

    mapping(address => Player) public Players;

    mapping(uint256 => Tarif) public Tarifs;

    uint public TotalNumbOfWallets;

    constructor() {
        Tarifs[0] = Tarif(36135, 54203);

        TokenAddress = 0x55d398326f99059fF775485246999027B3197955; //BEP20-USDT
        USD = IERC20(TokenAddress);
    }

    function Deposit(uint256 amount) external {
        require(amount >= 100 ether, 
        "A friendly reminder: 100 USDT is the minimum amount to Deposit ");

        require(IsContractCapped <= 0, 
        "The contract is capped, you can't deposit ");

        USD.safeTransferFrom(msg.sender, address(this), amount);

        if (Players[msg.sender].user_total_invested <= 0) {
            TotalNumbOfWallets++;
        }

        Player storage player = Players[msg.sender];

        player.deposits.push(Depo({
            tarif: 0,
            amount: amount,
            time: uint40(block.timestamp)
        }));  
        player.last_Deposit = uint40(block.timestamp);
       

        emit _Deposit(msg.sender, amount, uint40(block.timestamp));

        player.user_total_invested += amount;

        TotalInvested += amount;
    }

    function Claim() external {
        Player storage player = Players[msg.sender];
        require(
            player.user_total_invested >= 0,
        "I thought we need to Deposit first, then we can Claim rewards.. "
        );
        
        require(
            block.timestamp >= (player.last_Claimed + (DAY * NumbOfDaysBeforeClaiming)), 
        "Not satisfied yet? You already Claimed this week "
        );

        getPayout(msg.sender);

        require(
            player.dividends >= 10 ether, 
            "Minimum amount to Claim is 10 USDT"
        );

        uint256 amount = player.dividends;
        player.dividends = 0;

        player.user_total_claimed += amount;

        USD.safeTransfer(msg.sender, amount);
        emit _Claim(msg.sender, amount);

        TotalClaimed += amount;
    }

    function Refund() external {
        Player storage player = Players[msg.sender];
        require(IsLeavePFXPaused <= 0, 
        "Oh! You must wait till the end of the current Cycle, but wait a minute.. already thinking of leaving us?" );
        
        require(player.user_total_invested >= 0, 
        "Apparently, you're not one of our investors yet.. What you're waiting for?");
        
        uint256 refund = player.user_total_invested;

        USD.safeTransfer(msg.sender, refund);
        emit _Refund(msg.sender, refund);

        player.user_total_refunded += refund;
        player.user_total_invested -= refund;
        TotalClaimed += refund;
        TotalRefunded += refund;
    }

    function CalculateClaimable(address _addr) external view returns (uint256 value) {
        Player storage player = Players[_addr];
        if (player.user_total_invested <= 0){ return 0; }

        for (uint256 i = 0; i < player.deposits.length; i++) {
            Depo storage dep = player.deposits[i];
            Tarif storage tarif = Tarifs[dep.tarif];

            uint256 time_end = dep.time + tarif.life_days * 86400;
            uint40 from = player.last_Claimed > dep.time
                ? player.last_Claimed
                : dep.time;
            uint256 to = block.timestamp > time_end
                ? time_end
                : block.timestamp;

            if (from < to) {
                value +=
                    (dep.amount * (to - from) * tarif.percent) /
                    tarif.life_days /
                    8640000;
            }
        }
        return value;
    }

    function getPayout(address _addr) private {
        uint256 payout = this.CalculateClaimable(_addr);

        if (payout > 0) {
            Players[_addr].last_Claimed = uint40(block.timestamp);
            Players[_addr].dividends += payout;
        }
    }

    function SendPFXInvests(
        uint256 amount
     ) public onlyOwner returns (bool success) {
        USD.safeTransfer(msg.sender, amount);
        TotalPFXInvests += amount;
        return true;
    }

    function InjectPFXProfits(uint256 amount) external {
        require(amount >= 1 ether, "Minimum is 1 USDT !");
        USD.safeTransferFrom(msg.sender, address(this), amount);
        TotalPFXProfits += amount;
    }

    function NextClaimTime(
        address _addr
     ) external view returns (uint40 next_sked) {
        Player storage player = Players[_addr];
        if (player.deposits.length > 0) {
            return uint40(player.last_Claimed + (DAY * NumbOfDaysBeforeClaiming));
        }
        return 0;
    }

	function SetWeeklyPercentage(uint256 total_perc) public onlyOwner returns (bool success) {
	    Tarifs[0] = Tarif(36135, total_perc);
        return true;
    }

    function SetContractCapped(uint8 newval) public onlyOwner returns (bool success) {
        IsContractCapped = newval;
        return true;
    }   

    function SetLeavePFXStatus(uint8 newval) public onlyOwner returns (bool success) {
        IsLeavePFXPaused = newval;
        return true;
    } 

    function MemberInfo(
        address _addr
     ) external view returns (uint256 to_claim, uint256 numDeposits) {
        Player storage player = Players[_addr];

        uint256 payout = this.CalculateClaimable(_addr);
        return (payout + player.dividends, player.deposits.length);
    }

    function MemberFirstDeposit(
        address _addr,
        uint256 index
     )
        external
        view
        returns (uint40 time, uint256 amount, uint256 lifedays, uint256 percent)
     {
        Player storage player = Players[_addr];
        Depo storage dep = player.deposits[index];
        Tarif storage tarif = Tarifs[dep.tarif];
        return (dep.time, dep.amount, tarif.life_days, tarif.percent);
    }

    function GetOwner() external view returns (address) {
        return owner();
    }
}