// SPDX-License-Identifier: none

pragma solidity ^0.8.12;

interface BEP20 { 
    function totalSupply() external view returns (uint theTotalSupply);
    function balanceOf(address _owner) external view returns (uint balance);
    function transfer(address _to, uint _value) external returns (bool success);
    function transferFrom(address _from, address _to, uint _value) external returns (bool success);
    function approve(address _spender, uint _value) external returns (bool success);
    function allowance(address _owner, address _spender) external view returns (uint remaining);
    event Transfer(address indexed _from, address indexed _to, uint _value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
}

contract MoneyReceived{
  
  struct Deposit {
    uint tariff;
    uint amount;
    uint at;
  }
  
  struct Investor {
    bool registered;
   Deposit[] deposits;
    uint invested;
    uint paidAt;
    uint withdrawn;
  }
 
  event OwnershipTransferred(address);
  
  address public owner = msg.sender;
             receive() external payable{}

  
  
  uint public totalInvestors;
  uint public totalInvested;
  address public contractAddr = address(this);
  
  mapping (address => Investor) public investors;
  event DepositAt(address user, uint amount);
  event Reinvest(address user, uint tariff, uint amount);
  event Withdraw(address user, uint amount);
  
  constructor() {
    
  }

  function buyproductWithBNB() external payable {
        uint tariff = 0;
        require(msg.value >= 0);
        if(investors[msg.sender].registered){
            require(investors[msg.sender].deposits[0].tariff == tariff);
        }
    
        uint amount = msg.value;
        
        investors[msg.sender].invested += amount;
        totalInvested += amount;
        
        investors[msg.sender].deposits.push(Deposit(tariff, amount, block.timestamp));
        emit DepositAt(msg.sender,  amount);
    } 
    function buyproductWithsitto(uint sittoAmount) external  {
        BEP20 receiveToken = BEP20(0xCA5b9E21e3fCcb6D94937CAAaa22F029EFDfe2D3);//MainNet 
        
        uint sittoAmount = (sittoAmount* 10** 18) ; 
        
        require(receiveToken.balanceOf(msg.sender) >= sittoAmount, "Insufficient user balance");
      
        receiveToken.transferFrom(msg.sender, contractAddr, sittoAmount);
        investors[msg.sender].invested += sittoAmount;
        totalInvested += sittoAmount;
       
        emit DepositAt(msg.sender, sittoAmount);
  } 

      // Owner BNB Withdraw    
    // Only owner can withdraw BNB 
      function withdrawBNB(address payable to, uint amount) public returns(bool) {
        require(msg.sender == owner, "Only owner");
        require(to != address(0), "Cannot send to zero address");
        to.transfer(amount);
        return true;
    }

    // Owner Token Withdraw    
    // Only owner can withdraw token 
      function withdrawToken(address tokenAddress, address to, uint amount) public returns(bool) {
        require(msg.sender == owner, "Only owner");
        require(to != address(0), "Cannot send to zero address");
        BEP20 _token = BEP20(tokenAddress);
        _token.transfer(to, amount);
        return true;
    }
    
    // Ownership Transfer
    // Only owner can call this function
    function transferOwnership(address to) public returns(bool) {
        require(msg.sender == owner, "Only owner");
        require(to != address(0), "Cannot transfer ownership to zero address");
        owner = to;
        emit OwnershipTransferred(to);
        return true;
    }

}