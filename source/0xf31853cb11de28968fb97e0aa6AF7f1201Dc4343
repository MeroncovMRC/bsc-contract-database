// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

contract XENSIM {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    mapping(address => uint256) public stakedBalance;
    mapping(address => uint256) public lastStakeTime;

    uint256 public totalStakedBalance;
    uint256 public epochDuration;
    uint256 public rewardsPerStake;
    uint256 public rewardsDecrementPeriod;
    uint256 public rewardsDecrementFactor;
    uint256 public lastHalvingTime;
    uint256 public halvingInterval;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Staked(address indexed user, uint256 amount);
    event Unstaked(address indexed user, uint256 amount);

    constructor() {
        name = "XENSIM";
        symbol = "XSIM";
        decimals = 18;
        totalSupply = 21000000 * 10**uint256(decimals);

        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transfer(address to, uint256 value) public returns (bool) {
        require(balanceOf[msg.sender] >= value, "Insufficient balance");

        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;

        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool) {
        allowance[msg.sender][spender] = value;

        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        require(balanceOf[from] >= value, "Insufficient balance");
        require(allowance[from][msg.sender] >= value, "Not allowed to transfer");

        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;

        emit Transfer(from, to, value);
        return true;
    }

    function stake(uint256 amount) public {
        require(balanceOf[msg.sender] >= amount, "Insufficient balance");

        balanceOf[msg.sender] -= amount;
        stakedBalance[msg.sender] += amount;
        totalStakedBalance += amount;
        lastStakeTime[msg.sender] = block.timestamp;

        emit Staked(msg.sender, amount);
    }

    function unstake() public {
        require(stakedBalance[msg.sender] > 0, "No tokens staked");

        uint256 stakedAmount = stakedBalance[msg.sender];
        uint256 rewards = calculateRewards(msg.sender);
        uint256 totalAmount = stakedAmount + rewards;

        balanceOf[msg.sender] += totalAmount;
        stakedBalance[msg.sender] = 0;
        totalStakedBalance -= stakedAmount;

        emit Unstaked(msg.sender, totalAmount);
    }

    function calculateRewards(address user) internal view returns (uint256) {
        uint256 stakedAmount = stakedBalance[user];
        uint256 stakeDuration = block.timestamp - lastStakeTime[user];
        uint256 rewards = 0;

        if (stakedAmount > 0 && stakeDuration > 0) {
            rewards = stakedAmount * rewardsPerStake * stakeDuration / epochDuration;

            if (rewardsDecrementPeriod > 0 && block.timestamp >= lastHalvingTime + rewardsDecrementPeriod) {
                rewards = rewards * rewardsDecrementFactor / 100;
            }
        }

        return rewards;
    }
}