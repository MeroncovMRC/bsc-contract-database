{"CryptoChuckler.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.2;\n\nimport \"./SafeMath.sol\";\n\ncontract Token {\n    using SafeMath for uint256;\n\n    mapping(address =\u003e uint256) public balances;\n    mapping(address =\u003e mapping(address =\u003e uint256)) public allowance;\n    uint256 public totalSupply = 100000000000 * 10 ** uint256(18);\n    string public constant name = \"CryptoChuckler\";\n    string public constant symbol = \"CKL\";\n    uint8 public constant decimals = 18;\n\n    address public owner;\n    bool public paused;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Mint(address indexed to, uint256 value);\n    event Burn(address indexed from, uint256 value);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event Paused(bool status);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not the owner\");\n        _;\n    }\n\n    modifier notPaused() {\n        require(!paused, \"Contract is paused\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n        balances[msg.sender] = totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return balances[account];\n    }\n\n    function transfer(address to, uint256 value) public notPaused returns (bool) {\n        require(balances[msg.sender] \u003e= value, \"Insufficient balance\");\n        balances[msg.sender] = balances[msg.sender].sub(value);\n        balances[to] = balances[to].add(value);\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 value) public notPaused returns (bool) {\n        require(balances[from] \u003e= value, \"Insufficient balance\");\n        require(allowance[from][msg.sender] \u003e= value, \"Allowance exceeded\");\n        balances[from] = balances[from].sub(value);\n        balances[to] = balances[to].add(value);\n        allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n        emit Transfer(from, to, value);\n        return true;\n    }\n\n    function approve(address spender, uint256 value) public notPaused returns (bool) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function mint(address to, uint256 value) public onlyOwner notPaused returns (bool) {\n        totalSupply = totalSupply.add(value);\n        balances[to] = balances[to].add(value);\n        emit Mint(to, value);\n        emit Transfer(address(0), to, value);\n        return true;\n    }\n\n    function burn(uint256 value) public notPaused returns (bool) {\n        require(balances[msg.sender] \u003e= value, \"Insufficient balance\");\n        balances[msg.sender] = balances[msg.sender].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Burn(msg.sender, value);\n        emit Transfer(msg.sender, address(0), value);\n        return true;\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0), \"New owner is the zero address\");\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n    function pauseContract() public onlyOwner {\n        paused = true;\n        emit Paused(true);\n    }\n\n    function unpauseContract() public onlyOwner {\n        paused = false;\n        emit Paused(false);\n    }\n}\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.2;\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003e 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        return c;\n    }\n}\n"}}