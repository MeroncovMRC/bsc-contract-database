{"Address.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.1;\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        return account.code.length \u003e 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\r\n        (bool success,) = recipient.call{value : amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value : value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length \u003e 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n"},"Context.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n"},"IBurn.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\ninterface IBurn{\r\n    function burn(uint256 amount) external;\r\n}"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n"},"IRandomNumberGenerator.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\ninterface IRandomNumberGenerator {\r\n    /**\r\n     * Requests randomness from a user-provided seed\r\n     */\r\n    function getRandomNumber(uint256 _seed) external;\r\n    /**\r\n     * View latest lotteryId numbers\r\n     */\r\n    function viewLatestLotteryId() external view returns (uint256);\r\n    /**\r\n     * Views random result\r\n     */\r\n    function viewRandomResult() external view returns (uint32);\r\n}"},"ITeddyLottery.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\ninterface ITeddyLottery {\r\n    /**\r\n     * @notice Buy tickets for the current lottery\r\n     * @param _lotteryId: lotteryId\r\n     * @param _ticketNumbers: array of ticket numbers between 1,000,000 and 1,999,999\r\n     * @dev Callable by users\r\n     */\r\n    function buyTickets(uint256 _lotteryId, uint32[] calldata _ticketNumbers) external;\r\n\r\n    /**\r\n     * @notice Claim a set of winning tickets for a lottery\r\n     * @param _lotteryId: lottery id\r\n     * @param _ticketIds: array of ticket ids\r\n     * @param _brackets: array of brackets for the ticket ids\r\n     * @dev Callable by users only, not contract!\r\n     */\r\n    function claimTickets(\r\n        uint256 _lotteryId,\r\n        uint256[] calldata _ticketIds,\r\n        uint32[] calldata _brackets\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Close lottery\r\n     * @param _lotteryId: lottery id\r\n     * @dev Callable by operator\r\n     */\r\n    function closeLottery(uint256 _lotteryId) external;\r\n\r\n    /**\r\n     * @notice Draw the final number, calculate reward in CAKE per group, and make lottery claimable\r\n     * @param _lotteryId: lottery id\r\n     * @param _autoInjection: reinjects funds into next lottery (vs. withdrawing all)\r\n     * @dev Callable by operator\r\n     */\r\n    function drawFinalNumberAndMakeLotteryClaimable(uint256 _lotteryId, bool _autoInjection) external;\r\n\r\n    /**\r\n     * @notice Inject funds\r\n     * @param _lotteryId: lottery id\r\n     * @param _amount: amount to inject in CAKE token\r\n     * @dev Callable by operator\r\n     */\r\n    function injectFunds(uint256 _lotteryId, uint256 _amount) external;\r\n\r\n    /**\r\n     * @notice Start the lottery\r\n     * @dev Callable by operator\r\n     * @param _endTime: endTime of the lottery\r\n     * @param _priceTicketInCake: price of a ticket in CAKE\r\n     * @param _discountDivisor: the divisor to calculate the discount magnitude for bulks\r\n     * @param _rewardsBreakdown: breakdown of rewards per bracket (must sum to 10,000)\r\n     * @param _treasuryFee: treasury fee (10,000 = 100%, 100 = 1%)\r\n     */\r\n    function startLottery(\r\n        uint256 _endTime,\r\n        uint256 _priceTicketInCake,\r\n        uint256 _discountDivisor,\r\n        uint256[6] calldata _rewardsBreakdown,\r\n        uint256 _treasuryFee\r\n    ) external;\r\n\r\n    /**\r\n     * @notice View current lottery id\r\n     */\r\n    function viewCurrentLotteryId() external returns (uint256);\r\n}\r\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./Context.sol\";\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n"},"ReentrancyGuard.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status;\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n"},"SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./Address.sol\";\r\n\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n    unchecked {\r\n        uint256 oldAllowance = token.allowance(address(this), spender);\r\n        require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\r\n        uint256 newAllowance = oldAllowance - value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n    }\r\n\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length \u003e 0) {\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n"},"TeddyLottery.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./Ownable.sol\";\r\nimport \"./ReentrancyGuard.sol\";\r\nimport \"./IERC20.sol\";\r\nimport \"./SafeERC20.sol\";\r\nimport \"./IRandomNumberGenerator.sol\";\r\nimport \"./ITeddyLottery.sol\";\r\nimport \"./Address.sol\";\r\nimport \"./IBurn.sol\";\r\npragma solidity ^0.8.7;\r\npragma abicoder v2;\r\n\r\n/** @title Lottery.\r\n * @notice It is a contract for a lottery system using\r\n * randomness provided externally.\r\n */\r\ncontract TeddyLottery is ReentrancyGuard, ITeddyLottery, Ownable {\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n    address public injectorAddress=address(0x0a41B812C2d497d8B758F7d1B22F7877b0b9FB63);\r\n    address public operatorAddress=address(0x0a41B812C2d497d8B758F7d1B22F7877b0b9FB63);\r\n    uint256 public currentLotteryId;\r\n    uint256 public currentTicketId;\r\n\r\n    uint256 public maxNumberTicketsPerBuyOrClaim = 100;\r\n\r\n    uint256 public pendingInjectionNextLottery;\r\n\r\n    uint256 public constant MIN_DISCOUNT_DIVISOR = 300;\r\n    uint256 public constant MIN_LENGTH_LOTTERY =  25 minutes; // 2 hours\r\n    uint256 public constant MAX_LENGTH_LOTTERY = 4 days + 5 minutes; // 4 days\r\n    uint256 public constant MAX_TREASURY_FEE = 3000; // 30%\r\n\r\n    IERC20 public teddyToken;\r\n    IRandomNumberGenerator public randomGenerator;\r\n    enum Status {Pending, Open, Close, Claimable}\r\n\r\n    struct Lottery {\r\n        Status status;\r\n        uint256 startTime;\r\n        uint256 endTime;\r\n        uint256 priceTicketInTeddy;\r\n        uint256 discountDivisor;\r\n        uint256[6] rewardsBreakdown; // 0: 1 matching number // 5: 6 matching numbers\r\n        uint256 treasuryFee; // 500: 5% // 200: 2% // 50: 0.5%\r\n        uint256[6] TeddyPerBracket;\r\n        uint256[6] countWinnersPerBracket;\r\n        uint256 firstTicketId;\r\n        uint256 firstTicketIdNextLottery;\r\n        uint256 amountCollectedInTeddy;\r\n        uint32 finalNumber;\r\n    }\r\n\r\n    struct Ticket {\r\n        uint32 number;\r\n        address owner;\r\n    }\r\n\r\n    // Mapping are cheaper than arrays\r\n    mapping(uint256 =\u003e Lottery) private _lotteries;\r\n    mapping(uint256 =\u003e Ticket) private _tickets;\r\n\r\n    // Bracket calculator is used for verifying claims for ticket prizes\r\n    mapping(uint32 =\u003e uint32) private _bracketCalculator;\r\n\r\n    // Keeps track of number of ticket per unique combination for each lotteryId\r\n    mapping(uint256 =\u003e mapping(uint32 =\u003e uint256)) private _numberTicketsPerLotteryId;\r\n\r\n    // Keep track of user ticket ids for a given lotteryId\r\n    mapping(address =\u003e mapping(uint256 =\u003e uint256[])) private _userTicketIdsPerLotteryId;\r\n\r\n    mapping(address =\u003euint256[]) private _userLotteryIds;\r\n    mapping(address =\u003emapping(uint256=\u003ebool)) private _userLotteryIdLogs;\r\n\r\n    modifier notContract() {\r\n        require(!_isContract(msg.sender), \"Contract not allowed\");\r\n        require(msg.sender == tx.origin, \"Proxy contract not allowed\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(msg.sender == operatorAddress, \"Not operator\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerOrInjector() {\r\n        require((msg.sender == owner()) || (msg.sender == injectorAddress), \"Not owner or injector\");\r\n        _;\r\n    }\r\n\r\n    event AdminTokenRecovery(address token, uint256 amount);\r\n    event LotteryClose(uint256 indexed lotteryId, uint256 firstTicketIdNextLottery);\r\n    event LotteryInjection(uint256 indexed lotteryId, uint256 injectedAmount);\r\n    event LotteryOpen(\r\n        uint256 indexed lotteryId,\r\n        uint256 startTime,\r\n        uint256 endTime,\r\n        uint256 priceTicketInTeddy,\r\n        uint256 firstTicketId,\r\n        uint256 injectedAmount\r\n    );\r\n    event LotteryNumberDrawn(uint256 indexed lotteryId, uint256 finalNumber, uint256 countWinningTickets);\r\n    event NewOperatorAndTreasuryAndInjectorAddresses(address operator,  address injector);\r\n    event NewRandomGenerator(address indexed randomGenerator);\r\n    event TicketsPurchase(address indexed buyer, uint256 indexed lotteryId, uint256 numberTickets);\r\n    event TicketsClaim(address indexed claimer, uint256 amount, uint256 indexed lotteryId, uint256 numberTickets);\r\n\r\n    constructor(address _teddyTokenAddress, address _randomGeneratorAddress) {\r\n        teddyToken = IERC20(_teddyTokenAddress);\r\n        randomGenerator = IRandomNumberGenerator(_randomGeneratorAddress);\r\n        // Initializes a mapping\r\n        _bracketCalculator[0] = 1;\r\n        _bracketCalculator[1] = 11;\r\n        _bracketCalculator[2] = 111;\r\n        _bracketCalculator[3] = 1111;\r\n        _bracketCalculator[4] = 11111;\r\n        _bracketCalculator[5] = 111111;\r\n    }\r\n\r\n    function getLoteryIdAndStatus() public view returns (uint256 lotteryId, Status status){\r\n        return (currentLotteryId, _lotteries[currentLotteryId].status);\r\n    }\r\n    /**\r\n     * @notice Buy tickets for the current lottery\r\n     * @param _lotteryId: lotteryId\r\n     * @param _ticketNumbers: array of ticket numbers between 1,000,000 and 1,999,999\r\n     * @dev Callable by users\r\n     */\r\n    function buyTickets(uint256 _lotteryId, uint32[] calldata _ticketNumbers) external override notContract nonReentrant {\r\n        require(_ticketNumbers.length != 0, \"No ticket specified\");\r\n        require(_ticketNumbers.length \u003c= maxNumberTicketsPerBuyOrClaim, \"Too many tickets\");\r\n        require(_lotteries[_lotteryId].status == Status.Open, \"Lottery is not open\");\r\n        require(block.timestamp \u003c _lotteries[_lotteryId].endTime, \"Lottery is over\");\r\n        // Calculate number of Teddy to this contract\r\n        uint256 amountTeddyToTransfer = _calculateTotalPriceForBulkTickets(\r\n            _lotteries[_lotteryId].discountDivisor,\r\n            _lotteries[_lotteryId].priceTicketInTeddy,\r\n            _ticketNumbers.length\r\n        );\r\n\r\n        // Transfer Teddy tokens to this contract\r\n        teddyToken.safeTransferFrom(address(msg.sender), address(this), amountTeddyToTransfer);\r\n\r\n        // Increment the total amount collected for the lottery round\r\n        _lotteries[_lotteryId].amountCollectedInTeddy += amountTeddyToTransfer;\r\n\r\n        for (uint256 i = 0; i \u003c _ticketNumbers.length; i++) {\r\n            uint32 thisTicketNumber = _ticketNumbers[i];\r\n            require((thisTicketNumber \u003e= 1000000) \u0026\u0026 (thisTicketNumber \u003c= 1999999), \"Outside range\");\r\n            _numberTicketsPerLotteryId[_lotteryId][1 + (thisTicketNumber % 10)]++;\r\n            _numberTicketsPerLotteryId[_lotteryId][11 + (thisTicketNumber % 100)]++;\r\n            _numberTicketsPerLotteryId[_lotteryId][111 + (thisTicketNumber % 1000)]++;\r\n            _numberTicketsPerLotteryId[_lotteryId][1111 + (thisTicketNumber % 10000)]++;\r\n            _numberTicketsPerLotteryId[_lotteryId][11111 + (thisTicketNumber % 100000)]++;\r\n            _numberTicketsPerLotteryId[_lotteryId][111111 + (thisTicketNumber % 1000000)]++;\r\n            _userTicketIdsPerLotteryId[msg.sender][_lotteryId].push(currentTicketId);\r\n            _tickets[currentTicketId] = Ticket({number : thisTicketNumber, owner : msg.sender});\r\n            // Increase lottery ticket number\r\n            currentTicketId++;\r\n        }\r\n        if(!_userLotteryIdLogs[msg.sender][_lotteryId]){\r\n            _userLotteryIdLogs[msg.sender][_lotteryId]=true;\r\n            _userLotteryIds[msg.sender].push(_lotteryId);\r\n        }\r\n        emit TicketsPurchase(msg.sender, _lotteryId, _ticketNumbers.length);\r\n    }\r\n\r\n    /**\r\n     * @notice Claim a set of winning tickets for a lottery\r\n     * @param _lotteryId: lottery id\r\n     * @param _ticketIds: array of ticket ids\r\n     * @param _brackets: array of brackets for the ticket ids\r\n     * @dev Callable by users only, not contract!\r\n     */\r\n    function claimTickets(\r\n        uint256 _lotteryId,\r\n        uint256[] calldata _ticketIds,\r\n        uint32[] calldata _brackets\r\n    ) external override notContract nonReentrant {\r\n        require(_ticketIds.length == _brackets.length, \"Not same length\");\r\n        require(_ticketIds.length != 0, \"Length must be \u003e0\");\r\n        require(_ticketIds.length \u003c= maxNumberTicketsPerBuyOrClaim, \"Too many tickets\");\r\n        require(_lotteries[_lotteryId].status == Status.Claimable, \"Lottery not claimable\");\r\n\r\n        // Initializes the rewardInTeddyToTransfer\r\n        uint256 rewardInTeddyToTransfer;\r\n\r\n        for (uint256 i = 0; i \u003c _ticketIds.length; i++) {\r\n            require(_brackets[i] \u003c 6, \"Bracket out of range\");\r\n            // Must be between 0 and 5\r\n\r\n            uint256 thisTicketId = _ticketIds[i];\r\n\r\n            require(_lotteries[_lotteryId].firstTicketIdNextLottery \u003e thisTicketId, \"TicketId too high\");\r\n            require(_lotteries[_lotteryId].firstTicketId \u003c= thisTicketId, \"TicketId too low\");\r\n            require(msg.sender == _tickets[thisTicketId].owner, \"Not the owner\");\r\n\r\n            // Update the lottery ticket owner to 0x address\r\n            _tickets[thisTicketId].owner = address(0);\r\n\r\n            uint256 rewardForTicketId = _calculateRewardsForTicketId(_lotteryId, thisTicketId, _brackets[i]);\r\n\r\n            // Check user is claiming the correct bracket\r\n            require(rewardForTicketId != 0, \"No prize for this bracket\");\r\n\r\n            if (_brackets[i] != 5) {\r\n                require(\r\n                    _calculateRewardsForTicketId(_lotteryId, thisTicketId, _brackets[i] + 1) == 0,\r\n                    \"Bracket must be higher\"\r\n                );\r\n            }\r\n\r\n            // Increment the reward to transfer\r\n            rewardInTeddyToTransfer += rewardForTicketId;\r\n        }\r\n\r\n        // Transfer money to msg.sender\r\n        teddyToken.safeTransfer(msg.sender, rewardInTeddyToTransfer);\r\n\r\n        emit TicketsClaim(msg.sender, rewardInTeddyToTransfer, _lotteryId, _ticketIds.length);\r\n    }\r\n\r\n    /**\r\n     * @notice Close lottery\r\n     * @param _lotteryId: lottery id\r\n     * @dev Callable by operator\r\n     */\r\n    function closeLottery(uint256 _lotteryId) external override onlyOperator nonReentrant {\r\n        require(_lotteries[_lotteryId].status == Status.Open, \"Lottery not open\");\r\n        require(block.timestamp \u003e _lotteries[_lotteryId].endTime, \"Lottery not over\");\r\n        _lotteries[_lotteryId].firstTicketIdNextLottery = currentTicketId;\r\n\r\n        // Request a random number from the generator based on a seed\r\n        randomGenerator.getRandomNumber(uint256(keccak256(abi.encodePacked(_lotteryId, currentTicketId))));\r\n\r\n        _lotteries[_lotteryId].status = Status.Close;\r\n\r\n        emit LotteryClose(_lotteryId, currentTicketId);\r\n    }\r\n\r\n    /**\r\n     * @notice Draw the final number, calculate reward in Teddy per group, and make lottery claimable\r\n     * @param _lotteryId: lottery id\r\n     * @param _autoInjection: reinjects funds into next lottery (vs. withdrawing all)\r\n     * @dev Callable by operator\r\n     */\r\n    function drawFinalNumberAndMakeLotteryClaimable(uint256 _lotteryId, bool _autoInjection)\r\n    external\r\n    override\r\n    onlyOperator\r\n    nonReentrant\r\n    {\r\n        require(_lotteries[_lotteryId].status == Status.Close, \"Lottery not close\");\r\n        require(_lotteryId == randomGenerator.viewLatestLotteryId(), \"Numbers not drawn\");\r\n\r\n        // Calculate the finalNumber based on the randomResult generated by ChainLink\u0027s fallback\r\n        uint32 finalNumber = randomGenerator.viewRandomResult();\r\n\r\n        // Initialize a number to count addresses in the previous bracket\r\n        uint256 numberAddressesInPreviousBracket;\r\n\r\n        // Calculate the amount to share post-treasury fee\r\n        uint256 amountToShareToWinners = (\r\n        ((_lotteries[_lotteryId].amountCollectedInTeddy) * (10000 - _lotteries[_lotteryId].treasuryFee))\r\n        ) / 10000;\r\n\r\n        // Initializes the amount to withdraw to treasury\r\n        uint256 amountToWithdrawToTreasury;\r\n\r\n        // Calculate prizes in Teddy for each bracket by starting from the highest one\r\n        for (uint32 i = 0; i \u003c 6; i++) {\r\n            uint32 j = 5 - i;\r\n            uint32 transformedWinningNumber = _bracketCalculator[j] + (finalNumber % (uint32(10) ** (j + 1)));\r\n\r\n            _lotteries[_lotteryId].countWinnersPerBracket[j] =\r\n            _numberTicketsPerLotteryId[_lotteryId][transformedWinningNumber] -\r\n            numberAddressesInPreviousBracket;\r\n\r\n            // A. If number of users for this _bracket number is superior to 0\r\n            if ((_numberTicketsPerLotteryId[_lotteryId][transformedWinningNumber] - numberAddressesInPreviousBracket) != 0) {\r\n                // B. If rewards at this bracket are \u003e 0, calculate, else, report the numberAddresses from previous bracket\r\n                if (_lotteries[_lotteryId].rewardsBreakdown[j] != 0) {\r\n                    _lotteries[_lotteryId].TeddyPerBracket[j] =\r\n                    ((_lotteries[_lotteryId].rewardsBreakdown[j] * amountToShareToWinners) /\r\n                    (_numberTicketsPerLotteryId[_lotteryId][transformedWinningNumber] -\r\n                    numberAddressesInPreviousBracket)) /\r\n                    10000;\r\n\r\n                    // Update numberAddressesInPreviousBracket\r\n                    numberAddressesInPreviousBracket = _numberTicketsPerLotteryId[_lotteryId][transformedWinningNumber];\r\n                }\r\n                // A. No Teddy to distribute, they are added to the amount to withdraw to treasury address\r\n            } else {\r\n                _lotteries[_lotteryId].TeddyPerBracket[j] = 0;\r\n                amountToWithdrawToTreasury += (_lotteries[_lotteryId].rewardsBreakdown[j] * amountToShareToWinners) / 10000;\r\n            }\r\n        }\r\n\r\n        // Update internal statuses for lottery\r\n        _lotteries[_lotteryId].finalNumber = finalNumber;\r\n        _lotteries[_lotteryId].status = Status.Claimable;\r\n\r\n        if (_autoInjection) {\r\n            pendingInjectionNextLottery = amountToWithdrawToTreasury;\r\n            amountToWithdrawToTreasury = 0;\r\n        }\r\n        amountToWithdrawToTreasury += (_lotteries[_lotteryId].amountCollectedInTeddy - amountToShareToWinners);\r\n        if(amountToWithdrawToTreasury\u003e0){\r\n            address(teddyToken).functionCall(abi.encodeWithSelector(IBurn(address(teddyToken)).burn.selector, amountToWithdrawToTreasury));\r\n        }\r\n        emit LotteryNumberDrawn(currentLotteryId, finalNumber, numberAddressesInPreviousBracket);\r\n    }\r\n\r\n    /**\r\n     * @notice Change the random generator\r\n     * @dev The calls to functions are used to verify the new generator implements them properly.\r\n     * It is necessary to wait for the VRF response before starting a round.\r\n     * Callable only by the contract owner\r\n     * @param _randomGeneratorAddress: address of the random generator\r\n     */\r\n    function changeRandomGenerator(address _randomGeneratorAddress) external onlyOwner {\r\n        require(_lotteries[currentLotteryId].status == Status.Claimable, \"Lottery not in claimable\");\r\n\r\n        // Request a random number from the generator based on a seed\r\n        IRandomNumberGenerator(_randomGeneratorAddress).getRandomNumber(\r\n            uint256(keccak256(abi.encodePacked(currentLotteryId, currentTicketId)))\r\n        );\r\n\r\n        // Calculate the finalNumber based on the randomResult generated by ChainLink\u0027s fallback\r\n        IRandomNumberGenerator(_randomGeneratorAddress).viewRandomResult();\r\n\r\n        randomGenerator = IRandomNumberGenerator(_randomGeneratorAddress);\r\n\r\n        emit NewRandomGenerator(_randomGeneratorAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Inject funds\r\n     * @param _lotteryId: lottery id\r\n     * @param _amount: amount to inject in Teddy token\r\n     * @dev Callable by owner or injector address\r\n     */\r\n    function injectFunds(uint256 _lotteryId, uint256 _amount) external override onlyOwnerOrInjector {\r\n        require(_lotteries[_lotteryId].status == Status.Open, \"Lottery not open\");\r\n        teddyToken.safeTransferFrom(address(msg.sender), address(this), _amount);\r\n        _lotteries[_lotteryId].amountCollectedInTeddy += _amount;\r\n        emit LotteryInjection(_lotteryId, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Start the lottery\r\n     * @dev Callable by operator\r\n     * @param _endTime: endTime of the lottery\r\n     * @param _priceTicketInTeddy: price of a ticket in Teddy\r\n     * @param _discountDivisor: the divisor to calculate the discount magnitude for bulks\r\n     * @param _rewardsBreakdown: breakdown of rewards per bracket (must sum to 10,000)\r\n     * @param _treasuryFee: treasury fee (10,000 = 100%, 100 = 1%)\r\n     */\r\n    function startLottery(\r\n        uint256 _endTime,\r\n        uint256 _priceTicketInTeddy,\r\n        uint256 _discountDivisor,\r\n        uint256[6] calldata _rewardsBreakdown,\r\n        uint256 _treasuryFee\r\n    ) external override onlyOperator {\r\n        require(\r\n            (currentLotteryId == 0) || (_lotteries[currentLotteryId].status == Status.Claimable),\r\n            \"Not time to start lottery\"\r\n        );\r\n\r\n        require(\r\n            ((_endTime - block.timestamp) \u003e MIN_LENGTH_LOTTERY) \u0026\u0026 ((_endTime - block.timestamp) \u003c MAX_LENGTH_LOTTERY),\r\n            \"Lottery length outside of range\"\r\n        );\r\n\r\n\r\n        require(_discountDivisor \u003e= MIN_DISCOUNT_DIVISOR, \"Discount divisor too low\");\r\n        require(_treasuryFee \u003c= MAX_TREASURY_FEE, \"Treasury fee too high\");\r\n\r\n        require(\r\n            (_rewardsBreakdown[0] +\r\n            _rewardsBreakdown[1] +\r\n            _rewardsBreakdown[2] +\r\n            _rewardsBreakdown[3] +\r\n            _rewardsBreakdown[4] +\r\n            _rewardsBreakdown[5]) == 10000,\r\n            \"Rewards must equal 10000\"\r\n        );\r\n\r\n        currentLotteryId++;\r\n\r\n        _lotteries[currentLotteryId] = Lottery({\r\n        status : Status.Open,\r\n        startTime : block.timestamp,\r\n        endTime : _endTime,\r\n        priceTicketInTeddy : _priceTicketInTeddy,\r\n        discountDivisor : _discountDivisor,\r\n        rewardsBreakdown : _rewardsBreakdown,\r\n        treasuryFee : _treasuryFee,\r\n        TeddyPerBracket : [uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0)],\r\n        countWinnersPerBracket : [uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0)],\r\n        firstTicketId : currentTicketId,\r\n        firstTicketIdNextLottery : currentTicketId,\r\n        amountCollectedInTeddy : pendingInjectionNextLottery,\r\n        finalNumber : 0\r\n        });\r\n\r\n        emit LotteryOpen(\r\n            currentLotteryId,\r\n            block.timestamp,\r\n            _endTime,\r\n            _priceTicketInTeddy,\r\n            currentTicketId,\r\n            pendingInjectionNextLottery\r\n        );\r\n\r\n        pendingInjectionNextLottery = 0;\r\n    }\r\n\r\n    /**\r\n     * @notice It allows the admin to recover wrong tokens sent to the contract\r\n     * @param _tokenAddress: the address of the token to withdraw\r\n     * @param _tokenAmount: the number of token amount to withdraw\r\n     * @dev Only callable by owner.\r\n     */\r\n    function recoverWrongTokens(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {\r\n        require(_tokenAddress != address(teddyToken), \"Cannot be Teddy token\");\r\n\r\n        IERC20(_tokenAddress).safeTransfer(address(msg.sender), _tokenAmount);\r\n\r\n        emit AdminTokenRecovery(_tokenAddress, _tokenAmount);\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Set max number of tickets\r\n     * @dev Only callable by owner\r\n     */\r\n    function setMaxNumberTicketsPerBuy(uint256 _maxNumberTicketsPerBuy) external onlyOwner {\r\n        require(_maxNumberTicketsPerBuy != 0, \"Must be \u003e 0\");\r\n        maxNumberTicketsPerBuyOrClaim = _maxNumberTicketsPerBuy;\r\n    }\r\n\r\n    /**\r\n     * @notice Set operator, treasury, and injector addresses\r\n     * @dev Only callable by owner\r\n     * @param _operatorAddress: address of the operator\r\n     * @param _injectorAddress: address of the injector\r\n     */\r\n    function setOperatorAndTreasuryAndInjectorAddresses(\r\n        address _operatorAddress,\r\n        address _injectorAddress\r\n    ) external onlyOwner {\r\n        require(_operatorAddress != address(0), \"Cannot be zero address\");\r\n        require(_injectorAddress != address(0), \"Cannot be zero address\");\r\n\r\n        operatorAddress = _operatorAddress;\r\n        injectorAddress = _injectorAddress;\r\n\r\n        emit NewOperatorAndTreasuryAndInjectorAddresses(_operatorAddress, _injectorAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate price of a set of tickets\r\n     * @param _discountDivisor: divisor for the discount\r\n     * @param _priceTicket price of a ticket (in Teddy)\r\n     * @param _numberTickets number of tickets to buy\r\n     */\r\n    function calculateTotalPriceForBulkTickets(\r\n        uint256 _discountDivisor,\r\n        uint256 _priceTicket,\r\n        uint256 _numberTickets\r\n    ) external pure returns (uint256) {\r\n        require(_discountDivisor \u003e= MIN_DISCOUNT_DIVISOR, \"Must be \u003e= MIN_DISCOUNT_DIVISOR\");\r\n        require(_numberTickets != 0, \"Number of tickets must be \u003e 0\");\r\n\r\n        return _calculateTotalPriceForBulkTickets(_discountDivisor, _priceTicket, _numberTickets);\r\n    }\r\n\r\n    /**\r\n     * @notice View current lottery id\r\n     */\r\n    function viewCurrentLotteryId() external view override returns (uint256) {\r\n        return currentLotteryId;\r\n    }\r\n\r\n    /**\r\n     * @notice View lottery information\r\n     * @param _lotteryId: lottery id\r\n     */\r\n    function viewLottery(uint256 _lotteryId) external view returns (Lottery memory) {\r\n        return _lotteries[_lotteryId];\r\n    }\r\n    /**\r\n     * @notice View ticker statuses and numbers for an array of ticket ids\r\n     * @param _ticketIds: array of _ticketId\r\n     */\r\n    function viewNumbersAndStatusesForTicketIds(uint256[] calldata _ticketIds) external view returns (uint32[] memory, bool[] memory) {\r\n        uint256 length = _ticketIds.length;\r\n        uint32[] memory ticketNumbers = new uint32[](length);\r\n        bool[] memory ticketStatuses = new bool[](length);\r\n\r\n        for (uint256 i = 0; i \u003c length; i++) {\r\n            ticketNumbers[i] = _tickets[_ticketIds[i]].number;\r\n            if (_tickets[_ticketIds[i]].owner == address(0)) {\r\n                ticketStatuses[i] = true;\r\n            } else {\r\n                ticketStatuses[i] = false;\r\n            }\r\n        }\r\n\r\n        return (ticketNumbers, ticketStatuses);\r\n    }\r\n\r\n    /**\r\n     * @notice View rewards for a given ticket, providing a bracket, and lottery id\r\n     * @dev Computations are mostly offchain. This is used to verify a ticket!\r\n     * @param _lotteryId: lottery id\r\n     * @param _ticketId: ticket id\r\n     * @param _bracket: bracket for the ticketId to verify the claim and calculate rewards\r\n     */\r\n    function viewRewardsForTicketId(uint256 _lotteryId, uint256 _ticketId, uint32 _bracket) external view returns (uint256) {\r\n        // Check lottery is in claimable status\r\n        if (_lotteries[_lotteryId].status != Status.Claimable) {\r\n            return 0;\r\n        }\r\n\r\n        // Check ticketId is within range\r\n        if (\r\n            (_lotteries[_lotteryId].firstTicketIdNextLottery \u003c _ticketId) \u0026\u0026\r\n            (_lotteries[_lotteryId].firstTicketId \u003e= _ticketId)\r\n        ) {\r\n            return 0;\r\n        }\r\n\r\n        return _calculateRewardsForTicketId(_lotteryId, _ticketId, _bracket);\r\n    }\r\n\r\n\r\n    function viewUserLengthForLotteryId(address _user, uint256 _lotteryId) external view returns (uint256) {\r\n        return _userTicketIdsPerLotteryId[_user][_lotteryId].length;\r\n    }\r\n    /**\r\n     * @notice View user ticket ids, numbers, and statuses of user for a given lottery\r\n     * @param _user: user address\r\n     * @param _lotteryId: lottery id\r\n     * @param _cursor: cursor to start where to retrieve the tickets\r\n     * @param _size: the number of tickets to retrieve\r\n     */\r\n    function viewUserInfoForLotteryId(\r\n        address _user,\r\n        uint256 _lotteryId,\r\n        uint256 _cursor,\r\n        uint256 _size\r\n    )\r\n    external\r\n    view\r\n    returns (\r\n        uint256[] memory,\r\n        uint32[] memory,\r\n        bool[] memory,\r\n        uint256\r\n    )\r\n    {\r\n        uint256 length = _size;\r\n        uint256 numberTicketsBoughtAtLotteryId = _userTicketIdsPerLotteryId[_user][_lotteryId].length;\r\n\r\n        if (length \u003e (numberTicketsBoughtAtLotteryId - _cursor)) {\r\n            length = numberTicketsBoughtAtLotteryId - _cursor;\r\n        }\r\n\r\n        uint256[] memory lotteryTicketIds = new uint256[](length);\r\n        uint32[] memory ticketNumbers = new uint32[](length);\r\n        bool[] memory ticketStatuses = new bool[](length);\r\n\r\n        for (uint256 i = 0; i \u003c length; i++) {\r\n            lotteryTicketIds[i] = _userTicketIdsPerLotteryId[_user][_lotteryId][i + _cursor];\r\n            ticketNumbers[i] = _tickets[lotteryTicketIds[i]].number;\r\n\r\n            // True = ticket claimed\r\n            if (_tickets[lotteryTicketIds[i]].owner == address(0)) {\r\n                ticketStatuses[i] = true;\r\n            } else {\r\n                // ticket not claimed (includes the ones that cannot be claimed)\r\n                ticketStatuses[i] = false;\r\n            }\r\n        }\r\n\r\n        return (lotteryTicketIds, ticketNumbers, ticketStatuses, _cursor + length);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate rewards for a given ticket\r\n     * @param _lotteryId: lottery id\r\n     * @param _ticketId: ticket id\r\n     * @param _bracket: bracket for the ticketId to verify the claim and calculate rewards\r\n     */\r\n    function _calculateRewardsForTicketId(\r\n        uint256 _lotteryId,\r\n        uint256 _ticketId,\r\n        uint32 _bracket\r\n    ) internal view returns (uint256) {\r\n        // Retrieve the winning number combination\r\n        uint32 userNumber = _lotteries[_lotteryId].finalNumber;\r\n\r\n        // Retrieve the user number combination from the ticketId\r\n        uint32 winningTicketNumber = _tickets[_ticketId].number;\r\n\r\n        // Apply transformation to verify the claim provided by the user is true\r\n        uint32 transformedWinningNumber = _bracketCalculator[_bracket] +\r\n        (winningTicketNumber % (uint32(10) ** (_bracket + 1)));\r\n\r\n        uint32 transformedUserNumber = _bracketCalculator[_bracket] + (userNumber % (uint32(10) ** (_bracket + 1)));\r\n\r\n        // Confirm that the two transformed numbers are the same, if not throw\r\n        if (transformedWinningNumber == transformedUserNumber) {\r\n            return _lotteries[_lotteryId].TeddyPerBracket[_bracket];\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate final price for bulk of tickets\r\n     * @param _discountDivisor: divisor for the discount (the smaller it is, the greater the discount is)\r\n     * @param _priceTicket: price of a ticket\r\n     * @param _numberTickets: number of tickets purchased\r\n     */\r\n    function _calculateTotalPriceForBulkTickets(\r\n        uint256 _discountDivisor,\r\n        uint256 _priceTicket,\r\n        uint256 _numberTickets\r\n    ) internal pure returns (uint256) {\r\n        return (_priceTicket * _numberTickets * (_discountDivisor + 1 - _numberTickets)) / _discountDivisor;\r\n    }\r\n\r\n    function _isContract(address _addr) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {size := extcodesize(_addr)}\r\n        return size \u003e 0;\r\n    }\r\n\r\n    function viewUserTotalLotteryId(address _user) external view returns (uint256) {\r\n        return _userLotteryIds[_user].length ;\r\n    }\r\n\r\n    function viewUserLotteryId(address _user,uint256 _cursor, uint256 _size) external view returns (uint256[] memory,uint256){\r\n        uint256 length = _size;\r\n        if (length \u003e (_userLotteryIds[_user].length- _cursor)) {\r\n            length = _userLotteryIds[_user].length - _cursor;\r\n        }\r\n        uint256[] memory list = new uint256[](length);\r\n        for (uint256 i = 0; i \u003c length; i++) {\r\n            list[i] = _userLotteryIds[_user][i + _cursor];\r\n        }\r\n        return (list, _cursor + length);\r\n    }\r\n}\r\n"},"VRFConsumerBaseV2.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.7;\r\nabstract contract VRFConsumerBaseV2 {\r\n  error OnlyCoordinatorCanFulfill(address have, address want);\r\n  address private immutable vrfCoordinator;\r\n  constructor(address _vrfCoordinator) {\r\n    vrfCoordinator = _vrfCoordinator;\r\n  }\r\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\r\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\r\n    if (msg.sender != vrfCoordinator) {\r\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\r\n    }\r\n    fulfillRandomWords(requestId, randomWords);\r\n  }\r\n}"},"VRFCoordinatorV2Interface.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.7;\r\n\r\ninterface VRFCoordinatorV2Interface {\r\n  function getRequestConfig() external view returns (uint16, uint32, bytes32[] memory);\r\n  function requestRandomWords(bytes32 keyHash,uint64 subId,uint16 minimumRequestConfirmations,uint32 callbackGasLimit,uint32 numWords) external returns (uint256 requestId);\r\n  function createSubscription() external returns (uint64 subId);\r\n  function getSubscription(uint64 subId) external view returns (uint96 balance, uint64 reqCount, address owner, address[] memory consumers);\r\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\r\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\r\n  function addConsumer(uint64 subId, address consumer) external;\r\n  function removeConsumer(uint64 subId, address consumer) external;\r\n  function cancelSubscription(uint64 subId, address to) external;\r\n  function pendingRequestExists(uint64 subId) external view returns (bool);\r\n}"}}