{"CarbonRouter.sol":{"content":"// SPDX-License-Identifier: --?--\n\npragma solidity ^0.8.0;\n\nimport \"./SafeMath.sol\";\n\n// Get a link to treedefi collectibles BEP721\ninterface ITreedefiForest {\n    \n    // returns address of treedefi owner\n    function getOwner() external view returns (address);\n\n}\n\n// Get a link to treedefi collectibles Registry\ninterface ITreedefiRegistry {\n    \n    // generates green bonds for given epoch\n    function generateGreenBond(\n        uint256 epochIndex_,\n        uint256 greenBond_,\n        address to_\n    ) external payable;\n\n}\n\n// Get a link to green linker\ninterface IGreenLinker {\n    \n  // mint CO2 credit tokens for given epoch    \n  function mintGreenBondCO2(\n    address to_,\n    uint256 amount_,\n    uint256 epochIndex_\n  ) external;\n\n}\n\n/**\n * @title Treedefi Carbon Router Version 1.0\n *\n * @author treedefi\n */\ncontract CarbonRouter {\n      \n  using SafeMath for uint256;    \n  \n  // Address of treedefi owner\n  address private _owner;\n  \n  // Link to treedefi collectibles\n  ITreedefiForest public NFTREE;\n  \n  // Link to treedefi collectibles registry\n  ITreedefiRegistry public REG;\n  \n  // Link to green linker V1\n  IGreenLinker public LINKER;\n  \n  // Fee for green bond registration\n  uint256 public greenBondFee;\n \n  // To check re-entrancy\n  bool internal _locked;\n  \n  // Checks re-entrancy\n  modifier noReentrant() {\n        require(!_locked, \"No re-entrancy\");\n        _locked = true;\n        _;\n        _locked = false;\n  }\n\n\n  /**\n\t * @dev Creates/deploys treedefi carbon router version 1.0\n\t *\n\t * @param nftree_ address of treedefi collectibles\n\t * @param reg_ address of treedefi collectibles registry\n\t * @param linker_ address of green linker v1\n\t */\n  constructor(address nftree_, address reg_, address linker_) \n  {\n     // verify inputs are set\n\t require(nftree_ != address(0), \"Treedefi: Treedefi Collectibles address is not set\");\n\t require(reg_ != address(0), \"Treedefi: Treedefi Collectibles Registry address is not set\");\n\t require(linker_ != address(0), \"Treedefi: Green Linker address is not set\");\n\t \n\t // setup smart contract internal state\n     NFTREE = ITreedefiForest(nftree_);\n     REG = ITreedefiRegistry(reg_);\n     LINKER = IGreenLinker(linker_);\n     _owner = NFTREE.getOwner();\n     \n  }\n\n\n  /**\n    * @dev Returns the address of treedefi owner.\n    */\n  function getOwner() external view returns (address) {\n        return _owner;\n  }\n\n  /** @notice upgrades admin address to existing NFTREE V2 owner\n     *        as ownership of NFTREE V2 is transferable\n     */\n  function upgradeOwnerAddress() external {\n    _owner = NFTREE.getOwner();\n  }\n\n  \n  /** @dev Sets fee for green bond generation\n     *\n     *@notice restricted access function \n     *@param fee_ unsigned integer defines fee\n     */\n  function setGreenBondFee(\n     uint256 fee_\n  ) \n    external \n  {\n      \n     require(\n      msg.sender == _owner,\n      \"Treedefi: Only Owner can set fee\"\n      );\n      \n     greenBondFee = fee_;\n     \n  }\n  \n  \n  /** @dev Register green bond and mint CO2 credit tokens for given epoch\n     * \n     *@param epochIndex_ array defines index of epoch\n     *@param greenBond_ array defines number of tokens\n     */\n  function generateCarbonTokens(\n     uint256[] memory epochIndex_,\n     uint256[] memory greenBond_\n  )   \n    external\n    payable\n    noReentrant \n  {\n     \n     // fetch array length \n     uint256 _length = epochIndex_.length;\n     \n     require(greenBond_.length == _length, \"Treedefi: Invalid inputs\");\n     \n     require(_length \u003c 11, \"Treedefi: Too many inputs\");\n     \n     // calculates total payable amount\n     uint256 _fee = calculateFee(greenBond_);\n      \n     require(\n       msg.value \u003e= _fee,\n       \"Treedefi: Provided value is not enough to generate carbon tokens\"\n     );\n     \n     for(uint8 i; i \u003c _length; i++) {\n        // register token assignment for given epoch\n        REG.generateGreenBond(epochIndex_[i], greenBond_[i], msg.sender);\n        \n        // mint new tokens for given epoch\n        LINKER.mintGreenBondCO2(msg.sender, greenBond_[i].mul(1e15), epochIndex_[i]);\n        \n     }\n              \n  }\n  \n  /** @dev Calculates total fees to generate given amount of tokens\n     * \n     *@param greenBond_ array defines amount of tokens\n     */\n  function calculateFee(\n    uint256[] memory greenBond_\n  )\n    internal\n    view\n    returns (uint256 fee_)\n  {\n    \n    uint256 _total;\n    \n    for(uint8 i; i \u003c greenBond_.length; i++) {\n        _total = _total.add(greenBond_[i]);   \n    }\n    \n    fee_ = _total.mul(greenBondFee);\n    \n  }    \n  \n  // withdraw the earnings :-)\n  function withdraw() external {\n      \n    require(\n      msg.sender == _owner,\n      \"Treedefi: Only Owner can withdraw funds\"\n    );\n    \n    // Fetch current balance of Nftree V2 contract  \n\tuint256 balance = address(this).balance;\n\t\n\t// Transfer current balance to owner\u0027s address \n\tpayable(msg.sender).transfer(balance);\n  \n  }\n  \n}\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler\u0027s built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations.\n *\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c \u003c a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b \u003e a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n            // benefit is lost if \u0027b\u0027 is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003c= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003e 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003e 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"}}