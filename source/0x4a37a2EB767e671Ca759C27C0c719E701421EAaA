{"EleventhWorld.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.5;\n\nimport \"./String.sol\";\n\ninterface WETH {\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\ncontract EleventhWorld {\n    mapping(address =\u003e uint) public userBalance;\n    mapping(address =\u003e uint) public userClaimed;\n    mapping(string =\u003e address) public rmIdToUser; //get owner from room id\n    mapping(string =\u003e uint8) public rmIdToType; //get room type from room id\n    mapping(uint8 =\u003e bool) public roomStatus;\n    mapping(address =\u003e mapping(uint8 =\u003e uint)) public userOwnedRmsNum; //get number of room that user owned by room type and roomId\n    mapping(address =\u003estring[]) internal userRms; //get user owned room from room type and roomId\n    mapping(uint8 =\u003e uint256) public roomTypeToRoomFee;\n    mapping(uint8 =\u003e string) internal roomTypeToCode;\n\n    event Deposit(address userAddress, uint256 ETH);\n    event Withdraw(address userAddress, uint256 ETH, uint256 BETCOIN);\n    event WithdrawList(address[] users, uint256[] ETH, uint256[] BETCOIN);\n    event CreateRoom(address user, uint8 roomType, string roomId);\n    event GovCreateRoom(address user, uint8 roomType, string roomId);\n\n    address public owner;\n    uint256 public processFee;\n    uint256 public totalRoomNumber;\n    uint256 public maxRoomNumber;\n    uint256 public exchangeRateETH;\n    uint256 public exchangeRateBetcoin;\n\n    address public WETHAddress;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Caller is not the owner\");\n        _;\n    }\n\n    constructor(address _WETHAddress) {\n        owner = msg.sender;\n        processFee = 35 * 10 ** 14;\n        roomTypeToRoomFee[1] = 0;\n        roomTypeToCode[1] = \"S\";\n        roomTypeToCode[2] = \"M\";\n        roomTypeToCode[3] = \"L\";\n        roomTypeToRoomFee[2] = 1 * 10 ** 16;\n        roomTypeToRoomFee[3] = 1 * 10 ** 17;\n        totalRoomNumber = 0;\n        maxRoomNumber = 1;\n        exchangeRateETH = 7_000_000_000_000_000;\n        exchangeRateBetcoin = 10_000_000;\n        WETHAddress = _WETHAddress;\n    }\n\n    function deposit(uint256 _WETH) public {\n        uint256 _BETCOIN = exchangeRateBetcoin / exchangeRateETH * _WETH;\n        require(_BETCOIN % 10 == 0, \"deposit amount needs to be a multiple of 10.\");\n\n        require(WETH(WETHAddress).transferFrom(msg.sender, address(this), _WETH), \"weth transfer error\");\n\n        userBalance[msg.sender] += _WETH;\n        emit Deposit(msg.sender, _WETH);\n    }\n\n    function withdraw(address _claimer, uint256 _BETCOIN) public onlyOwner {\n        require(_BETCOIN % 10 == 0, \"withdrawal needs to be a multiple of 10.\");\n\n        uint256 _claim = _BETCOIN * exchangeRateETH / exchangeRateBetcoin;\n        require(_claim - processFee \u003e 0, \"value does not reach the minimum withdrawal amount\");\n\n        require(WETH(WETHAddress).transfer(owner, processFee), \"[process fee] weth transfer error\");\n        require(WETH(WETHAddress).transfer(_claimer, _claim - processFee), \"[claim fee] weth transfer error\");\n        userClaimed[_claimer] += _claim;\n        emit Withdraw(_claimer, _claim - processFee, _BETCOIN);\n    }\n\n    function withdrawList(address[] memory _claimers, uint256[] memory _BETCOINs) public onlyOwner {\n        require(_claimers.length == _BETCOINs.length, \"Array input lengths do not match.\");\n\n        uint256[] memory _claimFees = new uint256[](_claimers.length);\n        uint256 _totalProcessFee = 0;\n\n        for(uint i = 0; i \u003c _claimers.length; i++) {\n            require(_BETCOINs[i] % 10 == 0, \"(list) withdraw betcoin needs to be a multiple of 10.\");\n\n            uint256 _claim = _BETCOINs[i] * exchangeRateETH / exchangeRateBetcoin;\n            require(_claim - processFee \u003e 0, \"value does not reach the minimum withdrawal amount\");\n\n            require(WETH(WETHAddress).transfer(_claimers[i], _claim - processFee), \"[claim fee] weth transfer error\");\n            userClaimed[_claimers[i]] += _claim;\n            _claimFees[i] = _claim - processFee;\n            _totalProcessFee += processFee;\n        }\n        require(WETH(WETHAddress).transfer(owner, _totalProcessFee), \"[process fee] weth transfer error\");\n\n        emit WithdrawList(_claimers, _claimFees, _BETCOINs);\n    }\n\n    function updateProcessFee(uint256 _fee) public onlyOwner {\n        processFee = _fee;\n    }\n\n    function updateMaxRoomNumber(uint256 _maxNumber) public onlyOwner {\n        maxRoomNumber = _maxNumber;\n    }\n\n    function updateRoomFee(uint256 _fee, uint8 _roomType) public onlyOwner {\n        //1 = small, 2 = middle, 3 = large\n        roomTypeToRoomFee[_roomType] = _fee;\n    }\n\n    function updateExchangeRate(uint256 _exchangeRateETH, uint256 _exchangeRateBetcoin) public onlyOwner {\n        exchangeRateETH = _exchangeRateETH;\n        exchangeRateBetcoin = _exchangeRateBetcoin;\n    }\n\n    function createRoom(uint8 _roomType) public {\n        require(roomStatus[_roomType], \"The selected room type is currently unavailable\");\n        require(userOwnedRmsNum[msg.sender][_roomType] \u003c maxRoomNumber, \"user has reached the maximum number of created rooms\");\n\n        //1 = small, 2 = middle, 3 = large\n        require(WETH(WETHAddress).transferFrom(msg.sender, address(this), roomTypeToRoomFee[_roomType]), \"weth transfer error\");\n\n        string memory _roomId = string.concat(roomTypeToCode[_roomType], getTime(), \"_\", Strings.toString(totalRoomNumber));\n        totalRoomNumber += 1;\n\n        rmIdToUser[_roomId] = msg.sender;\n        rmIdToType[_roomId] = _roomType;\n        userRms[msg.sender].push(_roomId);\n        userOwnedRmsNum[msg.sender][_roomType]++;\n\n        emit CreateRoom(msg.sender, _roomType, _roomId);\n    }\n\n    function govRoom(address _ownerAddress) external onlyOwner {\n        uint8 _roomType = 0;\n\n        string memory _roomCode = \"C\";\n        string memory _roomId = string.concat(_roomCode, getTime(), \"_\", Strings.toString(totalRoomNumber));\n        totalRoomNumber += 1;\n\n        rmIdToUser[_roomId] = _ownerAddress;\n        rmIdToType[_roomId] = _roomType;\n        userRms[_ownerAddress].push(_roomId);\n        userOwnedRmsNum[_ownerAddress][_roomType]++;\n\n        emit GovCreateRoom(_ownerAddress, _roomType, _roomId);\n    }\n\n    function updateRoomStatus(uint8 _roomType, bool status) external onlyOwner {\n        roomStatus[_roomType] = status;\n    }\n\n    //return date time in string (U.K)\n    function getTime() internal view returns (string memory _date) {\n        uint _year;\n        uint _month;\n        uint _day;\n        uint _hour;\n        uint _minute;\n        uint _second;\n\n        (_year, _month, _day, _hour, _minute, _second) = timestampToDateTime(block.timestamp);\n        _date = string.concat(Strings.toString(_year), Strings.toString(_month), Strings.toString(_day), Strings.toString(_hour), Strings.toString(_minute), Strings.toString(_second));\n    }\n\n\n    //functions from https://github.com/RollaProject/solidity-datetime/blob/master/contracts/TestDateTime.sol\n    function _daysToDate(uint256 _days) internal pure returns (uint256 year, uint256 month, uint256 day) {\n        unchecked {\n            int256 OFFSET19700101 = 2440588;\n\n            int256 __days = int256(_days);\n\n            int256 L = __days + 68569 + OFFSET19700101;\n            int256 N = (4 * L) / 146097;\n            L = L - (146097 * N + 3) / 4;\n            int256 _year = (4000 * (L + 1)) / 1461001;\n            L = L - (1461 * _year) / 4 + 31;\n            int256 _month = (80 * L) / 2447;\n            int256 _day = L - (2447 * _month) / 80;\n            L = _month / 11;\n            _month = _month + 2 - 12 * L;\n            _year = 100 * (N - 49) + _year + L;\n\n            year = uint256(_year);\n            month = uint256(_month);\n            day = uint256(_day);\n        }\n    }\n\n    function timestampToDateTime(uint256 timestamp)\n        internal\n        pure\n        returns (uint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute, uint256 second)\n    {\n        uint256 SECONDS_PER_DAY = 24 * 60 * 60;\n        uint256 SECONDS_PER_HOUR = 60 * 60;\n        uint256 SECONDS_PER_MINUTE = 60;\n\n        unchecked {\n            (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n            uint256 secs = timestamp % SECONDS_PER_DAY;\n            hour = secs / SECONDS_PER_HOUR;\n            secs = secs % SECONDS_PER_HOUR;\n            minute = secs / SECONDS_PER_MINUTE;\n            second = secs % SECONDS_PER_MINUTE;\n        }\n    }\n\n    function addRoomSize(uint8 _roomType, uint256 _roomFee, string memory _roomCode) external onlyOwner {\n        roomTypeToRoomFee[_roomType] = _roomFee;\n        roomTypeToCode[_roomType] = _roomCode;\n    }\n\n    //show all room id\n    function displayUserRooms(address _user) external view returns (string[] memory) {\n        return userRms[_user];\n    }\n\n    function govWithdraw(uint _withdrawValue) external onlyOwner {\n        require(WETH(WETHAddress).transfer(owner, _withdrawValue));\n    }\n\n    function updateWETHContractAddress(address _WETHAddress) external onlyOwner {\n        WETHAddress = _WETHAddress;\n    }\n}"},"String.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI\u0027s implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp \u003e\u003e= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i \u003e 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value \u0026 0xf];\n            value \u003e\u003e= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"}}