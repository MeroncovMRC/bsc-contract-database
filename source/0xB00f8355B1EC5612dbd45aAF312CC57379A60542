// SPDX-License-Identifier: MIT

pragma solidity 0.8.19;

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {return a + b;}
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {return a - b;}
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {return a * b;}
    function div(uint256 a, uint256 b) internal pure returns (uint256) {return a / b;}
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {return a % b;}
    
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {uint256 c = a + b; if(c < a) return(false, 0); return(true, c);}}

    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {if(b > a) return(false, 0); return(true, a - b);}}

    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {if (a == 0) return(true, 0); uint256 c = a * b;
        if(c / a != b) return(false, 0); return(true, c);}}

    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {if(b == 0) return(false, 0); return(true, a / b);}}

    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {if(b == 0) return(false, 0); return(true, a % b);}}

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        unchecked{require(b <= a, errorMessage); return a - b;}}

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        unchecked{require(b > 0, errorMessage); return a / b;}}

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        unchecked{require(b > 0, errorMessage); return a % b;}}}

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function decimals() external view returns (uint8);
    function symbol() external view returns (string memory);
    function name() external view returns (string memory);
    function getOwner() external view returns (address);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address _owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);}

interface DAPP {
    function disperseTokenPercent(address token, address receiver, uint256 amount) external;
    function disperseTokenAmount(address token, address receiver, uint256 amount) external;
    function rescueETH(uint256 amountPercentage) external;
}

abstract contract Auth {
    address internal owner;
    mapping (address => bool) internal authorizations;
    constructor(address _owner) {owner = _owner; authorizations[_owner] = true; }
    modifier onlyOwner() {require(isOwner(msg.sender), "!OWNER"); _;}
    modifier authorized() {require(isAuthorized(msg.sender), "!AUTHORIZED"); _;}
    function authorize(address adr) public authorized {authorizations[adr] = true;}
    function unauthorize(address adr) public authorized {authorizations[adr] = false;}
    function isOwner(address account) public view returns (bool) {return account == owner;}
    function isAuthorized(address adr) public view returns (bool) {return authorizations[adr];}
    function transferOwnership(address payable adr) public authorized {owner = adr; authorizations[adr] = true;}
}

contract Migration is DAPP, Auth {
    using SafeMath for uint256;
    mapping (address => uint256) public migrationAvailable;
    mapping (address => uint256) public migrationClaimed;
    uint256 public tokenClaimed;
    IERC20 public migrationToken;

    constructor() Auth(msg.sender) {
        migrationToken = IERC20(0x3CC4532e54608857ADE75190Ea9749c3fA2034a1);
        migrationAvailable[0x28CD183E595f46f2938079eaFFd7b3B7CF6BC288] = 1560666457946250;
        migrationAvailable[0xbfd95cBe2F8F8C13b1cb27fee39514B43C49cE8e] = 2429947000000000;
        migrationAvailable[0x687618B152A7BE3Edb0Ea3AB11a836A8a2B9518A] = 1072146362329020;
        migrationAvailable[0x0B657e52f5Af33b5e7c8ff60D23585966eC4b91d] = 2000000000000000;
        migrationAvailable[0x742E265019E8C03451F0cCA8C218Eba1b3E2ce94] = 318040957188512;
        migrationAvailable[0x8932Ba3480fAF5E32271Bd18546Af07aAC237bda] = 370668000000000;
        migrationAvailable[0xF2a2Bb231e4ddEd7D150e9ed346eB3b635c3f671] = 1029475000000000;
        migrationAvailable[0xea38Fc28e55809908CBdB03d982c0ea4f9de221F] = 3135078847107630;
        migrationAvailable[0xD569CA8dc7c38B0BaE277a5c1fdfc8ad07f146ba] = 5692776676171030;
        migrationAvailable[0x4da054fb5EEf39b2B6021458C5AFb95317C9A3a1] = 4025365993075500;
        migrationAvailable[0x9e52A2bD709b935D3Da2EBF4aa57136CED073E0c] = 3944958880309150;
        migrationAvailable[0x1e350edbaE0D27Fe274831c9b2792fdf1B7bEac9] = 4040933794497140;
        migrationAvailable[0xB8c394564b22Ea97976FaDd6A5870500cF4BD109] = 2046234902559380;
        migrationAvailable[0x26528D4a97ED7fE1B3eD1C6e3E0Acf10D8F0621b] = 3668789727075130;
        migrationAvailable[0xcF658D025AD1a474e9Cea9b1b5FCbCA8C13E7953] = 3516155637153600;
        migrationAvailable[0x475bE51fBb1E7af10eDaA855a9Dd4F2b32EE28A8] = 3469463940298120;
        migrationAvailable[0x7F395af151D0De3510F24B38142f3942E7A45d17] = 1914128275577270;
        migrationAvailable[0x67457c61A981186d9DA796aB841eec4eB7867Aa7] = 8144749879394320;
        migrationAvailable[0xF713131f03D477312070883ea5BE851618562452] = 8377539421212340;
        migrationAvailable[0xD1BB0b0209F8Ff4bE042DaF266EDd52940Db3A85] = 6072705729620506;
        migrationAvailable[0x1eF5F48B43780ABc741839f97F9DCEA557ff4242] = 6072705729620506;
    }
    receive() external payable {}

    function migrationClaim() external {
        address user = msg.sender;
        require(migrationAvailable[user] > uint256(0), "Migration: Available Migration Balance is Zero");
        uint256 amount = migrationAvailable[user];
        migrationToken.transfer(user, amount);
        migrationAvailable[user] = migrationAvailable[user].sub(amount);
        migrationClaimed[user] = migrationClaimed[user].add(amount);
        tokenClaimed = tokenClaimed.add(amount);
    }

    function setMigrationAvailable(address user, uint256 amount) external authorized {
        migrationAvailable[user] = amount;
    }

    function setMultipleMigrationAvailable(address[] calldata addresses, uint256[] calldata amount) external onlyOwner {
        for(uint i=0; i < addresses.length; i++){migrationAvailable[addresses[i]] = amount[i];}
    }

    function setMigrationClaimed(address user, uint256 amount) external authorized {
        migrationClaimed[user] = amount;
    }

    function setMigrationToken(address token) external authorized {
        migrationToken = IERC20(token);
    }

    function disperseTokenPercent(address token, address receiver, uint256 amount) external override authorized {
        uint256 tokenAmt = IERC20(token).balanceOf(address(this));
        IERC20(token).transfer(receiver, (tokenAmt * amount / 100));
    }

    function disperseTokenAmount(address token, address receiver, uint256 amount) external override authorized {
        IERC20(token).transfer(receiver, amount);
    }

    function rescueETH(uint256 amountPercentage) external override authorized {
        uint256 amountETH = address(this).balance;
        payable(msg.sender).transfer(amountETH * amountPercentage / 100);
    }

    function tokenAvailable() external view returns (uint256) {
        return migrationToken.balanceOf(address(this));
    }
}