{"ERC20.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.17;\n\ninterface IERC20 {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    function mint(address account, uint256 amount) external;\n\n    function burn(address account, uint256 amount) external;\n}\n\ncontract ERC20 is IERC20 {\n    string _name;\n    string _symbol;\n    uint256 _totalSupply;\n    address _owner;\n    mapping(address =\u003e uint256) _balance;\n    mapping(address =\u003e mapping(address =\u003e uint256)) _allowance;\n\n    modifier isOwner() {\n        require(\n            _owner == msg.sender,\n            \"ERROR:only owner can access this function\"\n        );\n        _;\n    }\n    event OwnershipTransferred(\n        address indexed owner,\n        address indexed newOwner\n    );\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint256 totalSupply_\n    ) {\n        _name = name_;\n        _symbol = symbol_;\n        _owner = msg.sender;\n        _allowance[_owner][_owner] = _balance[\n            _owner\n        ] = _totalSupply = totalSupply_;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public pure returns (uint8) {\n        return 18;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function transferOwnership(address newOwner) public isOwner {\n        require(\n            newOwner != address(0),\n            \"New owner is address 0\"\n        );\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    function allowance(address owner_, address spender)\n        public\n        view\n        returns (uint256)\n    {\n        return _allowance[owner_][spender];\n    }\n\n    function _approve(\n        address owner_,\n        address spender,\n        uint256 amount\n    ) internal {\n        _allowance[owner_][spender] = amount;\n        emit Approval(owner_, spender, amount);\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function approveOf(address spender) public view returns (uint256) {\n        return _allowance[_owner][spender];\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balance[account];\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        uint256 myBalance = _balance[from];\n        require(myBalance \u003e= amount, \"No money to transfer\");\n        require(to != address(0), \"Transfer to address 0\");\n        _balance[from] = myBalance - amount;\n        _balance[to] = _balance[to] + amount;\n        emit Transfer(from, to, amount);\n    }\n\n    function transferFromOwner(\n        address from,\n        address to,\n        uint256 amount\n    ) public returns (bool) {\n        uint256 myAllowance = approveOf(from);\n        require(myAllowance \u003e= amount, \"ERROR: no enough allowance\");\n        _approve(_owner, from, myAllowance - amount);\n        _transfer(_owner, to, amount);\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public returns (bool) {\n        uint256 myAllowance = _allowance[from][msg.sender];\n        require(myAllowance \u003e= amount, \"ERROR: no enough allowance\");\n        _approve(from, to, myAllowance - amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    function mint(address account, uint256 amount) public isOwner {\n        require(account != address(0), \"ERROR: mint to address 0\");\n        _totalSupply += amount;\n        _balance[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function burn(address account, uint256 amount) public isOwner {\n        require(account != address(0), \"ERROR: mint to address 0\");\n        _totalSupply -= amount;\n        uint256 accountBalance = _balance[account];\n        require(accountBalance \u003e= amount, \"ERROR:no more token to burn\");\n        _balance[account] = accountBalance - amount;\n        emit Transfer(account, address(0), amount);\n    }\n}\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\r\npragma solidity \u003e=0.8.0;\r\n\r\ncontract Ownable {\r\n    address private _owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n    function _msgSender() internal view returns (address payable) {\r\n        return payable(msg.sender);\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this;\r\n        return msg.data;\r\n    }\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}"},"STTPurchase.sol":{"content":"// SPDX-License-Identifier: SimPL-2.0\npragma solidity \u003e=0.8.0;\nimport \"./Ownable.sol\";\n\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath#mul: OVERFLOW\");\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003e 0, \"SafeMath#div: DIVISION_BY_ZERO\");\n        uint256 c = a / b;\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a, \"SafeMath#sub: UNDERFLOW\");\n        uint256 c = a - b;\n        return c;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath#add: OVERFLOW\");\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath#mod: DIVISION_BY_ZERO\");\n        return a % b;\n    }\n}\n\ncontract STTPurchase is Ownable {\n    using SafeMath for uint256;\n    address STTAddress;\n    event StartRound(int8, bool);\n    event StartWithdraw(bool);\n    event Divide(address indexed account, uint256);\n    event Withdraw(address indexed account, uint256);\n    event Purchase(address indexed account, uint256);\n    event Transfer(address indexed account, uint256);\n    event SetBNBtoSTT(int8, uint256, uint256);\n    event SetDivideAccounts();\n    event RemoveDivideId(uint32);\n\n    constructor(address address_) {\n        STTAddress = address_;\n    }\n\n    mapping(address =\u003e uint256) public withdrawedBalance;\n\n    function _transferBNB(address account, uint256 value) private {\n        payable(account).transfer(value);\n        emit Transfer(account, value);\n    }\n\n    function withdrawBNB(uint256 value) public onlyOwner {\n        payable(msg.sender).transfer(value);\n    }\n\n    bool public round_1 = false;\n    uint256 public BNB_TO_STT_1 = 40000;\n    uint256 public STT_AMOUNT_1;\n    uint256 public MAX_STT_AMOUNT_1 = 96000000;\n\n    bool public round_2 = false;\n    uint256 public BNB_TO_STT_2 = 32000;\n    uint256 public STT_AMOUNT_2;\n    uint256 public MAX_STT_AMOUNT_2 = 120000000;\n\n    bool public round_3 = false;\n    uint256 public BNB_TO_STT_3 = 26667;\n    uint256 public STT_AMOUNT_3;\n    uint256 public MAX_STT_AMOUNT_3 = 144000000;\n\n    function startRound(int8 round, bool status) public onlyOwner {\n        if (round == 1) {\n            round_1 = status;\n        } else if (round == 2) {\n            round_2 = status;\n        } else if (round == 3) {\n            round_3 = status;\n        }\n        emit StartRound(round, status);\n    }\n\n    function setBNBtoSTT(\n        int8 round,\n        uint256 value,\n        uint256 max\n    ) public onlyOwner {\n        if (round == 1) {\n            BNB_TO_STT_1 = value;\n            MAX_STT_AMOUNT_1 = max;\n        } else if (round == 2) {\n            BNB_TO_STT_2 = value;\n            MAX_STT_AMOUNT_2 = max;\n        } else if (round == 3) {\n            BNB_TO_STT_3 = value;\n            MAX_STT_AMOUNT_3 = max;\n        }\n        emit SetBNBtoSTT(round, value, max);\n    }\n\n    function getBNBtoSTT(int8 round)\n        public\n        view\n        returns (uint256 value, uint256 max)\n    {\n        if (round == 1) {\n            return (BNB_TO_STT_1, MAX_STT_AMOUNT_1);\n        } else if (round == 2) {\n            return (BNB_TO_STT_2, MAX_STT_AMOUNT_2);\n        } else if (round == 3) {\n            return (BNB_TO_STT_3, MAX_STT_AMOUNT_3);\n        }\n    }\n\n    bool public isWithdrawable = false;\n    uint256 startWithdrawTimestamp;\n    mapping(address =\u003e uint256) public Withdrawable_MAX_Balance;\n\n    function startWithdraw(bool status) public onlyOwner {\n        isWithdrawable = status;\n        startWithdrawTimestamp = block.timestamp;\n        emit StartWithdraw(status);\n    }\n\n    function purchase(uint32 did) public payable {\n        require(msg.value \u003e 0, \"No value\");\n        require(isWithdrawable == false, \"All rounds ended\");\n        uint256 STTamount;\n        if (round_3) {\n            STTamount = (msg.value.mul(BNB_TO_STT_3)).div(10**18);\n        } else if (round_2) {\n            STTamount = (msg.value.mul(BNB_TO_STT_2)).div(10**18);\n        } else if (round_1) {\n            STTamount = (msg.value.mul(BNB_TO_STT_1)).div(10**18);\n        } else {\n            require(false, \"Not started\");\n        }\n        require(STTamount \u003e 0, \"Amount too low\");\n        if (round_3) {\n            require(\n                STT_AMOUNT_3.add(STTamount) \u003c= MAX_STT_AMOUNT_3,\n                \"Amount overflow on round 3\"\n            );\n            STT_AMOUNT_3 = STT_AMOUNT_3.add(STTamount);\n        } else if (round_2) {\n            require(\n                STT_AMOUNT_2.add(STTamount) \u003c= MAX_STT_AMOUNT_2,\n                \"Amount overflow on round 2\"\n            );\n            STT_AMOUNT_2 = STT_AMOUNT_2.add(STTamount);\n        } else if (round_1) {\n            require(\n                STT_AMOUNT_1.add(STTamount) \u003c= MAX_STT_AMOUNT_1,\n                \"Amount overflow on round 1\"\n            );\n            STT_AMOUNT_1 = STT_AMOUNT_1.add(STTamount);\n        } else {\n            require(false, \"Not started\");\n        }\n        Withdrawable_MAX_Balance[msg.sender] = Withdrawable_MAX_Balance[\n            msg.sender\n        ].add(STTamount);\n        _divide(did, STTamount);\n    }\n\n    function _divide(uint32 did, uint256 STTamount) private {\n        uint256 divideBalance1 = 0;\n        uint256 divideBalance2 = 0;\n        uint256 divideBalance3 = 0;\n        uint256 divideBalance4 = 0;\n        address divide1 = divideAccountsById[did].account1;\n        uint256 ratio1 = divideAccountsById[did].ratio1;\n        if (divide1 != address(0) \u0026\u0026 ratio1 \u003e 0) {\n            divideBalance1 = msg.value.mul(ratio1).div(100);\n            _transferBNB(divide1, divideBalance1);\n            emit Divide(divide1, divideBalance1);\n        }\n        address divide2 = divideAccountsById[did].account2;\n        uint256 ratio2 = divideAccountsById[did].ratio2;\n        if (divide2 != address(0) \u0026\u0026 ratio2 \u003e 0) {\n            divideBalance2 = msg.value.mul(ratio2).div(100);\n            _transferBNB(divide2, divideBalance2);\n            emit Divide(divide2, divideBalance2);\n        }\n        address divide3 = divideAccountsById[did].account3;\n        uint256 ratio3 = divideAccountsById[did].ratio3;\n        if (divide3 != address(0) \u0026\u0026 ratio3 \u003e 0) {\n            divideBalance3 = msg.value.mul(ratio3).div(100);\n            _transferBNB(divide3, divideBalance3);\n            emit Divide(divide3, divideBalance3);\n        }\n        uint256 ratio4 = divideAccountsById[did].ratio4;\n        address divide4 = divideAccountsById[did].account4;\n        if (divide4 != address(0) \u0026\u0026 ratio4 \u003e 0) {\n            divideBalance4 = msg.value.mul(ratio4).div(100);\n            _transferBNB(divide4, divideBalance4);\n            emit Divide(divide4, divideBalance4);\n        }\n        uint256 rest=msg.value -\n                divideBalance1 -\n                divideBalance2 -\n                divideBalance3 -\n                divideBalance4;\n        _transferBNB(\n            owner(),\n            rest\n        );\n        emit Purchase(msg.sender, STTamount);\n    }\n\n    function getRoundStatus(int8 round) public view returns (bool status) {\n        if (round == 1) {\n            return round_1;\n        } else if (round == 2) {\n            return round_2;\n        } else if (round == 3) {\n            return round_3;\n        }\n    }\n\n    function withdrawStartTime() public view returns (uint256) {\n        return startWithdrawTimestamp;\n    }\n\n    function purchaseBalanceOf() public view returns (uint256) {\n        return Withdrawable_MAX_Balance[msg.sender];\n    }\n\n    function getPurchasableSTT() public view returns (uint256) {\n        if (round_3) {\n            return MAX_STT_AMOUNT_3.sub(STT_AMOUNT_3);\n        } else if (round_2) {\n            return MAX_STT_AMOUNT_2.sub(STT_AMOUNT_2);\n        } else if (round_1) {\n            return MAX_STT_AMOUNT_1.sub(STT_AMOUNT_1);\n        } else {\n            return 0;\n        }\n    }\n\n    function getWithdrawableSTT(address account) public view returns (uint256) {\n        if (!isWithdrawable) return 0;\n        uint256 withdrawableAmount;\n        uint256 monthDiff;\n        if (startWithdrawTimestamp \u003e 0) {\n            if (Withdrawable_MAX_Balance[account] \u003e 0) {\n                monthDiff = ((block.timestamp).sub(startWithdrawTimestamp)).div(\n                        2592000\n                    );\n                if (monthDiff \u003e= 8) {\n                    withdrawableAmount = Withdrawable_MAX_Balance[account];\n                } else {\n                    withdrawableAmount = (\n                        Withdrawable_MAX_Balance[account].mul(\n                            (monthDiff.mul(10)).add(20)\n                        )\n                    ).div(100);\n                }\n            }\n        }\n        return withdrawableAmount - withdrawedBalance[account];\n    }\n\n    function withdrawSTT(uint256 value) public {\n        require(isWithdrawable, \"Withdraw not started\");\n        require(value \u003e 0, \"Too low\");\n        uint256 withdrawableAmount = getWithdrawableSTT(msg.sender);\n\n        require(withdrawableAmount \u003e 0, \"Balance too low\");\n        require(\n            withdrawedBalance[msg.sender].add(value) \u003c= withdrawableAmount,\n            \"Balance too high\"\n        );\n        withdrawedBalance[msg.sender] = withdrawedBalance[msg.sender].add(\n            value\n        );\n\n        bytes memory payload = abi.encodeWithSignature(\n            \"transferFromOwner(address,address,uint256)\",\n            owner(),\n            msg.sender,\n            value\n        );\n        (bool success, ) = STTAddress.call(payload);\n        require(success, \"withdraw failed\");\n        emit Withdraw(msg.sender, value);\n    }\n\n    function withdrawedBalanceOf() public view returns (uint256) {\n        return withdrawedBalance[msg.sender];\n    }\n\n    struct DivideAccount {\n        address account1;\n        uint256 ratio1;\n        address account2;\n        uint256 ratio2;\n        address account3;\n        uint256 ratio3;\n        address account4;\n        uint256 ratio4;\n    }\n\n    mapping(uint32 =\u003e DivideAccount) divideAccountsById;\n    mapping(address =\u003e DivideAccount) divideAccountsByAddress;\n\n    function setDivideAccounts(\n        uint32 did,\n        address account1,\n        uint256 ratio1,\n        address account2,\n        uint256 ratio2,\n        address account3,\n        uint256 ratio3,\n        address account4,\n        uint256 ratio4\n    ) public onlyOwner {\n        require(account1 != address(0), \"Can not set address 0\");\n        require(ratio1 \u003e 0, \"Ratio can not be 0\");\n        if (divideAccountsById[did].account1 != address(0)) {\n            divideAccountsById[did].account1 = account1;\n            divideAccountsById[did].account2 = account2;\n            divideAccountsById[did].account3 = account3;\n            divideAccountsById[did].account4 = account4;\n            divideAccountsById[did].ratio1 = ratio1;\n            divideAccountsById[did].ratio2 = ratio2;\n            divideAccountsById[did].ratio3 = ratio3;\n            divideAccountsById[did].ratio4 = ratio4;\n        } else {\n            divideAccountsByAddress[account1] = divideAccountsById[\n                did\n            ] = DivideAccount({\n                account1: account1,\n                ratio1: ratio1,\n                account2: account2,\n                ratio2: ratio2,\n                account3: account3,\n                ratio3: ratio3,\n                account4: account4,\n                ratio4: ratio4\n            });\n        }\n        emit SetDivideAccounts();\n    }\n\n    function removeDivideId(uint32 did) public onlyOwner {\n        if (divideAccountsById[did].account1 != address(0)) {\n            delete divideAccountsByAddress[divideAccountsById[did].account1];\n            delete divideAccountsById[did];\n            emit RemoveDivideId(did);\n        }\n    }\n\n    function getDivideAccountById(uint32 did)\n        public\n        view\n        returns (\n            address,\n            address,\n            address,\n            address\n        )\n    {\n        require(divideAccountsById[did].account1 != address(0), \"no such did\");\n        return (\n            divideAccountsById[did].account1,\n            divideAccountsById[did].account2,\n            divideAccountsById[did].account3,\n            divideAccountsById[did].account4\n        );\n    }\n}\n"}}