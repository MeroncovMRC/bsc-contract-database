{"AddressSetLib.sol":{"content":"pragma solidity 0.5.8;\n\n\nlibrary AddressSetLib {\n    struct AddressSet {\n        address[] elements;\n        mapping(address =\u003e uint) indices;\n    }\n\n    function contains(AddressSet storage set, address candidate) internal view returns (bool) {\n        if (set.elements.length == 0) {\n            return false;\n        }\n        uint index = set.indices[candidate];\n        return index != 0 || set.elements[0] == candidate;\n    }\n\n    function getPage(\n        AddressSet storage set,\n        uint index,\n        uint pageSize\n    ) internal view returns (address[] memory) {\n        // NOTE: This implementation should be converted to slice operators if the compiler is updated to v0.6.0+\n        uint endIndex = index + pageSize; // The check below that endIndex \u003c= index handles overflow.\n\n        // If the page extends past the end of the list, truncate it.\n        if (endIndex \u003e set.elements.length) {\n            endIndex = set.elements.length;\n        }\n        if (endIndex \u003c= index) {\n            return new address[](0);\n        }\n\n        uint n = endIndex - index; // We already checked for negative overflow.\n        address[] memory page = new address[](n);\n        for (uint i; i \u003c n; i++) {\n            page[i] = set.elements[i + index];\n        }\n        return page;\n    }\n\n    function add(AddressSet storage set, address element) internal {\n        // Adding to a set is an idempotent operation.\n        if (!contains(set, element)) {\n            set.indices[element] = set.elements.length;\n            set.elements.push(element);\n        }\n    }\n\n    function remove(AddressSet storage set, address element) internal {\n        require(contains(set, element), \"Element not in set.\");\n        // Replace the removed element with the last element of the list.\n        uint index = set.indices[element];\n        uint lastIndex = set.elements.length - 1; // We required that element is in the list, so it is not empty.\n        if (index != lastIndex) {\n            // No need to shift the last element if it is the one we want to delete.\n            address shiftedElement = set.elements[lastIndex];\n            set.elements[index] = shiftedElement;\n            set.indices[shiftedElement] = index;\n        }\n        set.elements.pop();\n        delete set.indices[element];\n    }\n}\n"},"ERC20.sol":{"content":"pragma solidity ^0.5.8;\n\nimport \"./IERC20.sol\";\nimport \"./SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20Mintable}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn\u0027t required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address =\u003e uint256) private _balances;\n\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `value`.\n     * - the caller must have allowance for `sender`\u0027s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n    * @dev Destroys `amount` tokens from `account`, reducing the\n    * total supply.\n    *\n    * Emits a {Transfer} event with `to` set to the zero address.\n    *\n    * Requirements\n    *\n    * - `account` cannot be the zero address.\n    * - `account` must have at least `amount` tokens.\n    */\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller\u0027s allowance.\n     *\n     * See {_burn} and {_approve}.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\n    }\n}"},"ERC20Detailed.sol":{"content":"pragma solidity ^0.5.8;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Optional functions from the ERC20 standard.\n */\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n"},"IERC20.sol":{"content":"pragma solidity ^0.5.8;\n\n/**\n * @title TRC20 interface\n */\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"},"IRefer.sol":{"content":"pragma solidity 0.5.8;\n\n\ninterface IRefer {\n    function submitRefer(address referrer) external returns (bool);\n    function getReferLength(address usr) external view returns (uint256);\n    function isReferContains(address usr, address referrer) external view returns (bool);\n    function getReferrer(address usr) external view returns (address);\n}"},"ITRC20.sol":{"content":"pragma solidity 0.5.8;\n\n/**\n * @title TRC20 interface\n */\ninterface ITRC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"MOTToken.sol":{"content":"pragma solidity 0.5.8;\n\nimport \"./ITRC20.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Ownable.sol\";\n\ncontract MOTToken is ITRC20, Ownable {\n    using SafeMath for uint256;\n\n    string private _name = \"MOT\";\n    string private _symbol = \"MOT\";\n    uint8 private _decimals = 18;\n    mapping (address =\u003e uint256) private _balances;\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\n    uint256 private _totalSupply;\n\n    mapping (address =\u003e bool) private _isIncludedFromFee;\n\n    address public burnPool = 0x000000000000000000000000000000000000dEaD;\n    address public fixedWallet;\n\n    constructor (address recipient) public {\n        _mint(recipient, 54500000e18);\n        fixedWallet = msg.sender;\n    }\n\n    function setBurnPool(address _pool) public onlyOwner {\n        burnPool = _pool;\n    }\n\n    function excludeFromFee(address account) public onlyOwner {\n        _isIncludedFromFee[account] = false;\n    }\n\n    function includeInFee(address account) public onlyOwner {\n        _isIncludedFromFee[account] = true;\n    }\n\n    function isIncludedFromFee(address account) public view returns(bool) {\n        return _isIncludedFromFee[account];\n    }\n\n    function calculateTaxFee(uint256 _amount) private view returns (uint256 burnAmount, uint256 fixedAmount, uint256 leftover) {\n        burnAmount = _amount.mul(5).div(100);\n        fixedAmount = _amount.mul(3).div(100);\n        leftover = _amount.sub(burnAmount).sub(fixedAmount);\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    function mint(address _to, uint256 _amount) public onlyOwner {\n        _mint(_to, _amount);\n    }\n\n    function burn(address _from, uint256 _amount) public onlyOwner {\n        _burn(_from, _amount);\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(amount \u003e 0, \"Transfer amount must be greater than zero\");\n\n        if(!_isIncludedFromFee[recipient]) { // no fee\n            _balances[sender] = _balances[sender].sub(amount);\n            _balances[recipient] = _balances[recipient].add(amount);\n            emit Transfer(sender, recipient, amount);\n        } else {\n            uint256 leftover;\n            uint256 burnAmount;\n            uint256 fixedAmount;\n            (burnAmount, fixedAmount, leftover) = calculateTaxFee(amount);\n\n            _balances[sender] = _balances[sender].sub(amount);\n            _balances[recipient] = _balances[recipient].add(leftover);\n            _balances[fixedWallet] = _balances[fixedWallet].add(fixedAmount);\n            _balances[burnPool] = _balances[burnPool].add(burnAmount);\n\n            emit Transfer(sender, recipient, leftover);\n            emit Transfer(sender, fixedWallet, fixedAmount);\n            emit Transfer(sender, burnPool, burnAmount);\n        }\n    }\n\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\n    }\n}"},"Ownable.sol":{"content":"pragma solidity 0.5.8;\n\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n    * @dev Initializes the contract setting the deployer as the initial owner.\n    */\n    constructor() internal {\n        address msgSender = msg.sender;\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}"},"Rank.sol":{"content":"pragma solidity 0.5.8;\n\nimport \"./Ownable.sol\";\n\n\ncontract Rank is Ownable {\n    mapping(address =\u003e uint256)  balances;\n    mapping(address =\u003e address)  _nextAddress;\n    uint256 public listSize;\n    address constant GUARD = address(1);\n\n    constructor() public {\n        _nextAddress[GUARD] = GUARD;\n    }\n\n    function addRankAddress(address addr, uint256 balance) internal {\n        if (_nextAddress[addr] != address(0)) {\n            return;\n        }\n\n        address index = _findIndex(balance);\n        balances[addr] = balance;\n        _nextAddress[addr] = _nextAddress[index];\n        _nextAddress[index] = addr;\n        listSize++;\n    }\n\n    function removeRankAddress(address addr) internal {\n        if (_nextAddress[addr] == address(0)) {\n            return;\n        }\n\n        address prevAddress = _findPrevAddress(addr);\n        _nextAddress[prevAddress] = _nextAddress[addr];\n\n        _nextAddress[addr] = address(0);\n        balances[addr] = 0;\n        listSize--;\n    }\n\n    function isContains(address addr) internal view returns (bool) {\n        return _nextAddress[addr] != address(0);\n    }\n\n    function getRank(address addr) public view returns (uint256) {\n        if (!isContains(addr)) {\n            return 0;\n        }\n\n        uint idx = 0;\n        address currentAddress = GUARD;\n        while(_nextAddress[currentAddress] != GUARD) {\n            if (addr != currentAddress) {\n                currentAddress = _nextAddress[currentAddress];\n                idx++;\n            } else {\n                break;\n            }\n        }\n        return idx;\n    }\n\n    function getRankBalance(address addr) internal view returns (uint256) {\n        return balances[addr];\n    }\n\n    function getTop(uint256 k) public view returns (address[] memory) {\n        if (k \u003e listSize) {\n            k = listSize;\n        }\n\n        address[] memory addressLists = new address[](k);\n        address currentAddress = _nextAddress[GUARD];\n        for (uint256 i = 0; i \u003c k; ++i) {\n            addressLists[i] = currentAddress;\n            currentAddress = _nextAddress[currentAddress];\n        }\n\n        return addressLists;\n    }\n\n    function updateRank(address addr, uint256 newBalance) internal {\n        if (!isContains(addr)) {\n            // 如果不存在，则添加\n            addRankAddress(addr, newBalance);\n        } else {\n            // 已存在，则更新\n            address prevAddress = _findPrevAddress(addr);\n            address nextAddress = _nextAddress[addr];\n            if (_verifyIndex(prevAddress, newBalance, nextAddress)) {\n                balances[addr] = newBalance;\n            } else {\n                removeRankAddress(addr);\n                addRankAddress(addr, newBalance);\n            }\n        }\n    }\n\n    function _isPrevAddress(address addr, address prevAddress) internal view returns (bool) {\n        return _nextAddress[prevAddress] == addr;\n    }\n\n    // 用于验证该值在左右地址之间\n    // 如果 左边的值 ≥ 新值 \u003e 右边的值将返回 true(如果我们保持降序，并且如果值等于，则新值应该在旧值的后面)\n    function _verifyIndex(address prevAddress, uint256 newValue, address nextAddress)\n    internal\n    view\n    returns (bool) {\n        return (prevAddress == GUARD || balances[prevAddress] \u003e= newValue) \u0026\u0026\n        (nextAddress == GUARD || newValue \u003e balances[nextAddress]);\n    }\n\n    // 用于查找新值应该插入在哪一个地址后面\n    function _findIndex(uint256 newValue) internal view returns (address) {\n        address candidateAddress = GUARD;\n        while(true) {\n            if (_verifyIndex(candidateAddress, newValue, _nextAddress[candidateAddress]))\n                return candidateAddress;\n\n            candidateAddress = _nextAddress[candidateAddress];\n        }\n    }\n\n    function _findPrevAddress(address addr) internal view returns (address) {\n        address currentAddress = GUARD;\n        while(_nextAddress[currentAddress] != GUARD) {\n            if (_isPrevAddress(addr, currentAddress))\n                return currentAddress;\n\n            currentAddress = _nextAddress[currentAddress];\n        }\n        return address(0);\n    }\n}"},"Refer.sol":{"content":"pragma solidity 0.5.8;\n\nimport \"./AddressSetLib.sol\";\n\n\ncontract Refer {\n    using AddressSetLib for AddressSetLib.AddressSet;\n\n    mapping (address =\u003e address) public referrers; // 推荐关系\n    mapping (address =\u003e address[]) public referList; // 推荐列表\n\n    AddressSetLib.AddressSet internal addressSet;\n\n    event NewReferr(address indexed usr, address refer);\n\n    // 提交推荐关系\n    function submitRefer(address usr, address referrer) public returns (bool) {\n        require(usr == tx.origin, \"usr must be tx origin\");\n        require(usr != referrer, \"can\u0027t invite your self\");\n\n        // 记录推荐关系\n        if (referrers[usr] == address(0)) {\n            referrers[usr] = referrer;\n            emit NewReferr(usr, referrer);\n\n            addressSet.add(referrer);\n\n            if (!isReferContains(usr, referrer)) {\n                referList[referrer].push(usr);\n            }\n        }\n        return true;\n    }\n\n    // 查询推荐的总人数\n    function getReferLength(address referrer) public view returns (uint256) {\n        return referList[referrer].length;\n    }\n\n    // 查询用户是否在指定地址的推荐列表中\n    function isReferContains(address usr, address referrer) public view returns (bool) {\n        address[] memory addrList = referList[referrer];\n        bool found = false;\n        for (uint256 i = 0; i \u003c addrList.length; i++) {\n            if (usr == addrList[i]) {\n                found = true;\n                break;\n            }\n        }\n        return found;\n    }\n\n    // 查询推荐人地址\n    function getReferrer(address usr) public view returns (address) {\n        return referrers[usr];\n    }\n\n    // 查询所有的推荐人，可指定index位置和返回数量\n    function getReferrers(uint256 index, uint256 pageSize) public view returns (address[] memory) {\n        return addressSet.getPage(index, pageSize);\n    }\n}\n"},"SafeMath.sol":{"content":"pragma solidity 0.5.8;\n\n\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n\n    /**\n     * @dev Multiplies two unsigned integers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath#mul: OVERFLOW\");\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, \"SafeMath#div: DIVISION_BY_ZERO\");\n        uint256 c = a / b;\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a, \"SafeMath#sub: UNDERFLOW\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two unsigned integers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath#add: OVERFLOW\");\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath#mod: DIVISION_BY_ZERO\");\n        return a % b;\n    }\n\n}"},"Swap.sol":{"content":"pragma solidity 0.5.8;\n\nimport \"./ITRC20.sol\";\nimport \"./MOTToken.sol\";\nimport \"./Ownable.sol\";\nimport \u0027./TransferHelper.sol\u0027;\nimport \u0027./Rank.sol\u0027;\nimport \u0027./IRefer.sol\u0027;\nimport \u0027./Refer.sol\u0027;\n\ncontract Swap is Ownable, Rank {\n    using SafeMath for uint256;\n\n    /////////////////////////////////////////////////////////\n    // for testnet\n    bool public flagTestNet = true;\n    function setTestFlag(bool flag) public returns (bool) {\n        flagTestNet = flag;\n        return flagTestNet;\n    }\n    /////////////////////////////////////////////////////////\n\n\n    struct SystemSetting {\n        uint256 round;\n        uint256 layers;\n        uint256 limitPerLayer;\n        uint256 price; // 初始价格，放大100倍\n        uint256 curLeftOver;\n    }\n\n    address public nullAddress = 0x0000000000000000000000000000000000000001;\n\n    // The MOT token\n    address public mot;\n\n    address public usdt;\n    // Dev address.\n    address public devaddr;\n\n    uint256 public startBlock;\n\n    Refer public refer;\n    uint256 public totalReferBonus; // 全网推荐总收益\n\n    mapping(address =\u003e uint256) referBonus;\n\n    // 系统参数\n    SystemSetting public setting;\n\n    // 不同层的差价\n    uint256[] public priceDeltas = [5, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\n    // 最少需要投入1 MOT\n    uint256 public constant MIN_GAMMA_REQUIRE = 1e18;\n\n    // 每层增加10000 MOT额度\n    uint256 public constant LAYER_DELTA = 10000e18;\n//    uint256 public constant LAYER_DELTA = 1000e18; //测试用，每层增加1000\n\n    // 最大轮数限制\n    uint256 public constant TOTAL_ROUND = 10;\n    // 最大层数限制\n    uint256 public constant TOTAL_LAYERS = 10;\n    // 9 人一组开奖\n    uint256 public constant GROUP_NUM_LIMIT = 9;\n    // 一组开奖3人\n    uint256 public constant GROUP_WIN_NUM = 3;\n\n    uint256 public constant USDTAmountLow = 100e18;\n    uint256 public constant USDTAmountMedium = 500e18;\n    uint256 public constant USDTAmountHigh = 1000e18;\n\n    address[] public winnersLow;\n    address[] public winnersMedium;\n    address[] public winnersHigh;\n\n    struct winAmount {\n        uint256 gammaAmount;\n        uint256 usdtAmount;\n    }\n\n    // 保存通兑成功获得的MOT数量\n    mapping (address =\u003e winAmount) public forgeWinAmount;\n\n    // 用于计算链上随机数\n    uint256 nonce = 0;\n\n    // 当季新增资金量\n    uint256 public increasedTotalAmount = 0;\n\n    // 奖励赛奖金池\n    mapping(uint256 =\u003e uint256) public racePool;\n\n    // 奖励赛前20名奖励的百分比，放大1000倍\n    uint256[] bonusRate = [300, 200, 100, 80, 70, 60, 50, 40, 30, 20, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5];\n    uint256 public RANK_TOP_NUM = 20;\n    uint256 public RANK_TOP_MAX = 100;\n\n    // constructor\n    constructor (\n        address _mot,\n        address _usdt,\n        address _devaddr,\n        Refer _refer\n    ) public {\n        mot = _mot;\n        usdt = _usdt;\n        devaddr = _devaddr;\n        refer = _refer;\n    }\n\n    // set init params\n    function setParams(uint256 _startBlock) public onlyOwner {\n        startBlock = _startBlock;\n        // 设置系统参数 (round, layers, limitPerLayer, price, curLeftOver)\n        setting = SystemSetting(1, 1, 50000e18, 10, 50000e18);\n\n//        setting = SystemSetting(1, 1, 10000e18, 10, 10000e18);\n    }\n\n    // set system setting\n    function setSystemSetting(uint256 _round, uint256 _layers, uint256 _limitPerLayer, uint256 _price, uint256 _curLeftOver) public onlyOwner {\n        setting = SystemSetting(_round, _layers, _limitPerLayer, _price, _curLeftOver);\n    }\n\n    function winnerNumber(uint256 N) internal returns (uint256, uint256, uint256) {\n        uint256 base = now;\n        uint256 a = base.add(nonce++).mod(N);\n        uint256 b = base.add(nonce++).mod(N);\n        uint256 c = base.add(nonce++).mod(N);\n        return (a, b, c);\n    }\n\n    // run at [20:00 - 20:30]\n    function requireSystemActive() internal view {\n        require(block.number \u003e= startBlock, \"next round not yet started\");\n        if (flagTestNet) {\n            return;\n        }\n        uint256 hour = now % (1 days) / (1 hours);\n        uint256 minute = now % (1 hours) / (1 minutes);\n        require(hour \u003e= 12 \u0026\u0026 hour \u003c 13, \"system only works in [20:00 - 20:30]!\");\n        require(minute \u003e= 0 \u0026\u0026 minute \u003c= 30, \"system only works in [20:00 - 20:30]!\");\n    }\n\n    function enterNextLayer() internal {\n        setting.layers = setting.layers.add(1);\n        if (setting.layers \u003e TOTAL_LAYERS) {\n            // 当前轮已超过10层，进入下一轮，轮数加1\n            setting.round = setting.round.add(1);\n            setting.layers = 1;\n        }\n\n        // 下一层增加1万额度，同时把上一层剩余的累加上去\n        setting.limitPerLayer = setting.limitPerLayer.add(LAYER_DELTA).add(setting.curLeftOver);\n        setting.curLeftOver = setting.limitPerLayer;\n        setting.price = setting.price.add(priceDeltas[setting.round.sub(1)]);\n    }\n\n    // 获取通兑成功的MOT数量\n    function getForgeWinAmount (address usr) public view returns (uint256 gammaAmount, uint256 usdtAmount) {\n        gammaAmount =  forgeWinAmount[usr].gammaAmount;\n        usdtAmount = forgeWinAmount[usr].usdtAmount;\n    }\n\n    function forgeLow(address referrer) public {\n        address sender = msg.sender;\n        require(sender != referrer, \"can\u0027t invite yourself\");\n\n        requireSystemActive();\n        uint256 usdtAmount = USDTAmountLow;\n        SystemSetting memory ss = setting;\n\n        // 如果额度不足，则进入下一层\n        uint256 gammaAmount = usdtAmount.mul(100).div(ss.price);\n        if (ss.curLeftOver \u003c gammaAmount.mul(GROUP_WIN_NUM)) {\n            // 如果剩余额度不足一组，则额度累加到下一层\n            enterNextLayer();// 返回值为是否进入了奖励赛\n            ss = setting;\n            gammaAmount = usdtAmount.mul(100).div(ss.price);\n        }\n        // 最多10轮\n        require(ss.round \u003c= TOTAL_ROUND, \"total 10 round finisehd\");\n\n        TransferHelper.safeTransferFrom(mot, sender, nullAddress, MIN_GAMMA_REQUIRE);\n        TransferHelper.safeTransferFrom(usdt, sender, address(this), usdtAmount);\n\n        // 记录推荐关系\n        refer.submitRefer(sender, referrer);\n\n        // 存储并计算通兑成功者\n        if (winnersLow.length \u003c GROUP_NUM_LIMIT) {\n            winnersLow.push(sender);\n        }\n\n        if (winnersLow.length == GROUP_NUM_LIMIT) {\n            // 计算出3个随机index, 范围[0 - 8]\n            (uint256 idx1, uint256 idx2, uint256 idx3) = winnerNumber(GROUP_NUM_LIMIT);\n\n            // 开奖\n            for (uint256 i = 0; i \u003c winnersLow.length; i++) {\n                address win = winnersLow[i];\n                if (i == idx1 || i == idx2 || i == idx3) {\n                    // 通兑成功\n                    // 发送MOT\n                    TransferHelper.safeTransfer(mot, win, gammaAmount);\n                    forgeWinAmount[win].gammaAmount = forgeWinAmount[win].gammaAmount.add(gammaAmount);\n                    forgeWinAmount[win].usdtAmount = forgeWinAmount[win].usdtAmount.add(usdtAmount);\n\n                    // 一级推荐人获得4%\n                    address refAddr = getReferrer(win);\n                    referBonus[refAddr] = referBonus[refAddr].add(usdtAmount.mul(4).div(100));\n\n                    // 二级推荐人获得1%\n                    address refAddr2 = getReferrer(refAddr);\n                    referBonus[refAddr2] = referBonus[refAddr2].add(usdtAmount.mul(1).div(100));\n                } else {\n                    // 通兑失败\n                    // 退还110%\n                    uint256 amount = usdtAmount.add(usdtAmount.div(10));\n                    TransferHelper.safeTransfer(usdt, win, amount);\n\n                    // 一级推荐人获得0.8%\n                    address refAddr = getReferrer(win);\n                    referBonus[refAddr] = referBonus[refAddr].add(usdtAmount.mul(8).div(1000));\n\n                    // 二级推荐人获得0.2%\n                    address refAddr2 = getReferrer(refAddr);\n                    referBonus[refAddr2] = referBonus[refAddr2].add(usdtAmount.mul(2).div(1000));\n                }\n            }\n\n            updateLeftOver(gammaAmount);\n            updateTotalReferBonus(usdtAmount);\n\n            uint256 delta = usdtAmount.mul(3).mul(15).div(100);\n            updateRacePool(ss.round, delta);\n\n            delete winnersLow;\n        }\n    }\n\n    // 为TOP K分发奖励\n    // only dev\n    function distributeBonus() public returns (bool) {\n        require(msg.sender == devaddr, \"dev: only devaddr\");\n\n        uint256 round = setting.round;\n        require(round \u003e 3 \u0026\u0026 round \u003c= 10, \"round not good\");\n\n        uint256 totalBonus = getRacePoolBonus(round);\n        address[] memory topList = getTopRank();\n        require(topList.length \u003c= bonusRate.length, \"topList above RANK_TOP_NUM\");\n\n        for (uint256 i = 0; i \u003c topList.length; i++) {\n            uint256 bonus = totalBonus.div(1000).mul(bonusRate[i]);\n            TransferHelper.safeTransfer(usdt, topList[i], bonus);\n        }\n        return true;\n    }\n\n    function claimRewards() public returns (uint256) {\n        address sender = msg.sender;\n        uint256 rewards = referBonus[sender];\n        referBonus[sender] = 0;\n        TransferHelper.safeTransfer(usdt, sender, rewards);\n        return rewards;\n    }\n\n    function updateLeftOver(uint256 gammaAmount) internal {\n        uint256 amount = gammaAmount.mul(3);\n        setting.curLeftOver = setting.curLeftOver.sub(amount);\n    }\n\n    function updateTotalReferBonus(uint256 usdtAmount) internal {\n        uint256 total = totalReferBonus;\n        total = total.add(usdtAmount.mul(3).div(20));\n        total = total.add(usdtAmount.mul(6).div(100));\n        totalReferBonus = total;\n    }\n\n    function updateRacePool(uint256 round, uint256 amount) internal {\n        racePool[round] = racePool[round].add(amount);\n    }\n\n    function setRacePool(uint256 round, uint256 amount) public onlyOwner {\n        racePool[round]  = amount;\n    }\n\n    // 查询推荐的总收益\n    function getReferBonus(address usr) public view returns (uint256) {\n        return referBonus[usr];\n    }\n\n    // 查询初级通兑池未成团人数\n    function getWinnersLowLength() public view returns (uint256) {\n        return winnersLow.length;\n    }\n\n    // 查询中级通兑池未成团人数\n    function getWinnersMediumLength() public view returns (uint256) {\n        return winnersMedium.length;\n    }\n\n    // 查询高级通兑池未成团人数\n    function getWinnersHighLength() public view returns (uint256) {\n        return winnersHigh.length;\n    }\n\n    function getBonus() public view returns (uint256) {\n        uint256 round3Total = racePool[0].add(racePool[1]).add(racePool[2]);\n        return round3Total.div(7).add(racePool[setting.round]);\n    }\n\n    // 获取指定轮季度赛的奖励池份额\n    function getRacePoolBonus(uint256 round) public view returns (uint256) {\n        if (round \u003c= 3 || round \u003e 10) {\n            return 0;\n        }\n        uint256 round3Total = racePool[0].add(racePool[1]).add(racePool[2]);\n        return round3Total.div(7).add(racePool[round]);\n    }\n\n    // 查询在三个通兑池中成团情况\n    function getPendingForge(address usr) public view returns (bool low, bool medium,bool high) {\n        low = false;\n        medium = false;\n        high = false;\n\n        // low\n        for (uint256 i = 0; i \u003c winnersLow.length; i++) {\n            if (usr == winnersLow[i]) {\n                low = true;\n                break;\n            }\n        }\n        // medium\n        for (uint256 i = 0; i \u003c winnersMedium.length; i++) {\n            if (usr == winnersMedium[i]) {\n                medium = true;\n                break;\n            }\n        }\n        // high\n        for (uint256 i = 0; i \u003c winnersHigh.length; i++) {\n            if (usr == winnersHigh[i]) {\n                high = true;\n                break;\n            }\n        }\n    }\n\n    function getTopRank() public view returns (address[] memory) {\n        address [] memory top100;\n        top100 = getTop(RANK_TOP_MAX);\n\n        address[] memory topk = new address[](RANK_TOP_NUM);\n        uint256 idx = 0;\n        for (uint256 i = 0; i \u003c top100.length \u0026\u0026 idx \u003c RANK_TOP_NUM; i++) {\n            address usr = top100[i];\n            if (getRankBalance(usr) \u003c= ITRC20(mot).balanceOf(usr)) {\n                topk[idx] = usr;\n                idx = idx.add(1);\n            }\n        }\n        return topk;\n    }\n\n    function getUserRank(address usr) public view returns (uint256) {\n        if (getRankBalance(usr) \u003e ITRC20(mot).balanceOf(usr)) {\n            return 0;\n        }\n        return getRank(usr);\n    }\n\n    function updateUserRank(address usr) public returns (bool) {\n        uint256 balance = forgeWinAmount[usr].gammaAmount;\n        uint256 rankBalance = getRankBalance(usr);\n        if (balance \u003e rankBalance) {\n            updateRank(usr, balance);\n        }\n        return true;\n    }\n\n    function forgeMedium(address referrer) public {\n        address sender = msg.sender;\n        require(sender != referrer, \"can\u0027t invite yourself\");\n\n        requireSystemActive();\n        uint256 usdtAmount = USDTAmountMedium;\n        SystemSetting memory ss = setting;\n\n        // 如果额度不足，则进入下一层\n        uint256 gammaAmount = usdtAmount.mul(100).div(ss.price);\n        if (ss.curLeftOver \u003c gammaAmount.mul(GROUP_WIN_NUM)) {\n            // 如果剩余额度不足一组，则额度累加到下一层\n            enterNextLayer();// 返回值为是否进入了奖励赛\n            ss = setting;\n            gammaAmount = usdtAmount.mul(100).div(ss.price);\n        }\n        // 最多10轮\n        require(ss.round \u003c= TOTAL_ROUND, \"total 10 round finisehd\");\n\n        TransferHelper.safeTransferFrom(mot, sender, nullAddress, MIN_GAMMA_REQUIRE);\n        TransferHelper.safeTransferFrom(usdt, sender, address(this), usdtAmount);\n\n        // 记录推荐关系\n        refer.submitRefer(sender, referrer);\n\n        // 存储并计算通兑成功者\n        if (winnersMedium.length \u003c GROUP_NUM_LIMIT) {\n            winnersMedium.push(sender);\n        }\n\n        if (winnersMedium.length == GROUP_NUM_LIMIT) {\n            // 计算出3个随机index, 范围[0 - 8]\n            (uint256 idx1, uint256 idx2, uint256 idx3) = winnerNumber(GROUP_NUM_LIMIT);\n\n            // 开奖\n            for (uint256 i = 0; i \u003c winnersMedium.length; i++) {\n                address win = winnersMedium[i];\n                if (i == idx1 || i == idx2 || i == idx3) {\n                    // 通兑成功\n                    // 发送MOT\n                    TransferHelper.safeTransfer(mot, win, gammaAmount);\n                    forgeWinAmount[win].gammaAmount = forgeWinAmount[win].gammaAmount.add(gammaAmount);\n                    forgeWinAmount[win].usdtAmount = forgeWinAmount[win].usdtAmount.add(usdtAmount);\n\n                    // 一级推荐人获得4%\n                    address refAddr = getReferrer(win);\n                    referBonus[refAddr] = referBonus[refAddr].add(usdtAmount.mul(4).div(100));\n\n                    // 二级推荐人获得1%\n                    address refAddr2 = getReferrer(refAddr);\n                    referBonus[refAddr2] = referBonus[refAddr2].add(usdtAmount.mul(1).div(100));\n                } else {\n                    // 通兑失败\n                    // 退还110%\n                    uint256 amount = usdtAmount.add(usdtAmount.div(10));\n                    TransferHelper.safeTransfer(usdt, win, amount);\n\n                    // 一级推荐人获得0.8%\n                    address refAddr = getReferrer(win);\n                    referBonus[refAddr] = referBonus[refAddr].add(usdtAmount.mul(8).div(1000));\n\n                    // 二级推荐人获得0.2%\n                    address refAddr2 = getReferrer(refAddr);\n                    referBonus[refAddr2] = referBonus[refAddr2].add(usdtAmount.mul(2).div(1000));\n                }\n            }\n\n            updateLeftOver(gammaAmount);\n            updateTotalReferBonus(usdtAmount);\n\n            uint256 delta = usdtAmount.mul(3).mul(15).div(100);\n            updateRacePool(ss.round, delta);\n\n            delete winnersMedium;\n        }\n    }\n\n    function forgeHigh(address referrer) public {\n        address sender = msg.sender;\n        require(sender != referrer, \"can\u0027t invite yourself\");\n\n        requireSystemActive();\n        uint256 usdtAmount = USDTAmountHigh;\n        SystemSetting memory ss = setting;\n\n        // 如果额度不足，则进入下一层\n        uint256 gammaAmount = usdtAmount.mul(100).div(ss.price);\n        if (ss.curLeftOver \u003c gammaAmount.mul(GROUP_WIN_NUM)) {\n            // 如果剩余额度不足一组，则额度累加到下一层\n            enterNextLayer();// 返回值为是否进入了奖励赛\n            ss = setting;\n            gammaAmount = usdtAmount.mul(100).div(ss.price);\n        }\n        // 最多10轮\n        require(ss.round \u003c= TOTAL_ROUND, \"total 10 round finisehd\");\n\n        TransferHelper.safeTransferFrom(mot, sender, nullAddress, MIN_GAMMA_REQUIRE);\n        TransferHelper.safeTransferFrom(usdt, sender, address(this), usdtAmount);\n\n        // 记录推荐关系\n        refer.submitRefer(sender, referrer);\n\n        // 存储并计算通兑成功者\n        if (winnersHigh.length \u003c GROUP_NUM_LIMIT) {\n            winnersHigh.push(sender);\n        }\n\n        if (winnersHigh.length == GROUP_NUM_LIMIT) {\n            // 计算出3个随机index, 范围[0 - 8]\n            (uint256 idx1, uint256 idx2, uint256 idx3) = winnerNumber(GROUP_NUM_LIMIT);\n\n            // 开奖\n            for (uint256 i = 0; i \u003c winnersHigh.length; i++) {\n                address win = winnersHigh[i];\n                if (i == idx1 || i == idx2 || i == idx3) {\n                    // 通兑成功\n                    // 发送MOT\n                    TransferHelper.safeTransfer(mot, win, gammaAmount);\n                    forgeWinAmount[win].gammaAmount = forgeWinAmount[win].gammaAmount.add(gammaAmount);\n                    forgeWinAmount[win].usdtAmount = forgeWinAmount[win].usdtAmount.add(usdtAmount);\n\n                    // 一级推荐人获得4%\n                    address refAddr = getReferrer(win);\n                    referBonus[refAddr] = referBonus[refAddr].add(usdtAmount.mul(4).div(100));\n\n                    // 二级推荐人获得1%\n                    address refAddr2 = getReferrer(refAddr);\n                    referBonus[refAddr2] = referBonus[refAddr2].add(usdtAmount.mul(1).div(100));\n                } else {\n                    // 通兑失败\n                    // 退还110%\n                    uint256 amount = usdtAmount.add(usdtAmount.div(10));\n                    TransferHelper.safeTransfer(usdt, win, amount);\n\n                    // 一级推荐人获得0.8%\n                    address refAddr = getReferrer(win);\n                    referBonus[refAddr] = referBonus[refAddr].add(usdtAmount.mul(8).div(1000));\n\n                    // 二级推荐人获得0.2%\n                    address refAddr2 = getReferrer(refAddr);\n                    referBonus[refAddr2] = referBonus[refAddr2].add(usdtAmount.mul(2).div(1000));\n                }\n            }\n\n            updateLeftOver(gammaAmount);\n            updateTotalReferBonus(usdtAmount);\n\n            uint256 delta = usdtAmount.mul(3).mul(15).div(100);\n            updateRacePool(ss.round, delta);\n\n            delete winnersHigh;\n        }\n    }\n\n    // 查询推荐人地址\n    function getReferrer(address usr) public view returns (address) {\n        return refer.getReferrer(usr);\n    }\n\n    // 查询推荐的总人数\n    function getReferLength(address referrer) public view returns (uint256) {\n        return refer.getReferLength(referrer);\n    }\n\n    // get invite list\n    function getInviteList(address usr) public view returns (address[] memory) {\n        uint256 referLen = refer.getReferLength(usr);\n        address[] memory addrList = new address[](referLen);\n        for(uint256 i = 0; i \u003c referLen; i++) {\n            addrList[i] = refer.referList(usr, i);\n        }\n        return addrList;\n    }\n\n    // only dev\n    function distributeRewards(address to, uint256 amount) public returns (bool) {\n        require(msg.sender == devaddr, \"dev: only devaddr\");\n        TransferHelper.safeTransferFrom(usdt, devaddr, to, amount);\n        return true;\n    }\n\n    // Update dev address by the previous dev.\n    function dev(address _devaddr) public {\n        require(msg.sender == devaddr, \"dev: only devaddr\");\n        devaddr = _devaddr;\n    }\n\n    function setMOT(address _mot) public onlyOwner {\n        mot = _mot;\n    }\n\n    function setUSDT(address _usdt) public onlyOwner {\n        usdt = _usdt;\n    }\n\n    function setRankTopNum(uint256 value) public onlyOwner {\n        RANK_TOP_NUM = value;\n    }\n\n    function setRankTopMax(uint256 value) public onlyOwner {\n        RANK_TOP_MAX = value;\n    }\n\n    function withdrawUSDT(uint256 amount) public returns (bool) {\n        require(msg.sender == devaddr, \"dev: only devaddr\");\n        TransferHelper.safeTransfer(usdt, devaddr, amount);\n        return true;\n    }\n\n    function withdrawMOT(uint256 amount) public returns (bool) {\n        require(msg.sender == devaddr, \"dev: only devaddr\");\n        TransferHelper.safeTransfer(mot, devaddr, amount);\n        return true;\n    }\n}"},"TransferHelper.sol":{"content":"pragma solidity 0.5.8;\n\n// helper methods for interacting with TRC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes(\u0027approve(address,uint256)\u0027)));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))), \u0027TransferHelper: APPROVE_FAILED\u0027);\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes(\u0027transfer(address,uint256)\u0027)));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success, \u0027TransferHelper: TRANSFER_FAILED\u0027);\n        //        require(success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))), \u0027TransferHelper: TRANSFER_FAILED\u0027);\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes(\u0027transferFrom(address,address,uint256)\u0027)));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success, \u0027TransferHelper: TRANSFER_FROM_FAILED\u0027);\n        //        require(success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))), \u0027TransferHelper: TRANSFER_FROM_FAILED\u0027);\n    }\n\n    function safeTransferTRX(address to, uint value) internal {\n        (bool success,) = to.call.value(value)(new bytes(0));\n        require(success, \u0027TransferHelper: TRX_TRANSFER_FAILED\u0027);\n    }\n}"}}