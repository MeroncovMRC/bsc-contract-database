/**
 *Submitted for verification at polygonscan.com on 2023-07-20
*/

pragma solidity ^0.8.18;
//SPDX-License-Identifier: MIT

contract StakeShariah {
    address public adminAddr;
    address public projectAddr;
    address public developerAddr;
    address public maintenanceAddr;
    address public defaultReferralAddr;
    uint256 public referralLevel1Rate = 7;
    uint256 public referralLevel2Rate = 2;
    uint256 public referralLevel3Rate = 1;
    uint256 public monthlyPrecentage = 0;
    uint256 public adminFeeRate = 40;
    uint256 public maintenanceFee = 3;
    uint256 public developerFeeRate = 1;
    struct Referral {
    address referrer;
    uint8 level;
    }
    struct User {
        uint256 balance;
        uint256 totalDeposits;
        uint256 totalWithdrawals;
        address referral;
        uint256 referralEarnings;
        bool blocked;
        Referral referralData;
    }
    

    struct CapitalWithdrawalRequest {
        address user;
        uint256 amount;
        bool approved;
    }

    mapping(address => User) public users;
    CapitalWithdrawalRequest[] public capitalWithdrawalRequests;

    constructor(address _adminAddr, address _projectAddr, address _maintenanceAddr,address _developerAddr,
    address _refAdd) {
        adminAddr = _adminAddr;
        projectAddr = _projectAddr;
        developerAddr = _developerAddr;
        maintenanceAddr = _maintenanceAddr;
        defaultReferralAddr = _refAdd;
    }

    modifier onlyAdmin() {
        require(msg.sender == adminAddr, "Only admin can call this function");
        _;
    }

    modifier onlyDeveloper() {
        require(msg.sender == developerAddr, "Only developer can call this function");
        _;
    }

    modifier notBlocked() {
        require(!users[msg.sender].blocked, "User is blocked");
        _;
    }

    modifier validReferral(address _referral) {
        require(_referral != msg.sender, "Cannot set self as upline partner");
        _;
    }

    function invest(address _referral) external payable notBlocked validReferral(_referral) {
    require(msg.value >= 0.01 ether, "Minimum amount for investing is 0.01 ether");

    User storage user = users[msg.sender];
    address userRef;
    if (user.referral == address(0)) {
        user.referral = _referral;
        userRef = _referral;
    }
    uint256 referralEarnings = 0;

  
    if (_referral != address(0) && _referral != msg.sender) {
        // First level referral earnings
        referralEarnings = (msg.value * referralLevel1Rate) / 100;
        
        if(user.referralData.referrer == address(0)){
        users[_referral].referralEarnings += referralEarnings;
        user.referralData.referrer = _referral;
        user.referralData.level = 1;
        }else{
        // Second level referral earnings
        address referrer2 = users[_referral].referral;
        userRef = users[_referral].referral;
        if (referrer2 != address(0) && referrer2 != msg.sender) {
           

            // Third level referral earnings
            uint256 level = users[referrer2].referralData.level;
            if(level ==1) {
            referralEarnings = (msg.value * referralLevel2Rate) / 100;
            users[referrer2].referralEarnings += referralEarnings;
            user.referralData.referrer = referrer2;
            user.referralData.level = 2;
            }
            if (level == 3 || level == 2) {
                uint256 referralEarnings3 = (msg.value * referralLevel3Rate) / 100;
                users[referrer2].referralEarnings += referralEarnings3;
                user.referralData.level = 3;
            }
        }
        }
    }

    uint256 maintenanceValue = (msg.value * maintenanceFee) / 100;
    uint256 adminFee = (msg.value * adminFeeRate) / 100;
    uint256 projectFee = msg.value - maintenanceValue - referralEarnings - adminFee;

    // Transfer fees
    payable(maintenanceAddr).transfer(maintenanceValue);
    payable(adminAddr).transfer(adminFee);
    payable(projectAddr).transfer(projectFee);
    payable(userRef).transfer(referralEarnings);

    user.balance += msg.value - maintenanceValue;
    user.totalDeposits += msg.value  - maintenanceValue; // Update totalDeposits value
}



    function withdraw(uint256 _amount) external notBlocked {
        require(_amount > 0, "Invalid withdrawal amount");
        User storage user = users[msg.sender];

        uint256 profit = calculateProfit(msg.sender);
            require(profit >= _amount, "Insufficient profit for withdrawal");
        require(user.balance >= profit, "Insufficient balance for withdrawal");

        uint256 adminFee = (profit * 2) / 100;
        uint256 devVal = (profit * 1) / 100;
        uint256 withdrawAmount = _amount - adminFee - devVal;

        user.balance -= _amount;
        user.totalWithdrawals += withdrawAmount;

        // Transfer fees
        payable(maintenanceAddr).transfer(adminFee);
        payable(developerAddr).transfer(devVal);
        payable(msg.sender).transfer(withdrawAmount);
    }
    ///
    function reinvest() external notBlocked {
        User storage user = users[msg.sender];

        uint256 profit = calculateProfit(msg.sender);
        require(profit > 0, "No profit available");

        uint256 reinvestAmount = profit;

        user.balance += reinvestAmount;
        user.totalDeposits += reinvestAmount;

        // Transfer
        payable(projectAddr).transfer(reinvestAmount);
    }
    function capitalWithdraw(uint256 _amount) external notBlocked {
        User storage user = users[msg.sender];
        require(user.balance >= _amount, "Insufficient balance for capital withdrawal");

        CapitalWithdrawalRequest memory request = CapitalWithdrawalRequest(msg.sender, _amount, false);
        capitalWithdrawalRequests.push(request);
    }

    function approveCapitalWithdrawal(uint256 _requestIndex) external onlyAdmin {
    require(_requestIndex < capitalWithdrawalRequests.length, "Invalid request index");

    CapitalWithdrawalRequest storage request = capitalWithdrawalRequests[_requestIndex];
    require(!request.approved, "Request already approved");

    User storage user = users[request.user];
    require(user.balance >= request.amount, "Insufficient balance for capital withdrawal");

    uint256 projectFee = (request.amount * 14) / 100;
    uint256 developerFee = (request.amount * developerFeeRate) / 100;

    user.balance -= request.amount;
    user.totalWithdrawals += request.amount;

    // Transfer fees and amount
    payable(projectAddr).transfer(projectFee);
    payable(developerAddr).transfer(developerFee);
    payable(request.user).transfer(request.amount  - projectFee - developerFee);

    request.approved = true;
}

    function calculateProfit(address _user) internal view returns (uint256) {
        User storage user = users[_user];
        uint256 daysSinceLastDeposit = (block.timestamp - user.totalDeposits) / 86400;
        uint256 monthly = (monthlyPrecentage * user.balance) / 100;
        uint256 profit = (monthly * daysSinceLastDeposit) / 30;
        return profit;
    }

    function setMonthlyPrecentage(uint256 _Rate) external onlyAdmin {
        monthlyPrecentage = _Rate;
    }

    function blockUser(address _user) external onlyAdmin {
        require(_user != developerAddr);
        users[_user].blocked = true;
    }

    function unblockUser(address _user) external onlyAdmin {
        users[_user].blocked = false;
    }

    function getUserBalance(address _user) external view returns (uint256) {
        return users[_user].balance;
    }

    function getUserProfit(address _user) external view returns (uint256) {
    User storage user = users[_user];
    uint256 daysSinceLastDeposit = (block.timestamp - user.totalDeposits) / 86400;

    // Check if user has made any deposits
    if (user.totalDeposits == 0 || daysSinceLastDeposit < 30) {
        return 0;
    }

    uint256 monthly = (monthlyPrecentage * user.balance) / 100;
    uint256 profit = (monthly * daysSinceLastDeposit) / 30;

    // Ensure profit doesn't exceed balance
    if (profit > user.balance) {
        profit = user.balance;
    }

    return profit;
}


    function getReferralEarnings(address _user) external view returns (uint256) {
        return users[_user].referralEarnings;
    }

    function getTotalDeposits(address _user) external view returns (uint256) {
        return users[_user].totalDeposits;
    }

    function getTotalWithdrawals(address _user) external view returns (uint256) {
        return users[_user].totalWithdrawals;
    }

    function deposit() external payable onlyAdmin {}

    function getReferralAddress(address _user) external view returns (address) {
        return users[_user].referral;
    }
    ///
    function getActiveCapitalWithdrawalRequests() external view returns (CapitalWithdrawalRequest[] memory) {
    uint256 count = 0;
    for (uint256 i = 0; i < capitalWithdrawalRequests.length; i++) {
        if (!capitalWithdrawalRequests[i].approved) {
            count++;
        }
    }

    CapitalWithdrawalRequest[] memory activeRequests = new CapitalWithdrawalRequest[](count);
    uint256 currentIndex = 0;
    for (uint256 i = 0; i < capitalWithdrawalRequests.length; i++) {
        if (!capitalWithdrawalRequests[i].approved) {
            activeRequests[currentIndex] = capitalWithdrawalRequests[i];
            currentIndex++;
        }
    }

    return activeRequests;
}
}