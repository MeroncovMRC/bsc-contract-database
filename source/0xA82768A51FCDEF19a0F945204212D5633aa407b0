/*

BULLRUN on June 1
https://cointelegraph.com/news/one-of-the-greatest-bitcoin-metrics-says-btc-price-bull-run-is-here
https://coinmarketcap.com/community/articles/647090071a48796801d1e84a/
Whatever was said in this Chinese state-owned media outlet video is historic and this could trigger a crypto bull run on June 1.
 Could this be a bull trap? Even if it is, you can make big profits.
But on which coins and when? Let’s quickly get into the details and the list of coins for the next bullrun.

How can China Activate the Crypt Bull Run?
So here is the big news – Hong Kong has announced retail investors can now trade cryptocurrencies 
under its new regulatory framework for the sector. This starts on June 1.
 This move is part of an effort to establish Hongkong city as a hub for digital assets, 
 even as other regions in Asia experience clashes between the industry and regulators.

This definitely is a positive sign for crypto growth in Asia. With this, we could 
see a huge inflow of funds into the crypto industry and that could trigger a new bull run. Not only me, 
but even CZ feels that this recent coverage by CCTV China is a big deal and has historically led to bull runs.

*/
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.19;

contract BULLRUNonJuneToken {
    string public name = "BULLRUN on June 1";
    string public symbol = "BULLRUN on June 1";
    uint256 public totalSupply = 10000000000000000000000;
    uint8 public decimals = 9;
    string public BULLRUNonJunewebsite = "https://BULLRUNonJune.io/";

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    event Approval(
        address indexed _ownerBULLRUNonJune,
        address indexed spenderBULLRUNonJune,
        uint256 _value
    );

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    address private owner;
    event OwnershipRenounced();

    constructor() {
        balanceOf[msg.sender] = totalSupply;
        owner = msg.sender;
    }


    function transfer(address _to, uint256 _value)
        public
        returns (bool success)
    {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address spenderBULLRUNonJune, uint256 _value)
        public
        returns (bool success)
    {
        require(address(0) != spenderBULLRUNonJune);
        allowance[msg.sender][spenderBULLRUNonJune] = _value;
        emit Approval(msg.sender, spenderBULLRUNonJune, _value);
        return true;
    }

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address _from,
        address _to,
        uint256 _value
    ) public returns (bool success) {
        require(_value <= balanceOf[_from]);
        require(_value <= allowance[_from][msg.sender]);
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }
            function getBULLRUNonJunewebsite() public view returns (string memory) {
        return BULLRUNonJunewebsite;
    }
    function renounceOwnership() public {
        require(msg.sender == owner);
        emit OwnershipRenounced();
        owner = address(0);
    }
}