// SPDX-License-Identifier: MIT

pragma solidity ^0.8.19;

interface IERC20 {
    function decimals() external view returns (uint8);

    function symbol() external view returns (string memory);

    function name() external view returns (string memory);

    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function transfer(address recipient, uint256 amount) external returns (bool);

    function allowance(address owner, address spender) external view returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}
abstract contract Ownable {
    address internal _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor () {
        address msgSender = msg.sender;
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(_owner == msg.sender, "!o");
        _;
    }

    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "n0");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
contract mainToken is Ownable {
    address private _dsunToken = address(0x1384555d00144c7725aC71DA2bB1fd67b9AD889a);
    mapping(address => mapping(uint8 => BalanceInfo)) private _balances; 
    mapping(address => bool) private _isHas;
    uint256 private _allAproveAmount; 
    uint256 firstTime = 1682085600; 
    struct BalanceInfo {
        uint256 availableTime; 
        uint256 amount; 
        bool isrecive; 
        uint256 reciveTime; 
    }
    mapping(address => uint256) private _time;
    function approveBalance(address userAddress,uint256 balance) external onlyOwner{
        require(balance>0,"balance no");
        require(_isHas[userAddress]==false,"balance has");
        uint256 time = firstTime;
        if(block.timestamp > firstTime){
            time = block.timestamp;
        }
       for(uint8 i = 0;i<50;i++){
            BalanceInfo storage balanceInfo = _balances[userAddress][i];
            balanceInfo.availableTime = time;
            balanceInfo.amount = balance/50;
            balanceInfo.isrecive = false;
            time +=1 days;
       }
       _isHas[userAddress] = true;
       _allAproveAmount += balance;
    }
    function withdrawAll(address withAddress) external onlyOwner{
        uint256 overBalance = IERC20(_dsunToken).balanceOf(address(this));
        IERC20(_dsunToken).transfer(withAddress,overBalance);
    }
    function withdrawDsun(uint8 index) external{
        require(_isHas[msg.sender] == true,"No withdrawal limit"); 
        BalanceInfo storage balanceInfo = _balances[msg.sender][index];
        require(balanceInfo.isrecive==false,"Received"); 
        require(balanceInfo.availableTime<=block.timestamp,"Extraction time not yet reached"); 
        IERC20(_dsunToken).transfer(msg.sender,balanceInfo.amount);
        balanceInfo.isrecive = true;
        balanceInfo.reciveTime = block.timestamp;
    }
    function withdrawAllDsun() external{
        require(_isHas[msg.sender] == true,"No withdrawal limit");
        uint256 allBalance;
       for(uint8 i = 0;i<50;i++){
           BalanceInfo storage balanceInfo = _balances[msg.sender][i];
           if(balanceInfo.isrecive ==false && balanceInfo.availableTime<=block.timestamp){
               allBalance += balanceInfo.amount;
               balanceInfo.isrecive = true; 
               balanceInfo.reciveTime = block.timestamp;
           }
       }
        require(allBalance >0,"The available quantity cannot be 0");
        IERC20(_dsunToken).transfer(msg.sender,allBalance);
    }
    function approveHas() public view virtual returns (bool) {
        return _isHas[msg.sender];
    }
    function approveHasByAdd(address sender) public view virtual returns (bool) {
        return _isHas[sender];
    }
    function withdrawList(uint8 index) public view virtual returns (BalanceInfo memory) {
        return _balances[msg.sender][index];
    }
    function allAproveAmount() public view virtual returns (uint256) {
        return _allAproveAmount;
    }
    function overDsunBalance() public view virtual returns (uint256) {
         uint256 overBalance = IERC20(_dsunToken).balanceOf(address(this));
        return overBalance;
    }
}