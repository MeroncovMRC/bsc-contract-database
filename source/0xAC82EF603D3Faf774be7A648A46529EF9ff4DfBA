{"busdoracle.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.7;\r\n\r\n// File: @chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\r\nimport \"./IERC20.sol\";\r\nimport \"./Ownable.sol\";\r\nimport \"./Chain.sol\";\r\n\r\ncontract BusdOracle is Context, Ownable {\r\n    AggregatorV3Interface internal priceFeed;\r\n\r\n    uint256 public constant min = 20 ether;\r\n    uint256 public max = 20000 ether;\r\n    uint256 roi = 30;\r\n    uint256 public constant fee = 8;\r\n    uint256 public constant ref_fee = 5;\r\n    int256 public pricediff;\r\n    uint256 public Timelast;\r\n    int256 public lastprice;\r\n    address public dev;\r\n    address public mkt;\r\n    address public mkt2;\r\n    IERC20 private BusdInterface;\r\n    address public tokenAdress;\r\n    address Oracleholder = address(0);\r\n    uint256 topdeposit;\r\n    bool public init = false;\r\n    address[] public Whitelist_TSLA;\r\n\r\n    constructor(address _dev, address _mkt, address _mkt2) {\r\n        require(!isContract(_dev) \u0026\u0026 !isContract(_mkt) \u0026\u0026 !isContract(_mkt2));\r\n        dev = _dev;\r\n        mkt = _mkt;\r\n        mkt2 = _mkt2;\r\n        priceFeed = AggregatorV3Interface(0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE); //BNB/usd pricefeed mainnet\r\n        //priceFeed = AggregatorV3Interface(0x2514895c72f50D8bd4B4F9b1110F0D6bD2c97526); //BNB/usd pricefeed testnet\r\n        //tokenAdress = 0x25C7c87B42ec086b01528eE72465F1e3c49B7B9D; //testnet\r\n        tokenAdress = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56; //Mainnet\r\n        BusdInterface = IERC20(tokenAdress);\r\n        lastprice = getLatestPrice();\r\n        }\r\n\r\n    struct refferal_system {\r\n        address ref_address;\r\n        uint256 reward;\r\n    }\r\n\r\n    struct refferal_withdraw {\r\n        address ref_address;\r\n        uint256 totalWithdraw;\r\n    }\r\n\r\n    struct user_investment_details {\r\n        address user_address;\r\n        uint256 invested;\r\n    }\r\n\r\n    struct weeklyWithdraw {\r\n        address user_address;\r\n        uint256 startTime;\r\n        uint256 deadline;\r\n    }\r\n\r\n    struct claimDaily {\r\n        address user_address;\r\n        uint256 startTime;\r\n        uint256 deadline;\r\n    }\r\n\r\n    struct userWithdrawal {\r\n        address user_address;\r\n        uint256 amount;\r\n    }\r\n\r\n    struct userTotalWithdraw {\r\n        address user_address;\r\n        uint256 amount;\r\n    }\r\n     struct userTotalRewards {\r\n        address user_address;\r\n        uint256 amount;\r\n    } \r\n    struct userUnlock {\r\n        address user_address;\r\n        bool lock;\r\n    } \r\n\r\n    mapping(address =\u003e refferal_system) public refferal;\r\n    mapping(address =\u003e user_investment_details) public investments;\r\n    mapping(address =\u003e weeklyWithdraw) public weekly;\r\n    mapping(address =\u003e claimDaily) public claimTime;\r\n    mapping(address =\u003e userWithdrawal) public approvedWithdrawal;\r\n    mapping(address =\u003e userTotalWithdraw) public totalWithdraw;\r\n    mapping(address =\u003e userTotalRewards) public totalRewards; //hhnew \r\n    mapping(address =\u003e refferal_withdraw) public refTotalWithdraw;\r\n    mapping(address =\u003e userUnlock) public unlock;\r\n\r\n    function ChangeROI() private {\r\n        if (getLatestPrice() - lastprice != 0){\r\n        pricediff = getLatestPrice() - lastprice;\r\n        if (pricediff \u003c 0 \u0026\u0026 roi \u003c= 50) {roi += 1;}\r\n        else if (pricediff \u003e 0 \u0026\u0026 roi \u003e= 10 ) { roi -= 1;}\r\n        }\r\n        lastprice = getLatestPrice();\r\n    }\r\n\r\n    // invest function \r\n    function deposit(address _ref, uint256 _amount) public  {\r\n        require(init \u0026\u0026 !isContract(msg.sender));\r\n        require(_amount \u003e= min \u0026\u0026 _amount \u003c= max, \"Cannot Deposit\");\r\n\r\n        //ref system\r\n        if(!checkAlready()){  \r\n            uint256 ref_fee_add = refFee(_amount);\r\n        if(_ref != address(0) \u0026\u0026 _ref != msg.sender) {\r\n            uint256 ref_last_balance = refferal[_ref].reward;\r\n            uint256 totalRefFee = ref_fee_add + ref_last_balance;   \r\n            refferal[_ref] = refferal_system(_ref,totalRefFee);\r\n        }\r\n        //dev \u0026 mkt get 1/4 of unused ref each, 1/2 stays in the contract\r\n        else {\r\n            uint256 ref_last_balance = refferal[dev].reward;\r\n            uint256 refmkt_last_balance = refferal[mkt].reward;\r\n            uint256 totalRefFee = (ref_fee_add / 4) + ref_last_balance; \r\n            uint256 totalRefFee2 = (ref_fee_add / 4) + refmkt_last_balance; \r\n            refferal[dev] = refferal_system(dev,totalRefFee);\r\n            refferal[mkt] = refferal_system(mkt,totalRefFee2);\r\n            }\r\n        }\r\n        \r\n        // investment details\r\n        uint256 userLastInvestment = investments[msg.sender].invested;\r\n        uint256 userCurrentInvestment = _amount - depositFee(_amount);\r\n        uint256 totalInvestment = userLastInvestment + userCurrentInvestment;\r\n        investments[msg.sender] = user_investment_details(msg.sender,totalInvestment);\r\n\r\n        // fees \r\n        uint256 total_fee = depositFee(_amount);\r\n        uint256 fee_mkt2 = total_fee / 8;\r\n        uint256 fee_gen = (total_fee - fee_mkt2) / 2;\r\n        uint256 total_contract = _amount - total_fee;\r\n        BusdInterface.transferFrom(msg.sender,dev,fee_gen);\r\n        BusdInterface.transferFrom(msg.sender,mkt,fee_gen);\r\n        BusdInterface.transferFrom(msg.sender,mkt2,fee_mkt2);\r\n        BusdInterface.transferFrom(msg.sender,address(this),total_contract);\r\n\r\n        //register the whitelist\r\n        if (totalInvestment \u003e= 500 ether){\r\n            Whitelist_TSLA.push(msg.sender);\r\n        }\r\n\r\n        //oracle swap\r\n        if (_amount \u003e topdeposit){\r\n            Oracleholder = msg.sender;\r\n            topdeposit = _amount;\r\n        }\r\n\r\n        ChangeROI();\r\n        UpdateTime();        \r\n    }\r\n\r\n    function UpdateTime() internal {\r\n        if (unlock[msg.sender].lock == false){\r\n        uint256 claimTimeStart = block.timestamp;\r\n        uint256 claimTimeEnd = block.timestamp + 1 days;\r\n        claimTime[msg.sender] = claimDaily(msg.sender,claimTimeStart,claimTimeEnd);\r\n\r\n        uint256 weeklyStart = block.timestamp;\r\n        uint256 deadline_weekly = block.timestamp + 7 days;\r\n        weekly[msg.sender] = weeklyWithdraw(msg.sender,weeklyStart,deadline_weekly);\r\n        } \r\n        else if (unlock[msg.sender].lock == true){\r\n        uint256 claimTimeStart = block.timestamp;\r\n        uint256 claimTimeEnd = block.timestamp + 120 days;\r\n        claimTime[msg.sender] = claimDaily(msg.sender,claimTimeStart,claimTimeEnd);\r\n\r\n        uint256 weeklyStart = block.timestamp;\r\n        uint256 deadline_weekly = block.timestamp + 120 days;\r\n        weekly[msg.sender] = weeklyWithdraw(msg.sender,weeklyStart,deadline_weekly);\r\n        }\r\n    }\r\n\r\n    function userReward(address _userAddress) public view returns(uint256) {\r\n        uint256 userInvestment = investments[_userAddress].invested;\r\n        uint256 userDailyReturn;\r\n        if (unlock[_userAddress].lock == true){\r\n\r\n            //if unlocked the calculation or daily rewards has to be multiplied by the days assigned to get the same daily %\r\n            userDailyReturn = DailyRoi(userInvestment) * 117;\r\n        } \r\n        else {\r\n            userDailyReturn = DailyRoi(userInvestment);\r\n        } \r\n    \r\n        // invested time\r\n        uint256 claimInvestTime = claimTime[_userAddress].startTime;\r\n        uint256 claimInvestEnd = claimTime[_userAddress].deadline;\r\n\r\n        uint256 totalTime = claimInvestEnd - claimInvestTime;\r\n        uint256 value = userDailyReturn / totalTime;\r\n        uint256 nowTime = block.timestamp;\r\n\r\n        if(claimInvestEnd \u003e= nowTime) {  //|| unlock[msg.sender].lock == true\r\n        uint256 earned = nowTime - claimInvestTime;\r\n        uint256 totalEarned = earned * value;\r\n\r\n        return totalEarned;\r\n        }\r\n        else {\r\n            return userDailyReturn;\r\n        }\r\n    }\r\n\r\n    function withdrawal() public {\r\n    require(init, \"Not Started Yet\");   \r\n    if (unlock[msg.sender].lock == false){\r\n            require(weekly[msg.sender].deadline \u003c= block.timestamp, \"You cant withdraw\");    \r\n            uint256 weeklyStart = block.timestamp;\r\n            uint256 deadline_weekly = block.timestamp + 7 days;\r\n            weekly[msg.sender] = weeklyWithdraw(msg.sender,weeklyStart,deadline_weekly);\r\n        } \r\n    \r\n    uint256 aval_withdraw = approvedWithdrawal[msg.sender].amount;\r\n    BusdInterface.transfer(msg.sender,aval_withdraw);\r\n    approvedWithdrawal[msg.sender] = userWithdrawal(msg.sender , 0 ); \r\n    uint256 amount = totalWithdraw[msg.sender].amount;\r\n    uint256 totalAmount = amount + aval_withdraw; \r\n    totalWithdraw[msg.sender] = userTotalWithdraw(msg.sender,totalAmount);\r\n\r\n    ChangeROI();\r\n    }\r\n    \r\n    function compound() public {\r\n    require(init, \"Not Started Yet\");   \r\n\r\n    if (unlock[msg.sender].lock == false){    \r\n            if (weekly[msg.sender].deadline \u003c= block.timestamp){\r\n            weekly[msg.sender].deadline = block.timestamp + 1 days; \r\n            }\r\n            else {\r\n            weekly[msg.sender].deadline += 1 days;\r\n            }\r\n        } \r\n    \r\n    uint256 aval_withdraw = approvedWithdrawal[msg.sender].amount;\r\n    approvedWithdrawal[msg.sender] = userWithdrawal(msg.sender , 0); \r\n    \r\n    if (unlock[msg.sender].lock == false){\r\n        uint256 claimTimeStart = block.timestamp;\r\n        uint256 claimTimeEnd = block.timestamp + 1 days;\r\n        claimTime[msg.sender] = claimDaily(msg.sender,claimTimeStart,claimTimeEnd);\r\n        } \r\n        else if (unlock[msg.sender].lock == true){\r\n        uint256 claimTimeStart = block.timestamp;\r\n        uint256 claimTimeEnd = block.timestamp + 120 days;\r\n        claimTime[msg.sender] = claimDaily(msg.sender,claimTimeStart,claimTimeEnd);\r\n        }\r\n\r\n    // investment details\r\n    uint256 userLastInvestment = investments[msg.sender].invested;\r\n    uint256 userCurrentInvestment = aval_withdraw;\r\n    uint256 totalInvestment = userLastInvestment + userCurrentInvestment;\r\n    investments[msg.sender] = user_investment_details(msg.sender,totalInvestment);\r\n\r\n    ChangeROI();\r\n    }\r\n    \r\n    function claimDailyRewards() public {\r\n        require(init, \"Not Started Yet\");\r\n        \r\n        //claim rewards before assigning a new claiming time\r\n        uint256 rewards = userReward(msg.sender);\r\n        uint256 claimTimeStart = block.timestamp;\r\n        //check the current state of the lock and assign a new claiming time\r\n        if (unlock[msg.sender].lock == false){\r\n            require(claimTime[msg.sender].deadline \u003c= block.timestamp, \"You cant claim\");          \r\n            uint256 claimTimeEnd = block.timestamp + 1 days;\r\n            claimTime[msg.sender] = claimDaily(msg.sender,claimTimeStart,claimTimeEnd);\r\n        }\r\n\r\n        else if (unlock[msg.sender].lock == true){\r\n        uint256 claimTimeEnd = claimTimeStart + 120 days;\r\n        claimTime[msg.sender] = claimDaily(msg.sender,claimTimeStart,claimTimeEnd);\r\n        }\r\n        \r\n        uint256 currentApproved = approvedWithdrawal[msg.sender].amount;\r\n        uint256 value = rewards + currentApproved;\r\n\r\n        approvedWithdrawal[msg.sender] = userWithdrawal(msg.sender,value);\r\n        uint256 amount = totalRewards[msg.sender].amount; \r\n        uint256 totalRewardAmount = amount + rewards; \r\n        totalRewards[msg.sender].amount = totalRewardAmount;\r\n\r\n        //if 7 days have passed OracleHolder resets\r\n        if (claimTimeStart - Timelast \u003e= 7 days){\r\n            Oracleholder = address(0);\r\n            topdeposit = 0;\r\n            Timelast = claimTimeStart;\r\n        }\r\n\r\n        //the oracle holder receives a bonus on any claim\r\n        if (msg.sender != Oracleholder){\r\n        uint256 BonusOracle = (rewards * 2 / 100) + approvedWithdrawal[Oracleholder].amount;\r\n        approvedWithdrawal[Oracleholder] = userWithdrawal(Oracleholder,BonusOracle);\r\n        }\r\n\r\n        //set new ROI\r\n        ChangeROI();\r\n    }\r\n\r\n    \r\n    function unlockTime() external {\r\n        require(init, \"Not Started Yet\");\r\n        require(unlock[msg.sender].lock == false, \"Already unlocked\");\r\n        BusdInterface.transferFrom(msg.sender,address(this), 200 ether);\r\n        \r\n        //get rewards before unlocking to avoid that current rewards are multiplied by 120\r\n        uint256 rewards = userReward(msg.sender);\r\n        uint256 currentApproved = approvedWithdrawal[msg.sender].amount;\r\n        uint256 value = rewards + currentApproved;\r\n\r\n        approvedWithdrawal[msg.sender] = userWithdrawal(msg.sender,value);\r\n        uint256 amount = totalRewards[msg.sender].amount;\r\n        uint256 totalRewardAmount = amount + rewards;\r\n        totalRewards[msg.sender].amount = totalRewardAmount;\r\n\r\n        //set new timeline and unlock\r\n        uint256 claimTimeStart = block.timestamp;\r\n        uint256 claimTimeEnd = block.timestamp + 120 days;\r\n        claimTime[msg.sender] = claimDaily(msg.sender,claimTimeStart,claimTimeEnd);\r\n\r\n        uint256 weeklyStart = block.timestamp;\r\n        uint256 deadline_weekly = block.timestamp + 120 days;\r\n        weekly[msg.sender] = weeklyWithdraw(msg.sender,weeklyStart,deadline_weekly);\r\n\r\n        unlock[msg.sender].lock = true;\r\n    }\r\n\r\n    function Ref_Withdraw() external {\r\n        require(init, \"Not Started Yet\");\r\n        uint256 value = refferal[msg.sender].reward;\r\n\r\n        BusdInterface.transfer(msg.sender,value);\r\n        refferal[msg.sender] = refferal_system(msg.sender,0);\r\n\r\n        uint256 lastWithdraw = refTotalWithdraw[msg.sender].totalWithdraw;\r\n        uint256 totalValue = value + lastWithdraw;\r\n\r\n        refTotalWithdraw[msg.sender] = refferal_withdraw(msg.sender,totalValue);\r\n    }\r\n\r\n    // initialized the market\r\n    function signal_market() external onlyOwner {\r\n        require (init == false, \"Already Init\");\r\n        init = true;\r\n        unlock[msg.sender].lock = true;\r\n        Timelast = block.timestamp;\r\n    }\r\n\r\n    function changeDev (address _dev, address _mkt, address _mkt2) external onlyOwner {\r\n        dev = _dev;\r\n        mkt = _mkt;\r\n        mkt2 = _mkt2;\r\n    }\r\n\r\n    //to be used if the max is reached so the Oracle can be passed again\r\n    function changeMaxdep (uint256 _max) external onlyOwner {\r\n        require (_max \u003e max, \"you cant lower max deposit\");\r\n        max = _max;\r\n    }\r\n\r\n\r\n    function getWhitelist() public view returns(address[] memory)\r\n    {\r\n        return Whitelist_TSLA;\r\n    }\r\n\r\n    \r\n\r\n    // only view functions\r\n    function isContract(address addr) internal view returns (bool) {\r\n        uint size;\r\n        assembly { size := extcodesize(addr) }\r\n        return size \u003e 0;\r\n    }\r\n\r\n    // call Chainlink to fetch a new BNB price\r\n    function getLatestPrice() public view returns (int) {\r\n        (\r\n            ,\r\n            /*uint80 roundID*/ int price /*uint startedAt*/ /*uint timeStamp*/ /*uint80 answeredInRound*/,\r\n            ,\r\n            ,\r\n        ) = priceFeed.latestRoundData();\r\n        return price;\r\n    }\r\n\r\n    function DailyRoi(uint256 _amount) public view returns(uint256) {\r\n            return _amount * roi / 1000;\r\n    }\r\n\r\n    function OracleHolder() external view returns(address) {\r\n            return Oracleholder;\r\n    }\r\n\r\n    function returnROI() external view returns(uint256) {\r\n            return roi;\r\n    }\r\n    \r\n    function returnDIFF() external view returns(int256) {\r\n            return pricediff;\r\n    }\r\n\r\n    function Topdeposit() external view returns(uint256) {\r\n            return topdeposit;\r\n    }\r\n\r\n    function checkAlready() public view returns(bool) {\r\n         address _address= msg.sender;\r\n        if(investments[_address].user_address == _address){\r\n            return true;\r\n        }\r\n        else{\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function depositFee(uint256 _amount) public pure returns(uint256){\r\n     return _amount * fee / 100;\r\n    }\r\n\r\n    function refFee(uint256 _amount) public pure returns(uint256) {\r\n        return _amount * ref_fee / 100;\r\n    }\r\n\r\n    function getBalance() public view returns(uint256){\r\n         return BusdInterface.balanceOf(address(this));\r\n    }\r\n\r\n    function checkLock(address _address) public view returns(bool){\r\n         return unlock[_address].lock;\r\n    }\r\n\r\n}\r\n"},"Chain.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface AggregatorV3Interface {\r\n  function decimals() external view returns (uint8);\r\n\r\n  function description() external view returns (string memory);\r\n\r\n  function version() external view returns (uint256);\r\n\r\n  function getRoundData(uint80 _roundId)\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n\r\n  function latestRoundData()\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n}\r\n"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.7;\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n    * @dev Initializes the contract setting the deployer as the initial owner.\r\n    */\r\n    constructor () {\r\n      address msgSender = _msgSender();\r\n      _owner = msgSender;\r\n      emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the address of the current owner.\r\n    */\r\n    function owner() public view returns (address) {\r\n      return _owner;\r\n    }\r\n\r\n    \r\n    modifier onlyOwner() {\r\n      require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n      _;\r\n    }\r\n\r\n    function renounceOwnership() public onlyOwner {\r\n      emit OwnershipTransferred(_owner, address(0));\r\n      _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n      _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal {\r\n      require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n      emit OwnershipTransferred(_owner, newOwner);\r\n      _owner = newOwner;\r\n    }\r\n}\r\n"}}