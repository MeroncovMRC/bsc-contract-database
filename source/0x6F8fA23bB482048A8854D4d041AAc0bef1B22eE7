{"agt.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./erc20.sol\";\ncontract AGT is ERC20{\n    address public owner;\n    address public minter;\n\n    constructor() ERC20(\"ATM Governance Token\", \"AGT\", 18){\n        owner = msg.sender;\n    }\n    \n    function setOwner(address user) external{\n        require(msg.sender == owner, \"GTA: only owner\");\n        require(user != address(0), \"user address cannot be 0\");\n        owner = user;\n    }\n   \n    function setMinter(address user) external{\n        require(msg.sender == owner, \"GTA: only owner\");\n        require(user != address(0), \"user address cannot be 0\");\n        minter = user;\n    }\n\n    function mint(address to, uint256 value) external{\n        require(msg.sender == minter, \"GTA: only minter\");\n        _mint(to, value);\n    }\n    \n    function burn(uint256 amount) external{\n        _burn(amount);\n    }\n}\n"},"erc20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary SafeMath {\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n        uint256 c = a + b;\n        if (c \u003c a) return (false, 0);\n        return (true, c);\n    }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n        if (b \u003e a) return (false, 0);\n        return (true, a - b);\n    }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n    }\n\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n    }\n\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n    }\n\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n    unchecked {\n        require(b \u003c= a, errorMessage);\n        return a - b;\n    }\n    }\n\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n    unchecked {\n        require(b \u003e 0, errorMessage);\n        return a / b;\n    }\n    }\n\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n    unchecked {\n        require(b \u003e 0, errorMessage);\n        return a % b;\n    }\n    }\n}\n\ncontract ERC20 {\n    using SafeMath for uint256;\n   \n    string   public name;\n    string   public symbol;\n    uint8    public decimals;\n    uint256  public totalSupply;\n \n    mapping (address =\u003e uint256) private balances;\n    mapping (address =\u003e mapping (address =\u003e uint256)) private allowances;\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    \n    constructor (string memory _name, string memory _symbol, uint8 _decimals) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n    }\n\n    function balanceOf(address owner) public view returns (uint256) {\n        return balances[owner];\n    }\n    \n    function allowance(address owner, address spender) public view returns(uint256) {\n        return allowances[owner][spender];\n    }\n    \n    function approve(address spender, uint256 amount) external returns(bool) {\n        allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) external returns (bool) {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function transferFrom(address owner, address to, uint256 amount) external returns(bool) {\n        require(allowances[owner][msg.sender] \u003e= amount, \"ERC20: transfer amount exceeds allowance\");\n        allowances[owner][msg.sender] = allowances[owner][msg.sender].sub(amount);\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    function _transfer(address from, address to, uint256 amount) internal {\n        require(to != address(0), \"to address cannot be 0\");\n        balances[from] = balances[from].sub(amount);\n        balances[to] =  balances[to].add(amount);\n        emit Transfer(from, to, amount);\n    }\n    \n    function _mint(address to, uint256 amount) internal {\n        require(to != address(0), \"to address cannot be 0\");\n        balances[to] = balances[to].add(amount);\n        totalSupply = totalSupply.add(amount);\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(uint256 amount) internal {\n        balances[msg.sender] = balances[msg.sender].sub(amount);\n        totalSupply = totalSupply.sub(amount);\n        emit Transfer(msg.sender, address(0), amount);\n    }\n}\n\n"}}