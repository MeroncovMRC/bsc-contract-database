// SPDX-License-Identifier: GPL-3.0-or-later

// File: contracts/interface/IPancakeswapRouter.sol


pragma solidity ^0.8.0;

interface IPancakeswapRouter {
    function factory() external pure returns (address);

    function WETH() external pure returns (address);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint256 amountADesired,
        uint256 amountBDesired,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    )
        external
        returns (
            uint256 amountA,
            uint256 amountB,
            uint256 liquidity
        );

    function addLiquidityETH(
        address token,
        uint256 amountTokenDesired,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    )
        external
        payable
        returns (
            uint256 amountToken,
            uint256 amountETH,
            uint256 liquidity
        );

    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint256 liquidity,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountA, uint256 amountB);

    function removeLiquidityETH(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountToken, uint256 amountETH);

    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint256 liquidity,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline,
        bool approveMax,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (uint256 amountA, uint256 amountB);

    function removeLiquidityETHWithPermit(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline,
        bool approveMax,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (uint256 amountToken, uint256 amountETH);

    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapTokensForExactTokens(
        uint256 amountOut,
        uint256 amountInMax,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapExactETHForTokens(
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable returns (uint256[] memory amounts);

    function swapTokensForExactETH(
        uint256 amountOut,
        uint256 amountInMax,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapExactTokensForETH(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapETHForExactTokens(
        uint256 amountOut,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable returns (uint256[] memory amounts);

    function quote(
        uint256 amountA,
        uint256 reserveA,
        uint256 reserveB
    ) external pure returns (uint256 amountB);

    function getAmountOut(
        uint256 amountIn,
        uint256 reserveIn,
        uint256 reserveOut
    ) external pure returns (uint256 amountOut);

    function getAmountIn(
        uint256 amountOut,
        uint256 reserveIn,
        uint256 reserveOut
    ) external pure returns (uint256 amountIn);

    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);

    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);

    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountETH);

    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline,
        bool approveMax,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (uint256 amountETH);

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;

    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable;

    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;
}

// File: contracts/interface/IPancakeswapPair.sol


pragma solidity ^0.8.0;

interface IPancakeswapPair {
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function name() external pure returns (string memory);

    function symbol() external pure returns (string memory);

    function decimals() external pure returns (uint8);

    function totalSupply() external view returns (uint256);

    function balanceOf(address owner) external view returns (uint256);

    function allowance(address owner, address spender) external view returns (uint256);

    function approve(address spender, uint256 value) external returns (bool);

    function transfer(address to, uint256 value) external returns (bool);

    function transferFrom(
        address from,
        address to,
        uint256 value
    ) external returns (bool);

    function DOMAIN_SEPARATOR() external view returns (bytes32);

    function PERMIT_TYPEHASH() external pure returns (bytes32);

    function nonces(address owner) external view returns (uint256);

    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    event Mint(address indexed sender, uint256 amount0, uint256 amount1);
    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint256 amount0In,
        uint256 amount1In,
        uint256 amount0Out,
        uint256 amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);

    function MINIMUM_LIQUIDITY() external pure returns (uint256);

    function factory() external view returns (address);

    function token0() external view returns (address);

    function token1() external view returns (address);

    function getReserves()
        external
        view
        returns (
            uint112 reserve0,
            uint112 reserve1,
            uint32 blockTimestampLast
        );

    function price0CumulativeLast() external view returns (uint256);

    function price1CumulativeLast() external view returns (uint256);

    function kLast() external view returns (uint256);

    function mint(address to) external returns (uint256 liquidity);

    function burn(address to) external returns (uint256 amount0, uint256 amount1);

    function swap(
        uint256 amount0Out,
        uint256 amount1Out,
        address to,
        bytes calldata data
    ) external;

    function skim(address to) external;

    function sync() external;

    function initialize(address, address) external;
}

// File: contracts/interface/IPancakeswapFactory.sol


pragma solidity ^0.8.0;

interface IPancakeswapFactory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);

    function feeTo() external view returns (address);

    function feeToSetter() external view returns (address);

    function getPair(address tokenA, address tokenB) external view returns (address pair);

    function allPairs(uint256) external view returns (address pair);

    function allPairsLength() external view returns (uint256);

    function createPair(address tokenA, address tokenB) external returns (address pair);

    function setFeeTo(address) external;

    function setFeeToSetter(address) external;
}

// File: @openzeppelin/contracts/utils/math/SafeMath.sol


// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)

pragma solidity ^0.8.0;

// CAUTION
// This version of SafeMath should only be used with Solidity 0.8 or later,
// because it relies on the compiler's built in overflow checks.

/**
 * @dev Wrappers over Solidity's arithmetic operations.
 *
 * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler
 * now has built in overflow checking.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            uint256 c = a + b;
            if (c < a) return (false, 0);
            return (true, c);
        }
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b > a) return (false, 0);
            return (true, a - b);
        }
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
            // benefit is lost if 'b' is also tested.
            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
            if (a == 0) return (true, 0);
            uint256 c = a * b;
            if (c / a != b) return (false, 0);
            return (true, c);
        }
    }

    /**
     * @dev Returns the division of two unsigned integers, with a division by zero flag.
     *
     * _Available since v3.4._
     */
    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a / b);
        }
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.
     *
     * _Available since v3.4._
     */
    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a % b);
        }
    }

    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return a - b;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        return a * b;
    }

    /**
     * @dev Returns the integer division of two unsigned integers, reverting on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator.
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * reverting when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return a % b;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {trySub}.
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b <= a, errorMessage);
            return a - b;
        }
    }

    /**
     * @dev Returns the integer division of two unsigned integers, reverting with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a / b;
        }
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * reverting with custom message when dividing by zero.
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {tryMod}.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a % b;
        }
    }
}

// File: @openzeppelin/contracts/utils/Address.sol


// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)

pragma solidity ^0.8.1;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     *
     * [IMPORTANT]
     * ====
     * You shouldn't rely on `isContract` to protect against flash loan attacks!
     *
     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
     * constructor.
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize/address.code.length, which returns 0
        // for contracts in construction, since the code is only stored at the end
        // of the constructor execution.

        return account.code.length > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain `call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling
     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.
     *
     * _Available since v4.8._
     */
    function verifyCallResultFromTarget(
        address target,
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        if (success) {
            if (returndata.length == 0) {
                // only check isContract if the call was successful and the return data is empty
                // otherwise we already know that it was a contract
                require(isContract(target), "Address: call to non-contract");
            }
            return returndata;
        } else {
            _revert(returndata, errorMessage);
        }
    }

    /**
     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the
     * revert reason or using the provided one.
     *
     * _Available since v4.3._
     */
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            _revert(returndata, errorMessage);
        }
    }

    function _revert(bytes memory returndata, string memory errorMessage) private pure {
        // Look for revert reason and bubble it up if present
        if (returndata.length > 0) {
            // The easiest way to bubble the revert reason is using memory via assembly
            /// @solidity memory-safe-assembly
            assembly {
                let returndata_size := mload(returndata)
                revert(add(32, returndata), returndata_size)
            }
        } else {
            revert(errorMessage);
        }
    }
}

// File: @chainlink/contracts/src/v0.8/interfaces/VRFV2WrapperInterface.sol


pragma solidity ^0.8.0;

interface VRFV2WrapperInterface {
  /**
   * @return the request ID of the most recent VRF V2 request made by this wrapper. This should only
   * be relied option within the same transaction that the request was made.
   */
  function lastRequestId() external view returns (uint256);

  /**
   * @notice Calculates the price of a VRF request with the given callbackGasLimit at the current
   * @notice block.
   *
   * @dev This function relies on the transaction gas price which is not automatically set during
   * @dev simulation. To estimate the price at a specific gas price, use the estimatePrice function.
   *
   * @param _callbackGasLimit is the gas limit used to estimate the price.
   */
  function calculateRequestPrice(uint32 _callbackGasLimit) external view returns (uint256);

  /**
   * @notice Estimates the price of a VRF request with a specific gas limit and gas price.
   *
   * @dev This is a convenience function that can be called in simulation to better understand
   * @dev pricing.
   *
   * @param _callbackGasLimit is the gas limit used to estimate the price.
   * @param _requestGasPriceWei is the gas price in wei used for the estimation.
   */
  function estimateRequestPrice(uint32 _callbackGasLimit, uint256 _requestGasPriceWei) external view returns (uint256);
}

// File: @chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol


pragma solidity ^0.8.0;

interface LinkTokenInterface {
  function allowance(address owner, address spender) external view returns (uint256 remaining);

  function approve(address spender, uint256 value) external returns (bool success);

  function balanceOf(address owner) external view returns (uint256 balance);

  function decimals() external view returns (uint8 decimalPlaces);

  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);

  function increaseApproval(address spender, uint256 subtractedValue) external;

  function name() external view returns (string memory tokenName);

  function symbol() external view returns (string memory tokenSymbol);

  function totalSupply() external view returns (uint256 totalTokensIssued);

  function transfer(address to, uint256 value) external returns (bool success);

  function transferAndCall(
    address to,
    uint256 value,
    bytes calldata data
  ) external returns (bool success);

  function transferFrom(
    address from,
    address to,
    uint256 value
  ) external returns (bool success);
}

// File: @chainlink/contracts/src/v0.8/VRFV2WrapperConsumerBase.sol


pragma solidity ^0.8.0;



/** *******************************************************************************
 * @notice Interface for contracts using VRF randomness through the VRF V2 wrapper
 * ********************************************************************************
 * @dev PURPOSE
 *
 * @dev Create VRF V2 requests without the need for subscription management. Rather than creating
 * @dev and funding a VRF V2 subscription, a user can use this wrapper to create one off requests,
 * @dev paying up front rather than at fulfillment.
 *
 * @dev Since the price is determined using the gas price of the request transaction rather than
 * @dev the fulfillment transaction, the wrapper charges an additional premium on callback gas
 * @dev usage, in addition to some extra overhead costs associated with the VRFV2Wrapper contract.
 * *****************************************************************************
 * @dev USAGE
 *
 * @dev Calling contracts must inherit from VRFV2WrapperConsumerBase. The consumer must be funded
 * @dev with enough LINK to make the request, otherwise requests will revert. To request randomness,
 * @dev call the 'requestRandomness' function with the desired VRF parameters. This function handles
 * @dev paying for the request based on the current pricing.
 *
 * @dev Consumers must implement the fullfillRandomWords function, which will be called during
 * @dev fulfillment with the randomness result.
 */
abstract contract VRFV2WrapperConsumerBase {
  LinkTokenInterface internal immutable LINK;
  VRFV2WrapperInterface internal immutable VRF_V2_WRAPPER;

  /**
   * @param _link is the address of LinkToken
   * @param _vrfV2Wrapper is the address of the VRFV2Wrapper contract
   */
  constructor(address _link, address _vrfV2Wrapper) {
    LINK = LinkTokenInterface(_link);
    VRF_V2_WRAPPER = VRFV2WrapperInterface(_vrfV2Wrapper);
  }

  /**
   * @dev Requests randomness from the VRF V2 wrapper.
   *
   * @param _callbackGasLimit is the gas limit that should be used when calling the consumer's
   *        fulfillRandomWords function.
   * @param _requestConfirmations is the number of confirmations to wait before fulfilling the
   *        request. A higher number of confirmations increases security by reducing the likelihood
   *        that a chain re-org changes a published randomness outcome.
   * @param _numWords is the number of random words to request.
   *
   * @return requestId is the VRF V2 request ID of the newly created randomness request.
   */
  function requestRandomness(
    uint32 _callbackGasLimit,
    uint16 _requestConfirmations,
    uint32 _numWords
  ) internal returns (uint256 requestId) {
    LINK.transferAndCall(
      address(VRF_V2_WRAPPER),
      VRF_V2_WRAPPER.calculateRequestPrice(_callbackGasLimit),
      abi.encode(_callbackGasLimit, _requestConfirmations, _numWords)
    );
    return VRF_V2_WRAPPER.lastRequestId();
  }

  /**
   * @notice fulfillRandomWords handles the VRF V2 wrapper response. The consuming contract must
   * @notice implement it.
   *
   * @param _requestId is the VRF V2 request ID.
   * @param _randomWords is the randomness result.
   */
  function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) internal virtual;

  function rawFulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) external {
    require(msg.sender == address(VRF_V2_WRAPPER), "only VRF V2 wrapper can fulfill");
    fulfillRandomWords(_requestId, _randomWords);
  }
}

// File: contracts/interface/IBEP20.sol



pragma solidity >=0.4.0;

interface IBEP20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the token decimals.
     */
    function decimals() external view returns (uint8);

    /**
     * @dev Returns the token symbol.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the token name.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the bep token owner.
     */
    function getOwner() external view returns (address);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address _owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

// File: @openzeppelin/contracts/security/ReentrancyGuard.sol


// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)

pragma solidity ^0.8.0;

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and making it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        _nonReentrantBefore();
        _;
        _nonReentrantAfter();
    }

    function _nonReentrantBefore() private {
        // On the first call to nonReentrant, _status will be _NOT_ENTERED
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;
    }

    function _nonReentrantAfter() private {
        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}

// File: contracts/v2/DrawManager.sol


pragma solidity ^0.8.0;









contract DrawManager is VRFV2WrapperConsumerBase, ReentrancyGuard {
    using SafeMath for uint256;
    using Address for address;

    struct DrawEntry {
        address user;
        uint256 startIndex;
        uint256 ticketCount;
    }

    struct UserInfo {
        uint256 totalTicketCount;
        uint256 busdBalance;
        uint256 roundNumber;
        uint256 roundTicketCount;
    }

    struct RngRequestStatus {
        uint256 paid;
        bool fulfilled;
        uint256[] randomWords;
    }

    address public constant LINK_TOKEN = 0x404460C6A5EdE2D891e8297795264fDe62ADBB75;
    address public constant VRF_WRAPPER = 0x721DFbc5Cfe53d32ab00A9bdFa605d3b8E1f3f42;

    uint256 private constant INITIAL_DRAW_TIME = 946728000;
    uint256 private constant DRAW_TIME_BUFFER = 86400;

    uint256 public constant MIN_BUY_AMOUNT = 25 * 10**18;
    uint256 public constant BUY_AWARD_TOLERANCE = 10**12;
    uint256 public constant MIN_AWARD_AMOUNT = 10 * 10**18;
    uint256 public constant MAX_WINNER_COUNT = 50;
    uint256 public constant TICKET_BUSD_PRICE = 10**18;

    IBEP20 public immutable moox;
    IBEP20 public busd;
    address public immutable mooxStakeManager;
    IPancakeswapPair public immutable pancakeswapBusdPair;
    IPancakeswapRouter public pancakeswapRouter;

    uint256 public roundCount = 1;
    uint256 public ticketCounter;
    uint256 public entryCounter;
    uint256 public drawTime = INITIAL_DRAW_TIME;

    mapping(address => UserInfo) public userInfoMap;
    mapping(uint256 => DrawEntry) public drawEntryMap;

    uint256 public rngRequestId;
    mapping(uint256 => RngRequestStatus) public rngRequestStatusMap;

    address public marketingWallet;
    address public marketingWalletSetter;
    address public charityWallet;
    address public charityWalletSetter;

    event TicketAward(address indexed user, uint256 mooxAmount, uint256 ticketCount, uint256 awardType);
    event UseTicket(address indexed user, uint256 round, uint256 startIndex, uint256 ticketCount);
    event TransferTicket(address indexed sender, address indexed receiver, uint256 ticketCount);
    event BuyTicket(address indexed buyer, uint256 ticketCount);
    event AwardUser(uint256 indexed roundCount, uint256 ticketNumber, address indexed winner, uint256 award);
    event CompleteDraw(
        uint256 indexed roundCount,
        uint256 drawTime,
        uint256 ticketCount,
        uint256 winnerCount,
        uint256 totalMooxAward,
        uint256 totalBusdAward
    );
    event MooxTransferFailed(address to, uint256 amount);
    event SetMarketingWalletSetter(address setter);
    event SetMarketingWallet(address setter, address wallet);
    event SetCharityWalletSetter(address setter);
    event SetCharityWallet(address setter, address wallet);

    constructor(
        address _creator,
        address _mooxStakeManager,
        IBEP20 _busd,
        IPancakeswapPair _pancakeswapBusdPair,
        IPancakeswapRouter _pancakeswapRouter
    ) VRFV2WrapperConsumerBase(LINK_TOKEN, VRF_WRAPPER) {
        require(_creator != address(0), 'DrawManager: Zero wallet address');

        moox = IBEP20(msg.sender);
        mooxStakeManager = _mooxStakeManager;
        pancakeswapBusdPair = _pancakeswapBusdPair;
        pancakeswapRouter = _pancakeswapRouter;
        busd = _busd;

        require(busd.approve(address(pancakeswapRouter), type(uint256).max), 'DrawManager: Cannot approve BUSD');

        charityWalletSetter = _creator;
        marketingWalletSetter = _creator;
    }

    function processBuyAward(uint256 _amount) external nonReentrant {
        require(msg.sender == address(moox), 'DrawManager: Not allowed');

        (uint256 mooxReserve, uint256 busdReserve) = _getReserves();

        uint256 busdAmount = busdReserve.mul(_amount).mul(10000).div(mooxReserve.sub(_amount).mul(9975)).add(1);

        if (busdReserve.add(busdAmount) > busd.balanceOf(address(pancakeswapBusdPair))) {
            return;
        }

        UserInfo storage userInfo = userInfoMap[tx.origin];
        uint256 totalBusdBalance = userInfo.busdBalance.add(busdAmount);
        uint256 totalBusdAmount = userInfo.busdBalance.add(busdAmount).add(BUY_AWARD_TOLERANCE);

        if (totalBusdAmount >= MIN_BUY_AMOUNT) {
            uint256 ticketCount = totalBusdAmount.div(MIN_BUY_AMOUNT);
            uint256 spentBusdAmount = MIN_BUY_AMOUNT.mul(ticketCount);

            userInfo.totalTicketCount += ticketCount;

            if (totalBusdBalance > spentBusdAmount) {
                userInfo.busdBalance = totalBusdBalance.sub(spentBusdAmount);
            } else {
                userInfo.busdBalance = 0;
            }

            emit TicketAward(tx.origin, _amount, ticketCount, 1);
        } else {
            userInfo.busdBalance = totalBusdBalance;
        }
    }

    function useTicket(uint256 _ticketCount) external nonReentrant {
        require(drawTime > block.timestamp, 'DrawManager: Time is up');

        UserInfo storage userInfo = userInfoMap[msg.sender];

        uint256 userTicketCount = userInfo.totalTicketCount;

        require(userTicketCount >= _ticketCount, 'DrawManager: Invalid ticket count');

        drawEntryMap[entryCounter] = DrawEntry({
            user: msg.sender,
            startIndex: ticketCounter,
            ticketCount: _ticketCount
        });

        emit UseTicket(msg.sender, roundCount, ticketCounter, _ticketCount);

        entryCounter += 1;
        ticketCounter += _ticketCount;

        userInfo.totalTicketCount -= _ticketCount;

        if (userInfo.roundNumber < roundCount) {
            userInfo.roundNumber = roundCount;
            userInfo.roundTicketCount = _ticketCount;
        } else {
            userInfo.roundTicketCount += _ticketCount;
        }
    }

    function buyTicket(
        uint256 _ticketCount,
        uint256 minMooxAmount,
        bool _joinDraw
    ) external nonReentrant {
        require(drawTime > INITIAL_DRAW_TIME, 'DrawManager: Not started');

        address[] memory path = new address[](2);
        path[0] = address(busd);
        path[1] = address(moox);

        uint256 busdAmount = _ticketCount.mul(TICKET_BUSD_PRICE);

        require(busd.transferFrom(msg.sender, address(this), busdAmount), 'DrawManager: BUSD transfer error');

        if (busd.allowance(address(this), address(pancakeswapRouter)) < busdAmount) {
            require(busd.approve(address(pancakeswapRouter), type(uint256).max), 'DrawManager: Cannot approve BUSD');
        }

        pancakeswapRouter.swapExactTokensForTokens(busdAmount, minMooxAmount, path, address(this), block.timestamp);

        emit BuyTicket(msg.sender, _ticketCount);

        if (_joinDraw) {
            require(drawTime > block.timestamp, 'DrawManager: Time is up');

            drawEntryMap[entryCounter] = DrawEntry({
                user: msg.sender,
                startIndex: ticketCounter,
                ticketCount: _ticketCount
            });

            emit UseTicket(msg.sender, roundCount, ticketCounter, _ticketCount);

            entryCounter += 1;
            ticketCounter += _ticketCount;

            UserInfo storage userInfo = userInfoMap[msg.sender];

            if (userInfo.roundNumber < roundCount) {
                userInfo.roundNumber = roundCount;
                userInfo.roundTicketCount = _ticketCount;
            } else {
                userInfo.roundTicketCount += _ticketCount;
            }
        } else {
            userInfoMap[msg.sender].totalTicketCount += _ticketCount;
        }
    }

    function transferTicket(uint256 _ticketCount, address _receiver) external nonReentrant {
        require(
            _ticketCount > 0 && userInfoMap[msg.sender].totalTicketCount >= _ticketCount,
            'DrawManager: Invalid ticket count'
        );

        userInfoMap[msg.sender].totalTicketCount -= _ticketCount;
        userInfoMap[_receiver].totalTicketCount += _ticketCount;

        emit TransferTicket(msg.sender, _receiver, _ticketCount);
    }

    function processStakeAward(address _user, uint256 _count) external nonReentrant {
        require(msg.sender == mooxStakeManager, 'DrawManager: Not allowed');

        userInfoMap[_user].totalTicketCount += _count;

        emit TicketAward(_user, 0, _count, 2);
    }

    function requestRandomNumber(
        uint32 _callbackGasLimit,
        uint16 _requestConfirmations,
        uint32 _randomNumberCount
    ) external returns (uint256 requestId) {
        require(drawTime > INITIAL_DRAW_TIME && drawTime <= block.timestamp, 'DrawManager: Invalid time');

        uint256 requestPrice = VRF_V2_WRAPPER.calculateRequestPrice(_callbackGasLimit);

        require(LINK.transferFrom(msg.sender, address(this), requestPrice), 'DrawManager: Cannot transfer LINK');

        requestId = requestRandomness(_callbackGasLimit, _requestConfirmations, _randomNumberCount);

        rngRequestStatusMap[requestId] = RngRequestStatus({
            paid: requestPrice,
            randomWords: new uint256[](0),
            fulfilled: false
        });

        rngRequestId = requestId;
    }

    function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) internal override {
        require(rngRequestStatusMap[_requestId].paid > 0, 'DrawManager: Rng request not paid');

        rngRequestStatusMap[_requestId].fulfilled = true;
        rngRequestStatusMap[_requestId].randomWords = _randomWords;
    }

    function draw() external nonReentrant {
        require(drawTime > INITIAL_DRAW_TIME && drawTime <= block.timestamp, 'DrawManager: Invalid time');

        uint256 roundTicketCount = ticketCounter;
        (uint256 awardToGiveaway, uint256 awardInBusd, uint256 roundWinnerCount) = getCurrentAwardAndWinnerCount();

        if (roundTicketCount <= 0) {
            emit CompleteDraw(roundCount, block.timestamp, roundTicketCount, 0, awardToGiveaway, awardInBusd);

            rngRequestId = 0;
            ticketCounter = 0;
            entryCounter = 0;
            roundCount += 1;
            drawTime += block.timestamp.sub(drawTime).div(DRAW_TIME_BUFFER).add(1).mul(DRAW_TIME_BUFFER);

            return;
        }

        require(awardToGiveaway > 0, 'DrawManager: Invalid award amount');

        uint256 randomNumber = 0;
        uint256 partitionLength = 1;
        uint256 partitionCount = 0;
        uint256 remainder = 0;

        if (roundTicketCount > roundWinnerCount) {
            require(rngRequestId != 0, 'DrawManager: Update random number');
            require(rngRequestStatusMap[rngRequestId].fulfilled, 'DrawManager: Random number in process');

            randomNumber = rngRequestStatusMap[rngRequestId].randomWords[0];
            partitionLength = roundTicketCount.div(roundWinnerCount);
            remainder = roundTicketCount.mod(roundWinnerCount);
            partitionCount = roundWinnerCount.sub(remainder);
        } else {
            roundWinnerCount = roundTicketCount;
        }

        address[] memory winners = new address[](roundWinnerCount);
        uint256[] memory winnerTicketNumbers = new uint256[](roundWinnerCount);

        for (uint256 i = 0; i < roundWinnerCount; i++) {
            uint256 winnerTicketIndex = i;
            uint256 winnerEntryIndex = 0;

            if (roundTicketCount > roundWinnerCount) {
                if (i < partitionCount) {
                    uint256 winnerStartIndex = i.mul(partitionLength);

                    if (partitionLength > 1) {
                        uint256 nextRandom = uint256(keccak256(abi.encode(randomNumber, i)));
                        winnerTicketIndex = winnerStartIndex.add(nextRandom.mod(partitionLength));
                    } else {
                        winnerTicketIndex = winnerStartIndex;
                    }
                } else if (remainder > 0) {
                    uint256 winnerStartIndex = partitionCount.mul(partitionLength).add(
                        i.sub(partitionCount).mul(partitionLength.add(1))
                    );

                    uint256 nextRandom = uint256(keccak256(abi.encode(randomNumber, i)));
                    winnerTicketIndex = winnerStartIndex.add(nextRandom.mod(partitionLength.add(1)));
                }
            }

            uint256 low = 0;
            uint256 high = entryCounter;

            while (low <= high) {
                uint256 mid = low + ((high - low) / 2);

                if (drawEntryMap[mid].startIndex + drawEntryMap[mid].ticketCount - 1 < winnerTicketIndex) {
                    low = mid + 1;
                } else if (drawEntryMap[mid].startIndex > winnerTicketIndex) {
                    high = mid - 1;
                } else {
                    winnerEntryIndex = mid;
                    break;
                }
            }

            winners[i] = drawEntryMap[winnerEntryIndex].user;
            winnerTicketNumbers[i] = winnerTicketIndex;
        }

        uint256 award = awardToGiveaway.div(roundWinnerCount);

        for (uint256 i = 0; i < roundWinnerCount; i++) {
            if (moox.transfer(winners[i], award)) {
                emit AwardUser(roundCount, winnerTicketNumbers[i], winners[i], award);
            } else {
                emit MooxTransferFailed(winners[i], award);
            }
        }

        emit CompleteDraw(
            roundCount,
            block.timestamp,
            roundTicketCount,
            roundWinnerCount,
            awardToGiveaway,
            awardInBusd
        );

        rngRequestId = 0;
        ticketCounter = 0;
        entryCounter = 0;
        roundCount += 1;
        drawTime += block.timestamp.sub(drawTime).div(DRAW_TIME_BUFFER).add(1).mul(DRAW_TIME_BUFFER);

        if (marketingWallet != address(0) && !moox.transfer(marketingWallet, awardToGiveaway.div(5))) {
            emit MooxTransferFailed(marketingWallet, awardToGiveaway.div(5));
        }

        if (charityWallet != address(0) && !moox.transfer(charityWallet, awardToGiveaway.div(10))) {
            emit MooxTransferFailed(charityWallet, awardToGiveaway.div(10));
        }
    }

    function calculateTicketCount(uint256 _amount) external view returns (uint256) {
        return _calculateTicketCount(_amount, 0);
    }

    function calculateTicketCountForAddress(uint256 _amount, address _account) external view returns (uint256) {
        return _calculateTicketCount(_amount, userInfoMap[_account].busdBalance);
    }

    function _calculateTicketCount(uint256 _mooxAmount, uint256 _busdAmount) internal view returns (uint256) {
        (uint256 mooxReserve, uint256 busdReserve) = _getReserves();

        if (_mooxAmount >= mooxReserve) {
            return 0;
        }

        uint256 busdAmount = busdReserve.mul(_mooxAmount).mul(10000).div(mooxReserve.sub(_mooxAmount).mul(9975)).add(1);

        busdAmount = busdAmount.add(_busdAmount).add(BUY_AWARD_TOLERANCE);

        uint256 ticketCount = 0;

        if (busdAmount >= MIN_BUY_AMOUNT) {
            ticketCount = busdAmount.div(MIN_BUY_AMOUNT);
        }

        return ticketCount;
    }

    function _getReserves() internal view returns (uint256 mooxReserve, uint256 busdReserve) {
        (uint256 reserveA, uint256 reserveB, ) = pancakeswapBusdPair.getReserves();

        (mooxReserve, busdReserve) = address(moox) < address(busd) ? (reserveA, reserveB) : (reserveB, reserveA);
    }

    function getCurrentAwardAndWinnerCount()
        public
        view
        returns (
            uint256 awardInMoox,
            uint256 awardInBusd,
            uint256 winnerCount
        )
    {
        uint256 mooxBalance = moox.balanceOf(address(this));

        if (mooxBalance <= 0) {
            return (0, 0, 0);
        }

        uint256 totalAward = moox.balanceOf(address(this)).div(3).mul(85).div(100);

        (uint256 mooxReserve, uint256 busdReserve) = _getReserves();

        if (mooxReserve <= 0 || busdReserve <= 0) {
            return (0, 0, 0);
        }

        uint256 amountInWithFee = totalAward.mul(9975);
        uint256 numerator = amountInWithFee.mul(busdReserve);
        uint256 denominator = mooxReserve.mul(10000).add(amountInWithFee);

        uint256 totalAwardInBusd = numerator / denominator;

        if (totalAwardInBusd <= MIN_AWARD_AMOUNT) {
            awardInBusd = totalAwardInBusd;
            awardInMoox = totalAward;
            winnerCount = 1;

            return (awardInMoox, awardInBusd, winnerCount);
        }

        winnerCount = totalAwardInBusd.div(MIN_AWARD_AMOUNT);

        if (winnerCount > MAX_WINNER_COUNT) {
            awardInBusd = totalAwardInBusd;
            awardInMoox = totalAward;
            winnerCount = MAX_WINNER_COUNT;

            return (awardInMoox, awardInBusd, winnerCount);
        }

        awardInBusd = MIN_AWARD_AMOUNT.mul(winnerCount);
        awardInMoox = totalAward.mul(awardInBusd).div(totalAwardInBusd);
    }

    function getUserTotalTicketCount(address _user) external view returns (uint256) {
        return userInfoMap[_user].totalTicketCount;
    }

    function getUserRoundTicketCount(address _user) external view returns (uint256) {
        UserInfo storage userInfo = userInfoMap[_user];

        if (userInfo.roundNumber < roundCount) {
            return 0;
        }

        return userInfo.roundTicketCount;
    }

    function getRandomNumber() external view returns (uint256) {
        if (rngRequestId == 0 || !rngRequestStatusMap[rngRequestId].fulfilled) {
            return 0;
        }

        return rngRequestStatusMap[rngRequestId].randomWords[0];
    }

    function startDraw() external {
        require(msg.sender == marketingWalletSetter, 'DrawManager: Not allowed');
        require(drawTime == INITIAL_DRAW_TIME, 'DrawManager: Already set');

        drawTime += block.timestamp.sub(drawTime).div(DRAW_TIME_BUFFER).add(1).mul(DRAW_TIME_BUFFER);
    }

    function setMarketingWalletSetter(address _setter) external {
        require(_setter != address(0), 'DrawManager: Invalid address');
        require(msg.sender == marketingWalletSetter, 'DrawManager: Not allowed');

        marketingWalletSetter = _setter;

        emit SetMarketingWalletSetter(_setter);
    }

    function setMarketingWallet(address _wallet) external {
        require(_wallet != address(0), 'DrawManager: Invalid address');
        require(msg.sender == marketingWalletSetter, 'DrawManager: Not allowed');

        marketingWallet = _wallet;

        emit SetMarketingWallet(msg.sender, _wallet);
    }

    function setCharityWalletSetter(address _setter) external {
        require(_setter != address(0), 'DrawManager: Invalid address');
        require(msg.sender == charityWalletSetter, 'DrawManager: Not allowed');

        charityWalletSetter = _setter;

        emit SetCharityWalletSetter(_setter);
    }

    function setCharityWallet(address _wallet) external {
        require(_wallet != address(0), 'DrawManager: Invalid address');
        require(msg.sender == charityWalletSetter, 'DrawManager: Not allowed');

        charityWallet = _wallet;

        emit SetCharityWallet(msg.sender, _wallet);
    }

    function setDrawTime(uint256 _time) external {
        drawTime = _time;
    }
}

// File: contracts/v2/MarketingWalletManager.sol


pragma solidity ^0.8.0;




contract MarketingWalletManager is ReentrancyGuard {
    using SafeMath for uint256;

    IBEP20 public constant MOOX = IBEP20(0x30b832E2E98463d9130B822Bd9F294287Edd0422);
    DrawManager public constant DRAW_MANAGER = DrawManager(0xCc52BE74E94c2AFEF596B8a9f95A35e0A8fecC21);

    address public marketingWallet;
    address public marketingWalletSetter;

    event SetMarketingWalletSetter(address setter);
    event SetMarketingWallet(address setter, address wallet);

    constructor() {
        marketingWalletSetter = msg.sender;
    }

    function draw() external {
        DRAW_MANAGER.draw();

        transferMoox();
    }

    function transferMoox() public nonReentrant {
        MOOX.transfer(marketingWallet, MOOX.balanceOf(address(this)).div(4));
        MOOX.transfer(address(DRAW_MANAGER), MOOX.balanceOf(address(this)));
    }

    function setMarketingWalletSetter(address _setter) external {
        require(_setter != address(0), 'DrawManager: Invalid address');
        require(msg.sender == marketingWalletSetter, 'DrawManager: Not allowed');

        marketingWalletSetter = _setter;

        emit SetMarketingWalletSetter(_setter);
    }

    function setMarketingWallet(address _wallet) external {
        require(_wallet != address(0), 'DrawManager: Invalid address');
        require(msg.sender == marketingWalletSetter, 'DrawManager: Not allowed');

        marketingWallet = _wallet;

        emit SetMarketingWallet(msg.sender, _wallet);
    }
}