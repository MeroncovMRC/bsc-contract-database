{"ConfirmedOwner.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ConfirmedOwnerWithProposal.sol\";\n\n/**\n * @title The ConfirmedOwner contract\n * @notice A contract with helpers for basic contract ownership.\n */\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\n}\n"},"ConfirmedOwnerWithProposal.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./OwnableInterface.sol\";\n\n/**\n * @title The ConfirmedOwner contract\n * @notice A contract with helpers for basic contract ownership.\n */\ncontract ConfirmedOwnerWithProposal is OwnableInterface {\n  address private s_owner;\n  address private s_pendingOwner;\n\n  event OwnershipTransferRequested(address indexed from, address indexed to);\n  event OwnershipTransferred(address indexed from, address indexed to);\n\n  constructor(address newOwner, address pendingOwner) {\n    require(newOwner != address(0), \"Cannot set owner to zero\");\n\n    s_owner = newOwner;\n    if (pendingOwner != address(0)) {\n      _transferOwnership(pendingOwner);\n    }\n  }\n\n  /**\n   * @notice Allows an owner to begin transferring ownership to a new address,\n   * pending.\n   */\n  function transferOwnership(address to) public override onlyOwner {\n    _transferOwnership(to);\n  }\n\n  /**\n   * @notice Allows an ownership transfer to be completed by the recipient.\n   */\n  function acceptOwnership() external override {\n    require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\n\n    address oldOwner = s_owner;\n    s_owner = msg.sender;\n    s_pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }\n\n  /**\n   * @notice Get the current owner\n   */\n  function owner() public view override returns (address) {\n    return s_owner;\n  }\n\n  /**\n   * @notice validate, transfer ownership, and emit relevant events\n   */\n  function _transferOwnership(address to) private {\n    require(to != msg.sender, \"Cannot transfer to self\");\n\n    s_pendingOwner = to;\n\n    emit OwnershipTransferRequested(s_owner, to);\n  }\n\n  /**\n   * @notice validate access\n   */\n  function _validateOwnership() internal view {\n    require(msg.sender == s_owner, \"Only callable by owner\");\n  }\n\n  /**\n   * @notice Reverts if called by anyone other than the contract owner.\n   */\n  modifier onlyOwner() {\n    _validateOwnership();\n    _;\n  }\n}\n"},"InitRedPacketRandom.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \u0027./ConfirmedOwner.sol\u0027;\nimport \u0027./VRFV2WrapperConsumerBase.sol\u0027;\n\ninterface IToken {\n    function transfer(address _to, uint256 _value) external;\n    function transferFrom(address sender, address recipient, uint256 amount) external;\n}\n\ncontract RandomDistribution is VRFV2WrapperConsumerBase, ConfirmedOwner {\n    event RequestSent(uint256 requestId, uint32 numWords);\n    event RequestFulfilled(uint256 requestId, uint256[] randomWords, uint256 payment);\n\n    IToken public ticket721;\n    event InitRandom(uint256 indexed sequenceId, uint256 requestId,uint256 randomV);\n    mapping(address =\u003e bool) public minters;\n\n    struct RequestStatus {\n        uint256 paid; // amount paid in link\n        uint256 sequenceId;\n        bool fulfilled; // whether the request has been successfully fulfilled\n        uint256[] randomWords;\n    }\n    mapping(uint256 =\u003e RequestStatus) public s_requests; /* requestId --\u003e requestStatus */\n    mapping(uint256 =\u003e uint256) public seeds;\n\n    // past requests Id.\n    uint256[] public requestIds;\n    uint256 public lastRequestId;\n\n    // Depends on the number of requested values that you want sent to the\n    // fulfillRandomWords() function. Test and adjust\n    // this limit based on the network that you select, the size of the request,\n    // and the processing of the callback request in the fulfillRandomWords()\n    // function.\n    uint32 callbackGasLimit = 100000;\n\n    // The default is 3, but you can set this higher.\n    uint16 requestConfirmations = 3;\n\n    // For this example, retrieve 2 random values in one request.\n    // Cannot exceed VRFV2Wrapper.getConfig().maxNumWords.\n    uint32 numWords = 1;\n\n    constructor(address _linkAddress,address _wrapperAddress) ConfirmedOwner(msg.sender) VRFV2WrapperConsumerBase(_linkAddress, _wrapperAddress) {}\n\n    modifier onlyMint() {\n        require( msg.sender == owner() || minters[msg.sender], \"nft: not minter\");\n        _;\n    }\n\n    function setChainLinkParameter(uint32 _callbackGasLimit, uint16 _requestConfirmations, uint32 _numWords) public onlyOwner {\n        callbackGasLimit = _callbackGasLimit;\n        requestConfirmations = _requestConfirmations;\n        numWords = _numWords;\n        //fee = _fee * 10 ** 16; // 0.2 LINK (Varies by network)\n    }\n\n    function setMinters(address _address, bool _allow) public onlyOwner {\n        require(_address != address(0), \"nft: zero_address\");\n        require(minters[_address] != _allow, \"nft: no edit\");\n        minters[_address] = _allow;\n    }\n\n    function setTicket(address _ticketToken) external onlyOwner() {\n        require(_ticketToken != address(0), \"The token\u0027s address cannot be 0\");\n        ticket721 = IToken(_ticketToken);\n    }\n    function requestRandomWords(uint256 _sequenceId) external onlyMint() returns (uint256 requestId) {\n        require(seeds[_sequenceId] == 0, \"Do not repeat  acquire\");\n        requestId = requestRandomness(callbackGasLimit, requestConfirmations, numWords);\n        s_requests[requestId] = RequestStatus({\n            paid: VRF_V2_WRAPPER.calculateRequestPrice(callbackGasLimit),\n            sequenceId: _sequenceId,\n            randomWords: new uint256[](0),\n            fulfilled: false\n            });\n        requestIds.push(requestId);\n        lastRequestId = requestId;\n        emit RequestSent(requestId, numWords);\n        return requestId;\n    }\n\n    function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) internal override {\n        require(s_requests[_requestId].paid \u003e 0, \u0027request not found\u0027);\n        s_requests[_requestId].fulfilled = true;\n        s_requests[_requestId].randomWords = _randomWords;\n        seeds[s_requests[_requestId].sequenceId] = _randomWords[0] ;\n        emit RequestFulfilled(_requestId, _randomWords, s_requests[_requestId].paid);\n        emit InitRandom(s_requests[_requestId].sequenceId,_requestId,_randomWords[0]);\n    }\n\n    function getRequestStatus(uint256 _requestId)\n    external\n    view\n    returns (\n        uint256 paid,\n        uint256 sequenceId,\n        bool fulfilled,\n        uint256[] memory randomWords\n    )\n    {\n        require(s_requests[_requestId].paid \u003e 0, \u0027request not found\u0027);\n        RequestStatus memory request = s_requests[_requestId];\n        return (request.paid, request.sequenceId,request.fulfilled, request.randomWords);\n    }\n\n    function getRandomSeed(uint256 sequenceId) public view returns (uint256) {\n        return seeds[sequenceId];\n    }\n\n    // withdraw token for rollback\n    function withdrawToken(address token, address payable dest, uint amount) public onlyOwner{\n        if (token == address(0x0))\n            dest.transfer(amount);\n        else\n            IToken(token).transfer(dest, amount);\n    }\n\n    // receive() external payable {}/* can accept ether */\n}"},"LinkTokenInterface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  function approve(address spender, uint256 value) external returns (bool success);\n\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  function decimals() external view returns (uint8 decimalPlaces);\n\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n\n  function name() external view returns (string memory tokenName);\n\n  function symbol() external view returns (string memory tokenSymbol);\n\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n\n  function transfer(address to, uint256 value) external returns (bool success);\n\n  function transferAndCall(\n    address to,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bool success);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool success);\n}\n"},"OwnableInterface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface OwnableInterface {\n  function owner() external returns (address);\n\n  function transferOwnership(address recipient) external;\n\n  function acceptOwnership() external;\n}\n"},"VRFV2WrapperConsumerBase.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./LinkTokenInterface.sol\";\nimport \"./VRFV2WrapperInterface.sol\";\n\n/** *******************************************************************************\n * @notice Interface for contracts using VRF randomness through the VRF V2 wrapper\n * ********************************************************************************\n * @dev PURPOSE\n *\n * @dev Create VRF V2 requests without the need for subscription management. Rather than creating\n * @dev and funding a VRF V2 subscription, a user can use this wrapper to create one off requests,\n * @dev paying up front rather than at fulfillment.\n *\n * @dev Since the price is determined using the gas price of the request transaction rather than\n * @dev the fulfillment transaction, the wrapper charges an additional premium on callback gas\n * @dev usage, in addition to some extra overhead costs associated with the VRFV2Wrapper contract.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from VRFV2WrapperConsumerBase. The consumer must be funded\n * @dev with enough LINK to make the request, otherwise requests will revert. To request randomness,\n * @dev call the \u0027requestRandomness\u0027 function with the desired VRF parameters. This function handles\n * @dev paying for the request based on the current pricing.\n *\n * @dev Consumers must implement the fullfillRandomWords function, which will be called during\n * @dev fulfillment with the randomness result.\n */\nabstract contract VRFV2WrapperConsumerBase {\n  LinkTokenInterface internal immutable LINK;\n  VRFV2WrapperInterface internal immutable VRF_V2_WRAPPER;\n\n  /**\n   * @param _link is the address of LinkToken\n   * @param _vrfV2Wrapper is the address of the VRFV2Wrapper contract\n   */\n  constructor(address _link, address _vrfV2Wrapper) {\n    LINK = LinkTokenInterface(_link);\n    VRF_V2_WRAPPER = VRFV2WrapperInterface(_vrfV2Wrapper);\n  }\n\n  /**\n   * @dev Requests randomness from the VRF V2 wrapper.\n   *\n   * @param _callbackGasLimit is the gas limit that should be used when calling the consumer\u0027s\n   *        fulfillRandomWords function.\n   * @param _requestConfirmations is the number of confirmations to wait before fulfilling the\n   *        request. A higher number of confirmations increases security by reducing the likelihood\n   *        that a chain re-org changes a published randomness outcome.\n   * @param _numWords is the number of random words to request.\n   *\n   * @return requestId is the VRF V2 request ID of the newly created randomness request.\n   */\n  function requestRandomness(\n    uint32 _callbackGasLimit,\n    uint16 _requestConfirmations,\n    uint32 _numWords\n  ) internal returns (uint256 requestId) {\n    LINK.transferAndCall(\n      address(VRF_V2_WRAPPER),\n      VRF_V2_WRAPPER.calculateRequestPrice(_callbackGasLimit),\n      abi.encode(_callbackGasLimit, _requestConfirmations, _numWords)\n    );\n    return VRF_V2_WRAPPER.lastRequestId();\n  }\n\n  /**\n   * @notice fulfillRandomWords handles the VRF V2 wrapper response. The consuming contract must\n   * @notice implement it.\n   *\n   * @param _requestId is the VRF V2 request ID.\n   * @param _randomWords is the randomness result.\n   */\n  function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) internal virtual;\n\n  function rawFulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) external {\n    require(msg.sender == address(VRF_V2_WRAPPER), \"only VRF V2 wrapper can fulfill\");\n    fulfillRandomWords(_requestId, _randomWords);\n  }\n}\n"},"VRFV2WrapperInterface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface VRFV2WrapperInterface {\n  /**\n   * @return the request ID of the most recent VRF V2 request made by this wrapper. This should only\n   * be relied option within the same transaction that the request was made.\n   */\n  function lastRequestId() external view returns (uint256);\n\n  /**\n   * @notice Calculates the price of a VRF request with the given callbackGasLimit at the current\n   * @notice block.\n   *\n   * @dev This function relies on the transaction gas price which is not automatically set during\n   * @dev simulation. To estimate the price at a specific gas price, use the estimatePrice function.\n   *\n   * @param _callbackGasLimit is the gas limit used to estimate the price.\n   */\n  function calculateRequestPrice(uint32 _callbackGasLimit) external view returns (uint256);\n\n  /**\n   * @notice Estimates the price of a VRF request with a specific gas limit and gas price.\n   *\n   * @dev This is a convenience function that can be called in simulation to better understand\n   * @dev pricing.\n   *\n   * @param _callbackGasLimit is the gas limit used to estimate the price.\n   * @param _requestGasPriceWei is the gas price in wei used for the estimation.\n   */\n  function estimateRequestPrice(uint32 _callbackGasLimit, uint256 _requestGasPriceWei) external view returns (uint256);\n}\n"}}