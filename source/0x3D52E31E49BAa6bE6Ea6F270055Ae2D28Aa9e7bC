// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;


interface IERC20 {
    function transfer(address to, uint amount) external returns(bool);
    function balanceOf(address _owner) external returns(uint);
}


contract Presale {
    uint public pricePerToken;
    address public owner;

    IERC20 public token;

    uint public totalEther;
    

    constructor(address _contractAddress, uint _price){
        owner = msg.sender;
        setPresale(_contractAddress, _price);
    }

    event JoinedPresale(address indexed buyer, uint amount);
    
    modifier onlyOwner(){
        require(msg.sender == owner, "you can't call this function");
        _;
    }

    function _buyToken(address _buyer, uint _sentAmount) private {
        uint boughtTokens = pricePerToken * _sentAmount;
        token.transfer(_buyer, boughtTokens);
        emit JoinedPresale(_buyer, boughtTokens);
    }

    function setToken(address _contractAddress) public onlyOwner {
        token = IERC20(_contractAddress);
    }

    function setPricePerToken(uint _price) public onlyOwner {
        pricePerToken = _price;
    }

    function setPresale(address _contractAddress, uint _price) public onlyOwner {
        setToken(_contractAddress);
        setPricePerToken(_price);
    }

    function withdraw() public onlyOwner {
        payable(owner).transfer(address(this).balance);
    }

    function clearToken(address _contractAddress) public onlyOwner {
        IERC20 _token = IERC20(_contractAddress);
        _token.transfer(owner, _token.balanceOf(address(this)));
    }

    receive() external payable {
        _buyToken(msg.sender, msg.value);
    }

    fallback() external payable {
        _buyToken(msg.sender, msg.value);
    }
}