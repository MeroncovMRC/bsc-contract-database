// SPDX-License-Identifier: Rayo
pragma solidity ^0.8.19;

interface IBEP20 {
    function transfer(address to, uint256 value) external returns (bool);
    function approve(address spender, uint256 value) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

contract RayoTokenDeposit {
    IBEP20 public token;
    address payable public wallet1;
    address payable public wallet2;
    address payable public wallet3;
    address payable public wallet4;
    address payable public wallet5;
    address payable public wallet6;
    address payable public wallet7;
    uint8 public wallet1Percent;
    uint8 public wallet2Percent;
    uint8 public wallet3Percent;
    uint8 public wallet4Percent;
    uint8 public wallet5Percent;
    uint8 public wallet6Percent;
    uint8 public walletPercentDenominator;

    struct DepositInfo {
        address wallet;
        uint256 amount;
        uint256 timestamp;
    }

    DepositInfo[] public depositHistory;
    
    constructor() {
        token = IBEP20(0x55d398326f99059fF775485246999027B3197955);
        wallet1 = payable(0xD7685c96262759F2122F3D5481DA0FEb73D6192E);
        wallet2 = payable(0x5c751A89F36b6c3a1cce26d684F1a36C9dbB748b);
        wallet3 = payable(0xebE54d6f11d4D77477eCE076f21F4D471Ce7869e);
        wallet4 = payable(0x5E363cFcCc11053Cc114bd2AdAe2C0FFa63DC351);
        wallet5 = payable(0xB2C64f5467ace4C8b716C70610Fe717eFAADAa4D);
        wallet6 = payable(0xc372F07C5dEDa342b33530eC82Ee3C5DA954F7b7);
        wallet7 = payable(0x0Cd726357C53DdB8A589769Fa464aa1fff96Be37);
        wallet1Percent = 3;
        wallet2Percent = 5;
        wallet3Percent = 2;
        wallet4Percent = 50;
        wallet5Percent = 37;
        wallet6Percent = 3;
        walletPercentDenominator = 100;
    }

    receive() external payable {}

    event Deposit(address indexed sender, uint256 amount);

    function deposit(uint256 _amount) public payable {
        require(_amount > 0, "Amount must be greater than 0");
        require(token.allowance(msg.sender, address(this)) >= _amount, "Token allowance not enough");
        require(token.balanceOf(msg.sender) >= _amount, "Insufficient token balance");
        token.transferFrom(msg.sender, address(this), _amount);
        // History
        DepositInfo memory depositInfo = DepositInfo({
            wallet: msg.sender,
            amount: _amount,
            timestamp: block.timestamp
        });
        depositHistory.push(depositInfo);
        // Distribution amount
        uint256 distributionAmount = _amount * 100 / 102;
        // Fee
        uint256 wallet7Part = _amount - distributionAmount;
        token.transfer(wallet7, wallet7Part);
        // Wallets part
        uint256 wallet1Part = distributionAmount * wallet1Percent / walletPercentDenominator;
        uint256 wallet2Part = distributionAmount * wallet2Percent / walletPercentDenominator;
        uint256 wallet3Part = distributionAmount * wallet3Percent / walletPercentDenominator;
        uint256 wallet4Part = distributionAmount * wallet4Percent / walletPercentDenominator;
        uint256 wallet5Part = distributionAmount * wallet5Percent / walletPercentDenominator;
        uint256 wallet6Part = distributionAmount * wallet6Percent / walletPercentDenominator;
        // Distribution
        token.transfer(wallet1, wallet1Part);
        token.transfer(wallet2, wallet2Part);
        token.transfer(wallet3, wallet3Part);
        token.transfer(wallet4, wallet4Part);
        token.transfer(wallet5, wallet5Part);
        token.transfer(wallet6, wallet6Part);

        emit Deposit(msg.sender, _amount);
    }

    function getDepositsHistory() public view returns (DepositInfo[] memory) {
        return depositHistory;
    }

    function getDepositsForAddress(address walletAddress) public view returns (DepositInfo[] memory) {
        uint256[] memory depositIndexes = new uint256[](depositHistory.length);
        uint256 depositCount = 0;
        for (uint256 i = 0; i < depositHistory.length; i++) {
            if (depositHistory[i].wallet == walletAddress) {
                depositIndexes[depositCount] = i;
                depositCount++;
            }
        }
        DepositInfo[] memory result = new DepositInfo[](depositCount);
        for (uint256 i = 0; i < depositCount; i++) {
            result[i] = depositHistory[depositIndexes[i]];
        }
        return result;
    }
}