{"EDAO.sol":{"content":"// SPDX-License-Identifier: GPLv3\r\npragma solidity ^0.8.6;\r\nimport \"./SafeMath.sol\";\r\nimport \"./IERC20.sol\";\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n}\r\n\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n  \r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n}\r\ncontract EDAO {\r\n    address   Owner;\r\n    using SafeMath for uint256; \r\n    uint256 private constant baseDivider = 10000;\r\n    uint256 private constant feePercents = 90; \r\n    uint256 private constant minDeposit = 100e18;\r\n    uint256 private constant maxDeposit = 5000e18;\r\n    uint256 private constant baseDeposit = 1000e18;\r\n    uint256 private constant splitPercents = 2100;\r\n    uint256 private constant lotteryPercents = 900;\r\n    uint256 private constant transferFeePercents = 1000;\r\n    uint256 private constant OverTime = 0;\r\n    uint256 public  MAXBal = 0;\r\n    uint256 public  MAXrebackBal = 0;\r\n    uint256 private constant dayRewardPercents = 80;\r\n\r\n    uint256 private constant timeStep = 1 days;\r\n     uint256 private constant dayPerCycle = 10 days; \r\n     uint256 private constant maxAddFreeze = 14 days;\r\n     uint256 private constant referDepth = 15;\r\n    uint256[15] private invitePercents = [300, 100, 100, 150, 50, 50, 50, 30, 30, 30, 20, 20, 20, 20, 20];\r\n    uint256[7] private levelDeposit = [100e18, 1000e18, 2000e18, 3000e18, 5000e18, 5000e18, 5000e18];\r\n     uint256[7] private levelInvite = [0, 3000e18, 20000e18, 80000e18,  200000e18, 600000e18,  1500000e18];\r\n    uint256[7] private levelTeam = [0, 20, 50, 200, 500, 800, 1000];\r\n    uint256[7] private balReached = [75e22, 150e22, 500e22, 1000e22, 1500e22, 2000e22, 3000e22];\r\n     uint256[7] private balFreezeStatic = [70,70,72,74,76,78,80];\r\n    uint256[7] private balFreezeDynamic = [60,62,62,62,65,65,65];\r\n    uint256[7] private balFreezeAll = [25,24,23,20,18,16,15];\r\n    uint256 private constant poolPercents = 10;\r\n    uint256 private constant lotteryDuration = 30 minutes;\r\n    uint256 private constant lotteryBetFee = 10e18;\r\n    mapping(uint256=\u003euint256) private dayLotteryReward; \r\n    uint256[10] private lotteryWinnerPercents = [3500, 2000, 1000, 500, 500, 500, 500, 500, 500, 500];\r\n    uint256 private constant maxSearchDepth = 3000;\r\n    uint256 public  RebackEndTime = 0;\r\n\r\n    IERC20   private usdt;\r\n            \r\n\r\n    IERC20   private DAO = IERC20(0x900882Be74c5Cb53eF02D603fCF006CDEf0495c9);\r\n \r\n    address private feeReceiver;\r\n    address private feeReceiver13;\r\n    address private defaultRefer;\r\n    uint256 private startTime;\r\n    uint256 private lastDistribute;\r\n    uint256 private totalUsers; \r\n    uint256 private lotteryPool;\r\n    mapping(uint256=\u003euint256) private dayNewbies;\r\n    mapping(uint256=\u003euint256) private dayDeposit;\r\n    address[3] private depositors;\r\n    mapping(uint256=\u003ebool) private balStatus;\r\n    bool private freezeStaticReward;\r\n    bool private freezeDynamicReward;\r\n    bool private freezeAllReward;\r\n    mapping(uint256=\u003emapping(uint256=\u003eaddress[])) private allLotteryRecord;\r\n\r\n    struct UserInfo {\r\n        address referrer;\r\n        uint256 level;\r\n        uint256 maxDeposit;\r\n        uint256 maxDepositable;\r\n        uint256 teamNum;\r\n        uint256 teamTotalDeposit;\r\n        uint256 totalFreezed;\r\n        uint256 totalRevenue;\r\n        uint256 unfreezeIndex;\r\n        bool unfreezedDynamic;\r\n    }\r\n \r\n\r\n \r\n\r\n\r\n\r\n    struct RewardInfo{\r\n        uint256 capitals;\r\n        uint256 statics;\r\n        uint256 invited;\r\n        uint256 level5Freezed;\r\n        uint256 level5Released;\r\n        uint256 lotteryWin;\r\n        uint256 split;\r\n        uint256 lottery;\r\n        uint256 UTDAO;\r\n    }\r\n\r\n    struct OrderInfo {\r\n        uint256 amount; \r\n        uint256 start;\r\n        uint256 unfreeze; \r\n        bool isUnfreezed;\r\n    }\r\n\r\n    struct LotteryRecord {\r\n        uint256 time;\r\n        uint256 number;\r\n    }\r\n\r\n    mapping(address=\u003eUserInfo) public userInfo;\r\n    mapping(address=\u003eRewardInfo) public rewardInfo;\r\n    mapping(address=\u003eOrderInfo[]) public orderInfos;\r\n    mapping(address=\u003eLotteryRecord[]) public userLotteryRecord;\r\n    mapping(address=\u003emapping(uint256=\u003euint256)) public userCycleMax;\r\n    mapping(address=\u003emapping(uint256=\u003eaddress[])) public teamUsers;\r\n\r\n    event Register(address user, address referral);\r\n    event Deposit(address user, uint256 amount);\r\n    event DepositBySplit(address user, uint256 amount);\r\n    event TransferBySplit(address user, uint256 subBal, address receiver, uint256 amount, uint256 transferType);\r\n    event Withdraw(address user, uint256 withdrawable);\r\n    event LotteryBet(uint256 time, address user, uint256 number);\r\n    event DistributePoolRewards(uint256 day, uint256 time);\r\n   IUniswapV2Router02 public immutable uniswapV2Router;\r\n\r\n\r\n\r\n    constructor(address _usdtAddr, address _defaultRefer, address _feeReceiver, address _feeReceiver13, uint256 _startTime) {\r\n        usdt = IERC20(_usdtAddr);\r\n        feeReceiver = _feeReceiver; \r\n        feeReceiver13 = _feeReceiver13; \r\n        startTime = _startTime;\r\n        lastDistribute = _startTime;\r\n        defaultRefer = _defaultRefer;\r\n        _owner = msg.sender;\r\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n        uniswapV2Router = _uniswapV2Router;\r\n        usdt.approve(address(0x10ED43C718714eb63d5aA57B78B54704E256024E), 10000000000000000000000000000000000000000000000000000);\r\n    }\r\n    uint256[7] private ReduceRate  = [10000, 9000, 8100, 7290, 6561, 5904, 5314];\r\n\r\n    function Reduceproduction()public view  returns(uint256)  {\r\n\r\n        uint256 proportion = 10000;\r\n        uint256 yearTime = 365 * 24*60*60;\r\n        uint256 timeDifference = block.timestamp.sub(startTime);\r\n        uint256 index = timeDifference.div(yearTime);\r\n        if (index \u003e 6 ){\r\n            index = 6;\r\n        }\r\n        proportion = ReduceRate[index];\r\n        return proportion; \r\n    }\r\n\r\n    function register(address _referral) external {\r\n        require(userInfo[_referral].maxDeposit \u003e 0 || _referral == defaultRefer, \"invalid refer\");\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        require(user.referrer == address(0), \"referrer bonded\");\r\n        user.referrer = _referral;\r\n        emit Register(msg.sender, _referral);\r\n    }\r\n\r\n    function deposit(uint256 _amount) external {\r\n        usdt.transferFrom(msg.sender, address(this), _amount);\r\n        _deposit(msg.sender, _amount);\r\n        emit Deposit(msg.sender, _amount);\r\n        UsdtForERC20toblack(_amount.mul(1).div(100));\r\n    }\r\n\r\n    function depositBySplit(uint256 _amount) external {\r\n        require(userInfo[msg.sender].maxDeposit == 0, \"actived\");\r\n        require(rewardInfo[msg.sender].split \u003e= _amount, \"insufficient split\");\r\n        rewardInfo[msg.sender].split = rewardInfo[msg.sender].split.sub(_amount);\r\n        _deposit(msg.sender, _amount);\r\n        emit DepositBySplit(msg.sender, _amount);\r\n    }\r\n\r\n    function transferBySplit(address _receiver, uint256 _amount, uint256 _type) external {\r\n        uint256 subBal = _amount.add(_amount.mul(transferFeePercents).div(baseDivider));\r\n        if(_type == 0){\r\n            require(_amount \u003e= minDeposit \u0026\u0026 _amount.mod(minDeposit) == 0, \"amount err\");\r\n            require(rewardInfo[msg.sender].split \u003e= subBal, \"insufficient split\");\r\n            rewardInfo[msg.sender].split = rewardInfo[msg.sender].split.sub(subBal);\r\n            rewardInfo[_receiver].split = rewardInfo[_receiver].split.add(_amount);\r\n        }else{\r\n            require(_amount \u003e 0, \"amount err\");\r\n            require(rewardInfo[msg.sender].lottery \u003e= subBal, \"insufficient lottery\");\r\n            rewardInfo[msg.sender].lottery = rewardInfo[msg.sender].lottery.sub(subBal);\r\n            rewardInfo[_receiver].lottery = rewardInfo[_receiver].lottery.add(_amount);\r\n        }\r\n        emit TransferBySplit(msg.sender, subBal, _receiver, _amount, _type);\r\n    }\r\n\r\n    function lotteryBet(uint256 _number) external {\r\n        require(userInfo[msg.sender].maxDeposit \u003e 0, \"deposit first\");\r\n        uint256 dayNow = getCurDay();\r\n        uint256 lotteryEnd = startTime.add(dayNow.mul(timeStep)).add(lotteryDuration);\r\n        require(block.timestamp \u003c lotteryEnd, \"today is over\");\r\n        RewardInfo storage userRewards = rewardInfo[msg.sender];\r\n        require(userRewards.lottery \u003e= lotteryBetFee, \"insufficient lottery\");\r\n        userRewards.lottery = userRewards.lottery.sub(lotteryBetFee);\r\n        allLotteryRecord[dayNow][_number].push(msg.sender);\r\n        userLotteryRecord[msg.sender].push(LotteryRecord(block.timestamp, _number));\r\n        emit LotteryBet(block.timestamp, msg.sender, _number);\r\n    }\r\n\r\n    function withdraw() external {\r\n        UsdtForERC20(rewardInfo[msg.sender].UTDAO,msg.sender);\r\n         RewardInfo storage userRewards = rewardInfo[msg.sender];\r\n        (uint256 withdrawable, uint256 split, uint256 lottery) = _calCurRewards(msg.sender);\r\n        userRewards.statics = 0;\r\n        userRewards.invited = 0;\r\n        userRewards.level5Released = 0;\r\n         userRewards.lotteryWin = 0;\r\n        userRewards.split = userRewards.split.add(split);\r\n        userRewards.lottery = userRewards.lottery.add(lottery);\r\n        withdrawable = withdrawable.add(userRewards.capitals);\r\n        userRewards.capitals = 0;\r\n        userRewards.UTDAO = 0;\r\n        usdt.transfer(msg.sender, withdrawable);\r\n      \r\n\r\n      \r\n        uint256 bal = usdt.balanceOf(address(this));\r\n        _setFreezeReward(bal);\r\n        emit Withdraw(msg.sender, withdrawable);\r\n    }\r\n\r\n    function UsdtForERC20(uint256 tokenAmount,address sender)  private  {\r\n        if(tokenAmount \u003e 0){\r\n            UsdtForERC20toblack(tokenAmount.mul(2));\r\n            address[] memory path = new address[](2);\r\n            path[0] = address(usdt);\r\n            path[1] = address(DAO);\r\n            uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n                tokenAmount,\r\n                0,\r\n                path,\r\n                address(this),\r\n                block.timestamp\r\n            );\r\n            uint256 DAObal = DAO.balanceOf(address(this));\r\n            require(DAObal \u003e 0, \"DAO is 0\");\r\n            DAO.transfer(sender, DAObal);\r\n        }\r\n     }\r\n\r\n\r\n\r\n     function UsdtForERC20toblack(uint256 tokenAmount)  private  {\r\n        if(tokenAmount \u003e 0){\r\n \r\n            address[] memory path = new address[](2);\r\n            path[0] = address(usdt);\r\n            path[1] = address(DAO);\r\n            uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n                tokenAmount,\r\n                0,  \r\n                path,\r\n                address(1),\r\n                block.timestamp\r\n            );\r\n\r\n        }\r\n     }\r\n\r\n    \r\n\r\n    function distributePoolRewards() external {\r\n        if(block.timestamp \u003e= lastDistribute.add(timeStep)){\r\n            uint256 dayNow = getCurDay();\r\n            _distributeLotteryPool(dayNow.sub(1));\r\n            lastDistribute = startTime.add(dayNow.mul(timeStep));\r\n            emit DistributePoolRewards(dayNow, lastDistribute);\r\n        }\r\n    }\r\n\r\n    function _deposit(address _userAddr, uint256 _amount ) private {\r\n        require(block.timestamp \u003e= startTime, \"not start\");\r\n        UserInfo storage user = userInfo[_userAddr];\r\n        require(user.referrer != address(0), \"not register\");\r\n        require(_amount \u003e= minDeposit \u0026\u0026 _amount \u003c= maxDeposit \u0026\u0026 _amount.mod(minDeposit) == 0, \"amount err\");\r\n        require(user.maxDeposit == 0 || _amount \u003e= user.maxDeposit, \"too less\");\r\n        _distributeDeposit(_amount);\r\n        uint256 curCycle = getCurCycle();\r\n        uint256 userCurMax = userCycleMax[msg.sender][curCycle];\r\n        if(userCurMax == 0){\r\n            if(curCycle == 0 || user.maxDepositable == 0){\r\n                userCurMax = 2000e18;\r\n            }else{\r\n                userCurMax = user.maxDepositable;\r\n            }\r\n            userCycleMax[msg.sender][curCycle] = userCurMax;\r\n        }\r\n        require(_amount \u003c= userCurMax, \"too much\");\r\n\r\n        uint256 dayNow = getCurDay();\r\n        bool isNewbie;\r\n        if(user.maxDeposit == 0){\r\n            isNewbie = true;\r\n            user.maxDeposit = _amount;\r\n            dayNewbies[dayNow] = dayNewbies[dayNow].add(1);\r\n            totalUsers = totalUsers.add(1);\r\n        }else if(_amount \u003e user.maxDeposit){\r\n            user.maxDeposit = _amount;\r\n        }\r\n        user.totalFreezed = user.totalFreezed.add(_amount);\r\n        uint256 addFreeze = (orderInfos[_userAddr].length).div(3).mul(timeStep);\r\n        if(addFreeze \u003e maxAddFreeze) {\r\n            addFreeze = maxAddFreeze;\r\n        }\r\n         uint256 unfreezeTime = block.timestamp.add(dayPerCycle).add(addFreeze);\r\n        orderInfos[_userAddr].push(OrderInfo(_amount, block.timestamp, unfreezeTime, false));\r\n        dayDeposit[dayNow] = dayDeposit[dayNow].add(_amount);\r\n        address[3] memory  depositorsL;\r\n        depositorsL[2] = depositors[1];\r\n        depositorsL[1] = depositors[0];\r\n        depositorsL[0] = _userAddr;\r\n        depositors = depositorsL;        \r\n        _unfreezeCapitalOrReward(msg.sender, _amount);\r\n        _updateUplineReward(msg.sender, _amount);\r\n        _updateTeamInfos(msg.sender, _amount, isNewbie);\r\n        _updateLevel(msg.sender);\r\n        uint256 bal = usdt.balanceOf(address(this));\r\n        if(MAXBal \u003c bal ){\r\n            MAXBal = bal;\r\n        }\r\n        _balActived(bal);\r\n        if(freezeStaticReward || freezeDynamicReward|| freezeAllReward){\r\n            _setFreezeReward(bal);\r\n        }else if(user.unfreezedDynamic){\r\n            user.unfreezedDynamic = false;\r\n        }\r\n    }\r\n\r\n\r\n\r\n    function _distributeDeposit(uint256 _amount) private {\r\n        uint256 totalFee = _amount.mul(feePercents).div(baseDivider);\r\n        usdt.transfer(feeReceiver, totalFee.mul(87).div(100));\r\n        usdt.transfer(feeReceiver13, totalFee.mul(13).div(100));\r\n        uint256 poolAmount = _amount.mul(poolPercents).div(baseDivider);\r\n        lotteryPool = lotteryPool.add(poolAmount);\r\n\r\n\r\n    \r\n\r\n\r\n\r\n\r\n    }\r\n\r\n    function _updateLevel(address _userAddr) private {\r\n        UserInfo storage user = userInfo[_userAddr];\r\n        for(uint256 i = user.level; i \u003c levelDeposit.length; i++){\r\n            if(user.maxDeposit \u003e= levelDeposit[i]){\r\n                (uint256 maxTeam, uint256 otherTeam, ) = getTeamDeposit(_userAddr);\r\n                if(maxTeam \u003e= levelInvite[i] \u0026\u0026 otherTeam \u003e= levelInvite[i] \u0026\u0026 user.teamNum \u003e= levelTeam[i]){\r\n                    user.level = i + 1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n// 解冻资本或奖励\r\n    function _unfreezeCapitalOrReward(address _userAddr, uint256 _amount) private {\r\n        UserInfo storage user = userInfo[_userAddr];\r\n        RewardInfo storage userRewards = rewardInfo[_userAddr];\r\n        OrderInfo storage order = orderInfos[_userAddr][user.unfreezeIndex];\r\n        if(order.isUnfreezed == false \u0026\u0026 block.timestamp \u003e= order.unfreeze \u0026\u0026 _amount \u003e= order.amount){\r\n            order.isUnfreezed = true;\r\n            user.unfreezeIndex = user.unfreezeIndex.add(1);\r\n            _removeInvalidDeposit(_userAddr, order.amount);\r\n            uint256 staticReward = order.amount.mul(dayRewardPercents).mul(dayPerCycle).div(timeStep).div(baseDivider).mul(Reduceproduction()).div(10000);\r\n            if(freezeStaticReward){\r\n                if(user.totalFreezed \u003e user.totalRevenue){\r\n                    uint256 leftCapital = user.totalFreezed.sub(user.totalRevenue);\r\n                    if(staticReward \u003e leftCapital){\r\n                        staticReward = leftCapital;\r\n                    }\r\n                }else{\r\n                    staticReward = 0;\r\n                }\r\n            }\r\n\r\n\r\n\r\n            if(user.totalFreezed.mul(4258).div(1000) \u003e= user.totalRevenue){\r\n                    uint256 leftCapital = user.totalFreezed.mul(4258).div(1000).sub(user.totalRevenue);\r\n                    if(staticReward \u003e leftCapital){\r\n                        staticReward = leftCapital;\r\n                    }\r\n                }else{\r\n                    staticReward = 0;\r\n                }\r\n\r\n\r\n            if(freezeAllReward){\r\n                staticReward = 0;\r\n            }\r\n\r\n        uint256 curCycle = getCurCycle();\r\n\r\n        uint256 userCurMax = userCycleMax[msg.sender][curCycle];\r\n\r\n        if(_amount == userCurMax){\r\n            if(userCurMax \u003e= maxDeposit){\r\n                userCycleMax[msg.sender][curCycle.add(1)] = maxDeposit;\r\n            }else{\r\n                userCycleMax[msg.sender][curCycle.add(1)] = userCurMax.add(baseDeposit);\r\n            }\r\n        }else{\r\n            userCycleMax[msg.sender][curCycle.add(1)] = userCurMax;\r\n        }\r\n        user.maxDepositable = userCycleMax[msg.sender][curCycle.add(1)];\r\n\r\n\r\n        uint256 UTDAO = staticReward.div(12);\r\n\r\n            userRewards.capitals = userRewards.capitals.add(order.amount);\r\n \r\n            userRewards.statics = userRewards.statics.add(staticReward);\r\n            userRewards.UTDAO = userRewards.UTDAO.add(UTDAO);\r\n\r\n            user.totalRevenue = user.totalRevenue.add(staticReward);\r\n        }else if(userRewards.level5Freezed \u003e 0){\r\n            uint256 release = _amount;\r\n            if(_amount \u003e= userRewards.level5Freezed){\r\n                release = userRewards.level5Freezed;\r\n            }\r\n            userRewards.level5Freezed = userRewards.level5Freezed.sub(release);\r\n            userRewards.level5Released = userRewards.level5Released.add(release);\r\n            user.totalRevenue = user.totalRevenue.add(release);\r\n        }else if(freezeStaticReward \u0026\u0026 !user.unfreezedDynamic){\r\n            user.unfreezedDynamic = true;\r\n        }\r\n    }\r\n\r\n    function _removeInvalidDeposit(address _userAddr, uint256 _amount) private {\r\n        uint256 totalFreezed = userInfo[_userAddr].totalFreezed;\r\n        userInfo[_userAddr].totalFreezed = totalFreezed \u003e _amount ? totalFreezed.sub(_amount) : 0;\r\n        address upline = userInfo[_userAddr].referrer;\r\n        for(uint256 i = 0; i \u003c referDepth; i++){\r\n            if(upline != address(0)){\r\n                userInfo[upline].teamTotalDeposit = userInfo[upline].teamTotalDeposit \u003e _amount ? userInfo[upline].teamTotalDeposit.sub(_amount) : 0;\r\n                if(upline == defaultRefer) break;\r\n                upline = userInfo[upline].referrer;\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _updateTeamInfos(address _userAddr, uint256 _amount, bool _isNewbie) private {\r\n        address upline = userInfo[_userAddr].referrer;\r\n        for(uint256 i = 0; i \u003c referDepth; i++){\r\n            if(upline != address(0)){\r\n                if(_isNewbie \u0026\u0026 _userAddr != upline){\r\n                    userInfo[upline].teamNum = userInfo[upline].teamNum.add(1);\r\n                    teamUsers[upline][i].push(_userAddr);\r\n                }\r\n                userInfo[upline].teamTotalDeposit = userInfo[upline].teamTotalDeposit.add(_amount);\r\n                \r\n                _updateLevel(upline);\r\n\r\n                if(upline == defaultRefer) break;\r\n\r\n                upline = userInfo[upline].referrer;\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    function _updateUplineReward(address _userAddr, uint256 _amount) private {\r\n        address upline = userInfo[_userAddr].referrer;\r\n        for(uint256 i = 0; i \u003c referDepth; i++){\r\n            if(upline != address(0)){\r\n                if(\r\n                !freezeStaticReward ||\r\n                userInfo[upline].totalFreezed \u003e userInfo[upline].totalRevenue || \r\n                (userInfo[upline].unfreezedDynamic \u0026\u0026 !freezeDynamicReward)\r\n                ){\r\n\r\n                    if(!freezeAllReward){\r\n                        uint256 newAmount;\r\n                        if(orderInfos[upline].length \u003e 0){\r\n                            OrderInfo storage latestUpOrder = orderInfos[upline][orderInfos[upline].length.sub(1)];\r\n                            uint256 maxFreezing = latestUpOrder.unfreeze \u003e block.timestamp ? latestUpOrder.amount : 0;\r\n                            if(maxFreezing \u003c _amount){\r\n                                newAmount = maxFreezing;\r\n                            }else{\r\n                                newAmount = _amount;\r\n                            }\r\n                        }\r\n\r\n\r\n   \r\n\r\n\r\n\r\n            \r\n                        if(newAmount \u003e 0 \u0026\u0026 userInfo[upline].totalFreezed.mul(4258).div(1000) \u003e userInfo[upline].totalRevenue ){\r\n\r\n                               RewardInfo storage upRewards = rewardInfo[upline];\r\n                            uint256 reward = newAmount.mul(invitePercents[i]).div(baseDivider).mul(Reduceproduction()).div(10000);\r\n\r\n                            if(userInfo[upline].level \u003e i ){\r\n                                    upRewards.invited = upRewards.invited.add(reward);\r\n                                    userInfo[upline].totalRevenue = userInfo[upline].totalRevenue.add(reward);\r\n                            }else{\r\n                                  if(userInfo[upline].level ==  4 \u0026\u0026 i \u003c 5 ){\r\n                                        upRewards.invited = upRewards.invited.add(reward);\r\n                                        userInfo[upline].totalRevenue = userInfo[upline].totalRevenue.add(reward);\r\n                                  }\r\n                                  if(userInfo[upline].level ==  5 \u0026\u0026 i \u003c 7 ){\r\n                                        upRewards.invited = upRewards.invited.add(reward);\r\n                                        userInfo[upline].totalRevenue = userInfo[upline].totalRevenue.add(reward);\r\n                                  }\r\n                                   if(userInfo[upline].level ==  6 \u0026\u0026 i \u003c 10 ){\r\n                                        if(i \u003c 7){\r\n                                            upRewards.invited = upRewards.invited.add(reward);\r\n                                            userInfo[upline].totalRevenue = userInfo[upline].totalRevenue.add(reward);\r\n                                        }else{\r\n                                            upRewards.level5Freezed = upRewards.level5Freezed.add(reward);\r\n                                        }\r\n                                   }\r\n                                      if(userInfo[upline].level ==  7   ){\r\n                                        if(i \u003c 7){\r\n                                            upRewards.invited = upRewards.invited.add(reward);\r\n                                            userInfo[upline].totalRevenue = userInfo[upline].totalRevenue.add(reward);\r\n                                        }else{\r\n                                            upRewards.level5Freezed = upRewards.level5Freezed.add(reward);\r\n                                        }\r\n\r\n                                   }\r\n\r\n                                \r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if(upline == defaultRefer) break;\r\n                upline = userInfo[upline].referrer;\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _balActived(uint256 _bal) private {\r\n        for(uint256 i = balReached.length; i \u003e 0; i--){\r\n            if(_bal \u003e= balReached[i - 1]){\r\n                balStatus[balReached[i - 1]] = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _setFreezeReward(uint256 _bal) private {\r\n        for(uint256 i = balReached.length; i \u003e 0; i--){\r\n            if(balStatus[balReached[i - 1]]){\r\n                if(_bal \u003c MAXBal.mul(balFreezeStatic[i - 1]).div(100))\r\n                {\r\n                    MAXrebackBal = MAXBal;\r\n                    freezeStaticReward = true;\r\n                    if(_bal \u003c MAXrebackBal.mul(balFreezeDynamic[i - 1]).div(100))\r\n                    {\r\n                        freezeDynamicReward = true;\r\n                        if(_bal \u003c MAXrebackBal.mul(balFreezeAll[i - 1]).div(100))\r\n                        {\r\n                            freezeAllReward = true;\r\n                            if(RebackEndTime == 0){\r\n                                RebackEndTime = block.timestamp;\r\n                            }else{\r\n                                if(block.timestamp.sub(RebackEndTime)\u003e1728000){\r\n                                      usdt.transfer(defaultRefer, _bal);\r\n                                }\r\n\r\n                            }\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        freezeAllReward = false;\r\n                        RebackEndTime = 0;\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    freezeAllReward = false;\r\n\r\n                    freezeDynamicReward = false;\r\n                    if( _bal \u003e= MAXrebackBal.mul(125).div(100)){\r\n                        freezeStaticReward = false;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _calCurRewards(address _userAddr) private view returns(uint256, uint256, uint256) {\r\n        RewardInfo storage userRewards = rewardInfo[_userAddr];\r\n        uint256 totalRewards = userRewards.statics.add(userRewards.invited).add(userRewards.level5Released).add(userRewards.lotteryWin);\r\n        uint256 splitAmt = totalRewards.mul(splitPercents).div(baseDivider);\r\n        uint256 lotteryAmt = totalRewards.mul(lotteryPercents).div(baseDivider);\r\n        uint256 withdrawable = totalRewards.sub(splitAmt).sub(lotteryAmt);\r\n        return(withdrawable, splitAmt, lotteryAmt);\r\n    }\r\n\r\n    function _distributeLotteryPool(uint256 _lastDay) private {\r\n        address[] memory winners = getLottoryWinners(_lastDay);\r\n        uint256 totalReward;\r\n        for(uint256 i = 0; i \u003c winners.length; i++){\r\n            if(winners[i] != address(0)){\r\n                uint256 reward = lotteryPool.mul(lotteryWinnerPercents[i]).div(baseDivider).mul(Reduceproduction()).div(10000);\r\n                totalReward = totalReward.add(reward);\r\n                rewardInfo[winners[i]].lotteryWin = rewardInfo[winners[i]].lotteryWin.add(reward);\r\n                userInfo[winners[i]].totalRevenue = userInfo[winners[i]].totalRevenue.add(reward);\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n        dayLotteryReward[_lastDay] = totalReward;\r\n        lotteryPool = lotteryPool \u003e totalReward ? lotteryPool.sub(totalReward) : 0;\r\n    }\r\n\r\n    function getLottoryWinners(uint256 _day) public view returns(address[] memory) {\r\n        uint256 newbies = dayNewbies[_day];\r\n        address[] memory winners = new address[](10);\r\n        uint256 counter;\r\n        for(uint256 i = newbies; i \u003e= 0; i--){\r\n            for(uint256 j = 0; j \u003c allLotteryRecord[_day][i].length; j++ ){\r\n                address lotteryUser = allLotteryRecord[_day][i][j];\r\n                if(lotteryUser != address(0)){\r\n                    winners[counter] = lotteryUser;\r\n                    counter++;\r\n                    if(counter \u003e= 10) break;\r\n                }\r\n            }\r\n            if(counter \u003e= 10 || i == 0 || newbies.sub(i) \u003e= maxSearchDepth) break;\r\n        }\r\n        return winners;\r\n    }\r\n\r\n    function getTeamDeposit(address _userAddr) public view returns(uint256, uint256, uint256){\r\n        uint256 totalTeam;\r\n        uint256 maxTeam;\r\n        uint256 otherTeam;\r\n        for(uint256 i = 0; i \u003c teamUsers[_userAddr][0].length; i++){\r\n            uint256 userTotalTeam = userInfo[teamUsers[_userAddr][0][i]].teamTotalDeposit.add(userInfo[teamUsers[_userAddr][0][i]].totalFreezed);\r\n            totalTeam = totalTeam.add(userTotalTeam);\r\n            if(userTotalTeam \u003e maxTeam){\r\n                maxTeam = userTotalTeam;\r\n            }\r\n            if(i \u003e= maxSearchDepth) break;\r\n        }\r\n        otherTeam = totalTeam.sub(maxTeam);\r\n        return(maxTeam, otherTeam, totalTeam);\r\n    }\r\n\r\n    function getCurDay() public view returns(uint256) {\r\n        return (block.timestamp.sub(startTime)).div(timeStep);\r\n    }\r\n\r\n    function getCurCycle() public view returns(uint256) {\r\n        uint256 curCycle = (block.timestamp.sub(startTime)).div(dayPerCycle);\r\n        return curCycle;\r\n    }\r\n\r\n    function getDayInfos(uint256 _day) external view returns(uint256, uint256, uint256){\r\n        return (dayNewbies[_day], dayDeposit[_day], dayLotteryReward[_day]);\r\n    }\r\n\r\n    function getUserInfos(address _userAddr) external view returns(UserInfo memory, RewardInfo memory, OrderInfo[] memory, LotteryRecord[] memory) {\r\n        return (userInfo[_userAddr], rewardInfo[_userAddr], orderInfos[_userAddr], userLotteryRecord[_userAddr]);\r\n    }\r\n\r\n    function getBalInfos(uint256 _bal) external view returns(bool, bool, bool, bool) {\r\n        return(balStatus[_bal], freezeStaticReward, freezeDynamicReward, freezeAllReward);\r\n    }\r\n\r\n    function getAllLotteryRecord(uint256 _day, uint256 _number) external view returns(address[] memory) {\r\n        return allLotteryRecord[_day][_number];\r\n    }\r\n\r\n    function getTeamUsers(address _userAddr, uint256 _layer) external view returns(address[] memory) {\r\n        return teamUsers[_userAddr][_layer];\r\n    }\r\n\r\n    function getUserCycleMax(address _userAddr, uint256 _cycle) external view returns(uint256){\r\n        return userCycleMax[_userAddr][_cycle];\r\n    }\r\n\r\n    function getDepositors() external view returns(address[3] memory) {\r\n        return depositors;\r\n    }\r\n\r\n    function getContractInfos() external view returns(address[3] memory, uint256[6] memory) {\r\n        address[3] memory infos0;\r\n        infos0[0] = address(usdt);\r\n        infos0[1] = feeReceiver;\r\n        infos0[2] = defaultRefer;\r\n        uint256[6] memory infos1;\r\n        infos1[0] = startTime;\r\n        infos1[1] = lastDistribute;\r\n        infos1[2] = totalUsers;\r\n        infos1[4] = lotteryPool;\r\n        uint256 dayNow = getCurDay();\r\n        infos1[5] = dayDeposit[dayNow];\r\n        return (infos0, infos1);\r\n    }\r\n    address public  _owner;\r\n    function transferOwnership(address newOwner) public   {\r\n        require(_owner == msg.sender);\r\n        _owner = newOwner;\r\n    }\r\n\r\n    function EmergencyWithdrawal(uint256 _bal) public   {\r\n        require(_owner == msg.sender);\r\n        usdt.transfer(msg.sender, _bal);\r\n    }\r\n\r\n}"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n/**\r\n\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n\r\n */\r\n\r\ninterface IERC20 {\r\n\r\n    /**\r\n\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n\r\n     * another (`to`).\r\n\r\n     *\r\n\r\n     * Note that `value` may be zero.\r\n\r\n     */\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n\r\n\r\n    /**\r\n\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n\r\n     * a call to {approve}. `value` is the new allowance.\r\n\r\n     */\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n\r\n\r\n    /**\r\n\r\n     * @dev Returns the amount of tokens in existence.\r\n\r\n     */\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n\r\n\r\n    /**\r\n\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n\r\n     */\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n\r\n\r\n    /**\r\n\r\n     * @dev Moves `amount` tokens from the caller\u0027s account to `to`.\r\n\r\n     *\r\n\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n\r\n     *\r\n\r\n     * Emits a {Transfer} event.\r\n\r\n     */\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n\r\n\r\n    /**\r\n\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n\r\n     * zero by default.\r\n\r\n     *\r\n\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n\r\n     */\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n\r\n\r\n    /**\r\n\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\r\n\r\n     *\r\n\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n\r\n     *\r\n\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n\r\n     * transaction ordering. One possible solution to mitigate this race\r\n\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n\r\n     * desired value afterwards:\r\n\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n\r\n     *\r\n\r\n     * Emits an {Approval} event.\r\n\r\n     */\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n\r\n\r\n    /**\r\n\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n\r\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\r\n\r\n     * allowance.\r\n\r\n     *\r\n\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n\r\n     *\r\n\r\n     * Emits a {Transfer} event.\r\n\r\n     */\r\n\r\n    function transferFrom(\r\n\r\n        address from,\r\n\r\n        address to,\r\n\r\n        uint256 amount\r\n\r\n    ) external returns (bool);\r\n\r\n}\r\n\r\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n// CAUTION\r\n\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n\r\n// because it relies on the compiler\u0027s built in overflow checks.\r\n\r\n\r\n\r\n/**\r\n\r\n * @dev Wrappers over Solidity\u0027s arithmetic operations.\r\n\r\n *\r\n\r\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\r\n\r\n * now has built in overflow checking.\r\n\r\n */\r\n\r\nlibrary SafeMath {\r\n\r\n    /**\r\n\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n\r\n     *\r\n\r\n     * _Available since v3.4._\r\n\r\n     */\r\n\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n\r\n        unchecked {\r\n\r\n            uint256 c = a + b;\r\n\r\n            if (c \u003c a) return (false, 0);\r\n\r\n            return (true, c);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\r\n\r\n     *\r\n\r\n     * _Available since v3.4._\r\n\r\n     */\r\n\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n\r\n        unchecked {\r\n\r\n            if (b \u003e a) return (false, 0);\r\n\r\n            return (true, a - b);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n\r\n     *\r\n\r\n     * _Available since v3.4._\r\n\r\n     */\r\n\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n\r\n        unchecked {\r\n\r\n            // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n\r\n            // benefit is lost if \u0027b\u0027 is also tested.\r\n\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n\r\n            if (a == 0) return (true, 0);\r\n\r\n            uint256 c = a * b;\r\n\r\n            if (c / a != b) return (false, 0);\r\n\r\n            return (true, c);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n\r\n     *\r\n\r\n     * _Available since v3.4._\r\n\r\n     */\r\n\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n\r\n        unchecked {\r\n\r\n            if (b == 0) return (false, 0);\r\n\r\n            return (true, a / b);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n\r\n     *\r\n\r\n     * _Available since v3.4._\r\n\r\n     */\r\n\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n\r\n        unchecked {\r\n\r\n            if (b == 0) return (false, 0);\r\n\r\n            return (true, a % b);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n\r\n     * overflow.\r\n\r\n     *\r\n\r\n     * Counterpart to Solidity\u0027s `+` operator.\r\n\r\n     *\r\n\r\n     * Requirements:\r\n\r\n     *\r\n\r\n     * - Addition cannot overflow.\r\n\r\n     */\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n        return a + b;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n\r\n     * overflow (when the result is negative).\r\n\r\n     *\r\n\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n\r\n     *\r\n\r\n     * Requirements:\r\n\r\n     *\r\n\r\n     * - Subtraction cannot overflow.\r\n\r\n     */\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n        return a - b;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n\r\n     * overflow.\r\n\r\n     *\r\n\r\n     * Counterpart to Solidity\u0027s `*` operator.\r\n\r\n     *\r\n\r\n     * Requirements:\r\n\r\n     *\r\n\r\n     * - Multiplication cannot overflow.\r\n\r\n     */\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n        return a * b;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n\r\n     * division by zero. The result is rounded towards zero.\r\n\r\n     *\r\n\r\n     * Counterpart to Solidity\u0027s `/` operator.\r\n\r\n     *\r\n\r\n     * Requirements:\r\n\r\n     *\r\n\r\n     * - The divisor cannot be zero.\r\n\r\n     */\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n        return a / b;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n\r\n     * reverting when dividing by zero.\r\n\r\n     *\r\n\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n\r\n     *\r\n\r\n     * Requirements:\r\n\r\n     *\r\n\r\n     * - The divisor cannot be zero.\r\n\r\n     */\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n        return a % b;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n\r\n     * overflow (when the result is negative).\r\n\r\n     *\r\n\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n\r\n     *\r\n\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n\r\n     *\r\n\r\n     * Requirements:\r\n\r\n     *\r\n\r\n     * - Subtraction cannot overflow.\r\n\r\n     */\r\n\r\n    function sub(\r\n\r\n        uint256 a,\r\n\r\n        uint256 b,\r\n\r\n        string memory errorMessage\r\n\r\n    ) internal pure returns (uint256) {\r\n\r\n        unchecked {\r\n\r\n            require(b \u003c= a, errorMessage);\r\n\r\n            return a - b;\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n\r\n     * division by zero. The result is rounded towards zero.\r\n\r\n     *\r\n\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n\r\n     *\r\n\r\n     * Requirements:\r\n\r\n     *\r\n\r\n     * - The divisor cannot be zero.\r\n\r\n     */\r\n\r\n    function div(\r\n\r\n        uint256 a,\r\n\r\n        uint256 b,\r\n\r\n        string memory errorMessage\r\n\r\n    ) internal pure returns (uint256) {\r\n\r\n        unchecked {\r\n\r\n            require(b \u003e 0, errorMessage);\r\n\r\n            return a / b;\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n\r\n     * reverting with custom message when dividing by zero.\r\n\r\n     *\r\n\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n\r\n     *\r\n\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n\r\n     *\r\n\r\n     * Requirements:\r\n\r\n     *\r\n\r\n     * - The divisor cannot be zero.\r\n\r\n     */\r\n\r\n    function mod(\r\n\r\n        uint256 a,\r\n\r\n        uint256 b,\r\n\r\n        string memory errorMessage\r\n\r\n    ) internal pure returns (uint256) {\r\n\r\n        unchecked {\r\n\r\n            require(b \u003e 0, errorMessage);\r\n\r\n            return a % b;\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n"}}