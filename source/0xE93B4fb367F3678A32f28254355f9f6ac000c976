{"Base.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\ncontract Base {\n    constructor () public {\n\n    }\n\n    //0x20 - length\n    //0x53c6eaee8696e4c5200d3d231b29cc6a40b3893a5ae1536b0ac08212ffada877\n    bytes constant notFoundMark = abi.encodePacked(keccak256(abi.encodePacked(keccak256(abi.encodePacked(keccak256(abi.encodePacked(\"404-method-not-found\")))))));\n\n\n    //return the payload of returnData, stripe the leading length\n    function returnAsm(bool isRevert, bytes memory returnData) pure internal {\n        assembly{\n            let length := mload(returnData)\n            switch isRevert\n            case 0x00{\n                return (add(returnData, 0x20), length)\n            }\n            default{\n                revert (add(returnData, 0x20), length)\n            }\n        }\n    }\n\n    modifier nonPayable(){\n        require(msg.value == 0, \"nonPayable\");\n        _;\n    }\n\n}\n"},"CelestialNameServiceInterface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"./OwnableInterface.sol\";\n\n\ninterface CelestialNameServiceInterface is OwnableInterface {\n\n    function celestialNFTCommon() view external returns (address);\n\n    function celestialNFTSupreme() view external returns (address);\n\n    function celestialNFTManager() view external returns (address);\n\n    function crystal() view external returns (address);\n\n    function chest() view external returns (address);\n\n    function celestial() view external returns (address);\n\n    function vCelestial() view external returns (address);\n\n    function miner() external view returns (address);\n\n    function profitCollector() external view returns (address);\n\n    //===============\n\n    function isCelestialNFTCommon(address input) view external returns (bool);\n\n    function isCelestialNFTSupreme(address input) view external returns (bool);\n\n    function isCelestialNFTManager(address input) view external returns (bool);\n\n    function isMiner(address input) view external returns (bool);\n\n    function isProfitCollector(address input) view external returns (bool);\n\n    function isCrystal(address input) view external returns (bool);\n\n    function isChest(address input) view external returns (bool);\n\n    function isCelestial(address input) view external returns (bool);\n\n    function isVCelestial(address input) view external returns (bool);\n\n    function isNftPool(address input) view external returns (bool);\n\n    function isNftLimitedPool(address input) view external returns (bool);\n\n    function isErc20Pool(address input) view external returns (bool);\n\n    function isSmartPoolContractAllowed(address input) external view returns (bool);\n\n    function isGlobalBlocked(address input) external view returns (bool);\n\n    //===============\n\n    function setCelestialNFTCommon(address input) external;\n\n    function setCelestialNFTSupreme(address input) external;\n\n    function setCelestialNFTManager(address input) external;\n\n    function setMiner(address input) external;\n\n    function setProfitCollector(address input) external;\n\n    function setCrystal(address input) external;\n\n    function setChest(address input) external;\n\n    function setCelestial(address input) external;\n\n    function setVCelestial(address input) external;\n\n    function setNtfPoolRegistry(address input, bool flag) external;\n\n    function setNtfLimitedPoolRegistry(address input, bool flag) external;\n\n    function setErc20PoolRegistry(address input, bool flag) external;\n\n    function setSmartPoolContractAllowanceList(address input, bool flag) external;\n\n    function setGlobalBlockList(address input, bool flag) external;\n}\n"},"CERC20Event.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\n\ninterface CERC20Event {\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"CERC20IMLayout.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./CERC20Layout.sol\";\nimport \"./OwnableLayout.sol\";\n\n//erc20, ownable, erc20im\ncontract CERC20IMLayout is CERC20Layout, OwnableLayout {\n\n    address internal _cns;\n\n    mapping(address =\u003e bool) internal _blockList;\n    mapping(address =\u003e bool) internal _privilegeList;\n\n    bool internal _supportTransfer;\n\n    uint256 internal _transferTxs;\n\n    uint256 internal _transferAmounts;\n\n    mapping(address =\u003e bool) internal _interactRecord;\n    uint256 internal _interactAmounts;\n}\n"},"CERC20IMLogicBase.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \u0027./SafeMath.sol\u0027;\n\nimport \"./CERC20LogicBase.sol\";\nimport \"./OwnableLogicBase.sol\";\nimport \"./CERC20IMLayout.sol\";\n\nimport \u0027./CelestialNameServiceInterface.sol\u0027;\n\ncontract CERC20IMLogicBase is CERC20LogicBase, OwnableLogicBase, CERC20IMLayout {\n    using SafeMath for uint256;\n\n\n    modifier interact(){\n        if (!_interactRecord[msg.sender]) {\n            _interactRecord[msg.sender] = true;\n            _interactAmounts = _interactAmounts.add(1);\n        }\n        _;\n    }\n\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\u0027s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\u0027s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) override(CERC20LogicBase) virtual internal interact {\n\n        if (_cns != address(0) \u0026\u0026\n            (\n            CelestialNameServiceInterface(_cns).isMiner(from) ||\n            CelestialNameServiceInterface(_cns).isErc20Pool(from) ||\n            CelestialNameServiceInterface(_cns).isNftPool(from) ||\n            CelestialNameServiceInterface(_cns).isNftLimitedPool(from) ||\n            CelestialNameServiceInterface(_cns).isMiner(to) ||\n            CelestialNameServiceInterface(_cns).isErc20Pool(to) ||\n            CelestialNameServiceInterface(_cns).isNftPool(to) ||\n            CelestialNameServiceInterface(_cns).isNftLimitedPool(to)\n            )\n        ) {\n\n        } else if (_privilegeList[from] || _privilegeList[to]) {\n            //privilege overrides all following condition\n        } else if (from != address(0) \u0026\u0026 to != address(0)) {\n            require(_supportTransfer, \"supportTransfer?\");\n        } else if (_blockList[from] || _blockList[to]) {\n            revert(\"blocked?\");\n        }\n\n        //impossible to hit the 2^256 :)\n        _transferTxs = _transferTxs.add(1);\n\n        //unreasonable to hit the 2^256 :)\n        _transferAmounts = _transferAmounts.add(amount);\n\n        CERC20LogicBase._beforeTokenTransfer(from, to, amount);\n\n    }\n}\n"},"CERC20IMStorage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./CERC20IMLogicBase.sol\";\n\ncontract CERC20IMStorage is CERC20IMLogicBase {\n\n    constructor (address cns_, bool supportTransfer_) public {\n        _cns = cns_;\n\n        _supportTransfer = supportTransfer_;\n    }\n}\n"},"CERC20Layout.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\ncontract CERC20Layout {\n\n    mapping(address =\u003e uint256) internal _balances;\n\n    mapping(address =\u003e mapping(address =\u003e uint256)) internal _allowances;\n\n    uint256 internal _totalSupply;\n\n    string internal _name;\n    string internal _symbol;\n    uint8 internal _decimals;\n\n    uint256 internal _cap;\n\n}\n"},"CERC20LogicBase.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \u0027./SafeMath.sol\u0027;\n\nimport \"./CERC20Event.sol\";\nimport \"./ContextLogicBase.sol\";\nimport \"./CERC20Layout.sol\";\n\ncontract CERC20LogicBase is CERC20Event, ContextLogicBase, CERC20Layout {\n    using SafeMath for uint256;\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\u0027s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\u0027s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address /*to*/, uint256 amount) internal virtual {\n        if (from == address(0)) {// When minting tokens\n            require(_totalSupply.add(amount) \u003c= _cap, \"ERC20Capped: cap exceeded\");\n        }\n    }\n}\n"},"CERC20Storage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./CERC20LogicBase.sol\";\n\ncontract CERC20Storage is CERC20LogicBase {\n\n    constructor (string memory name_, string memory symbol_, uint256 cap_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n        require(cap_ \u003e 0, \"ERC20Capped: cap is 0\");\n        _cap = cap_;\n    }\n}\n"},"ContextLogicBase.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity \u003e=0.6.0 \u003c0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract ContextLogicBase {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this;\n        // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"},"CrystalLayout.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./CrystalLayout1.sol\";\n\ncontract CrystalLayout is CrystalLayout1 {\n}\n"},"CrystalLayout1.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./CERC20Layout.sol\";\nimport \"./OwnableLayout.sol\";\n\ncontract CrystalLayout1 is CERC20Layout, OwnableLayout {\n    uint256 constant _cap_ = 10 ** 9 * 10 ** 18;\n    string constant _name_ = \"Crystal\";\n    string constant _symbol_ = \"Crystal\";\n}\n"},"CrystalLogicBase.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./CrystalLayout.sol\";\nimport \"./CERC20IMLogicBase.sol\";\n\ncontract CrystalLogicBase is CERC20IMLogicBase, CrystalLayout {\n\n}\n"},"CrystalStorage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./Proxy.sol\";\n\nimport \"./CERC20Storage.sol\";\nimport \"./OwnableStorage.sol\";\nimport \"./CERC20IMStorage.sol\";\n\nimport \"./CrystalLogicBase.sol\";\n\ncontract CrystalStorage is Proxy, CERC20Storage, OwnableStorage, CERC20IMStorage, CrystalLogicBase {\n\n    constructor(\n        address cns_,\n        address init_holder,\n        address owner_\n    ) public Proxy(msg.sender) CERC20Storage(_name_, _symbol_, _cap_) OwnableStorage(owner_) CERC20IMStorage(cns_,true) {\n        _mint(init_holder, _cap_);\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal\n    override(CERC20LogicBase, CERC20IMLogicBase) {\n        CERC20IMLogicBase._beforeTokenTransfer(from, to, amount);\n    }\n}\n"},"EnhancedMap.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./SlotData.sol\";\n\n//this is just a normal mapping, but which holds size and you can specify slot\n/*\nboth key and value shouldn\u0027t be 0x00\nthe key must be unique, the value would be whatever\n\nslot\n  key --- value\n    a --- 1\n    b --- 2\n    c --- 3\n    c --- 4   X   not allowed\n    d --- 3\n    e --- 0   X   not allowed\n    0 --- 9   X   not allowed\n\n*/\ncontract EnhancedMap is SlotData {\n\n    constructor() public {}\n\n    //set value to 0x00 to delete\n    function sysEnhancedMapSet(bytes32 slot, bytes32 key, bytes32 value) internal {\n        require(key != bytes32(0x00), \"sysEnhancedMapSet, notEmptyKey\");\n        sysMapSet(slot, key, value);\n    }\n\n    function sysEnhancedMapAdd(bytes32 slot, bytes32 key, bytes32 value) internal {\n        require(key != bytes32(0x00), \"sysEnhancedMapAdd, notEmptyKey\");\n        require(value != bytes32(0x00), \"EnhancedMap add, the value shouldn\u0027t be empty\");\n        require(sysMapGet(slot, key) == bytes32(0x00), \"EnhancedMap, the key already has value, can\u0027t add duplicate key\");\n        sysMapSet(slot, key, value);\n    }\n\n    function sysEnhancedMapDel(bytes32 slot, bytes32 key) internal {\n        require(key != bytes32(0x00), \"sysEnhancedMapDel, notEmptyKey\");\n        require(sysMapGet(slot, key) != bytes32(0x00), \"sysEnhancedMapDel, the key doesn\u0027t has value, can\u0027t delete empty key\");\n        sysMapSet(slot, key, bytes32(0x00));\n    }\n\n    function sysEnhancedMapReplace(bytes32 slot, bytes32 key, bytes32 value) public {\n        require(key != bytes32(0x00), \"sysEnhancedMapReplace, notEmptyKey\");\n        require(value != bytes32(0x00), \"EnhancedMap replace, the value shouldn\u0027t be empty\");\n        require(sysMapGet(slot, key) != bytes32(0x00), \"EnhancedMap, the key doesn\u0027t has value, can\u0027t replace it\");\n        sysMapSet(slot, key, value);\n    }\n\n    function sysEnhancedMapGet(bytes32 slot, bytes32 key) internal view returns (bytes32){\n        require(key != bytes32(0x00), \"sysEnhancedMapGet, notEmptyKey\");\n        return sysMapGet(slot, key);\n    }\n\n    function sysEnhancedMapSize(bytes32 slot) internal view returns (uint256){\n        return sysMapLen(slot);\n    }\n\n}\n"},"EnhancedUniqueIndexMap.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./SlotData.sol\";\n\n//once you input a value, it will auto generate an index for that\n//index starts from 1, 0 means this value doesn\u0027t exist\n//the value must be unique, and can\u0027t be 0x00\n//the index must be unique, and can\u0027t be 0x00\n/*\n\nslot\nvalue --- index\n    a --- 1\n    b --- 2\n    c --- 3\n    c --- 4   X   not allowed\n    d --- 3   X   not allowed\n    e --- 0   X   not allowed\n\nindexSlot = keccak256(abi.encodePacked(keccak256(abi.encodePacked(keccak256(abi.encodePacked(slot))))));\nindex --- value\n    1 --- a\n    2 --- b\n    3 --- c\n    3 --- d   X   not allowed\n\n*/\n\ncontract EnhancedUniqueIndexMap is SlotData {\n\n    constructor() public {}\n\n    // slot : value =\u003e index\n    function sysUniqueIndexMapAdd(bytes32 slot, bytes32 value) internal {\n\n        require(value != bytes32(0x00));\n\n        bytes32 indexSlot = calcIndexSlot(slot);\n\n        uint256 index = uint256(sysMapGet(slot, value));\n        require(index == 0, \"sysUniqueIndexMapAdd, value already exist\");\n\n        uint256 last = sysUniqueIndexMapSize(slot);\n        last ++;\n        sysMapSet(slot, value, bytes32(last));\n        sysMapSet(indexSlot, bytes32(last), value);\n    }\n\n    function sysUniqueIndexMapDel(bytes32 slot, bytes32 value) internal {\n\n        //require(value != bytes32(0x00), \"sysUniqueIndexMapDel, value must not be 0x00\");\n\n        bytes32 indexSlot = calcIndexSlot(slot);\n\n        uint256 index = uint256(sysMapGet(slot, value));\n        require(index != 0, \"sysUniqueIndexMapDel, value doesn\u0027t exist\");\n\n        uint256 lastIndex = sysUniqueIndexMapSize(slot);\n        require(lastIndex \u003e 0, \"sysUniqueIndexMapDel, lastIndex must be large than 0, this must not happen\");\n        if (index != lastIndex) {\n\n            bytes32 lastValue = sysMapGet(indexSlot, bytes32(lastIndex));\n            //move the last to the current place\n            //this would be faster than move all elements forward after the deleting one, but not stable(the sequence will change)\n            sysMapSet(slot, lastValue, bytes32(index));\n            sysMapSet(indexSlot, bytes32(index), lastValue);\n        }\n        sysMapSet(slot, value, bytes32(0x00));\n        sysMapSet(indexSlot, bytes32(lastIndex), bytes32(0x00));\n    }\n\n    function sysUniqueIndexMapDelArrange(bytes32 slot, bytes32 value) internal {\n\n        require(value != bytes32(0x00), \"sysUniqueIndexMapDelArrange, value must not be 0x00\");\n\n        bytes32 indexSlot = calcIndexSlot(slot);\n\n        uint256 index = uint256(sysMapGet(slot, value));\n        require(index != 0, \"sysUniqueIndexMapDelArrange, value doesn\u0027t exist\");\n\n        uint256 lastIndex = (sysUniqueIndexMapSize(slot));\n        require(lastIndex \u003e 0, \"sysUniqueIndexMapDelArrange, lastIndex must be large than 0, this must not happen\");\n\n        sysMapSet(slot, value, bytes32(0x00));\n\n        while (index \u003c lastIndex) {\n\n            bytes32 nextValue = sysMapGet(indexSlot, bytes32(index + 1));\n            sysMapSet(indexSlot, bytes32(index), nextValue);\n            sysMapSet(slot, nextValue, bytes32(index));\n\n            index ++;\n        }\n\n        sysMapSet(indexSlot, bytes32(lastIndex), bytes32(0x00));\n    }\n\n    function sysUniqueIndexMapReplace(bytes32 slot, bytes32 oldValue, bytes32 newValue) internal {\n        require(oldValue != bytes32(0x00), \"sysUniqueIndexMapReplace, oldValue must not be 0x00\");\n        require(newValue != bytes32(0x00), \"sysUniqueIndexMapReplace, newValue must not be 0x00\");\n\n        bytes32 indexSlot = calcIndexSlot(slot);\n\n        uint256 index = uint256(sysMapGet(slot, oldValue));\n        require(index != 0, \"sysUniqueIndexMapDel, oldValue doesn\u0027t exists\");\n        require(uint256(sysMapGet(slot, newValue)) == 0, \"sysUniqueIndexMapDel, newValue already exists\");\n\n        sysMapSet(slot, oldValue, bytes32(0x00));\n        sysMapSet(slot, newValue, bytes32(index));\n        sysMapSet(indexSlot, bytes32(index), newValue);\n    }\n\n    //============================view \u0026 pure============================\n\n    function sysUniqueIndexMapSize(bytes32 slot) internal view returns (uint256){\n        return sysMapLen(slot);\n    }\n\n    //returns index, 0 mean not exist\n    function sysUniqueIndexMapGetIndex(bytes32 slot, bytes32 value) internal view returns (uint256){\n        return uint256(sysMapGet(slot, value));\n    }\n\n    function sysUniqueIndexMapGetValue(bytes32 slot, uint256 index) internal view returns (bytes32){\n        bytes32 indexSlot = calcIndexSlot(slot);\n        return sysMapGet(indexSlot, bytes32(index));\n    }\n\n    // index =\u003e value\n    function calcIndexSlot(bytes32 slot) internal pure returns (bytes32){\n        return calcNewSlot(slot, \"index\");\n    }\n}\n"},"OwnableEvent.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\ninterface OwnableEvent {\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n}\n"},"OwnableInterface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"./OwnableEvent.sol\";\npragma experimental ABIEncoderV2;\n\ninterface OwnableInterface is OwnableEvent {\n\n    function owner() external view returns (address);\n\n    function isAssociatedOperator(address) external view returns (bool);\n\n    function renounceOwnership() external;\n\n    function transferOwnership(address newOwner) external;\n\n    function setAssociatedOperator(address newAssociatedOperator, bool flag) external;\n\n}\n"},"OwnableLayout.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nabstract contract OwnableLayout {\n    address internal _owner;\n\n    mapping(address =\u003e bool) internal _associatedOperators;\n}\n"},"OwnableLogicBase.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./OwnableLayout.sol\";\n\ncontract OwnableLogicBase is OwnableLayout {\n    //nothing to do here\n}\n"},"OwnableStorage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./OwnableLayout.sol\";\n\ncontract OwnableStorage is OwnableLayout {\n\n    constructor (address owner) internal {\n        _owner = owner;\n    }\n}\n"},"Proxy.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./Base.sol\";\nimport \"./EnhancedMap.sol\";\nimport \"./EnhancedUniqueIndexMap.sol\";\n\n\ncontract Proxy is Base, EnhancedMap, EnhancedUniqueIndexMap {\n    constructor (address admin) public {\n        require(admin != address(0));\n        sysSaveSlotData(adminSlot, bytes32(uint256(admin)));\n        sysSaveSlotData(userSigZeroSlot, bytes32(uint256(0)));\n        sysSaveSlotData(outOfServiceSlot, bytes32(uint256(0)));\n        sysSaveSlotData(revertMessageSlot, bytes32(uint256(1)));\n        //sysSetDelegateFallback(address(0));\n        sysSaveSlotData(transparentSlot, bytes32(uint256(1)));\n\n    }\n\n    bytes32 constant adminSlot = keccak256(abi.encodePacked(keccak256(abi.encodePacked(keccak256(abi.encodePacked(\"adminSlot\"))))));\n\n    bytes32 constant revertMessageSlot = keccak256(abi.encodePacked(keccak256(abi.encodePacked(keccak256(abi.encodePacked(\"revertMessageSlot\"))))));\n\n    bytes32 constant outOfServiceSlot = keccak256(abi.encodePacked(keccak256(abi.encodePacked(keccak256(abi.encodePacked(\"outOfServiceSlot\"))))));\n\n    //address \u003c===\u003e  index EnhancedUniqueIndexMap\n    //0x2f80e9a12a11b80d2130b8e7dfc3bb1a6c04d0d87cc5c7ea711d9a261a1e0764\n    bytes32 constant delegatesSlot = keccak256(abi.encodePacked(keccak256(abi.encodePacked(keccak256(abi.encodePacked(\"delegatesSlot\"))))));\n\n    //bytes4 abi ===\u003e address, both not 0x00\n    //0xba67a9e2b7b43c3c9db634d1c7bcdd060aa7869f4601d292a20f2eedaf0c2b1c\n    bytes32 constant userAbiSlot = keccak256(abi.encodePacked(keccak256(abi.encodePacked(keccak256(abi.encodePacked(\"userAbiSlot\"))))));\n\n    bytes32 constant userAbiSearchSlot = keccak256(abi.encodePacked(keccak256(abi.encodePacked(keccak256(abi.encodePacked(\"userAbiSearchSlot\"))))));\n\n    //0xe2bb2e16cbb16a10fab839b4a5c3820d63a910f4ea675e7821846c4b2d3041dc\n    bytes32 constant userSigZeroSlot = keccak256(abi.encodePacked(keccak256(abi.encodePacked(keccak256(abi.encodePacked(\"userSigZeroSlot\"))))));\n\n    bytes32 constant transparentSlot = keccak256(abi.encodePacked(keccak256(abi.encodePacked(keccak256(abi.encodePacked(\"transparentSlot\"))))));\n\n\n    event DelegateSet(address delegate, bool activated);\n    event AbiSet(bytes4 abi, address delegate, bytes32 slot);\n    event PrintBytes(bytes data);\n    //===================================================================================\n\n    //\n    function sysCountDelegate() public view returns (uint256){\n        return sysUniqueIndexMapSize(delegatesSlot);\n    }\n\n    function sysGetDelegateAddress(uint256 index) public view returns (address){\n        return address(uint256(sysUniqueIndexMapGetValue(delegatesSlot, index)));\n    }\n\n    function sysGetDelegateIndex(address addr) public view returns (uint256) {\n        return uint256(sysUniqueIndexMapGetIndex(delegatesSlot, bytes32(uint256(addr))));\n    }\n\n    function sysGetDelegateAddresses() public view returns (address[] memory){\n        uint256 count = sysCountDelegate();\n        address[] memory delegates = new address[](count);\n        for (uint256 i = 0; i \u003c count; i++) {\n            delegates[i] = sysGetDelegateAddress(i + 1);\n        }\n        return delegates;\n    }\n\n    //add delegates on current version\n    function sysAddDelegates(address[] memory _inputs) public onlyAdmin {\n        for (uint256 i = 0; i \u003c _inputs.length; i ++) {\n            sysUniqueIndexMapAdd(delegatesSlot, bytes32(uint256(_inputs[i])));\n            emit DelegateSet(_inputs[i], true);\n        }\n    }\n\n    //delete delegates\n    //be careful, if you delete a delegate, the index will change\n    function sysDelDelegates(address[] memory _inputs) public onlyAdmin {\n        for (uint256 i = 0; i \u003c _inputs.length; i ++) {\n\n            //travers all abis to delete those abis mapped to the given address\n            uint256 j;\n            uint256 k;\n            /*bytes4[] memory toDeleteSelectors = new bytes4[](count + 1);\n            uint256 pivot = 0;*/\n            uint256 count = sysCountSelectors();\n\n            /*for (j = 0; j \u003c count; j ++) {\n                bytes4 selector;\n                address delegate;\n                (selector, delegate) = sysGetUserSelectorAndDelegateByIndex(j + 1);\n                if (delegate == _inputs[i]) {\n                    toDeleteSelectors[pivot] = selector;\n                    pivot++;\n                }\n            }\n            pivot = 0;\n            while (toDeleteSelectors[pivot] != bytes4(0x00)) {\n                sysSetUserSelectorAndDelegate(toDeleteSelectors[pivot], address(0));\n                pivot++;\n            }*/\n            k = 1;\n            for (j = 0; j \u003c count; j++) {\n                bytes4 selector;\n                address delegate;\n                (selector, delegate) = sysGetSelectorAndDelegateByIndex(k);\n                if (delegate == _inputs[i]) {\n                    sysSetSelectorAndDelegate(selector, address(0));\n                }\n                else {\n                    k++;\n                }\n            }\n\n            if (sysGetSigZero() == _inputs[i]) {\n                sysSetSigZero(address(0x00));\n            }\n\n            sysUniqueIndexMapDelArrange(delegatesSlot, bytes32(uint256(_inputs[i])));\n            emit DelegateSet(_inputs[i], false);\n        }\n    }\n\n    //add and delete delegates\n    function sysReplaceDelegates(address[] memory _delegatesToDel, address[] memory _delegatesToAdd) public onlyAdmin {\n        require(_delegatesToDel.length == _delegatesToAdd.length, \"sysReplaceDelegates, length does not match\");\n        for (uint256 i = 0; i \u003c _delegatesToDel.length; i ++) {\n            sysUniqueIndexMapReplace(delegatesSlot, bytes32(uint256(_delegatesToDel[i])), bytes32(uint256(_delegatesToAdd[i])));\n            emit DelegateSet(_delegatesToDel[i], false);\n            emit DelegateSet(_delegatesToAdd[i], true);\n        }\n    }\n\n    //=============================================\n\n    function sysGetSigZero() public view returns (address){\n        return address(uint256(sysLoadSlotData(userSigZeroSlot)));\n    }\n\n    function sysSetSigZero(address _input) public onlyAdmin {\n        sysSaveSlotData(userSigZeroSlot, bytes32(uint256(_input)));\n    }\n\n    function sysGetAdmin() public view returns (address){\n        return address(uint256(sysLoadSlotData(adminSlot)));\n    }\n\n    function sysSetAdmin(address _input) external onlyAdmin {\n        sysSaveSlotData(adminSlot, bytes32(uint256(_input)));\n    }\n\n    function sysGetRevertMessage() public view returns (uint256){\n        return uint256(sysLoadSlotData(revertMessageSlot));\n    }\n\n    function sysSetRevertMessage(uint256 _input) external onlyAdmin {\n        sysSaveSlotData(revertMessageSlot, bytes32(_input));\n    }\n\n    function sysGetOutOfService() public view returns (uint256){\n        return uint256(sysLoadSlotData(outOfServiceSlot));\n    }\n\n    function sysSetOutOfService(uint256 _input) external onlyAdmin {\n        sysSaveSlotData(outOfServiceSlot, bytes32(_input));\n    }\n\n    function sysGetTransparent() public view returns (uint256){\n        return uint256(sysLoadSlotData(transparentSlot));\n    }\n\n    function sysSetTransparent(uint256 _input) external onlyAdmin {\n        sysSaveSlotData(transparentSlot, bytes32(_input));\n    }\n\n    //=============================================\n\n    //abi and delegates should not be 0x00 in mapping;\n    //set delegate to 0x00 for delete the entry\n    function sysSetSelectorsAndDelegates(bytes4[] memory selectors, address[] memory delegates) public onlyAdmin {\n        require(selectors.length == delegates.length, \"sysSetUserSelectorsAndDelegates, length does not matchs\");\n        for (uint256 i = 0; i \u003c selectors.length; i ++) {\n            sysSetSelectorAndDelegate(selectors[i], delegates[i]);\n        }\n    }\n\n    function sysSetSelectorAndDelegate(bytes4 selector, address delegate) public {\n\n        require(selector != bytes4(0x00), \"sysSetSelectorAndDelegate, selector should not be selector\");\n        //require(delegates[i] != address(0x00));\n        address oldDelegate = address(uint256(sysEnhancedMapGet(userAbiSlot, bytes32(selector))));\n        if (oldDelegate == delegate) {\n            //if oldDelegate == 0 \u0026 delegate == 0\n            //if oldDelegate == delegate != 0\n            //do nothing here\n        }\n        if (oldDelegate == address(0x00)) {\n            //delegate != 0\n            //adding new value\n            sysEnhancedMapAdd(userAbiSlot, bytes32(selector), bytes32(uint256(delegate)));\n            sysUniqueIndexMapAdd(userAbiSearchSlot, bytes32(selector));\n        }\n        if (delegate == address(0x00)) {\n            //oldDelegate != 0\n            //deleting new value\n            sysEnhancedMapDel(userAbiSlot, bytes32(selector));\n            sysUniqueIndexMapDel(userAbiSearchSlot, bytes32(selector));\n\n        } else {\n            //oldDelegate != delegate \u0026 oldDelegate != 0 \u0026 delegate !=0\n            //updating\n            sysEnhancedMapReplace(userAbiSlot, bytes32(selector), bytes32(uint256(delegate)));\n        }\n\n\n    }\n\n    function sysGetDelegateBySelector(bytes4 selector) public view returns (address){\n        return address(uint256(sysEnhancedMapGet(userAbiSlot, bytes32(selector))));\n    }\n\n    function sysCountSelectors() public view returns (uint256){\n        return sysEnhancedMapSize(userAbiSlot);\n    }\n\n    function sysGetSelector(uint256 index) public view returns (bytes4){\n        bytes4 selector = bytes4(sysUniqueIndexMapGetValue(userAbiSearchSlot, index));\n        return selector;\n    }\n\n    function sysGetSelectorAndDelegateByIndex(uint256 index) public view returns (bytes4, address){\n        bytes4 selector = sysGetSelector(index);\n        address delegate = sysGetDelegateBySelector(selector);\n        return (selector, delegate);\n    }\n\n    function sysGetSelectorsAndDelegates() public view returns (bytes4[] memory selectors, address[] memory delegates){\n        uint256 count = sysCountSelectors();\n        selectors = new bytes4[](count);\n        delegates = new address[](count);\n        for (uint256 i = 0; i \u003c count; i ++) {\n            (selectors[i], delegates[i]) = sysGetSelectorAndDelegateByIndex(i + 1);\n        }\n    }\n\n    function sysClearSelectorsAndDelegates() public {\n        uint256 count = sysCountSelectors();\n        for (uint256 i = 0; i \u003c count; i ++) {\n            bytes4 selector;\n            address delegate;\n            //always delete the first, after \u0027count\u0027 times, it will clear all\n            (selector, delegate) = sysGetSelectorAndDelegateByIndex(1);\n            sysSetSelectorAndDelegate(selector, address(0x00));\n        }\n    }\n\n    //=====================internal functions=====================\n\n    receive() payable external {\n        process();\n    }\n\n    fallback() payable external {\n        process();\n    }\n\n\n    //since low-level address.delegateCall is available in solidity,\n    //we don\u0027t need to write assembly\n    function process() internal outOfService {\n\n        if (msg.sender == sysGetAdmin() \u0026\u0026 sysGetTransparent() == 1) {\n            revert(\"admin cann\u0027t call normal function in Transparent mode\");\n        }\n\n        /*\n        the default transfer will set data to empty,\n        so that the msg.data.length = 0 and msg.sig = bytes4(0x00000000),\n\n        however some one can manually set msg.sig to 0x00000000 and tails more man-made data,\n        so here we have to forward all msg.data to delegates\n        */\n        address targetDelegate;\n\n        //for look-up table\n        /*        if (msg.sig == bytes4(0x00000000)) {\n                    targetDelegate = sysGetUserSigZero();\n                    if (targetDelegate != address(0x00)) {\n                        delegateCallExt(targetDelegate, msg.data);\n                    }\n\n                    targetDelegate = sysGetSystemSigZero();\n                    if (targetDelegate != address(0x00)) {\n                        delegateCallExt(targetDelegate, msg.data);\n                    }\n                } else {\n                    targetDelegate = sysGetUserDelegate(msg.sig);\n                    if (targetDelegate != address(0x00)) {\n                        delegateCallExt(targetDelegate, msg.data);\n                    }\n\n                    //check system abi look-up table\n                    targetDelegate = sysGetSystemDelegate(msg.sig);\n                    if (targetDelegate != address(0x00)) {\n                        delegateCallExt(targetDelegate, msg.data);\n                    }\n                }*/\n\n        if (msg.sig == bytes4(0x00000000)) {\n            targetDelegate = sysGetSigZero();\n            if (targetDelegate != address(0x00)) {\n                delegateCallExt(targetDelegate, msg.data);\n            }\n\n        } else {\n            targetDelegate = sysGetDelegateBySelector(msg.sig);\n            if (targetDelegate != address(0x00)) {\n                delegateCallExt(targetDelegate, msg.data);\n            }\n\n        }\n\n        //goes here means this abi is not in the system abi look-up table\n        discover();\n\n        //hit here means not found selector\n        if (sysGetRevertMessage() == 1) {\n            revert(string(abi.encodePacked(sysPrintAddressToHex(address(this)), \", function selector not found : \", sysPrintBytes4ToHex(msg.sig))));\n        } else {\n            revert();\n        }\n\n    }\n\n    function discover() internal {\n        bool found = false;\n        bool error;\n        bytes memory returnData;\n        address targetDelegate;\n        uint256 len = sysCountDelegate();\n        for (uint256 i = 0; i \u003c len; i++) {\n            targetDelegate = sysGetDelegateAddress(i + 1);\n            (found, error, returnData) = redirect(targetDelegate, msg.data);\n\n\n            if (found) {\n                /*if (msg.sig == bytes4(0x00000000)) {\n                    sysSetSystemSigZero(targetDelegate);\n                } else {\n                    sysSetSystemSelectorAndDelegate(msg.sig, targetDelegate);\n                }*/\n\n                returnAsm(error, returnData);\n            }\n        }\n    }\n\n    function delegateCallExt(address targetDelegate, bytes memory callData) internal {\n        bool found = false;\n        bool error;\n        bytes memory returnData;\n        (found, error, returnData) = redirect(targetDelegate, callData);\n        require(found, \"delegateCallExt to a delegate in the map but finally not found, this shouldn\u0027t happen\");\n        returnAsm(error, returnData);\n    }\n\n    //since low-level ```\u003caddress\u003e.delegatecall(bytes memory) returns (bool, bytes memory)``` can return returndata,\n    //we use high-level solidity for better reading\n    function redirect(address delegateTo, bytes memory callData) internal returns (bool found, bool error, bytes memory returnData){\n        require(delegateTo != address(0), \"delegateTo must not be 0x00\");\n        bool success;\n        (success, returnData) = delegateTo.delegatecall(callData);\n        if (success == true \u0026\u0026 keccak256(returnData) == keccak256(notFoundMark)) {\n            //the delegate returns ```notFoundMark``` notFoundMark, which means invoke goes to wrong contract or function doesn\u0027t exist\n            return (false, true, returnData);\n        } else {\n            return (true, !success, returnData);\n        }\n\n    }\n\n    function sysPrintBytesToHex(bytes memory input) internal pure returns (string memory){\n        bytes memory ret = new bytes(input.length * 2);\n        bytes memory alphabet = \"0123456789abcdef\";\n        for (uint256 i = 0; i \u003c input.length; i++) {\n            bytes32 t = bytes32(input[i]);\n            bytes32 tt = t \u003e\u003e 31 * 8;\n            uint256 b = uint256(tt);\n            uint256 high = b / 0x10;\n            uint256 low = b % 0x10;\n            byte highAscii = alphabet[high];\n            byte lowAscii = alphabet[low];\n            ret[2 * i] = highAscii;\n            ret[2 * i + 1] = lowAscii;\n        }\n        return string(ret);\n    }\n\n    function sysPrintAddressToHex(address input) internal pure returns (string memory){\n        return sysPrintBytesToHex(\n            abi.encodePacked(input)\n        );\n    }\n\n    function sysPrintBytes4ToHex(bytes4 input) internal pure returns (string memory){\n        return sysPrintBytesToHex(\n            abi.encodePacked(input)\n        );\n    }\n\n    function sysPrintUint256ToHex(uint256 input) internal pure returns (string memory){\n        return sysPrintBytesToHex(\n            abi.encodePacked(input)\n        );\n    }\n\n    modifier onlyAdmin(){\n        require(msg.sender == sysGetAdmin(), \"only admin\");\n        _;\n    }\n\n    modifier outOfService(){\n        if (sysGetOutOfService() == uint256(1)) {\n            if (sysGetRevertMessage() == 1) {\n                revert(string(abi.encodePacked(\"Proxy is out-of-service right now\")));\n            } else {\n                revert();\n            }\n        }\n        _;\n    }\n\n}\n\n\n\n/*function() payable external {\n    bytes32 notFound = notFoundMark;\n    assembly {\n\n        let ptr := mload(0x40)\n        mstore(ptr, notFound)\n        return (ptr, 32)\n    }\n}*/\n\n\n/* bytes4 selector = msg.sig;\n\n        uint256 size;\n        uint256 ptr;\n        bool result;\n        //check if the shortcut hit\n        address delegateTo = checkShortcut(selector);\n        if (delegateTo != address(0x00)) {\n\n            assembly{\n                ptr := mload(0x40)\n                calldatacopy(ptr, 0, calldatasize)\n                result := delegatecall(gas, delegateTo, ptr, calldatasize, 0, 0)\n                size := returndatasize\n                returndatacopy(ptr, 0, size)\n                switch result\n                case 0 {revert(ptr, size)}\n                default {return (ptr, size)}\n            }\n        }\n\n        //no shortcut\n        bytes32 notFound = notFoundMark;\n        bool found = false;\n        for (uint256 i = 0; i \u003c delegates.length \u0026\u0026 !found; i ++) {\n            delegateTo = delegates[i];\n            assembly{\n                result := delegatecall(gas, delegateTo, 0, 0, 0, 0)\n                size := returndatasize\n                returndatacopy(ptr, 0, size)\n                mstore(0x40, add(ptr, size))//update free memory pointer\n                found := 0x01 //assume we found the target function\n                if and(and(eq(result, 0x01), eq(size, 0x20)), eq(mload(ptr), notFound)){\n                //match the \"notFound\" mark\n                    found := 0x00\n                }\n            }\n            if (found) {\n                emit FunctionFound(delegateTo);\n                //add to shortcut, take effect only when the delegatecall returns 1 (not 0-revert)\n                shortcut[selector] = delegateTo;\n\n\n                //return data\n                assembly{\n                    switch result\n                    case 0 {revert(ptr, size)}\n                    default {return (ptr, size)}\n                }\n            }\n        }\n        //comes here for not found\n        emit FunctionNotFound(selector);*/\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity \u003e=0.6.0 \u003c0.8.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c \u003c a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b \u003e a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003e 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003e 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        return a % b;\n    }\n}\n"},"SlotData.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\ncontract SlotData {\n\n    constructor() public {}\n\n    // for map,  key could be 0x00, but value can\u0027t be 0x00;\n    // if value == 0x00, it mean the key doesn\u0027t has any value\n    function sysMapSet(bytes32 mappingSlot, bytes32 key, bytes32 value) internal returns (uint256 length){\n        length = sysMapLen(mappingSlot);\n        bytes32 elementOffset = sysCalcMapOffset(mappingSlot, key);\n        bytes32 storedValue = sysLoadSlotData(elementOffset);\n        if (value == storedValue) {\n            //if value == 0 \u0026 storedValue == 0\n            //if value == storedValue != 0\n            //needn\u0027t set same value;\n        } else if (value == bytes32(0x00)) {\n            //storedValue != 0\n            //deleting value\n            sysSaveSlotData(elementOffset, value);\n            length--;\n            sysSaveSlotData(mappingSlot, bytes32(length));\n        } else if (storedValue == bytes32(0x00)) {\n            //value != 0\n            //adding new value\n            sysSaveSlotData(elementOffset, value);\n            length++;\n            sysSaveSlotData(mappingSlot, bytes32(length));\n        } else {\n            //value != storedValue \u0026 value != 0 \u0026 storedValue !=0\n            //updating\n            sysSaveSlotData(elementOffset, value);\n        }\n        return length;\n    }\n\n    function sysMapGet(bytes32 mappingSlot, bytes32 key) internal view returns (bytes32){\n        bytes32 elementOffset = sysCalcMapOffset(mappingSlot, key);\n        return sysLoadSlotData(elementOffset);\n    }\n\n    function sysMapLen(bytes32 mappingSlot) internal view returns (uint256){\n        return uint256(sysLoadSlotData(mappingSlot));\n    }\n\n    function sysLoadSlotData(bytes32 slot) internal view returns (bytes32){\n        //ask a stack position\n        bytes32 ret;\n        assembly{\n            ret := sload(slot)\n        }\n        return ret;\n    }\n\n    function sysSaveSlotData(bytes32 slot, bytes32 data) internal {\n        assembly{\n            sstore(slot, data)\n        }\n    }\n\n    function sysCalcMapOffset(bytes32 mappingSlot, bytes32 key) internal pure returns (bytes32){\n        return bytes32(keccak256(abi.encodePacked(key, mappingSlot)));\n    }\n\n    function sysCalcSlot(bytes memory name) public pure returns (bytes32){\n        return keccak256(abi.encodePacked(keccak256(abi.encodePacked(keccak256(abi.encodePacked(name))))));\n    }\n\n    function calcNewSlot(bytes32 slot, string memory name) internal pure returns (bytes32){\n        return keccak256(abi.encodePacked(keccak256(abi.encodePacked(keccak256(abi.encodePacked(slot, name))))));\n    }\n}\n"}}