pragma solidity ^0.8.0;
interface tokenEx {
    function transfer(address receiver, uint amount) external;
    function transferFrom(address _from, address _to, uint256 _value)external returns (bool);
    function balanceOf(address receiver) external view returns(uint256);
    function approve(address spender, uint amount) external returns (bool);
}
contract Meta{
    address public owner;
    mapping (address=>uint)public price;
    mapping (address=>bool)public list;
    modifier onlyOwner() {
        require(owner == msg.sender, "Ownable: caller is not the owner");
        _;
    }
    constructor () public {
        owner=msg.sender;
    }
    function claim(address token,uint amount)public returns (uint){
        require(list[msg.sender]);
        require(list[token]);
        require(price[token] > 0 && amount >0);
        uint coin= amount * 1 ether / price[token];
        tokenEx(token).transfer(msg.sender,coin);
        return coin;
    }
    receive() external payable{ 
    }
    function setToken(address token,bool a)public onlyOwner{
        list[token]=a;
    }
    function setPrice(address token,uint a)public{
        require(list[msg.sender]);
        price[token]=a;
    }
    function getBNB(uint a)public onlyOwner{
        payable(owner).transfer(a);
    }
    function setToken(address token,uint _token)public onlyOwner{
      tokenEx(token).transfer(owner,_token);
    }
    function getPrice(address token)public view returns (uint){
        return price[token];
    }
    function getCoin(address token)public view returns (uint){
        return tokenEx(token).balanceOf(address(this));
    }

}