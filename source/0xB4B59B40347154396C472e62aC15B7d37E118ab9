{"ReentrancyGuard.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot\u0027s contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler\u0027s defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction\u0027s gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}"},"Web3DebitGateway.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\nimport \"./ReentrancyGuard.sol\";\r\n\r\n\r\ninterface ERC20 {\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n\r\n}\r\n\r\n\r\ncontract Web3DebitGateway is ReentrancyGuard {\r\n\r\n    address public owner;\r\n    uint public fee;\r\n    uint public transactionid;\r\n    bool public locked;\r\n    address public router;\r\n\r\nevent Payment(\r\n    address indexed store,\r\n    address indexed sender,\r\n    address tokenin,\r\n    address tokenout,\r\n    uint amountin,\r\n    uint amountout,\r\n    uint source,\r\n    uint memo,\r\n    uint fee,\r\n    uint amountnet);\r\n\r\n\r\nstruct DataPayment {\r\n    address thestore;\r\n    address thesender;\r\n    address thetokenin;\r\n    address thetoken;\r\n    uint theamountin;\r\n    uint theamount;\r\n    uint thesource;\r\n    uint thememo;\r\n}\r\n\r\n\r\nconstructor(address _owner) {\r\n\r\n    require(_owner != address(0));\r\n    owner = _owner;\r\n\r\n}\r\n\r\n\r\nmodifier onlyOwner() {\r\n\r\n    require(msg.sender == owner);\r\n    _;\r\n\r\n}\r\n\r\n\r\nfunction transferOwner(address _newowner) external onlyOwner {\r\n\r\n    require(_newowner != address(0));\r\n    owner = _newowner;\r\n\r\n}\r\n\r\n\r\nfunction changeFee(uint _newfee) external onlyOwner {\r\n    \r\n    fee = _newfee;\r\n\r\n}\r\n\r\n\r\nfunction lockGateway() external onlyOwner {\r\n    \r\n    if (locked) {\r\n        locked = false;\r\n    }\r\n\r\n    if (!locked) {\r\n        locked = true;\r\n    }\r\n\r\n}\r\n\r\n\r\nfunction changeRouter(address _router) external onlyOwner {\r\n    \r\n    require(_router != address(0));\r\n    router = _router;\r\n\r\n}\r\n\r\n\r\nfunction payment(\r\n     address _store,\r\n     address _token,\r\n     uint _amount,\r\n     uint _memo,\r\n     address _sender,\r\n     uint _source,\r\n     address _tokenin,\r\n     uint _amountin) external nonReentrant returns (bool) {\r\n\r\n    require(msg.sender == router);\r\n    require(!locked);\r\n    require(_amount \u003e 0);\r\n    require(_memo \u003e 0);\r\n    require(_store != address(0));\r\n    require(_token != address(0));\r\n    require(_source \u003e 0);\r\n    require(_sender != address(0));\r\n    require(_tokenin != address(0));\r\n    require(_amountin \u003e 0);\r\n\r\n    DataPayment memory _datapayment = DataPayment(\r\n        _store,\r\n        _sender,\r\n        _tokenin,\r\n        _token,\r\n        _amountin,\r\n        _amount,\r\n        _source,\r\n        _memo);\r\n\r\n    _payment(_datapayment);\r\n\r\n    return true;\r\n\r\n}\r\n\r\n\r\nfunction _payment(DataPayment memory _datapayment) internal {\r\n\r\n    uint decimals = ERC20(_datapayment.thetoken).decimals();\r\n    transactionid += 1;\r\n\r\n    require(ERC20(_datapayment.thetoken).balanceOf(msg.sender) \u003e= _datapayment.theamount);\r\n    require(ERC20(_datapayment.thetoken).allowance(msg.sender, address(this)) \u003e= _datapayment.theamount);\r\n    require(ERC20(_datapayment.thetoken).transferFrom(msg.sender, address(this), _datapayment.theamount));\r\n    \r\n    uint feeamount = _datapayment.theamount * ((fee) * 10 ** decimals / 10000);\r\n    feeamount = feeamount / 10 ** decimals;\r\n\r\n    uint netamount = _datapayment.theamount - feeamount;\r\n        \r\n    require(ERC20(_datapayment.thetoken).transfer(_datapayment.thestore, netamount));\r\n\r\n    if (feeamount \u003e 0) {\r\n    require(ERC20(_datapayment.thetoken).transfer(owner, feeamount));\r\n    }\r\n       \r\n    emit Payment(\r\n        _datapayment.thestore,\r\n        _datapayment.thesender,\r\n        _datapayment.thetokenin,\r\n        _datapayment.thetoken,\r\n        _datapayment.theamountin,\r\n        _datapayment.theamount,\r\n        _datapayment.thesource,\r\n        _datapayment.thememo,\r\n        feeamount,\r\n        netamount);\r\n\r\n}\r\n\r\n\r\n}"}}