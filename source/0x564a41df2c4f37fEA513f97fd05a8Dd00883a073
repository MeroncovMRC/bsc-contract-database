{"SafeMath.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\r\n\r\n/**\r\n * @Author Vron\r\n */\r\n\r\npragma solidity \u003e=0.7.0 \u003c0.9.0;\r\n\r\n/**\r\n * SafeMath\r\n * Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b \u003c= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n}"},"SafuBet2.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\r\n\r\n/**\r\n * @Author Vron\r\n */\r\n\r\npragma solidity \u003e=0.7.0 \u003c0.9.0;\r\nimport \"./SafeMath.sol\";\r\n\r\ninterface BUSD {\r\n    function balanceOf(address _address) external returns (uint256);\r\n\r\n    function transfer(address _address, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address _sender,\r\n        address recipient,\r\n        uint256 value\r\n    ) external returns (bool);\r\n}\r\n\r\ninterface Context{\r\n    function onlyOwner(address _address) external view;\r\n    function onlyAdmin(address _address) external view;\r\n    function isMarketCreationPaused(address _address) external view;\r\n    function isPlatformActive(address _address) external view;\r\n    function isBettingPaused(address _address) external view;\r\n    function isEventValidationPaused(address _address) external view;\r\n    function _calculateValidatorsNeeded(uint256 _value) external pure returns (uint256);\r\n    function getSystemRewardAddress() external view returns (address);\r\n    function getVCContractAddress() external view returns (address);\r\n    function isUsernameSet(address addr) external view;\r\n    function setUserBonusOnEvent(address user_address, uint256 event_id, uint256 amount) external;\r\n    function getUserBonusOnEvent(address user_address, uint256 event_id) external view returns (uint256);\r\n}\r\n\r\ninterface Point{\r\n    function deductValidationPoint(address validator_address) external;\r\n}\r\n\r\ncontract SafuBet {\r\n    // 0x7f78dd0cc6e097d55002cfbAD7c70E53f66d4159\r\n    using SafeMath for uint256;\r\n    // mapping maps event to its index in allActiveEvent\r\n    mapping(uint256 =\u003e uint256) private event_index;\r\n    // [eventID][MSG.SENDER] = true or false determines if user betted on an event\r\n    mapping(uint256 =\u003e mapping(address =\u003e bool)) private bets;\r\n    // [eventID] = true or false - determines if a BetEvent is still active\r\n    mapping(uint256 =\u003e bool) private activeEvents;\r\n    // maps an event to its record\r\n    mapping(uint256 =\u003e BetEvent) private events;\r\n    // maps an event and a bettor to bettors bets information [eventID][msg.sender]\r\n    mapping(uint256 =\u003e mapping(address =\u003e Betted)) private userBets;\r\n    // maps an address to the amount won on a particular event\r\n    mapping(uint256 =\u003e mapping(address =\u003e uint256)) private _amountWonByUserOnEvent;\r\n    // maps bet event occurrence to the number of users who selected it\r\n    mapping(uint256 =\u003e mapping(Occurences =\u003e address[]))\r\n        private eventBetOccurenceCount;\r\n    // maps bet event occurence and the amount betted on it\r\n    mapping(uint256 =\u003e mapping(Occurences =\u003e uint256))\r\n        private eventBetOccurenceAmount;\r\n    // maps an event to the occurence that won after validation\r\n    mapping(uint256 =\u003e Occurences) private occuredOccurrence;\r\n    // maps a user to all their bets\r\n    mapping(address =\u003e uint256[]) private userBetHistory;\r\n    // maps a user to the events created by the user\r\n    mapping(address=\u003euint256[]) private userEventHistory;\r\n    // maps a validator to an event - used in checking if a validator validated an event\r\n    mapping(address =\u003e mapping(uint256 =\u003e bool))\r\n        private validatorValidatedEvent;\r\n    // maps a validator to the occurrence chosen\r\n    mapping(uint256 =\u003e mapping(address =\u003e mapping(Occurences =\u003e bool)))\r\n        private selectedValidationOccurrence;\r\n    // maps an event and its occurence to validators that chose it\r\n    mapping(uint256 =\u003e mapping(Occurences =\u003e address[]))\r\n        private eventOccurenceValidators;\r\n    // maps an event and a user to know if user has reclaimed the event\u0027s wager\r\n    mapping(uint256 =\u003e mapping(address =\u003e bool)) private reclaimedBetWager;\r\n    // maps an event to the amount lost in bet by bettors who choose the wrong event outcome\r\n    mapping(uint256 =\u003e uint256) private amountLostInBet;\r\n    // maps a bet event to validators who validated it\r\n    mapping(uint256 =\u003e address[]) private eventValidators;\r\n    // maps a validator to all the events they validated\r\n    mapping (address =\u003e uint256[]) private validationHistory;\r\n    // maps an event and a bettor to whether the reward has been claimed\r\n    mapping(uint256 =\u003e mapping(address =\u003e bool)) private claimedReward;\r\n    // maps an event and a validator to whether the validator has claimed reward\r\n    mapping (uint256 =\u003e mapping (address =\u003e bool)) private validatorClaimedReward;\r\n    // maps an a validator to their validator reward on an event [ADDR][EVENT ID] = _VALUE\r\n    mapping (address=\u003emapping(uint256=\u003euint256)) private validatorRewardOnEvent;\r\n    // maps an event to the divs for validators, system and all event bettors\r\n    mapping(uint256 =\u003e Distribution) private divs;\r\n    // maps user to total amount wagered\r\n    mapping(address =\u003e uint256) private _totalAmountWagered;\r\n    // maps user to total winnings\r\n    mapping(address =\u003e uint256) private _totalWinnings;\r\n    mapping(address=\u003emapping(uint256=\u003euint256)) private creator_reward;\r\n    // maps a user to their active user status\r\n    mapping(address =\u003e bool) private _isActiveUser;\r\n    // maps an event to whether the crumbs has been claimed\r\n    mapping(uint256 =\u003e bool) private _eventCrumbClaimed;\r\n    // map holds each event tax\r\n    mapping(uint256=\u003euint256) private eventTax;\r\n    // maps user to event tax\r\n    mapping(address=\u003emapping(uint256=\u003euint256)) private userEventTax;\r\n\r\n    // event is emitted when a validator validates an event\r\n    event ValidateEvent(\r\n        uint256 indexed eventID,\r\n        Occurences occurence,\r\n        address validator_address\r\n    );\r\n\r\n    ////////////////////////////////////\r\n\r\n    // event emitted once event is created\r\n    event CreateEvent(\r\n        uint256 indexed event_id,\r\n        Category category,\r\n        string eventName,\r\n        uint256 pool_size,\r\n        uint256 eventTime,\r\n        string eventOne,\r\n        string eventTwo,\r\n        address betCreator\r\n    );\r\n\r\n    // event emitted when a wager is made\r\n    event PlaceBet(\r\n        uint256 indexed event_id,\r\n        address bettor_address,\r\n        uint256 amount,\r\n        Occurences occured\r\n    );\r\n\r\n    // event emitted when a user claims bet reward/winnings\r\n    event Claim(address indexed user_address, uint256 _amount);\r\n\r\n    /**\r\n     * @dev WIN = 0, LOOSE = 1, LOOSE_OR_WIN = 2 and INVALID = 3\r\n     * On the client side, the user is only to see the follwoing\r\n     * {WIN}, {LOOSE}, {DRAW}\r\n     */\r\n    enum Occurences {\r\n        WIN,\r\n        LOOSE,\r\n        LOOSE_OR_WIN,\r\n        INVALID,\r\n        UNKNOWN\r\n    } //  possible bet outcome\r\n    enum Category {\r\n        SPORTS,\r\n        ESPORTS,\r\n        OTHERS\r\n    } // event categories\r\n\r\n    /**\r\n     * @dev stores Betevent information\r\n     *\r\n     * Requirement:\r\n     * event creator must be an admin\r\n     */\r\n    struct BetEvent {\r\n        uint256 eventID;\r\n        Category categories;\r\n        string eventName;\r\n        string description;\r\n        string url;\r\n        uint256 poolSize; // size of event pool\r\n        uint256 startTime; // time event will occur\r\n        uint256 endTime;\r\n        uint256 validationElapseTime; // time event validation elapses\r\n        string eventOne; // eventOne vs\r\n        string eventTwo; //eventTwo\r\n        bool validated; // false if event is not yet validated\r\n        uint256 validatorsNeeded;\r\n        Occurences occured;\r\n        uint256 bettorsCount;\r\n        uint256 noOfBettorsRewarded;\r\n        uint256 amountClaimed;\r\n        bool isBoosted;\r\n        uint256 boostTime;\r\n        uint256 boostAmount;\r\n        bool isCreatorBetted;\r\n        address betCreator;\r\n        string referral;\r\n    }\r\n\r\n    /**\r\n     * @dev stores user bet records\r\n     * bettor balance must be greater or equal to 0\r\n    */\r\n    struct Betted {\r\n        uint256 eventID;\r\n        address bettorAddress;\r\n        uint256 amount;\r\n        Occurences occurence;\r\n    }\r\n\r\n    /**\r\n     * @dev struct stores distribution divs\r\n     * for each event\r\n    */\r\n    struct Distribution {\r\n        uint256 validatorDiv;\r\n        uint256 bettorsDiv;\r\n        uint256 systemDiv;\r\n        uint256 creatorDiv;\r\n        uint256 VCDiv;\r\n        uint256 royalty;\r\n    }\r\n\r\n    BUSD private BUSD_token;\r\n    Context private context_address;\r\n    address private royalty = address(0);\r\n    Point private point_address;\r\n    BetEvent[] private _event_id;\r\n    uint256[] allActiveEvent; // list of active events\r\n    uint256[] private validatedEvent; // list of validated events\r\n    uint256[] private cancelledEvent; // list of cancelled events\r\n    address[] private activeUsersList; // list of active users\r\n    uint256 private totalAmountBetted; // total amount that has been betted on the platform\r\n    uint256 private totalAmountClaimed; // total amount claimed on the platform\r\n    uint256 private totalValidatorRewardClaimed; // total amount claimed by validators on the platform\r\n\r\n    /**\r\n     * @dev modifier ensures user can only select WIN, LOOSE or LOOSE_OR_WIN\r\n     * as the occurence they wager on or pick as occured occurence (for validators)\r\n    */\r\n    modifier isValidOccurence(Occurences chosen) {\r\n        require(\r\n            chosen == Occurences.WIN ||\r\n                chosen == Occurences.LOOSE ||\r\n                chosen == Occurences.LOOSE_OR_WIN,\r\n            \"IOS\"\r\n        );\r\n        _;\r\n    }\r\n    \r\n\r\n    /**\r\n     * @dev modifier check if a user has already claimed their bet reward\r\n    */\r\n    modifier hasClaimedReward(uint256 event_id) {\r\n        // check if user betted and validated event\r\n        if (bets[event_id][msg.sender] == true \u0026\u0026 validatorValidatedEvent[msg.sender][event_id] == true) {\r\n            // user betted and validated event - check if user has claimed both rewards\r\n            require(claimedReward[event_id][msg.sender] == false \u0026\u0026 validatorClaimedReward[event_id][msg.sender] == false, \"RC\");\r\n            _;\r\n        } else if(bets[event_id][msg.sender] == true){\r\n            require(claimedReward[event_id][msg.sender] == false, \"RC\");\r\n            _;\r\n        } else {\r\n            require(validatorClaimedReward[event_id][msg.sender] == false, \"RC\");\r\n            _;\r\n        }\r\n        \r\n    }\r\n\r\n    /**\r\n     * @dev modifier hinders validators from Validating\r\n     * events that do not have opposing bets.\r\n     */\r\n    modifier hasOpposingBets(uint256 event_id) {\r\n        if (\r\n            eventBetOccurenceCount[event_id][Occurences.WIN].length != 0 \u0026\u0026\r\n            eventBetOccurenceCount[event_id][Occurences.LOOSE].length != 0\r\n        ) {\r\n            _;\r\n        } else if (\r\n            eventBetOccurenceCount[event_id][Occurences.WIN].length != 0 \u0026\u0026\r\n            eventBetOccurenceCount[event_id][Occurences.LOOSE_OR_WIN].length !=\r\n            0\r\n        ) {\r\n            _;\r\n        } else if (\r\n            eventBetOccurenceCount[event_id][Occurences.LOOSE].length != 0 \u0026\u0026\r\n            eventBetOccurenceCount[event_id][Occurences.LOOSE_OR_WIN].length !=\r\n            0\r\n        ) {\r\n            _;\r\n        } else {\r\n            revert(\"VEWNOBNA\");\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     *@dev modifier restricts access of assigned subcatehory to addresses it was assigned to.\r\n    */\r\n\r\n    constructor(address busd_token, address _context, address _point_address) {\r\n        BUSD_token = BUSD(address(busd_token));\r\n        point_address = Point(address(_point_address));\r\n        context_address = Context(address(_context));\r\n    }\r\n\r\n    // create event\r\n    function createEvent(\r\n        Category _category,\r\n        string memory _name,\r\n        string memory _description,\r\n        string memory _url,\r\n        uint256 _time,\r\n        uint256 _endTime,\r\n        string memory _event1,\r\n        string memory _event2\r\n    ) external returns (bool) {\r\n        _createEvent(\r\n            _category,\r\n            _name,\r\n            _description,\r\n            _url,\r\n            _time,\r\n            _endTime,\r\n            _event1,\r\n            _event2,\r\n            msg.sender\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    // function creates betting event\r\n    function _createEvent(\r\n        Category _category,\r\n        string memory _name,\r\n        string memory _description,\r\n        string memory _url,\r\n        uint256 _time,\r\n        uint256 _endTime,\r\n        string memory _event1,\r\n        string memory _event2,\r\n        address _creator\r\n    ) private  {\r\n        context_address.isMarketCreationPaused(_creator);\r\n        context_address.isPlatformActive(_creator);\r\n        context_address.isUsernameSet(_creator);\r\n        uint256 _elapseTime = 48 hours;\r\n        // ensure eventTime is greater current timestamp\r\n        require(\r\n            _time \u003e currentTime(),\r\n            \"IT1\"\r\n        );\r\n        require(_endTime \u003e currentTime() \u0026\u0026 _endTime \u003e _time, \"IT2\");\r\n        string memory ref = \"\";\r\n        events[_event_id.length] = BetEvent(\r\n            _event_id.length,\r\n            _category,\r\n            _name,\r\n            _description,\r\n            _url,\r\n            0,\r\n            _time,\r\n            _endTime,\r\n            _endTime + _elapseTime,\r\n            _event1,\r\n            _event2,\r\n            false,\r\n            context_address._calculateValidatorsNeeded(0),\r\n            Occurences.UNKNOWN,\r\n            0,\r\n            0,\r\n            0,\r\n            false,\r\n            0,\r\n            0,\r\n            false,\r\n            _creator,\r\n            ref\r\n        ); // create event\r\n        activeEvents[_event_id.length] = true; // set event as active\r\n        allActiveEvent.push(_event_id.length); // add event to active event list\r\n        event_index[_event_id.length] = allActiveEvent.length - 1;\r\n        userEventHistory[_creator].push(_event_id.length); // add event to user event history\r\n        _event_id.push(events[_event_id.length]); // increment number of events created\r\n        // check if address is already an active user\r\n        incrementNoOfActiveUsers(_creator);\r\n        \r\n        emit CreateEvent(\r\n            _event_id.length - 1,\r\n            _category,\r\n            _name,\r\n            0,\r\n            _time,\r\n            _event1,\r\n            _event2,\r\n            _creator\r\n        );\r\n    }\r\n\r\n    // function places bet\r\n    function placeBet(\r\n        uint256[] memory event_id,\r\n        uint256[] memory _amount,\r\n        Occurences[] memory _occured\r\n    ) external returns (bool) {\r\n        _placeBet(event_id, _amount, _occured, msg.sender);\r\n        return true;\r\n    }\r\n\r\n    // function places a bet\r\n    function _placeBet(\r\n        uint256[] memory event_id,\r\n        uint256[] memory _amount,\r\n        Occurences[] memory _occurred,\r\n        address _bettor\r\n    ) private returns (bool) {\r\n        context_address.isPlatformActive(_bettor);\r\n        context_address.isBettingPaused(_bettor);\r\n        context_address.isUsernameSet(_bettor);\r\n        // check if event list, _amount and occurrence are equal\r\n        require(event_id.length == _amount.length \u0026\u0026 event_id.length == _occurred.length, \"LE\");\r\n       \r\n            // check bal\r\n            require(\r\n                BUSD_token.balanceOf(_bettor) \u003e= _amount[0],\r\n                \"IB\"\r\n            );\r\n            // ensure bet amount is not 0\r\n            require(_amount[0] \u003e 0, \"AMBGT0\");\r\n            // check if bet event date has passed\r\n            require(\r\n                events[event_id[0]].startTime \u003e= currentTime(),\r\n                \"BNA\"\r\n            );\r\n            // check if event exist and is active\r\n            require(\r\n                activeEvents[event_id[0]] == true,\r\n                \"ENA\"\r\n            );\r\n            // check if event creator already wagered on event\r\n            require(events[event_id[0]].isCreatorBetted == true || _bettor == events[event_id[0]].betCreator, \"ONW\");\r\n       \r\n             // check if address is already an active user\r\n            incrementNoOfActiveUsers(_bettor);\r\n        for(uint i=0; i\u003cevent_id.length; i++){\r\n            BetEvent storage newEvent = events[event_id[i]]; // get event details\r\n            // check if bettor is event creator\r\n            if(_bettor == events[event_id[i]].betCreator \u0026\u0026 events[event_id[i]].isCreatorBetted == false){\r\n                newEvent.isCreatorBetted = true;  // mark event as wagered by creator\r\n            }\r\n            // check if user already Betted - increase betted amount on previous bet\r\n            if (bets[event_id[i]][_bettor] == true) {\r\n                // check if user current bet occurrence and old one is same\r\n                require(userBets[event_id[i]][_bettor].occurence == _occurred[i], \"CAONA\");\r\n                // user already betted on event - increase stake on already placed bet\r\n                BUSD_token.transferFrom(_bettor, address(this), _amount[i]);\r\n                userBets[event_id[i]][_bettor].amount = userBets[event_id[i]][\r\n                    _bettor\r\n                ].amount.add(_amount[i]);\r\n                eventBetOccurenceAmount[event_id[i]][\r\n                    _occurred[i]\r\n                ] = eventBetOccurenceAmount[event_id[i]][_occurred[i]].add(_amount[i]); // increment the amount betted on the occurence\r\n                newEvent.poolSize = newEvent.poolSize.add(_amount[i]); // update pool amount\r\n                newEvent.validatorsNeeded = context_address._calculateValidatorsNeeded(newEvent.poolSize); // update no of validators needed\r\n                _incrementTotalAmountBetted(_amount[i]); // increment amount betted on platform\r\n                _totalAmountWagered[_bettor] = _totalAmountWagered[_bettor].add(_amount[i]);  // increment total amount wagered by user\r\n                emit PlaceBet(event_id[i], _bettor, _amount[i], _occurred[i]);\r\n            }else{\r\n                // user first BET\r\n                // deduct tax\r\n                _amount[i] = (_amount[i] * 98) / 100;\r\n                eventTax[event_id[i]] = (_amount[i] * 2) / 100;\r\n                userEventTax[_bettor][event_id[i]] = eventTax[event_id[i]];\r\n                BUSD_token.transferFrom(_bettor, address(this), _amount[i]);\r\n                addUserToOccurrenceBetCount(event_id[i], _occurred[i], _bettor); // increment number of users who betted on an event occurencece\r\n                _incrementEventOccurrenceBetAmount(event_id[i], _occurred[i], _amount[i]); // increment the amount betted on the occurence\r\n                bets[event_id[i]][_bettor] = true; // mark user as betted on event\r\n                userBets[event_id[i]][_bettor] = Betted(\r\n                    event_id[i],\r\n                    _bettor,\r\n                    _amount[i],\r\n                    _occurred[i]\r\n                ); // place user bet\r\n                newEvent.poolSize = newEvent.poolSize.add(_amount[i]); // update pool amount\r\n                newEvent.validatorsNeeded = context_address._calculateValidatorsNeeded(newEvent.poolSize); // update no of validators needed\r\n                newEvent.bettorsCount = newEvent.bettorsCount.add(1); // increment users that betted on the event\r\n                addEventToUserHistory(event_id[i]);\r\n                _incrementTotalAmountBetted(_amount[i]); // increment amount betted on platform\r\n                _totalAmountWagered[_bettor] = _totalAmountWagered[_bettor].add(_amount[i]);  // increment total amount wagered by user\r\n                emit PlaceBet(event_id[i], _bettor, _amount[i], _occurred[i]);\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // function gets users who selected a specific outcome for a betting event\r\n    function getOccurrenceBetCount(uint256 event_id, Occurences _occured)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return eventBetOccurenceCount[event_id][_occured].length;\r\n    }\r\n\r\n    // function adds a user to list of users who wagered on an event outcome\r\n    function addUserToOccurrenceBetCount(\r\n        uint256 event_id,\r\n        Occurences _occurred,\r\n        address _address\r\n    ) private {\r\n        eventBetOccurenceCount[event_id][_occurred].push(_address);\r\n    }\r\n\r\n    // function gets amount wagered on a specific event occurrence\r\n    function getEventOccurrenceBetAmount(uint256 event_id, Occurences _occurred)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return eventBetOccurenceAmount[event_id][_occurred];\r\n    }\r\n\r\n    // function increments amount wagered on an event outcome\r\n    function _incrementEventOccurrenceBetAmount(\r\n        uint256 event_id,\r\n        Occurences _occurred,\r\n        uint256 _amount\r\n    ) private {\r\n        eventBetOccurenceAmount[event_id][_occurred] = eventBetOccurenceAmount[\r\n            event_id\r\n        ][_occurred].add(_amount);\r\n    }\r\n\r\n    // functions sets event occured occurrence after validation\r\n    function setEventOccurredOccurrence(uint256 event_id, Occurences _occured)\r\n        private\r\n    {\r\n        occuredOccurrence[event_id] = _occured;\r\n    }\r\n\r\n    // function gets event  occurred occurrence after validation\r\n    function getEventOccurredOccurrence(uint256 event_id)\r\n        internal\r\n        view\r\n        returns (Occurences)\r\n    {\r\n        return occuredOccurrence[event_id];\r\n    }\r\n\r\n    // function remove event form active event list and puts it in validated event list\r\n    function removeFromActiveEvents(uint256 event_id) internal {\r\n        // check if event is active\r\n        require(activeEvents[event_id] == false, \"EF\");\r\n        allActiveEvent[event_index[event_id]] = allActiveEvent[\r\n            allActiveEvent.length - 1\r\n        ];\r\n        allActiveEvent.pop();\r\n    }\r\n\r\n    // function gets all active events\r\n    function getActiveEvents() external view returns (uint256[] memory) {\r\n        return allActiveEvent;\r\n    }\r\n\r\n    // function gets all validated event\r\n    function getValidatedEvents() external view returns (uint256[] memory) {\r\n        return validatedEvent;\r\n    }\r\n\r\n    // function get total betting event\r\n    function totalEvents() external view returns (uint256) {\r\n        return _event_id.length;\r\n    }\r\n\r\n    // function adds event to user bet history\r\n    function addEventToUserHistory(uint256 event_id) internal {\r\n        userBetHistory[msg.sender].push(event_id);\r\n    }\r\n\r\n    // function returns user bet histroy\r\n    function getUserBetHistory(address _address) external view returns (uint256[] memory) {\r\n        return userBetHistory[_address];\r\n    }\r\n\r\n    // function returns list of events created by a user\r\n    function getUserEventHistory(address _address) external view returns (uint256[] memory){\r\n        return userEventHistory[_address];\r\n    }\r\n\r\n    // function increments amount wagered on the platform\r\n    function _incrementTotalAmountBetted(uint256 _amount) internal {\r\n        totalAmountBetted = totalAmountBetted.add(_amount);\r\n    }\r\n\r\n    // function returns total amount wagered on the platform (total bet createed)\r\n    function totalBetCreated() external view returns (uint256){\r\n        return totalAmountBetted;\r\n    }\r\n    \r\n    /**\r\n     * @dev function gets the total amount wagered by a user\r\n     * REQUIREMENTS\r\n     * [_address] must be provided.\r\n    */\r\n    function getTotalUserWagerAmount(address _address) external view returns (uint256) {\r\n        return _totalAmountWagered[_address];\r\n    }\r\n    \r\n    /**\r\n     * @dev function gets a user\u0027s total winnings\r\n     * REQUIREMENTS\r\n     * [_address] must be provided and must be the address of the user whose total winnings is to be retrieved\r\n    */\r\n    function getUserTotalWinnings(address _address) external view returns (uint256) {\r\n        return _totalWinnings[_address];\r\n    }\r\n    /**\r\n     * @dev function sets user total winning\r\n    */\r\n    function setTotalWinnings(address _address, uint256 _value) internal {\r\n        _totalWinnings[_address] = _totalWinnings[_address].add(_value);\r\n    }\r\n\r\n    /**\r\n     *@dev function sets validator reward on an event\r\n    */\r\n    function setValidatorRewardOnEvent(address _address, uint256 event_id, uint256 _value)\r\n        private\r\n    {\r\n        validatorRewardOnEvent[_address][event_id] = _value;\r\n    }\r\n\r\n    /**\r\n     *@dev function sets \u0026 increments the total amount claimed by validators\r\n    */\r\n    function setTotalValidatorRewardClaimed(uint256 _value)\r\n        private\r\n    {\r\n        totalValidatorRewardClaimed = totalValidatorRewardClaimed.add(_value);\r\n    }\r\n\r\n    // function returns validator reward on an event\r\n    function getValidatorRewardOnEvent(address _address, uint256 event_id)\r\n        external view\r\n        returns (uint256)\r\n    {\r\n        return validatorRewardOnEvent[_address][event_id];\r\n    }\r\n\r\n    // function returns total amount claimed in within the validation sys\r\n    function getTotalValidatorRewardClaimed()\r\n        external view\r\n        returns (uint256)\r\n    {\r\n        return totalValidatorRewardClaimed;\r\n    }\r\n\r\n    /**\r\n    * @dev function gets the amount wagered by an address on an event\r\n    * REQUIREMENTS\r\n    * [_bettor] and [event_id] must be provided.\r\n    */\r\n    function getUserEventWager(uint256 event_id, address _bettor) external view returns (uint256) {\r\n        return userBets[event_id][_bettor].amount;\r\n    }\r\n\r\n    /**\r\n    * @dev function gets the amount won by an address on an event\r\n    */\r\n    function getUserEventWon(uint256 event_id, address _bettor) external view returns (uint256) {\r\n        return _amountWonByUserOnEvent[event_id][_bettor];\r\n    }\r\n\r\n    /**\r\n     * @dev function sets amount won by an address on an event\r\n    */\r\n    function setAmountWonByUserOnEvent(uint256 event_id, address _bettor, uint256 _value) internal{\r\n        _amountWonByUserOnEvent[event_id][_bettor] = _amountWonByUserOnEvent[event_id][_bettor].add(_value);\r\n    }\r\n\r\n    /**\r\n     * @dev function returns the information\r\n     * of a bet event and the number of bettors it has\r\n     */\r\n    function getEvent(uint256 index) external view returns (BetEvent memory) {\r\n        // check if bet event exist\r\n        require(events[index].startTime \u003e 0, \"EF\");\r\n        return events[index];\r\n    }\r\n\r\n   \r\n\r\n    /**\r\n     * @dev function is used to validate an event\r\n     * by validators.\r\n     *\r\n     * Requirements:\r\n     * validator must have 1000 or more points\r\n     * event validationElapseTime must not exceed block.timestamp.\r\n     * eventTime must exceed block.timestamp\r\n     */\r\n    function validateEvent(uint256 event_id, Occurences occurence)\r\n        external\r\n        returns (bool)\r\n    {\r\n        _validateEvent(event_id, occurence, msg.sender);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev function is used to validate an event\r\n     * by validators.\r\n     *\r\n     * Requirements:\r\n     * valdator must provide the event intended to be validated and the occurence that occured for the event\r\n     * number of validators required to validate event must not have been exceeded\r\n     * validator must have 1000 or more points\r\n     * event validationElapseTime must not exceed block.timestamp.\r\n     * eventTime must exceed block.timestamp\r\n     *\r\n     * Restriction:\r\n     * validator cannot validate an event twice or more\r\n     */\r\n    function _validateEvent(\r\n        uint256 event_id,\r\n        Occurences occurence,\r\n        address validator_address\r\n    )\r\n        private\r\n        hasOpposingBets(event_id)\r\n        isValidOccurence(occurence)\r\n    {\r\n        context_address.isPlatformActive(validator_address);\r\n        context_address.isUsernameSet(validator_address);\r\n        context_address.isEventValidationPaused(validator_address);\r\n        // check if event exist\r\n        require(event_id \u003c= _event_id.length, \"EF\");\r\n        // check if event has been validated\r\n        require(events[event_id].validated == false, \"EV\");\r\n        // check if number of validators required to validate event has been exceeded\r\n        require(\r\n            eventValidators[event_id].length \u003c=\r\n                events[event_id].validatorsNeeded,\r\n            \"NVNR\"\r\n        );\r\n        // check if eventTime has been exceeded\r\n        require(\r\n            events[event_id].startTime \u003c currentTime(),\r\n            \"EHO\"\r\n        );\r\n        // check if event end time has reached\r\n        require(\r\n            events[event_id].endTime \u003c currentTime(),\r\n            \"ENRFV\"\r\n        );\r\n        // check if event validation time has elapsed\r\n        require(events[event_id].validationElapseTime \u003e currentTime(), \"EVTE\");\r\n        // check if validator has validated event before\r\n        require(\r\n            validatorValidatedEvent[validator_address][event_id] == false,\r\n            \"VETNA\"\r\n        );\r\n\r\n        // validator validates event\r\n        eventOccurenceValidators[event_id][occurence].push(validator_address); // add validator to list of individuals that voted this occurence\r\n        validatorValidatedEvent[validator_address][event_id] = true; // mark validator as validated event\r\n        eventValidators[event_id].push(validator_address); // add validator to list of validators that validated event\r\n        selectedValidationOccurrence[event_id][validator_address][occurence] = true;\r\n        point_address.deductValidationPoint(msg.sender);\r\n        validationHistory[validator_address].push(event_id);\r\n\r\n        // 5 minutes to validation elapse time - check if event has 60% of required validators\r\n        if (\r\n            (events[event_id].validatorsNeeded / 100) * 80 \u003e=\r\n            eventValidators[event_id].length\r\n        ) {\r\n            // event has 70% of needed validators\r\n            _markAsValidated(event_id); // mark as validated\r\n            _cummulateEventValidation(event_id); // cumulate validators event occurence vote\r\n            // check if event occurred occurence isn\u0027t INVALID\r\n            if (occuredOccurrence[event_id] != Occurences.INVALID) {\r\n                _distributionFormular(event_id); // calculate divs\r\n                _rewardSystem(event_id); // reward system\r\n                _rewardVC(event_id); // reward VC\r\n            }\r\n        }\r\n        // check if validators needed has beeen reached\r\n        if (\r\n            eventValidators[event_id].length ==\r\n            events[event_id].validatorsNeeded\r\n        ) {\r\n            _markAsValidated(event_id); // mark as validated\r\n            _cummulateEventValidation(event_id); // cumulate validators event occurence vote\r\n            // check if event occurred occurence isn\u0027t INVALID\r\n            if (occuredOccurrence[event_id] != Occurences.INVALID) {\r\n                _distributionFormular(event_id); // calculate divs\r\n                _rewardSystem(event_id); // reward system\r\n                _rewardVC(event_id); // reward VC\r\n            }\r\n        }\r\n        emit ValidateEvent(event_id, occurence, validator_address); // emit ValidateEvent event\r\n    }\r\n\r\n    /**\r\n     * @dev function returns list of events validated by a validator\r\n    */\r\n    function validatorHistory(address _validator) external view returns (uint256[] memory){\r\n        return validationHistory[_validator];\r\n    }\r\n\r\n    /**\r\n     * @dev function checks for the event occurence which\r\n     * validators voted the most as the occured event\r\n     * occurence.\r\n     * Returns 0 if occurence is WIN\r\n     * Returns 1 if occurence is LOOSE\r\n     * Returns 2 if occurence is LOOSE_OR_WIN\r\n     * Returns 3 if none of the above occurences won out.\r\n     */\r\n    function _cummulateEventValidation(uint256 event_id) private {\r\n        BetEvent storage event_occurrence = events[event_id]; // init betEvent instance\r\n\r\n        // check the occurence that has the highest vote\r\n        if (\r\n            eventOccurenceValidators[event_id][Occurences.WIN].length \u003e\r\n            eventOccurenceValidators[event_id][Occurences.LOOSE].length \u0026\u0026\r\n            eventOccurenceValidators[event_id][Occurences.WIN].length \u003e\r\n            eventOccurenceValidators[event_id][Occurences.LOOSE_OR_WIN].length\r\n        ) {\r\n            // set occured occurence\r\n            occuredOccurrence[event_id] = Occurences.WIN;\r\n            // set event occured occurence\r\n            event_occurrence.occured = occuredOccurrence[event_id];\r\n            // assign amount to be shared\r\n            amountLostInBet[event_id] = amountLostInBet[event_id].add(\r\n                eventBetOccurenceAmount[event_id][Occurences.LOOSE] +\r\n                    eventBetOccurenceAmount[event_id][Occurences.LOOSE_OR_WIN]\r\n            );\r\n        } else if (\r\n            eventOccurenceValidators[event_id][Occurences.LOOSE].length \u003e\r\n            eventOccurenceValidators[event_id][Occurences.WIN].length \u0026\u0026\r\n            eventOccurenceValidators[event_id][Occurences.LOOSE].length \u003e\r\n            eventOccurenceValidators[event_id][Occurences.LOOSE_OR_WIN].length\r\n        ) {\r\n            occuredOccurrence[event_id] = Occurences.LOOSE;\r\n            // set event occured occurence\r\n            event_occurrence.occured = occuredOccurrence[event_id];\r\n            // assign amount to be shared\r\n            amountLostInBet[event_id] = amountLostInBet[event_id].add(\r\n                eventBetOccurenceAmount[event_id][Occurences.WIN] +\r\n                    eventBetOccurenceAmount[event_id][Occurences.LOOSE_OR_WIN]\r\n            );\r\n        } else if (\r\n            eventOccurenceValidators[event_id][Occurences.LOOSE_OR_WIN].length \u003e\r\n            eventOccurenceValidators[event_id][Occurences.WIN].length \u0026\u0026\r\n            eventOccurenceValidators[event_id][Occurences.LOOSE_OR_WIN].length \u003e\r\n            eventOccurenceValidators[event_id][Occurences.LOOSE].length\r\n        ) {\r\n            occuredOccurrence[event_id] = Occurences.LOOSE_OR_WIN;\r\n            // set event occured occurence\r\n            event_occurrence.occured = occuredOccurrence[event_id];\r\n            // assign amount to be shared\r\n            amountLostInBet[event_id] = amountLostInBet[event_id].add(\r\n                eventBetOccurenceAmount[event_id][Occurences.LOOSE] +\r\n                    eventBetOccurenceAmount[event_id][Occurences.WIN]\r\n            );\r\n        } else {\r\n            occuredOccurrence[event_id] = Occurences.INVALID;\r\n            // set event occured occurence\r\n            event_occurrence.occured = occuredOccurrence[event_id];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev function check if validator selected the\r\n     * right event occurence reached through concensus\r\n     */\r\n    function _isSelectedRightOccurrence(uint256 event_id)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        // check if validator selected right event outcome\r\n        if (\r\n            selectedValidationOccurrence[event_id][msg.sender][\r\n                occuredOccurrence[event_id]\r\n            ] == true\r\n        ) {\r\n            // validator selected right event outcome\r\n            return true;\r\n        }\r\n        // validator selected wrong event outcome\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev function calculates the distribution of funds\r\n     * after an event has been validated\r\n     */\r\n    function _distributionFormular(uint256 event_id) internal {\r\n        // calculate what is left after winners reward has been removed\r\n        uint256 winners_percent = (eventBetOccurenceAmount[event_id][occuredOccurrence[event_id]] * 100) / events[event_id].poolSize;\r\n        uint256 winners_reward = (amountLostInBet[event_id] * winners_percent) / 100;\r\n        uint256 div_amount = amountLostInBet[event_id].sub(winners_reward);\r\n        div_amount = div_amount.add(eventTax[event_id]);\r\n        Distribution storage setDivs = divs[event_id];\r\n        setDivs.bettorsDiv = setDivs.bettorsDiv.add((div_amount * 10) / 100);  // bettors reward\r\n        setDivs.systemDiv = setDivs.systemDiv.add((div_amount * 3) / 100);  // system reward\r\n        setDivs.validatorDiv = setDivs.validatorDiv.add((div_amount * 80 ) / 100); // validator reward\r\n        setDivs.creatorDiv = setDivs.creatorDiv.add((div_amount * 1) / 100); // creator reward\r\n        setDivs.VCDiv = setDivs.VCDiv.add((div_amount * 4) / 100); // VC reward\r\n        setDivs.royalty = setDivs.royalty.add((div_amount * 2) / 100); // Royalty reward\r\n    }\r\n\r\n    /**\r\n     * @dev function is used in claiming reward\r\n     */\r\n    function claimReward(uint256 event_id) external returns (bool) {\r\n        _claimReward(event_id, msg.sender);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev function helps a user claim rewards\r\n     *\r\n     * Requirements:\r\n     * [event_id] must be an event that has been validated\r\n     * [msg.sender] must either be a bettor that participated in the event or validator\r\n     * that validated the event\r\n     */\r\n    function _claimReward(uint256 event_id, address user_address)\r\n        internal\r\n        hasClaimedReward(event_id)\r\n    {\r\n        // check if event exist\r\n        require(events[event_id].poolSize \u003e 0, \"EF\");\r\n        // check if event occurrence is not UNKNOWN OR INVALID\r\n        require(\r\n            events[event_id].occured == Occurences.WIN ||\r\n                events[event_id].occured == Occurences.LOOSE ||\r\n                events[event_id].occured == Occurences.LOOSE_OR_WIN,\r\n            \"RWI\"\r\n        );\r\n        // check if user has reclaimed wager \r\n        require(reclaimedBetWager[event_id][user_address] == false, \"WAR\");\r\n        // check if event has been validated\r\n        require(events[event_id].validated == true, \"ENV\");\r\n        BetEvent storage getEventDetails = events[event_id];\r\n        uint256 user_reward;\r\n        // check if user is a bettor of the event\r\n        if(bets[event_id][user_address] == true){\r\n            uint256 event_bonus = divs[event_id].bettorsDiv / events[event_id].bettorsCount;  // get user bonus on event\r\n            context_address.setUserBonusOnEvent(user_address, event_id, event_bonus);\r\n            // check if addr is event creator\r\n            if(events[event_id].betCreator == user_address){\r\n                // addr created event - reward addr\r\n                creator_reward[user_address][event_id] = divs[event_id].creatorDiv;\r\n                getEventDetails.amountClaimed = getEventDetails.amountClaimed.add(\r\n                    divs[event_id].creatorDiv\r\n                ); // increment event winnings claimed\r\n                BUSD_token.transfer(user_address, divs[event_id].creatorDiv);\r\n            }\r\n            // check if user selected occured occurrence\r\n            if (\r\n                userBets[event_id][user_address].occurence ==\r\n                occuredOccurrence[event_id]\r\n            ) {\r\n                // user selected occured occurrence - calculate user reward\r\n                uint256 winners_percent = (userBets[event_id][user_address].amount * 100) / events[event_id].poolSize;\r\n                user_reward = (amountLostInBet[event_id] * winners_percent) / 100;\r\n                user_reward = user_reward.add(\r\n                    userBets[event_id][user_address].amount.add(userEventTax[user_address][event_id])\r\n                ); // refund user original bet amount\r\n                user_reward = user_reward.add(\r\n                    event_bonus\r\n                ); // divide div amount by number of bettors - add amount to user reward\r\n                claimedReward[event_id][user_address] = true; // user marked as collected reward\r\n                _incrementTotalAmountClaimed(user_reward); // increment total amount claimed on platform\r\n                getEventDetails.noOfBettorsRewarded = getEventDetails\r\n                    .noOfBettorsRewarded\r\n                    .add(1); // increment no. of event bettors rewarded\r\n                getEventDetails.amountClaimed = getEventDetails.amountClaimed.add(\r\n                    user_reward\r\n                ); // increment event winnings claimed\r\n                setTotalWinnings(user_address, user_reward);\r\n                setAmountWonByUserOnEvent(event_id, user_address, user_reward);\r\n                BUSD_token.transfer(user_address, user_reward); // transfer user reward to user\r\n            } else {\r\n                // user chose wrong occurrence - reward user from div\r\n                claimedReward[event_id][user_address] = true; // user marked as collected reward\r\n                _incrementTotalAmountClaimed(event_bonus); // increment total amount claimed on platform\r\n                getEventDetails.noOfBettorsRewarded = getEventDetails\r\n                    .noOfBettorsRewarded\r\n                    .add(1); // increment no. of event bettors rewarded\r\n                getEventDetails.amountClaimed = getEventDetails.amountClaimed.add(\r\n                    event_bonus\r\n                ); // increment event winnings claimed\r\n                setTotalWinnings(user_address, event_bonus);\r\n                setAmountWonByUserOnEvent(event_id, user_address, event_bonus);\r\n                BUSD_token.transfer(user_address, event_bonus); // transfer user reward to user\r\n            }\r\n        }\r\n        // check if user validated event\r\n        if (validatorValidatedEvent[user_address][event_id] == true \u0026\u0026 _isSelectedRightOccurrence(event_id) == true) {\r\n            // validator selected the reached occured occurence - reward validator\r\n            user_reward = divs[event_id].validatorDiv / eventOccurenceValidators[event_id][occuredOccurrence[event_id]].length;\r\n            validatorClaimedReward[event_id][user_address] = true;  // mark validator as claimed reward  \r\n            _incrementTotalAmountClaimed(user_reward);  // increment total amount claimed on \r\n            getEventDetails.amountClaimed = getEventDetails.amountClaimed.add(\r\n                    user_reward\r\n                ); // increment event winnings claimed\r\n            setValidatorRewardOnEvent(user_address, event_id, user_reward); // set validator reward on event\r\n            setTotalValidatorRewardClaimed(user_reward);\r\n            setTotalWinnings(user_address, user_reward);\r\n            BUSD_token.transfer(user_address, user_reward);  // transfer user reward to user\r\n        }\r\n        emit Claim(user_address, user_reward); // emit claim event\r\n    }\r\n\r\n    function isBetRewardClaimed(uint256 event_id, address _address) \r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        return claimedReward[event_id][_address];\r\n    }\r\n    \r\n    /**\r\n     * @dev function handles user reclaiming their bet wager\r\n    */\r\n    function reclaimWager(uint256 event_id) external returns (bool) {\r\n        _reclaimBettingWager(event_id, msg.sender);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev function handles user reclaiming their wager on\r\n     * an event, if the event was not validated.\r\n    */\r\n    function _reclaimBettingWager(uint256 event_id, address user_address) internal {\r\n        // check if event exist\r\n        require(events[event_id].startTime \u003e 0, \"EF\");\r\n        // check if event was validated and outcome was invalid\r\n        require(events[event_id].occured == Occurences.UNKNOWN || events[event_id].occured == Occurences.INVALID, \"EVCR\");\r\n        // check if event time has elapsed\r\n        require(events[event_id].validationElapseTime \u003c currentTime(), \"WUEVOE\");\r\n        // check if user betted on event\r\n        require(bets[event_id][user_address] == true, \"WNF\");\r\n        // check if user has reclaimed wager\r\n        require(reclaimedBetWager[event_id][user_address] == false, \"WAR\");\r\n        \r\n        // refund user wager\r\n        reclaimedBetWager[event_id][user_address] = true;  // mark user as collected wager\r\n        uint256 amount = userEventTax[user_address][event_id].add(userBets[event_id][user_address].amount);\r\n        BUSD_token.transfer(user_address, amount);  // refund user wager\r\n        \r\n    }\r\n\r\n    function isBetWagerReclaimed(uint256 event_id, address _address) \r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        return reclaimedBetWager[event_id][_address];\r\n    }\r\n\r\n    /**\r\n     * @dev function handles rewarding system after\r\n     * validation concensus has been reached\r\n    */\r\n    function _rewardSystem(uint256 event_id) internal {\r\n        BetEvent storage eventDetails = events[event_id];\r\n        uint256 amount = divs[event_id].systemDiv;\r\n        // uint256 royalty_amount = divs[event_id].royalty;\r\n        eventDetails.amountClaimed = eventDetails.amountClaimed.add(\r\n                   amount\r\n                ); // increment event winnings claimed\r\n        BUSD_token.transfer(royalty, divs[event_id].royalty);\r\n        BUSD_token.transfer(context_address.getSystemRewardAddress(), amount);  // transfer funds to team wallet\r\n    }\r\n\r\n    /**\r\n     * @dev function handles rewarding of VC contract\r\n     * after validation concensus has been reached\r\n    */\r\n    function _rewardVC(uint256 event_id) internal{\r\n        BetEvent storage eventDetails = events[event_id];\r\n        eventDetails.amountClaimed = eventDetails.amountClaimed.add(\r\n            divs[event_id].VCDiv\r\n        );\r\n        BUSD_token.transfer(context_address.getVCContractAddress(), divs[event_id].VCDiv);\r\n    }\r\n\r\n    /**\r\n     * @dev function marks an event as validated\r\n     */\r\n    function _markAsValidated(uint256 event_id) private {\r\n        BetEvent storage thisEvent = events[event_id]; // initialize event instance\r\n\r\n        thisEvent.validated = true;\r\n\r\n        activeEvents[event_id] = false; // set event as not active\r\n\r\n        removeFromActiveEvents(event_id); // remove event from avalaibleEvents array\r\n        validatedEvent.push(event_id); // add event to list of validated event\r\n    }\r\n\r\n    /**\r\n     * @dev function increments the total winnings claimed\r\n     * on the platform\r\n     */\r\n    function _incrementTotalAmountClaimed(uint256 _value) internal {\r\n        totalAmountClaimed = totalAmountClaimed.add(_value);\r\n    }\r\n\r\n    // function returns the platform\u0027s total payout/winnings\r\n    function getTotalPayout() external view returns (uint256){\r\n        return totalAmountClaimed;\r\n    }\r\n\r\n    // function returns the amount an addr got reward for creating an event\r\n    function getCreatorRewardOnEvent(address user_address, uint256 event_id)\r\n        external view\r\n        returns (uint256)\r\n    {\r\n        return  creator_reward[user_address][event_id];\r\n    }\r\n\r\n    function currentTime() public view returns (uint256) {\r\n        return block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * @dev function withdraws funds left in smart contract after a particular\r\n     * event winnings distribution.\r\n     * This ensures funds are not mistakenly locked away in the smart contract\r\n     *\r\n     * REQUIREMENTS\r\n     * [event_id] must an event that exist and is validated.\r\n     * [event_id] must be an event in which all winnings have been distributed\r\n     * [msg.sender] must be _owner\r\n     */\r\n    function _transferCrumbs(uint256 event_id, address _address)\r\n        private\r\n    {\r\n        context_address.onlyOwner(msg.sender);\r\n        // check if event has been validated\r\n        require(events[event_id].validated == true, \"ENV\");\r\n        // check if all winnings have been distributed\r\n        require(\r\n            events[event_id].noOfBettorsRewarded ==\r\n                events[event_id].bettorsCount,\r\n            \"WNDC\"\r\n        );\r\n        // check if event crumbs has been claimed\r\n        require(_eventCrumbClaimed[event_id] == false, \"ECC\");\r\n\r\n        BetEvent memory eventDetails = events[event_id];\r\n        uint256 leftOverFunds = eventDetails.poolSize -\r\n            eventDetails.amountClaimed; // funds left over after Winnings distribution\r\n        _eventCrumbClaimed[event_id] = true; // mark event crumbs as claimed\r\n        BUSD_token.transfer(_address, leftOverFunds);\r\n    }\r\n\r\n    /**\r\n     * @dev function withdraws funds left in smart contract after a particular\r\n     * event winnings distribution.\r\n     * This ensures funds are not mistakenly locked away in the smart contract\r\n     *\r\n     * REQUIREMENTS\r\n     * [event_id] must an event that exist and is validated.\r\n     * [event_id] must be an event in which all winnings have been distributed\r\n     * [msg.sender] must be _owner\r\n     */\r\n    function transferCrumbs(uint256 event_id, address _address)\r\n        external\r\n        returns (bool)\r\n    {\r\n        _transferCrumbs(event_id, _address);\r\n        return true;\r\n    }\r\n    /**\r\n     * @dev function changes the address for the Royalty contract\r\n    */\r\n    function changeRoyaltyAddress(address _address)\r\n        external \r\n        returns (bool)\r\n    {\r\n        context_address.onlyOwner(msg.sender);\r\n        royalty = _address;\r\n        return true;\r\n    }\r\n\r\n    // function returns Royalty contract address\r\n    function getRoyaltyAddress()\r\n        external\r\n        view\r\n        returns (address)\r\n    {\r\n        return royalty;\r\n    }\r\n\r\n    /**\r\n     * @dev function is used to change the contract address\r\n     * of BUSD\r\n     */\r\n    function changeTokenContractAddress(address _busd)\r\n        external\r\n        returns (bool)\r\n    {\r\n        context_address.onlyOwner(msg.sender);\r\n        BUSD_token = BUSD(address(_busd));\r\n        return true;\r\n    }\r\n\r\n    // function returns token contract address\r\n    function getTokenContractAddress()\r\n        external view\r\n        returns (address)\r\n    {\r\n        return address(BUSD_token);\r\n    }\r\n\r\n    /**\r\n     *@dev function changes the address of the Validator Point contract\r\n    */\r\n    function changePointContractAddress(address _point) \r\n        external \r\n        returns (bool)\r\n    {\r\n        context_address.onlyOwner(msg.sender);\r\n        point_address = Point(address(_point));\r\n        return true;\r\n    }\r\n\r\n    // function returns Validator Point contract address\r\n    function getPointContractAddress()\r\n        external view\r\n        returns (address)\r\n    {\r\n        return address(point_address);\r\n    }\r\n\r\n    /**\r\n     *@dev function changes the address of the Context contract\r\n    */\r\n    function changeContextContractAddress(address _contextAddress)\r\n        external\r\n        returns (bool)\r\n    {\r\n        context_address.onlyOwner(msg.sender);\r\n        context_address = Context(address(_contextAddress));\r\n        return true;\r\n    }\r\n\r\n    // function returns Context contract address\r\n    function getContextContractAddress()\r\n        external view\r\n        returns (address)\r\n    {\r\n        return address(context_address);\r\n    }\r\n\r\n\r\n\r\n    /**\r\n    * @dev function increments the number of active users\r\n    */\r\n    function incrementNoOfActiveUsers(address _address) internal {\r\n        // check if address is an active user\r\n        if(_isActiveUser[_address] == false) {\r\n            _isActiveUser[_address] = true; // mark address as active user\r\n            activeUsersList.push(_address); // add address to active user list\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev function returns list of active users\r\n    */\r\n    function getActiveUsersList() external view returns (address[] memory){\r\n        return activeUsersList;\r\n    }\r\n\r\n    /**\r\n    * @dev function returns number of active users\r\n    */\r\n    function getNoOfActiveUsers() external view returns (uint256){\r\n        return activeUsersList.length;\r\n    }\r\n\r\n    // calls internal function _boostEvent\r\n    function boostEvent(uint256 _boostAmount, uint256 event_id) external {\r\n       _boostEvent(_boostAmount, event_id);\r\n    }\r\n\r\n    /**\r\n     * @dev function is used to boost/promote an event\r\n    */\r\n    function _boostEvent(uint256 _boostAmount, uint256 event_id) private{\r\n         uint256 boostCost = 1000000000000000000;\r\n        // check event endtime\r\n        require(events[event_id].endTime \u003e currentTime(), \"EAE\");\r\n        // check bal\r\n        require(BUSD_token.balanceOf(msg.sender) \u003e= boostCost \u0026\u0026 _boostAmount == boostCost, \"IB\");\r\n        // check event hasn\u0027t been validated\r\n        require(events[event_id].validated == false, \"EV\");\r\n        // check if user wagered on event\r\n        require(bets[event_id][msg.sender] == true, \"NS\");\r\n        BUSD_token.transferFrom(msg.sender, context_address.getSystemRewardAddress(), boostCost);\r\n        BetEvent storage theEvent = events[event_id];\r\n        theEvent.isBoosted = true;\r\n        theEvent.boostTime = block.timestamp + 20 minutes;\r\n    }\r\n\r\n    /**\r\n     * @dev function check if validator has claimed validator reward.\r\n     * Returns true if claimed and false otherwise.\r\n    */\r\n    function isValidatorRewardClaimed(uint256 event_id, address _address) external view returns (bool) {\r\n        return validatorClaimedReward[event_id][_address];\r\n    }\r\n\r\n    /**\r\n     *@dev function sets the referral link for an event to make it sharable.\r\n    */\r\n    function setRefLink(address addr, uint256 event_id, string memory ref) external {\r\n        // check if bettor is market creator and if ref link is set\r\n        if(addr == events[event_id].betCreator \u0026\u0026 bytes(events[event_id].referral).length \u003c 1){\r\n            BetEvent storage updateEvent = events[event_id];\r\n            updateEvent.referral = ref;\r\n        }\r\n    }\r\n}   "}}