// SPDX-License-Identifier: Unlicensed

/*
This is the GiftyCoin Development Pool Contract.
It distributes the BNB as per the Allocation mentioned on the webisite for Development Pool.
For more information check website or reach out to us on telegram.
Website:    https://giftycoin.com
Telegram:   https://t.me/GiftyCoin_GIFTS

This contract is built with guidance from https://t.me/GenTokens_GEN 
Built on code of GEN_Splitter developed by him.
*/


pragma solidity 0.8.19;

interface IERC20 {
    
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

}

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }
}

abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    constructor() {
        _setOwner(_msgSender());
    }

    function Owner() public view virtual returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(Owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }
        
    // Transfer to New Owner - To prevent accidental transfer, you must enter the Confirmation_Code: 30072022
    function X_Ownership_TRANSFER(address newOwner, uint256 Confirmation_Code) public virtual onlyOwner {
        require(Confirmation_Code == 30072022, "Please enter Confirmation code 30072022"); // Transfer confirmation not correct
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        _owner = newOwner;
        emit OwnershipTransferred(_owner, newOwner);
    }
}


contract GiftyCoin_DevPool_Splitter is Ownable {

    address payable private Wallet_RandomTokens;

    address payable private Wallet_Marketing_Development;
    address payable private Wallet_Contingency_Reserve;
    address payable private Wallet_Charity;
    address payable private Wallet_Team;
    address payable private Wallet_Dev;
    address payable private Wallet_X;
    
    uint8 private _Percentage__Marketing_Development;
    uint8 private _Percentage__Contingency_Reserve;
    uint8 private _Percentage__Charity;
    uint8 private _Percentage__Team;
    uint8 private _Percentage__Dev;
    uint8 private _Percentage__X;

    function Process_BNB() external {
        uint256 contractBNB = address(this).balance;
        if (contractBNB > 0) {
        
        uint256 BNB_Marketing_Development = contractBNB * _Percentage__Marketing_Development / 100;
        uint256 BNB_Contingency_Reserve = contractBNB * _Percentage__Contingency_Reserve / 100;
        uint256 BNB_Charity = contractBNB * _Percentage__Charity / 100;
        uint256 BNB_Team = contractBNB * _Percentage__Team / 100;
        uint256 BNB_Dev = contractBNB * _Percentage__Dev / 100;
        uint256 BNB_X = contractBNB * _Percentage__X / 100;

            if (BNB_Marketing_Development > 0 ) { Send_BNB(BNB_Marketing_Development, Wallet_Marketing_Development);}
            if (BNB_Contingency_Reserve > 0 ) { Send_BNB(BNB_Contingency_Reserve, Wallet_Contingency_Reserve);}
            if (BNB_Charity > 0 ) { Send_BNB(BNB_Charity, Wallet_Charity);}
            if (BNB_Team > 0 ) { Send_BNB(BNB_Team, Wallet_Team);}
            if (BNB_Dev > 0 ) { Send_BNB(BNB_Dev, Wallet_Dev);}
            if (BNB_X > 0 ){ Send_BNB(BNB_X, Wallet_X);}        
        }
    }

    function Process_Tokens(address Token_Address, uint256 Percent_of_Tokens) public returns(bool _sent){
        if(Percent_of_Tokens > 100){Percent_of_Tokens = 100;}
        uint256 totalRandom = IERC20(Token_Address).balanceOf(address(this));
        uint256 removeRandom = totalRandom * Percent_of_Tokens / 100;
        _sent = IERC20(Token_Address).transfer(Wallet_RandomTokens, removeRandom);
    }      

    function UpdateWallet01_Marketing_Development(address payable wallet) public onlyOwner() {
        Wallet_Marketing_Development = wallet;
    }

    function UpdateWallet02_Contingency_Reserve(address payable wallet) public onlyOwner() {
        Wallet_Contingency_Reserve = wallet;
    }

    function UpdateWallet03_Charity(address payable wallet) public onlyOwner() {
        Wallet_Charity = wallet;
    }

    function UpdateWallet04_Team(address payable wallet) public onlyOwner() {
        Wallet_Team = wallet;
    }

    function UpdateWallet05_Dev(address payable wallet) public onlyOwner() {
        Wallet_Dev = wallet;
    }

    function UpdateWallet05_X(address payable wallet) public onlyOwner() {
        Wallet_X = wallet;
    }

    function UpdateWallet06_RandomTokens(address payable wallet) public onlyOwner() {
        Wallet_RandomTokens = wallet;
    }

    // Set Percentages
    function Set_Wallet_Percentages(

        uint8 Marketing_Development_Percentage, 
        uint8 Contingency_Reserve_Percentage, 
        uint8 Charity_Percentage,  
        uint8 Team_Percentage,
        uint8 Dev_Percentage,
        uint8 X_Percentage

        ) external onlyOwner {

        // Max or Minimum Percentage 100%
        require (Marketing_Development_Percentage   + 
                 Contingency_Reserve_Percentage     + 
                 Charity_Percentage                 + 
                 Team_Percentage                    +
                 Dev_Percentage                    +
                 X_Percentage   == 100, "Total percentage should be 100"); // Total percentage should be 100


        // Update Percentages
        _Percentage__Marketing_Development  = Marketing_Development_Percentage;
        _Percentage__Contingency_Reserve    = Contingency_Reserve_Percentage;
        _Percentage__Charity                = Charity_Percentage;
        _Percentage__Team                   = Team_Percentage;
        _Percentage__Dev                    = Dev_Percentage;
        _Percentage__X                      = X_Percentage;
    }
    
    
    function Send_BNB(uint256 amount, address payable sendTo) private {
        sendTo.transfer(amount);
    }  


    // info
    function GiftyCoin_DevPool_Wallets() external view returns (
                address Marketing_Development_Wallet,
                address Contingency_Reserve_Wallet,
                address Charity_Wallet,
                address Team_Wallet,
                address Dev_Wallet,
                address X_Wallet) {
                                            
        // Return Data
        return (Wallet_Marketing_Development,
                Wallet_Contingency_Reserve,
                Wallet_Charity,
                Wallet_Team,
                Wallet_Dev,
                Wallet_X);
    }


    // info
    function GiftyCoin_DevPool_Wallets_Percentages() external view returns (
                uint8  Marketing_Development_Percentage,
                uint8  Contingency_Reserve_Percentage,
                uint8  Charity_Percentage,
                uint8  Team_Percentage,
                uint8  Dev_Percentage,
                uint8  X_Percentage) {
                                            
        // Return Data
        return (_Percentage__Marketing_Development,
                _Percentage__Contingency_Reserve,
                _Percentage__Charity,
                _Percentage__Team,
                _Percentage__Dev,
                _Percentage__X);
    }

     // info
    function Wallet_for_RandomTokens() external view returns (address RandomTokens_Wallet)
        {
        // Return Data
        return (Wallet_RandomTokens);
    }

   receive() external payable {}

}