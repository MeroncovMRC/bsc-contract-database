{"DexMeta.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\nimport \"./ERC20.sol\";\nimport \"./SafeMath.sol\";\n\ncontract DexMeta {\n\n    using SafeMath for uint256;\n\n    ERC20   public BUSD_TOKEN;\n    ERC20   public U_TOKEN;\n\n    struct Order {\n        uint256 id;\n        address payable user;\n        uint256 amount;\n        uint256 remain;\n        uint256 price;\n        bool is_sell;\n        bool active;\n        uint256 time;\n    }\n\n    Order[] public orders;\n    uint256 public orderCount;\n    mapping(uint256 =\u003e uint256) public ordersCountOnPrice;\n    mapping(uint256 =\u003e uint256[]) public ordersOnPrice;\n    mapping(address =\u003e uint256[]) private userOrders;\n    \n\n    constructor(address busd, address utoken){\n        BUSD_TOKEN   = ERC20(busd);\n        U_TOKEN   = ERC20(utoken);\n    }\n\n    function createOrder(uint256 _amount, uint256 _price, bool is_sell, bool execute) public {\n\n        if(is_sell){\n            require(U_TOKEN.transferFrom(msg.sender, address(this), _amount), \"Transfer failed\");\n        }else{\n            require(BUSD_TOKEN.transferFrom(msg.sender, address(this), safeTotalPrice(_amount, _price)), \"Transfer failed\");\n        }\n\n        orders.push(Order(orderCount, payable(msg.sender), _amount, _amount, _price, is_sell, true, block.timestamp));\n        ordersOnPrice[_price].push(orderCount);\n        ordersCountOnPrice[_price]++;\n        userOrders[msg.sender].push(orderCount);\n        orderCount++;\n        if(execute){\n            executeOrder((orderCount - 1));\n        }\n\n        emit newOrder(msg.sender, _amount, _price, is_sell);\n    }\n\n    function cancelOrder(uint256 _orderId) public {\n        require(_orderId \u003c orders.length \u0026\u0026 orders[_orderId].active == true, \"Invalid order\");\n        require(orders[_orderId].user == msg.sender, \u0027You can not cancel this order\u0027);\n        orders[_orderId].active = false;\n        \n        if(orders[_orderId].is_sell){\n            require(U_TOKEN.transfer(orders[_orderId].user, orders[_orderId].remain), \"Transfer failed\");\n        }else{\n            require(BUSD_TOKEN.transfer(orders[_orderId].user, safeTotalPrice(orders[_orderId].remain, orders[_orderId].price)), \"Transfer failed\");\n        }\n        emit onCancelOrder(_orderId, orders[_orderId].remain);\n    }\n\n    function executeOrder(uint256 _orderId) private {\n\n        for(uint256 i=0; i\u003cordersCountOnPrice[orders[_orderId].price]; i++){\n\n            if(orders[ordersOnPrice[orders[_orderId].price][i]].is_sell != orders[_orderId].is_sell \u0026\u0026 orders[ordersOnPrice[orders[_orderId].price][i]].active == true){\n                \n                uint256 order1Remain = orders[_orderId].remain;\n                uint256 order2Remain = orders[ordersOnPrice[orders[_orderId].price][i]].remain;\n                uint256 amount = 0;\n\n                if(order1Remain \u003e= order2Remain){\n                    orders[_orderId].remain -= order2Remain;\n                    orders[ordersOnPrice[orders[_orderId].price][i]].remain = 0;\n                    orders[ordersOnPrice[orders[_orderId].price][i]].active = false;\n                    amount = order2Remain;\n                    if(orders[_orderId].remain \u003c= 0){\n                        orders[_orderId].active = false;\n                    }\n                }\n                else{\n                    orders[ordersOnPrice[orders[_orderId].price][i]].remain -= order1Remain;\n                    orders[_orderId].remain = 0;\n                    orders[_orderId].active = false;\n                    amount = order1Remain;\n                    if(orders[ordersOnPrice[orders[_orderId].price][i]].remain \u003c= 0){\n                        orders[ordersOnPrice[orders[_orderId].price][i]].active = false;\n                    }\n                }\n\n                if(amount \u003e 0){\n                    if(orders[_orderId].is_sell){\n                        require(U_TOKEN.transfer(orders[ordersOnPrice[orders[_orderId].price][i]].user, amount), \"Transfer failed\");\n                        require(BUSD_TOKEN.transfer(orders[_orderId].user, safeTotalPrice(amount, orders[_orderId].price)), \"Transfer failed\");\n                    }else{\n                        require(U_TOKEN.transfer(orders[_orderId].user, amount), \"Transfer failed\");\n                        require(BUSD_TOKEN.transfer(orders[ordersOnPrice[orders[_orderId].price][i]].user, safeTotalPrice(amount, orders[_orderId].price)), \"Transfer failed\");\n                    }\n                    emit onExecuteOrder(_orderId, ordersOnPrice[orders[_orderId].price][i], amount, orders[_orderId].price);\n                }\n\n            }\n\n            if(orders[_orderId].active == false){\n                break;\n            }\n        }\n\n    }\n\n    function getOrders(bool onlyActive) public returns (Order[] memory) {\n\n        Order[] memory OrderArray = new Order[](orderCount);\n        uint256 _i = 0;\n\n        for(uint256 i=0; i\u003corderCount; i++){\n            if(onlyActive == true \u0026\u0026 orders[i].active == false)\n                continue;\n            \n            OrderArray[_i] = orders[i];\n            _i++;\n            \n        }\n\n        return OrderArray;\n    }\n\n    function getBuyOrders(bool onlyActive) public returns (Order[] memory) {\n        Order[] memory OrderArray = new Order[](orderCount);\n        uint256 _i = 0;\n\n        for(uint256 i=0; i\u003corderCount; i++){\n            if((onlyActive == true \u0026\u0026 orders[i].active == false) || orders[i].is_sell == true)\n                continue;\n            \n\n            OrderArray[_i] = orders[i];\n            _i++;\n            \n        }\n\n        return OrderArray;\n    }\n\n    function getSellOrders(bool onlyActive) public returns (Order[] memory) {\n        Order[] memory OrderArray = new Order[](orderCount);\n        uint256 _i = 0;\n\n        for(uint256 i=0; i\u003corderCount; i++){\n            if((onlyActive == true \u0026\u0026 orders[i].active == false) || orders[i].is_sell == false)\n                continue;\n            \n\n            OrderArray[_i] = orders[i];\n            _i++;\n            \n        }\n\n        return OrderArray;\n    }\n\n    function safeTotalPrice(uint256 amount, uint256 price) private returns(uint256) {\n        uint256 total = totalPrice(amount, price);\n        require(total \u003e 0, \u0027Internal Error\u0027);\n        return total;\n    }\n\n    function totalPrice(uint256 amount, uint256 price) public returns(uint256){\n        return amount.div(1e8).mul(price.div(1e10));\n    }\n\n    function getUserOrderIds(address user_address) public view returns (uint256[] memory){\n        return userOrders[user_address];\n    }\n\n    function getUserOrder(address user_address) public view returns (Order[] memory){\n\n        uint256 oLength = userOrders[user_address].length;\n\n         Order[] memory OrderArray = new Order[](oLength);\n\n        for(uint256 i=0; i\u003coLength; i++){\n            OrderArray[i] = orders[userOrders[user_address][i]];\n        }\n\n        return OrderArray;\n    }\n\n    event newOrder(address indexed user, uint256 _amount, uint256 _price, bool is_sell);\n    event onCancelOrder(uint256 orderId, uint256 remain);\n    event onExecuteOrder(uint256 orderId1, uint256 orderId2, uint256 amount, uint256 price);\n\n\n}\n"},"ERC20.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity \u003e=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address =\u003e uint256) public balanceOf;\n\n    mapping(address =\u003e mapping(address =\u003e uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address =\u003e uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can\u0027t exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can\u0027t exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline \u003e= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner\u0027s nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) \u0026\u0026 recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can\u0027t exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user\u0027s balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler\u0027s built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c \u003c a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b \u003e a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n            // benefit is lost if \u0027b\u0027 is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003c= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003e 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003e 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"}}