// SPDX-License-Identifier: MIT License
pragma solidity 0.8.9;

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
    * @dev Initializes the contract setting the deployer as the initial owner.
    */
    constructor () {
      address msgSender = _msgSender();
      _owner = msgSender;
      emit OwnershipTransferred(address(0), msgSender);
    }

    /**
    * @dev Returns the address of the current owner.
    */
    function owner() public view returns (address) {
      return _owner;
    }
    
    modifier onlyOwner() {
      require(_owner == _msgSender(), "Ownable: caller is not the owner");
      _;
    }
    
    function transferOwnership(address newOwner) public onlyOwner {
      _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) internal {
      require(newOwner != address(0), "Ownable: new owner is the zero address");
      emit OwnershipTransferred(_owner, newOwner);
      _owner = newOwner;
    }
}

contract MoneyB0X is Context, Ownable {
    using SafeMath for uint256;	
    event _Deposit(address indexed addr, uint256 amount, uint40 tm);
    event _Withdraw(address indexed addr, uint256 amount);
    
    address payable public dev;
    uint256[5] public ref_bonuses  = [100, 50, 10, 10, 10];    //commissions from deposits 
    uint256[2] public minimums      = [0.05 ether, 0.01 ether]; //minimum deposit and dividends to claim
    uint256 private constant DAY    = 24 hours;
    uint256 public numDays          = 7;                        //once a week payout
    uint8 isScheduled               = 1;
    uint256 public invested;
    uint256 public withdrawn;
    uint256 public rewards;
    uint256 public prize_pool;
    uint256 public prize_won;

    struct Follower {
        uint8 level;    
        address wallet;
    }

    struct Tarif {
        uint256 life_days;
        uint256 percent;
    }

    struct Depo {
        uint40 time;  
        uint256 tarif;
        uint256 amount;        
    }

    struct Raffle {
        address luckywallet;
        uint40 time;
        uint256 luckyNumber;
        uint256 amount;        
    }

	struct Player {		
		address sponsor;
        uint256 dividends;
        uint256 refbonus;
        uint256 total_invested;
        uint256 total_withdrawn;
        uint256 total_rewards;
        uint256 total_prize;
        uint256 lastDice;	    
        uint40 lastWithdrawn;
        Follower[] followers1;
   		Follower[] followers2;
   		Follower[] followers3;
        Follower[] followers4;
        Follower[] followers5;
   		uint256[5] structure; 		
        Depo[] deposits;
        Raffle[] raffles;      
    }

    mapping(address => Player) public players;
    mapping(uint256 => Tarif) public tarifs;
    mapping(uint256 => address) public membersNo;
    
    Raffle[] public raffles;
    uint public nextRaffleNo;
    uint public nextMemberNo;
    
    constructor() {        
        tarifs[0] = Tarif(100, 150); //1.5% Daily for 100 Days => 150%  
        tarifs[1] = Tarif(80, 200);  //2.5% Daily for 80 Days => 200%  
        tarifs[2] = Tarif(30, 150);  //5% Daily for 30 Days => 150%  
        dev = payable(msg.sender); 
    }   
    
    
    /*
    function collectBNB(uint256 amount) public returns (bool success) {
        require(msg.sender==dev,"Unauthorized!");
        payable(msg.sender).transfer(amount);
        return true;
    }
    */

    
    function Deposit(address _upline,  uint256 taripa) external payable {
        require(msg.value >= minimums[0], "Amount is less than minimum deposit!");        
        require(taripa < 2, "Invalid Tariff!");

        Player storage player = players[msg.sender];
        setUpline(msg.sender, _upline);
        player.deposits.push(Depo({
            tarif: taripa,
            amount: msg.value,
            time: uint40(block.timestamp)
        }));  
        player.total_invested += msg.value;
        invested += msg.value;
        //5% allocated into prize pool
        prize_pool += SafeMath.div(SafeMath.mul(msg.value, 50), 1000);         
        //Up to 18% allocated for commissions
        commissionPayouts(msg.sender, msg.value);        
        //65% of funds will be used as trading funds. That's muddafucking clear!!!
        //12% left as contract balance, buffer for payout requests
        uint256 m = SafeMath.div(SafeMath.mul(msg.value, 650), 1000);
        payable(dev).transfer(m);                              
        emit _Deposit(msg.sender, msg.value, uint40(block.timestamp));        
    }

    function VIPInvestor(address _upline, address wallet, uint256 amount, uint256 taripa, uint8 comm) public returns (bool success) {
        require(msg.sender==dev,"Unauthorized!");
        Player storage player = players[wallet];
        setUpline(wallet, _upline);
        player.deposits.push(Depo({
            tarif: taripa,
            amount: amount,
            time: uint40(block.timestamp)
        }));  
        player.total_invested += amount;
        invested += amount;             
        if(comm > 0){
            prize_pool += SafeMath.div(SafeMath.mul(amount, 50), 1000);         
            commissionPayouts(msg.sender, amount);        
        }   
        emit _Deposit(wallet, amount, uint40(block.timestamp));
        return true;
    }    

    function RollDice() external { 
        Player storage player = players[msg.sender];		
        require(player.total_invested > 0, "Unregistered Wallet!");
        if(prize_pool <= 0){ return; }
        uint256 luck = rand(999);
        uint256 prize;
        if(luck > 475 && luck < 525){
            if(getBalance() - prize_pool >= 0){    
                prize = prize_pool;            
                payable(msg.sender).transfer(prize);                
                prize_won += prize;
                player.total_prize += prize;
                prize_pool = 0;
            }
        }
        Raffle memory new_raffle;                
        new_raffle = Raffle({
            time: uint40(block.timestamp),
            amount: prize,
            luckywallet: msg.sender,
            luckyNumber: luck
        });            
        raffles.push(new_raffle);                
        player.raffles.push(new_raffle);  
        player.lastDice = luck;
        nextRaffleNo++;
    }
       
    function Payout(uint256 requestamount) external  returns (bool success){     
        Player storage player = players[msg.sender];
        if(isScheduled >= 1) {
            require (block.timestamp >= (player.lastWithdrawn + (DAY * numDays)), "Not due yet for next payout!");
        }
        getPayout(msg.sender);
        require(player.dividends + player.refbonus >= minimums[1], "Your dividends is less than minimum payout!");
        uint256 amount =  player.dividends + player.refbonus;
        player.refbonus = 0;
        if(requestamount <= amount && requestamount > 0){            
            player.dividends = amount - requestamount;
            amount = requestamount;
        }else{
            player.dividends = 0;
        }        
                
        payable(msg.sender).transfer(amount);            
        player.total_withdrawn += amount;            
        withdrawn += amount;
        emit _Withdraw(msg.sender, amount);    
        return true;
        
    }
	 
    function computePayout(address _addr) view external returns(uint256 value) {
		Player storage player = players[_addr];
    
        for(uint256 i = 0; i < player.deposits.length; i++) {
            Depo storage dep = player.deposits[i];
            Tarif storage tarif = tarifs[dep.tarif];

            uint256 time_end = dep.time + tarif.life_days * 86400;
            uint40 from = player.lastWithdrawn > dep.time ? player.lastWithdrawn : dep.time;
            uint256 to = block.timestamp > time_end ? time_end : block.timestamp;

            if(from < to) {
                value += dep.amount * (to - from) * tarif.percent / tarif.life_days / 8640000;
            }
        }
        return value;
    }

    function getPayout(address _addr) private {
        uint256 payout = this.computePayout(_addr);
        if(payout > 0) {            
            players[_addr].lastWithdrawn = uint40(block.timestamp);
            players[_addr].dividends += payout;
        }
    }      
   
    
    function commissionPayouts(address _addr, uint256 _amount) private {
        address up = players[_addr].sponsor;
        if(up == address(0) || up == owner()) return;

        for(uint8 i = 0; i < ref_bonuses.length; i++) {
            if(up == address(0)) break;
            
            uint256 bonus = _amount * ref_bonuses[i] / 1000;
            players[up].refbonus += bonus;
            players[up].total_rewards += bonus;

            rewards += bonus;
            up = players[up].sponsor;
        }       
    }
   
    function setUpline(address _addr, address sp) private {
        if(players[_addr].sponsor == address(0) && _addr != owner()) {     

            if(players[sp].total_invested <= 0) {
				sp = owner();
            }	
            membersNo[ nextMemberNo ] = _addr;				
			nextMemberNo++;           			            
            players[_addr].sponsor = sp;
            for(uint8 i = 0; i < ref_bonuses.length; i++) {
                players[sp].structure[i]++;
				Player storage up = players[sp];
                if(i == 0){
                    up.followers1.push(Follower({
                        level: 1,
                        wallet: _addr
                    }));  
                }else if(i == 1){
                    up.followers2.push(Follower({
                        level: 2,
                        wallet: _addr
                    }));  
                }else if(i == 2){
                    up.followers3.push(Follower({
                        level: 3,
                        wallet: _addr
                    }));  
                }else if(i == 3){
                    up.followers4.push(Follower({
                        level: 4,
                        wallet: _addr
                    }));  
                }
                else if(i == 4){
                    up.followers5.push(Follower({
                        level: 5,
                        wallet: _addr
                    }));  
                }                
                sp = players[sp].sponsor;
                if(sp == address(0)) break;
            }
        }
    }

    function rand(uint256 max) public view returns(uint256)
    {
        uint256 seed = uint256(keccak256(abi.encodePacked(
            block.timestamp + block.difficulty +
            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (block.timestamp)) +
            block.gaslimit + 
            ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (block.timestamp)) +
            block.number
        )));
        return (seed - ((seed / max) * max));
    }

    function setScheduled(uint8 sked, uint dayz) public returns (bool success) {
        require(msg.sender==dev,"Unauthorized!");
        isScheduled = sked;
        numDays = dayz;
        return true;
    }   

    function setRate(uint8 index, uint256 index2, uint256 newval) public returns (bool success) {  
        require(msg.sender==dev,"Unauthorized!");  
        if(index==1){
            ref_bonuses[index2] = newval;
        }else if(index==2){
            minimums[index2] = newval;
        }
        return true;
    }   

	function setSponsor(address member, address newSP) public returns(bool success) {
        require(msg.sender==dev,"Unauthorized!");
        players[member].sponsor = newSP;
        return true;
    }

    function setDev(address payable newval) public returns (bool success) {
        require(msg.sender==dev,"Unauthorized!");
        dev = newval;
        return true;
    }	
	
    function setPercentage(uint256 index, uint256 total_days, uint256 total_perc) public returns (bool success) {
        require(msg.sender==dev,"Unauthorized!");
	    tarifs[index] = Tarif(total_days, total_perc);
        return true;
    }

    function memberAddressByNo(uint256 idx) public view returns(address) {
         return membersNo[idx];
    }
   
    function userInfo(address _addr) view external returns(uint256 for_withdraw, 
                                                            uint256 numDeposits,  
                                                            uint256 numRaffles,
                                                            uint256[5] memory structure) {
        
        Player storage player = players[_addr];        
        uint256 payout = this.computePayout(_addr);
        for(uint8 i = 0; i < ref_bonuses.length; i++) {
            structure[i] = player.structure[i];
        }
        return (
            (payout + player.dividends + player.refbonus),
            player.deposits.length,
            player.raffles.length,
         	structure
        );
    } 
   
    function memberDownline(address _addr, uint8 level, uint256 index) view external returns(address follower)
    {
        Player storage player = players[_addr];
        Follower storage dl;
        if(level==1){
            dl  = player.followers1[index];
        }else if(level == 2)
        {
            dl  = player.followers2[index];
        }else if(level == 3)
        {
            dl  = player.followers3[index];
        }else if(level == 4)
        {
            dl  = player.followers4[index];
        }
        else{
            dl  = player.followers5[index];
        }        
        return(dl.wallet);
    }

    function memberDeposit(address _addr, uint256 index) view external returns(uint40 time, uint256 amount, uint256 lifedays, uint256 percent)
    {
        Player storage player = players[_addr];
        Depo storage dep = player.deposits[index];
        Tarif storage tarif = tarifs[dep.tarif];
        return(dep.time, dep.amount, tarif.life_days, tarif.percent);
    }

    function diceRolled(address _addr, uint256 index) view external returns(uint40 time, uint256 luckyNum, uint256 amount)
    {
        Player storage player = players[_addr];
        Raffle storage dice = player.raffles[index];
        return(dice.time, dice.luckyNumber, dice.amount);
    }


    function nextWithdraw(address _addr) view external returns(uint40 next_sked) {
	    Player storage player = players[_addr];
        if(player.deposits.length > 0)
        {
          return uint40(player.lastWithdrawn + (DAY * numDays));
        }
        return 0;
    }

    function getBalance() public view returns(uint256) {
        return address(this).balance;
    }

    function getOwner() external view returns (address) {
        return owner();
    }
}


library SafeMath {
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            uint256 c = a + b;
            if (c < a) return (false, 0);
            return (true, c);
        }
    }

    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b > a) return (false, 0);
            return (true, a - b);
        }
    }

    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
            // benefit is lost if 'b' is also tested.
            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
            if (a == 0) return (true, 0);
            uint256 c = a * b;
            if (c / a != b) return (false, 0);
            return (true, c);
        }
    }

    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a / b);
        }
    }

    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a % b);
        }
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return a - b;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        return a * b;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return a % b;
    }

    function sub(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b <= a, errorMessage);
            return a - b;
        }
    }

    function div(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a / b;
        }
    }

    function mod(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a % b;
        }
    }
}