// Sources flattened with hardhat v2.6.2 https://hardhat.org

// File @openzeppelin/contracts/utils/Context.sol@v4.3.0

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}


// File @openzeppelin/contracts/security/Pausable.sol@v4.3.0


pragma solidity ^0.8.0;

/**
 * @dev Contract module which allows children to implement an emergency stop
 * mechanism that can be triggered by an authorized account.
 *
 * This module is used through inheritance. It will make available the
 * modifiers `whenNotPaused` and `whenPaused`, which can be applied to
 * the functions of your contract. Note that they will not be pausable by
 * simply including this module, only once the modifiers are put in place.
 */
abstract contract Pausable is Context {
    /**
     * @dev Emitted when the pause is triggered by `account`.
     */
    event Paused(address account);

    /**
     * @dev Emitted when the pause is lifted by `account`.
     */
    event Unpaused(address account);

    bool private _paused;

    /**
     * @dev Initializes the contract in unpaused state.
     */
    constructor() {
        _paused = false;
    }

    /**
     * @dev Returns true if the contract is paused, and false otherwise.
     */
    function paused() public view virtual returns (bool) {
        return _paused;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     *
     * Requirements:
     *
     * - The contract must not be paused.
     */
    modifier whenNotPaused() {
        require(!paused(), "Pausable: paused");
        _;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is paused.
     *
     * Requirements:
     *
     * - The contract must be paused.
     */
    modifier whenPaused() {
        require(paused(), "Pausable: not paused");
        _;
    }

    /**
     * @dev Triggers stopped state.
     *
     * Requirements:
     *
     * - The contract must not be paused.
     */
    function _pause() internal virtual whenNotPaused {
        _paused = true;
        emit Paused(_msgSender());
    }

    /**
     * @dev Returns to normal state.
     *
     * Requirements:
     *
     * - The contract must be paused.
     */
    function _unpause() internal virtual whenPaused {
        _paused = false;
        emit Unpaused(_msgSender());
    }
}


// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.3.0


pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}


// File pancakeswap-peripheral/contracts/interfaces/IPancakeRouter01.sol@v1.1.0-beta.0

pragma solidity >=0.6.2;

interface IPancakeRouter01 {
    function factory() external pure returns (address);
    function WETH() external pure returns (address);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETH(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountToken, uint amountETH);
    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETHWithPermit(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountToken, uint amountETH);
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);
    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);

    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);
    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
}


// File pancakeswap-peripheral/contracts/interfaces/IPancakeRouter02.sol@v1.1.0-beta.0

pragma solidity >=0.6.2;
interface IPancakeRouter02 is IPancakeRouter01 {
    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountETH);
    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountETH);

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable;
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
}


// File contracts/interfaces/IPancakePair.sol

pragma solidity >=0.5.0;

interface IPancakePair {
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function name() external pure returns (string memory);

    function symbol() external pure returns (string memory);

    function decimals() external pure returns (uint8);

    function totalSupply() external view returns (uint256);

    function balanceOf(address owner) external view returns (uint256);

    function allowance(address owner, address spender) external view returns (uint256);

    function approve(address spender, uint256 value) external returns (bool);

    function transfer(address to, uint256 value) external returns (bool);

    function transferFrom(
        address from,
        address to,
        uint256 value
    ) external returns (bool);

    function DOMAIN_SEPARATOR() external view returns (bytes32);

    function PERMIT_TYPEHASH() external pure returns (bytes32);

    function nonces(address owner) external view returns (uint256);

    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    event Mint(address indexed sender, uint256 amount0, uint256 amount1);
    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint256 amount0In,
        uint256 amount1In,
        uint256 amount0Out,
        uint256 amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);

    function MINIMUM_LIQUIDITY() external pure returns (uint256);

    function factory() external view returns (address);

    function token0() external view returns (address);

    function token1() external view returns (address);

    function getReserves()
        external
        view
        returns (
            uint112 reserve0,
            uint112 reserve1,
            uint32 blockTimestampLast
        );

    function price0CumulativeLast() external view returns (uint256);

    function price1CumulativeLast() external view returns (uint256);

    function kLast() external view returns (uint256);

    function mint(address to) external returns (uint256 liquidity);

    function burn(address to) external returns (uint256 amount0, uint256 amount1);

    function swap(
        uint256 amount0Out,
        uint256 amount1Out,
        address to,
        bytes calldata data
    ) external;

    function skim(address to) external;

    function sync() external;

    function initialize(address, address) external;
}


// File contracts/interfaces/IPancakeFactory.sol

pragma solidity >=0.5.0;


interface IPancakeFactory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);

    function feeTo() external view returns (address);
    function feeToSetter() external view returns (address);

    function getPair(address tokenA, address tokenB) external view returns (address pair);
    function allPairs(uint) external view returns (address pair);
    function allPairsLength() external view returns (uint);

    function createPair(address tokenA, address tokenB) external returns (address pair);

    function setFeeTo(address) external;
    function setFeeToSetter(address) external;
}


// File contracts/interfaces/IBlockMonsterFactory.sol

pragma solidity 0.8.6;

interface IBlockMonsterFactory {
    function mintBlockMon(address to, uint64 monsterClassId, uint16 level, uint32 exp, bool isShiny, uint32 specialMove) external returns (uint256 monsterId);
    function burnBlockMon(uint256 tokenId) external;
    function changeAuthManager( address newAuthManager ) external;
    function changeDataManager( address newDataManager ) external;
    function withdrawStuckERC20(address token, address to) external;
    function withdrawStuckBalance(address to) external;
}


// File contracts/interfaces/IBlockMonsterAuthManager.sol

pragma solidity 0.8.6;

interface IBlockMonsterAuthManager {
    function hasPrivilege(bytes32 privilege, address account) external view returns(bool);
    
    function hasPrivilegeForInterface(bytes4 funcSig, address account) external view returns(bool);
    function assignPrivilege(bytes32 privilege, address account) external;
    function registerInterfaceToPrivilege(bytes4 funcSig, bytes32 privilege) external;

    function unregisterInterfaceFromPrivilege(bytes4 funcSig) external;

    function assignSystemContract(address account) external;
}

interface IBlockMonsterAuthClient {
    function hasPrivilegeForInterface(bytes4 funcSig, address account) external view returns (bool);
    function hasPrivilege(bytes32 privilege, address account) external view returns (bool);
    function registerInterfaceToPrivilege(bytes4 funcSig, bytes32 privilege) external;
}


// File contracts/libraries/StarterChoice.sol

pragma solidity 0.8.6;

enum StarterChoice {
    Petaliz,
    Orcalf,
    Flamisire
}


// File contracts/interfaces/IBuyStarterReplacementV2.sol

interface IBuyStarterReplacementV2 {
    function initialize(
        address _blockMonFactory,
        address _pancakeRouter,
        address _busd,
        address _wbnb,
        address _mnstrs,
        address _operationsVault,
        uint256 _factor,
        uint256 _starterPrice,
        uint256 _limitThreshold,
        uint256 _limitTimeframe
    ) external;
    function buyStarterBlockMon() external;
    function pauseNFTSale() external;
    function unpauseNFTSale() external;
    function changeAuthManager( address newAuthManager ) external;
    function withdrawStuckERC20(address token, address to) external;
    function withdrawStuckBalance(address to) external;
}


// File contracts/sales/BuyStarterReplacementV2.sol

pragma solidity ^0.8.6;


contract BuyStarterReplacementV2 is Pausable {
    IBlockMonsterAuthManager _authManager;
    IBlockMonsterFactory blockMonFactory;
    IPancakePair public poolBusd;
    IPancakePair public poolMnstrs;
    IPancakeRouter02 public pancakeRouter;
    IERC20 public busd;
    IERC20 public wbnb;
    IERC20 public mnstrs;

    mapping(address => uint256) public lastMinted;
    uint256 public starterPrice;
    uint256 public factor;
    uint256 public currentThreshold;
    uint256 public currentTimestamp;
    uint256 public limitThreshold;
    uint256 public limitTimeframe;
    address operationsVault;

    bytes4 _interfaceHash;
    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;

    event BuyStarterBlockMon( address trainer, uint64 monsterClassId );

    modifier onlyAdmin() {
        require(
            _authManager.hasPrivilege( DEFAULT_ADMIN_ROLE, msg.sender), 
            "BuyStarterReplacementV2: sender is not DEFAULT_ADMIN_ROLE"
        );
        _;
    }

    constructor (
        address authManager
    ) {
        _authManager = IBlockMonsterAuthManager(authManager);
        _interfaceHash = type(IBuyStarterReplacementV2).interfaceId;
    }

    function initialize(
        address _blockMonFactory,
        address _pancakeFactory,
        address _pancakeRouter,
        address _busd,
        address _wbnb,
        address _mnstrs,
        address _operationsVault,
        uint256 _factor,
        uint256 _starterPrice,
        uint256 _limitThreshold,
        uint256 _limitTimeframe
    ) external onlyAdmin {
        require(_factor != 0, "BuyStarterReplacementV2: can not set factor to zero");
        require(_starterPrice != 0, "BuyStarterReplacementV2: can not set price to zero");
        _pause();
        factor = _factor;
        starterPrice = _starterPrice;
        operationsVault = _operationsVault;
        blockMonFactory = IBlockMonsterFactory(_blockMonFactory); 

        busd = IERC20(_busd);
        wbnb = IERC20(_wbnb);
        mnstrs = IERC20(_mnstrs);

        pancakeRouter = IPancakeRouter02(_pancakeRouter);
        
        // get pairs
        IPancakeFactory pancakeFactory = IPancakeFactory(_pancakeFactory);
        poolBusd = IPancakePair(pancakeFactory.getPair(_busd, _wbnb));
        poolMnstrs = IPancakePair(pancakeFactory.getPair(_mnstrs, _wbnb));
        
        // approve pancake router
        mnstrs.approve(_pancakeRouter, ~uint256(0));

        limitThreshold = _limitThreshold;
        limitTimeframe = _limitTimeframe;
        currentThreshold = 0;
        currentTimestamp = block.timestamp + limitTimeframe;
    }

    function getStarterPrice() public view returns (uint256){
        uint112 reserveBUSD;
        uint112 reserveWBNB1;
        if (poolBusd.token0() == address(busd)){
            (reserveBUSD, reserveWBNB1, ) = poolBusd.getReserves();
        } else {
            (reserveWBNB1, reserveBUSD, ) = poolBusd.getReserves();
        }

        uint112 reserveMNSTRS;
        uint112 reserveWBNB2;
        if (poolMnstrs.token0() == address(mnstrs)){
            (reserveMNSTRS, reserveWBNB2, ) = poolMnstrs.getReserves();
        } else {
            (reserveWBNB2, reserveMNSTRS, ) = poolMnstrs.getReserves();
        }

        return starterPrice * reserveWBNB1 * reserveMNSTRS / reserveBUSD / reserveWBNB2;
    }


    function buyStarterBlockMon() external whenNotPaused {
        address sender = msg.sender; // gas savings
        uint256 blockNr = block.number; // gas savings
        
        // limit to one blockMon per block
        require(lastMinted[sender] < blockNr, "BuyStarterReplacementV2: Can only buy one BlockMonster per block");
        lastMinted[sender] = blockNr;

        // get pegged starter price
        uint256 price = getStarterPrice();

        // check if sender is able to pay $mnstrs
        require( mnstrs.balanceOf(sender) > price, "BuyStarterReplacementV2: Not enough $MNSTRS");
        require( mnstrs.allowance(sender, address(this)) > price, "BuyStarterReplacementV2: Allowance of $MNSTRS Token too low");

        // send $mnstrs
        mnstrs.transferFrom(sender, address(this), price);

        // The tokenomics say 4% operations wallet in bnb and 1% to rewards wallet,
        // and since we twisted the percentage amounts now 4% go to rewardswallet.
        // We swap a small amount back into bnb to mitigate that and receive funds for
        // business operations
        swapTokensToOperationVault(price);

        // min starter
        StarterChoice starter = StarterChoice(_random()); 
        _mintStarterBlockMon(sender, starter);
    }

    function _mintStarterBlockMon(address to, StarterChoice starter) private { 
        uint64 monsterClassId;
        if ( starter == StarterChoice.Petaliz ) {
            monsterClassId = 7;
        } else if ( starter == StarterChoice.Orcalf) {
            monsterClassId = 4;
        } else if ( starter == StarterChoice.Flamisire) {
            monsterClassId = 1;
        }

        blockMonFactory.mintBlockMon(
            to,
            monsterClassId,     
            1,                
            1,         
            false,      
            0          
        );

        emit BuyStarterBlockMon( to, monsterClassId );
    }

    function swapTokensToOperationVault( uint256 tokensChanged ) private {
        uint256 blockTimestamp = block.timestamp; // gas savings

        // check if oversaturated
        if (blockTimestamp> currentTimestamp){
            currentThreshold = 0;
            currentTimestamp = blockTimestamp + limitTimeframe;
        
        } else if (currentThreshold >= limitThreshold) {
            return; // limit is reached
        }

        uint256 tokensToSwap = tokensChanged * factor / 10000;
        uint256 contractBalance = mnstrs.balanceOf(address(this));

        if( tokensToSwap > contractBalance ){
            tokensToSwap = contractBalance;
        }

        currentThreshold += starterPrice * tokensToSwap / tokensChanged; // get value in usd

        address[] memory path = new address[](2);
        path[0] = address(mnstrs);
        path[1] = address(wbnb);

        pancakeRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(tokensToSwap, 0, path, operationsVault, blockTimestamp);
    }

    function _random() private view returns (uint8) {
        return uint8(uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty))) % 3);
    }


    function pauseNFTSale() external onlyAdmin {
        _pause();
    }

    function unpauseNFTSale() external onlyAdmin {
        _unpause();
    }

    function changeAuthManager( address newAuthManager ) external onlyAdmin {
        _authManager = IBlockMonsterAuthManager(newAuthManager);
    }
    
    function withdrawStuckERC20(address token, address to) external onlyAdmin {
        uint256 balance = IERC20(token).balanceOf(address(this));
        IERC20(token).transfer(to, balance);
    }

    function withdrawStuckBalance(address to) external onlyAdmin {
        payable(to).transfer(address(this).balance);
    }
}