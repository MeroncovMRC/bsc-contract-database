// Sources flattened with hardhat v2.14.0 https://hardhat.org

// File contracts/did/interfaces/IBeacon.sol

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;

interface IDAOBeacon {
    function DAO() external view returns (address);
}

interface IDBBeacon {
    function DB() external view returns (address);
}

interface IEditorBeacon {
    function editor() external view returns (address);
}

interface IBufferBeacon {
    function buffer() external view returns (address);
}

interface IVaultBeacon {
    function vault() external view returns (address);
}

interface IBrandBeacon {
    function brand() external view returns (address);
}

interface IHookBeacon {
    function hook() external view returns (address);
}

interface IMarketBeacon {
    function market() external view returns (address);
}

interface IResolverBeacon {
    function resolver() external view returns (address);
}

interface IFilterBeacon {
    function filter() external view returns (address);
}

interface IValueMiningBeacon {
    function valueMining() external view returns (address);
}


// File contracts/did/interfaces/IHashDB.sol

//
pragma solidity ^0.8.9;

interface IPushItemSingle {
    function pushElement(bytes32 itemKey, bytes memory itemValue) external;
}

interface IRemoveElement {
    function removeElement(bytes32 itemKey) external;
}

interface IItemArray {
    function itemArrayLength(bytes32 itemKey) external view returns (uint256);

    function itemArraySlice(bytes32 itemKey, uint256 start, uint256 end) external view returns (bytes[] memory);
}

interface IGetElement {
    function getElement(bytes32 itemKey, uint256 idx) external view returns (bytes memory);
}

interface IGetFirstElement {
    function getFirstElement(bytes32 itemKey) external view returns (bytes memory);
}

interface IRemoveItemArray {
    function removeItemArray(bytes32 itemKey) external;
}

interface IReplaceItemArray {
    function replaceItemArray(bytes32 itemKey, bytes[] memory itemArray) external;
}

interface IReplaceItemArrayWithElement {
    function replaceItemArray(bytes32 itemKey, bytes memory itemValue) external;
}


// File contracts/did/interfaces/IDB.sol

//

pragma solidity ^0.8.9;

interface ISetReverse {
    function setReverse(address owner, bytes32 node) external;
}

interface INodeStatus {
    function isNodeActive(bytes32 node) external view returns (bool);
    function isNodeExisted(bytes32 node) external view returns (bool);
}

interface IActivate {
    function activate(bytes32 parent, address owner, uint64 expire, string memory name, bytes memory _data)
        external
        returns (bytes32);
}

interface IDeactivate {
    function deactivate(bytes32 node) external;
}

interface NodeStruct {
    struct Node {
        bytes32 parent;
        address owner;
        uint64 expire;
        uint64 transfer;
        string name;
    }
}

interface INodeRecord is NodeStruct {
    function getNodeRecord(bytes32 node) external view returns (Node memory);
}

interface IIsNodeActive {
    function isNodeActive(bytes32 node) external view returns (bool);
}

interface IOwnerOf {
    function ownerOf(uint256 tokenId) external view returns (address);
}


// File contracts/did/lib/KeyEnumBase.sol

//

pragma solidity ^0.8.9;

abstract contract KeyEnumBase {
    bytes32 public constant ROOT = bytes32(0);
    uint256 internal constant INDEX_NULL = 0;
    address internal constant ADDRESS_NULL = address(0);
    bytes32 internal constant KEY_NULL = bytes32(0);
    // encodeToKey(bytes32 node, address owner, bytes32 keyHash, bytes32 keySub)

    bytes32 internal constant KEY_BRAND = keccak256("KEY_BRAND");
    // contract address for a domain to set customized tokenURI function for subdomain

    bytes32 internal constant KEY_LIKE = keccak256("KEY_LIKE");
    // maxLength == 100
    // encodeToKey(node, address(0), KEY_LIKE, bytes32(0)) => [liker1, liker2, liker3...]
    // maxLength == Type(uint256).max
    // encodeToKey(node, address(0), KEY_LIKE, bytes32(1)) => [(likee1, timestamp1), (likee2, timestamp2)...]

    bytes32 internal constant KEY_NODE_AGENT = keccak256("KEY_NODE_AGENT");

    bytes32 internal constant KEY_ORDER = keccak256("KEY_ORDER");
    // => [(market address, taker address, expire time, fixed price)]

    bytes32 internal constant KEY_TTL = keccak256("KEY_TTL"); // => [time to live]

    // !!! order and ttl should be cleared before transfer !!!

    // bytes32 internal constant KEY_RESERVE = keccak256("KEY_RESERVE"); // => [marker]
}


// File contracts/did/lib/Parser.sol

//

pragma solidity ^0.8.9;

library Parser {
    function encodeNameToNode(bytes32 parent, string memory name) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(parent, keccak256(abi.encodePacked(name))));
    }

    // !!! keyHash must be a hash value, but keySub might be converted from a unit256 number directly !!!
    function encodeToKey(bytes32 node, address owner, bytes32 keyHash, bytes32 keySub)
        internal
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(node, owner, keyHash, keySub));
    }

    function abiBytesToAddressTime(bytes memory bys) internal pure returns (address addr, uint64 time) {
        uint256 num = abiBytesToUint256(bys);
        addr = address(uint160(num >> 96));
        time = uint64(num & type(uint96).max);
    }

    //
    //    function abiBytesToAddress(bytes memory bys) internal pure returns (address ret) {
    //        require(bys.length == 32 || bys.length == 0, "Data bytes can not be decoded");
    //        if (bys.length == 32) {
    //            ret = abi.decode(bys, (address));
    //        }
    //        return ret;
    //    }
    //
    //    function abiBytesToUint64(bytes memory bys) internal pure returns (uint64 ret) {
    //        require(bys.length == 32 || bys.length == 0, "Data bytes can not be decoded");
    //        if (bys.length == 32) {
    //            ret = abi.decode(bys, (uint64));
    //        }
    //        return ret;
    //    }
    //
    function abiBytesToUint256(bytes memory bys) internal pure returns (uint256 ret) {
        require(bys.length == 32 || bys.length == 0, "Data bytes can not be decoded");
        if (bys.length == 32) {
            ret = abi.decode(bys, (uint256));
        }
        return ret;
    }
    //
    //    function abiBytesToString(bytes memory bys) internal pure returns (string memory ret) {
    //        if (bys.length > 0) {
    //            ret = abi.decode(bys, (string));
    //        }
    //        return ret;
    //    }
    //

    function abiBytesCutToAddress(bytes memory bys) internal pure returns (address addr) {
        uint256 num = abiBytesToUint256(bys);
        addr = address(uint160(num >> 96));
    }
}


// File contracts/lib/TransferHelper.sol

//

pragma solidity ^0.8.9;

library TransferHelper {
    function sendValue(address recipient, uint256 amount) internal {
        address payable payableRecipient = payable(recipient);

        require(address(this).balance >= amount, "Insufficient balance");

        (bool success,) = payableRecipient.call{value: amount}("");
        require(success, "Unable to send value");
    }
}


// File contracts/aggregator/MultiCall.sol

//

pragma solidity ^0.8.9;





interface IRegistrar {
    function batchRegister(address to, string[] calldata names, address agent) external;
}

interface IResolver {
    function fullName(bytes32 node) external view returns (string memory);
}

interface ITakeOrders {
    function takeOrders(bytes32[] calldata tokenIds, address taker) external;
}

interface IBalanceOf {
    function balanceOf(address owner) external view returns (uint256);
}

interface ITokenOfOwnerByIndex {
    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);
}

interface IReverseRecord {
    function reverseRecord(address owner) external view returns (bytes32);
}

interface IGetCost {
    function getCost(string memory name) external view returns (bytes32 node, address owner, uint256 totalCost);
}

contract MultiCall is KeyEnumBase {
    using TransferHelper for address;

    uint256 private constant ZERO = 0;

    address public BEACON;
    address public DB;
    address public ADMIN;
    address public RESOLVER;

    uint256 public constant ERROR = 1000000000;

    address[] public registrarList;

    event DBUpdated(address db);
    event AdminUpdated(address admin);
    event MarketUpdated(address market);
    event BufferUpdated(address buffer);
    event BeaconUpdated(address beacon);
    event ResolverUpdated(address resolver);
    event TargetUpdated(uint256 index, address registrar);

    constructor(address beacon) {
        BEACON = beacon;
        ADMIN = IDAOBeacon(beacon).DAO();
        DB = IDBBeacon(beacon).DB();
        RESOLVER = IResolverBeacon(beacon).resolver();
    }

    modifier onlyAdmin() {
        require(msg.sender == ADMIN || msg.sender == address(this), "Not Granted");
        _;
    }

    function targetListLength() external view returns (uint256) {
        return registrarList.length;
    }

    function setBeacon(address beacon) external onlyAdmin {
        BEACON = beacon;
        emit BeaconUpdated(beacon);
        setDB(IDBBeacon(beacon).DB());
        setResolver(IResolverBeacon(beacon).resolver());
        setAdmin(IDAOBeacon(beacon).DAO());
    }

    function addNewTarget(address registrar) public onlyAdmin {
        require(registrar != address(0), "Zero address");

        registrarList.push(registrar);

        emit TargetUpdated(registrarList.length - 1, registrar);
    }

    function changeTarget(uint256 index, address registrar) public onlyAdmin {
        require(index < registrarList.length, "Index error");
        require(registrar != address(0), "Zero address");

        registrarList[index] = registrar;

        emit TargetUpdated(index, registrar);
    }

    function setDB(address db) public onlyAdmin {
        DB = db;
        emit DBUpdated(db);
    }

    function setAdmin(address admin) public onlyAdmin {
        ADMIN = admin;
        emit AdminUpdated(admin);
    }

    function setResolver(address resolver) public onlyAdmin {
        RESOLVER = resolver;
        emit ResolverUpdated(resolver);
    }

    function launchToChain(uint64 index, bytes32[] calldata orders, string[] calldata registers, address agent)
        external
    {
        // !!! The sequence: takeOrders > batchRegister > batchReserve > batchLike !!!
        require(msg.sender == tx.origin, "Contract caller");

        if (orders.length > 0) {
            ITakeOrders(registrarList[index]).takeOrders(orders, msg.sender); // for DB
        }

        if (registers.length > 0) {
            IRegistrar(registrarList[index]).batchRegister(msg.sender, registers, agent);
        }
    }

    function checkRegisters(address registrar, string[] memory registers)
        public
        view
        returns (uint256 state, uint256 accCost)
    {
        address owner;
        uint256 totalCost;

        for (uint256 i = 0; i < registers.length; i++) {
            (, owner, totalCost) = IGetCost(registrar).getCost(registers[i]);
            if (owner != address(0)) {
                return ((3 * ERROR) + i, 0);
            }
            accCost += totalCost;
        }
    }

    function checkOrders(bytes32[] memory orders) public view returns (uint256 state, uint256 accCost) {
        address market;
        address taker;
        uint64 expire;
        uint256 price;

        uint256 factor = 2;
        // 2 * ERROR for DB orders, 6 * ERROR for Buffer orders

        for (uint256 i = 0; i < orders.length; i++) {
            (market, taker, expire, price,) = searchOrder(orders[i]);
            if (expire <= block.timestamp || market != registrarList[0]) {
                return ((factor * ERROR) + i, 0);
            }
            accCost += price;
        }
    }

    // !!! calldata will cause compiler error: stack-too-deep !!!
    function launchCheck(uint64 index, bytes32[] memory orders, string[] memory registers)
        external
        view
        returns (uint256 state, uint256[2] memory costs)
    {
        // costs => [ordersCost, registersCost]

        if (orders.length > 0) {
            (state, costs[0]) = checkOrders(orders); // for DB
            if (state != 0) {
                return (state, [ZERO, ZERO]);
            }
        }

        if (registers.length > 0) {
            (state, costs[1]) = checkRegisters(registrarList[index], registers);
            if (state != 0) {
                return (state, [ZERO, ZERO]);
            }
        }
    }

    function searchReverse(address addr) public view returns (bytes32 node) {
        address db = DB;
        if (IBalanceOf(db).balanceOf(addr) > 0) {
            node = IReverseRecord(db).reverseRecord(addr);
        }
    }

    function searchOrder(bytes32 node)
        public
        view
        returns (address market, address taker, uint64 expire, uint256 price, address dbOwner)
    {
        address db = DB;
        dbOwner = INodeRecord(db).getNodeRecord(node).owner;
        address owner = dbOwner;
        (market, taker, expire, price) = searchOrder(node, owner, db);
    }

    function searchOrder(bytes32 node, address owner, address db)
        public
        view
        returns (address market, address taker, uint64 expire, uint256 price)
    {
        if (owner != address(0)) {
            bytes32 orderKey = Parser.encodeToKey(node, owner, KEY_ORDER, KEY_NULL);
            if (IItemArray(db).itemArrayLength(orderKey) > 0) {
                (market, taker, expire, price) =
                    abi.decode(IGetFirstElement(db).getFirstElement(orderKey), (address, address, uint64, uint256));
            }
        }
    }

    function search(uint256 index, string memory targetName)
        external
        view
        returns (bytes32 targetNode, uint256 price, address owner, address taker)
    {
        (targetNode, owner, price) = IGetCost(registrarList[index]).getCost(targetName);
        if (owner != address(0)) {
            uint64 expire;
            (, taker, expire, price) = searchOrder(targetNode, owner, DB);
            if (expire <= block.timestamp) {
                price = 0;
                taker = address(0);
            }
        }
    }

    function searchNameList(address asker) external view returns (string[] memory names) {
        address db = DB;
        uint256 balance = IBalanceOf(db).balanceOf(asker);
        names = new string[](balance);
        for (uint256 i = 0; i < balance; i++) {
            uint256 tokenId = ITokenOfOwnerByIndex(db).tokenOfOwnerByIndex(asker, i);
            // NodeStruct.Node memory n = INodeRecord(db).getNodeRecord(bytes32(tokenId)).name;
            names[i] = INodeRecord(db).getNodeRecord(bytes32(tokenId)).name;
        }
    }
}