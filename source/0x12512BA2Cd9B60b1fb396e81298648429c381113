// Welcome to LUNE Token!
// ðŸŒ• Join the Moon Economy ðŸš€
//
// LUNE is a revolutionary token with a total supply of 384.4 billion tokens, representing the distance between Earth and the Moon.
// Our mission is to transform the world of decentralized finance and unlock incredible opportunities for investors.
//
// ðŸŒŸ Key Features of LUNE Token:
// - Regular Redistribution: Every 29 days, holders receive redistributed tokens based on the cycles of the moon.
//   This redistribution mechanism ensures that your LUNE holdings grow over time.
// - 5% Redistribution Fee: Each transaction incurs a 4% fee, which is distributed to existing token holders and 1% to owner.
//   Holders are rewarded simply for holding LUNE in their wallets.
// - Solid and Transparent: LUNE is built on the Ethereum blockchain using proven smart contract technology,
//   ensuring security, transparency, and trustworthiness.
// - Immutable Ownership: The contract owner has renounced ownership, fostering a truly decentralized ecosystem.
//
// Join us on this lunar journey and become part of the LUNE community. Invest today and experience
// the potential of moonshot returns. Together, we can reach for the stars!
//
// How Redistribution Works:
// - Every transaction triggers a 4% redistribution fee.
// - 4% fee is proportionally distributed to all existing token holders based on their holdings.
// - This redistribution mechanism incentivizes long-term holding, encourages community growth, and rewards loyalty.
//
//
// Invest in LUNE Token and embark on a celestial investment opportunity!
//
// No twitter, no discord, no nothing untill 10k holders
//
// We start with 50$ liduidity pool let's have fun

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract LuneToken {
    string public name = "LUNE";
    string public symbol = "LUNE";
    uint256 public totalSupply = 384400000000 * 10**18; // 384 400 000 000 LUNE
    uint8 public decimals = 18;
    address public immutable owner; // Immutable owner variable
    uint256 public creationFee;
    uint256 public redistributionDate;
    uint256 public redistributionInterval = 29 days; // Full moon cycle

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Redistribution(uint256 amount);

    constructor() {
        owner = msg.sender; // Set the contract deployer as the owner
        creationFee = totalSupply * 5 / 100; // 5% of total supply
        balanceOf[owner] = totalSupply; // Credit all tokens to the owner's wallet
        redistributionDate = block.timestamp + redistributionInterval;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, "Insufficient balance");
        _transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value, "Insufficient balance");
        require(allowance[_from][msg.sender] >= _value, "Insufficient allowance");
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    function _transfer(address _from, address _to, uint256 _value) internal {
        uint256 redistributionAmount = _value * 4 / 100; // 4% fee for redistribution
        uint256 creatorAmount = _value * 1 / 100; // 1% fee for the creator
        uint256 transferAmount = _value - redistributionAmount - creatorAmount; // Remaining amount after deducting fees
        
        balanceOf[_from] -= _value;
        balanceOf[_to] += transferAmount;
        emit Transfer(_from, _to, transferAmount);

        if (block.timestamp >= redistributionDate) {
            uint256 amount = balanceOf[address(this)];
            balanceOf[address(this)] = 0;
            redistributionDate += redistributionInterval;
            emit Redistribution(amount);

            // Transfer the redistribution amount to the contract itself
            balanceOf[address(this)] += redistributionAmount;
            emit Transfer(_from, address(this), redistributionAmount);

            // Transfer the creator fee to the owner
            balanceOf[owner] += creatorAmount;
            emit Transfer(_from, owner, creatorAmount);
        }
    }
}