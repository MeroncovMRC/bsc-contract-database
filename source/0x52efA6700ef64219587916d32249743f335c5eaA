{"ERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./IERC165.sol\";\n\nabstract contract ERC165 is IERC165 {\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n\n}\n"},"IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"IERC2981.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./IERC165.sol\";\n\n/**\n * Interface for the NFT Royalty Standard.\n *\n */\ninterface IERC2981 is IERC165 {\n    /**\n     * Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\n     */\n    function royaltyInfo(\n        uint256 tokenId,\n        uint256 salePrice\n    ) external view returns (address receiver, uint256 royaltyAmount);\n}"},"IERC721.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./IERC165.sol\";\n\ninterface IERC721 is IERC165 {\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n}\n"},"IERC721Enumerable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./IERC721.sol\";\n\ninterface IERC721Enumerable is IERC721 {\n\n    function totalSupply() external view returns (uint256);\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n    function tokenByIndex(uint256 index) external view returns (uint256);\n    \n}"},"IERC721Metadata.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./IERC721.sol\";\n\ninterface IERC721Metadata is IERC721 {\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n\n}\n"},"IERC721Receiver.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IERC721Receiver {\n\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n\n}"},"NFTChicken.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./ERC165.sol\";\nimport \"./IERC721.sol\";\nimport \"./IERC2981.sol\";\nimport \"./IERC721Enumerable.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./IERC721Metadata.sol\";\n\ncontract NFTChicken is ERC165, IERC721Enumerable, IERC721Metadata, IERC2981 {\n    uint private constant MASS_MINT_CALL_LIMIT = 500;\n    /**\n     * Token storage\n     */\n    mapping(uint =\u003e address) private _owners;\n    mapping(address =\u003e uint) private _balances;\n    mapping(uint =\u003e address) private _tokenApprovals;\n    mapping(address =\u003e mapping(address =\u003e bool)) private _operatorApprovals;\n\n    /**\n     * Metadata\n     */\n    string private _baseURL;\n\n    /**\n     * Token counter\n     */\n    uint private _nextTokenId = 1;\n\n    /**\n     * User management\n     */\n    struct MinterCreationRequest {\n        mapping(address =\u003e bool) accounts;\n        uint approveCounter;\n        uint mintingLimit;\n    }\n    mapping(address =\u003e MinterCreationRequest) private _minterCreationRequests;\n    mapping(uint =\u003e mapping(address =\u003e address[])) private _userDeleteRequests;\n    uint private _minApprovalsRequired;\n\n    /**\n     * Enumerable\n     */\n    uint[] private _allTokens;\n    mapping(address =\u003e uint[]) private _ownedTokens;\n    mapping(uint =\u003e uint) private _allTokensIndex;\n    mapping(uint =\u003e uint) private _ownedTokensIndex;\n\n    /**\n     * Minting limit\n     */\n    mapping(address =\u003e uint) private _lastMintedDay;\n    mapping(address =\u003e uint) private _mintedToday;\n    mapping(address =\u003e uint) private _minterLimits;\n\n    /**\n     * Roles\n     */\n    mapping(uint =\u003e mapping(address =\u003e bool)) private _roles;\n    uint private constant ROLE_ADMIN = 0;\n    uint private constant ROLE_MINTER = 1;\n\n    /**\n     * Royalty\n     */\n    struct Royalty {\n        address receiver;\n        uint96 royaltyFraction;\n    }\n    Royalty[] private _settingRoyaltyRequests;\n    mapping(uint =\u003e mapping(address =\u003e bool)) private _settingRoyaltyApprovals;\n    mapping(uint =\u003e uint) private _settingRoyaltyApproveCounters;\n    Royalty private _currentRoyalty;\n\n    /**\n     * Pausable\n     */\n    bool private _paused;\n    address[] private _unpauseRequests;\n\n    event AddingMinterRequest(address indexed account, address indexed requester, uint mintintLimit);\n    event AddingMinterApproval(address indexed account, address indexed requester);\n    event AddingMinterRevocation(address indexed account, address indexed requester);\n    event AddingMinter(address indexed account, address indexed requester);\n    event DeletingUserRequest(uint role, address indexed account, address indexed requester);\n    event DeletingUserRevocation(uint role, address indexed account, address indexed requester);\n    event DeletingUser(uint role, address indexed account, address indexed requester);\n    event SettingRoyaltyRequest(address indexed receiver, uint96 royaltyFraction, uint indexed requestIndex, address indexed requester);\n    event SettingRoyaltyApproval(uint requestIndex, address indexed requester);\n    event SettingRoyaltyRevocation(uint requestIndex, address indexed requester);\n    event SettingRoyalty(uint requestIndex, address indexed requester);\n    event Pause(address indexed requester);\n    event UnpauseRequest(address indexed requester);\n    event UnpauseRevocation(address indexed requester);\n    event Unpause(address indexed requester);\n\n    modifier tokenExists(uint tokenId) {\n        require(_exists(tokenId), \"NFTChicken: Token does not exist.\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(hasRole(ROLE_ADMIN, msg.sender), \"NFTChicken: You are not an admin.\");\n        _;\n    }\n\n    modifier onlyMinter() {\n        require(hasRole(ROLE_MINTER, msg.sender), \"NFTChicken: You are not a minter.\");\n        _;\n    }\n\n    modifier unpaused() {\n        require(!_paused, \"NFTChicken: Paused.\");\n        _;\n    }\n\n    constructor(address[] memory admins, uint minApprovalsRequired, string memory baseURL) {\n        require(admins.length \u003e 0, \"HENVesting: Admins are required.\");\n        require(bytes(baseURL).length \u003e 0, \"HENVesting: baseURL is empty.\");\n        require(\n            minApprovalsRequired \u003e 0 \u0026\u0026\n            minApprovalsRequired \u003c= admins.length,\n            \"NFTChicken: Invalid number of minimum votes.\"\n        );\n\n        for (uint i=0; i\u003cadmins.length; i++) {\n            require(admins[i] != address(0), \"NFTChicken: Zero address.\");\n            require(!_roles[ROLE_ADMIN][admins[i]], \"NFTChicken: Admins are not unique.\");\n\n            _roles[ROLE_ADMIN][admins[i]] = true;\n        }\n\n        _minApprovalsRequired = minApprovalsRequired;\n        _baseURL = baseURL;\n    }\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // Token storage\n    // ---------------------------------------------------------------------------------------------------------------\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC2981).interfaceId ||\n            interfaceId == type(IERC721Enumerable).interfaceId ||\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function name() public pure returns (string memory) {\n        return \u0027Rich Hens NFT\u0027;\n    }\n\n    function symbol() public pure returns (string memory) {\n        return \u0027RHN\u0027;\n    }\n\n    function tokenURI(uint tokenId) external view tokenExists(tokenId) returns (string memory) {\n        return string(abi.encodePacked(_baseURL, uint2str(tokenId)));\n    }\n\n    function ownerOf(uint tokenId) public view tokenExists(tokenId) returns (address) {\n        return _owners[tokenId];\n    }\n\n    function balanceOf(address owner) public view returns (uint) {\n        require(owner != address(0), \"NFTChicken: Address zero is not a valid owner.\");\n\n        return _balances[owner];\n    }\n\n    function getApproved(uint tokenId) public view tokenExists(tokenId) returns (address) {\n        return _tokenApprovals[tokenId];\n    }\n\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    function approve(address to, uint tokenId) external {\n        address _owner = ownerOf(tokenId);\n\n        require(to != _owner, \"NFTChicken: Approval to current owner\");\n\n        require(\n            _owner == msg.sender || isApprovedForAll(_owner, msg.sender),\n            \"NFTChicken: Approve caller is not token owner or approved for all.\"\n        );\n\n        _tokenApprovals[tokenId] = to;\n\n        emit Approval(_owner, to, tokenId);\n    }\n\n    function setApprovalForAll(address operator, bool approved) external {\n        require(msg.sender != operator, \"NFTChicken: Approve to caller.\");\n\n        _operatorApprovals[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(address from, address to, uint tokenId) external {\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"NFTChicken: Caller is not token owner or approved.\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    function safeTransferFrom(address from, address to, uint tokenId, bytes memory data) public {\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"NFTChicken: Caller is not token owner or approved.\");\n\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    function safeTransferFrom(address from, address to, uint tokenId) external {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * Mints one NFT\n     *\n     * @param to - address to send minted NFT\n     *\n     * @return NFT ID\n     */\n    function safeMint(address to) public onlyMinter returns (uint) {\n        require(_checkOnERC721Received(address(0), to, _nextTokenId, \"\"), \"NFTChicken: Transfer to non ERC721Receiver implementer.\");\n\n        _mint(to);\n\n        return _nextTokenId - 1;\n    }\n\n    /**\n     * Mints many NFT\n     *\n     * @param to - address to send minted NFT\n     * @param amount - amount NFT to mint\n     *\n     * @return last created NFT ID\n     */\n    function safeMassMint(address to, uint amount) public onlyMinter returns (uint) {\n        require(_checkOnERC721Received(address(0), to, _nextTokenId, \"\"), \"NFTChicken: Transfer to non ERC721Receiver implementer.\");\n\n        _massMint(to, amount);\n\n        return _nextTokenId - 1;\n    }\n\n    function getNextTokenId() external view returns (uint) {\n        return _nextTokenId;\n    }\n\n    function _exists(uint tokenId) internal view returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    function _isApprovedOrOwner(address spender, uint tokenId) internal view returns (bool) {\n        address owner = ownerOf(tokenId);\n\n        return (\n            spender == owner ||\n            isApprovedForAll(owner, spender) ||\n            getApproved(tokenId) == spender\n        );\n    }\n\n    function _transfer(address from, address to, uint tokenId) internal unpaused {\n        require(ownerOf(tokenId) == from, \"NFTChicken: Transfer from incorrect owner.\");\n        //require(to != address(0), \"NFTChicken: Transfer to the zero address.\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        delete _tokenApprovals[tokenId];\n\n        _balances[from]--;\n        _balances[to]++;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    function _safeTransfer(address from, address to, uint tokenId, bytes memory data) internal {\n        _transfer(from, to, tokenId);\n\n        require(_checkOnERC721Received(from, to, tokenId, data), \"NFTChicken: Transfer to non ERC721Receiver implementer.\");\n    }\n\n    function _mint(address to) internal unpaused {\n        require(to != address(0), \"NFTChicken: Mint to the zero address.\");\n        require(!_isMintingLimited(msg.sender, 1), \"NFTChicken: Minting limit.\");\n\n        _beforeTokenTransfer(address(0), to, _nextTokenId);\n\n        _owners[_nextTokenId] = to;\n\n        _balances[to]++;\n\n        emit Transfer(address(0), to, _nextTokenId++);\n    }\n\n    function _massMint(address to, uint amount) internal unpaused {\n        require(to != address(0), \"NFTChicken: Mint to the zero address.\");\n        require(!_isMintingLimited(msg.sender, amount), \"NFTChicken: Minting limit.\");\n        require(amount \u003e 0, \"NFTChicken: Nothing to mint.\");\n        require(amount \u003c= MASS_MINT_CALL_LIMIT, \"NFTChicken: Minting limit per call.\");\n\n        for (uint i=0; i\u003camount; i++) {\n            _beforeTokenTransfer(address(0), to, _nextTokenId);\n\n            _owners[_nextTokenId] = to;\n\n            emit Transfer(address(0), to, _nextTokenId++);\n        }\n\n        _balances[to] += amount;\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint tokenId) internal {\n        if(from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if(from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n\n        if(to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if(to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    function _isMintingLimited(address account, uint amount) internal returns (bool) {\n        uint dayNumber = getCurrentTime() / 86400;\n\n        if (_lastMintedDay[account] != dayNumber) {\n            _mintedToday[account] = 0;\n            _lastMintedDay[account] = dayNumber;\n        }\n\n        if (_minterLimits[account] == 0 || _mintedToday[account] + amount \u003c= _minterLimits[account]) {\n            _mintedToday[account] += amount;\n            return false;\n        }\n\n        return true;\n    }\n\n    function _checkOnERC721Received(address from, address to, uint tokenId, bytes memory data) private returns (bool) {\n        if (to.code.length \u003e 0) {\n            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, data) returns (bytes4 ret) {\n                return ret == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"NFTChicken: Transfer to non ERC721Receiver implementer.\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // Enumerable interface\n    // ---------------------------------------------------------------------------------------------------------------\n    function totalSupply() public view returns (uint) {\n        return _allTokens.length;\n    }\n\n    function tokenByIndex(uint index) external view returns (uint) {\n        require(index \u003c totalSupply(), \"NFTChicken: Out of bonds.\");\n\n        return _allTokens[index];\n    }\n\n    function tokenOfOwnerByIndex(address owner, uint index) external view returns (uint) {\n        require(index \u003c balanceOf(owner), \"NFTChicken: Out of bonds.\");\n\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * Returns all tokens for the owner\n     */\n    function tokensByOwner(address owner) external view returns (uint[] memory) {\n        return _ownedTokens[owner];\n    }\n\n    function _addTokenToAllTokensEnumeration(uint tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    function _removeTokenFromAllTokensEnumeration(uint tokenId) private {\n        uint lastTokenIndex = _allTokens.length - 1;\n        uint tokenIndex = _allTokensIndex[tokenId];\n\n        uint lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId;\n        _allTokensIndex[lastTokenId] = tokenIndex;\n\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n\n    function _addTokenToOwnerEnumeration(address to, uint tokenId) private {\n        uint _length = balanceOf(to);\n\n        _ownedTokensIndex[tokenId] = _length;\n        _ownedTokens[to].push(tokenId);\n    }\n\n    function _removeTokenFromOwnerEnumeration(address from, uint tokenId) private {\n        uint lastTokenIndex = balanceOf(from) - 1;\n        uint tokenIndex = _ownedTokensIndex[tokenId];\n\n        if (tokenIndex != lastTokenIndex) {\n            uint lastTokenId = _ownedTokens[from][lastTokenIndex];\n            _ownedTokens[from][tokenIndex] = lastTokenId;\n            _ownedTokensIndex[lastTokenId] = tokenIndex;\n        }\n\n        delete _ownedTokensIndex[tokenId];\n        _ownedTokens[from].pop();\n    }\n\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // Pausable interface\n    // ---------------------------------------------------------------------------------------------------------------\n    /**\n     * Pauses all transactions\n     */\n    function pause() external onlyAdmin {\n        require(!_paused, \"NFTChicken: Already paused.\");\n\n        _paused = true;\n\n        emit Pause(msg.sender);\n    }\n\n    /**\n     * Requests unpause\n     */\n    function requestUnpause() external onlyAdmin {\n        require(_paused, \"NFTChicken: Not paused.\");\n        require(!_addressInArray(_unpauseRequests, msg.sender), \"NFTChicken: Request already exists.\");\n\n        _unpauseRequests.push(msg.sender);\n\n        emit UnpauseRequest(msg.sender);\n    }\n\n    /**\n     * Revokes previous unpause request\n     */\n    function revokeUnpauseRequest() external onlyAdmin {\n        require(_addressInArray(_unpauseRequests, msg.sender), \"NFTChicken: Request does not exist.\");\n\n        _deleteAddressInArray(_unpauseRequests, msg.sender);\n\n        emit UnpauseRevocation(msg.sender);\n    }\n\n    /**\n     * Unpauses.\n     * It\u0027s needed _minApprovalsRequired requests to unpause the contract.\n     */\n    function unpause() external onlyAdmin {\n        require(_paused, \"NFTChicken: Not unpaused.\");\n        require(_unpauseRequests.length \u003e= _minApprovalsRequired, \"NFTChicken: Not enough requests.\");\n\n        _paused = false;\n        delete _unpauseRequests;\n\n        emit Unpause(msg.sender);\n    }\n\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // User management\n    // ---------------------------------------------------------------------------------------------------------------\n    /**\n     * Checks if the user exists\n     */\n    function hasRole(uint role, address account) public view returns (bool) {\n        return _roles[role][account];\n    }\n\n    /**\n     * Requests to add a minter user.\n     *\n     * @param account - the minter user account\n     * @param mintingLimit - how many NFT cat mint the minter per day (0 - no limit)\n     */\n    function requestAddingMinter(address account, uint mintingLimit) external onlyAdmin {\n        require(!hasRole(ROLE_MINTER, account), \"NFTChicken: User already exists.\");\n        require(_minterCreationRequests[account].approveCounter == 0, \"NFTChicken: Approve already exists.\");\n\n        _minterCreationRequests[account].accounts[msg.sender] = true;\n        _minterCreationRequests[account].approveCounter = 1;\n        _minterCreationRequests[account].mintingLimit = mintingLimit;\n\n        emit AddingMinterRequest(account, msg.sender, mintingLimit);\n    }\n\n    /**\n     * Approves of the minter adding request\n     *\n     * @param account - the minter user account from requestAddingMinter() request\n     */\n    function approveAddingMinterRequest(address account) external onlyAdmin {\n        require(_minterCreationRequests[account].approveCounter \u003e 0, \"NFTChicken: Request does not exist.\");\n        require(!_minterCreationRequests[account].accounts[msg.sender], \"NFTChicken: Approve already exists.\");\n\n        _minterCreationRequests[account].accounts[msg.sender] = true;\n        _minterCreationRequests[account].approveCounter++;\n\n        emit AddingMinterApproval(account, msg.sender);\n    }\n\n    /**\n     * Revokes the previous request of adding a minter.\n     *\n     * @param account - the minter user account from requestAddingMinter()/approveAddingMinterRequest()\n     */\n    function revokeAddingMinterRequest(address account) external onlyAdmin {\n        require(_minterCreationRequests[account].accounts[msg.sender], \"NFTChicken: Approve does not exist.\");\n\n        _minterCreationRequests[account].accounts[msg.sender] = false;\n        _minterCreationRequests[account].approveCounter--;\n\n        if (_minterCreationRequests[account].approveCounter == 0) {\n            delete _minterCreationRequests[account];\n        }\n\n        emit AddingMinterRevocation(account, msg.sender);\n    }\n\n    /**\n     * Adds the minter from the minter adding request.\n     * It\u0027s needed _minApprovalsRequired confirms to allow it.\n     *\n     * @param account - a minter user account from requestAddingMinter()/approveAddingMinterRequest()\n     */\n    function addMinter(address account) external onlyAdmin {\n        require(!hasRole(ROLE_MINTER, account), \"NFTChicken: User already exists.\");\n        require(_minterCreationRequests[account].approveCounter \u003e= _minApprovalsRequired, \"NFTChicken: Not enough approvals.\");\n\n        _roles[ROLE_MINTER][account] = true;\n        _minterLimits[account] = _minterCreationRequests[account].mintingLimit;\n        delete _minterCreationRequests[account];\n\n        emit AddingMinter(account, msg.sender);\n    }\n\n    /**\n     * Requests/Approves a user deleting.\n     *\n     * @param role - the user role\n     * @param account - the minter user account\n     */\n    function requestDeletingUser(uint role, address account) external onlyAdmin {\n        require(role == ROLE_ADMIN || role == ROLE_MINTER, \"NFTChicken: Role does not exist.\");\n        require(hasRole(role, account), \"NFTChicken: User does not exist.\");\n        require(!(role == ROLE_ADMIN \u0026\u0026 account == msg.sender), \"NFTChicken: It is forbidden to ban yourself.\");\n        require(!_addressInArray(_userDeleteRequests[role][account], msg.sender), \"NFTChicken: Request already exists.\");\n\n        _userDeleteRequests[role][account].push(msg.sender);\n\n        emit DeletingUserRequest(role, account, msg.sender);\n    }\n\n    /**\n     * Revokes the previous request of deleting a user.\n     *\n     * @param role - the user role\n     * @param account - the minter user account\n     */\n    function revokeDeletingUserRequest(uint role, address account) external onlyAdmin {\n        require(_addressInArray(_userDeleteRequests[role][account], msg.sender), \"NFTChicken: Request doesn\u0027t exist.\");\n\n        _deleteAddressInArray(_userDeleteRequests[role][account], msg.sender);\n\n        emit DeletingUserRevocation(role, account, msg.sender);\n    }\n\n    /**\n     * Deletes a minter from the minter deleting request.\n     * It\u0027s needed _minApprovalsRequired confirms to allow it.\n     *\n     * @param role - the user role\n     * @param account - the minter user account\n     */\n    function deleteUser(uint role, address account) external onlyAdmin {\n        require(hasRole(role, account), \"NFTChicken: User does not exist.\");\n        require(_userDeleteRequests[role][account].length \u003e= _minApprovalsRequired, \"NFTChicken: Not enough requests.\");\n\n        _roles[role][account] = false;\n        delete _userDeleteRequests[role][account];\n\n        delete _minterLimits[account];\n        delete _mintedToday[account];\n\n        emit DeletingUser(role, account, msg.sender);\n    }\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // Royalty\n    // ---------------------------------------------------------------------------------------------------------------\n    /**\n     * Requests to setup royalty\n     *\n     * @param receiver - the royalty receiver\n     * @param royaltyFraction - the percent of the royalty: 10000=100%, 100=10%, 10=0.1%, 1=0.01%\n     *\n     * @return - the index of request\n     */\n    function requestSettingRoyalty(address receiver, uint96 royaltyFraction) external onlyAdmin returns (uint) {\n        require(receiver != address(0), \"NFTChicken: Zero address.\");\n        require(royaltyFraction \u003e= 0 \u0026\u0026 royaltyFraction \u003c= 10000, \"NFTChicken: Wrong royalty fraction range.\");\n\n        uint requestIndex = _settingRoyaltyRequests.length;\n\n        _settingRoyaltyRequests.push(\n            Royalty({\n                receiver: receiver,\n                royaltyFraction: royaltyFraction\n            })\n        );\n\n        _settingRoyaltyApprovals[requestIndex][msg.sender] = true;\n        _settingRoyaltyApproveCounters[requestIndex] = 1;\n\n        emit SettingRoyaltyRequest(receiver, royaltyFraction, requestIndex, msg.sender);\n\n        return requestIndex;\n    }\n\n    /**\n     * Approves of the setup royalty request\n     *\n     * @param requestIndex - the index of request from requestSetupRoyalty()\n     */\n    function approveSettingRoyaltyRequest(uint requestIndex) external onlyAdmin {\n        require(requestIndex \u003c _settingRoyaltyRequests.length, \"NFTChicken: Request does not exist.\");\n        require(!_settingRoyaltyApprovals[requestIndex][msg.sender], \"NFTChicken: Approve already exists.\");\n\n        _settingRoyaltyApprovals[requestIndex][msg.sender] = true;\n        _settingRoyaltyApproveCounters[requestIndex]++;\n\n        emit SettingRoyaltyApproval(requestIndex, msg.sender);\n    }\n\n    /**\n     * Revokes of the setup royalty request\n     *\n     * @param requestIndex - the index of request from requestSetupRoyalty()\n     */\n    function revokeSettingRoyaltyRequest(uint requestIndex) external onlyAdmin {\n        require(_settingRoyaltyApprovals[requestIndex][msg.sender], \"NFTChicken: Approve does not exist.\");\n\n        _settingRoyaltyApprovals[requestIndex][msg.sender] = false;\n        _settingRoyaltyApproveCounters[requestIndex]--;\n\n        emit SettingRoyaltyRevocation(requestIndex, msg.sender);\n    }\n\n    /**\n     * Setup the current royalty from the request\n     */\n    function setRoyalty(uint requestIndex) external onlyAdmin {\n        require(requestIndex \u003c _settingRoyaltyRequests.length, \"NFTChicken: Request does not exist.\");\n        require(_settingRoyaltyApproveCounters[requestIndex] \u003e= _minApprovalsRequired, \"NFTChicken: Not enough approvals.\");\n\n        _currentRoyalty.receiver = _settingRoyaltyRequests[requestIndex].receiver;\n        _currentRoyalty.royaltyFraction = _settingRoyaltyRequests[requestIndex].royaltyFraction;\n\n        emit SettingRoyalty(requestIndex, msg.sender);\n    }\n\n    /*\n     * Returns how much royalty is owed and to whom\n     */\n    function royaltyInfo(uint tokenId, uint salePrice) external view tokenExists(tokenId) returns (address, uint) {\n        uint royaltyAmount = 0;\n\n        if (!hasRole(ROLE_ADMIN, ownerOf(tokenId)) \u0026\u0026 !hasRole(ROLE_MINTER, ownerOf(tokenId))) {\n            royaltyAmount = (salePrice * _currentRoyalty.royaltyFraction) / 10000;\n        }\n\n        return (_currentRoyalty.receiver, royaltyAmount);\n    }\n\n    function getSettingRoyaltyRequestByIndex(uint requestIndex) external view returns (Royalty memory) {\n        require(requestIndex \u003c _settingRoyaltyRequests.length, \"NFTChicken: Request does not exist.\");\n\n        return _settingRoyaltyRequests[requestIndex];\n    }\n\n    function getCurrentRoyalty() external view returns (Royalty memory) {\n        return _currentRoyalty;\n    }\n\n    function getTotalRoyaltyRequests() external view returns (uint) {\n        return _settingRoyaltyRequests.length;\n    }\n\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // Payable functions\n    // ---------------------------------------------------------------------------------------------------------------\n    fallback() external payable { }\n\n    receive() external payable { }\n\n    function withdraw(uint amount) external onlyAdmin {\n        address payable _to = payable(msg.sender);\n        _to.transfer(amount);\n    }\n\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // Helpers\n    // ---------------------------------------------------------------------------------------------------------------\n    /**\n     * Returns time of the current block. (for using in mock)\n     */\n    function getCurrentTime() public virtual view returns(uint) {\n        return block.timestamp;\n    }\n\n    function _addressInArray(address[] storage arr, address account) internal view returns (bool) {\n       for (uint i=0; i\u003carr.length; i++) {\n            if (arr[i] == account) {\n               return true;\n            }\n       }\n\n       return false;\n    }\n\n    function _deleteAddressInArray(address[] storage arr, address account) internal {\n        bool found = false;\n\n        for (uint i=0; i\u003carr.length-1; i++) {\n            if (arr[i] == account) {\n                found = true;\n            }\n            if (found) {\n                arr[i] = arr[i+1];\n            }\n        }\n        if (found || arr[arr.length-1] == account) {\n            arr.pop();\n        }\n    }\n\n    /**\n     * Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint j = _i;\n        uint len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint k = len;\n        while (_i != 0) {\n            k = k-1;\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n\n}\n"}}