{"Address.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.1;\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        return account.code.length \u003e 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\r\n        (bool success,) = recipient.call{value : amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value : value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length \u003e 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n"},"AggregatorV3Interface.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface AggregatorV3Interface {\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function description() external view returns (string memory);\r\n\r\n    function version() external view returns (uint256);\r\n\r\n    function getRoundData(uint80 _roundId) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\r\n\r\n    function latestRoundData() external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\r\n}\r\n"},"Context.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n"},"IBurn.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\ninterface IBurn{\r\n    function burn(uint256 amount) external;\r\n}"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./Context.sol\";\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n"},"Pausable.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./Context.sol\";\r\n\r\nabstract contract Pausable is Context {\r\n    event Paused(address account);\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n    modifier whenNotPaused() {\r\n        require(!paused(), \"Pausable: paused\");\r\n        _;\r\n    }\r\n    modifier whenPaused() {\r\n        require(paused(), \"Pausable: not paused\");\r\n        _;\r\n    }\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n"},"Prediction.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.7;\r\npragma abicoder v2;\r\n\r\nimport \"./Ownable.sol\";\r\nimport \"./Pausable.sol\";\r\nimport \"./ReentrancyGuard.sol\";\r\nimport \"./IERC20.sol\";\r\nimport \"./SafeERC20.sol\";\r\nimport \"./IBurn.sol\";\r\nimport \"./AggregatorV3Interface.sol\";\r\n\r\ncontract Prediction is Ownable, Pausable, ReentrancyGuard {\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n    IERC20 public immutable token; // Prediction token\r\n    AggregatorV3Interface public oracle;\r\n    bool public genesisLockOnce = false;\r\n    bool public genesisStartOnce = false;\r\n    address public adminAddress; // address of the admin\r\n    address public operatorAddress; // address of the operator\r\n    uint256 public intervalSeconds; // interval in seconds between two prediction rounds\r\n    uint256 public minBetAmount; // minimum betting amount (denominated in wei)\r\n    uint256 public treasuryAmount; // treasury amount that was not claimed\r\n    uint256 public poolAmount; // pool amount that game\r\n    uint256 public currentEpoch; // current epoch for prediction round\r\n    uint256 public oracleLatestRoundId; // converted from uint80 (Chainlink)\r\n    uint256 public oracleUpdateAllowance; // seconds\r\n    mapping(uint256 =\u003e mapping(address =\u003e BetInfo)) public ledger;\r\n    mapping(uint256 =\u003e Round) public rounds;\r\n    mapping(address =\u003e uint256[]) public userRounds;\r\n    mapping(uint256 =\u003e address[]) private ledgerUser;//ledger totalUSer\r\n    WithdrawLog[] private  userWithdraw;\r\n    enum Position {\r\n        Bull,\r\n        Bear\r\n    }\r\n\r\n    struct Round {\r\n        uint256 epoch;\r\n        uint256 startTimestamp;\r\n        uint256 lockTimestamp;\r\n        uint256 closeTimestamp;\r\n        int256 lockPrice;\r\n        int256 closePrice;\r\n        uint256 lockOracleId;\r\n        uint256 closeOracleId;\r\n        uint256 totalAmount;\r\n        uint256 bullAmount;\r\n        uint256 bearAmount;\r\n        uint256 rewardBaseCalAmount;\r\n        uint256 rewardAmount;\r\n        bool oracleCalled;\r\n    }\r\n    struct BetInfo {\r\n        Position position;\r\n        uint256 amount;\r\n        bool claimed; // default false\r\n    }\r\n    struct WithdrawLog{\r\n        address user;\r\n        uint256 epoch;\r\n    }\r\n\r\n    event BetBear(address indexed sender, uint256 indexed epoch, uint256 amount);\r\n    event BetBull(address indexed sender, uint256 indexed epoch, uint256 amount);\r\n    event Claim(address indexed sender, uint256 indexed epoch, uint256 amount);\r\n    event EndRound(uint256 indexed epoch, uint256 indexed roundId, int256 price);\r\n    event LockRound(uint256 indexed epoch, uint256 indexed roundId, int256 price);\r\n    event NewAdminAddress(address admin);\r\n    event NewIntervalSeconds(uint256 intervalSeconds);\r\n    event NewMinBetAmount(uint256 indexed epoch, uint256 minBetAmount);\r\n    event NewOperatorAddress(address operator);\r\n    event NewOracle(address oracle);\r\n    event NewOracleUpdateAllowance(uint256 oracleUpdateAllowance);\r\n    event Pause(uint256 indexed epoch);\r\n    event Unpause(uint256 indexed epoch);\r\n    event RewardsCalculated(uint256 indexed epoch, uint256 rewardBaseCalAmount, uint256 rewardAmount);\r\n    event StartRound(uint256 indexed epoch);\r\n    event TokenRecovery(address indexed token, uint256 amount);\r\n    event TreasuryClaim(uint256 amount);\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == adminAddress, \"Not admin\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdminOrOperator() {\r\n        require(\r\n            msg.sender == adminAddress || msg.sender == operatorAddress,\r\n            \"Not operator/admin\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(msg.sender == operatorAddress, \"Not operator\");\r\n        _;\r\n    }\r\n    modifier notContract() {\r\n        require(!_isContract(msg.sender), \"Contract not allowed\");\r\n        require(msg.sender == tx.origin, \"Proxy contract not allowed\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Constructor\r\n     * @param _token: prediction token\r\n     * @param _oracleAddress: oracle address\r\n     * @param _adminAddress: admin address\r\n     * @param _operatorAddress: operator address\r\n     * @param _intervalSeconds: number of time within an interval\r\n    \r\n     * @param _minBetAmount: minimum bet amounts (in wei)\r\n     * @param _oracleUpdateAllowance: oracle update allowance\r\n     */\r\n    constructor(\r\n        IERC20 _token,\r\n        address _oracleAddress, \r\n        address _adminAddress, \r\n        address _operatorAddress, \r\n        uint256 _intervalSeconds,\r\n        uint256 _minBetAmount, \r\n        uint256 _oracleUpdateAllowance\r\n        ) {\r\n        token = _token;\r\n        oracle = AggregatorV3Interface(_oracleAddress);\r\n        adminAddress = _adminAddress;\r\n        operatorAddress = _operatorAddress;\r\n        intervalSeconds = _intervalSeconds;\r\n        minBetAmount = _minBetAmount;\r\n        oracleUpdateAllowance = _oracleUpdateAllowance;\r\n    }\r\n\r\n    /**\r\n     * @notice Bet bear position\r\n     * @param epoch: epoch\r\n     */\r\n    function betBear(uint256 epoch, uint256 _amount) external whenNotPaused nonReentrant notContract {\r\n        require(epoch == currentEpoch, \"Bet is too early/late\");\r\n        require(_bettable(epoch), \"Round not bettable\");\r\n        require(_amount \u003e= minBetAmount, \"Bet amount must be greater than minBetAmount\");\r\n        require(ledger[epoch][msg.sender].amount == 0, \"Can only bet once per round\");\r\n        token.safeTransferFrom(msg.sender, address(this), _amount);\r\n        // Update round data\r\n        uint256 amount = _amount;\r\n        Round storage round = rounds[epoch];\r\n        round.totalAmount = round.totalAmount + amount;\r\n        round.bearAmount = round.bearAmount + amount;\r\n        ledgerUser[epoch].push(msg.sender);\r\n        // Update user data\r\n        BetInfo storage betInfo = ledger[epoch][msg.sender];\r\n        betInfo.position = Position.Bear;\r\n        betInfo.amount = amount;\r\n        userRounds[msg.sender].push(epoch);\r\n        emit BetBear(msg.sender, epoch, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Bet bull position\r\n     * @param epoch: epoch\r\n     */\r\n    function betBull(uint256 epoch, uint256 _amount) external whenNotPaused nonReentrant notContract {\r\n        require(epoch == currentEpoch, \"Bet is too early/late\");\r\n        require(_bettable(epoch), \"Round not bettable\");\r\n        require(_amount \u003e= minBetAmount, \"Bet amount must be greater than minBetAmount\");\r\n        require(ledger[epoch][msg.sender].amount == 0, \"Can only bet once per round\");\r\n        token.safeTransferFrom(msg.sender, address(this), _amount);\r\n        // Update round data\r\n        uint256 amount = _amount;\r\n        Round storage round = rounds[epoch];\r\n        round.totalAmount = round.totalAmount + amount;\r\n        round.bullAmount = round.bullAmount + amount;\r\n        ledgerUser[epoch].push(msg.sender);\r\n        // Update user data\r\n        BetInfo storage betInfo = ledger[epoch][msg.sender];\r\n        betInfo.position = Position.Bull;\r\n        betInfo.amount = amount;\r\n        userRounds[msg.sender].push(epoch);\r\n        emit BetBull(msg.sender, epoch, amount);\r\n    }\r\n\r\n    function getEpochUser(uint256 epoch, uint256 cursor, uint256 size) external view returns (address[] memory addr, BetInfo[] memory bet, uint256 start){\r\n        uint256 length = size;\r\n        if (length \u003e ledgerUser[epoch].length - cursor) {\r\n            length = ledgerUser[epoch].length - cursor;\r\n        }\r\n        address[] memory user = new address[](length);\r\n        BetInfo[] memory info = new BetInfo[](length);\r\n        for (uint256 i = 0; i \u003c length; i++) {\r\n            address u = ledgerUser[epoch][cursor + i];\r\n            user[i] = u;\r\n            info[i] = ledger[epoch][u];\r\n        }\r\n        return (user,info, cursor + length);\r\n    }\r\n    /**\r\n     * @notice Claim reward for an array of epochs\r\n     * @param epochs: array of epochs\r\n     */\r\n    function claim(uint256[] calldata epochs) external nonReentrant notContract {\r\n        uint256 reward;\r\n        // Initializes reward\r\n        for (uint256 i = 0; i \u003c epochs.length; i++) {\r\n            require(rounds[epochs[i]].startTimestamp != 0, \"Round has not started\");\r\n            uint256 addedReward = 0;\r\n            require(claimable(epochs[i], msg.sender), \"Not eligible for claim\");\r\n            Round memory round = rounds[epochs[i]];\r\n            addedReward = (ledger[epochs[i]][msg.sender].amount * round.rewardAmount) / round.rewardBaseCalAmount;\r\n            ledger[epochs[i]][msg.sender].claimed = true;\r\n            userWithdraw.push(WithdrawLog({user:msg.sender,epoch:epochs[i]}));\r\n            reward += addedReward;\r\n            emit Claim(msg.sender, epochs[i], addedReward);\r\n        }\r\n        require(reward \u003e 0, \"not reward to withdraw\");\r\n        token.safeTransfer(msg.sender, reward);\r\n    }\r\n\r\n    /**\r\n     * @notice Start the next round n, lock price for round n-1, end round n-2\r\n     * @dev Callable by operator\r\n     */\r\n    function executeRound() external whenNotPaused onlyOperator {\r\n        require( genesisStartOnce \u0026\u0026 genesisLockOnce,\"Can only run after genesisStartRound and genesisLockRound is triggered\");\r\n        (uint80 currentRoundId, int256 currentPrice) = _getPriceFromOracle();\r\n        oracleLatestRoundId = uint256(currentRoundId);\r\n        // CurrentEpoch refers to previous round (n-1)\r\n        _safeLockRound(currentEpoch, currentRoundId, currentPrice);\r\n        _safeEndRound(currentEpoch - 1, currentRoundId, currentPrice);\r\n        _calculateRewards(currentEpoch - 1);\r\n        // Increment currentEpoch to current round (n)\r\n        currentEpoch = currentEpoch + 1;\r\n        _safeStartRound(currentEpoch);\r\n    }\r\n\r\n    /**\r\n     * @notice Lock genesis round\r\n     * @dev Callable by operator\r\n     */\r\n    function genesisLockRound() external whenNotPaused onlyOperator {\r\n        require(genesisStartOnce, \"Can only run after genesisStartRound is triggered\");\r\n        require(!genesisLockOnce, \"Can only run genesisLockRound once\");\r\n        (uint80 currentRoundId, int256 currentPrice) = _getPriceFromOracle();\r\n        oracleLatestRoundId = uint256(currentRoundId);\r\n        _safeLockRound(currentEpoch, currentRoundId, currentPrice);\r\n        currentEpoch = currentEpoch + 1;\r\n        _startRound(currentEpoch);\r\n        genesisLockOnce = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Start genesis round\r\n     * @dev Callable by admin or operator\r\n     */\r\n    function genesisStartRound() external whenNotPaused onlyOperator {\r\n        require(!genesisStartOnce, \"Can only run genesisStartRound once\");\r\n        currentEpoch = currentEpoch + 1;\r\n        _startRound(currentEpoch);\r\n        genesisStartOnce = true;\r\n    }\r\n\r\n    /**\r\n     * @notice called by the admin to pause, triggers stopped state\r\n     * @dev Callable by admin or operator\r\n     */\r\n    function pause() external whenNotPaused onlyAdminOrOperator {\r\n        _pause();\r\n        emit Pause(currentEpoch);\r\n    }\r\n\r\n    /**\r\n     * @notice Claim all rewards in treasury\r\n     * @dev Callable by admin\r\n     */\r\n    function claimTreasury() external nonReentrant onlyAdmin {\r\n        require(treasuryAmount \u003e 0, \"not reward to withdraw\");\r\n        uint256 currentTreasuryAmount = treasuryAmount;\r\n        treasuryAmount = 0;\r\n        token.safeTransfer(adminAddress, currentTreasuryAmount);\r\n        emit TreasuryClaim(currentTreasuryAmount);\r\n    }\r\n    function withdrawPool() external  onlyAdminOrOperator {\r\n        require(poolAmount \u003e 0, \"not pool to withdraw\");\r\n        uint256 currentPoolAmount = poolAmount;\r\n        poolAmount = 0;\r\n        token.safeTransfer(adminAddress, currentPoolAmount);\r\n    }\r\n    function injectPool(uint256 amount) external onlyAdminOrOperator {\r\n        require(amount \u003e 0, \"inject amount is 0\");\r\n        poolAmount =poolAmount+amount;\r\n        token.safeTransferFrom(msg.sender,address(this), amount);\r\n    }\r\n\r\n    /**\r\n     * @notice called by the admin to unpause, returns to normal state\r\n     * Reset genesis state. Once paused, the rounds would need to be kickstarted by genesis\r\n     * @dev Callable by admin or operator or keeper\r\n     */\r\n    function unpause() external whenPaused onlyAdminOrOperator {\r\n        _unpause();\r\n        emit Unpause(currentEpoch);\r\n    }\r\n\r\n    /**\r\n     * @notice Set buffer and interval (in seconds)\r\n     * @dev Callable by admin\r\n     */\r\n    function setIntervalSeconds(uint256 _intervalSeconds) external whenPaused onlyAdmin{\r\n        intervalSeconds = _intervalSeconds;\r\n        emit NewIntervalSeconds(_intervalSeconds);\r\n    }\r\n\r\n    /**\r\n     * @notice Set minBetAmount\r\n     * @dev Callable by admin\r\n     */\r\n    function setMinBetAmount(uint256 _minBetAmount) external whenPaused onlyAdmin {\r\n        require(_minBetAmount != 0, \"Must be superior to 0\");\r\n        minBetAmount = _minBetAmount;\r\n        emit NewMinBetAmount(currentEpoch, minBetAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Set operator address\r\n     * @dev Callable by admin\r\n     */\r\n    function setOperator(address _operatorAddress) external onlyAdmin {\r\n        require(_operatorAddress != address(0), \"Cannot be zero address\");\r\n        operatorAddress = _operatorAddress;\r\n        emit NewOperatorAddress(_operatorAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Set Oracle address\r\n     * @dev Callable by admin\r\n     */\r\n    function setOracle(address _oracle) external whenPaused onlyAdmin {\r\n        require(_oracle != address(0), \"Cannot be zero address\");\r\n        oracleLatestRoundId = 0;\r\n        oracle = AggregatorV3Interface(_oracle);\r\n        oracle.latestRoundData();\r\n        emit NewOracle(_oracle);\r\n    }\r\n\r\n    /**\r\n     * @notice Set oracle update allowance\r\n     * @dev Callable by admin\r\n     */\r\n    function setOracleUpdateAllowance(uint256 _oracleUpdateAllowance) external whenPaused onlyAdmin {\r\n        oracleUpdateAllowance = _oracleUpdateAllowance;\r\n        emit NewOracleUpdateAllowance(_oracleUpdateAllowance);\r\n    }\r\n   \r\n    /**\r\n     * @notice It allows the owner to recover tokens sent to the contract by mistake\r\n     * @param _token: token address\r\n     * @param _amount: token amount\r\n     * @dev Callable by owner\r\n     */\r\n    function recoverToken(address _token, uint256 _amount) external onlyOwner {\r\n        require(_token != address(token), \"Cannot be prediction token address\");\r\n        IERC20(_token).safeTransfer(address(msg.sender), _amount);\r\n        emit TokenRecovery(_token, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Set admin address\r\n     * @dev Callable by owner\r\n     */\r\n    function setAdmin(address _adminAddress) external onlyOwner {\r\n        require(_adminAddress != address(0), \"Cannot be zero address\");\r\n        adminAddress = _adminAddress;\r\n        emit NewAdminAddress(_adminAddress);\r\n    }\r\n    /**\r\n     * @notice Returns round epochs and bet information for a user that has participated\r\n     * @param user: user address\r\n     * @param cursor: cursor\r\n     * @param size: size\r\n     */\r\n    function getUserRounds(address user,uint256 cursor,uint256 size) external view returns (uint256[] memory,BetInfo[] memory,uint256){\r\n        uint256 length = size;\r\n        if (length \u003e userRounds[user].length - cursor) {\r\n            length = userRounds[user].length - cursor;\r\n        }\r\n        uint256[] memory values = new uint256[](length);\r\n        BetInfo[] memory betInfo = new BetInfo[](length);\r\n        for (uint256 i = 0; i \u003c length; i++) {\r\n            values[i] = userRounds[user][cursor + i];\r\n            betInfo[i] = ledger[values[i]][user];\r\n        }\r\n        return (values, betInfo, cursor + length);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns round epochs length\r\n     * @param user: user address\r\n     */\r\n    function getUserRoundsLength(address user) external view returns (uint256) {\r\n        return userRounds[user].length;\r\n    }\r\n\r\n    function getEpochUserLength(uint256 epoch) external view returns (uint256) {\r\n        return ledgerUser[epoch].length;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the claimable stats of specific epoch and user account\r\n     * @param epoch: epoch\r\n     * @param user: user address\r\n     */\r\n    function claimable(uint256 epoch, address user) public view returns (bool) {\r\n        BetInfo memory betInfo = ledger[epoch][user];\r\n        Round memory round = rounds[epoch];\r\n        if (round.lockPrice == round.closePrice) {\r\n            return false;\r\n        }\r\n        return\r\n        round.oracleCalled \u0026\u0026\r\n        betInfo.amount != 0 \u0026\u0026\r\n        !betInfo.claimed \u0026\u0026\r\n        ((round.closePrice \u003e round.lockPrice \u0026\u0026 betInfo.position == Position.Bull) ||\r\n        (round.closePrice \u003c round.lockPrice \u0026\u0026 betInfo.position == Position.Bear));\r\n    }\r\n    /**\r\n     * @notice Calculate rewards for round\r\n     * @param epoch: epoch\r\n     */\r\n    function _calculateRewards(uint256 epoch) internal {\r\n        require(rounds[epoch].rewardBaseCalAmount == 0 \u0026\u0026 rounds[epoch].rewardAmount == 0, \"Rewards calculated\");\r\n        Round storage round = rounds[epoch];\r\n        uint256 rewardBaseCalAmount;\r\n        if (round.closePrice \u003e round.lockPrice) {\r\n            rewardBaseCalAmount = round.bullAmount;\r\n        }\r\n        else if (round.closePrice \u003c round.lockPrice) {\r\n            rewardBaseCalAmount = round.bearAmount;\r\n        }\r\n        else {\r\n            rewardBaseCalAmount = 0;\r\n        }\r\n        round.rewardBaseCalAmount = rewardBaseCalAmount;\r\n        uint256 totalAmount=round.totalAmount;\r\n        //有人中奖\r\n        if(rewardBaseCalAmount\u003e0){\r\n            uint256 injectAmount;\r\n            if(round.bullAmount==0){\r\n                injectAmount=round.bearAmount;\r\n            }\r\n            if(round.bearAmount==0){\r\n                injectAmount=round.bullAmount;\r\n            }\r\n            if(injectAmount\u003epoolAmount){\r\n                injectAmount=poolAmount;\r\n            }\r\n            if(injectAmount\u003e0){\r\n                poolAmount=poolAmount-injectAmount;\r\n                totalAmount=totalAmount+injectAmount;\r\n            }\r\n        }else{\r\n            //放入池子\r\n           poolAmount=poolAmount+totalAmount;\r\n           totalAmount=0;\r\n        }\r\n        uint256 rewardAmount=totalAmount;\r\n        if(totalAmount\u003e0){\r\n           uint256 burnFee=totalAmount*2/100; //2% 销毁\r\n            if(burnFee\u003e0){\r\n                rewardAmount-=burnFee;\r\n                address(token).functionCall(abi.encodeWithSelector(IBurn(address(token)).burn.selector, burnFee));\r\n            }\r\n            uint256 treasuryAmt= totalAmount / 100; //1% 手续费\r\n            if(treasuryAmt\u003e0){\r\n                rewardAmount-=treasuryAmt;\r\n                treasuryAmount += treasuryAmt;\r\n            }\r\n            uint256 poolFee= totalAmount*7/ 100;//7% 手续费\r\n            if(poolFee\u003e0){\r\n                rewardAmount-=poolFee;\r\n                poolAmount += poolFee;\r\n            }\r\n        }\r\n        round.rewardAmount = rewardAmount;\r\n        emit RewardsCalculated(epoch, rewardBaseCalAmount, rewardAmount);\r\n    }\r\n    /**\r\n     * @notice End round\r\n     * @param epoch: epoch\r\n     * @param roundId: roundId\r\n     * @param price: price of the round\r\n     */\r\n    function _safeEndRound(uint256 epoch,uint256 roundId,int256 price) internal {\r\n        require(rounds[epoch].lockTimestamp != 0, \"Can only end round after round has locked\");\r\n        require(block.timestamp \u003e= rounds[epoch].closeTimestamp, \"Can only end round after closeTimestamp\");\r\n        Round storage round = rounds[epoch];\r\n        round.closePrice = price;\r\n        round.closeOracleId = roundId;\r\n        round.oracleCalled = true;\r\n        emit EndRound(epoch, roundId, round.closePrice);\r\n    }\r\n\r\n    /**\r\n     * @notice Lock round\r\n     * @param epoch: epoch\r\n     * @param roundId: roundId\r\n     * @param price: price of the round\r\n     */\r\n    function _safeLockRound(uint256 epoch,uint256 roundId,int256 price) internal {\r\n        require(rounds[epoch].startTimestamp != 0, \"Can only lock round after round has started\");\r\n        require(block.timestamp \u003e= rounds[epoch].lockTimestamp, \"Can only lock round after lockTimestamp\");\r\n        Round storage round = rounds[epoch];\r\n        round.closeTimestamp = block.timestamp + intervalSeconds;\r\n        round.lockPrice = price;\r\n        round.lockOracleId = roundId;\r\n        emit LockRound(epoch, roundId, round.lockPrice);\r\n    }\r\n\r\n    /**\r\n     * @notice Start round\r\n     * Previous round n-2 must end\r\n     * @param epoch: epoch\r\n     */\r\n    function _safeStartRound(uint256 epoch) internal {\r\n        require(genesisStartOnce, \"Can only run after genesisStartRound is triggered\");\r\n        require(rounds[epoch - 2].closeTimestamp != 0, \"Can only start round after round n-2 has ended\");\r\n        require(\r\n            block.timestamp \u003e= rounds[epoch - 2].closeTimestamp,\r\n            \"Can only start new round after round n-2 closeTimestamp\"\r\n        );\r\n        _startRound(epoch);\r\n    }\r\n\r\n    /**\r\n     * @notice Start round\r\n     * Previous round n-2 must end\r\n     * @param epoch: epoch\r\n     */\r\n    function _startRound(uint256 epoch) internal {\r\n        Round storage round = rounds[epoch];\r\n        round.startTimestamp = block.timestamp;\r\n        round.lockTimestamp = block.timestamp + intervalSeconds;\r\n        round.closeTimestamp = block.timestamp + (2 * intervalSeconds);\r\n        round.epoch = epoch;\r\n        round.totalAmount = 0;\r\n        emit StartRound(epoch);\r\n    }\r\n\r\n    /**\r\n     * @notice Determine if a round is valid for receiving bets\r\n     * Round must have started and locked\r\n     * Current timestamp must be within startTimestamp and closeTimestamp\r\n     */\r\n    function _bettable(uint256 epoch) internal view returns (bool) {\r\n        return rounds[epoch].startTimestamp != 0 \u0026\u0026\r\n        rounds[epoch].lockTimestamp != 0 \u0026\u0026\r\n        block.timestamp \u003e rounds[epoch].startTimestamp \u0026\u0026\r\n        block.timestamp \u003c rounds[epoch].lockTimestamp;\r\n    }\r\n\r\n    /**\r\n     * @notice Get latest recorded price from oracle\r\n     * If it falls below allowed buffer or has not updated, it would be invalid.\r\n     */\r\n    function _getPriceFromOracle() internal view returns (uint80, int256) {\r\n        uint256 leastAllowedTimestamp = block.timestamp + oracleUpdateAllowance;\r\n        (uint80 roundId, int256 price, , uint256 timestamp,) = oracle.latestRoundData();\r\n        require(timestamp \u003c= leastAllowedTimestamp, \"Oracle update exceeded max timestamp allowance\");\r\n        require(\r\n            uint256(roundId) \u003e oracleLatestRoundId,\r\n            \"Oracle update roundId must be larger than oracleLatestRoundId\"\r\n        );\r\n        return (roundId, price);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns true if `account` is a contract.\r\n     * @param account: account address\r\n     */\r\n    function _isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size \u003e 0;\r\n    }\r\n\r\n    function getWithdrawLog(uint256 cursor, uint256 size) external view returns (WithdrawLog[] memory log, uint256 start){\r\n        uint256 length = size;\r\n        if (length \u003e userWithdraw.length - cursor) {\r\n            length =  userWithdraw.length - cursor;\r\n        }\r\n        WithdrawLog[] memory info = new WithdrawLog[](length);\r\n        for (uint256 i = 0; i \u003c length; i++) {\r\n            info[i] = userWithdraw[cursor + i];\r\n        }\r\n        return (info, cursor + length);\r\n    }\r\n}\r\n"},"ReentrancyGuard.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status;\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n"},"SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./Address.sol\";\r\n\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n    unchecked {\r\n        uint256 oldAllowance = token.allowance(address(this), spender);\r\n        require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\r\n        uint256 newAllowance = oldAllowance - value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n    }\r\n\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length \u003e 0) {\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n"}}