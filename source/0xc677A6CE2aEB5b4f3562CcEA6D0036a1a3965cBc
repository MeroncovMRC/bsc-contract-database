{"Address.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\n\nlibrary Address {\n\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256(\u0027\u0027)`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash \u0026\u0026 codehash != 0x0);\n    }\n\n    /**\n     * @dev Replacement for Solidity\u0027s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n\n}\n"},"IERC20.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\ninterface IERC20 {\n\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n    \n    /**\n     * @dev Returns the number of decimal places\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"},"IUniswapV2Router02.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    payable\n    returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n    external\n    payable\n    returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"},"IXToken.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"./IERC20.sol\";\n\n/**\n * Exempt Surge Interface\n */\ninterface IXToken is IERC20 {\n    function mintXToken(uint256 amount) external returns(bool);\n    function redeemNative(uint256 amount) external returns(bool);\n    function getNativeAddress() external view returns(address);\n}\n\n\n"},"ReentrantGuard.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nabstract contract ReentrancyGuard {\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private _status;\n    constructor () {\n        _status = _NOT_ENTERED;\n    }\n\n    modifier nonReentrant() {\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n        _status = _ENTERED;\n        _;\n        _status = _NOT_ENTERED;\n    }\n}\n"},"SafeMath.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"},"xToken.sol":{"content":"pragma solidity 0.8.4;\n//SPDX-License-Identifier: MIT\n\nimport \"./Address.sol\";\nimport \"./SafeMath.sol\";\nimport \"./IXToken.sol\";\nimport \"./IUniswapV2Router02.sol\";\nimport \"./ReentrantGuard.sol\";\n\n/**\n * Contract: xToken\n * Developed By: Markymark (DeFiMark / MoonMark)\n *\n * Tax Exempt (or Extra) Token that is Pegged 1:1 to a Native Asset\n * Can Be Used For Tax-Exemptions, Low Gas Transfers, Or anything else\n *\n */\ncontract xToken is IXToken, ReentrancyGuard {\n\n    using SafeMath for uint256;\n    using SafeMath for uint8;\n    using Address for address;\n\n    // Native Token Contract Address\n    address public immutable _native;\n    // To Collect Peg In/Out Fees\n    address public _feeCollector;\n    // To Buy And Burn ETHVault\n    address public _ethVaultBurner;\n    // Liquidity Provider For xToken Pairings\n    address public _liquidityProvider;\n    // contract owner\n    address public _owner;\n    modifier onlyOwner(){require(msg.sender == _owner, \u0027Only Owner Function\u0027); _;}\n    // PCS Router For Auto Purchase-\u003eConvert on BNB Received\n    IUniswapV2Router02 _router;\n    // BNB -\u003e Native\n    address[] path;\n    // allow Self Minting\n    bool _allowSelfMinting;\n    // token data\n    string _name;\n    string _symbol;\n    uint8 immutable _decimals;\n    // 0 Total Supply\n    uint256 _totalSupply = 0;\n    // transfer tax\n    uint256 public _transferDenom;\n    uint256 public _bridgeFee;\n    uint256 public _purchaseFee;\n    uint256 public constant _bridgeFeeDenom = 10**5;\n    // balances\n    mapping (address =\u003e uint256) _balances;\n    mapping (address =\u003e mapping (address =\u003e uint256)) _allowances;\n    // blacklist liquidity pools that are not xTokens\n    mapping (address =\u003e bool) blacklistedLP;\n\n    // Create xToken\n    constructor ( address native, string memory tName, string memory tSymbol, \n                uint8 nativeDecimals, address feeCollector, address liquidityProvider,\n                address ethVaultBurner\n    ) {\n        _name = tName;\n        _symbol = tSymbol;\n        _decimals = nativeDecimals;\n        _native = native;\n        _feeCollector = feeCollector;\n        _ethVaultBurner = ethVaultBurner;\n        _liquidityProvider = liquidityProvider;\n        _router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n        path = new address[](2);\n        path[0] = _router.WETH();\n        path[1] = native;\n        _allowSelfMinting = true;\n        _transferDenom = 400;\n        _bridgeFee = 200;\n        _purchaseFee = 10;\n        _owner = msg.sender;\n    }\n    // basic IERC20 Functions\n    function totalSupply() external view override returns (uint256) { return _totalSupply; }\n    function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }\n    function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _decimals;\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /** Transfer Function */\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\n        return _transferFrom(msg.sender, recipient, amount);\n    }\n    /** Transfer Function */\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\n        _allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount, \"Insufficient Allowance\");\n        return _transferFrom(sender, recipient, amount);\n    }\n\n    /** Internal Transfer */\n    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\n        // make standard checks\n        require(recipient != address(0), \"BEP20: transfer to the zero address\");\n        require(amount \u003e 0, \"Transfer amount must be greater than zero\");\n        require(!blacklistedLP[recipient] \u0026\u0026 !blacklistedLP[sender], \u0027Blacklisted Liquidity Pool Detected\u0027);\n        // subtract from sender\n        _balances[sender] = _balances[sender].sub(amount, \"Insufficient Balance\");\n        // take a tax\n        uint256 tax = amount.div(_transferDenom);\n        // Add to Fee Collector\n        _balances[_liquidityProvider] = _balances[_liquidityProvider].add(tax);\n        // receiver gets amount sub tax\n        amount = amount.sub(tax);\n        // give amount to receiver\n        _balances[recipient] = _balances[recipient].add(amount);\n        // Transfer Event\n        emit Transfer(sender, recipient, amount);\n        emit Transfer(sender, _liquidityProvider, tax);\n        return true;\n    }\n    \n    \n    ////////////////////////////////////\n    //////    PUBLIC FUNCTIONS    //////\n    ////////////////////////////////////\n    \n\n\n    /** Creates xTokens based on how many Native received */\n    function mintXToken(uint256 nNative) external override nonReentrant returns(bool) {\n        return _mintXToken(nNative);\n    }\n    \n    /** Destroys xTokens based on how many it is sending back */\n    function redeemNative(uint256 amount) external override nonReentrant returns(bool) {\n        return _redeemNative(amount);\n    }\n    \n    /** Swaps xToken For xToken if pairing on PCS exists between them */\n    function swapTokenForToken(address tokenToReceive, uint256 amountStartingToken) external nonReentrant returns (bool) {\n        return _swapTokenForToken(tokenToReceive, amountStartingToken, msg.sender);\n    }\n    \n    /** Mint xToken And Swap For Desired xToken */\n    function swapNativeForxToken(address xTokenToReceive, uint256 nNative) external nonReentrant returns (bool) {\n        // balance before \n        uint256 before = _balances[msg.sender];\n        // mint xTokens\n        bool successfulMint = _mintXToken(nNative);\n        // ensure successful mint\n        require(successfulMint, \u0027Error Minting xTokens\u0027);\n        // balance received in xTokens\n        uint256 diff = _balances[msg.sender].sub(before);\n        // swap for external token\n        return _swapTokenForToken(xTokenToReceive, diff, msg.sender);\n    }\n    \n    \n    ////////////////////////////////////\n    //////   INTERNAL FUNCTIONS   //////\n    ////////////////////////////////////\n    \n    \n    /** Creates xTokens based on how many Native received */\n    function _mintXToken(uint256 nNative) private returns(bool) {\n        // native balance of sender\n        uint256 bal = IERC20(_native).balanceOf(msg.sender);\n        require(bal \u003e 0 \u0026\u0026 nNative \u003c= bal, \u0027Insufficient Balance\u0027);\n        // balance before transfer\n        uint256 balBefore = IERC20(_native).balanceOf(address(this));\n        // move tokens into contract\n        bool success = IERC20(_native).transferFrom(msg.sender, address(this), nNative);\n        // balance after transfer\n        uint256 received = IERC20(_native).balanceOf(address(this)).sub(balBefore);\n        require(received \u003c= nNative \u0026\u0026 received \u003e 0 \u0026\u0026 success, \u0027Failure In Transfer Evaluation\u0027);\n        // allocate fee to go toward dynamic liquidity\n        uint256 taxAmount = calculateBridgeFee(received);\n        // how much should we send without the tax\n        uint256 amountToSend = received.sub(taxAmount);\n        // add xToken to receiver\u0027s wallet\n        _balances[msg.sender] = _balances[msg.sender].add(amountToSend);\n        // add tax to the Liquidity Provider\n        _balances[_feeCollector] = _balances[_feeCollector].add(taxAmount);\n        // Increase total supply\n        _totalSupply = _totalSupply.add(received);\n        // make sure this won\u0027t break the 1:1\n        require(_totalSupply \u003c= IERC20(_native).balanceOf(address(this)), \u0027This Transaction Would Break the 1:1 Ratio\u0027);\n        // tell the blockchain\n        emit Transfer(address(this), msg.sender, amountToSend);\n        emit Transfer(address(this), _feeCollector, taxAmount);\n        return true;\n    }\n    \n    /** Destroys xTokens based on how many it is sending back */\n    function _redeemNative(uint256 amount) private returns(bool) {\n        // check balance of Native\n        uint256 nativeBal = IERC20(_native).balanceOf(address(this));\n        // make sure there is enough native asset to transfer\n        require(nativeBal \u003e= amount \u0026\u0026 nativeBal \u003e 0 \u0026\u0026 amount \u003c= _balances[msg.sender] \u0026\u0026 _balances[msg.sender] \u003e 0, \u0027Insufficient Balance\u0027);\n        amount = amount == 0 ? _balances[msg.sender] : amount;\n        // allocate bridge fee to go toward dynamic liquidity\n        uint256 taxAmount = calculateBridgeFee(amount);\n        // how much should we send without the tax\n        uint256 amountToBurn = amount.sub(taxAmount);\n        // subtract full amount from sender\n        _balances[msg.sender] = _balances[msg.sender].sub(amount, \u0027Insufficient Sender Balance\u0027);\n        // add xToken to dynamic liquidity receiver\n        _balances[_feeCollector] = _balances[_feeCollector].add(taxAmount);\n        // if successful, remove tokens from supply\n        _totalSupply = _totalSupply.sub(amountToBurn, \u0027total supply cannot be negative\u0027);\n        // transfer Native from this contract to destroyer\n        bool success = IERC20(_native).transfer(msg.sender, amountToBurn);\n        // check if transfer succeeded\n        require(success, \u0027Native Transfer Failed\u0027);\n        // enforce 1:1\n        require(_totalSupply \u003c= IERC20(_native).balanceOf(address(this)), \u0027This tx would break the 1:1 ratio\u0027);\n        // Transfer from seller to address\n        emit Transfer(msg.sender, address(this), amount);\n        if (taxAmount \u003e 0) emit Transfer(address(this), _feeCollector, taxAmount);\n        return true;\n    }\n    \n    /** Swaps xToken For xToken if pairing on PCS exists between them */\n    function _swapTokenForToken(address tokenToReceive, uint256 amountStartingToken, address recipient) private returns (bool) {\n        // check cases\n        require(_balances[recipient] \u003e= amountStartingToken \u0026\u0026 _balances[recipient] \u003e 0, \u0027Insufficient Balance\u0027);\n        // if zero use full balance \n        amountStartingToken = amountStartingToken == 0 ? _balances[recipient] : amountStartingToken;\n        // re-allocate balances before swap initiates\n        _balances[recipient] = _balances[recipient].sub(amountStartingToken, \u0027Insufficient Balance Subtraction Overflow\u0027);\n        _balances[address(this)] = _balances[address(this)].add(amountStartingToken);\n        // path from this -\u003e desired token\n        address[] memory tokenPath = new address[](2);\n        tokenPath[0] = address(this);\n        tokenPath[1] = tokenToReceive;\n        // approve router to move tokens\n        _allowances[address(this)][address(_router)] = amountStartingToken;\n        // make the swap\n        try _router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            amountStartingToken,\n            0,\n            tokenPath,\n            recipient, // give to recipient\n            block.timestamp.add(30)\n        ) {} catch {revert(\u0027Error On Token Swap\u0027);}\n        return true;\n    }\n    \n    /** Buys Native, Returns Amount Received From Purchase */\n    function buyToken() private returns (uint256) {\n        // Match Native Purchase Fee\n        uint256 taxAmount = msg.value.mul(_purchaseFee).div(10**3);\n        uint256 swapAmount = msg.value.sub(taxAmount);\n        // balance before swap\n        uint256 balBefore = IERC20(_native).balanceOf(address(this));\n        // make swap\n        _router.swapExactETHForTokens{value:swapAmount}(\n            0,\n            path,\n            address(this),\n            block.timestamp.add(30)\n        );\n        // collect fee\n        (bool succ,) = payable(_ethVaultBurner).call{value: taxAmount}(\"\");\n        require(succ, \u0027Error On Fee Collection\u0027);\n        // return amount purchased\n        return IERC20(_native).balanceOf(address(this)).sub(balBefore);\n    }\n    \n    /** Private Function To Mint xTokens on BNB Received */\n    function _selfMintXToken() private returns(bool) {\n        // purchase Native\n        uint256 received = buyToken();\n        // received from purchase\n        require(received \u003e 0, \u0027Zero Native Received\u0027);\n        // allocate fee to go toward dynamic liquidity\n        uint256 taxAmount = calculateBridgeFee(received);\n        // how much should we send without the tax\n        uint256 amountToSend = received.sub(taxAmount);\n        // add xToken to receiver\u0027s wallet\n        _balances[msg.sender] = _balances[msg.sender].add(amountToSend);\n        // add tax to the Liquidity Provider\n        _balances[_feeCollector] = _balances[_feeCollector].add(taxAmount);\n        // Increase total supply\n        _totalSupply = _totalSupply.add(received);\n        // make sure this won\u0027t break the 1:1\n        require(_totalSupply \u003c= IERC20(_native).balanceOf(address(this)), \u0027This Transaction Would Break the 1:1 Ratio\u0027);\n        // tell the blockchain\n        emit Transfer(address(this), msg.sender, amountToSend);\n        emit Transfer(address(this), _feeCollector, taxAmount);\n        return true;\n    }\n    \n    \n    ////////////////////////////////////\n    //////     OWNER FUNCTIONS    //////\n    ////////////////////////////////////\n\n\n\n    /** Withdraw Tokens that are not native token that were mistakingly sent to this address */\n    function withdrawTheMistakesOfOthers(address tokenAddress, uint256 nTokens) external onlyOwner {\n        require(tokenAddress != _native, \u0027CANNOT WITHDRAW NATIVE\u0027);\n        nTokens = nTokens == 0 ? IERC20(tokenAddress).balanceOf(address(this)) : nTokens;\n        IERC20(tokenAddress).transfer(msg.sender, nTokens);\n        emit WithdrawTheMistakesOfOthers(tokenAddress, nTokens);\n    }\n    \n    /** Enforce One to One Ratio In Event Tokens Are Incorrectly Sent To Contract */\n    function enforceOneToOne() external onlyOwner {\n        // check balance of Native\n        uint256 nativeBal = IERC20(_native).balanceOf(address(this));\n        // has Native been sent to xToken by mistake\n        if (nativeBal \u003e _totalSupply) {\n            // send excess to liquidity provider\n            IERC20(_native).transfer(_feeCollector, nativeBal.sub(_totalSupply));\n        }\n    }\n    \n    /** Excludes A Liquidity Pool From Exchanging This xToken */\n    function blacklistLiquidityPool(address lpAddress, bool excluded) external onlyOwner {\n        require(lpAddress != address(this), \u0027Cannot Exclude xToken\u0027);\n        blacklistedLP[lpAddress] = excluded;\n        emit BlacklistedLiquidityPool(lpAddress, excluded);\n    }\n\n    /** Incase Pancakeswap Upgrades To V3 */\n    function updateFeeCollectorAddress(address newFeeCollector) external onlyOwner {\n        _feeCollector = newFeeCollector;\n        emit UpdatedFeeCollector(newFeeCollector);\n    }\n    \n    /** Incase Pancakeswap Upgrades To V3 */\n    function updateLiquidityProviderAddress(address newLiquidityProvider) external onlyOwner {\n        _liquidityProvider = newLiquidityProvider;\n        emit UpdatedLiquidityProvider(newLiquidityProvider);\n    }\n    \n    /** Upgrades The Pancakeswap Router Used To Purchase Native on BNB Received */\n    function updatePancakeswapRouterAddress(address newPCSRouter) external onlyOwner {\n        _router = IUniswapV2Router02(newPCSRouter);\n        path[0] = _router.WETH();\n        emit UpdatedPancakeswapRouter(newPCSRouter);\n    }\n    \n    /** Transfers Ownership To New Address */\n    function transferOwnership(address newOwner) external onlyOwner {\n        _owner = newOwner;\n        emit TransferOwnership(newOwner);\n    }\n    \n    /** Updates The Fee Taken Between Token Transfers */\n    function setTransferDenominator(uint256 newDenom) external onlyOwner {\n        require(newDenom \u003e= 5, \u0027Transfer Fee Too High\u0027);\n        _transferDenom = newDenom;\n        emit UpdatedTransferDenominator(newDenom);\n    }\n    \n    /** Native Purchase Fee */\n    function setPurchaseFee(uint256 newPurchaseFee) external onlyOwner {\n        require(newPurchaseFee \u003c= 300, \u0027Fee Too High\u0027);\n        _purchaseFee = newPurchaseFee;\n        emit UpdatedPurchaseFee(newPurchaseFee);\n    }\n    \n    /** Enables BNB Received to Buy+Bridge Native Into xToken */\n    function setAllowSelfMinting(bool allow) external onlyOwner {\n        _allowSelfMinting = allow;\n        emit UpdatedAllowSelfMinting(allow);\n    }\n    \n    /** Updates The Fee Taken When Minting/Burning xTokens */\n    function setBridgeFee(uint256 newBridgeFee) external onlyOwner {\n        require(newBridgeFee \u003c= _bridgeFeeDenom.div(4), \u0027Bridge Fee Too High\u0027);\n        _bridgeFee = newBridgeFee;\n        emit UpdatedBridgeFee(newBridgeFee);\n    }\n    \n    /** Sets The Burner Contract To Burn ETHVault On BNB Received */\n    function setETHVaultBurner(address newBurner) external onlyOwner {\n        require(newBurner != address(0) \u0026\u0026 newBurner != _ethVaultBurner, \u0027Invalid Address\u0027);\n        _ethVaultBurner = newBurner;\n        emit UpdatedETHVaultBurner(newBurner);\n    }\n    \n    ////////////////////////////////////\n    //////     READ FUNCTIONS     //////\n    ////////////////////////////////////\n    \n    /** If LP is Blacklisted */\n    function isBlacklisted(address liquidityPool) external view returns(bool) {\n        return blacklistedLP[liquidityPool];\n    }\n\n    /** Caulcates Bridge Fee Applied When Minting / Redeeming xTokens */\n    function calculateBridgeFee(uint256 amount) public view returns (uint256) {\n        return amount.mul(_bridgeFee).div(_bridgeFeeDenom);\n    }\n\n    /** Returns the Native Token This xToken Is Pegged To */\n    function getNativeAddress() external override view returns(address) {\n        return _native;\n    }\n    \n    /** Returns the amount of Native Asset in this contract */\n    function getNativeBalanceInContract() external view returns(uint256) {\n        return IERC20(_native).balanceOf(address(this));\n    }\n    \n    receive() external payable {\n        require(_allowSelfMinting, \u0027Self Minting is Disabled\u0027);\n        require(_selfMintXToken(), \u0027Error Minting xTokens From BNB Transfer\u0027);\n    }\n\n    // EVENTS\n    event UpdatedBridgeFee(uint256 newBridgeFee);\n    event UpdatedFeeCollector(address newFeeBurner);\n    event UpdatedLiquidityProvider(address newProvider);\n    event UpdatedPurchaseFee(uint256 newPurchaseFee);\n    event UpdatedAllowSelfMinting(bool allow);\n    event UpdatedETHVaultBurner(address newBurner);\n    event UpdatedTransferDenominator(uint256 newDenom);\n    event UpdatedPancakeswapRouter(address newRouter);\n    event BlacklistedLiquidityPool(address LiquidityPool, bool isExcluded);\n    event WithdrawTheMistakesOfOthers(address token, uint256 tokenAmount);\n    event TransferOwnership(address newOwner);\n}\n"}}