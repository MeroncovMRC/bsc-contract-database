{"Address.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\n\nlibrary Address {\n\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256(\u0027\u0027)`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash \u0026\u0026 codehash != 0x0);\n    }\n\n    /**\n     * @dev Replacement for Solidity\u0027s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n\n}\n"},"BTCVault.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"./IDistributor.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Address.sol\";\nimport \"./IERC20.sol\";\nimport \"./IUniswapV2Factory.sol\";\nimport \"./IUniswapV2Router02.sol\";\nimport \"./ReentrantGuard.sol\";\n\n/** \n * Contract: Vault\n * Author: DeFi Mark (Markymark)\n * \n *  This Contract Awards Surge Tokens to holders\n *  weighed by how much Vault is held. \n *  If A User Holds Over 0.01% of Supply They Can Specify\n *  Their Preferred Reward Token\n * \n *  Transfer Fee:  5%\n *  Buy Fee:       5%\n *  Sell Fee:     30%\n * \n *  Buys/Transfers Directly Deletes Tokens From Fees\n * \n *  Sell Fees Go Toward:\n *  83% SurgeBTC Distribution\n *  9% SafeVault+ETHVault Buy+Burn\n *  4% Burn\n *  4% Marketing\n */\ncontract Vault is IERC20, ReentrancyGuard {\n    \n    using SafeMath for uint256;\n    using SafeMath for uint8;\n    using Address for address;\n\n    // token data\n    string constant _name = \"Vault\";\n    string constant _symbol = \"VAULT\";\n    uint8 constant _decimals = 9;\n    \n    // 1 Trillion Max Supply\n    uint256 _totalSupply = 1 * 10**12 * (10 ** _decimals);\n    uint256 public _maxTxAmount = _totalSupply.div(100); // 1% or 10 Billion\n    \n    // balances\n    mapping (address =\u003e uint256) _balances;\n    mapping (address =\u003e mapping (address =\u003e uint256)) _allowances;\n    \n    // Token Lock Structure\n    struct TokenLock {\n        bool isLocked;\n        uint256 startTime;\n        uint256 duration;\n        uint256 nTokens;\n    }\n    \n    // permissions\n    struct Permissions {\n        bool isFeeExempt;\n        bool isTxLimitExempt;\n        bool isDividendExempt;\n        bool isLiquidityPool;\n    }\n    // user -\u003e permissions\n    mapping (address =\u003e Permissions) permissions;\n    \n    // Token Lockers\n    mapping (address =\u003e TokenLock) tokenLockers;\n    \n    // fees\n    uint256 public burnFee = 125;\n    uint256 public reflectionFee = 2750;\n    uint256 public marketingFee = 125;\n    // total fees\n    uint256 totalFeeSells = 3000;\n    uint256 totalFeeBuys = 500;\n    uint256 totalFeeTransfers = 500;\n    uint256 constant feeDenominator = 10000;\n    \n    // Marketing Funds Receiver\n    address public marketingFeeReceiver = 0xC618FDbDd2254f37a44882bD53fD7FB91163A9A7;\n    // CA which buys/burns ETHVault+SafeVault\n    address public burner = 0x7b09C924c31437725ABcA4261849e60AC52b8E91;\n    \n    // Pancakeswap V2 Router\n    IUniswapV2Router02 router;\n    address private pair;\n\n    // gas for distributor\n    IDistributor public distributor;\n    uint256 distributorGas = 1000000;\n    \n    // in charge of swapping\n    bool public swapEnabled = true;\n    uint256 public swapThreshold = _totalSupply.div(2000); // 800,000,000 tokens\n    \n    // true if our threshold decreases with circulating supply\n    bool public canChangeSwapThreshold = false;\n    uint256 public swapThresholdPercentOfCirculatingSupply = 2000;\n    bool inSwap;\n\n    // false to stop the burn\n    bool public burnEnabled = true;\n    modifier swapping() { inSwap = true; _; inSwap = false; }\n    \n    // Uniswap Router V2\n    address private _dexRouter = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\n    \n    // ownership\n    address public _owner;\n    modifier onlyOwner(){require(msg.sender == _owner, \u0027OnlyOwner\u0027); _;}\n    \n    // Token -\u003e BNB\n    address[] path;\n    // BNB -\u003e Token\n    address[] buyPath;\n    \n    // swapper info\n    bool swapperEnabled;\n    bool public _manualSwapperDisabled;\n\n    // initialize some stuff\n    constructor ( address payable _distributor\n    ) {\n        // Pancakeswap V2 Router\n        router = IUniswapV2Router02(_dexRouter);\n        // Liquidity Pool Address for BNB -\u003e Vault\n        pair = IUniswapV2Factory(router.factory()).createPair(router.WETH(), address(this));\n        _allowances[address(this)][address(router)] = _totalSupply;\n        // our dividend Distributor\n        distributor = IDistributor(_distributor);\n        // exempt deployer and contract from fees\n        permissions[msg.sender].isFeeExempt = true;\n        permissions[address(this)].isFeeExempt = true;\n        // exempt important addresses from TX limit\n        permissions[msg.sender].isTxLimitExempt = true;\n        permissions[marketingFeeReceiver].isTxLimitExempt = true;\n        permissions[address(this)].isTxLimitExempt = true;\n        // exempt important addresses from receiving Rewards\n        permissions[pair].isDividendExempt = true;\n        permissions[address(router)].isDividendExempt = true;\n        permissions[address(this)].isDividendExempt = true;\n        // declare LP as Liquidity Pool\n        permissions[pair].isLiquidityPool = true;\n        permissions[address(router)].isLiquidityPool = true;\n        swapperEnabled = true;\n        // approve router of total supply\n        approve(_dexRouter, _totalSupply);\n        approve(address(pair), _totalSupply);\n        _balances[msg.sender] = _totalSupply;\n        // token path\n        path = new address[](2);\n        path[0] = address(this);\n        path[1] = router.WETH();\n        buyPath = new address[](2);\n        buyPath[0] = router.WETH();\n        buyPath[1] = address(this);\n        _owner = msg.sender;\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n\n    receive() external payable {\n        if (msg.sender == address(this) || msg.sender == address(router) || _manualSwapperDisabled) return;\n        if (swapperEnabled) {\n            try router.swapExactETHForTokens{value: msg.value}(\n                0,\n                buyPath,\n                msg.sender,\n                block.timestamp.add(30)\n            ) {} catch {revert(\u0027Failure On Token Purchase\u0027);}\n        }\n    }\n\n    function totalSupply() external view override returns (uint256) { return _totalSupply; }\n    function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }\n    function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }\n    function name() public pure returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public pure returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return _decimals;\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n    \n    /** Approves Router and Pair For Updating Total Supply */\n    function internalApprove() private {\n        _allowances[address(this)][address(router)] = _totalSupply;\n        _allowances[address(this)][address(pair)] = _totalSupply;\n        // update thresholds\n        if (canChangeSwapThreshold) {\n            swapThreshold = _totalSupply.div(swapThresholdPercentOfCirculatingSupply);\n            _maxTxAmount = _totalSupply.div(100);\n        }\n    }\n    \n    /** Approve Total Supply */\n    function approveMax(address spender) external returns (bool) {\n        return approve(spender, _totalSupply);\n    }\n    \n    /** Transfer Function */\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\n        return _transferFrom(msg.sender, recipient, amount);\n    }\n    \n    /** Transfer Function */\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\n        if(_allowances[sender][msg.sender] != _totalSupply){\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount, \"Insufficient Allowance\");\n        }\n\n        return _transferFrom(sender, recipient, amount);\n    }\n    \n    ////////////////////////////////////\n    /////    INTERNAL FUNCTIONS    /////\n    ////////////////////////////////////\n    \n    /** Internal Transfer */\n    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\n        // make standard checks\n        require(recipient != address(0), \"BEP20: Invalid Transfer\");\n        require(amount \u003e 0, \"Zero Amount\");\n        // check if we have reached the transaction limit\n        require(amount \u003c= _maxTxAmount || permissions[sender].isTxLimitExempt, \"TX Limit\");\n        // For Time-Locking Developer Tokens\n        if (tokenLockers[sender].isLocked) {\n            if (tokenLockers[sender].startTime + tokenLockers[sender].duration \u003e block.number) {\n                tokenLockers[sender].nTokens = tokenLockers[sender].nTokens.sub(amount, \u0027Exceeds Token Lock Allowance\u0027);\n            } else {\n                delete tokenLockers[sender];\n            }\n        }\n        // whether transfer succeeded\n        bool success;\n        // amount of tokens received by recipient\n        uint256 amountReceived;\n        // if we\u0027re in swap perform a basic transfer\n        if(inSwap){\n            (amountReceived, success) = handleTransferBody(sender, recipient, amount);\n            emit Transfer(sender, recipient, amountReceived);\n            return success;\n        }\n        \n        // limit gas consumption by splitting up operations\n        if(shouldSwapBack()) {\n            swapBack();\n            (amountReceived, success) = handleTransferBody(sender, recipient, amount);\n        } else {\n            (amountReceived, success) = handleTransferBody(sender, recipient, amount);\n            try distributor.process(distributorGas) {} catch {}\n        }\n        \n        emit Transfer(sender, recipient, amountReceived);\n        return success;\n    }\n    \n    /** Takes Associated Fees and sets holders\u0027 new Share for the Vault Distributor */\n    function handleTransferBody(address sender, address recipient, uint256 amount) internal returns (uint256, bool) {\n        // subtract balance from sender\n        _balances[sender] = _balances[sender].sub(amount, \"Insufficient Balance\");\n        // amount receiver should receive\n        uint256 amountReceived = (permissions[sender].isFeeExempt || permissions[recipient].isFeeExempt) ? amount : takeFee(sender, recipient, amount);\n        // add amount to recipient\n        _balances[recipient] = _balances[recipient].add(amountReceived);\n        // set shares for distributors\n        if(!permissions[sender].isDividendExempt){ \n            distributor.setShare(sender, _balances[sender]);\n        }\n        if(!permissions[recipient].isDividendExempt){ \n            distributor.setShare(recipient, _balances[recipient]);\n        }\n        // return the amount received by receiver\n        return (amountReceived, true);\n    }\n    \n    /** Takes Fee and Stores in contract Or Deletes From Circulation */\n    function takeFee(address sender, address receiver, uint256 amount) internal returns (uint256) {\n        uint256 tFee = permissions[receiver].isLiquidityPool ? totalFeeSells : permissions[sender].isLiquidityPool ? totalFeeBuys : totalFeeTransfers;\n        uint256 feeAmount = amount.mul(tFee).div(feeDenominator);\n        if (permissions[receiver].isLiquidityPool || !burnEnabled) {\n            _balances[address(this)] = _balances[address(this)].add(feeAmount);\n            // fee event\n            emit Transfer(sender, address(this), feeAmount);\n        } else {\n            // update Total Supply\n            _totalSupply = _totalSupply.sub(feeAmount);\n            // approve Router for total supply\n            internalApprove();\n            // fee event\n            emit Transfer(sender, address(0), feeAmount);\n        }\n        return amount.sub(feeAmount);\n    }\n    \n    /** True if we should swap from Vault =\u003e BNB */\n    function shouldSwapBack() internal view returns (bool) {\n        return !permissions[msg.sender].isLiquidityPool\n        \u0026\u0026 !inSwap\n        \u0026\u0026 swapEnabled\n        \u0026\u0026 _balances[address(this)] \u003e swapThreshold;\n    }\n    \n    /**\n     *  Swaps Vault for BNB if threshold is reached and the swap is enabled\n     *  Burns percent of Vault in Contract, delivers percent to marketing\n     *  Swaps The Rest For BNB\n     */\n    function swapBack() private swapping {\n        // tokens allocated to burning\n        uint256 burnAmount = swapThreshold.mul(burnFee).div(totalFeeSells);\n        // burn tokens\n        burnTokens(burnAmount);\n        // tokens allocated to marketing\n        uint256 marketingTokens = swapThreshold.mul(marketingFee).div(totalFeeSells);\n        // send tokens to marketing wallet\n        if (marketingTokens \u003e 0) {\n            _balances[address(this)] = _balances[address(this)].sub(marketingTokens);\n            _balances[marketingFeeReceiver] = _balances[marketingFeeReceiver].add(marketingTokens);\n            if (!permissions[marketingFeeReceiver].isDividendExempt) {\n                distributor.setShare(marketingFeeReceiver, _balances[marketingFeeReceiver]);\n            }\n            emit Transfer(address(this), marketingFeeReceiver, marketingTokens);\n        }\n        // disable receive\n        swapperEnabled = false;\n        // how many are left to swap with\n        uint256 swapAmount = swapThreshold.sub(burnAmount).sub(marketingTokens);\n        // swap tokens for BNB\n        try router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            swapAmount,\n            0,\n            path,\n            address(this),\n            block.timestamp.add(30)\n        ) {} catch{return;}\n        \n        // enable receive\n        swapperEnabled = true;\n        // fuel distributor\n        fuelDistributorAndBurner();\n        // Tell The Blockchain\n        emit SwappedBack(swapAmount, burnAmount, marketingTokens);\n    }\n\n    /** Removes Tokens From Circulation */\n    function burnTokens(uint256 tokenAmount) private returns (bool) {\n        if (!burnEnabled || tokenAmount == 0) {\n            return false;\n        }\n        // update balance of contract\n        _balances[address(this)] = _balances[address(this)].sub(tokenAmount);\n        // update Total Supply\n        _totalSupply = _totalSupply.sub(tokenAmount);\n        // approve Router for total supply\n        internalApprove();\n        // emit Transfer to Blockchain\n        emit Transfer(address(this), address(0), tokenAmount);\n        return true;\n    }\n    \n    /** Deposits BNB To Distributor And Burner*/\n    function fuelDistributorAndBurner() private returns (bool) {\n        // allocate percentage to buy/burn ETHVault+SafeVault\n        uint256 forBurning = address(this).balance.div(10);\n        uint256 forDistribution = address(this).balance.sub(forBurning);\n        bool succ; bool succTwo;\n        // send bnb to distributor\n        (succ,) = payable(address(distributor)).call{value: forDistribution}(\"\");\n        (succTwo,) = payable(address(burner)).call{value: forBurning}(\"\");\n        emit FueledContracts(forBurning, forDistribution);\n        return succ \u0026\u0026 succTwo;\n    }\n    \n    ////////////////////////////////////\n    /////    EXTERNAL FUNCTIONS    /////\n    ////////////////////////////////////\n    \n    \n    /** Deletes the portion of holdings from sender */\n    function deleteBag(uint256 nTokens) external nonReentrant returns(bool){\n        // make sure you are burning enough tokens\n        require(nTokens \u003e 0 \u0026\u0026 _balances[msg.sender] \u003e= nTokens, \u0027Insufficient Balance\u0027);\n        // remove tokens from sender\n        _balances[msg.sender] = _balances[msg.sender].sub(nTokens);\n        // remove tokens from total supply\n        _totalSupply = _totalSupply.sub(nTokens);\n        // set share to be new balance\n        if (!permissions[msg.sender].isDividendExempt) {\n            distributor.setShare(msg.sender, _balances[msg.sender]);\n        }\n        // approve Router for the new total supply\n        internalApprove();\n        // tell blockchain\n        emit Transfer(msg.sender, address(0), nTokens);\n        return true;\n    }\n    \n    \n    \n    ////////////////////////////////////\n    /////      READ FUNCTIONS      /////\n    ////////////////////////////////////\n    \n    \n    \n    /** Is Holder Exempt From Fees */\n    function getIsFeeExempt(address holder) public view returns (bool) {\n        return permissions[holder].isFeeExempt;\n    }\n    \n    /** Is Holder Exempt From Dividends */\n    function getIsDividendExempt(address holder) public view returns (bool) {\n        return permissions[holder].isDividendExempt;\n    }\n    \n    /** Is Holder Exempt From Transaction Limit */\n    function getIsTxLimitExempt(address holder) public view returns (bool) {\n        return permissions[holder].isTxLimitExempt;\n    }\n    \n    /** True If Tokens Are Locked For Target, False If Unlocked */\n    function isTokenLocked(address target) external view returns (bool) {\n        return tokenLockers[target].isLocked;\n    }\n\n    /** Time In Blocks Until Tokens Unlock For Target User */    \n    function timeLeftUntilTokensUnlock(address target) public view returns (uint256) {\n        if (tokenLockers[target].isLocked) {\n            uint256 endTime = tokenLockers[target].startTime.add(tokenLockers[target].duration);\n            if (endTime \u003c= block.number) return 0;\n            return endTime.sub(block.number);\n        } else {\n            return 0;\n        }\n    }\n    \n    /** Number Of Tokens A Locked Wallet Has Left To Spend Before Time Expires */\n    function nTokensLeftToSpendForLockedWallet(address wallet) external view returns (uint256) {\n        return tokenLockers[wallet].nTokens;\n    }\n    \n    \n    ////////////////////////////////////\n    /////     OWNER FUNCTIONS      /////\n    ////////////////////////////////////\n    \n\n    /** Sets Various Fees */\n    function setFees(uint256 _burnFee, uint256 _reflectionFee, uint256 _marketingFee, uint256 _buyFee, uint256 _transferFee) external onlyOwner {\n        burnFee = _burnFee;\n        reflectionFee = _reflectionFee;\n        marketingFee = _marketingFee;\n        totalFeeSells = _burnFee.add(_reflectionFee).add(_marketingFee);\n        totalFeeBuys = _buyFee;\n        totalFeeTransfers = _transferFee;\n        require(_buyFee \u003c= feeDenominator/2);\n        require(totalFeeSells \u003c= feeDenominator/2);\n        require(_transferFee \u003c= feeDenominator/2);\n        emit UpdateFees(_buyFee, totalFeeSells, _transferFee, _burnFee, _reflectionFee);\n    }\n    \n    /** Set Exemption For Holder */\n    function setExemptions(address holder, bool feeExempt, bool txLimitExempt, bool _isLiquidityPool) external onlyOwner {\n        require(holder != address(0));\n        permissions[holder].isFeeExempt = feeExempt;\n        permissions[holder].isTxLimitExempt = txLimitExempt;\n        permissions[holder].isLiquidityPool = _isLiquidityPool;\n        emit SetExemptions(holder, feeExempt, txLimitExempt, _isLiquidityPool);\n    }\n    \n    /** Set Holder To Be Exempt From Dividends */\n    function setIsDividendExempt(address holder, bool exempt) external onlyOwner {\n        permissions[holder].isDividendExempt = exempt;\n        if(exempt) {\n            distributor.setShare(holder, 0);\n        } else {\n            distributor.setShare(holder, _balances[holder]);\n        }\n    }\n    \n    /** Set Settings related to Swaps */\n    function setSwapBackSettings(bool _swapEnabled, uint256 _swapThreshold, bool _canChangeSwapThreshold, uint256 _percentOfCirculatingSupply, bool _burnEnabled) external onlyOwner {\n        swapEnabled = _swapEnabled;\n        swapThreshold = _swapThreshold;\n        canChangeSwapThreshold = _canChangeSwapThreshold;\n        swapThresholdPercentOfCirculatingSupply = _percentOfCirculatingSupply;\n        burnEnabled = _burnEnabled;\n        emit UpdateSwapBackSettings(_swapEnabled, _swapThreshold, _canChangeSwapThreshold, _burnEnabled);\n    }\n\n    /** Should We Transfer To Marketing */\n    function setMarketingFundReceiver(address _marketingFeeReceiver) external onlyOwner {\n        require(_marketingFeeReceiver != address(0), \u0027Invalid Address\u0027);\n        permissions[marketingFeeReceiver].isTxLimitExempt = false;\n        marketingFeeReceiver = _marketingFeeReceiver;\n        permissions[_marketingFeeReceiver].isTxLimitExempt = true;\n        emit UpdateTransferToMarketing(_marketingFeeReceiver);\n    }\n    \n    /** Updates Burner Contract */\n    function setVaultBurnerContract(address newVaultBurner) external onlyOwner {\n        burner = newVaultBurner;\n        emit UpdateVaultBurner(newVaultBurner);\n    }\n    \n    /** Disables or Enables the swapping mechanism inside of BTCVault */\n    function setManualSwapperDisabled(bool manualSwapperDisabled) external onlyOwner {\n        _manualSwapperDisabled = manualSwapperDisabled;\n        emit UpdatedManualSwapperDisabled(manualSwapperDisabled);\n    }\n    \n    /** Updates Gas Required For Redistribution */\n    function setDistributorGas(uint256 newGas) external onlyOwner {\n        require(newGas \u003e= 10**5 \u0026\u0026 newGas \u003c= 10**7, \u0027Out Of Range\u0027);\n        distributorGas = newGas;\n        emit UpdatedDistributorGas(newGas);\n    }\n    \n    /** Updates The Pancakeswap Router */\n    function setDexRouter(address nRouter) external onlyOwner{\n        require(nRouter != _dexRouter \u0026\u0026 nRouter != address(0), \u0027Invalid Address\u0027);\n        _dexRouter = nRouter;\n        router = IUniswapV2Router02(nRouter);\n        address _newPair = IUniswapV2Factory(router.factory())\n            .createPair(address(this), router.WETH());\n        pair = _newPair;\n        permissions[_newPair].isLiquidityPool = true;\n        permissions[_newPair].isDividendExempt = true;\n        path[1] = router.WETH();\n        internalApprove();\n        emit UpdatePancakeswapRouter(nRouter);\n    }\n\n    /** Set Address For Surge Distributor */\n    function setDistributor(address newDistributor) external onlyOwner {\n        require(newDistributor != address(distributor) \u0026\u0026 newDistributor != address(0), \u0027Invalid Address\u0027);\n        distributor = IDistributor(payable(newDistributor));\n        emit SwappedDistributor(newDistributor);\n    }\n\n    /** Lock Tokens For A User Over A Set Amount of Time */\n    function lockTokens(address target, uint256 lockDurationInBlocks, uint256 tokenAllowance) external onlyOwner {\n        require(lockDurationInBlocks \u003c= 10512000, \u0027Invalid Duration\u0027);\n        require(timeLeftUntilTokensUnlock(target) \u003c= 100, \u0027Not Time\u0027);\n        tokenLockers[target] = TokenLock({\n            isLocked:true,\n            startTime:block.number,\n            duration:lockDurationInBlocks,\n            nTokens:tokenAllowance\n        });\n        emit TokensLockedForWallet(target, lockDurationInBlocks, tokenAllowance);\n    }\n    \n    /** Transfers Ownership of Vault Contract */\n    function transferOwnership(address newOwner) external onlyOwner {\n        require(_owner != newOwner);\n        _owner = newOwner;\n        emit TransferOwnership(newOwner);\n    }\n\n    \n    ////////////////////////////////////\n    //////        EVENTS          //////\n    ////////////////////////////////////\n    \n    \n    event TransferOwnership(address newOwner);\n    event UpdatedDistributorGas(uint256 newGas);\n    event SwappedDistributor(address newDistributor);\n    event UpdateVaultBurner(address newVaultBurner);\n    event UpdatedManualSwapperDisabled(bool disabled);\n    event FueledContracts(uint256 bnbForBurning, uint256 bnbForReflections);\n    event SetExemptions(address holder, bool feeExempt, bool txLimitExempt, bool isLiquidityPool);\n    event SwappedBack(uint256 tokensSwapped, uint256 amountBurned, uint256 marketingTokens);\n    event UpdateTransferToMarketing(address fundReceiver);\n    event UpdateSwapBackSettings(bool swapEnabled, uint256 swapThreshold, bool canChangeSwapThreshold, bool burnEnabled);\n    event UpdatePancakeswapRouter(address newRouter);\n    event TokensLockedForWallet(address wallet, uint256 duration, uint256 allowanceToSpend);\n    event UpdateFees(uint256 buyFee, uint256 sellFee, uint256 transferFee, uint256 burnFee, uint256 reflectionFee);\n    \n}\n"},"IDistributor.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\ninterface IDistributor {\n    function setShare(address shareholder, uint256 amount) external;\n    function process(uint256 gas) external;\n}"},"IERC20.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\ninterface IERC20 {\n\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n    \n    /**\n     * @dev Returns the number of decimal places\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"},"IUniswapV2Factory.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}"},"IUniswapV2Router02.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    payable\n    returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n    external\n    payable\n    returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"},"ReentrantGuard.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nabstract contract ReentrancyGuard {\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private _status;\n    constructor () {\n        _status = _NOT_ENTERED;\n    }\n\n    modifier nonReentrant() {\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n        _status = _ENTERED;\n        _;\n        _status = _NOT_ENTERED;\n    }\n}\n"},"SafeMath.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"}}