{"address-utils.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\n/**\n * @notice Based on:\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\n * Requires EIP-1052.\n * @dev Utility library of inline functions on addresses.\n */\nlibrary AddressUtils\n{\n\n  /**\n   * @dev Returns whether the target address is a contract.\n   * @param _addr Address to check.\n   * @return addressCheck True if _addr is a contract, false if not.\n   */\n  function isContract(\n    address _addr\n  )\n    internal\n    view\n    returns (bool addressCheck)\n  {\n    // This method relies in extcodesize, which returns 0 for contracts in\n    // construction, since the code is only stored at the end of the\n    // constructor execution.\n\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n    // for accounts without code, i.e. `keccak256(\u0027\u0027)`\n    bytes32 codehash;\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n    assembly { codehash := extcodehash(_addr) } // solhint-disable-line\n    addressCheck = (codehash != 0x0 \u0026\u0026 codehash != accountHash);\n  }\n\n}\n"},"Base64.sol":{"content":"/// SPDX-License-Identifier: MIT\n/// @title Base64\n/// @notice Provides a function for encoding some bytes in base64\n/// @author Brecht Devos \u003cbrecht@loopring.org\u003e\n\npragma solidity ^0.8.0;\n\nlibrary Base64 {\n    bytes internal constant TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    /// @notice Encodes some bytes to the base64 representation\n    function encode(bytes memory data) internal pure returns (string memory) {\n        uint256 len = data.length;\n        if (len == 0) return \"\";\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((len + 2) / 3);\n\n        // Add some extra buffer at the end\n        bytes memory result = new bytes(encodedLen + 32);\n\n        bytes memory table = TABLE;\n\n        assembly {\n            let tablePtr := add(table, 1)\n            let resultPtr := add(result, 32)\n\n            for {\n                let i := 0\n            } lt(i, len) {\n\n            } {\n                i := add(i, 3)\n                let input := and(mload(add(data, i)), 0xffffff)\n\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\n                out := shl(8, out)\n                out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\n                out := shl(8, out)\n                out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\n                out := shl(8, out)\n                out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\n                out := shl(224, out)\n\n                mstore(resultPtr, out)\n\n                resultPtr := add(resultPtr, 4)\n            }\n\n            switch mod(len, 3)\n            case 1 {\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n            }\n            case 2 {\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\n            }\n\n            mstore(result, encodedLen)\n        }\n\n        return string(result);\n    }\n}"},"IAttr.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"./ownable.sol\";\n\nstruct NftInfo{\n     string uri;  \n     uint256 tokenId; \n     uint256 templateId; \n     uint256 typeId;  \n     uint16 atk; \n     uint16 ce; \n     uint16 cp;  \n     uint16 hp; \n     uint16 fatigue;\n     string name; \n     uint16 campId; \n     uint16 level; \n}\n\ninterface IAttr\n{\n\n  function getNftInfoMap(uint256 tokenId) external view returns(NftInfo memory);\n\n  function delNftInfo(uint256 tokenId) external;\n  \n  function genearteNftInfo(uint256 typeId) external returns(NftInfo memory);\n  \n  function bulkGetNftInfo(uint256[] calldata tokenIds) external view returns (NftInfo[] memory);\n\n}\n\ncontract Attr is Ownable{\n  \n  IAttr public nftAttrAddress;\n  function updateNftAttrAddress(address newAddress) public onlyOwner {\n    require(address(nftAttrAddress) != newAddress, \"The attrAddress \");\n    nftAttrAddress = IAttr(newAddress);\n  }\n  \n}"},"IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\n/**\n * @dev A standard for detecting smart contract interfaces. \n * See: https://eips.ethereum.org/EIPS/eip-165.\n */\ninterface IERC165\n{\n\n  /**\n   * @dev Checks if the smart contract includes a specific interface.\n   * This function uses less than 30,000 gas.\n   * @param _interfaceID The interface identifier, as specified in ERC-165.\n   * @return True if _interfaceID is supported, false otherwise.\n   */\n  function supportsInterface(\n    bytes4 _interfaceID\n  )\n    external\n    view\n    returns (bool);\n    \n}\n"},"IERC721.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\n/**\n * @dev ERC-721 non-fungible token standard.\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\n */\ninterface IERC721\n{\n\n  /**\n   * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\n   * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\n   * number of NFTs may be created and assigned without emitting Transfer. At the time of any\n   * transfer, the approved address for that NFT (if any) is reset to none.\n   */\n  event Transfer(\n    address indexed _from,\n    address indexed _to,\n    uint256 indexed _tokenId\n  );\n\n  /**\n   * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\n   * address indicates there is no approved address. When a Transfer event emits, this also\n   * indicates that the approved address for that NFT (if any) is reset to none.\n   */\n  event Approval(\n    address indexed _owner,\n    address indexed _approved,\n    uint256 indexed _tokenId\n  );\n\n  /**\n   * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\n   * all NFTs of the owner.\n   */\n  event ApprovalForAll(\n    address indexed _owner,\n    address indexed _operator,\n    bool _approved\n  );\n\n  /**\n   * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\n   * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\n   * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\n   * function checks if `_to` is a smart contract (code size \u003e 0). If so, it calls\n   * `onERC721Received` on `_to` and throws if the return value is not\n   * `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\n   * @dev Transfers the ownership of an NFT from one address to another address.\n   * @param _from The current owner of the NFT.\n   * @param _to The new owner.\n   * @param _tokenId The NFT to transfer.\n   * @param _data Additional data with no specified format, sent in call to `_to`.\n   */\n  function safeTransferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    bytes calldata _data\n  )\n    external;\n\n  /**\n   * @notice This works identically to the other function with an extra data parameter, except this\n   * function just sets data to \"\"\n   * @dev Transfers the ownership of an NFT from one address to another address.\n   * @param _from The current owner of the NFT.\n   * @param _to The new owner.\n   * @param _tokenId The NFT to transfer.\n   */\n  function safeTransferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  )\n    external;\n\n  /**\n   * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\n   * they may be permanently lost.\n   * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n   * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\n   * address. Throws if `_tokenId` is not a valid NFT.\n   * @param _from The current owner of the NFT.\n   * @param _to The new owner.\n   * @param _tokenId The NFT to transfer.\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  )\n    external;\n\n  /**\n   * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\n   * the current NFT owner, or an authorized operator of the current owner.\n   * @param _approved The new approved NFT controller.\n   * @dev Set or reaffirm the approved address for an NFT.\n   * @param _tokenId The NFT to approve.\n   */\n  function approve(\n    address _approved,\n    uint256 _tokenId\n  )\n    external;\n\n  /**\n   * @notice The contract MUST allow multiple operators per owner.\n   * @dev Enables or disables approval for a third party (\"operator\") to manage all of\n   * `msg.sender`\u0027s assets. It also emits the ApprovalForAll event.\n   * @param _operator Address to add to the set of authorized operators.\n   * @param _approved True if the operators is approved, false to revoke approval.\n   */\n  function setApprovalForAll(\n    address _operator,\n    bool _approved\n  )\n    external;\n\n  /**\n   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\n   * considered invalid, and this function throws for queries about the zero address.\n   * @notice Count all NFTs assigned to an owner.\n   * @param _owner Address for whom to query the balance.\n   * @return Balance of _owner.\n   */\n  function balanceOf(\n    address _owner\n  )\n    external\n    view\n    returns (uint256);\n\n  /**\n   * @notice Find the owner of an NFT.\n   * @dev Returns the address of the owner of the NFT. NFTs assigned to the zero address are\n   * considered invalid, and queries about them do throw.\n   * @param _tokenId The identifier for an NFT.\n   * @return Address of _tokenId owner.\n   */\n  function ownerOf(\n    uint256 _tokenId\n  )\n    external\n    view\n    returns (address);\n\n  /**\n   * @notice Throws if `_tokenId` is not a valid NFT.\n   * @dev Get the approved address for a single NFT.\n   * @param _tokenId The NFT to find the approved address for.\n   * @return Address that _tokenId is approved for.\n   */\n  function getApproved(\n    uint256 _tokenId\n  )\n    external\n    view\n    returns (address);\n\n  /**\n   * @notice Query if an address is an authorized operator for another address.\n   * @dev Returns true if `_operator` is an approved operator for `_owner`, false otherwise.\n   * @param _owner The address that owns the NFTs.\n   * @param _operator The address that acts on behalf of the owner.\n   * @return True if approved for all, false otherwise.\n   */\n  function isApprovedForAll(\n    address _owner,\n    address _operator\n  )\n    external\n    view\n    returns (bool);\n\n}\n"},"IERC721Enumerable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``\u0027s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}"},"IERC721Metadata.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\n/**\n * @dev Optional metadata extension for ERC-721 non-fungible token standard.\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\n */\ninterface IERC721Metadata\n{\n\n  /**\n   * @dev Returns a descriptive name for a collection of NFTs in this contract.\n   * @return _name Representing name.\n   */\n  function name()\n    external\n    view\n    returns (string memory _name);\n\n  /**\n   * @dev Returns a abbreviated name for a collection of NFTs in this contract.\n   * @return _symbol Representing symbol.\n   */\n  function symbol()\n    external\n    view\n    returns (string memory _symbol);\n\n  /**\n   * @dev Returns a distinct Uniform Resource Identifier (URI) for a given asset. It Throws if\n   * `_tokenId` is not a valid NFT. URIs are defined in RFC3986. The URI may point to a JSON file\n   * that conforms to the \"ERC721 Metadata JSON Schema\".\n   * @return URI of _tokenId.\n   */\n  function tokenURI(uint256 _tokenId)\n    external\n    view\n    returns (string memory);\n\n}\n"},"IERC721TokenReceiver.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\n/**\n * @dev ERC-721 interface for accepting safe transfers.\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\n */\ninterface IERC721TokenReceiver\n{\n\n  /**\n   * @notice The contract address is always the message sender. A wallet/broker/auction application\n   * MUST implement the wallet interface if it will accept safe transfers.\n   * @dev Handle the receipt of a NFT. The ERC721 smart contract calls this function on the\n   * recipient after a `transfer`. This function MAY throw to revert and reject the transfer. Return\n   * of other than the magic value MUST result in the transaction being reverted.\n   * Returns `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))` unless throwing.\n   * @param _operator The address which called `safeTransferFrom` function.\n   * @param _from The address which previously owned the token.\n   * @param _tokenId The NFT identifier which is being transferred.\n   * @param _data Additional data with no specified format.\n   * @return Returns `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n   */\n  function onERC721Received(\n    address _operator,\n    address _from,\n    uint256 _tokenId,\n    bytes calldata _data\n  )\n    external\n    returns(bytes4);\n\n}\n"},"nf-token-metadata.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"./nf-token.sol\";\nimport \"./IERC721Metadata.sol\";\nimport \"./IERC721Enumerable.sol\";\n\n/**\n * @dev Optional metadata implementation for ERC-721 non-fungible token standard.\n */\nabstract contract NFTokenMetadata is\n  NFToken,\n  IERC721Metadata,\n  IERC721Enumerable\n{\n\n  /**\n   * @dev A descriptive name for a collection of NFTs.\n   */\n  string internal nftName;\n\n  /**\n   * @dev An abbreviated name for NFTokens.\n   */\n  string internal nftSymbol;\n\n  /**\n   * @dev Mapping from NFT ID to metadata uri.\n   */\n  mapping (uint256 =\u003e string) internal idToUri;\n\n  /**\n   * @notice When implementing this contract don\u0027t forget to set nftName and nftSymbol.\n   * @dev Contract constructor.\n   */\n  constructor()\n  {\n    supportedInterfaces[0x5b5e139f] = true; // ERC721Metadata\n  }\n\n  /**\n   * @dev Returns a descriptive name for a collection of NFTokens.\n   * @return _name Representing name.\n   */\n  function name()\n    external\n    override\n    view\n    returns (string memory _name)\n  {\n    _name = nftName;\n  }\n\n  /**\n   * @dev Returns an abbreviated name for NFTokens.\n   * @return _symbol Representing symbol.\n   */\n  function symbol()\n    external\n    override\n    view\n    returns (string memory _symbol)\n  {\n    _symbol = nftSymbol;\n  }\n\n  /**\n   * @notice This is an internal function which should be called from user-implemented external\n   * burn function. Its purpose is to show and properly initialize data structures when using this\n   * implementation. Also, note that this burn implementation allows the minter to re-mint a burned\n   * NFT.\n   * @dev Burns a NFT.\n   * @param _tokenId ID of the NFT to be burned.\n   */\n  function _burn(\n    uint256 _tokenId\n  )\n    internal\n    override\n    virtual\n  {\n    super._burn(_tokenId);\n\n    delete idToUri[_tokenId];\n  }\n\n  /**\n   * @notice This is an internal function which should be called from user-implemented external\n   * function. Its purpose is to show and properly initialize data structures when using this\n   * implementation.\n   */\n  function _setTokenUri(\n    uint256 _tokenId,\n    string calldata i\n  )\n    internal\n    // validNFToken(_tokenId)\n  {\n    idToUri[_tokenId] = i;\n  }\n\n}\n"},"nf-token.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721TokenReceiver.sol\";\nimport \"./supports-interface.sol\";\nimport \"./address-utils.sol\";\n\n/**\n * @dev Implementation of ERC-721 non-fungible token standard.\n */\ncontract NFToken is\n  IERC721,\n  SupportsInterface\n{\n  using AddressUtils for address;\n\n  /**\n   * @dev List of revert message codes. Implementing dApp should handle showing the correct message.\n   * Based on 0xcert framework error codes.\n   */\n  string constant ZERO_ADDRESS = \"003001\";\n  string constant NOT_VALID_NFT = \"003002\";\n  string constant NOT_OWNER_OR_OPERATOR = \"003003\";\n  string constant NOT_OWNER_APPROVED_OR_OPERATOR = \"003004\";\n  string constant NOT_ABLE_TO_RECEIVE_NFT = \"003005\";\n  string constant NFT_ALREADY_EXISTS = \"003006\";\n  string constant NOT_OWNER = \"003007\";\n  string constant IS_OWNER = \"003008\";\n\n  /**\n   * @dev Magic value of a smart contract that can receive NFT.\n   * Equal to: bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")).\n   */\n  bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\n\n  /**\n   * @dev A mapping from NFT ID to the address that owns it.\n   */\n  mapping (uint256 =\u003e address) internal idToOwner;\n\n  /**\n   * @dev Mapping from NFT ID to approved address.\n   */\n  mapping (uint256 =\u003e address) internal idToApproval;\n\n   /**\n   * @dev Mapping from owner address to count of their tokens.\n   */\n  mapping (address =\u003e uint256) private ownerToNFTokenCount;\n\n  /**\n   * @dev Mapping from owner address to mapping of operator addresses.\n   */\n  mapping (address =\u003e mapping (address =\u003e bool)) internal ownerToOperators;\n\n  /**\n   * @dev Guarantees that the msg.sender is an owner or operator of the given NFT.\n   * @param _tokenId ID of the NFT to validate.\n   */\n  modifier canOperate(\n    uint256 _tokenId\n  )\n  {\n    address tokenOwner = idToOwner[_tokenId];\n    require(\n      tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender],\n      NOT_OWNER_OR_OPERATOR\n    );\n    _;\n  }\n\n  /**\n   * @dev Guarantees that the msg.sender is allowed to transfer NFT.\n   * @param _tokenId ID of the NFT to transfer.\n   */\n  modifier canTransfer(\n    uint256 _tokenId\n  )\n  {\n    address tokenOwner = idToOwner[_tokenId];\n    require(\n      tokenOwner == msg.sender\n      || idToApproval[_tokenId] == msg.sender\n      || ownerToOperators[tokenOwner][msg.sender],\n      NOT_OWNER_APPROVED_OR_OPERATOR\n    );\n    _;\n  }\n\n  /**\n   * @dev Guarantees that _tokenId is a valid Token.\n   * @param _tokenId ID of the NFT to validate.\n   */\n  modifier validNFToken(\n    uint256 _tokenId\n  )\n  {\n    require(idToOwner[_tokenId] != address(0), NOT_VALID_NFT);\n    _;\n  }\n\n  /**\n   * @dev Contract constructor.\n   */\n  constructor()\n  {\n    supportedInterfaces[0x80ac58cd] = true; // ERC721\n  }\n\n  /**\n   * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\n   * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\n   * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\n   * function checks if `_to` is a smart contract (code size \u003e 0). If so, it calls\n   * `onERC721Received` on `_to` and throws if the return value is not\n   * `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\n   * @dev Transfers the ownership of an NFT from one address to another address. This function can\n   * be changed to payable.\n   * @param _from The current owner of the NFT.\n   * @param _to The new owner.\n   * @param _tokenId The NFT to transfer.\n   * @param _data Additional data with no specified format, sent in call to `_to`.\n   */\n  function safeTransferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    bytes calldata _data\n  )\n    external\n    override\n  {\n    _safeTransferFrom(_from, _to, _tokenId, _data);\n  }\n\n  /**\n   * @notice This works identically to the other function with an extra data parameter, except this\n   * function just sets data to \"\".\n   * @dev Transfers the ownership of an NFT from one address to another address. This function can\n   * be changed to payable.\n   * @param _from The current owner of the NFT.\n   * @param _to The new owner.\n   * @param _tokenId The NFT to transfer.\n   */\n  function safeTransferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  )\n    external\n    override\n  {\n    _safeTransferFrom(_from, _to, _tokenId, \"\");\n  }\n\n  /**\n   * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\n   * they may be permanently lost.\n   * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n   * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\n   * address. Throws if `_tokenId` is not a valid NFT. This function can be changed to payable.\n   * @param _from The current owner of the NFT.\n   * @param _to The new owner.\n   * @param _tokenId The NFT to transfer.\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  )\n    external\n    override\n    canTransfer(_tokenId)\n    validNFToken(_tokenId)\n  {\n    address tokenOwner = idToOwner[_tokenId];\n    require(tokenOwner == _from, NOT_OWNER);\n    require(_to != address(0), ZERO_ADDRESS);\n\n    _transfer(_to, _tokenId);\n  }\n\n  /**\n   * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\n   * the current NFT owner, or an authorized operator of the current owner.\n   * @dev Set or reaffirm the approved address for an NFT. This function can be changed to payable.\n   * @param _approved Address to be approved for the given NFT ID.\n   * @param _tokenId ID of the token to be approved.\n   */\n  function approve(\n    address _approved,\n    uint256 _tokenId\n  )\n    external\n    override\n    canOperate(_tokenId)\n    validNFToken(_tokenId)\n  {\n    address tokenOwner = idToOwner[_tokenId];\n    require(_approved != tokenOwner, IS_OWNER);\n\n    idToApproval[_tokenId] = _approved;\n    emit Approval(tokenOwner, _approved, _tokenId);\n  }\n\n  /**\n   * @notice This works even if sender doesn\u0027t own any tokens at the time.\n   * @dev Enables or disables approval for a third party (\"operator\") to manage all of\n   * `msg.sender`\u0027s assets. It also emits the ApprovalForAll event.\n   * @param _operator Address to add to the set of authorized operators.\n   * @param _approved True if the operators is approved, false to revoke approval.\n   */\n  function setApprovalForAll(\n    address _operator,\n    bool _approved\n  )\n    external\n    override\n  {\n    ownerToOperators[msg.sender][_operator] = _approved;\n    emit ApprovalForAll(msg.sender, _operator, _approved);\n  }\n\n  /**\n   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\n   * considered invalid, and this function throws for queries about the zero address.\n   * @param _owner Address for whom to query the balance.\n   * @return Balance of _owner.\n   */\n  function balanceOf(\n    address _owner\n  )\n    external\n    override\n    view\n    returns (uint256)\n  {\n    require(_owner != address(0), ZERO_ADDRESS);\n    return _getOwnerNFTCount(_owner);\n  }\n\n  /**\n   * @dev Returns the address of the owner of the NFT. NFTs assigned to the zero address are\n   * considered invalid, and queries about them do throw.\n   * @param _tokenId The identifier for an NFT.\n   * @return _owner Address of _tokenId owner.\n   */\n  function ownerOf(\n    uint256 _tokenId\n  )\n    external\n    override\n    view\n    returns (address _owner)\n  {\n    _owner = idToOwner[_tokenId];\n    require(_owner != address(0), NOT_VALID_NFT);\n  }\n\n  /**\n   * @notice Throws if `_tokenId` is not a valid NFT.\n   * @dev Get the approved address for a single NFT.\n   * @param _tokenId ID of the NFT to query the approval of.\n   * @return Address that _tokenId is approved for.\n   */\n  function getApproved(\n    uint256 _tokenId\n  )\n    external\n    override\n    view\n    validNFToken(_tokenId)\n    returns (address)\n  {\n    return idToApproval[_tokenId];\n  }\n\n  /**\n   * @dev Checks if `_operator` is an approved operator for `_owner`.\n   * @param _owner The address that owns the NFTs.\n   * @param _operator The address that acts on behalf of the owner.\n   * @return True if approved for all, false otherwise.\n   */\n  function isApprovedForAll(\n    address _owner,\n    address _operator\n  )\n    external\n    override\n    view\n    returns (bool)\n  {\n    return ownerToOperators[_owner][_operator];\n  }\n\n  /**\n   * @notice Does NO checks.\n   * @dev Actually performs the transfer.\n   * @param _to Address of a new owner.\n   * @param _tokenId The NFT that is being transferred.\n   */\n  function _transfer(\n    address _to,\n    uint256 _tokenId\n  )\n    internal\n  {\n    address from = idToOwner[_tokenId];\n    _clearApproval(_tokenId);\n\n    _removeNFToken(from, _tokenId);\n    _addNFToken(_to, _tokenId);\n\n    emit Transfer(from, _to, _tokenId);\n  }\n\n  /**\n   * @notice This is an internal function which should be called from user-implemented external\n   * mint function. Its purpose is to show and properly initialize data structures when using this\n   * implementation.\n   * @dev Mints a new NFT.\n   * @param _to The address that will own the minted NFT.\n   * @param _tokenId of the NFT to be minted by the msg.sender.\n   */\n  function _mint(\n    address _to,\n    uint256 _tokenId\n  )\n    internal\n    virtual\n  {\n    require(_to != address(0), ZERO_ADDRESS);\n    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\n\n    _addNFToken(_to, _tokenId);\n\n    emit Transfer(address(0), _to, _tokenId);\n  }\n\n  /**\n   * @notice This is an internal function which should be called from user-implemented external burn\n   * function. Its purpose is to show and properly initialize data structures when using this\n   * implementation. Also, note that this burn implementation allows the minter to re-mint a burned\n   * NFT.\n   * @dev Burns a NFT.\n   * @param _tokenId ID of the NFT to be burned.\n   */\n  function _burn(\n    uint256 _tokenId\n  )\n    internal\n    virtual\n    validNFToken(_tokenId)\n  {\n    address tokenOwner = idToOwner[_tokenId];\n    _clearApproval(_tokenId);\n    _removeNFToken(tokenOwner, _tokenId);\n    emit Transfer(tokenOwner, address(0), _tokenId);\n  }\n\n  /**\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\n   * @dev Removes a NFT from owner.\n   * @param _from Address from which we want to remove the NFT.\n   * @param _tokenId Which NFT we want to remove.\n   */\n  function _removeNFToken(\n    address _from,\n    uint256 _tokenId\n  )\n    internal\n    virtual\n  {\n    require(idToOwner[_tokenId] == _from, NOT_OWNER);\n    ownerToNFTokenCount[_from] -= 1;\n    delete idToOwner[_tokenId];\n  }\n\n  /**\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\n   * @dev Assigns a new NFT to owner.\n   * @param _to Address to which we want to add the NFT.\n   * @param _tokenId Which NFT we want to add.\n   */\n  function _addNFToken(\n    address _to,\n    uint256 _tokenId\n  )\n    internal\n    virtual\n  {\n    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\n\n    idToOwner[_tokenId] = _to;\n    ownerToNFTokenCount[_to] += 1;\n  }\n\n  /**\n   * @dev Helper function that gets NFT count of owner. This is needed for overriding in enumerable\n   * extension to remove double storage (gas optimization) of owner NFT count.\n   * @param _owner Address for whom to query the count.\n   * @return Number of _owner NFTs.\n   */\n  function _getOwnerNFTCount(\n    address _owner\n  )\n    internal\n    virtual\n    view\n    returns (uint256)\n  {\n    return ownerToNFTokenCount[_owner];\n  }\n\n  /**\n   * @dev Actually perform the safeTransferFrom.\n   * @param _from The current owner of the NFT.\n   * @param _to The new owner.\n   * @param _tokenId The NFT to transfer.\n   * @param _data Additional data with no specified format, sent in call to `_to`.\n   */\n  function _safeTransferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    bytes memory _data\n  )\n    private\n    canTransfer(_tokenId)\n    validNFToken(_tokenId)\n  {\n    address tokenOwner = idToOwner[_tokenId];\n    require(tokenOwner == _from, NOT_OWNER);\n    require(_to != address(0), ZERO_ADDRESS);\n\n    _transfer(_to, _tokenId);\n\n    if (_to.isContract())\n    {\n      bytes4 retval = IERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\n      require(retval == MAGIC_ON_ERC721_RECEIVED, NOT_ABLE_TO_RECEIVE_NFT);\n    }\n  }\n\n  /**\n   * @dev Clears the current approval of a given NFT ID.\n   * @param _tokenId ID of the NFT to be transferred.\n   */\n  function _clearApproval(\n    uint256 _tokenId\n  )\n    private\n  {\n    delete idToApproval[_tokenId];\n  }\n\n}\n"},"nft.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\n// import \"https://github.com/0xcert/ethereum-erc721/src/contracts/tokens/nf-token-metadata.sol\";\n// import \"https://github.com/0xcert/ethereum-erc721/blob/master/src/contracts/tokens/nf-token-metadata.sol\";\n// import \"https://github.com/0xcert/ethereum-erc721/src/contracts/ownership/ownable.sol\";\n\nimport \"./nf-token-metadata.sol\";\nimport \"./safemath.sol\";\nimport \"./ownable.sol\";\n// import \"./IAttr.sol\";\n\ninterface IURI {\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\ncontract MBNFT is NFTokenMetadata, Ownable, Context {\n  using SafeMath for uint256;\n\n  constructor() {\n    nftName = \"MonsterNFT\";\n    nftSymbol = \"MBNFT\";\n    updateAdminAddress(_msgSender(), true);\n  }\n  \n  mapping(address =\u003e bool) public adminAddress;\n\n  modifier onlyOwnerOrAdminAddress()\n  {\n    require(adminAddress[_msgSender()], \"permission denied\");\n    _;\n  }\n  function updateAdminAddress(address newAddress, bool flag) public onlyOwner {\n    require(adminAddress[newAddress] != flag, \"The adminAddress already has that address\");\n    adminAddress[newAddress] = flag;\n  }\n  \n  \n  \n  event Mint(address, uint256);\n  function mint(address _to, uint256 tkId, string calldata i) external onlyOwnerOrAdminAddress returns(uint256) {\n    super._mint(_to, tkId);\n    super._setTokenUri(tkId, i);\n    emit Mint(_to, tkId);\n    return tkId;\n  }\n  \n  event Burn(uint256);\n  function burn(uint256 tokenId) external onlyOwnerOrAdminAddress{\n    super._burn(tokenId);\n    // nftAttrAddress.delNftInfo(tokenId);\n    emit Burn(tokenId);\n  }\n    \n \n  mapping(address =\u003e uint256[]) public _ownerTokens;\n  // mapping(address =\u003e NftInfo[]) public _ownerTokensAndInfo;\n  event OwnerTokenRemove(address, uint256, uint256[]);\n  \n  function tokenOfOwnerGet(address _owner) public view returns (uint256[] memory){\n    return _ownerTokens[_owner];\n  }\n  \n  function tokenOfOwnerByIndex(address _owner, uint256 index) public view override returns (uint256 tokenId) {\n    return _ownerTokens[_owner][index];\n  }\n\n  function tokenByIndex(uint256 index) public view override returns (uint256) {\n    return tokens[index];\n  }\n  \n  function _tokenOfOwnerRemove(address owner,uint256 tokenId) internal {\n    bool found = false;\n    uint j = 0;\n    uint lastIndex = _ownerTokens[owner].length - 1;\n    for(uint i = 0;i \u003c= lastIndex; i++) {\n        if (_ownerTokens[owner][i] == tokenId){\n          found = true;\n          j = i;\n          break;\n        }\n    } \n    if(found) {\n      _ownerTokens[owner][j] = _ownerTokens[owner][lastIndex]; \n      _ownerTokens[owner].pop(); \n    }\n    \n  }\n\n  function _tokenOfOwnerAdd(address owner, uint256 tokenId) internal {\n    _ownerTokens[owner].push(tokenId);\n  }\n  \n  uint256[] internal tokens;\n  mapping(uint256 =\u003e uint256) internal idToIndex;\n  \n  function totalSupply()\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return tokens.length;\n  }\n  \n  function _addTokens(uint256 _tokenId) internal {\n      tokens.push(_tokenId);\n      idToIndex[_tokenId] = tokens.length - 1;\n  }\n  \n  function _delTokens(uint256 _tokenId) internal {\n    uint256 tokenIndex = idToIndex[_tokenId];\n    uint256 lastTokenIndex = tokens.length - 1;\n    uint256 lastToken = tokens[lastTokenIndex];\n    tokens[tokenIndex] = lastToken;\n    tokens.pop();\n    idToIndex[lastToken] = tokenIndex;\n    idToIndex[_tokenId] = 0;\n  }\n  \n  function _removeNFToken(address _from, uint256 _tokenId)internal override virtual{\n    super._removeNFToken(_from, _tokenId);\n    _tokenOfOwnerRemove(_from, _tokenId);\n    _delTokens(_tokenId);\n  }\n\n  /**\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\n   * @dev Assigns a new NFT to owner.\n   * @param _to Address to which we want to add the NFT.\n   * @param _tokenId Which NFT we want to add.\n   */\n  function _addNFToken( address _to, uint256 _tokenId)internal override virtual{\n    super._addNFToken(_to, _tokenId);\n    _tokenOfOwnerAdd(_to, _tokenId);\n    _addTokens(_tokenId);\n  }\n  \n  function baseImage(uint256 _tokenId) public view returns (string memory) {\n      return idToUri[_tokenId];\n  }\n  \n  address public tokenUriAddress;\n  \n  function updateTokenUriAddress(address _addr) public onlyOwnerOrAdminAddress {\n      tokenUriAddress = _addr;\n  }\n\n  function tokenURI(uint256 _tokenId) external override view returns (string memory){\n        if(tokenUriAddress == address(0)) {\n            return baseImage(_tokenId);\n        }   \n        return IURI(tokenUriAddress).tokenURI(_tokenId);\n  }\n  \n}"},"ownable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\n/**\n * @dev The contract has an owner address, and provides basic authorization control whitch\n * simplifies the implementation of user permissions. This contract is based on the source code at:\n * https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ownership/Ownable.sol\n */\ncontract Ownable\n{\n\n  /**\n   * @dev Error constants.\n   */\n  string public constant NOT_CURRENT_OWNER = \"018001\";\n  string public constant CANNOT_TRANSFER_TO_ZERO_ADDRESS = \"018002\";\n\n  /**\n   * @dev Current owner address.\n   */\n  address public owner;\n\n  /**\n   * @dev An event which is triggered when the owner is changed.\n   * @param previousOwner The address of the previous owner.\n   * @param newOwner The address of the new owner.\n   */\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n  /**\n   * @dev The constructor sets the original `owner` of the contract to the sender account.\n   */\n  constructor()\n  {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner()\n  {\n    require(msg.sender == owner, NOT_CURRENT_OWNER);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(\n    address _newOwner\n  )\n    public\n    onlyOwner\n  {\n    require(_newOwner != address(0), CANNOT_TRANSFER_TO_ZERO_ADDRESS);\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }\n\n}\n"},"safemath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.7;\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"},"supports-interface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of standard for detect smart contract interfaces.\n */\ncontract SupportsInterface is IERC165 {\n\n  /**\n   * @dev Mapping of supported intefraces. You must not set element 0xffffffff to true.\n   */\n  mapping(bytes4 =\u003e bool) internal supportedInterfaces;\n\n  /**\n   * @dev Contract constructor.\n   */\n  constructor()\n  {\n    supportedInterfaces[0x01ffc9a7] = true; // ERC165\n  }\n\n  /**\n   * @dev Function to check which interfaces are suported by this contract.\n   * @param _interfaceID Id of the interface.\n   * @return True if _interfaceID is supported, false otherwise.\n   */\n  function supportsInterface(\n    bytes4 _interfaceID\n  )\n    external\n    override\n    view\n    returns (bool)\n  {\n    return supportedInterfaces[_interfaceID];\n  }\n\n}\n"}}