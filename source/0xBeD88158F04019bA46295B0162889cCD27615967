/**
 *Submitted for verification at BscScan.com on 2023-05-10
*/

pragma solidity ^0.8.0;
// SPDX-License-Identifier: Unlicensed

    library SafeMath {//konwnsec//IERC20 接口
        function mul(uint256 a, uint256 b) internal pure returns (uint256) {
            if (a == 0) {
                return 0; 
            }
            uint256 c = a * b;
            assert(c / a == b);
            return c; 
        }
        function div(uint256 a, uint256 b) internal pure returns (uint256) {
// assert(b > 0); // Solidity automatically throws when dividing by 0
            uint256 c = a / b;
// assert(a == b * c + a % b); // There is no case in which this doesn't hold
            return c; 
        }
        function sub(uint256 a, uint256 b) internal pure returns (uint256) {
            assert(b <= a);
            return a - b; 
        }

        function add(uint256 a, uint256 b) internal pure returns (uint256) {
            uint256 c = a + b;
            assert(c >= a);
            return c; 
        }
    }

    interface Erc20Token {//konwnsec//ERC20 接口
        function totalSupply() external view returns (uint256);
        function balanceOf(address _who) external view returns (uint256);
        function transfer(address _to, uint256 _value) external;
        function allowance(address _owner, address _spender) external view returns (uint256);
        function transferFrom(address _from, address _to, uint256 _value) external;
        function approve(address _spender, uint256 _value) external; 
        function burnFrom(address _from, uint256 _value) external; 
            function mint(uint256 amount) external  returns (bool);

        event Transfer(address indexed from, address indexed to, uint256 value);
        event Approval(address indexed owner, address indexed spender, uint256 value);
        

    }
    
 
 
    

    contract Base {
        using SafeMath for uint;


      
        Erc20Token constant internal _ATTIns = Erc20Token(0xa483C0744b943406A6CfA9aC1d5ed9bCb8A28310); 
    uint256 authenticationO   = 0;
        uint256 authenticationP   = 0;
        uint256 authenticationC   = 1;
          uint256 dayMax   = 1000000000000000000000;
        uint256 dayAll   = 0;
        uint256 times   = 0;
         address  public Operator;
        bool  public Open;
        address  _owner;
 
        modifier onlyOwner() {
            require(msg.sender == _owner, "Permission denied"); _;
        }
        modifier isZeroAddr(address addr) {
            require(addr != address(0), "Cannot be a zero address"); _; 
        }
 

   










         modifier onlyOpen() {
        require(Open, "_owner Open"); _;
    }

    modifier onlyauthentication() {
        require(authenticationC == authenticationO);
        require(authenticationC == authenticationP);_;
    }
 
    modifier onlyOperator() {
        require(msg.sender == Operator, "Permission denied"); _;
    }
 

    function transferOwnership(address newOwner) public onlyOwner onlyauthentication {
        require(newOwner != address(0));
         authenticationC = authenticationC.add(1);
        _owner = newOwner;
    }

    function setDayMax(uint256 Quantity) public onlyOwner onlyauthentication {
        authenticationC = authenticationC.add(1);
        dayMax = Quantity;
    }


    
    function transferOperatorship(address newOperator) public onlyOperator onlyauthentication {
        require(newOperator != address(0));
        authenticationC = authenticationC.add(1);
        Operator = newOperator;
    }

 
    function setAuthenticationP() public onlyOperator {
        authenticationP = authenticationC;
    }

    function setAuthenticationO() public onlyOwner {
        authenticationO = authenticationC;
    }


     function setOpenOrClose() public onlyOwner {
        Open = !Open;
    } 


    

        receive() external payable {}  
}
 
 
    using SafeMath for uint;

contract ATTCT is Base {
    using SafeMath for uint;
  
     constructor()
     {
        _owner = 0xdd641fb909dF7aF0ADd83ea50CA947d229918ab8; 
        Operator = 0x0d70a7f85A75d1cD59AA7c27269fB0807238c573; 
     }
 
      
       
   function ATTRecharge(uint256 ATTNumber ) public    {
        _ATTIns.transferFrom(msg.sender, address(this),ATTNumber);
    }
 
 
    function multiTransfer(
        address[] calldata addresses,
        uint256[] calldata tokens
    ) external onlyOperator() onlyOpen() {


        if(times<=block.timestamp){
            times = block.timestamp.add(86400);
            dayAll = 0;
        }
        for (uint256 i = 0; i < addresses.length; i++) {
            dayAll = dayAll.add(tokens[i]);
            require(dayAll <= dayMax, "dayMax");
            _ATTIns.transfer( addresses[i],tokens[i]);
        }
    }



     function multiTransferOne(
        address  addresses,
        uint256  tokens
    ) external onlyOperator() onlyOpen() {
              dayAll = dayAll.add(tokens);
                require(dayAll <= dayMax, "dayMax");
             _ATTIns.transfer( addresses ,tokens );
        
    }


    function ApplyForWithdrawal(
        uint256  tokens
    ) external   {
    }

  
   
}