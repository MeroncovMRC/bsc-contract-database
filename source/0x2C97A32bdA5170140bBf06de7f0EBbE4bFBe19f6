// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract DOR {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    uint256 public pricePerToken;
    uint256 public developerFee;
    uint256 public insuranceFee;
    uint256 public marketingFee;
    address public developerWallet;
    address public insuranceWallet;
    address public marketingWallet;

    mapping (address => uint256) private _balances;

    constructor () {
        name = "DOR";
        symbol = "DOR";
        decimals = 2;
        totalSupply = 1000000000 * 10**uint256(decimals);
        pricePerToken = 100;
        developerFee = 5;
        insuranceFee = 2;
        marketingFee = 3;
        developerWallet = msg.sender;
        insuranceWallet = msg.sender;
        marketingWallet = msg.sender;
        _balances[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        require(_balances[msg.sender] >= amount, "Insufficient balance");

        // Calculate the fees
        uint256 developerAmount = (amount * developerFee) / 100;
        uint256 insuranceAmount = (amount * insuranceFee) / 1000;
        uint256 marketingAmount = (amount * marketingFee) / 1000;
        uint256 transferAmount = amount - developerAmount - insuranceAmount - marketingAmount;

        // Transfer the tokens
        _balances[msg.sender] -= amount;
        _balances[recipient] += transferAmount;

        // Transfer the fees
        _balances[developerWallet] += developerAmount;
        _balances[insuranceWallet] += insuranceAmount;
        _balances[marketingWallet] += marketingAmount;

        // Emit events
        emit Transfer(msg.sender, recipient, transferAmount);
        emit Transfer(msg.sender, developerWallet, developerAmount);
        emit Transfer(msg.sender, insuranceWallet, insuranceAmount);
        emit Transfer(msg.sender, marketingWallet, marketingAmount);

        return true;
    }

    function setDeveloperFee(uint256 fee) public {
        require(msg.sender == developerWallet, "Only the developer can change the developer fee");
        developerFee = fee;
    }

    function setInsuranceFee(uint256 fee) public {
        require(msg.sender == insuranceWallet, "Only the insurance can change the insurance fee");
        insuranceFee = fee;
    }

    function setMarketingFee(uint256 fee) public {
        require(msg.sender == marketingWallet, "Only the marketing can change the marketing fee");
        marketingFee = fee;
    }

    function setDeveloperWallet(address wallet) public {
        require(msg.sender == developerWallet, "Only the developer can change the developer wallet address");
        developerWallet = wallet;
    }

    function setInsuranceWallet(address wallet) public {
        require(msg.sender == insuranceWallet, "Only the insurance can change the insurance wallet address");
        insuranceWallet = wallet;
    }

    function setMarketingWallet(address wallet) public {
        require(msg.sender == marketingWallet, "Only the marketing can change the marketing wallet address");
        marketingWallet = wallet;
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
}