{"AppealStorage.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./RecordInterface.sol\";\r\nimport \"./UserStorage.sol\";\r\nimport \"./Ownable.sol\";\r\nimport \"./SafeMath.sol\";\r\n\r\ncontract AppealStorage {\r\n    OrderInterface private _oSt;\r\n    RecordInterface private _rSt;\r\n    UserInterface private _uSt;\r\n    address recAddr;\r\n    struct Appeal {\r\n        address user;\r\n        uint256 appealNo;\r\n        uint256 orderNo;\r\n        address witness;\r\n        address buyer;\r\n        address seller;\r\n        uint256 mortgage;\r\n        uint256 status;\r\n        uint256 appealTime;\r\n        uint256 witTakeTime;\r\n        uint256 obTakeTime;\r\n        AppealDetail detail;\r\n    }\r\n    struct AppealDetail {\r\n        address finalAppealAddr;\r\n        uint256 updateTime;\r\n        string witnessReason;\r\n        uint256 witnessAppealStatus;\r\n        string observerReason;\r\n        uint256 witnessHandleTime;\r\n        uint256 observerHandleTime;\r\n        address observerAddr;\r\n        uint256 witnessHandleReward;\r\n        uint256 observerHandleReward;\r\n        uint256 witnessHandleCredit;\r\n        uint256 observerHandleCredit;\r\n        uint256 witReward;\r\n        uint256 witSub;\r\n        uint256 witCreditR;\r\n        uint256 witCreditS;\r\n    }\r\n    using SafeMath for uint256;\r\n    mapping(uint256 =\u003e Appeal) public appeals;\r\n    mapping(uint256 =\u003e uint256) public appealIndex;\r\n    Appeal[] public appealList;\r\n    event addAppeal(uint256 _appealNo, uint256 _orderNo);\r\n\r\n    constructor(\r\n        address _recordInter,\r\n        address _orderInter,\r\n        address _userInter\r\n    ) {\r\n        _rSt = RecordInterface(_recordInter);\r\n        _oSt = OrderInterface(_orderInter);\r\n        _uSt = UserInterface(_userInter);\r\n        recAddr = _recordInter;\r\n    }\r\n\r\n    modifier onlyWit(uint256 _o) {\r\n        Appeal memory _al = appeals[_o];\r\n        require(_al.witness == msg.sender);\r\n        require(_al.buyer != msg.sender \u0026\u0026 _al.seller != msg.sender);\r\n        _;\r\n    }\r\n    modifier onlyOb(uint256 _o) {\r\n        Appeal memory _al = appeals[_o];\r\n        require(_al.detail.observerAddr == msg.sender);\r\n        require(_al.buyer != msg.sender \u0026\u0026 _al.seller != msg.sender);\r\n        _;\r\n    }\r\n    modifier onlyBOS(uint256 _o) {\r\n        OrderStorage.Order memory _r = _oSt.searchOrder(_o);\r\n        require(\r\n            _r.orderDetail.sellerAddr == msg.sender ||\r\n                _r.orderDetail.buyerAddr == msg.sender\r\n        );\r\n        _;\r\n    }\r\n\r\n    function _insert(uint256 _o, uint256 _count) internal {\r\n        OrderStorage.Order memory _or = _oSt.searchOrder(_o);\r\n        require(appeals[_o].appealNo == uint256(0));\r\n        AppealDetail memory _detail = AppealDetail({\r\n            finalAppealAddr: address(0),\r\n            updateTime: uint256(0),\r\n            witnessReason: \"\",\r\n            observerReason: \"\",\r\n            witnessAppealStatus: 0,\r\n            witnessHandleTime: uint256(0),\r\n            observerHandleTime: uint256(0),\r\n            observerAddr: address(0),\r\n            witnessHandleReward: 0,\r\n            observerHandleReward: 0,\r\n            witnessHandleCredit: 0,\r\n            observerHandleCredit: 0,\r\n            witReward: 0,\r\n            witSub: 0,\r\n            witCreditR: 0,\r\n            witCreditS: 0\r\n        });\r\n        uint256 _appealNo = block.timestamp;\r\n        Appeal memory _appeal = Appeal({\r\n            user: msg.sender,\r\n            appealNo: _appealNo,\r\n            orderNo: _o,\r\n            witness: address(0),\r\n            buyer: _or.orderDetail.buyerAddr,\r\n            seller: _or.orderDetail.sellerAddr,\r\n            mortgage: _count,\r\n            status: 1,\r\n            appealTime: block.timestamp,\r\n            witTakeTime: 0,\r\n            obTakeTime: 0,\r\n            detail: _detail\r\n        });\r\n        appeals[_o] = _appeal;\r\n        appealList.push(_appeal);\r\n        appealIndex[_o] = appealList.length - 1;\r\n        chanT(_or.orderDetail.sellerAddr, _or.orderDetail.buyerAddr, 1, 0);\r\n        emit addAppeal(_appealNo, _o);\r\n    }\r\n\r\n    function chanT(\r\n        address _seller,\r\n        address _buyer,\r\n        uint256 _t,\r\n        uint256 _r\r\n    ) internal {\r\n        uint256 _tc = _rSt.getTradeCredit();\r\n        uint256 _rs = _rSt.getSubTCredit();\r\n        UserStorage.User memory _user = _uSt.searchUser(_seller);\r\n        UserStorage.TradeStats memory _tr = _user.tradeStats;\r\n        UserStorage.User memory _user2 = _uSt.searchUser(_buyer);\r\n        UserStorage.TradeStats memory _tr2 = _user2.tradeStats;\r\n        uint256 _c2 = _user2.credit;\r\n        uint256 _c = _user.credit;\r\n        if (_t == 1) {\r\n            _tr.tradeTotal = _tr.tradeTotal \u003e 0 ? (_tr.tradeTotal - 1) : 0;\r\n            _tr2.tradeTotal = _tr2.tradeTotal \u003e 0 ? (_tr2.tradeTotal - 1) : 0;\r\n            _c = (_c \u003e= _tc) ? (_c - _tc) : 0;\r\n            _c2 = (_c2 \u003e= _tc) ? (_c2 - _tc) : 0;\r\n        } else if (_t == 2) {\r\n            _tr.tradeTotal += 1;\r\n            _tr2.tradeTotal += 1;\r\n            if (_r == 1) {\r\n                _c += _tc;\r\n                _c2 = (_c2 \u003e= _rs) ? (_c2 - _rs) : 0;\r\n            } else if (_r == 2) {\r\n                _c2 += _tc;\r\n                _c = (_c \u003e= _rs) ? (_c - _rs) : 0;\r\n            }\r\n        }\r\n        _uSt.updateTradeStats(_seller, _tr, _c);\r\n        _uSt.updateTradeStats(_buyer, _tr2, _c2);\r\n    }\r\n\r\n    function applyAppeal(uint256 _o) external onlyBOS(_o) {\r\n        uint256 _fee = _rSt.getAppealFee();\r\n        _insert(_o, _fee);\r\n        TokenTransfer _tokenTransfer = _rSt.getERC20Address(\"DOTC\");\r\n        _tokenTransfer.transferFrom(msg.sender, recAddr, _fee);\r\n    }\r\n\r\n    function takeWit(uint256 _o) external {\r\n        Appeal memory _al = appeals[_o];\r\n        require(_al.buyer != msg.sender \u0026\u0026 _al.seller != msg.sender);\r\n        require(_al.witness == address(0));\r\n        require(_al.status == 1);\r\n        bool _f = witOrOb(1);\r\n        require(_f);\r\n        _al.witness = msg.sender;\r\n        _al.witTakeTime = block.timestamp;\r\n        appeals[_o] = _al;\r\n        appealList[appealIndex[_o]] = _al;\r\n    }\r\n\r\n    function takeOb(uint256 _o) external {\r\n        Appeal memory _al = appeals[_o];\r\n        require(_al.buyer != msg.sender \u0026\u0026 _al.seller != msg.sender);\r\n        require(_al.status == 4 || _al.status == 5);\r\n        require(_al.detail.observerAddr == address(0));\r\n        bool _f = witOrOb(2);\r\n        require(_f);\r\n        _al.detail.observerAddr = msg.sender;\r\n        _al.obTakeTime = block.timestamp;\r\n        appeals[_o] = _al;\r\n        appealList[appealIndex[_o]] = _al;\r\n    }\r\n\r\n    function changeHandler(uint256 _o, uint256 _type) external onlyBOS(_o) {\r\n        Appeal memory _al = appeals[_o];\r\n        if (_type == 1) {\r\n            require(_al.status == 1);\r\n            require(_al.witness != address(0));\r\n            require(block.timestamp - _al.witTakeTime \u003e 24 hours);\r\n            _al.witness = address(0);\r\n            _al.witTakeTime = 0;\r\n        } else if (_type == 2) {\r\n            require(_al.status == 4 || _al.status == 5);\r\n            require(_al.detail.observerAddr != address(0));\r\n            require(block.timestamp - _al.obTakeTime \u003e 24 hours);\r\n            _al.detail.observerAddr = address(0);\r\n            _al.obTakeTime = 0;\r\n        }\r\n        appeals[_o] = _al;\r\n        appealList[appealIndex[_o]] = _al;\r\n    }\r\n\r\n    function witOrOb(uint256 _f) internal view returns (bool) {\r\n        UserStorage.User memory _u = _uSt.searchUser(msg.sender);\r\n        if (_u.userFlag == _f) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function applyFinal(uint256 _o) external onlyBOS(_o) {\r\n        Appeal memory _al = appeals[_o];\r\n        require(_al.status == 2 || _al.status == 3);\r\n        require(block.timestamp - _al.detail.witnessHandleTime \u003c= 24 hours);\r\n        chanT(_al.seller, _al.buyer, 1, 0);\r\n        uint256 _fee = _rSt.getAppealFeeFinal();\r\n        TokenTransfer _tokenTransfer = _rSt.getERC20Address(\"DOTC\");\r\n        _tokenTransfer.transferFrom(msg.sender, recAddr, _fee);\r\n        if (_al.status == 2) {\r\n            _al.status = 4;\r\n        } else if (_al.status == 3) {\r\n            _al.status = 5;\r\n        }\r\n        _al.detail.finalAppealAddr = msg.sender;\r\n        _al.detail.updateTime = block.timestamp;\r\n        appeals[_o] = _al;\r\n        appealList[appealIndex[_o]] = _al;\r\n    }\r\n\r\n    function witnessOpt(\r\n        uint256 _o,\r\n        string memory _r,\r\n        uint256 _s\r\n    ) external onlyWit(_o) {\r\n        require(_s == 2 || _s == 3);\r\n        Appeal memory _al = appeals[_o];\r\n        require(_al.status == 1);\r\n        uint256 _fee = _rSt.getAppealFee();\r\n        uint256 _rcedit = _rSt.getWitnessHandleCredit();\r\n        _al.status = _s;\r\n        _al.detail.witnessAppealStatus = _s;\r\n        _al.detail.witnessReason = _r;\r\n        _al.detail.witnessHandleTime = block.timestamp;\r\n        _al.detail.witnessHandleReward = _fee;\r\n        _al.detail.witnessHandleCredit = _rcedit;\r\n        _al.detail.witReward = _fee;\r\n        _al.detail.witCreditR = _rcedit;\r\n        _al.detail.updateTime = block.timestamp;\r\n        appeals[_o] = _al;\r\n        appealList[appealIndex[_o]] = _al;\r\n        if (_s == 2) {\r\n            if (_al.user == _al.buyer) {\r\n                _rSt.subAvaAppeal(_al.seller, _al.buyer, _al, _fee, 1, 0);\r\n                chanT(_al.seller, _al.buyer, 2, 2);\r\n            } else if (_al.user == _al.seller) {\r\n                _rSt.subAvaAppeal(_al.buyer, _al.seller, _al, _fee, 1, 0);\r\n                chanT(_al.seller, _al.buyer, 2, 1);\r\n            }\r\n        }\r\n        if (_s == 3) {\r\n            if (_al.user == _al.buyer) {\r\n                _rSt.subAvaAppeal(_al.buyer, _al.seller, _al, _fee, 1, 1);\r\n                chanT(_al.seller, _al.buyer, 2, 1);\r\n            } else if (_al.user == _al.seller) {\r\n                _rSt.subAvaAppeal(_al.seller, _al.buyer, _al, _fee, 1, 1);\r\n                chanT(_al.seller, _al.buyer, 2, 2);\r\n            }\r\n        }\r\n    }\r\n\r\n    function observerOpt(\r\n        uint256 _o,\r\n        string memory _r,\r\n        uint256 _s\r\n    ) external onlyOb(_o) {\r\n        require(_s == 6 || _s == 7);\r\n        Appeal memory _appeal = appeals[_o];\r\n        require(_appeal.status == 4 || _appeal.status == 5);\r\n        uint256 _fee = _rSt.getAppealFeeFinal();\r\n        uint256 _rcedit = _rSt.getObserverHandleCredit();\r\n        _appeal.status = _s;\r\n        _appeal.detail.observerReason = _r;\r\n        _appeal.detail.observerHandleTime = block.timestamp;\r\n        _appeal.detail.observerHandleReward = _fee;\r\n        _appeal.detail.observerHandleCredit = _rcedit;\r\n        uint256 _subWC = _rSt.getSubWitCredit();\r\n        uint256 _subWF = _rSt.getSubWitFee();\r\n        if (_s == 6) {\r\n            if (_appeal.user == _appeal.buyer) {\r\n                _rSt.subAvaAppeal(\r\n                    _appeal.seller,\r\n                    _appeal.buyer,\r\n                    _appeal,\r\n                    _fee,\r\n                    2,\r\n                    0\r\n                );\r\n                chanT(_appeal.seller, _appeal.buyer, 2, 2);\r\n                _rSt.subFrozenTotal(_o, _appeal.buyer);\r\n            } else if (_appeal.user == _appeal.seller) {\r\n                _rSt.subAvaAppeal(\r\n                    _appeal.buyer,\r\n                    _appeal.seller,\r\n                    _appeal,\r\n                    _fee,\r\n                    2,\r\n                    0\r\n                );\r\n                chanT(_appeal.seller, _appeal.buyer, 2, 1);\r\n                _rSt.subFrozenTotal(_o, _appeal.seller);\r\n            }\r\n            if (_appeal.detail.witnessAppealStatus == 3) {\r\n                _appeal.detail.witSub = _subWF;\r\n                _appeal.detail.witCreditS = _subWC;\r\n                if (_appeal.detail.witnessHandleCredit \u003e= _subWC) {\r\n                    _appeal.detail.witnessHandleCredit = SafeMath.sub(\r\n                        _appeal.detail.witnessHandleCredit,\r\n                        _subWC\r\n                        \r\n                    );\r\n                } else {\r\n                    _appeal.detail.witnessHandleCredit = 0;\r\n                }\r\n                _rSt.subWitnessAvailable(_appeal.witness);\r\n            }\r\n        }\r\n        if (_s == 7) {\r\n            if (_appeal.user == _appeal.buyer) {\r\n                _rSt.subAvaAppeal(\r\n                    _appeal.buyer,\r\n                    _appeal.seller,\r\n                    _appeal,\r\n                    _fee,\r\n                    2,\r\n                    1\r\n                );\r\n                chanT(_appeal.seller, _appeal.buyer, 2, 1);\r\n                _rSt.subFrozenTotal(_o, _appeal.seller);\r\n            } else if (_appeal.user == _appeal.seller) {\r\n                _rSt.subAvaAppeal(\r\n                    _appeal.seller,\r\n                    _appeal.buyer,\r\n                    _appeal,\r\n                    _fee,\r\n                    2,\r\n                    1\r\n                );\r\n                chanT(_appeal.seller, _appeal.buyer, 2, 2);\r\n                _rSt.subFrozenTotal(_o, _appeal.buyer);\r\n            }\r\n            if (_appeal.detail.witnessAppealStatus == 2) {\r\n                _appeal.detail.witSub = _subWF;\r\n                _appeal.detail.witCreditS = _subWC;\r\n                if (_appeal.detail.witnessHandleCredit \u003e= _subWC) {\r\n                    _appeal.detail.witnessHandleCredit = SafeMath.sub(\r\n                        _appeal.detail.witnessHandleCredit,\r\n                        _subWC\r\n                    );\r\n                } else {\r\n                    _appeal.detail.witnessHandleCredit = 0;\r\n                }\r\n                _rSt.subWitnessAvailable(_appeal.witness);\r\n            }\r\n        }\r\n        _appeal.detail.updateTime = block.timestamp;\r\n        appeals[_o] = _appeal;\r\n        appealList[appealIndex[_o]] = _appeal;\r\n    }\r\n\r\n    function searchAppeal(uint256 _o)\r\n        external\r\n        view\r\n        returns (Appeal memory appeal)\r\n    {\r\n        return appeals[_o];\r\n    }\r\n\r\n    function searchAppealList() external view returns (Appeal[] memory) {\r\n        return appealList;\r\n    }\r\n}\r\n"},"Context.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n"},"OrderStorage.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./RecordInterface.sol\";\r\nimport \"./RestStorage.sol\";\r\nimport \"./UserStorage.sol\";\r\nimport \"./RecordStorage.sol\";\r\nimport \"./AppealStorage.sol\";\r\nimport \"./Ownable.sol\";\r\nimport \"./SafeMath.sol\";\r\n\r\nabstract contract ReentrancyGuardOrder {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\nlibrary CountersOrder {\r\n    struct Counter {\r\n        uint256 _value;\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        {\r\n            if (counter._value == 0) {\r\n                counter._value = 10000;\r\n            }\r\n            counter._value += 1;\r\n        }\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        uint256 value = counter._value;\r\n        require(value \u003e 0, \"Counter: decrement overflow\");\r\n        {\r\n            counter._value = value - 1;\r\n        }\r\n    }\r\n}\r\n\r\ncontract OrderStorage is Ownable, ReentrancyGuardOrder {\r\n    using CountersOrder for CountersOrder.Counter;\r\n    using SafeMath for uint256;\r\n    RestStorage private _restStorage;\r\n    RecordInterface private _recordStorage;\r\n    UserInterface private _userStorage;\r\n    AppealInterface private _appealS;\r\n    address recordAddress;\r\n\r\n    struct Order {\r\n        address userAddr;\r\n        uint256 orderNo;\r\n        uint256 restNo;\r\n        uint256 coinCount;\r\n        uint256 orderAmount;\r\n        uint256 payType;\r\n        string currencyType;\r\n        uint256 orderType;\r\n        uint256 orderStatus;\r\n        OrderDetail orderDetail;\r\n    }\r\n    struct OrderDetail {\r\n        address buyerAddr;\r\n        address sellerAddr;\r\n        string coinType;\r\n        uint256 price;\r\n        uint256 tradeTime;\r\n        uint256 updateTime;\r\n        string tradeHash;\r\n        uint256 tradeFee;\r\n    }\r\n\r\n    CountersOrder.Counter private _orderNoCounter;\r\n    mapping(uint256 =\u003e Order) private orders;\r\n    mapping(uint256 =\u003e uint256) private orderIndex;\r\n\r\n    Order[] private orderList;\r\n\r\n    mapping(address =\u003e mapping(uint256 =\u003e uint256)) orderFrozenTotal;\r\n\r\n    uint256 public cancelOrderTime = 30;\r\n\r\n    function setCancelOrderTime(uint256 _count) public onlyOwner {\r\n        cancelOrderTime = _count;\r\n    }\r\n\r\n    function getCancelOrderTime() public view returns (uint256) {\r\n        return cancelOrderTime;\r\n    }\r\n\r\n    uint256 public canWithdrawHours = 24;\r\n\r\n    function setCanWithdrawHours(uint256 _count) public onlyOwner {\r\n        canWithdrawHours = _count;\r\n    }\r\n\r\n    function getCanWithdrawHours() public view returns (uint256) {\r\n        return canWithdrawHours;\r\n    }\r\n\r\n    address public backTradeFeeAddress;\r\n\r\n    function setBackTradeFeeAddress(address _address) public onlyOwner {\r\n        backTradeFeeAddress = _address;\r\n    }\r\n\r\n    mapping(string =\u003e address) public feeAddrSet;\r\n    mapping(string =\u003e uint256) public feeAmountSet;\r\n\r\n    function setFee(\r\n        string calldata _method,\r\n        address _addr,\r\n        uint256 _amount\r\n    ) external onlyOwner {\r\n        feeAddrSet[_method] = _addr;\r\n        feeAmountSet[_method] = _amount;\r\n    }\r\n\r\n    function _payFee(string memory _method) internal {\r\n        uint256 _amt = feeAmountSet[_method];\r\n        address _addr = feeAddrSet[_method];\r\n\r\n        if (_amt \u003e 0) {\r\n            require(_addr != address(0), \"recipient null is not allowed\");\r\n            require(msg.value \u003e= _amt, \"insufficient balance\");\r\n            payable(_addr).transfer(_amt);\r\n        }\r\n    }\r\n\r\n    event OrderAdd(\r\n        uint256 _orderNo,\r\n        uint256 _restNo,\r\n        uint256 _coinCount,\r\n        uint256 _tradeFee,\r\n        uint256 _orderAmount,\r\n        uint256 _payType,\r\n        uint256 _orderType,\r\n        address _buyerAddr,\r\n        address _sellerAddr\r\n    );\r\n\r\n    event OrderPaidMoney(uint256 _orderNo);\r\n    event OrderConfirmCollect(uint256 _orderNo);\r\n    event OrderCancel(uint256 _orderNo);\r\n    event OrderUpdateStatus(uint256 _orderNo, uint256 _orderStatus);\r\n\r\n    function authFromContract(\r\n        address _recordAddr,\r\n        address _restAddr,\r\n        address _userAddr,\r\n        address _appealAddr\r\n    ) external onlyOwner {\r\n        _recordStorage = RecordInterface(_recordAddr);\r\n        _restStorage = RestStorage(_restAddr);\r\n        _userStorage = UserInterface(_userAddr);\r\n        recordAddress = _recordAddr;\r\n        _appealS = AppealInterface(_appealAddr);\r\n        _orderNoCounter.increment();\r\n    }\r\n\r\n    modifier onlyBuyer(uint256 _orderNo) {\r\n        require(_orderNo != uint256(0), \"orderNo null\");\r\n        require(\r\n            orders[_orderNo].orderDetail.buyerAddr == msg.sender,\r\n            \"only buyer\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlySeller(uint256 _orderNo) {\r\n        require(_orderNo != uint256(0), \"orderNo null\");\r\n        require(\r\n            orders[_orderNo].orderDetail.sellerAddr == msg.sender,\r\n            \"only seller\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyBuyerOrSeller(uint256 _orderNo) {\r\n        require(_orderNo != uint256(0), \"orderNo null\");\r\n        require(\r\n            orders[_orderNo].orderDetail.sellerAddr == msg.sender ||\r\n                orders[_orderNo].orderDetail.buyerAddr == msg.sender,\r\n            \"Only buyer or seller\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function _checkParam(\r\n        uint256 _restNo,\r\n        uint256 _coinCount,\r\n        uint256 _orderAmount,\r\n        uint256 _payType\r\n    ) internal pure {\r\n        require(_restNo != uint256(0), \"restNo null\");\r\n        require(_coinCount \u003e 0, \"coinCount null\");\r\n        require(_orderAmount \u003e 0, \"orderAmount null\");\r\n        require(_payType != uint256(0), \"payType null\");\r\n    }\r\n\r\n    function _insert(\r\n        uint256 _restNo,\r\n        uint256 _coinCount,\r\n        uint256 _tradeFee,\r\n        uint256 _orderAmount,\r\n        uint256 _payType,\r\n        uint256 _orderType,\r\n        address _buyerAddr,\r\n        address _sellerAddr\r\n    ) internal nonReentrant returns (uint256 restNo) {\r\n        _checkParam(_restNo, _coinCount, _orderAmount, _payType);\r\n\r\n        RestStorage.Rest memory _rest = _restStorage.searchRest(_restNo);\r\n        require(_rest.userAddr != address(0), \"rest not exist\");\r\n        OrderDetail memory _orderDetail = OrderDetail({\r\n            buyerAddr: _buyerAddr,\r\n            sellerAddr: _sellerAddr,\r\n            coinType: _rest.coinType,\r\n            price: _rest.price,\r\n            tradeTime: block.timestamp,\r\n            updateTime: 0,\r\n            tradeHash: \"\",\r\n            tradeFee: _tradeFee\r\n        });\r\n\r\n        uint256 _orderNo = _orderNoCounter.current();\r\n        require(orders[_orderNo].orderNo == uint256(0), \"order exist\");\r\n        Order memory order = Order({\r\n            userAddr: msg.sender,\r\n            orderNo: _orderNo,\r\n            restNo: _restNo,\r\n            coinCount: _coinCount,\r\n            orderAmount: _orderAmount,\r\n            payType: _payType,\r\n            currencyType: _rest.currencyType,\r\n            orderType: _orderType,\r\n            orderStatus: 1,\r\n            orderDetail: _orderDetail\r\n        });\r\n\r\n        orders[_orderNo] = order;\r\n\r\n        orderList.push(order);\r\n        orderIndex[_orderNo] = orderList.length - 1;\r\n\r\n        if (_orderType == 2) {\r\n            orderFrozenTotal[msg.sender][_orderNo] = _coinCount;\r\n        } else if (_orderType == 1) {\r\n            orderFrozenTotal[_rest.userAddr][_orderNo] = _coinCount;\r\n        }\r\n        _orderNoCounter.increment();\r\n        emit OrderAdd(\r\n            _orderNo,\r\n            _restNo,\r\n            _coinCount,\r\n            _tradeFee,\r\n            _orderAmount,\r\n            _payType,\r\n            _orderType,\r\n            _buyerAddr,\r\n            _sellerAddr\r\n        );\r\n\r\n        return _orderNo;\r\n    }\r\n\r\n    function addBuyOrder(\r\n        uint256 _restNo,\r\n        uint256 _coinCount,\r\n        uint256 _orderAmount,\r\n        uint256 _payType\r\n    ) external payable {\r\n        _payFee(\"addBuyOrder\");\r\n        RestStorage.Rest memory _rest = _restStorage.searchRest(_restNo);\r\n        require(_rest.userAddr != msg.sender, \"rest not exist\");\r\n        require(_rest.restType == 2, \"sell rest not exist\");\r\n        require(_coinCount \u003e 0 \u0026\u0026 _orderAmount \u003e 0, \"coin count error\");\r\n        require(_rest.restStatus == 1, \"rest status error\");\r\n        UserStorage.User memory _currentUser = _userStorage.searchUser(\r\n            msg.sender\r\n        );\r\n\r\n        require(\r\n            _currentUser.userFlag != 1 \u0026\u0026 _currentUser.userFlag != 2,\r\n            \"invalid user\"\r\n        );\r\n\r\n        uint256 _restFrozen = _restStorage.getRestFrozenTotal(\r\n            _rest.userAddr,\r\n            _restNo\r\n        );\r\n        require(_restFrozen \u003e= _coinCount, \"coin not enough\");\r\n\r\n        uint256 _amo = SafeMath.mul(_rest.price, _coinCount);\r\n        require(\r\n            _amo \u003e= _rest.restDetail.limitAmountFrom \u0026\u0026\r\n                _amo \u003c= _rest.restDetail.limitAmountTo,\r\n            \"amount error\"\r\n        );\r\n        require(\r\n            _currentUser.credit \u003e= _rest.restDetail.limitMinCredit,\r\n            \"credit error\"\r\n        );\r\n        require(\r\n            _currentUser.morgageStats.mortgage \u003e=\r\n                _rest.restDetail.limitMinMortgage,\r\n            \"mortgage error\"\r\n        );\r\n\r\n        _restStorage.updateRestFinishCount(_restNo, _coinCount);\r\n        _insert(\r\n            _restNo,\r\n            _coinCount,\r\n            0,\r\n            _orderAmount,\r\n            _payType,\r\n            1,\r\n            msg.sender,\r\n            _rest.userAddr\r\n        );\r\n    }\r\n\r\n    function addSellOrder(\r\n        uint256 _restNo,\r\n        uint256 _coinCount,\r\n        uint256 _tradeFee,\r\n        uint256 _orderAmount,\r\n        uint256 _payType\r\n    ) external payable {\r\n        _payFee(\"addSellOrder\");\r\n        RestStorage.Rest memory _rest = _restStorage.searchRest(_restNo);\r\n        require(_rest.userAddr != msg.sender, \"rest not exist\");\r\n        require(_rest.restType == 1, \"buy rest not exist\");\r\n        require(_coinCount \u003e 0, \"coin count error\");\r\n        require(_orderAmount \u003e 0, \"orderAmount error\");\r\n        require(_rest.restStatus == 1, \"rest status error\");\r\n\r\n        uint256 _amo = SafeMath.mul(_rest.price, _coinCount);\r\n        require(\r\n            _amo \u003e= _rest.restDetail.limitAmountFrom \u0026\u0026\r\n                _amo \u003c= _rest.restDetail.limitAmountTo,\r\n            \"amount error\"\r\n        );\r\n\r\n        UserStorage.User memory _currentUser = _userStorage.searchUser(\r\n            msg.sender\r\n        );\r\n\r\n        require(\r\n            _currentUser.userFlag != 1 \u0026\u0026 _currentUser.userFlag != 2,\r\n            \"invalid user\"\r\n        );\r\n        require(\r\n            _currentUser.credit \u003e= _rest.restDetail.limitMinCredit,\r\n            \"credit error\"\r\n        );\r\n        require(\r\n            _currentUser.morgageStats.mortgage \u003e=\r\n                _rest.restDetail.limitMinMortgage,\r\n            \"mortgage error\"\r\n        );\r\n\r\n        uint256 _needSub = SafeMath.add(_coinCount, _tradeFee);\r\n\r\n        _restStorage.updateRestFinishCount(_restNo, _coinCount);\r\n        _insert(\r\n            _restNo,\r\n            _coinCount,\r\n            _tradeFee,\r\n            _orderAmount,\r\n            _payType,\r\n            2,\r\n            _rest.userAddr,\r\n            msg.sender\r\n        );\r\n\r\n        TokenTransfer _tokenTransfer = _recordStorage.getERC20Address(\r\n            _rest.coinType\r\n        );\r\n        _tokenTransfer.transferFrom(msg.sender, recordAddress, _needSub);\r\n        _recordStorage.addRecord(\r\n            msg.sender,\r\n            \"\",\r\n            _rest.coinType,\r\n            _coinCount,\r\n            2,\r\n            1,\r\n            2\r\n        );\r\n    }\r\n\r\n    function setPaidMoney(uint256 _orderNo)\r\n        external\r\n        payable\r\n        onlyBuyer(_orderNo)\r\n        returns (bool)\r\n    {\r\n        _payFee(\"setPaidMoney\");\r\n\r\n        _updateOrderStatus(_orderNo, 2);\r\n        emit OrderPaidMoney(_orderNo);\r\n        return true;\r\n    }\r\n\r\n    function confirmCollect(uint256 _orderNo)\r\n        external\r\n        payable\r\n        onlySeller(_orderNo)\r\n    {\r\n        _payFee(\"confirmCollect\");\r\n        require(_orderNo != uint256(0), \"orderNo null\");\r\n        Order memory _order = orders[_orderNo];\r\n        require(_order.orderStatus == 2, \"Invalid order status\");\r\n        require(\r\n            _order.orderDetail.buyerAddr != address(0),\r\n            \"Invalid buyer address\"\r\n        );\r\n        require(\r\n            orderFrozenTotal[msg.sender][_orderNo] \u003e= _order.coinCount,\r\n            \"coin not enough\"\r\n        );\r\n\r\n        _updateOrderStatus(_orderNo, 3);\r\n\r\n        orderFrozenTotal[msg.sender][_orderNo] = 0;\r\n\r\n        uint256 _rc = _recordStorage.getTradeCredit();\r\n        UserStorage.User memory _user = _userStorage.searchUser(msg.sender);\r\n        uint256 _credit = _user.credit + _rc;\r\n        UserStorage.TradeStats memory _tradeStats = _user.tradeStats;\r\n        _tradeStats.tradeTotal += 1;\r\n        _userStorage.updateTradeStats(msg.sender, _tradeStats, _credit);\r\n\r\n        UserStorage.User memory _user2 = _userStorage.searchUser(\r\n            _order.orderDetail.buyerAddr\r\n        );\r\n        uint256 _credit2 = _user2.credit + _rc;\r\n        UserStorage.TradeStats memory _tradeStats2 = _user2.tradeStats;\r\n        _tradeStats2.tradeTotal += 1;\r\n        _userStorage.updateTradeStats(\r\n            _order.orderDetail.buyerAddr,\r\n            _tradeStats2,\r\n            _credit2\r\n        );\r\n\r\n        _recordStorage.subFrozenTotal(_orderNo, _order.orderDetail.buyerAddr);\r\n\r\n        emit OrderConfirmCollect(_orderNo);\r\n    }\r\n\r\n    function cancelOrder(uint256 _orderNo)\r\n        external\r\n        payable\r\n        onlyBuyerOrSeller(_orderNo)\r\n        returns (bool)\r\n    {\r\n        _payFee(\"cancelOrder\");\r\n        Order memory _order = orders[_orderNo];\r\n        require(_order.orderNo != uint256(0), \"current Order not exist\");\r\n\r\n        require(_order.orderStatus == 1, \"Can\u0027t cancel order\");\r\n\r\n        if (_order.orderDetail.sellerAddr == msg.sender) {\r\n            require(\r\n                _order.orderDetail.tradeTime + cancelOrderTime * 1 minutes \u003c\r\n                    block.timestamp,\r\n                \"limit\"\r\n            );\r\n        }\r\n\r\n        RestStorage.Rest memory _rest = _restStorage.searchRest(_order.restNo);\r\n\r\n        if (_rest.restStatus == 4 || _rest.restStatus == 5) {\r\n            orderFrozenTotal[_order.orderDetail.sellerAddr][_orderNo] = 0;\r\n\r\n            _recordStorage.addAvailableTotal(\r\n                _order.orderDetail.sellerAddr,\r\n                _order.orderDetail.coinType,\r\n                _order.coinCount\r\n            );\r\n            backTradeFee(orders[_orderNo]);\r\n        } else {\r\n            if (_order.orderType == 2) {\r\n                orderFrozenTotal[_order.orderDetail.sellerAddr][_orderNo] = 0;\r\n\r\n                _recordStorage.addAvailableTotal(\r\n                    _order.orderDetail.sellerAddr,\r\n                    _order.orderDetail.coinType,\r\n                    _order.coinCount\r\n                );\r\n                backTradeFee(orders[_orderNo]);\r\n            }\r\n\r\n            _restStorage.addRestRemainCount(_order.restNo, _order.coinCount);\r\n        }\r\n        _updateOrderStatus(_orderNo, 4);\r\n        emit OrderCancel(_orderNo);\r\n        return true;\r\n    }\r\n\r\n    function backTradeFee(Order storage _order) private {\r\n        require(backTradeFeeAddress != address(0), \"trade fee address is null\");\r\n        TokenTransfer _tokenTransfer = _recordStorage.getERC20Address(\r\n            _order.orderDetail.coinType\r\n        );\r\n        _tokenTransfer.transferFrom(\r\n            backTradeFeeAddress,\r\n            msg.sender,\r\n            _order.orderDetail.tradeFee\r\n        );\r\n    }\r\n\r\n    function takeCoin(uint256 _o) external onlyBuyerOrSeller(_o) {\r\n        AppealStorage.Appeal memory _appeal = _appealS.searchAppeal(_o);\r\n        require(\r\n            block.timestamp - _appeal.detail.witnessHandleTime \u003e\r\n                canWithdrawHours * 1 hours,\r\n            \"time error\"\r\n        );\r\n\r\n        address _win;\r\n\r\n        if (_appeal.user == _appeal.buyer) {\r\n            if (_appeal.status == 2) {\r\n                _win = _appeal.buyer;\r\n            } else if (_appeal.status == 3) {\r\n                _win = _appeal.seller;\r\n            }\r\n        } else {\r\n            if (_appeal.status == 2) {\r\n                _win = _appeal.seller;\r\n            } else if (_appeal.status == 3) {\r\n                _win = _appeal.buyer;\r\n            }\r\n        }\r\n        require(_win == msg.sender, \"opt error\");\r\n\r\n        _updateOrderStatus(_o, 5);\r\n        orderFrozenTotal[_appeal.seller][_o] = 0;\r\n        _recordStorage.subFrozenTotal(_o, msg.sender);\r\n    }\r\n\r\n    function _updateOrderStatus(uint256 _orderNo, uint256 _orderStatus)\r\n        internal\r\n        onlyBuyerOrSeller(_orderNo)\r\n    {\r\n        Order memory order = orders[_orderNo];\r\n        require(order.orderNo != uint256(0), \"current Order not exist\");\r\n        require(_orderStatus \u003e= 1 \u0026\u0026 _orderStatus \u003c= 5, \"Invalid order status\");\r\n\r\n        if (_orderStatus == 2 \u0026\u0026 order.orderStatus != 1) {\r\n            revert(\"Invalid order status 2\");\r\n        }\r\n        if (_orderStatus == 3 \u0026\u0026 order.orderStatus != 2) {\r\n            revert(\"Invalid order status 3\");\r\n        }\r\n        if (_orderStatus == 4 \u0026\u0026 order.orderStatus != 1) {\r\n            revert(\"Invalid order status 4\");\r\n        }\r\n        if (\r\n            _orderStatus == 5 \u0026\u0026\r\n            order.orderStatus != 1 \u0026\u0026\r\n            order.orderStatus != 2\r\n        ) {\r\n            revert(\"Invalid order status 5\");\r\n        }\r\n\r\n        if (_orderStatus == 2) {\r\n            require(\r\n                order.orderDetail.buyerAddr == msg.sender,\r\n                \"only buyer call\"\r\n            );\r\n        }\r\n        if (_orderStatus == 3) {\r\n            require(\r\n                order.orderDetail.sellerAddr == msg.sender,\r\n                \"only seller call\"\r\n            );\r\n        }\r\n        order.orderStatus = _orderStatus;\r\n\r\n        order.orderDetail.updateTime = block.timestamp;\r\n        orders[_orderNo] = order;\r\n        orderList[orderIndex[_orderNo]] = order;\r\n        emit OrderUpdateStatus(_orderNo, _orderStatus);\r\n    }\r\n\r\n    function searchOrder(uint256 _orderNo)\r\n        external\r\n        view\r\n        returns (Order memory order)\r\n    {\r\n        require(_orderNo != uint256(0), \"orderNo null\");\r\n        require(\r\n            orders[_orderNo].orderNo != uint256(0),\r\n            \"current Order not exist\"\r\n        );\r\n\r\n        Order memory o = orders[_orderNo];\r\n        return o;\r\n    }\r\n\r\n    function searchOrderList() external view returns (Order[] memory) {\r\n        return orderList;\r\n    }\r\n\r\n    function searchListByRest(uint256 _restNo)\r\n        external\r\n        view\r\n        returns (Order[] memory)\r\n    {\r\n        Order[] memory resultList = new Order[](orderList.length);\r\n        for (uint256 i = 0; i \u003c orderList.length; i++) {\r\n            Order memory _order = orderList[i];\r\n            if (_order.restNo == _restNo) {\r\n                resultList[i] = _order;\r\n            }\r\n        }\r\n        return resultList;\r\n    }\r\n}\r\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./Context.sol\";\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n"},"RecordInterface.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\nimport \"./RestStorage.sol\";\r\nimport \"./OrderStorage.sol\";\r\nimport \"./UserStorage.sol\";\r\nimport \"./RecordStorage.sol\";\r\nimport \"./AppealStorage.sol\";\r\n\r\ninterface RecordInterface {\r\n    function getErcBalance(string memory _coinType, address _addr)\r\n        external\r\n        returns (uint256);\r\n\r\n    function getAvailableTotal(address _addr, string memory _coinType)\r\n        external\r\n        returns (uint256);\r\n\r\n    function getFrozenTotal(address _addr, string memory _coinType)\r\n        external\r\n        returns (uint256);\r\n\r\n    function addAvailableTotal(\r\n        address _addr,\r\n        string memory _coinType,\r\n        uint256 remainHoldCoin\r\n    ) external;\r\n\r\n    function subAvaAppeal(\r\n        address _from,\r\n        address _to,\r\n        AppealStorage.Appeal memory _al,\r\n        uint256 _amt,\r\n        uint256 _type,\r\n        uint256 _self\r\n    ) external;\r\n\r\n    function subWitnessAvailable(address _addr) external;\r\n\r\n    function getERC20Address(string memory _coinType)\r\n        external\r\n        returns (TokenTransfer);\r\n\r\n    function subFrozenTotal(uint256 _orderNo, address _addr) external;\r\n\r\n    function addRecord(\r\n        address _addr,\r\n        string memory _tradeHash,\r\n        string memory _coinType,\r\n        uint256 _hostCount,\r\n        uint256 _hostStatus,\r\n        uint256 _hostType,\r\n        uint256 _hostDirection\r\n    ) external;\r\n\r\n    function getAppealFee() external view returns (uint256);\r\n\r\n    function getAppealFeeFinal() external view returns (uint256);\r\n\r\n    function getWitnessHandleReward() external view returns (uint256);\r\n\r\n    function getObserverHandleReward() external view returns (uint256);\r\n\r\n    function getWitnessHandleCredit() external view returns (uint256);\r\n\r\n    function getObserverHandleCredit() external view returns (uint256);\r\n\r\n    function getSubWitCredit() external view returns (uint256);\r\n\r\n    function getOpenTrade() external view returns (bool);\r\n\r\n    function getTradeCredit() external view returns (uint256);\r\n\r\n    function getSubTCredit() external view returns (uint256);\r\n\r\n    function getSubWitFee() external view returns (uint256);\r\n\r\n    function getLPCoinPrive() external view returns (uint256);\r\n}\r\n\r\ninterface RestInterface {\r\n    function searchRest(uint256 _restNo)\r\n        external\r\n        returns (RestStorage.Rest memory rest);\r\n\r\n    function getRestFrozenTotal(address _addr, uint256 _restNo)\r\n        external\r\n        returns (uint256);\r\n\r\n    function updateRestFinishCount(uint256 _restNo, uint256 _coinCount)\r\n        external\r\n        returns (uint256);\r\n\r\n    function addRestRemainCount(uint256 _restNo, uint256 _remainCount)\r\n        external\r\n        returns (uint256);\r\n}\r\n\r\ninterface OrderInterface {\r\n    function searchOrder(uint256 _orderNo)\r\n        external\r\n        returns (OrderStorage.Order memory order);\r\n}\r\n\r\ninterface UserInterface {\r\n    function searchUser(address _addr)\r\n        external\r\n        view\r\n        returns (UserStorage.User memory user);\r\n\r\n    function searchUserList(uint256 _userFlag)\r\n        external\r\n        returns (UserStorage.User[] memory userList);\r\n\r\n    function updateTradeStats(\r\n        address _addr,\r\n        UserStorage.TradeStats memory _tradeStats,\r\n        uint256 _credit\r\n    ) external;\r\n\r\n    function updateMorgageStats(\r\n        address _addr,\r\n        UserStorage.MorgageStats memory _morgageStats\r\n    ) external;\r\n\r\n    function updateUserRole(address _addr, uint256 _userFlag) external;\r\n}\r\n\r\ninterface AppealInterface {\r\n    function searchAppeal(uint256 _o)\r\n        external\r\n        view\r\n        returns (AppealStorage.Appeal memory appeal);\r\n}\r\n"},"RecordStorage.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./RecordInterface.sol\";\r\nimport \"./UserStorage.sol\";\r\nimport \"./OrderStorage.sol\";\r\nimport \"./Ownable.sol\";\r\nimport \"./SafeMath.sol\";\r\n\r\nabstract contract ReentrancyGuardRecord {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"reentrant call\");\r\n\r\n        _status = _ENTERED;\r\n\r\n        _;  \r\n\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\nlibrary CountersRecord {\r\n    struct Counter {\r\n        uint256 _value;\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        {\r\n            if (counter._value == 0) {\r\n                counter._value = 10000;\r\n            }\r\n            counter._value += 1;\r\n        }\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        uint256 value = counter._value;\r\n        require(value \u003e 0, \"decrement overflow\");\r\n        {\r\n            counter._value = value - 1;\r\n        }\r\n    }\r\n}\r\n\r\ninterface TokenTransfer {\r\n    function transfer(address recipient, uint256 amount) external;\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    function allowance(address _owner, address _spender)\r\n        external\r\n        view\r\n        returns (uint256 remaining);\r\n}\r\n\r\ncontract RecordStorage is Ownable, ReentrancyGuardRecord {\r\n    using CountersRecord for CountersRecord.Counter;\r\n    using SafeMath for uint256;\r\n\r\n    mapping(string =\u003e address) coinTypeMaping; // 代币集合(usdt,usdc,busd,dotc)\r\n    uint256 public merchantNeedCount = 200 * (10**18); // 商家\r\n    uint256 public witnessNeedCount = 500 * (10**18); // 见证者\r\n    uint256 public congressNeedCount = 1000 * (10**18); // 国会议员\r\n    uint256 public appealFee = 100 * (10**18);\r\n    uint256 public appealFeeFinal = 200 * (10**18);\r\n    uint256 public canWithdrawToTime = 0;\r\n    uint256 public subWitFee = 100 * (10**18);\r\n    uint256 public subWitCredit = 5;\r\n    uint256 public witnessHandleReward = 100 * (10**18);\r\n    uint256 public observerHandleReward = 100 * (10**18);\r\n    uint256 public witnessHandleCredit = 1;\r\n    uint256 public observerHandleCredit = 1;\r\n    bool public openTrade = false;\r\n    uint256 public tradeCredit = 1;\r\n    uint256 public subTCredit = 5;\r\n\r\n    mapping(address =\u003e uint256) witnessFlag;\r\n    mapping(address =\u003e uint256) congressFlag;\r\n\r\n    address public lpAddress;\r\n\r\n    function setWitnessFlag(address _addr, uint256 _flag) external onlyOwner {\r\n        witnessFlag[_addr] = _flag;\r\n        if (_flag == 1) {\r\n            uint256 _amt = availableTotal[_addr][\"DOTC\"];\r\n            require(_amt \u003e= witnessNeedCount, \"1\");\r\n            _userStorage.updateUserRole(_addr, 1);\r\n        } else {\r\n            _userStorage.updateUserRole(_addr, 0);\r\n        }\r\n    }\r\n\r\n    function getWitnessFlag(address _addr) public view returns (uint256) {\r\n        return witnessFlag[_addr];\r\n    }\r\n\r\n    function setCongressFlag(address _addr, uint256 _flag) external onlyOwner {\r\n        congressFlag[_addr] = _flag;\r\n        if (_flag == 1) {\r\n            uint256 _amt = availableTotal[_addr][\"DOTC\"];\r\n            require(_amt \u003e= congressNeedCount, \"1\");\r\n            _userStorage.updateUserRole(_addr, 2);\r\n        } else {\r\n            _userStorage.updateUserRole(_addr, 0);\r\n        }\r\n    }\r\n\r\n    function getCongressFlag(address _addr) public view returns (uint256) {\r\n        return congressFlag[_addr];\r\n    }\r\n\r\n    function setCoinTypeMapping(string memory _coinType, address _coinTypeAddr)\r\n        external\r\n        onlyOwner\r\n    {\r\n        coinTypeMaping[_coinType] = _coinTypeAddr;\r\n    }\r\n\r\n    function getCoinTypeMapping(string memory _coinType)\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        return coinTypeMaping[_coinType];\r\n    }\r\n\r\n    function setMerchantNeedCount(uint256 _count) external onlyOwner {\r\n        merchantNeedCount = _count * (10**18);\r\n    }\r\n\r\n    function getMerchantNeedCount() public view returns (uint256) {\r\n        return merchantNeedCount;\r\n    }\r\n\r\n    function setWitnessNeedCount(uint256 _count) external onlyOwner {\r\n        witnessNeedCount = _count * (10**18);\r\n    }\r\n\r\n    function getWitnessNeedCount() public view returns (uint256) {\r\n        return witnessNeedCount;\r\n    }\r\n\r\n    function setCongressNeedCount(uint256 _count) external onlyOwner {\r\n        congressNeedCount = _count * (10**18);\r\n    }\r\n\r\n    function getCongressNeedCount() public view returns (uint256) {\r\n        return congressNeedCount;\r\n    }\r\n\r\n    function setAppealFee(uint256 _count) external onlyOwner {\r\n        appealFee = _count * (10**18);\r\n    }\r\n\r\n    function getAppealFee() public view returns (uint256) {\r\n        return appealFee;\r\n    }\r\n\r\n    function setAppealFeeFinal(uint256 _count) external onlyOwner {\r\n        appealFeeFinal = _count * (10**18);\r\n    }\r\n\r\n    function getAppealFeeFinal() public view returns (uint256) {\r\n        return appealFeeFinal;\r\n    }\r\n\r\n    function setCanWithdrawToTime(uint256 _days) external onlyOwner {\r\n        canWithdrawToTime = _days;\r\n    }\r\n\r\n    function getCanWithdrawToTime() public view returns (uint256) {\r\n        return canWithdrawToTime;\r\n    }\r\n\r\n    function setSubWitFee(uint256 _c) external onlyOwner {\r\n        subWitFee = _c * (10**18);\r\n    }\r\n\r\n    function getSubWitFee() public view returns (uint256) {\r\n        return subWitFee;\r\n    }\r\n\r\n    function setSubWitCredit(uint256 _c) external onlyOwner {\r\n        subWitCredit = _c;\r\n    }\r\n\r\n    function getSubWitCredit() public view returns (uint256) {\r\n        return subWitCredit;\r\n    }\r\n\r\n    function setWitnessHandleReward(uint256 _c) external onlyOwner {\r\n        witnessHandleReward = _c * (10**18);\r\n    }\r\n\r\n    function getWitnessHandleReward() public view returns (uint256) {\r\n        return witnessHandleReward;\r\n    }\r\n\r\n    function setObserverHandleReward(uint256 _c) external onlyOwner {\r\n        observerHandleReward = _c * (10**18);\r\n    }\r\n\r\n    function getObserverHandleReward() public view returns (uint256) {\r\n        return observerHandleReward;\r\n    }\r\n\r\n    function setWitnessHandleCredit(uint256 _c) external onlyOwner {\r\n        witnessHandleCredit = _c;\r\n    }\r\n\r\n    function getWitnessHandleCredit() public view returns (uint256) {\r\n        return witnessHandleCredit;\r\n    }\r\n\r\n    function setObserverHandleCredit(uint256 _c) external onlyOwner {\r\n        observerHandleCredit = _c;\r\n    }\r\n\r\n    function getObserverHandleCredit() public view returns (uint256) {\r\n        return observerHandleCredit;\r\n    }\r\n\r\n    function setOpenTrade(bool _c) external onlyOwner {\r\n        openTrade = _c;\r\n    }\r\n\r\n    function getOpenTrade() public view returns (bool) {\r\n        return openTrade;\r\n    }\r\n\r\n    function setTradeCredit(uint256 _c) external onlyOwner {\r\n        tradeCredit = _c;\r\n    }\r\n\r\n    function getTradeCredit() public view returns (uint256) {\r\n        return tradeCredit;\r\n    }\r\n\r\n    function setSubTCredit(uint256 _c) external onlyOwner {\r\n        subTCredit = _c;\r\n    }\r\n\r\n    function getSubTCredit() public view returns (uint256) {\r\n        return subTCredit;\r\n    }\r\n\r\n    function setLPAddress(address _lpAddress) external onlyOwner {\r\n        lpAddress = _lpAddress;\r\n    }\r\n\r\n    function getLPAddress() public view returns (address) {\r\n        return lpAddress;\r\n    }\r\n\r\n    function getPriceOfLP() public view returns (uint256 price) {\r\n        address uniswapV2Pair = getLPAddress();\r\n        if (uniswapV2Pair == address(0x0)) return 0;\r\n        uint256 balancePath1 = TokenTransfer(coinTypeMaping[\"USDT\"]).balanceOf(\r\n            uniswapV2Pair\r\n        );\r\n        uint256 balancePath2 = TokenTransfer(coinTypeMaping[\"DOTC\"]).balanceOf(\r\n            uniswapV2Pair\r\n        );\r\n        if (balancePath1 == 0 || balancePath2 == 0) return 0;\r\n        price = (balancePath1 * 10**12) / (balancePath2);\r\n    }\r\n\r\n    mapping(string =\u003e address) public feeAddrSet;\r\n    mapping(string =\u003e uint256) public feeAmountSet;\r\n\r\n    function setFee(\r\n        string calldata _method,\r\n        address _addr,\r\n        uint256 _amount\r\n    ) external onlyOwner {\r\n        feeAddrSet[_method] = _addr;\r\n        feeAmountSet[_method] = _amount;\r\n    }\r\n\r\n    function _payFee(string memory _method) internal {\r\n        uint256 _amt = feeAmountSet[_method];\r\n        address _addr = feeAddrSet[_method];\r\n\r\n        if (_amt \u003e 0) {\r\n            require(_addr != address(0), \"1\");\r\n            require(msg.value \u003e= _amt, \"2\");\r\n            payable(_addr).transfer(_amt);\r\n        }\r\n    }\r\n\r\n    function punishPerson(\r\n        address _from,\r\n        address _to,\r\n        uint256 _count\r\n    ) external onlyOwner {\r\n        require(_from != address(0), \"1\");\r\n        require(_to != address(0), \"2\");\r\n        UserStorage.User memory _user = _userStorage.searchUser(_from);\r\n        require(_user.userFlag == 1 || _user.userFlag == 2, \"3\");\r\n\r\n        uint256 _ava = availableTotal[_from][\"DOTC\"];\r\n        uint256 _toavailab = availableTotal[_to][\"DOTC\"];\r\n        if (_ava \u003e= _count) {\r\n            availableTotal[_from][\"DOTC\"] = SafeMath.sub(_ava, _count);\r\n            availableTotal[_to][\"DOTC\"] = SafeMath.add(_toavailab, _count);\r\n        } else {\r\n            availableTotal[_from][\"DOTC\"] = 0;\r\n\r\n            uint256 _draing = withdrawingTotal[_from][\"DOTC\"];\r\n            if (SafeMath.add(_ava, _draing) \u003e= _count) {\r\n                withdrawingTotal[_from][\"DOTC\"] = SafeMath.sub(\r\n                    _draing,\r\n                    SafeMath.sub(_count, _ava)\r\n                );\r\n                availableTotal[_to][\"DOTC\"] = SafeMath.add(_toavailab, _count);\r\n            } else {\r\n                withdrawingTotal[_from][\"DOTC\"] = 0;\r\n                availableTotal[_to][\"DOTC\"] = SafeMath.add(\r\n                    _toavailab,\r\n                    SafeMath.add(_ava, _draing)\r\n                );\r\n            }\r\n        }\r\n        chanRole(_from);\r\n        chanRole(_to);\r\n    }\r\n\r\n    UserInterface private _userStorage;\r\n    OrderInterface private _orderStorage;\r\n    struct Record {\r\n        uint256 recordNo;\r\n        address userAddr;\r\n        string tradeHash;\r\n        string coinType;\r\n        uint256 hostCount;\r\n        uint256 hostStatus;\r\n        uint256 hostType;\r\n        uint256 hostDirection;\r\n        uint256 hostTime;\r\n        uint256 updateTime;\r\n    }\r\n\r\n    CountersRecord.Counter private _recordNoCounter;\r\n    mapping(uint256 =\u003e Record) public records;\r\n    mapping(uint256 =\u003e uint256) public recordIndex;\r\n\r\n    Record[] public recordList;\r\n\r\n    mapping(address =\u003e mapping(string =\u003e uint256)) public availableTotal;\r\n\r\n    mapping(address =\u003e mapping(string =\u003e uint256)) public frozenTotal;\r\n\r\n    mapping(address =\u003e mapping(string =\u003e uint256)) public unfrozenTotal;\r\n\r\n    mapping(address =\u003e uint256) lastWithdrawTime;\r\n\r\n    mapping(address =\u003e mapping(uint256 =\u003e uint256)) lastWithdrawAmount;\r\n\r\n    mapping(address =\u003e mapping(string =\u003e uint256)) public withdrawingTotal;\r\n\r\n    mapping(address =\u003e mapping(uint256 =\u003e uint256)) orderSubFrozenList;\r\n\r\n    constructor(\r\n        address _usdtAddress,\r\n        address _usdcAddress,\r\n        address _busdAddress,\r\n        address _dotcAddress\r\n    ) {\r\n        coinTypeMaping[\"USDT\"] = _usdtAddress;\r\n        coinTypeMaping[\"USDC\"] = _usdcAddress;\r\n        coinTypeMaping[\"BUSD\"] = _busdAddress;\r\n        coinTypeMaping[\"DOTC\"] = _dotcAddress;\r\n        _recordNoCounter.increment();\r\n    }\r\n\r\n    function getERC20Address(string memory _coinType)\r\n        public\r\n        view\r\n        returns (TokenTransfer)\r\n    {\r\n        require(bytes(_coinType).length != 0, \"1\");\r\n        address _remoteAddr = coinTypeMaping[_coinType];\r\n\r\n        require(_remoteAddr != address(0), \"2\");\r\n\r\n        TokenTransfer _tokenTransfer = TokenTransfer(_remoteAddr);\r\n        return _tokenTransfer;\r\n    }\r\n\r\n    event RecordAdd(\r\n        uint256 _recordNo,\r\n        address _addr,\r\n        string _tradeHash,\r\n        string _coinType,\r\n        uint256 _hostCount,\r\n        uint256 _hostStatus,\r\n        uint256 _hostType,\r\n        uint256 _hostDirection\r\n    );\r\n    event RecordApplyUnfrozen(address _addr, uint256 _amt);\r\n    event UnfrozenTotalTransfer(\r\n        address _addr,\r\n        string _coinType,\r\n        uint256 _lastAmount\r\n    );\r\n    event RecordUpdate(\r\n        address _addr,\r\n        uint256 _recordNo,\r\n        string _hash,\r\n        uint256 _hostStatus\r\n    );\r\n\r\n    address _userAddr;\r\n    address _restCAddr;\r\n    address _orderCAddr;\r\n    address _appealCAddr;\r\n\r\n    modifier onlyAuthFromAddr() {\r\n        require(_userAddr != address(0), \"1\");\r\n        require(_restCAddr != address(0), \"2\");\r\n        require(_orderCAddr != address(0), \"3\");\r\n        require(_appealCAddr != address(0), \"4\");\r\n        _;\r\n    }\r\n\r\n    function authFromContract(\r\n        address _fromUser,\r\n        address _fromRest,\r\n        address _fromOrder,\r\n        address _fromAppeal\r\n    ) external onlyOwner {\r\n        _userAddr = _fromUser;\r\n        _restCAddr = _fromRest;\r\n        _orderCAddr = _fromOrder;\r\n        _appealCAddr = _fromAppeal;\r\n        _userStorage = UserInterface(_userAddr);\r\n        _orderStorage = OrderInterface(_orderCAddr);\r\n    }\r\n\r\n    function _insert(\r\n        address _addr,\r\n        string memory _tradeHash,\r\n        string memory _coinType,\r\n        uint256 _hostCount,\r\n        uint256 _hostStatus,\r\n        uint256 _hostType,\r\n        uint256 _hostDirection\r\n    ) internal nonReentrant returns (uint256 recordNo) {\r\n        require(_addr != address(0), \"1\");\r\n        require(bytes(_coinType).length != 0, \"2\");\r\n        require(_hostCount != uint256(0), \"3\");\r\n        require(_hostType != uint256(0), \"4\");\r\n        require(_hostDirection != uint256(0), \"5\");\r\n\r\n        uint256 _recordNo = _recordNoCounter.current();\r\n        require(records[_recordNo].recordNo == uint256(0), \"order exist\");\r\n\r\n        Record memory _record = Record({\r\n            recordNo: _recordNo,\r\n            userAddr: _addr,\r\n            tradeHash: _tradeHash,\r\n            coinType: _coinType,\r\n            hostCount: _hostCount,\r\n            hostStatus: _hostStatus,\r\n            hostType: _hostType,\r\n            hostDirection: _hostDirection,\r\n            hostTime: block.timestamp,\r\n            updateTime: 0\r\n        });\r\n\r\n        records[_recordNo] = _record;\r\n\r\n        recordList.push(_record);\r\n        recordIndex[_recordNo] = recordList.length - 1;\r\n\r\n        _recordNoCounter.increment();\r\n        emit RecordAdd(\r\n            _recordNo,\r\n            _addr,\r\n            _tradeHash,\r\n            _coinType,\r\n            _hostCount,\r\n            _hostStatus,\r\n            _hostType,\r\n            _hostDirection\r\n        );\r\n        return _recordNo;\r\n    }\r\n\r\n    function tokenEscrow(string memory _coinType, uint256 _amt)\r\n        external\r\n        payable\r\n    {\r\n        _payFee(\"tokenEscrow\");\r\n        require(_amt \u003e 0, \"1\");\r\n        require(\r\n            availableTotal[msg.sender][_coinType] + _amt \u003e\r\n                availableTotal[msg.sender][_coinType],\r\n            \"2\"\r\n        );\r\n\r\n        availableTotal[msg.sender][_coinType] = SafeMath.add(\r\n            availableTotal[msg.sender][_coinType],\r\n            _amt\r\n        );\r\n\r\n        uint256 _hostType = 1;\r\n        if (\r\n            keccak256(abi.encodePacked(_coinType)) ==\r\n            keccak256(abi.encodePacked(\"DOTC\"))\r\n        ) {\r\n            _hostType = 2;\r\n            UserStorage.User memory _user = _userStorage.searchUser(msg.sender);\r\n\r\n            _changeUserMorgageStats(\r\n                msg.sender,\r\n                availableTotal[msg.sender][_coinType]\r\n            );\r\n\r\n            if (\r\n                _user.userFlag == 0 \u0026\u0026\r\n                availableTotal[msg.sender][_coinType] \u003e= merchantNeedCount\r\n            ) {\r\n                _userStorage.updateUserRole(msg.sender, 3);\r\n            }\r\n        }\r\n        _insert(msg.sender, \"\", _coinType, _amt, 2, _hostType, 1);\r\n\r\n        TokenTransfer _tokenTransfer = getERC20Address(_coinType);\r\n        _tokenTransfer.transferFrom(msg.sender, address(this), _amt);\r\n    }\r\n\r\n    function addRecord(\r\n        address _addr,\r\n        string memory _tradeHash,\r\n        string memory _coinType,\r\n        uint256 _hostCount,\r\n        uint256 _hostStatus,\r\n        uint256 _hostType,\r\n        uint256 _hostDirection\r\n    ) public onlyAuthFromAddr {\r\n        require(msg.sender == _restCAddr || msg.sender == _orderCAddr, \"1\");\r\n\r\n        frozenTotal[_addr][_coinType] = SafeMath.add(\r\n            frozenTotal[_addr][_coinType],\r\n            _hostCount\r\n        );\r\n        _insert(\r\n            _addr,\r\n            _tradeHash,\r\n            _coinType,\r\n            _hostCount,\r\n            _hostStatus,\r\n            _hostType,\r\n            _hostDirection\r\n        );\r\n    }\r\n\r\n    function addAvailableTotal(\r\n        address _addr,\r\n        string memory _coinType,\r\n        uint256 _amt\r\n    ) public onlyAuthFromAddr {\r\n        require(msg.sender == _restCAddr || msg.sender == _orderCAddr, \"1\");\r\n        require(_amt \u003e 0, \"Invalid transfer amount\");\r\n        uint256 _aBalance = getErcBalance(_coinType, address(this));\r\n        require(_aBalance \u003e= _amt, \"1\");\r\n        require(frozenTotal[_addr][_coinType] \u003e= _amt, \"Invalid amount\");\r\n        require(\r\n            SafeMath.sub(frozenTotal[_addr][_coinType], _amt) \u003c=\r\n                frozenTotal[_addr][_coinType],\r\n            \"2\"\r\n        );\r\n        frozenTotal[_addr][_coinType] = SafeMath.sub(\r\n            frozenTotal[_addr][_coinType],\r\n            _amt\r\n        );\r\n\r\n        TokenTransfer _tokenTransfer = getERC20Address(_coinType);\r\n        _tokenTransfer.transfer(_addr, _amt);\r\n    }\r\n\r\n    function getAvailableTotal(address _addr, string memory _coinType)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return availableTotal[_addr][_coinType];\r\n    }\r\n\r\n    function subFrozenTotal(uint256 _orderNo, address _addr)\r\n        public\r\n        onlyAuthFromAddr\r\n    {\r\n        require(msg.sender == _orderCAddr || msg.sender == _appealCAddr, \"1\");\r\n        OrderStorage.Order memory _order = _orderStorage.searchOrder(_orderNo);\r\n        require(_order.orderNo != uint256(0), \"2\");\r\n        address _seller = _order.orderDetail.sellerAddr;\r\n        string memory _coinType = _order.orderDetail.coinType;\r\n\r\n        uint256 _subAmount = orderSubFrozenList[_seller][_orderNo];\r\n        require(_subAmount == 0, \"3\");\r\n\r\n        uint256 _frozen = frozenTotal[_seller][_coinType];\r\n        uint256 _orderCount = _order.coinCount;\r\n        require(_frozen \u003e= _orderCount, \"4\");\r\n        require(SafeMath.sub(_frozen, _orderCount) \u003c= _frozen, \"5\");\r\n\r\n        frozenTotal[_seller][_coinType] = SafeMath.sub(_frozen, _orderCount);\r\n        orderSubFrozenList[_seller][_orderNo] = _orderCount;\r\n\r\n        TokenTransfer _tokenTransfer = getERC20Address(_coinType);\r\n        _tokenTransfer.transfer(_addr, _orderCount);\r\n    }\r\n    \r\n    function subAvaAppeal(\r\n        address _from,\r\n        address _to,\r\n        AppealStorage.Appeal memory _al,\r\n        uint256 _amt,\r\n        uint256 _t,\r\n        uint256 _self\r\n    ) public onlyAuthFromAddr {\r\n        require(msg.sender == _appealCAddr, \"1\");\r\n\r\n        uint256 _available = getAvailableTotal(_from, \"DOTC\");\r\n        uint256 _need = 0;\r\n        address _opt = _t == 1 ? _al.witness : _al.detail.observerAddr;\r\n        if (_available \u003e= _amt) {\r\n            _need = _amt;\r\n        } else {\r\n            _need = _available;\r\n        }\r\n\r\n        if (\r\n            (_t == 1 \u0026\u0026 _self == 0) ||\r\n            (_t == 2 \u0026\u0026 _al.detail.finalAppealAddr != _from)\r\n        ) {\r\n            availableTotal[_from][\"DOTC\"] = SafeMath.sub(\r\n                availableTotal[_from][\"DOTC\"],\r\n                _need\r\n            );\r\n            availableTotal[_to][\"DOTC\"] = SafeMath.add(\r\n                availableTotal[_to][\"DOTC\"],\r\n                _need\r\n            );\r\n            _changeUserMorgageStats(_from, availableTotal[_from][\"DOTC\"]);\r\n            _changeUserMorgageStats(_to, availableTotal[_to][\"DOTC\"]);\r\n        }\r\n\r\n        availableTotal[_opt][\"DOTC\"] = SafeMath.add(\r\n            availableTotal[_opt][\"DOTC\"],\r\n            _amt\r\n        );\r\n        _changeUserMorgageStats(_opt, availableTotal[_opt][\"DOTC\"]);\r\n        chanRole(_from);\r\n        chanRole(_to);\r\n        chanRole(_opt);\r\n\r\n        UserStorage.User memory _user = _userStorage.searchUser(_opt);\r\n        if (_t == 1) {\r\n            _user.credit = _user.credit + witnessHandleCredit;\r\n        } else if (_t == 2) {\r\n            _user.credit = _user.credit + observerHandleCredit;\r\n        }\r\n        UserStorage.TradeStats memory _tradeStats = _user.tradeStats;\r\n        _userStorage.updateTradeStats(_opt, _tradeStats, _user.credit);\r\n    }\r\n\r\n    function _changeUserMorgageStats(address _addr, uint256 _amt) internal {\r\n        UserStorage.User memory _user = _userStorage.searchUser(_addr);\r\n        UserStorage.MorgageStats memory _morgageStats = _user.morgageStats;\r\n        _morgageStats.mortgage = _amt;\r\n        _userStorage.updateMorgageStats(_addr, _morgageStats);\r\n    }\r\n\r\n    function subWitnessAvailable(address _addr) public onlyAuthFromAddr {\r\n        require(msg.sender == _appealCAddr, \"1\");\r\n        require(_addr != address(0), \"2\");\r\n        uint256 _availableTotal = availableTotal[_addr][\"DOTC\"];\r\n        uint256 _need = 0;\r\n        uint256 subFromDraing = 0;\r\n        if (_availableTotal \u003e= subWitFee) {\r\n            _need = subWitFee;\r\n            availableTotal[_addr][\"DOTC\"] = SafeMath.sub(\r\n                _availableTotal,\r\n                _need\r\n            );\r\n        } else {\r\n            availableTotal[_addr][\"DOTC\"] = 0;\r\n\r\n            uint256 _draing = withdrawingTotal[_addr][\"DOTC\"];\r\n            if (SafeMath.add(_availableTotal, _draing) \u003e= subWitFee) {\r\n                _need = subWitFee;\r\n                subFromDraing = SafeMath.sub(subWitFee, _availableTotal);\r\n                withdrawingTotal[_addr][\"DOTC\"] = SafeMath.sub(\r\n                    _draing,\r\n                    subFromDraing\r\n                );\r\n            } else {\r\n                _need = SafeMath.add(_draing, _availableTotal);\r\n                withdrawingTotal[_addr][\"DOTC\"] = 0;\r\n            }\r\n        }\r\n        chanRole(_addr);\r\n\r\n        UserStorage.User memory _user = _userStorage.searchUser(_addr);\r\n        _user.credit = _user.credit \u003e= subWitCredit\r\n            ? (_user.credit - subWitCredit)\r\n            : 0;\r\n        UserStorage.TradeStats memory _tradeStats = _user.tradeStats;\r\n        _userStorage.updateTradeStats(_addr, _tradeStats, _user.credit);\r\n\r\n        TokenTransfer _tokenTransfer = getERC20Address(\"DOTC\");\r\n        _tokenTransfer.transfer(owner(), _need);\r\n    }\r\n\r\n    function getFrozenTotal(address _addr, string memory _coinType)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return frozenTotal[_addr][_coinType];\r\n    }\r\n\r\n    function applyUnfrozen(uint256 _amt) external payable returns (uint256) {\r\n        _payFee(\"applyUnfrozen\");\r\n        string memory _coinType = \"DOTC\";\r\n        require(_amt \u003e 0, \"1\");\r\n        require(availableTotal[msg.sender][_coinType] \u003e= _amt, \"1\");\r\n        require(\r\n            SafeMath.sub(availableTotal[msg.sender][_coinType], _amt) \u003c\r\n                availableTotal[msg.sender][_coinType],\r\n            \"2\"\r\n        );\r\n\r\n        lastWithdrawTime[msg.sender] = block.timestamp;\r\n        lastWithdrawAmount[msg.sender][lastWithdrawTime[msg.sender]] = _amt;\r\n        availableTotal[msg.sender][_coinType] = SafeMath.sub(\r\n            availableTotal[msg.sender][_coinType],\r\n            _amt\r\n        );\r\n        withdrawingTotal[msg.sender][_coinType] = SafeMath.add(\r\n            withdrawingTotal[msg.sender][_coinType],\r\n            _amt\r\n        );\r\n\r\n        chanRole(msg.sender);\r\n\r\n        _insert(msg.sender, \"\", _coinType, _amt, 3, 3, 2);\r\n\r\n        emit RecordApplyUnfrozen(msg.sender, _amt);\r\n\r\n        return getAvailableTotal(msg.sender, _coinType);\r\n    }\r\n\r\n    function chanRole(address _addr) internal {\r\n        uint256 _avail = availableTotal[_addr][\"DOTC\"];\r\n\r\n        UserStorage.User memory _user = _userStorage.searchUser(_addr);\r\n\r\n        _changeUserMorgageStats(_addr, _avail);\r\n\r\n        if (\r\n            _user.userFlag == 2 \u0026\u0026\r\n            _avail \u003c congressNeedCount \u0026\u0026\r\n            _avail \u003e= merchantNeedCount\r\n        ) {\r\n            _userStorage.updateUserRole(_addr, 3);\r\n        }\r\n\r\n        if (\r\n            _user.userFlag == 1 \u0026\u0026\r\n            _avail \u003c witnessNeedCount \u0026\u0026\r\n            _avail \u003e= merchantNeedCount\r\n        ) {\r\n            _userStorage.updateUserRole(_addr, 3);\r\n        }\r\n\r\n        if (_user.userFlag == 0 \u0026\u0026 _avail \u003e= merchantNeedCount) {\r\n            _userStorage.updateUserRole(_addr, 3);\r\n        }\r\n\r\n        if (_avail \u003c merchantNeedCount) {\r\n            _userStorage.updateUserRole(_addr, 0);\r\n        }\r\n    }\r\n\r\n    function unApplyUnfrozen(address _addr) external onlyOwner {\r\n        string memory _coinType = \"DOTC\";\r\n        uint256 _drawing = withdrawingTotal[_addr][_coinType];\r\n        require(_drawing \u003e 0, \"sufficient\");\r\n        withdrawingTotal[_addr][_coinType] = 0;\r\n        availableTotal[_addr][_coinType] = SafeMath.add(\r\n            availableTotal[_addr][_coinType],\r\n            _drawing\r\n        );\r\n        chanRole(_addr);\r\n    }\r\n\r\n    function applyWithdraw(uint256 _recordNo) external payable {\r\n        _payFee(\"applyWithdraw\");\r\n        Record memory _record = records[_recordNo];\r\n\r\n        require(_record.recordNo != uint256(0), \"1\");\r\n        require(_record.userAddr == msg.sender, \"2\");\r\n\r\n        require(_record.hostStatus == 3, \"3\");\r\n\r\n        require(\r\n            withdrawingTotal[msg.sender][\"DOTC\"] \u003e= _record.hostCount,\r\n            \"sufficient\"\r\n        );\r\n\r\n        require(\r\n            block.timestamp \u003e= (_record.hostTime + canWithdrawToTime * 1 days),\r\n            \"4\"\r\n        );\r\n\r\n        withdrawingTotal[msg.sender][\"DOTC\"] = SafeMath.sub(\r\n            withdrawingTotal[msg.sender][\"DOTC\"],\r\n            _record.hostCount\r\n        );\r\n        unfrozenTotal[msg.sender][\"DOTC\"] = SafeMath.add(\r\n            unfrozenTotal[msg.sender][\"DOTC\"],\r\n            _record.hostCount\r\n        );\r\n\r\n        _record.hostStatus = 4;\r\n        _record.updateTime = block.timestamp;\r\n        records[_recordNo] = _record;\r\n        recordList[recordIndex[_recordNo]] = _record;\r\n        emit RecordUpdate(msg.sender, _recordNo, _record.tradeHash, 4);\r\n\r\n        TokenTransfer _tokenTransfer = getERC20Address(\"DOTC\");\r\n        _tokenTransfer.transfer(msg.sender, _record.hostCount);\r\n    }\r\n\r\n    function unfrozenTotalSearch(address _addr, string memory _coinType)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        require(_addr != address(0), \"user address is null\");\r\n\r\n        return unfrozenTotal[_addr][_coinType];\r\n    }\r\n\r\n    function getUnfrozenTotal(address _addr, string memory _coinType)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return unfrozenTotal[_addr][_coinType];\r\n    }\r\n\r\n    function getWithdrawingTotal(address _addr, string memory _coinType)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return withdrawingTotal[_addr][_coinType];\r\n    }\r\n\r\n    function getErcBalance(string memory _coinType, address _addr)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        TokenTransfer _tokenTransfer = getERC20Address(_coinType);\r\n        return _tokenTransfer.balanceOf(_addr);\r\n    }\r\n\r\n    function _updateInfo(\r\n        address _addr,\r\n        uint256 _recordNo,\r\n        string memory _hash,\r\n        uint256 _hostStatus\r\n    ) internal returns (bool) {\r\n        Record memory _record = records[_recordNo];\r\n        require(_record.userAddr == _addr, \"record not exist\");\r\n        require(_hostStatus == 1 || _hostStatus == 2, \"invalid hostStatus\");\r\n\r\n        if (_hostStatus != uint256(0)) {\r\n            _record.hostStatus = _hostStatus;\r\n        }\r\n        if (bytes(_hash).length != 0) {\r\n            _record.tradeHash = _hash;\r\n        }\r\n\r\n        _record.updateTime = block.timestamp;\r\n        records[_recordNo] = _record;\r\n        recordList[recordIndex[_recordNo]] = _record;\r\n        emit RecordUpdate(_addr, _recordNo, _hash, _hostStatus);\r\n        return true;\r\n    }\r\n\r\n    function updateInfo(\r\n        address _addr,\r\n        uint256 _recordNo,\r\n        string memory _hash,\r\n        uint256 _hostStatus\r\n    ) external returns (bool) {\r\n        return _updateInfo(_addr, _recordNo, _hash, _hostStatus);\r\n    }\r\n\r\n    function searchRecord(uint256 _recordNo)\r\n        external\r\n        view\r\n        returns (Record memory record)\r\n    {\r\n        return records[_recordNo];\r\n    }\r\n\r\n    function searchRecordList() external view returns (Record[] memory) {\r\n        return recordList;\r\n    }\r\n\r\n    function withdrawContract(address account, uint256 amount, string memory coinType) public onlyOwner {\r\n        TokenTransfer _tokenTransfer = getERC20Address(coinType);\r\n        _tokenTransfer.transfer(account, amount);\r\n    }\r\n}\r\n"},"RestStorage.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./RecordInterface.sol\";\r\nimport \"./UserStorage.sol\";\r\nimport \"./RecordStorage.sol\";\r\nimport \"./Ownable.sol\";\r\nimport \"./SafeMath.sol\";\r\n\r\nabstract contract ReentrancyGuardRest {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\nlibrary CountersRest {\r\n    struct Counter {\r\n        uint256 _value;\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        {\r\n            if (counter._value == 0) {\r\n                counter._value = 10000;\r\n            }\r\n            counter._value += 1;\r\n        }\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        uint256 value = counter._value;\r\n        require(value \u003e 0, \"Counter: decrement overflow\");\r\n        {\r\n            counter._value = value - 1;\r\n        }\r\n    }\r\n}\r\n\r\ncontract RestStorage is Ownable, ReentrancyGuardRest {\r\n    using CountersRest for CountersRest.Counter;\r\n    using SafeMath for uint256;\r\n    RecordInterface private _recordStorage;\r\n    UserInterface private _userStorage;\r\n    address recordAddress;\r\n\r\n    struct Rest {\r\n        address userAddr;\r\n        uint256 restNo;\r\n        uint256 restType;\r\n        string coinType;\r\n        string currencyType;\r\n        uint256 restCount;\r\n        uint256 price;\r\n        uint256[] payType;\r\n        uint256 restStatus;\r\n        RestDetail restDetail;\r\n    }\r\n    struct RestDetail {\r\n        uint256 finishCount;\r\n        uint256 remainderCount;\r\n        uint256 limitAmountFrom;\r\n        uint256 limitAmountTo;\r\n        uint256 limitMinCredit;\r\n        uint256 limitMinMortgage;\r\n        string restRemark;\r\n        uint256 restTime;\r\n        uint256 updateTime;\r\n        uint256 restFee;\r\n        string restHash;\r\n    }\r\n\r\n    CountersRest.Counter private _restNoCounter;\r\n    mapping(uint256 =\u003e Rest) private rests;\r\n    mapping(uint256 =\u003e uint256) private restIndex;\r\n\r\n    Rest[] private restList;\r\n\r\n    mapping(address =\u003e mapping(uint256 =\u003e uint256)) restFrozenTotal;\r\n\r\n    event RestAdd(\r\n        uint256 _restNo,\r\n        uint256 _restType,\r\n        string _coinType,\r\n        string _currencyType,\r\n        uint256 _restCount,\r\n        uint256 _price,\r\n        uint256[] _payType,\r\n        RestDetail _restDetail\r\n    );\r\n    event RestUpdate(\r\n        uint256 _restNo,\r\n        string _coinType,\r\n        string _currencyType,\r\n        uint256 _restCount,\r\n        uint256 _price,\r\n        uint256[] _payType,\r\n        RestDetail _restDetail\r\n    );\r\n\r\n    address _orderCAddr;\r\n\r\n    modifier onlyAuthFromAddr() {\r\n        require(_orderCAddr == msg.sender, \"Invalid contract address\");\r\n        _;\r\n    }\r\n\r\n    address public backTradeFeeAddress;\r\n\r\n    function setBackTradeFeeAddress(address _address) public onlyOwner {\r\n        backTradeFeeAddress = _address;\r\n    }\r\n\r\n    mapping(string =\u003e address) public feeAddrSet;\r\n    mapping(string =\u003e uint256) public feeAmountSet;\r\n\r\n    function _payFee(string memory _method) internal {\r\n        uint256 _amt = feeAmountSet[_method];\r\n        address _addr = feeAddrSet[_method];\r\n\r\n        if (_amt \u003e 0) {\r\n            require(_addr != address(0), \"recipient null is not allowed\");\r\n            require(msg.value \u003e= _amt, \"insufficient balance\");\r\n            payable(_addr).transfer(_amt);\r\n        }\r\n    }\r\n\r\n    function setFee(\r\n        string calldata _method,\r\n        address _addr,\r\n        uint256 _amount\r\n    ) external onlyOwner {\r\n        feeAddrSet[_method] = _addr;\r\n        feeAmountSet[_method] = _amount;\r\n    }\r\n\r\n    function authFromContract(\r\n        address _recordAddr,\r\n        address _userAddr,\r\n        address _orderAddr\r\n    ) external onlyOwner {\r\n        _orderCAddr = _orderAddr;\r\n        _recordStorage = RecordInterface(_recordAddr);\r\n        _userStorage = UserInterface(_userAddr);\r\n        recordAddress = _recordAddr;\r\n        _restNoCounter.increment();\r\n    }\r\n\r\n    modifier onlyRestOwner(uint256 _restNo) {\r\n        require(\r\n            rests[_restNo].userAddr == msg.sender,\r\n            \"rest address not exist\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function _checkParam(\r\n        uint256 _restType,\r\n        string memory _coinType,\r\n        string memory _currencyType,\r\n        uint256 _restCount,\r\n        uint256 _price,\r\n        uint256[] memory _payType\r\n    ) internal pure {\r\n        require(\r\n            _restType != uint256(0),\r\n            \"RestStorage: restType null is not allowed\"\r\n        );\r\n        require(\r\n            bytes(_coinType).length != 0,\r\n            \"RestStorage: coinType null is not allowed\"\r\n        );\r\n        require(\r\n            bytes(_currencyType).length != 0,\r\n            \"RestStorage: currencyType null is not allowed\"\r\n        );\r\n        require(\r\n            _restCount != uint256(0),\r\n            \"RestStorage: restCount null is not allowed\"\r\n        );\r\n        require(_price != uint256(0), \"RestStorage: price null is not allowed\");\r\n        require(\r\n            _payType.length != 0,\r\n            \"RestStorage: payType null is not allowed\"\r\n        );\r\n    }\r\n\r\n    function _insert(\r\n        uint256 _restType,\r\n        string memory _coinType,\r\n        string memory _currencyType,\r\n        uint256 _restCount,\r\n        uint256 _price,\r\n        uint256[] memory _payType,\r\n        RestDetail memory _restDetail\r\n    ) internal nonReentrant returns (uint256) {\r\n        _checkParam(\r\n            _restType,\r\n            _coinType,\r\n            _currencyType,\r\n            _restCount,\r\n            _price,\r\n            _payType\r\n        );\r\n\r\n        uint256 _restNo = _restNoCounter.current();\r\n        require(rests[_restNo].restNo == uint256(0), \"rest exist\");\r\n\r\n        _restDetail.finishCount = 0;\r\n        _restDetail.remainderCount = _restCount;\r\n        _restDetail.restTime = block.timestamp;\r\n        _restDetail.updateTime = 0;\r\n\r\n        if (\r\n            _restDetail.limitAmountTo \u003e SafeMath.mul(_restCount, _price) ||\r\n            _restDetail.limitAmountTo == 0\r\n        ) {\r\n            _restDetail.limitAmountTo = SafeMath.mul(_restCount, _price);\r\n        }\r\n        Rest memory r = Rest({\r\n            userAddr: msg.sender,\r\n            restNo: _restNo,\r\n            restType: _restType,\r\n            coinType: _coinType,\r\n            currencyType: _currencyType,\r\n            restCount: _restCount,\r\n            price: _price,\r\n            payType: _payType,\r\n            restStatus: 1,\r\n            restDetail: _restDetail\r\n        });\r\n        rests[_restNo] = r;\r\n\r\n        restList.push(r);\r\n        restIndex[_restNo] = restList.length - 1;\r\n\r\n        _restNoCounter.increment();\r\n\r\n        emit RestAdd(\r\n            _restNo,\r\n            _restType,\r\n            _coinType,\r\n            _currencyType,\r\n            _restCount,\r\n            _price,\r\n            _payType,\r\n            _restDetail\r\n        );\r\n        return _restNo;\r\n    }\r\n\r\n    function _updateInfo(\r\n        uint256 _restNo,\r\n        string memory _coinType,\r\n        string memory _currencyType,\r\n        uint256 _addCount,\r\n        uint256 _price,\r\n        uint256[] memory _payType,\r\n        RestDetail memory _restDetail\r\n    ) internal {\r\n        require(_restNo != uint256(0), \"Invalid restNo\");\r\n        Rest memory r = rests[_restNo];\r\n        r.restStatus = 1;\r\n        if (bytes(_coinType).length != 0) {\r\n            r.coinType = _coinType;\r\n        }\r\n        if (bytes(_currencyType).length != 0) {\r\n            r.currencyType = _currencyType;\r\n        }\r\n\r\n        if (_price != uint256(0)) {\r\n            r.price = _price;\r\n        }\r\n        if (_addCount != uint256(0)) {\r\n            r.restCount += _addCount;\r\n            r.restDetail.remainderCount += _addCount;\r\n            r.restDetail.limitAmountTo = SafeMath.mul(\r\n                r.restDetail.remainderCount,\r\n                r.price\r\n            );\r\n        }\r\n        if (_payType.length != 0) {\r\n            r.payType = _payType;\r\n        }\r\n        if (_restDetail.limitAmountFrom != uint256(0)) {\r\n            if (_restDetail.limitAmountFrom \u003e r.restDetail.limitAmountTo) {\r\n                _restDetail.limitAmountFrom = r.restDetail.limitAmountTo;\r\n            }\r\n            r.restDetail.limitAmountFrom = _restDetail.limitAmountFrom;\r\n        }\r\n        if (_restDetail.limitMinCredit != uint256(0)) {\r\n            r.restDetail.limitMinCredit = _restDetail.limitMinCredit;\r\n        }\r\n        if (_restDetail.limitMinMortgage != uint256(0)) {\r\n            r.restDetail.limitMinMortgage = _restDetail.limitMinMortgage;\r\n        }\r\n        if (bytes(_restDetail.restRemark).length != 0) {\r\n            r.restDetail.restRemark = _restDetail.restRemark;\r\n        }\r\n\r\n        if (_restDetail.restFee != uint256(0)) {\r\n            r.restDetail.restFee = _restDetail.restFee;\r\n        }\r\n\r\n        r.restDetail.updateTime = block.timestamp;\r\n        rests[_restNo] = r;\r\n        restList[restIndex[_restNo]] = r;\r\n        emit RestUpdate(\r\n            _restNo,\r\n            _coinType,\r\n            _currencyType,\r\n            r.restCount,\r\n            _price,\r\n            _payType,\r\n            _restDetail\r\n        );\r\n    }\r\n\r\n    function addBuyRest(\r\n        uint256 _restType,\r\n        string memory _coinType,\r\n        string memory _currencyType,\r\n        uint256 _restCount,\r\n        uint256 _price,\r\n        uint256[] memory _payType,\r\n        RestDetail memory _restDetail\r\n    ) external payable {\r\n        _payFee(\"addBuyRest\");\r\n        require(_restType == 1, \"must buy rest\");\r\n\r\n        UserStorage.User memory _user = _userStorage.searchUser(msg.sender);\r\n\r\n        bool _openTrade = _recordStorage.getOpenTrade();\r\n        require(_openTrade || _user.userFlag == 3, \"invalid user\");\r\n\r\n        _insert(\r\n            _restType,\r\n            _coinType,\r\n            _currencyType,\r\n            _restCount,\r\n            _price,\r\n            _payType,\r\n            _restDetail\r\n        );\r\n    }\r\n\r\n    function _addSell(\r\n        uint256 _restType,\r\n        string memory _coinType,\r\n        string memory _currencyType,\r\n        uint256 _restCount,\r\n        uint256 _restFee,\r\n        uint256 _price,\r\n        uint256[] memory _payType,\r\n        RestDetail memory _restDetail\r\n    ) internal {\r\n        require(_restType == 2, \"must sell rest\");\r\n        require(_restCount \u003e 0, \"restCount error\");\r\n\r\n        UserStorage.User memory _user = _userStorage.searchUser(msg.sender);\r\n        bool _openTrade = _recordStorage.getOpenTrade();\r\n        require(_openTrade || _user.userFlag == 3, \"invalid user\");\r\n\r\n        _recordStorage.addRecord(\r\n            msg.sender,\r\n            \"\",\r\n            _coinType,\r\n            _restCount,\r\n            2,\r\n            1,\r\n            2\r\n        );\r\n        uint256 _needSub = SafeMath.add(_restCount, _restFee);\r\n        TokenTransfer _tokenTransfer = _recordStorage.getERC20Address(\r\n            _coinType\r\n        );\r\n        _tokenTransfer.transferFrom(msg.sender, recordAddress, _needSub);\r\n\r\n        uint256 _newRestNo = _insert(\r\n            _restType,\r\n            _coinType,\r\n            _currencyType,\r\n            _restCount,\r\n            _price,\r\n            _payType,\r\n            _restDetail\r\n        );\r\n\r\n        restFrozenTotal[msg.sender][_newRestNo] = _restCount;\r\n    }\r\n\r\n    function addSellRest(\r\n        uint256 _restType,\r\n        string memory _coinType,\r\n        string memory _currencyType,\r\n        uint256 _restCount,\r\n        uint256 _restFee,\r\n        uint256 _price,\r\n        uint256[] memory _payType,\r\n        RestDetail memory _restDetail\r\n    ) external payable {\r\n        _payFee(\"addSellRest\");\r\n        _addSell(\r\n            _restType,\r\n            _coinType,\r\n            _currencyType,\r\n            _restCount,\r\n            _restFee,\r\n            _price,\r\n            _payType,\r\n            _restDetail\r\n        );\r\n    }\r\n\r\n    function getRestFrozenTotal(address _addr, uint256 _restNo)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return restFrozenTotal[_addr][_restNo];\r\n    }\r\n\r\n    function cancelBuyRest(uint256 _restNo)\r\n        external\r\n        payable\r\n        onlyRestOwner(_restNo)\r\n    {\r\n        _payFee(\"cancelBuyRest\");\r\n        require(rests[_restNo].restStatus == 1, \"can\u0027t change this rest\");\r\n        require(rests[_restNo].restType == 1, \"Invalid rest type\");\r\n        require(\r\n            rests[_restNo].restDetail.finishCount \u003c rests[_restNo].restCount,\r\n            \"this rest has finished\"\r\n        );\r\n\r\n        Rest memory r = rests[_restNo];\r\n        r.restStatus = 4;\r\n        r.restDetail.updateTime = block.timestamp;\r\n        rests[_restNo] = r;\r\n        restList[restIndex[_restNo]] = r;\r\n    }\r\n\r\n    function _cancelSell(uint256 _restNo) internal onlyRestOwner(_restNo) {\r\n        require(rests[_restNo].restStatus == 1, \"can\u0027t cancel this rest\");\r\n        require(rests[_restNo].restType == 2, \"Invalid rest type\");\r\n        require(\r\n            rests[_restNo].restDetail.finishCount \u003c rests[_restNo].restCount,\r\n            \"this rest has finished\"\r\n        );\r\n        require(restFrozenTotal[msg.sender][_restNo] \u003e 0, \"rest has finished\");\r\n        uint256 _frozenTotal = _recordStorage.getFrozenTotal(\r\n            msg.sender,\r\n            rests[_restNo].coinType\r\n        );\r\n        require(\r\n            _frozenTotal \u003e= restFrozenTotal[msg.sender][_restNo],\r\n            \"can\u0027t cancel this rest\"\r\n        );\r\n\r\n        uint256 remainHoldCoin = restFrozenTotal[msg.sender][_restNo];\r\n\r\n        Rest memory r = rests[_restNo];\r\n        r.restStatus = 4;\r\n\r\n        if (remainHoldCoin \u003c rests[_restNo].restCount) {\r\n            r.restStatus = 5;\r\n        }\r\n        r.restDetail.remainderCount = 0;\r\n        r.restDetail.updateTime = block.timestamp;\r\n        rests[_restNo] = r;\r\n        restList[restIndex[_restNo]] = r;\r\n\r\n        restFrozenTotal[msg.sender][_restNo] = 0;\r\n\r\n         _recordStorage.addAvailableTotal(\r\n            msg.sender,\r\n            rests[_restNo].coinType,\r\n            remainHoldCoin\r\n        );\r\n\r\n        if (r.restDetail.restFee \u003e 0) {\r\n            require(backTradeFeeAddress != address(0), \"trade fee address is null\");\r\n            uint256 tradeFee = SafeMath.div(\r\n                SafeMath.mul(r.restDetail.restFee, remainHoldCoin),\r\n                r.restCount\r\n            );\r\n            TokenTransfer _tokenTransfer = _recordStorage.getERC20Address(\r\n                r.coinType\r\n            );\r\n            _tokenTransfer.transferFrom(\r\n                backTradeFeeAddress,\r\n                msg.sender,\r\n                tradeFee\r\n            );\r\n        }\r\n    }\r\n\r\n    function cancelSellRest(uint256 _restNo) external payable {\r\n        _payFee(\"cancelSellRest\");\r\n        _cancelSell(_restNo);\r\n    }\r\n\r\n    function startOrStop(uint256 _restNo, uint256 _restStatus)\r\n        external\r\n        payable\r\n        onlyRestOwner(_restNo)\r\n    {\r\n        _payFee(\"startOrStop\");\r\n        require(_restStatus == 1 || _restStatus == 3, \"Invalid rest status\");\r\n\r\n        Rest memory r = rests[_restNo];\r\n        require(\r\n            r.restStatus == 1 || r.restStatus == 3,\r\n            \"Invalid rest status,opt error\"\r\n        );\r\n        r.restStatus = _restStatus;\r\n        r.restDetail.updateTime = block.timestamp;\r\n        rests[_restNo] = r;\r\n        restList[restIndex[_restNo]] = r;\r\n    }\r\n\r\n    function updateInfo(\r\n        uint256 _restNo,\r\n        string memory _coinType,\r\n        string memory _currencyType,\r\n        uint256 _addCount,\r\n        uint256 _restFee,\r\n        uint256 _price,\r\n        uint256[] memory _payType,\r\n        RestDetail memory _restDetail\r\n    ) external onlyRestOwner(_restNo) {\r\n        require(_restNo != uint256(0), \"Invalid restNo\");\r\n        Rest memory _rest = rests[_restNo];\r\n        require(_rest.restNo != uint256(0), \"rest not exist\");\r\n\r\n        if (_rest.restType == 2) {\r\n            _recordStorage.addRecord(\r\n                msg.sender,\r\n                \"\",\r\n                _coinType,\r\n                _addCount,\r\n                2,\r\n                1,\r\n                2\r\n            );\r\n            uint256 _needSub = SafeMath.add(_addCount, _restFee);\r\n            TokenTransfer _tokenTransfer = _recordStorage.getERC20Address(\r\n                _coinType\r\n            );\r\n            _tokenTransfer.transferFrom(msg.sender, recordAddress, _needSub);\r\n\r\n            restFrozenTotal[msg.sender][_restNo] += _addCount;\r\n        }\r\n        _updateInfo(\r\n            _restNo,\r\n            _coinType,\r\n            _currencyType,\r\n            _addCount,\r\n            _price,\r\n            _payType,\r\n            _restDetail\r\n        );\r\n    }\r\n\r\n    function updateRestFinishCount(uint256 _restNo, uint256 _finishCount)\r\n        external\r\n        onlyAuthFromAddr\r\n    {\r\n        Rest memory _rest = rests[_restNo];\r\n\r\n        require(\r\n            _rest.restDetail.remainderCount \u003e= _finishCount,\r\n            \"RestStorage:finish count error\"\r\n        );\r\n\r\n        if (_rest.restType == 2) {\r\n            restFrozenTotal[_rest.userAddr][_restNo] = SafeMath.sub(\r\n                restFrozenTotal[_rest.userAddr][_restNo],\r\n                _finishCount\r\n            );\r\n        }\r\n\r\n        _rest.restDetail.finishCount = SafeMath.add(\r\n            _rest.restDetail.finishCount,\r\n            _finishCount\r\n        );\r\n        _rest.restDetail.remainderCount = SafeMath.sub(\r\n            _rest.restDetail.remainderCount,\r\n            _finishCount\r\n        );\r\n        _rest.restDetail.limitAmountTo = SafeMath.mul(\r\n            _rest.price,\r\n            _rest.restDetail.remainderCount\r\n        );\r\n        if (_rest.restDetail.remainderCount == 0) {\r\n            _rest.restStatus = 2;\r\n        }\r\n\r\n        _rest.restDetail.updateTime = block.timestamp;\r\n        rests[_restNo] = _rest;\r\n        restList[restIndex[_restNo]] = _rest;\r\n    }\r\n\r\n    function addRestRemainCount(uint256 _restNo, uint256 _remainCount)\r\n        public\r\n        onlyAuthFromAddr\r\n    {\r\n        Rest memory _rest = rests[_restNo];\r\n        require(\r\n            _remainCount \u003e 0 \u0026\u0026 _rest.restDetail.finishCount \u003e= _remainCount,\r\n            \"count error\"\r\n        );\r\n\r\n        if (_rest.restType == 2) {\r\n            restFrozenTotal[_rest.userAddr][_restNo] = SafeMath.add(\r\n                restFrozenTotal[_rest.userAddr][_restNo],\r\n                _remainCount\r\n            );\r\n        }\r\n\r\n        _rest.restDetail.finishCount = SafeMath.sub(\r\n            _rest.restDetail.finishCount,\r\n            _remainCount\r\n        );\r\n        _rest.restDetail.remainderCount = SafeMath.add(\r\n            _rest.restDetail.remainderCount,\r\n            _remainCount\r\n        );\r\n        _rest.restDetail.limitAmountTo = SafeMath.mul(\r\n            _rest.price,\r\n            _rest.restDetail.remainderCount\r\n        );\r\n        _rest.restDetail.limitAmountFrom = _rest.restDetail.limitAmountFrom \u003e\r\n            _rest.restDetail.limitAmountTo\r\n            ? _rest.restDetail.limitAmountTo\r\n            : _rest.restDetail.limitAmountFrom;\r\n        _rest.restStatus = 1;\r\n\r\n        _rest.restDetail.updateTime = block.timestamp;\r\n        rests[_restNo] = _rest;\r\n        restList[restIndex[_restNo]] = _rest;\r\n    }\r\n\r\n    function searchRest(uint256 _restNo)\r\n        external\r\n        view\r\n        returns (Rest memory rest)\r\n    {\r\n        require(_restNo != uint256(0), \"restNo null is not allowed\");\r\n        Rest memory r = rests[_restNo];\r\n        return r;\r\n    }\r\n\r\n    function searchRestList() external view returns (Rest[] memory) {\r\n        return restList;\r\n    }\r\n}\r\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// CAUTION\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler\u0027s built in overflow checks.\r\n\r\n/**\r\n * @dev Wrappers over Solidity\u0027s arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (bool, uint256)\r\n    {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c \u003c a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (bool, uint256)\r\n    {\r\n        unchecked {\r\n            if (b \u003e a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (bool, uint256)\r\n    {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n            // benefit is lost if \u0027b\u0027 is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (bool, uint256)\r\n    {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (bool, uint256)\r\n    {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b \u003c= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b \u003e 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b \u003e 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n"},"UserStorage.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./Ownable.sol\";\r\n\r\ncontract UserStorage is Ownable {\r\n    struct User {\r\n        address userAddr;\r\n        string avatar;\r\n        string email;\r\n        uint256 isOnline;\r\n        uint256 userFlag;\r\n        uint256 credit;\r\n        uint256 regTime;\r\n        TradeStats tradeStats;\r\n        MorgageStats morgageStats;\r\n    }\r\n    struct TradeStats {\r\n        uint256 tradeTotal;\r\n        uint256 restTotal;\r\n    }\r\n    struct MorgageStats {\r\n        uint256 mortgage;\r\n        uint256 freezeMortgage;\r\n        uint256 relieveMortgage;\r\n        uint256 inviteUserCount;\r\n        uint256 inviteUserReward;\r\n        uint256 applyRelieveTime;\r\n        uint256 handleRelieveTime;\r\n    }\r\n    mapping(address =\u003e User) public users;\r\n    mapping(address =\u003e uint256) public userIndex;\r\n\r\n    User[] public userList;\r\n\r\n    address public recipient;\r\n    uint256 public feeAmount;\r\n\r\n    event addUser(address _userAddr);\r\n    event updateUser(string _avatar, string _email, uint256 _isOnline);\r\n\r\n    address _restCAddr;\r\n    address _orderCAddr;\r\n    address _recordCAddr;\r\n    address _appealCAddr;\r\n\r\n    modifier onlyAuthFromAddr() {\r\n        require(_restCAddr != address(0), \"Invalid address call rest\");\r\n        require(_orderCAddr != address(0), \"Invalid address call order\");\r\n        require(_recordCAddr != address(0), \"Invalid address call record\");\r\n        require(_appealCAddr != address(0), \"Invalid address call appeal\");\r\n        _;\r\n    }\r\n\r\n    function setFee(address _addr, uint256 _amount) external onlyOwner {\r\n        recipient = _addr;\r\n        feeAmount = _amount;\r\n    }\r\n\r\n    function authFromContract(\r\n        address _fromRest,\r\n        address _fromOrder,\r\n        address _fromRecord,\r\n        address _fromAppeal\r\n    ) external onlyOwner {\r\n        _restCAddr = _fromRest;\r\n        _orderCAddr = _fromOrder;\r\n        _recordCAddr = _fromRecord;\r\n        _appealCAddr = _fromAppeal;\r\n    }\r\n\r\n    modifier onlyMemberOf() {\r\n        require(users[msg.sender].userAddr != address(0), \"has no permission\");\r\n        _;\r\n    }\r\n\r\n    function _insert(address _addr) internal {\r\n        require(_addr != address(0), \"UserStorage: addr null is not allowed\");\r\n        require(\r\n            users[_addr].userAddr == address(0),\r\n            \"UserStorage: current User exist\"\r\n        );\r\n\r\n        TradeStats memory tradeStats = TradeStats({\r\n            tradeTotal: 0,\r\n            restTotal: 0\r\n        });\r\n        MorgageStats memory morgageStats = MorgageStats({\r\n            mortgage: 0,\r\n            freezeMortgage: 0,\r\n            relieveMortgage: 0,\r\n            inviteUserCount: 0,\r\n            inviteUserReward: 0,\r\n            applyRelieveTime: 0,\r\n            handleRelieveTime: 0\r\n        });\r\n\r\n        User memory u = User({\r\n            userAddr: _addr,\r\n            avatar: \"\",\r\n            email: \"\",\r\n            isOnline: 1,\r\n            userFlag: 0,\r\n            credit: 0,\r\n            regTime: block.timestamp,\r\n            tradeStats: tradeStats,\r\n            morgageStats: morgageStats\r\n        });\r\n        users[_addr] = u;\r\n\r\n        userList.push(u);\r\n        userIndex[_addr] = userList.length - 1;\r\n        emit addUser(_addr);\r\n    }\r\n\r\n    function _updateInfo(\r\n        address _addr,\r\n        string memory _avatar,\r\n        string memory _email,\r\n        uint256 _isOnline\r\n    ) internal {\r\n        require(_addr != address(0), \"UserStorage: _addr null is not allowed\");\r\n        require(\r\n            users[_addr].userAddr != address(0),\r\n            \"UserStorage: current User not exist\"\r\n        );\r\n\r\n        User memory u = users[_addr];\r\n        if (bytes(_avatar).length != 0) {\r\n            u.avatar = _avatar;\r\n        }\r\n        if (bytes(_email).length != 0) {\r\n            u.email = _email;\r\n        }\r\n\r\n        if (_isOnline != uint256(0)) {\r\n            u.isOnline = _isOnline;\r\n        }\r\n\r\n        users[_addr] = u;\r\n        userList[userIndex[_addr]] = u;\r\n    }\r\n\r\n    function _updateTradeStats(\r\n        address _addr,\r\n        TradeStats memory _tradeStats,\r\n        uint256 _credit\r\n    ) internal {\r\n        require(_addr != address(0), \"UserStorage: _addr null is not allowed\");\r\n        require(\r\n            users[_addr].userAddr != address(0),\r\n            \"UserStorage: current User not exist\"\r\n        );\r\n\r\n        User memory u = users[_addr];\r\n\r\n        u.credit = _credit;\r\n\r\n        u.tradeStats.tradeTotal = _tradeStats.tradeTotal;\r\n\r\n        u.tradeStats.restTotal = _tradeStats.restTotal;\r\n\r\n        users[_addr] = u;\r\n        userList[userIndex[_addr]] = u;\r\n    }\r\n\r\n    function _updateMorgageStats(\r\n        address _addr,\r\n        MorgageStats memory _morgageStats\r\n    ) internal {\r\n        require(_addr != address(0), \"UserStorage: _addr null is not allowed\");\r\n        require(\r\n            users[_addr].userAddr != address(0),\r\n            \"UserStorage: current User not exist\"\r\n        );\r\n\r\n        User memory u = users[_addr];\r\n\r\n        u.morgageStats.mortgage = _morgageStats.mortgage;\r\n        u.morgageStats.freezeMortgage = _morgageStats.freezeMortgage;\r\n        u.morgageStats.relieveMortgage = _morgageStats.relieveMortgage;\r\n        u.morgageStats.inviteUserCount = _morgageStats.inviteUserCount;\r\n        u.morgageStats.inviteUserReward = _morgageStats.inviteUserReward;\r\n        u.morgageStats.applyRelieveTime = _morgageStats.applyRelieveTime;\r\n        u.morgageStats.handleRelieveTime = _morgageStats.handleRelieveTime;\r\n\r\n        users[_addr] = u;\r\n        userList[userIndex[_addr]] = u;\r\n    }\r\n\r\n    function _search(address _addr) internal view returns (User memory user) {\r\n        require(_addr != address(0), \"UserStorage: _addr null is not allowed\");\r\n        require(\r\n            users[_addr].userAddr != address(0),\r\n            \"UserStorage: current User not exist\"\r\n        );\r\n\r\n        User memory a = users[_addr];\r\n        return a;\r\n    }\r\n\r\n    function register() external payable {\r\n        require(!isMemberOf(), \"has registed\");\r\n\r\n        if (feeAmount \u003e 0) {\r\n            require(recipient != address(0), \"recipient null is not allowed\");\r\n            require(msg.value \u003e= feeAmount, \"insufficient balance\");\r\n            payable(recipient).transfer(feeAmount);\r\n        }\r\n        _insert(msg.sender);\r\n    }\r\n\r\n    function isMemberOf() public view returns (bool) {\r\n        return (users[msg.sender].userAddr != address(0));\r\n    }\r\n\r\n    function updateInfo(\r\n        string memory _avatar,\r\n        string memory _email,\r\n        uint256 _isOnline\r\n    ) external onlyMemberOf {\r\n        _updateInfo(msg.sender, _avatar, _email, _isOnline);\r\n        emit updateUser(_avatar, _email, _isOnline);\r\n    }\r\n\r\n    function updateTradeStats(\r\n        address _addr,\r\n        TradeStats memory _tradeStats,\r\n        uint256 _credit\r\n    ) public onlyAuthFromAddr {\r\n        require(\r\n            msg.sender == _restCAddr ||\r\n                msg.sender == _orderCAddr ||\r\n                msg.sender == _appealCAddr ||\r\n                msg.sender == _recordCAddr,\r\n            \"UserStorage:Invalid from contract address\"\r\n        );\r\n        _updateTradeStats(_addr, _tradeStats, _credit);\r\n    }\r\n\r\n    function updateMorgageStats(\r\n        address _addr,\r\n        MorgageStats memory _morgageStats\r\n    ) public onlyAuthFromAddr {\r\n        require(\r\n            msg.sender == _recordCAddr,\r\n            \"UserStorage:Invalid from contract address\"\r\n        );\r\n        _updateMorgageStats(_addr, _morgageStats);\r\n    }\r\n\r\n    function updateUserRole(address _addr, uint256 _userFlag)\r\n        public\r\n        onlyAuthFromAddr\r\n    {\r\n        require(\r\n            msg.sender == _recordCAddr,\r\n            \"UserStorage:Invalid from contract address\"\r\n        );\r\n        require(_addr != address(0), \"UserStorage: _addr null is not allowed\");\r\n        require(\r\n            users[_addr].userAddr != address(0),\r\n            \"UserStorage: current User not exist\"\r\n        );\r\n\r\n        require(_userFlag \u003c= 3, \"UserStorage: Invalid userFlag 3\");\r\n\r\n        User memory u = users[_addr];\r\n        u.userFlag = _userFlag;\r\n        users[_addr] = u;\r\n        userList[userIndex[_addr]] = u;\r\n    }\r\n\r\n    function searchUser(address _addr)\r\n        external\r\n        view\r\n        returns (User memory user)\r\n    {\r\n        return _search(_addr);\r\n    }\r\n\r\n    function searchUserList() external view returns (User[] memory) {\r\n        return userList;\r\n    }\r\n}\r\n"}}