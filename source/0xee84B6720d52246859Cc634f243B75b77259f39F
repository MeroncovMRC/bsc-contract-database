{"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}"},"Rocket.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.7;\npragma experimental ABIEncoderV2;\nimport \"./IERC20.sol\";\n\ncontract RocketII {\n    struct Tower {\n        uint256 crystals;\n        uint256 money;\n        uint256 money2;\n        uint256 yield;\n        uint256 timestamp;\n        uint256 hrs;\n        address ref;\n        uint256 refs;\n        uint256 refDeps;\n        uint8   treasury;\n        uint8   market;\n        uint8[5] chefs;\n        bool[5] bounties;\n        bool king;\n    }\n\n    struct Stable {\n        uint256 stableBounty;\n        uint256 stableTimestamp;\n        uint256 stableHrs;\n        uint8   stable;\n    }\n\n    mapping(address =\u003e Tower) public towers;\n    mapping(address =\u003e Stable) public stables;\n\n    uint256 public totalChefs;\n    uint256 public totalTowers;\n    uint256 public totalKings;\n    uint256 public totalInvested;\n    address public manager;\n\n    IERC20 constant BUSD_TOKEN = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n\n    uint256 immutable public denominator = 10;\n    bool public init;\n    uint256 public initTimestamp;\n\n    modifier initialized {\n      require(init, \u0027Not initialized\u0027);\n      _;\n    }\n\n    constructor(address manager_) {\n       manager = manager_;\n    }\n\n\n    function initialize() external {\n      require(manager == msg.sender);\n      require(!init);\n      init = true;\n      initTimestamp = block.timestamp;\n    }\n\n    function canUpgradeTower(address _addr) public view returns(bool) {\n        uint256 passedDays = (block.timestamp - initTimestamp) / 1 days;\n        uint256 currentChefs = towers[_addr].chefs[0] + towers[_addr].chefs[1] + towers[_addr].chefs[2] + towers[_addr].chefs[3] + towers[_addr].chefs[4];\n        if (currentChefs \u003e passedDays) return false;\n        return true;\n    }\n\n    function addCrystals(address ref, uint256 value) initialized external {\n        uint256 crystals = value / 2e17;\n        require(crystals \u003e 0, \"Zero stone\");\n        address user = msg.sender;\n        totalInvested += value;\n        if (towers[user].timestamp == 0) {\n            totalTowers++;\n            towers[ref].refs++;\n            towers[user].ref = ref;\n            towers[user].timestamp = block.timestamp;\n            towers[user].treasury = 0;\n            towers[user].market = 0;\n        }\n        ref = towers[user].ref;\n        uint8 marketId = towers[ref].market;\n        (,uint256 refCrystal, uint256 refGold) = getMarket(marketId);\n\n        towers[ref].crystals += (crystals * refCrystal) / 100;\n        towers[ref].money += (crystals * 100 * refGold) / 100;\n        towers[ref].refDeps += crystals;\n        towers[user].crystals += crystals;\n\n        BUSD_TOKEN.transferFrom(msg.sender, address(this), value);\n    }\n\n    function withdrawMoney(uint256 gold) initialized external {\n        address user = msg.sender;\n        require(gold \u003c= towers[user].money \u0026\u0026 gold \u003e 0);\n        towers[user].money -= gold;\n        uint256 amount = gold * 2e15;\n        BUSD_TOKEN.transfer(user, BUSD_TOKEN.balanceOf(address(this)) \u003c amount ? BUSD_TOKEN.balanceOf(address(this)) : amount);\n    }\n\n    function kingBounty() initialized external {\n        address user = msg.sender;\n        require(towers[user].king == false, \"Alread Claimed\");\n        require(towers[user].chefs[4] == 6 \u0026\u0026 towers[user].treasury == 4 \u0026\u0026 towers[user].market == 2 \u0026\u0026 stables[user].stable == 3, \"All building must be max level\");\n        syncTower(user);\n        towers[user].money += 250000;\n        towers[user].king = true;\n        totalKings += 1;\n    }\n\n    function collectMoney() public {\n        address user = msg.sender;\n        syncTower(user);\n        towers[user].hrs = 0;\n        towers[user].money += towers[user].money2;\n        towers[user].money2 = 0;\n    }\n    \n    function collectStableBounty() public {\n        address user = msg.sender;\n        syncStable(user);\n        stables[user].stableHrs = 0;\n        towers[user].money += stables[user].stableBounty;\n        stables[user].stableBounty = 0;\n    }\n\n    function claimAirdrop(uint256 towerId) initialized external {\n        address user = msg.sender;\n        syncTower(user);\n        require(towers[user].chefs[towerId] == 6, \"Not Max Level\");\n        require(towers[user].bounties[towerId] == false, \"Already Claimed\");\n        uint256 bounty = getBounty(towerId);\n        towers[user].money += bounty;\n        towers[user].bounties[towerId] = true;\n    }\n\n    function upgradeTower(uint256 towerId) initialized external {\n        require(towerId \u003c 5, \"Max 5 towers\");\n        address user = msg.sender;\n        require(canUpgradeTower(user), \"Should wait 1 day again\");\n        if (towerId \u003e 0) {\n            require(towers[user].chefs[towerId-1] == 6, \"Prev Tower not upgraded\");\n        }\n\n        syncTower(user);\n        towers[user].chefs[towerId]++;\n        totalChefs++;\n        uint256 chefs = towers[user].chefs[towerId];\n        towers[user].crystals -= getUpgradePrice(towerId, chefs) / denominator;\n        towers[user].yield += getYield(towerId, chefs);\n    }\n\n    function upgradeTowncenter() initialized external {\n      address user = msg.sender;\n      require(towers[user].chefs[0] == 6, \"Tower-1 should be Max Level\");\n      uint8 treasuryId = towers[user].treasury + 1;\n      syncTower(user);\n      require(treasuryId \u003c 5, \"Max 5 treasury\");\n      (uint256 price,) = getTreasure(treasuryId);\n      towers[user].crystals -= price / denominator; \n      towers[user].treasury = treasuryId;\n    }\n\n    function upgradeMarket() initialized external {\n      address user = msg.sender;\n      require(towers[user].chefs[1] == 6, \"Tower-2 should be Max Level\");\n      uint8 marketId = towers[user].market + 1;\n      require(marketId \u003c 3, \"Max 2 market\");\n      (uint256 price,,) = getMarket(marketId);\n      towers[user].crystals -= price / denominator; \n      towers[user].market = marketId;\n    }\n\n    function upgradeStable() initialized external {\n      address user = msg.sender;\n      uint8 stableId = stables[user].stable + 1;\n      require(stableId \u003c 4, \"Max 3 stable\");\n      (uint256 price,, uint256 towerId) = getStable(stableId);\n      require(towers[user].chefs[towerId] == 6, \"Tower should be Max Level\");\n      \n      towers[user].crystals -= price / denominator; \n      stables[user].stable = stableId;\n      stables[user].stableTimestamp = block.timestamp;\n    }\n\n    function compound() initialized external {\n        address user = msg.sender;\n        syncTower(user);\n        towers[user].crystals += 2 * towers[user].money / 100;\n        towers[user].money = 0;\n    }\n\n    function getChefs(address addr) external view returns (uint8[5] memory) {\n        return towers[addr].chefs;\n    }\n    \n    function getBounties(address addr) external view returns (bool[5] memory) {\n        return towers[addr].bounties;\n    }\n\n    function syncTower(address user) internal {\n        require(towers[user].timestamp \u003e 0, \"User is not registered\");\n        if (towers[user].yield \u003e 0) {\n            (, uint256 treasury) = getTreasure(towers[user].treasury);\n            uint256 hrs = block.timestamp / 3600 - towers[user].timestamp / 3600;\n            if (hrs + towers[user].hrs \u003e treasury) {\n                hrs = treasury - towers[user].hrs;\n            }\n            towers[user].money2 += hrs * towers[user].yield;\n            towers[user].hrs += hrs;\n        }\n        towers[user].timestamp = block.timestamp;\n    }\n\n    function syncStable(address user) internal {\n        require(stables[user].stableTimestamp \u003e 0, \"User Stable is not registered\");\n        uint8 stableId = stables[user].stable;\n        (,uint256 bounty,) = getStable(stableId);\n\n        if (bounty \u003e 0) {\n            uint256 hrs = block.timestamp / 3600 - stables[user].stableTimestamp / 3600;\n            if (hrs + stables[user].stableHrs \u003e 24) {\n                hrs = 24 - stables[user].stableHrs;\n            }\n            stables[user].stableBounty = (hrs + stables[user].stableHrs) / 24 * bounty;\n            stables[user].stableHrs += hrs;\n        }\n        stables[user].stableTimestamp = block.timestamp;\n    }\n\n    function getUpgradePrice(uint256 towerId, uint256 chefId) internal pure returns (uint256) {\n        if (chefId == 1) return [600, 9975, 25000, 40000, 55000][towerId];\n        if (chefId == 2) return [1145, 12425, 27500, 42500, 62500][towerId];\n        if (chefId == 3) return [2510, 15000, 30000, 45000, 67500][towerId];\n        if (chefId == 4) return [3960, 17525, 32500, 47500, 70000][towerId];\n        if (chefId == 5) return [5000, 20000, 35000, 50000, 77500][towerId];\n        if (chefId == 6) return [7500, 22500, 37500, 52500, 85000][towerId];\n        revert(\"Incorrect chefId\");\n    }\n\n    function getYield(uint256 towerId, uint256 chefId) internal pure returns (uint256) {\n        if (chefId == 1) return [5, 108, 333, 634, 1008][towerId];\n        if (chefId == 2) return [10, 140, 378, 691, 1173][towerId];\n        if (chefId == 3) return [23, 175, 425, 750, 1295][towerId];\n        if (chefId == 4) return [38, 212, 474, 812, 1372][towerId];\n        if (chefId == 5) return [50, 250, 525, 875, 1550][towerId];\n        if (chefId == 6) return [78, 291, 578, 940, 1735][towerId];\n        revert(\"Incorrect chefId\");\n    }\n\n    function getTreasure(uint256 treasureId) internal pure returns (uint256, uint256) {\n      if(treasureId == 0) return (0, 24); // price | hours\n      if(treasureId == 1) return (2000, 36);\n      if(treasureId == 2) return (2500, 48);\n      if(treasureId == 3) return (3000, 60);\n      if(treasureId == 4) return (4000, 72);\n      revert(\"Incorrect treasureId\");\n    }\n\n    function getMarket(uint256 marketId) internal pure returns (uint256, uint256, uint256) {\n      if(marketId == 0) return (0, 8, 4); // price | crystal Ref |  gold Ref\n      if(marketId == 1) return (2000, 10, 6);\n      if(marketId == 2) return (4000, 12, 8);\n      revert(\"Incorrect marketId\");\n    }\n\n    function getBounty(uint256 towerId) internal pure returns (uint256) {\n        return [10000, 50000, 80000, 140000, 210000][towerId];\n    }\n\n    function getStable(uint256 stableId) internal pure returns (uint256, uint256, uint256 ) {\n        if(stableId == 0) return (0, 0, 0); // price | gold bounty per 24hrs | tower id to max\n        if(stableId == 1) return (50000, 25000, 2);\n        if(stableId == 2) return (75000, 68750, 3);\n        if(stableId == 3) return (100000, 135000, 4);\n        revert(\"Incorrect stableId\");\n    }\n}"}}