
// File: @chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface AggregatorV3Interface {
  function decimals() external view returns (uint8);

  function description() external view returns (string memory);

  function version() external view returns (uint256);

  function getRoundData(uint80 _roundId)
    external
    view
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    );

  function latestRoundData()
    external
    view
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    );
}


// File: @uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol
pragma solidity >=0.5.0;

interface IUniswapV2Pair {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);

    function name() external pure returns (string memory);
    function symbol() external pure returns (string memory);
    function decimals() external pure returns (uint8);
    function totalSupply() external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);

    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);

    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function PERMIT_TYPEHASH() external pure returns (bytes32);
    function nonces(address owner) external view returns (uint);

    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;

    event Mint(address indexed sender, uint amount0, uint amount1);
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);

    function MINIMUM_LIQUIDITY() external pure returns (uint);
    function factory() external view returns (address);
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function price0CumulativeLast() external view returns (uint);
    function price1CumulativeLast() external view returns (uint);
    function kLast() external view returns (uint);

    function mint(address to) external returns (uint liquidity);
    function burn(address to) external returns (uint amount0, uint amount1);
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
    function skim(address to) external;
    function sync() external;

    function initialize(address, address) external;
}


// File: contracts/BountyKindERC20.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import {
    AccessControlEnumerable
} from "oz-custom/contracts/oz/access/AccessControlEnumerable.sol";

import {
    ERC20,
    ERC20Permit
} from "oz-custom/contracts/oz/token/ERC20/extensions/ERC20Permit.sol";

import {
    ERC20Burnable
} from "oz-custom/contracts/oz/token/ERC20/extensions/ERC20Burnable.sol";

import {
    Pausable,
    ERC20Pausable
} from "oz-custom/contracts/oz/token/ERC20/extensions/ERC20Pausable.sol";

import {
    Taxable,
    FixedPointMathLib
} from "oz-custom/contracts/internal/Taxable.sol";
import {Transferable} from "oz-custom/contracts/internal/Transferable.sol";
import {ProxyChecker} from "oz-custom/contracts/internal/ProxyChecker.sol";
import {Blacklistable} from "oz-custom/contracts/internal/Blacklistable.sol";

import {IWNT} from "oz-custom/contracts/presets/token/interfaces/IWNT.sol";

import {
    IUniswapV2Pair,
    IBountyKindsERC20
} from "./interfaces/IBountyKindsERC20.sol";
import {
    AggregatorV3Interface
} from "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";

import {ErrorHandler} from "oz-custom/contracts/libraries/ErrorHandler.sol";

contract BountyKindsERC20 is
    Taxable,
    ERC20Permit,
    Transferable,
    ProxyChecker,
    Blacklistable,
    ERC20Burnable,
    ERC20Pausable,
    IBountyKindsERC20,
    AccessControlEnumerable
{
    using ErrorHandler for bool;
    using FixedPointMathLib for uint256;

    bytes32 public constant PAUSER_ROLE =
        0x65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a;
    bytes32 public constant MINTER_ROLE =
        0x9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6;
    bytes32 public constant OPERATOR_ROLE =
        0x97667070c54ef182b0f5858b034beac1b6f3089aa2d3188bb1e8929f4fa9b929;

    IWNT public immutable wnt;
    AggregatorV3Interface public immutable priceFeed;

    IUniswapV2Pair public pool;

    constructor(
        string memory name_,
        string memory symbol_,
        address admin_,
        address beneficiary_,
        uint256 initialSupply_,
        IWNT wnt_,
        AggregatorV3Interface priceFeed_
    ) payable Pausable() Taxable(beneficiary_) ERC20Permit(name_, symbol_) {
        wnt = wnt_;
        priceFeed = priceFeed_;

        address operator = _msgSender();

        bytes32 pauserRole = PAUSER_ROLE;
        bytes32 minterRole = MINTER_ROLE;
        bytes32 operatorRole = OPERATOR_ROLE;

        _grantRole(pauserRole, operator);
        _grantRole(minterRole, operator);
        _grantRole(operatorRole, operator);

        _grantRole(pauserRole, admin_);
        _grantRole(minterRole, admin_);
        _grantRole(operatorRole, admin_);
        _grantRole(DEFAULT_ADMIN_ROLE, admin_);

        _mint(beneficiary_, initialSupply_ * 1 ether);
    }

    /// @inheritdoc IBountyKindsERC20
    function setPool(
        IUniswapV2Pair pool_
    ) external whenPaused onlyRole(OPERATOR_ROLE) {
        _setPool(pool_);
    }

    function setUserStatus(
        address account_,
        bool status_
    ) external onlyRole(OPERATOR_ROLE) {
        _setUserStatus(account_, status_);
    }

    function pause() external onlyRole(PAUSER_ROLE) {
        _pause();
    }

    function unpause() external onlyRole(PAUSER_ROLE) {
        _unpause();
    }

    function toggleTax() external whenPaused onlyRole(PAUSER_ROLE) {
        _toggleTax();
    }

    function setTaxBeneficiary(
        address beneficiary_
    ) external onlyRole(OPERATOR_ROLE) {
        _setTaxBeneficiary(beneficiary_);
    }

    /// @inheritdoc IBountyKindsERC20
    function mint(address to_, uint256 amount_) external onlyRole(MINTER_ROLE) {
        _mint(to_, amount_);
    }

    /// @inheritdoc IBountyKindsERC20
    //  @dev minimal function to recover lost funds
    function execute(
        address target_,
        uint256 value_,
        bytes calldata calldata_
    ) external whenPaused onlyRole(OPERATOR_ROLE) {
        (bool success, bytes memory returnOrRevertData) = target_.call{
            value: value_
        }(calldata_);
        success.handleRevertIfNotSuccess(returnOrRevertData);

        emit Executed(
            _msgSender(),
            target_,
            value_,
            calldata_,
            returnOrRevertData
        );
    }

    function tax(
        address pool_,
        uint256 amount_
    ) public view override returns (uint256) {
        uint256 tokenReserve;
        uint256 nativeReserve;
        if (IUniswapV2Pair(pool_).token1() == address(this))
            (nativeReserve, tokenReserve, ) = IUniswapV2Pair(pool_)
                .getReserves();
        else
            (tokenReserve, nativeReserve, ) = IUniswapV2Pair(pool_)
                .getReserves();

        // amount token => amount native
        uint256 amtNative = amount_.mulDivUp(nativeReserve, tokenReserve);
        AggregatorV3Interface _priceFeed = priceFeed;
        (, int256 usd, , , ) = _priceFeed.latestRoundData();
        // amount native => amount usd
        uint256 amtUSD = amtNative.mulDivUp(
            uint256(usd),
            10 ** _priceFeed.decimals()
        );

        // usd tax amount
        uint256 usdTax = amtUSD.mulDivUp(
            taxFraction(address(0)),
            percentageFraction()
        );
        // native tax amount
        return usdTax.mulDivUp(1 ether, uint256(usd));
    }

    function taxEnabledDuration() public pure override returns (uint256) {
        return 20 minutes;
    }

    function taxFraction(address) public pure override returns (uint256) {
        return 2500;
    }

    function percentageFraction() public pure override returns (uint256) {
        return 10_000;
    }

    function _setPool(IUniswapV2Pair pool_) internal {
        if (address(pool_) == address(0) || !_isProxy(address(pool_)))
            revert BountyKindsERC20__InvalidArguments();

        emit PoolSet(_msgSender(), pool, pool_);
        pool = pool_;
    }

    function _beforeTokenTransfer(
        address from_,
        address to_,
        uint256 amount_
    ) internal override(ERC20, ERC20Pausable) {
        if (
            isBlacklisted(to_) ||
            isBlacklisted(from_) ||
            isBlacklisted(_msgSender())
        ) revert BountyKindsERC20__Blacklisted();

        if (isTaxEnabled()) {
            uint256 _tax = tax(address(pool), amount_);
            IWNT _wnt = wnt;

            if (msg.value != 0) {
                //  @dev will throw underflow error if msg.value < _tax
                uint256 refund = msg.value - _tax;
                _wnt.deposit{value: _tax}();

                address spender = _msgSender();
                if (refund != 0) {
                    _safeNativeTransfer(spender, refund, "");
                    emit Refunded(spender, refund);
                }
            }

            _safeERC20TransferFrom(_wnt, address(this), taxBeneficiary, _tax);
        }

        super._beforeTokenTransfer(from_, to_, amount_);
    }
}


// File: contracts/interfaces/IBountyKindsERC20.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import {
    IUniswapV2Pair
} from "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol";

/**
 *@title IBountyKindsERC20
 *@dev This interface defines the methods and events for a contract that manages a ERC20 token and allows executing calls to external contracts.
 */
interface IBountyKindsERC20 {
    error BountyKindsERC20__Blacklisted();
    error BountyKindsERC20__InvalidArguments();

    /**
     * @dev Emitted when a refund is made to an operator.
     * @param operator The address of the operator that receives the refund.
     * @param refund The amount of tokens refunded.
     */
    event Refunded(address indexed operator, uint256 indexed refund);

    /**
     * @dev Emitted when a call to an external contract is executed.
     * @param operator The address of the operator that executed the call.
     * @param target The address of the external contract that was called.
     * @param value_ The amount of ether sent in the call.
     * @param callData The data sent in the call.
     * @param returnData The data returned by the external contract.
     */
    event Executed(
        address indexed operator,
        address indexed target,
        uint256 indexed value_,
        bytes callData,
        bytes returnData
    );

    /**
     * @dev Emitted when the Uniswap V2 pair is updated.
     * @param operator The address of the operator that updated the Uniswap V2 pair.
     * @param poolOld The old Uniswap V2 pair address.
     * @param poolNew The new Uniswap V2 pair address.
     */
    event PoolSet(
        address indexed operator,
        IUniswapV2Pair indexed poolOld,
        IUniswapV2Pair indexed poolNew
    );

    /**
     * @dev Sets the Uniswap V2 pair address.
     * @param pool_ The address of the new Uniswap V2 pair.
     */
    function setPool(IUniswapV2Pair pool_) external;

    /**
     * @dev Mints tokens to the specified address.
     * @param to_ The address that will receive the tokens.
     * @param amount_ The amount of tokens to mint.
     */
    function mint(address to_, uint256 amount_) external;

    /**
     * @dev Executes a call to an external contract.
     * @param target_ The address of the external contract to call.
     * @param value_ The amount of ether to send with the call.
     * @param calldata_ The data to send with the call.
     */
    function execute(
        address target_,
        uint256 value_,
        bytes calldata calldata_
    ) external;
}


// File: oz-custom/contracts/internal/Blacklistable.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import {Context} from "../oz/utils/Context.sol";

import {IBlacklistable} from "./interfaces/IBlacklistable.sol";

import {BitMaps} from "../oz/utils/structs/BitMaps.sol";
import {Bytes32Address} from "../libraries/Bytes32Address.sol";

/**
 * @title Blacklistable
 * @dev Abstract contract that provides blacklist functionality.
 * Users of this contract can add or remove an address from the blacklist.
 * Users can check if an address is blacklisted.
 */
abstract contract Blacklistable is Context, IBlacklistable {
    using Bytes32Address for address;
    using BitMaps for BitMaps.BitMap;

    BitMaps.BitMap private __blacklisted;

    /// @inheritdoc IBlacklistable
    function isBlacklisted(
        address account_
    ) public view virtual returns (bool) {
        return __blacklisted.get(account_.fillLast96Bits());
    }

    function areBlacklisted(
        address[] calldata accounts_
    ) public view virtual returns (bool) {
        uint256 length = accounts_.length;
        for (uint256 i; i < length; ) {
            if (__blacklisted.get(accounts_[i].fillLast96Bits())) return true;
            unchecked {
                ++i;
            }
        }

        return false;
    }

    /**
     * @dev Internal function to set the status of an account.
     * @param account_ The address to change the status of.
     * @param status_ The new status for the address. True for blacklisted, false for not blacklisted.
     */
    function _setUserStatus(address account_, bool status_) internal virtual {
        __blacklisted.setTo(account_.fillLast96Bits(), status_);
        emit UserStatusSet(_msgSender(), account_, status_);
    }
}


// File: oz-custom/contracts/internal/interfaces/IBlacklistable.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

interface IBlacklistable {
    event UserStatusSet(
        address indexed operator,
        address indexed account,
        bool indexed isBlacklisted
    );

    /**
     * @dev Set the status of an account to either blacklisted or not blacklisted.
     * @param account_ The address to change the status of.
     * @param status The new status for the address. True for blacklisted, false for not blacklisted.
     */
    function setUserStatus(address account_, bool status) external;

    /**
     * @dev Check if an address is blacklisted.
     * @param account_ The address to check.
     * @return True if the address is blacklisted, false otherwise.
     */
    function isBlacklisted(address account_) external view returns (bool);

    function areBlacklisted(
        address[] calldata accounts_
    ) external view returns (bool);
}


// File: oz-custom/contracts/internal/interfaces/ISignable.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

interface ISignable {
    error Signable__InvalidSignature();

    event NonceIncremented(
        address indexed operator,
        bytes32 indexed id,
        uint256 indexed value
    );

    /**
     * @dev Returns the domain separator for EIP712 v4
     * @return Domain separator for EIP712 v4
     */
    function DOMAIN_SEPARATOR() external view returns (bytes32);
}


// File: oz-custom/contracts/internal/interfaces/ITaxable.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

interface ITaxable {
    error Taxable__TaxDisabled();
    error Taxable__AlreadyEnabled();
    error Taxable__InvalidArguments();

    event TaxEnabled(
        address indexed operator,
        uint256 indexed start,
        uint256 indexed stop
    );

    event TaxBeneficiarySet(
        address indexed operator,
        address indexed oldBeneficiary,
        address indexed newBeneficiary
    );

    function toggleTax() external;

    function setTaxBeneficiary(address taxBeneficiary_) external;

    function tax(
        address token_,
        uint256 amount_
    ) external view returns (uint256);

    function taxFraction(address token_) external pure returns (uint256);

    function percentageFraction() external pure returns (uint256);

    function isTaxEnabled() external view returns (bool);

    function taxEnabledDuration() external pure returns (uint256);
}


// File: oz-custom/contracts/internal/ProxyChecker.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

/**
 * @dev Revert error if call is made from a proxy contract
 */
error ProxyChecker__EOAUnallowed();
/**
 * @dev Revert error if call is made from an externally owned account
 */
error ProxyChecker__ProxyUnallowed();

/**
 * @title ProxyChecker
 * @dev Abstract contract for checking if a call was made by a proxy contract or an externally owned account.
 */
abstract contract ProxyChecker {
    modifier onlyProxy() {
        _onlyProxy(msg.sender);
        _;
    }

    /**
     * @dev Modifier to allow a function to be called only by an externally owned account
     */
    modifier onlyEOA() {
        _onlyEOA(msg.sender);
        _;
    }

    /**
     * @dev Check if the sender is an externally owned account
     * @param sender_ Address of the sender
     */
    function _onlyEOA(address sender_) internal view {
        _onlyEOA(sender_, _txOrigin());
    }

    /**
     * @dev Check if the sender is an externally owned account
     * @param msgSender_ Address of the sender
     * @param txOrigin_ Origin of the transaction
     */
    function _onlyEOA(address msgSender_, address txOrigin_) internal pure {
        if (_isProxyCall(msgSender_, txOrigin_))
            revert ProxyChecker__ProxyUnallowed();
    }

    /**
     * @dev Check if the sender is a proxy contract
     * @param sender_ Address of the sender
     */
    function _onlyProxy(address sender_) internal view {
        if (!(_isProxyCall(sender_, _txOrigin()) || _isProxy(sender_)))
            revert ProxyChecker__EOAUnallowed();
    }

    /**
     * @dev Check if the sender is a proxy contract
     * @param msgSender_ Address of the sender
     * @param txOrigin_ Origin of the transaction
     */
    function _onlyProxy(address msgSender_, address txOrigin_) internal view {
        if (!(_isProxyCall(msgSender_, txOrigin_) || _isProxy(msgSender_)))
            revert ProxyChecker__EOAUnallowed();
    }

    /**
     * @dev Check if the call was made by a proxy contract
     * @param msgSender_ Address of the sender
     * @param txOrigin_ Origin of the transaction
     * @return True if the call was made by a proxy contract, false otherwise
     */
    function _isProxyCall(
        address msgSender_,
        address txOrigin_
    ) internal pure returns (bool) {
        return msgSender_ != txOrigin_;
    }

    /**
     * @dev Check if the caller is a proxy contract
     * @param caller_ Address of the caller
     * @return True if the caller is a proxy contract, false otherwise
     */
    function _isProxy(address caller_) internal view returns (bool) {
        return caller_.code.length != 0;
    }

    /**
     * @dev Returns the origin of the transaction
     * @return Origin of the transaction
     */
    function _txOrigin() internal view returns (address) {
        return tx.origin;
    }
}


// File: oz-custom/contracts/internal/Signable.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import {Context} from "../oz/utils/Context.sol";
import {ECDSA, EIP712} from "../oz/utils/cryptography/draft-EIP712.sol";

import {ISignable} from "./interfaces/ISignable.sol";

import {Bytes32Address} from "../libraries/Bytes32Address.sol";

/**
 * @title Signable
 * @dev Abstract contract for signing and verifying typed data.
 */
abstract contract Signable is Context, EIP712, ISignable {
    using ECDSA for bytes32;
    using Bytes32Address for address;

    /**
     * @dev Mapping of nonces for each id
     */
    mapping(bytes32 => uint256) internal _nonces;

    /**
     * @dev Constructor that initializes EIP712 with the given name and version
     * @param name_ Name of the typed data
     * @param version_ Version of the typed data
     */
    constructor(
        string memory name_,
        string memory version_
    ) payable EIP712(name_, version_) {}

    /**
     * @dev Verifies that the signer of the typed data is the given address
     * @param verifier_ Address to verify
     * @param structHash_ Hash of the typed data
     * @param signature_ Signature of the typed data
     */
    function _verify(
        address verifier_,
        bytes32 structHash_,
        bytes calldata signature_
    ) internal view virtual {
        if (_recoverSigner(structHash_, signature_) != verifier_)
            revert Signable__InvalidSignature();
    }

    /**
     * @dev Verifies that the signer of the typed data is the given address
     * @param verifier_ Address to verify
     * @param structHash_ Hash of the typed data
     * @param v ECDSA recovery value
     * @param r ECDSA r value
     * @param s ECDSA s value
     */
    function _verify(
        address verifier_,
        bytes32 structHash_,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal view virtual {
        if (_recoverSigner(structHash_, v, r, s) != verifier_)
            revert Signable__InvalidSignature();
    }

    /**
     * @dev Recovers the signer of the typed data from the signature
     * @param structHash_ Hash of the typed data
     * @param signature_ Signature of the typed data
     * @return Address of the signer
     */
    function _recoverSigner(
        bytes32 structHash_,
        bytes calldata signature_
    ) internal view returns (address) {
        return _hashTypedDataV4(structHash_).recover(signature_);
    }

    /**
     * @dev Recovers the signer of the typed data from the signature
     * @param structHash_ Hash of the typed data
     * @param v ECDSA recovery value
     * @param r ECDSA r value
     * @param s ECDSA s value
     * @return Address of the signer
     */
    function _recoverSigner(
        bytes32 structHash_,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal view returns (address) {
        return _hashTypedDataV4(structHash_).recover(v, r, s);
    }

    /**
     * @dev Increases the nonce for the given account by 1
     * @param id_ ID to increase the nonce for
     * @return nonce The new nonce for the account
     */
    function _useNonce(bytes32 id_) internal virtual returns (uint256 nonce) {
        assembly {
            mstore(0x00, id_)
            mstore(0x20, _nonces.slot)
            let key := keccak256(0x00, 0x40)
            nonce := sload(key)
            sstore(key, add(nonce, 1))
        }

        emit NonceIncremented(_msgSender(), id_, nonce);
    }

    /// @inheritdoc ISignable
    function DOMAIN_SEPARATOR() external view virtual returns (bytes32) {
        return _domainSeparatorV4();
    }
}


// File: oz-custom/contracts/internal/Taxable.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import {Context} from "../oz/utils/Context.sol";

import {ITaxable} from "./interfaces/ITaxable.sol";

import {FixedPointMathLib} from "../libraries/FixedPointMathLib.sol";

abstract contract Taxable is Context, ITaxable {
    using FixedPointMathLib for uint256;

    address public taxBeneficiary;
    uint256 public taxEnabledTimestamp;

    modifier whenTaxEnabled() virtual {
        _checkTaxEnabled();
        _;
    }

    constructor(address taxBeneficiary_) payable {
        _setTaxBeneficiary(taxBeneficiary_);
    }

    function _setTaxBeneficiary(address taxBeneficiary_) internal virtual {
        if (taxBeneficiary_ == address(0)) revert Taxable__InvalidArguments();

        emit TaxBeneficiarySet(_msgSender(), taxBeneficiary, taxBeneficiary_);

        taxBeneficiary = taxBeneficiary_;
    }

    function _toggleTax() internal virtual {
        if (taxEnabledTimestamp != 0) revert Taxable__AlreadyEnabled();
        taxEnabledTimestamp = block.timestamp;

        emit TaxEnabled(
            _msgSender(),
            block.timestamp,
            block.timestamp + taxEnabledDuration()
        );
    }

    function tax(
        address token_,
        uint256 amount_
    ) public view virtual returns (uint256) {
        return amount_.mulDivUp(taxFraction(token_), percentageFraction());
    }

    function taxFraction(address token_) public pure virtual returns (uint256);

    function percentageFraction() public pure virtual returns (uint256);

    function taxEnabledDuration() public pure virtual returns (uint256);

    function _checkTaxEnabled() internal view {
        if (!isTaxEnabled()) revert Taxable__TaxDisabled();
    }

    function isTaxEnabled() public view virtual returns (bool) {
        return taxEnabledTimestamp + taxEnabledDuration() > block.timestamp;
    }
}


// File: oz-custom/contracts/internal/Transferable.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import {IERC20} from "../oz/token/ERC20/IERC20.sol";

error Transferable__TransferFailed();
error Transferable__InvalidArguments();

/**
 * @dev Library for transferring Ether and tokens between accounts
 */
abstract contract Transferable {
    /**
     * @dev Reverts the transaction if the transfer fails
     * @param token_ Address of the token contract to transfer. If zero address, transfer Ether.
     * @param from_ Address to transfer from
     * @param to_ Address to transfer to
     * @param value_ Amount of tokens or Ether to transfer
     */
    function _safeTransferFrom(
        address token_,
        address from_,
        address to_,
        uint256 value_,
        bytes memory data_
    ) internal virtual {
        __checkValidTransfer(to_, value_);

        if (
            token_ == address(0)
                ? _nativeTransfer(to_, value_, data_)
                : _ERC20TransferFrom(IERC20(token_), from_, to_, value_)
        ) return;

        revert Transferable__TransferFailed();
    }

    /**
     * @dev Reverts the transaction if the transfer fails
     * @param token_ Address of the token contract to transfer. If zero address, transfer Ether.
     * @param to_ Address to transfer to
     * @param value_ Amount of tokens or Ether to transfer
     */
    function _safeTransfer(
        address token_,
        address to_,
        uint256 value_,
        bytes memory data_
    ) internal virtual {
        __checkValidTransfer(to_, value_);

        if (
            token_ == address(0)
                ? _nativeTransfer(to_, value_, data_)
                : _ERC20Transfer(IERC20(token_), to_, value_)
        ) return;

        revert Transferable__TransferFailed();
    }

    /**
     * @dev Reverts the transaction if the Ether transfer fails
     * @param to_ Address to transfer to
     * @param amount_ Amount of Ether to transfer
     */
    function _safeNativeTransfer(
        address to_,
        uint256 amount_,
        bytes memory data_
    ) internal virtual {
        __checkValidTransfer(to_, amount_);
        if (!_nativeTransfer(to_, amount_, data_))
            revert Transferable__TransferFailed();
    }

    function _safeERC20Transfer(
        IERC20 token_,
        address to_,
        uint256 amount_
    ) internal virtual {
        __checkValidTransfer(to_, amount_);
        if (!_ERC20Transfer(token_, to_, amount_))
            revert Transferable__TransferFailed();
    }

    function _safeERC20TransferFrom(
        IERC20 token_,
        address from_,
        address to_,
        uint256 amount_
    ) internal virtual {
        __checkValidTransfer(to_, amount_);

        if (!_ERC20TransferFrom(token_, from_, to_, amount_))
            revert Transferable__TransferFailed();
    }

    function _nativeTransfer(
        address to_,
        uint256 amount_,
        bytes memory data_
    ) internal virtual returns (bool success) {
        /// @solidity memory-safe-assembly
        assembly {
            // Transfer the ETH and store if it succeeded or not.
            success := call(
                gas(),
                to_,
                amount_,
                add(data_, 32),
                mload(data_),
                0,
                0
            )
        }
    }

    function _ERC20Transfer(
        IERC20 token_,
        address to_,
        uint256 value_
    ) internal virtual returns (bool success) {
        assembly {
            // Get a pointer to some free memory.
            let freeMemoryPointer := mload(0x40)

            // Write the abi-encoded calldata into memory, beginning with the function selector.
            mstore(
                freeMemoryPointer,
                0xa9059cbb00000000000000000000000000000000000000000000000000000000
            )
            mstore(add(freeMemoryPointer, 4), to_) // Append the "to" argument.
            mstore(add(freeMemoryPointer, 36), value_) // Append the "amount" argument.

            success := and(
                or(
                    and(eq(mload(0), 1), gt(returndatasize(), 31)),
                    iszero(returndatasize())
                ),
                call(gas(), token_, 0, freeMemoryPointer, 68, 0, 32)
            )
        }
    }

    function _ERC20TransferFrom(
        IERC20 token_,
        address from_,
        address to_,
        uint256 value_
    ) internal virtual returns (bool success) {
        assembly {
            let freeMemoryPointer := mload(0x40)

            mstore(
                freeMemoryPointer,
                0x23b872dd00000000000000000000000000000000000000000000000000000000
            )
            mstore(add(freeMemoryPointer, 4), from_)
            mstore(add(freeMemoryPointer, 36), to_)
            mstore(add(freeMemoryPointer, 68), value_)

            success := and(
                or(
                    and(eq(mload(0), 1), gt(returndatasize(), 31)),
                    iszero(returndatasize())
                ),
                call(gas(), token_, 0, freeMemoryPointer, 100, 0, 32)
            )
        }
    }

    function __checkValidTransfer(address to_, uint256 value_) private pure {
        if (to_ == address(0) || value_ == 0)
            revert Transferable__InvalidArguments();
    }
}


// File: oz-custom/contracts/libraries/ArrayUtil.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import {BitMap256} from "./structs/BitMap256.sol";

/**
 *@title ArrayUtil
 *@dev Utility library for working with arrays. This library contains functions for trimming an array and removing duplicate elements from an array by converting it to a set using a bitmap.
 */
library ArrayUtil {
    using BitMap256 for uint256;

    /*
     *@dev Converts an array to a set by removing duplicate elements. Uses a bitmap to store the seen elements for efficiency.
     *@param arr_ The input array to convert to a set.
     *@return An array with the duplicate elements removed.
     */
    function toSet(
        uint256[] memory arr_
    ) internal pure returns (uint256[] memory) {
        uint256 length = arr_.length;
        uint256 seenBitmap;
        uint256 valI;
        unchecked {
            for (uint256 i; i < length; ++i) {
                //  @dev cache element to stack
                valI = arr_[i];

                //  @dev remove dupplicated element by moving it to the end of the array and reduce the length, break the loop only if we found an unseen element (x)
                while (
                    length > i &&
                    seenBitmap.get({value_: valI, shouldHash_: true})
                ) valI = arr_[--length];

                // @dev set seen element in the bitmap and replace dupplicated one with unseen element (x)
                seenBitmap = seenBitmap.set({value_: valI, shouldHash_: true});
                arr_[i] = valI;
            }
        }

        // Shorten the dynamic array by the reduced length.
        assembly {
            mstore(arr_, length)
        }
        return arr_;
    }

    /**
     *@dev Trims an array by removing all elements that match a given value.
     *@param trimVal_ The value to remove from the array.
     *@param arr_ The input array to trim.
     *@return trimmed An array with the specified elements removed.
     */
    function trim(
        uint256[256] storage arr_,
        uint256 trimVal_
    ) internal view returns (uint256[] memory trimmed) {
        trimmed = new uint256[](256);

        uint8 j;
        uint256 valI;
        unchecked {
            for (uint256 i; i < 256; ++i) {
                valI = arr_[i];
                if (valI == trimVal_) continue;

                trimmed[j] = valI;
                ++j;
            }
        }

        // Shorten the `trimmed` dynamic array by new length.
        assembly {
            mstore(trimmed, j)
        }
    }

    /**
     *@dev Trims an array by removing all elements that match a given value.
     *@param trimVal_ The value to remove from the array.
     *@param arr_ The input array to trim.
     *@return trimmed An array with the specified elements removed.
     */
    function trim(
        uint256[] memory arr_,
        uint256 trimVal_
    ) internal pure returns (uint256[] memory trimmed) {
        uint256 length = arr_.length;
        trimmed = new uint256[](length);

        uint256 j;
        uint256 valI;
        unchecked {
            for (uint256 i; i < length; ++i) {
                valI = arr_[i];
                if (valI == trimVal_) continue;

                trimmed[j] = valI;
                ++j;
            }
        }

        // Shorten the `trimmed` dynamic array by new length.
        assembly {
            mstore(trimmed, j)
        }
    }
}


// File: oz-custom/contracts/libraries/Bytes32Address.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

library Bytes32Address {
    function fromFirst20Bytes(
        bytes32 bytesValue
    ) internal pure returns (address addr) {
        assembly {
            addr := bytesValue
        }
    }

    function fillLast12Bytes(
        address addressValue
    ) internal pure returns (bytes32 value) {
        assembly {
            value := addressValue
        }
    }

    function fromFirst160Bits(
        uint256 uintValue
    ) internal pure returns (address addr) {
        assembly {
            addr := uintValue
        }
    }

    function fillLast96Bits(
        address addressValue
    ) internal pure returns (uint256 value) {
        assembly {
            value := addressValue
        }
    }

    function fromLast160Bits(
        uint256 uintValue
    ) internal pure returns (address addr) {
        assembly {
            addr := shr(0x60, uintValue)
        }
    }

    function fillFirst96Bits(
        address addressValue
    ) internal pure returns (uint256 value) {
        assembly {
            value := shl(0x60, addressValue)
        }
    }
}


// File: oz-custom/contracts/libraries/ErrorHandler.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

error ErrorHandler__ExecutionFailed();

library ErrorHandler {
    function handleRevertIfNotSuccess(
        bool ok_,
        bytes memory revertData_
    ) internal pure {
        if (!ok_)
            if (revertData_.length != 0)
                assembly {
                    revert(
                        // Start of revert data bytes. The 0x20 offset is always the same.
                        add(revertData_, 0x20),
                        // Length of revert data.
                        mload(revertData_)
                    )
                }
            else revert ErrorHandler__ExecutionFailed();
    }
}


// File: oz-custom/contracts/libraries/FixedPointMathLib.sol
// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity ^0.8.17;

/// @notice Arithmetic library with operations for fixed-point numbers.
/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)
/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)
library FixedPointMathLib {
    /*//////////////////////////////////////////////////////////////
                    SIMPLIFIED FIXED POINT OPERATIONS
    //////////////////////////////////////////////////////////////*/

    uint256 internal constant MAX_UINT256 = (1 << 256) - 1;
    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.

    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {
        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.
    }

    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {
        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.
    }

    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {
        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.
    }

    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {
        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.
    }

    /*//////////////////////////////////////////////////////////////
                    LOW LEVEL FIXED POINT OPERATIONS
    //////////////////////////////////////////////////////////////*/

    function mulDivDown(
        uint256 x,
        uint256 y,
        uint256 denominator
    ) internal pure returns (uint256 z) {
        assembly {
            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))
            if iszero(
                mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))
            ) {
                revert(0, 0)
            }

            z := div(mul(x, y), denominator)
        }
    }

    function mulDivUp(
        uint256 x,
        uint256 y,
        uint256 denominator
    ) internal pure returns (uint256 z) {
        assembly {
            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))
            if iszero(
                mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))
            ) {
                revert(0, 0)
            }

            // Add 1 to the result if x * y mod denominator != 0.
            z := add(
                gt(mod(mul(x, y), denominator), 0),
                div(mul(x, y), denominator)
            )
        }
    }

    function rpow(
        uint256 x,
        uint256 n,
        uint256 scalar
    ) internal pure returns (uint256 z) {
        assembly {
            switch x
            case 0 {
                switch n
                case 0 {
                    // 0 ** 0 = 1
                    z := scalar
                }
                default {
                    // 0 ** n = 0
                    z := 0
                }
            }
            default {
                switch mod(n, 2)
                case 0 {
                    // If n is even, store scalar in z for now.
                    z := scalar
                }
                default {
                    // If n is odd, store x in z for now.
                    z := x
                }

                // Shifting right by 1 is like dividing by 2.
                let half := shr(1, scalar)

                for {
                    // Shift n right by 1 before looping to halve it.
                    n := shr(1, n)
                } n {
                    // Shift n right by 1 each iteration to halve it.
                    n := shr(1, n)
                } {
                    // Revert immediately if x ** 2 would overflow.
                    // Equivalent to iszero(eq(div(xx, x), x)) here.
                    if shr(128, x) {
                        revert(0, 0)
                    }

                    // Store x squared.
                    let xx := mul(x, x)

                    // Round to the nearest number.
                    let xxRound := add(xx, half)

                    // Revert if xx + half overflowed.
                    if lt(xxRound, xx) {
                        revert(0, 0)
                    }

                    // Set x to scaled xxRound.
                    x := div(xxRound, scalar)

                    // If n is even:
                    if mod(n, 2) {
                        // Compute z * x.
                        let zx := mul(z, x)

                        // If z * x overflowed:
                        if iszero(eq(div(zx, x), z)) {
                            // Revert if x is non-zero.
                            if iszero(iszero(x)) {
                                revert(0, 0)
                            }
                        }

                        // Round to the nearest number.
                        let zxRound := add(zx, half)

                        // Revert if zx + half overflowed.
                        if lt(zxRound, zx) {
                            revert(0, 0)
                        }

                        // Return properly scaled zxRound.
                        z := div(zxRound, scalar)
                    }
                }
            }
        }
    }

    /*//////////////////////////////////////////////////////////////
                        GENERAL NUMBER UTILITIES
    //////////////////////////////////////////////////////////////*/

    function sqrt(uint256 x) internal pure returns (uint256 z) {
        assembly {
            // Start off with z at 1.
            z := 1

            // Used below to help find a nearby power of 2.
            let y := x

            // Find the lowest power of 2 that is at least sqrt(x).
            if iszero(lt(y, 0x100000000000000000000000000000000)) {
                y := shr(128, y) // Like dividing by 2 ** 128.
                z := shl(64, z) // Like multiplying by 2 ** 64.
            }
            if iszero(lt(y, 0x10000000000000000)) {
                y := shr(64, y) // Like dividing by 2 ** 64.
                z := shl(32, z) // Like multiplying by 2 ** 32.
            }
            if iszero(lt(y, 0x100000000)) {
                y := shr(32, y) // Like dividing by 2 ** 32.
                z := shl(16, z) // Like multiplying by 2 ** 16.
            }
            if iszero(lt(y, 0x10000)) {
                y := shr(16, y) // Like dividing by 2 ** 16.
                z := shl(8, z) // Like multiplying by 2 ** 8.
            }
            if iszero(lt(y, 0x100)) {
                y := shr(8, y) // Like dividing by 2 ** 8.
                z := shl(4, z) // Like multiplying by 2 ** 4.
            }
            if iszero(lt(y, 0x10)) {
                y := shr(4, y) // Like dividing by 2 ** 4.
                z := shl(2, z) // Like multiplying by 2 ** 2.
            }
            if iszero(lt(y, 0x8)) {
                // Equivalent to 2 ** z.
                z := shl(1, z)
            }

            // Shifting right by 1 is like dividing by 2.
            z := shr(1, add(z, div(x, z)))
            z := shr(1, add(z, div(x, z)))
            z := shr(1, add(z, div(x, z)))
            z := shr(1, add(z, div(x, z)))
            z := shr(1, add(z, div(x, z)))
            z := shr(1, add(z, div(x, z)))
            z := shr(1, add(z, div(x, z)))

            // Compute a rounded down version of z.
            let zRoundDown := div(x, z)

            // If zRoundDown is smaller, use it.
            if lt(zRoundDown, z) {
                z := zRoundDown
            }
        }
    }
}


// File: oz-custom/contracts/libraries/structs/BitMap256.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

/**
 *@title BitMap256 Library
 *@dev A library for storing a bitmap of 256 slots, where each slot is represented by a single bit. This allows for efficient storage and manipulation of large amounts of boolean data.
 */
library BitMap256 {
    /**
     * @dev Struct for holding a 256-bit bitmap.
     */
    struct BitMap {
        uint256 data;
    }

    /**
     *@dev Calculate the index for a given value in the bitmap.
     *@param value_ The value for which the index needs to be calculated.
     *@param shouldHash_ A boolean flag indicating if the value should be hashed.
     *@return idx The calculated index for the given value.
     */
    function index(
        uint256 value_,
        bool shouldHash_
    ) internal pure returns (uint256 idx) {
        assembly {
            if shouldHash_ {
                mstore(0x00, value_)
                value_ := keccak256(0x00, 0x20)
            }
            idx := and(0xff, value_)
        }
    }

    /**
     *@dev Get the value of a bit at a given index in the bitmap.
     *@param bitmap_ The storage bitmap to get the value from.
     *@param value_ The value for which the index needs to be calculated.
     *@param shouldHash_ A boolean flag indicating if the value should be hashed.
     *@return isSet A boolean indicating if the bit at the given index is set.
     */
    function get(
        BitMap storage bitmap_,
        uint256 value_,
        bool shouldHash_
    ) internal view returns (bool isSet) {
        assembly {
            if shouldHash_ {
                mstore(0x00, value_)
                value_ := keccak256(0x00, 0x20)
            }
            isSet := and(sload(bitmap_.slot), shl(and(value_, 0xff), 1))
        }
    }

    /**
     *@dev Get the value of a bit at a given index in the bitmap.
     *@param bitmap_ The storage bitmap to get the value from.
     *@param value_ The value for which the index needs to be calculated.
     *@param shouldHash_ A boolean flag indicating if the value should be hashed.
     *@return isSet A boolean indicating if the bit at the given index is set.
     */
    function get(
        uint256 bitmap_,
        uint256 value_,
        bool shouldHash_
    ) internal pure returns (bool isSet) {
        assembly {
            if shouldHash_ {
                mstore(0x00, value_)
                value_ := keccak256(0x00, 0x20)
            }
            isSet := and(bitmap_, shl(and(value_, 0xff), 1))
        }
    }

    /**
     *@dev Set the data of the storage bitmap to a given value.
     *@param bitmap_ The storage bitmap to set the data of.
     *@param value The value to set the data of the bitmap to.
     */
    function setData(BitMap storage bitmap_, uint256 value) internal {
        assembly {
            sstore(bitmap_.slot, value)
        }
    }

    /**
     *@dev Set or unset the bit at a given index in the bitmap based on the status flag.
     *@param bitmap_ The storage bitmap to set or unset the bit in.
     *@param value_ The value for which the index needs to be calculated.
     *@param shouldHash_ A boolean flag indicating if the value should be hashed.
     *@param status_ A boolean flag indicating if the bit should be set or unset.
     */
    function setTo(
        BitMap storage bitmap_,
        uint256 value_,
        bool shouldHash_,
        bool status_
    ) internal {
        if (status_) set(bitmap_, value_, shouldHash_);
        else unset(bitmap_, value_, shouldHash_);
    }

    /**
     * @dev Sets the bit at the given index in the bitmap to the given value.
     * If `shouldHash_` is `true`, the value is hashed before computing the index.
     * @param bitmap_ The bitmap to set the bit in.
     * @param value_ The value for which the index needs to be calculated.
     * @param shouldHash_ A boolean flag indicating if the value should be hashed.
     */
    function set(
        BitMap storage bitmap_,
        uint256 value_,
        bool shouldHash_
    ) internal {
        assembly {
            if shouldHash_ {
                mstore(0x00, value_)
                value_ := keccak256(0, 0x20)
            }
            sstore(
                bitmap_.slot,
                or(sload(bitmap_.slot), shl(and(value_, 0xff), 1))
            )
        }
    }

    /**
     * @dev Sets the bit at the given index in the bitmap to the given value.
     * If `shouldHash_` is `true`, the value is hashed before computing the index.
     * @param bitmap_ The bitmap to set the bit in.
     * @param value_ The value for which the index needs to be calculated.
     * @param shouldHash_ A boolean flag indicating if the value should be hashed.
     */
    function set(
        uint256 bitmap_,
        uint256 value_,
        bool shouldHash_
    ) internal pure returns (uint256 bitmap) {
        assembly {
            if shouldHash_ {
                mstore(0x00, value_)
                value_ := keccak256(0x00, 0x20)
            }
            bitmap := or(bitmap_, shl(and(value_, 0xff), 1))
        }
    }

    /**
     * @dev Unsets the bit at the given index in the bitmap to the given value.
     * If `shouldHash_` is `true`, the value is hashed before computing the index.
     * @param bitmap_ The bitmap to set the bit in.
     * @param value_ The value for which the index needs to be calculated.
     * @param shouldHash_ A boolean flag indicating if the value should be hashed.
     */
    function unset(
        BitMap storage bitmap_,
        uint256 value_,
        bool shouldHash_
    ) internal {
        assembly {
            if shouldHash_ {
                mstore(0x00, value_)
                value_ := keccak256(0x00, 0x20)
            }

            sstore(
                bitmap_.slot,
                and(sload(bitmap_.slot), not(shl(and(value_, 0xff), 1)))
            )
        }
    }

    /**
     * @dev Unsets the bit at the given index in the bitmap to the given value.
     * If `shouldHash_` is `true`, the value is hashed before computing the index.
     * @param bitmap_ The bitmap to set the bit in.
     * @param value_ The value for which the index needs to be calculated.
     * @param shouldHash_ A boolean flag indicating if the value should be hashed.
     */
    function unset(
        uint256 bitmap_,
        uint256 value_,
        bool shouldHash_
    ) internal pure returns (uint256 bitmap) {
        assembly {
            if shouldHash_ {
                mstore(0x00, value_)
                value_ := keccak256(0x00, 32)
            }
            bitmap := and(bitmap_, not(shl(and(value_, 0xff), 1)))
        }
    }
}


// File: oz-custom/contracts/libraries/structs/EnumerableSet256.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)

pragma solidity ^0.8.17;

import {ArrayUtil, BitMap256} from "../ArrayUtil.sol";

library EnumerableSet256 {
    using BitMap256 for *;
    using ArrayUtil for *;

    struct Set {
        uint8 length;
        // Storage of set values
        uint256[256] _values;
        // Position of the value in the `values`
        BitMap256.BitMap _indexes;
    }

    function _add(Set storage set, uint256 value) private returns (bool) {
        if (!_contains(set, value)) {
            set._values[value.index({shouldHash_: false})] = value;
            unchecked {
                ++set.length;
            }
            return true;
        }
        return false;
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function _remove(Set storage set, uint256 value) private returns (bool) {
        // We read and store the value's index to prevent multiple reads from the same storage slot
        uint256 idx = value.index({shouldHash_: false});
        uint256 valueIndex = set._values[idx] == value ? idx : 0;

        if (valueIndex == 0) return false;

        delete set._values[valueIndex];
        unchecked {
            --set.length;
        }
        return true;
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function _contains(
        Set storage set,
        uint256 value
    ) private view returns (bool) {
        return set._values[value.index({shouldHash_: false})] == value;
    }

    /**
     * @dev Returns the number of values on the set. O(1).
     */
    function _length(Set storage set) private view returns (uint256) {
        return set.length;
    }

    /**
     * @dev Returns the value stored at position `index` in the set. O(1).
     *
     * Note that there are no guarantees on the ordering of values inside the
     * array, and it may change when more values are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function _at(
        Set storage set,
        uint256 index
    ) private view returns (uint256) {
        return set._values[index];
    }

    /**
     * @dev Return the entire set in an array
     *
     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
     * this function has an unbounded cost, and using it as part of a state-changing function may render the function
     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
     */
    function _values(Set storage set) private view returns (uint256[] memory) {
        return set._values.trim(0);
    }

    // Bytes32Set

    struct Bytes32Set {
        Set _inner;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function add(
        Bytes32Set storage set,
        bytes32 value
    ) internal returns (bool) {
        uint256 val;
        assembly {
            val := value
        }
        return _add(set._inner, val);
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function remove(
        Bytes32Set storage set,
        bytes32 value
    ) internal returns (bool) {
        uint256 val;
        assembly {
            val := value
        }
        return _remove(set._inner, val);
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function contains(
        Bytes32Set storage set,
        bytes32 value
    ) internal view returns (bool) {
        uint256 val;
        assembly {
            val := value
        }
        return _contains(set._inner, val);
    }

    /**
     * @dev Returns the number of values in the set. O(1).
     */
    function length(Bytes32Set storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

    /**
     * @dev Returns the value stored at position `index` in the set. O(1).
     *
     * Note that there are no guarantees on the ordering of values inside the
     * array, and it may change when more values are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function at(
        Bytes32Set storage set,
        uint256 index
    ) internal view returns (bytes32) {
        uint256 val = _at(set._inner, index);
        bytes32 val_;
        assembly {
            val_ := val
        }
        return val_;
    }

    /**
     * @dev Return the entire set in an array
     *
     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
     * this function has an unbounded cost, and using it as part of a state-changing function may render the function
     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
     */
    function values(
        Bytes32Set storage set
    ) internal view returns (bytes32[] memory res) {
        uint256[] memory val = _values(set._inner);
        assembly {
            res := val
        }
    }

    // AddressSet

    struct AddressSet {
        Set _inner;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function add(
        AddressSet storage set,
        address value
    ) internal returns (bool) {
        uint256 store;
        assembly {
            store := value
        }
        return _add(set._inner, store);
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function remove(
        AddressSet storage set,
        address value
    ) internal returns (bool) {
        uint256 store;
        assembly {
            store := value
        }
        return _remove(set._inner, store);
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function contains(
        AddressSet storage set,
        address value
    ) internal view returns (bool) {
        uint256 store;
        assembly {
            store := value
        }
        return _contains(set._inner, store);
    }

    /**
     * @dev Returns the number of values in the set. O(1).
     */
    function length(AddressSet storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

    /**
     * @dev Returns the value stored at position `index` in the set. O(1).
     *
     * Note that there are no guarantees on the ordering of values inside the
     * array, and it may change when more values are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function at(
        AddressSet storage set,
        uint256 index
    ) internal view returns (address addr) {
        uint256 value = _at(set._inner, index);
        assembly {
            addr := value
        }
    }

    /**
     * @dev Return the entire set in an array
     *
     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
     * this function has an unbounded cost, and using it as part of a state-changing function may render the function
     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
     */
    function values(
        AddressSet storage set
    ) internal view returns (address[] memory res) {
        uint256[] memory store = _values(set._inner);

        /// @solidity memory-safe-assembly
        assembly {
            res := store
        }
    }

    // UintSet

    struct UintSet {
        Set _inner;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function add(UintSet storage set, uint256 value) internal returns (bool) {
        return _add(set._inner, value);
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function remove(
        UintSet storage set,
        uint256 value
    ) internal returns (bool) {
        return _remove(set._inner, value);
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function contains(
        UintSet storage set,
        uint256 value
    ) internal view returns (bool) {
        return _contains(set._inner, value);
    }

    /**
     * @dev Returns the number of values on the set. O(1).
     */
    function length(UintSet storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

    /**
     * @dev Returns the value stored at position `index` in the set. O(1).
     *
     * Note that there are no guarantees on the ordering of values inside the
     * array, and it may change when more values are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function at(
        UintSet storage set,
        uint256 index
    ) internal view returns (uint256) {
        return uint256(_at(set._inner, index));
    }

    /**
     * @dev Return the entire set in an array
     *
     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
     * this function has an unbounded cost, and using it as part of a state-changing function may render the function
     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
     */
    function values(
        UintSet storage set
    ) internal view returns (uint256[] memory) {
        return _values(set._inner);
    }
}


// File: oz-custom/contracts/oz/access/AccessControl.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (access/AccessControl.sol)

pragma solidity ^0.8.17;

import {Context} from "../utils/Context.sol";
import {ERC165} from "../utils/introspection/ERC165.sol";

import {IAccessControl} from "./IAccessControl.sol";

import {BitMap256} from "../../libraries/structs/BitMap256.sol";
import {Bytes32Address} from "../../libraries/Bytes32Address.sol";

/**
 * @dev Contract module that allows children to implement role-based access
 * control mechanisms. This is a lightweight version that doesn't allow enumerating role
 * members except through off-chain means by accessing the contract event logs. Some
 * applications may benefit from on-chain enumerability, for those cases see
 * {AccessControlEnumerable}.
 *
 * Roles are referred to by their `bytes32` identifier. These should be exposed
 * in the external API and be unique. The best way to achieve this is by
 * using `public constant` hash digests:
 *
 * ```
 * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");
 * ```
 *
 * Roles can be used to represent a set of permissions. To restrict access to a
 * function call, use {hasRole}:
 *
 * ```
 * function foo() public {
 *     require(hasRole(MY_ROLE, msg.sender));
 *     ...
 * }
 * ```
 *
 * Roles can be granted and revoked dynamically via the {grantRole} and
 * {revokeRole} functions. Each role has an associated admin role, and only
 * accounts that have a role's admin role can call {grantRole} and {revokeRole}.
 *
 * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
 * that only accounts with this role will be able to grant or revoke other
 * roles. More complex role relationships can be created by using
 * {_setRoleAdmin}.
 *
 * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to
 * grant and revoke this role. Extra precautions should be taken to secure
 * accounts that have been granted it.
 */
abstract contract AccessControl is Context, IAccessControl, ERC165 {
    using Bytes32Address for address;
    using BitMap256 for BitMap256.BitMap;

    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;

    // role => admin
    mapping(bytes32 => bytes32) internal _adminRoles;
    // user => roles
    mapping(address => BitMap256.BitMap) internal _roles;

    /**
     * @dev Modifier that checks that an account has a specific role. Reverts
     * with a standardized message including the required role.
     *
     * The format of the revert reason is given by the following regular expression:
     *
     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/
     *
     * _Available since v4.1._
     */
    modifier onlyRole(bytes32 role) {
        _checkRole(role);
        _;
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(
        bytes4 interfaceId
    ) public view virtual override returns (bool) {
        return
            interfaceId == type(IAccessControl).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(
        bytes32 role,
        address account
    ) public view virtual override returns (bool) {
        return
            _roles[account].get({value_: uint256(role), shouldHash_: false});
    }

    /**
     * @dev Revert with a standard message if `_msgSender()` is missing `role`.
     * Overriding this function changes the behavior of the {onlyRole} modifier.
     *
     * Format of the revert message is described in {_checkRole}.
     *
     * _Available since v4.6._
     */
    function _checkRole(bytes32 role) internal view virtual {
        _checkRole(role, _msgSender());
    }

    /**
     * @dev Revert with a standard message if `account` is missing `role`.
     *
     * The format of the revert reason is given by the following regular expression:
     *
     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/
     */
    function _checkRole(bytes32 role, address account) internal view virtual {
        if (!hasRole(role, account))
            revert AccessControl__RoleMissing(role, account);
    }

    /**
     * @dev Returns the admin role that controls `role`. See {grantRole} and
     * {revokeRole}.
     *
     * To change a role's admin, use {_setRoleAdmin}.
     */
    function getRoleAdmin(
        bytes32 role
    ) public view virtual override returns (bytes32 admin) {
        assembly {
            mstore(0, role)
            mstore(32, _adminRoles.slot)
            admin := sload(keccak256(0, 64))
        }
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     *
     * May emit a {RoleGranted} event.
     */
    function grantRole(
        bytes32 role,
        address account
    ) public virtual override onlyRole(getRoleAdmin(role)) {
        _grantRole(role, account);
    }

    /**
     * @dev Revokes `role` from `account`.
     *
     * If `account` had been granted `role`, emits a {RoleRevoked} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     *
     * May emit a {RoleRevoked} event.
     */
    function revokeRole(
        bytes32 role,
        address account
    ) public virtual override onlyRole(getRoleAdmin(role)) {
        _revokeRole(role, account);
    }

    /**
     * @dev Revokes `role` from the calling account.
     *
     * Roles are often managed via {grantRole} and {revokeRole}: this function's
     * purpose is to provide a mechanism for accounts to lose their privileges
     * if they are compromised (such as when a trusted device is misplaced).
     *
     * If the calling account had been revoked `role`, emits a {RoleRevoked}
     * event.
     *
     * Requirements:
     *
     * - the caller must be `account`.
     *
     * May emit a {RoleRevoked} event.
     */
    function renounceRole(
        bytes32 role,
        address account
    ) public virtual override {
        if (account != _msgSender()) revert AccessControl__Unauthorized();
        _revokeRole(role, account);
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event. Note that unlike {grantRole}, this function doesn't perform any
     * checks on the calling account.
     *
     * May emit a {RoleGranted} event.
     *
     * [WARNING]
     * ====
     * This function should only be called from the constructor when setting
     * up the initial roles for the system.
     *
     * Using this function in any other way is effectively circumventing the admin
     * system imposed by {AccessControl}.
     * ====
     *
     * NOTE: This function is deprecated in favor of {_grantRole}.
     */
    function _setupRole(bytes32 role, address account) internal virtual {
        _grantRole(role, account);
    }

    /**
     * @dev Sets `adminRole` as ``role``'s admin role.
     *
     * Emits a {RoleAdminChanged} event.
     */
    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);
        assembly {
            mstore(0, role)
            mstore(32, _adminRoles.slot)
            sstore(keccak256(0, 64), adminRole)
        }
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * Internal function without access restriction.
     *
     * May emit a {RoleGranted} event.
     */
    function _grantRole(bytes32 role, address account) internal virtual {
        if (!hasRole(role, account)) {
            _roles[account].set({value_: uint256(role), shouldHash_: false});
            emit RoleGranted(role, account, _msgSender());
        }
    }

    /**
     * @dev Revokes `role` from `account`.
     *
     * Internal function without access restriction.
     *
     * May emit a {RoleRevoked} event.
     */
    function _revokeRole(bytes32 role, address account) internal virtual {
        if (hasRole(role, account)) {
            _roles[account].unset({value_: uint256(role), shouldHash_: false});
            emit RoleRevoked(role, account, _msgSender());
        }
    }
}


// File: oz-custom/contracts/oz/access/AccessControlEnumerable.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)

pragma solidity ^0.8.17;

import {AccessControl} from "./AccessControl.sol";

import {IAccessControlEnumerable} from "./IAccessControlEnumerable.sol";

import {EnumerableSet256} from "../../libraries/structs/EnumerableSet256.sol";

/**
 * @dev Extension of {AccessControl} that allows enumerating the members of each role.
 */
abstract contract AccessControlEnumerable is
    IAccessControlEnumerable,
    AccessControl
{
    using EnumerableSet256 for EnumerableSet256.AddressSet;

    mapping(bytes32 => EnumerableSet256.AddressSet) internal _roleMembers;

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(
        bytes4 interfaceId
    ) public view virtual override returns (bool) {
        return
            interfaceId == type(IAccessControlEnumerable).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    function getAllRoleMembers(
        bytes32 role_
    ) public view virtual override returns (address[] memory) {
        return _roleMembers[role_].values();
    }

    /**
     * @dev Returns one of the accounts that have `role`. `index` must be a
     * value between 0 and {getRoleMemberCount}, non-inclusive.
     *
     * Role bearers are not sorted in any particular way, and their ordering may
     * change at any point.
     *
     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure
     * you perform all queries on the same block. See the following
     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]
     * for more information.
     */
    function getRoleMember(
        bytes32 role,
        uint256 index
    ) public view virtual override returns (address) {
        return _roleMembers[role].at(index);
    }

    /**
     * @dev Returns the number of accounts that have `role`. Can be used
     * together with {getRoleMember} to enumerate all bearers of a role.
     */
    function getRoleMemberCount(
        bytes32 role
    ) public view virtual override returns (uint256) {
        return _roleMembers[role].length();
    }

    /**
     * @dev Overload {_grantRole} to track enumerable memberships
     */
    function _grantRole(
        bytes32 role,
        address account
    ) internal virtual override {
        super._grantRole(role, account);
        _roleMembers[role].add(account);
    }

    /**
     * @dev Overload {_revokeRole} to track enumerable memberships
     */
    function _revokeRole(
        bytes32 role,
        address account
    ) internal virtual override {
        super._revokeRole(role, account);
        _roleMembers[role].remove(account);
    }
}


// File: oz-custom/contracts/oz/access/IAccessControl.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)

pragma solidity ^0.8.17;

/**
 * @dev External interface of AccessControl declared to support ERC165 detection.
 */
interface IAccessControl {
    error AccessControl__Unauthorized();
    error AccessControl__RoleMissing(bytes32 role, address account);
    /**
     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`
     *
     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
     * {RoleAdminChanged} not being emitted signaling this.
     *
     * _Available since v3.1._
     */
    event RoleAdminChanged(
        bytes32 indexed role,
        bytes32 indexed previousAdminRole,
        bytes32 indexed newAdminRole
    );

    /**
     * @dev Emitted when `account` is granted `role`.
     *
     * `sender` is the account that originated the contract call, an admin role
     * bearer except when using {AccessControl-_setupRole}.
     */
    event RoleGranted(
        bytes32 indexed role,
        address indexed account,
        address indexed sender
    );

    /**
     * @dev Emitted when `account` is revoked `role`.
     *
     * `sender` is the account that originated the contract call:
     *   - if using `revokeRole`, it is the admin role bearer
     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
     */
    event RoleRevoked(
        bytes32 indexed role,
        address indexed account,
        address indexed sender
    );

    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(
        bytes32 role,
        address account
    ) external view returns (bool);

    /**
     * @dev Returns the admin role that controls `role`. See {grantRole} and
     * {revokeRole}.
     *
     * To change a role's admin, use {AccessControl-_setRoleAdmin}.
     */
    function getRoleAdmin(bytes32 role) external view returns (bytes32);

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function grantRole(bytes32 role, address account) external;

    /**
     * @dev Revokes `role` from `account`.
     *
     * If `account` had been granted `role`, emits a {RoleRevoked} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function revokeRole(bytes32 role, address account) external;

    /**
     * @dev Revokes `role` from the calling account.
     *
     * Roles are often managed via {grantRole} and {revokeRole}: this function's
     * purpose is to provide a mechanism for accounts to lose their privileges
     * if they are compromised (such as when a trusted device is misplaced).
     *
     * If the calling account had been granted `role`, emits a {RoleRevoked}
     * event.
     *
     * Requirements:
     *
     * - the caller must be `account`.
     */
    function renounceRole(bytes32 role, address account) external;

    function DEFAULT_ADMIN_ROLE() external pure returns (bytes32);
}


// File: oz-custom/contracts/oz/access/IAccessControlEnumerable.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)

pragma solidity ^0.8.17;

import {IAccessControl} from "./IAccessControl.sol";

/**
 * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.
 */
interface IAccessControlEnumerable is IAccessControl {
    /**
     * @dev Returns one of the accounts that have `role`. `index` must be a
     * value between 0 and {getRoleMemberCount}, non-inclusive.
     *
     * Role bearers are not sorted in any particular way, and their ordering may
     * change at any point.
     *
     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure
     * you perform all queries on the same block. See the following
     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]
     * for more information.
     */
    function getRoleMember(
        bytes32 role,
        uint256 index
    ) external view returns (address);

    /**
     * @dev Returns the number of accounts that have `role`. Can be used
     * together with {getRoleMember} to enumerate all bearers of a role.
     */
    function getRoleMemberCount(bytes32 role) external view returns (uint256);

    function getAllRoleMembers(
        bytes32 role_
    ) external view returns (address[] memory);
}


// File: oz-custom/contracts/oz/security/Pausable.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)

pragma solidity ^0.8.17;

import {Context} from "../utils/Context.sol";

interface IPausable {
    error Pausable__Paused();
    error Pausable__NotPaused();

    /**
     * @dev Emitted when the pause is triggered by `account`.
     */
    event Paused(address account);

    /**
     * @dev Emitted when the pause is lifted by `account`.
     */
    event Unpaused(address account);

    /**
     * @dev Pauses all functions in the contract. Only callable by accounts with the PAUSER_ROLE.
     */
    function pause() external;

    /**
     * @dev Unpauses all functions in the contract. Only callable by accounts with the PAUSER_ROLE.
     */
    function unpause() external;

    function paused() external view returns (bool isPaused);
}

/**
 * @dev Contract module which allows children to implement an emergency stop
 * mechanism that can be triggered by an authorized account.
 *
 * This module is used through inheritance. It will make available the
 * modifiers `whenNotPaused` and `whenPaused`, which can be applied to
 * the functions of your contract. Note that they will not be pausable by
 * simply including this module, only once the modifiers are put in place.
 */
abstract contract Pausable is Context, IPausable {
    uint256 private __paused;

    /**
     * @dev Initializes the contract in unpaused state.
     */
    constructor() payable {
        __paused = 1;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     *
     * Requirements:
     *
     * - The contract must not be paused.
     */
    modifier whenNotPaused() {
        _requireNotPaused();
        _;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is paused.
     *
     * Requirements:
     *
     * - The contract must be paused.
     */
    modifier whenPaused() {
        _requirePaused();
        _;
    }

    /**
     * @dev Returns true if the contract is paused, and false otherwise.
     */
    function paused() public view virtual returns (bool isPaused) {
        assembly {
            isPaused := eq(2, sload(__paused.slot))
        }
    }

    /**
     * @dev Throws if the contract is paused.
     */
    function _requireNotPaused() internal view virtual {
        if (paused()) revert Pausable__Paused();
    }

    /**
     * @dev Throws if the contract is not paused.
     */
    function _requirePaused() internal view virtual {
        if (!paused()) revert Pausable__NotPaused();
    }

    /**
     * @dev Triggers stopped state.
     *
     * Requirements:
     *
     * - The contract must not be paused.
     */
    function _pause() internal virtual whenNotPaused {
        __paused = 2;
        emit Paused(_msgSender());
    }

    /**
     * @dev Returns to normal state.
     *
     * Requirements:
     *
     * - The contract must be paused.
     */
    function _unpause() internal virtual whenPaused {
        __paused = 1;
        emit Unpaused(_msgSender());
    }
}


// File: oz-custom/contracts/oz/token/ERC20/ERC20.sol
// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity ^0.8.17;

import {Context} from "../../utils/Context.sol";

import {IERC20} from "./IERC20.sol";
import {IERC20Metadata} from "./extensions/IERC20Metadata.sol";

/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.
/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)
/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)
/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.
abstract contract ERC20 is Context, IERC20, IERC20Metadata {
    /*//////////////////////////////////////////////////////////////
                              ERC20 STORAGE
    //////////////////////////////////////////////////////////////*/

    uint256 public totalSupply;

    string public name;
    string public symbol;

    mapping(address => uint256) internal _balanceOf;

    mapping(address => mapping(address => uint256)) internal _allowance;

    /*//////////////////////////////////////////////////////////////
                               CONSTRUCTOR
    //////////////////////////////////////////////////////////////*/

    constructor(string memory name_, string memory symbol_) payable {
        if (bytes(symbol_).length > 32 || bytes(name_).length > 32)
            revert ERC20__StringTooLong();

        name = name_;
        symbol = symbol_;
    }

    /*//////////////////////////////////////////////////////////////
                               ERC20 LOGIC
    //////////////////////////////////////////////////////////////*/
    function decimals() public pure virtual returns (uint8) {
        return 18;
    }

    function approve(
        address spender,
        uint256 amount
    ) public virtual returns (bool) {
        address sender = _msgSender();

        assembly {
            mstore(0, sender)
            mstore(32, _allowance.slot)
            mstore(32, keccak256(0, 64))
            mstore(0, spender)
            sstore(keccak256(0, 64), amount)
        }

        emit Approval(sender, spender, amount);

        return true;
    }

    function transfer(
        address to,
        uint256 amount
    ) public virtual returns (bool) {
        address sender = _msgSender();
        _beforeTokenTransfer(sender, to, amount);
        _balanceOf[sender] -= amount;

        // Cannot overflow because the sum of all user
        // balances can't exceed the max uint256 value.
        unchecked {
            _balanceOf[to] += amount;
        }

        emit Transfer(sender, to, amount);

        _afterTokenTransfer(sender, to, amount);

        return true;
    }

    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public virtual returns (bool) {
        _beforeTokenTransfer(from, to, amount);

        _spendAllowance(from, _msgSender(), amount);

        _balanceOf[from] -= amount;

        // Cannot overflow because the sum of all user
        // balances can't exceed the max uint256 value.
        unchecked {
            _balanceOf[to] += amount;
        }

        assembly {
            mstore(0, amount)
            log3(
                0,
                0x20,
                0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef,
                from,
                to
            )
        }

        _afterTokenTransfer(from, to, amount);
        return true;
    }

    function balanceOf(
        address account
    ) external view override returns (uint256 _balance) {
        assembly {
            mstore(0, account)
            mstore(32, _balanceOf.slot)
            _balance := sload(keccak256(0, 64))
        }
    }

    function allowance(
        address owner,
        address spender
    ) external view override returns (uint256 allowance_) {
        assembly {
            mstore(0, owner)
            mstore(32, _allowance.slot)
            mstore(32, keccak256(0, 64))
            mstore(0, spender)
            allowance_ := sload(keccak256(0, 64))
        }
    }

    /*//////////////////////////////////////////////////////////////
                        INTERNAL MINT/BURN LOGIC
    //////////////////////////////////////////////////////////////*/
    function _spendAllowance(
        address owner_,
        address spender_,
        uint256 amount_
    ) internal virtual {
        bytes32 allowanceKey;
        uint256 allowed;
        assembly {
            mstore(0, owner_)
            mstore(32, _allowance.slot)
            mstore(32, keccak256(0, 64))
            mstore(0, spender_)
            allowanceKey := keccak256(0, 64)
            allowed := sload(allowanceKey)
        }

        if (allowed == ~uint256(0)) return;

        allowed -= amount_;
        assembly {
            sstore(allowanceKey, allowed)
        }
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {}

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {}

    function _mint(address to, uint256 amount) internal virtual {
        _beforeTokenTransfer(address(0), to, amount);
        totalSupply += amount;

        // Cannot overflow because the sum of all user
        // balances can't exceed the max uint256 value.
        unchecked {
            _balanceOf[to] += amount;
        }

        assembly {
            mstore(0, amount)
            log3(
                0,
                0x20,
                0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef,
                0,
                to
            )
        }

        _afterTokenTransfer(address(0), to, amount);
    }

    function _burn(address from, uint256 amount) internal virtual {
        _beforeTokenTransfer(from, address(0), amount);

        _balanceOf[from] -= amount;

        // Cannot underflow because a user's balance
        // will never be larger than the total supply.
        unchecked {
            totalSupply -= amount;
        }

        assembly {
            mstore(0, amount)
            log3(
                0,
                0x20,
                0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef,
                from,
                0
            )
        }

        _afterTokenTransfer(from, address(0), amount);
    }
}


// File: oz-custom/contracts/oz/token/ERC20/extensions/ERC20Burnable.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)

pragma solidity ^0.8.17;

import {ERC20, IERC20} from "../ERC20.sol";

interface IERC20Burnabble is IERC20 {
    function burn(uint256 amount) external;

    function burnFrom(address account, uint256 amount) external;
}

/**
 * @dev Extension of {ERC20} that allows token holders to destroy both their own
 * tokens and those that they have an allowance for, in a way that can be
 * recognized off-chain (via event analysis).
 */
abstract contract ERC20Burnable is ERC20, IERC20Burnabble {
    /**
     * @dev Destroys `amount` tokens from the caller.
     *
     * See {ERC20-_burn}.
     */
    function burn(uint256 amount) external virtual {
        _burn(_msgSender(), amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, deducting from the caller's
     * allowance.
     *
     * See {ERC20-_burn} and {ERC20-allowance}.
     *
     * Requirements:
     *
     * - the caller must have allowance for ``accounts``'s tokens of at least
     * `amount`.
     */
    function burnFrom(address account, uint256 amount) public virtual {
        _spendAllowance(account, _msgSender(), amount);
        _burn(account, amount);
    }
}


// File: oz-custom/contracts/oz/token/ERC20/extensions/ERC20Pausable.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/ERC20Pausable.sol)

pragma solidity ^0.8.17;

import {ERC20} from "../ERC20.sol";
import {Pausable} from "../../../security/Pausable.sol";

/**
 * @dev ERC20 token with pausable token transfers, minting and burning.
 *
 * Useful for scenarios such as preventing trades until the end of an evaluation
 * period, or having an emergency switch for freezing all token transfers in the
 * event of a large bug.
 */
abstract contract ERC20Pausable is ERC20, Pausable {
    /**
     * @dev See {ERC20-_beforeTokenTransfer}.
     *
     * Requirements:
     *
     * - the contract must not be paused.
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override whenNotPaused {
        super._beforeTokenTransfer(from, to, amount);
    }
}


// File: oz-custom/contracts/oz/token/ERC20/extensions/ERC20Permit.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import {ERC20} from "../ERC20.sol";

import {Signable, Bytes32Address} from "../../../../internal/Signable.sol";

import {IERC20Permit} from "./IERC20Permit.sol";

/**
 * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
 * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
 *
 * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
 * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't
 * need to send a transaction, and thus is not required to hold Ether at all.
 *
 * _Available since v3.4._
 */
abstract contract ERC20Permit is ERC20, IERC20Permit, Signable {
    using Bytes32Address for address;

    // solhint-disable-next-line var-name-mixedcase
    /// @dev value is equal to keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)")
    bytes32 private constant __PERMIT_TYPEHASH =
        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;

    /**
     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `"1"`.
     *
     * It's a good idea to use the same `name` that is defined as the ERC20 token name.
     */
    constructor(
        string memory name_,
        string memory symbol_
    ) payable Signable(name_, "1") ERC20(name_, symbol_) {}

    /**
     * @dev See {IERC20Permit-permit}.
     */
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external virtual override {
        if (block.timestamp > deadline) revert ERC20Permit__Expired();

        bytes32 digest;
        bytes32 allowanceKey;
        assembly {
            mstore(0, owner)
            mstore(32, _nonces.slot)
            let nonceKey := keccak256(0, 64)
            let nonce := sload(nonceKey)

            let freeMemPtr := mload(0x40)

            mstore(freeMemPtr, __PERMIT_TYPEHASH)
            mstore(add(freeMemPtr, 32), owner)
            mstore(add(freeMemPtr, 64), spender)
            mstore(add(freeMemPtr, 96), value)
            mstore(add(freeMemPtr, 128), nonce)
            mstore(add(freeMemPtr, 160), deadline)
            digest := keccak256(freeMemPtr, 192)

            sstore(nonceKey, add(1, nonce))

            mstore(32, _allowance.slot)
            allowanceKey := keccak256(0, 64)
        }

        _verify(owner, digest, v, r, s);

        assembly {
            mstore(0, spender)
            mstore(32, allowanceKey)
            sstore(keccak256(0, 64), value)
        }
    }

    /**
     * @dev See {IERC20Permit-nonces}.
     *

    /**
     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.
     */
    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR()
        external
        view
        override(IERC20Permit, Signable)
        returns (bytes32)
    {
        return _domainSeparatorV4();
    }

    function nonces(address account_) external view returns (uint256) {
        return _nonces[account_.fillLast12Bytes()];
    }
}


// File: oz-custom/contracts/oz/token/ERC20/extensions/IERC20Metadata.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)

pragma solidity ^0.8.0;

import {IERC20} from "../IERC20.sol";

/**
 * @dev Interface for the optional metadata functions from the ERC20 standard.
 *
 * _Available since v4.1._
 */
interface IERC20Metadata is IERC20 {
    /**
     * @dev Returns the name of the token.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the symbol of the token.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the decimals places of the token.
     */
    function decimals() external view returns (uint8);
}


// File: oz-custom/contracts/oz/token/ERC20/extensions/IERC20Permit.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)

pragma solidity ^0.8.17;

import {IERC20} from "../IERC20.sol";

/**
 * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
 * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
 *
 * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
 * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't
 * need to send a transaction, and thus is not required to hold Ether at all.
 */
interface IERC20Permit is IERC20 {
    error ERC20Permit__Expired();

    /**
     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,
     * given ``owner``'s signed approval.
     *
     * IMPORTANT: The same issues {IERC20-approve} has related to transaction
     * ordering also apply here.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `deadline` must be a timestamp in the future.
     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
     * over the EIP712-formatted function arguments.
     * - the signature must use ``owner``'s current nonce (see {nonces}).
     *
     * For more information on the signature format, see the
     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
     * section].
     */
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    /**
     * @dev Returns the current nonce for `owner`. This value must be
     * included whenever a signature is generated for {permit}.
     *
     * Every successful call to {permit} increases ``owner``'s nonce by one. This
     * prevents a signature from being used multiple times.
     */
    function nonces(address owner) external view returns (uint256);

    /**
     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.
     */
    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32);
}


// File: oz-custom/contracts/oz/token/ERC20/IERC20.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    error ERC20__Expired();
    error ERC20__StringTooLong();
    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(
        address owner,
        address spender
    ) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `from` to `to` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
}


// File: oz-custom/contracts/oz/utils/Context.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)

pragma solidity ^0.8.17;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address sender) {
        assembly {
            sender := caller()
        }
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}


// File: oz-custom/contracts/oz/utils/cryptography/draft-EIP712.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import {ECDSA, EIP712} from "./EIP712.sol";


// File: oz-custom/contracts/oz/utils/cryptography/ECDSA.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

/// @notice Gas optimized ECDSA wrapper.
/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/ECDSA.sol)
/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol)
library ECDSA {
    function recover(
        bytes32 hash,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal view returns (address result) {
        assembly {
            // Copy the free memory pointer so that we can restore it later.
            let m := mload(0x40)
            mstore(0x20, v)
            // If `s` in lower half order, such that the signature is not malleable.
            // prettier-ignore
            if iszero(gt(s, 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0)) {
                mstore(0x00, hash)
                mstore(0x40, r)
                mstore(0x60, s)
                pop(
                    staticcall(
                        gas(), // Amount of gas left for the transaction.
                        0x01, // Address of `ecrecover`.
                        0x00, // Start of input.
                        0x80, // Size of input.
                        0x40, // Start of output.
                        0x20 // Size of output.
                    )
                )
                // Restore the zero slot.
                mstore(0x60, 0)
                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.
                result := mload(sub(0x60, returndatasize()))
            }
            // Restore the free memory pointer.
            mstore(0x40, m)
        }
    }

    function recover(
        bytes32 hash,
        bytes calldata signature
    ) internal view returns (address result) {
        assembly {
            // Copy the free memory pointer so that we can restore it later.
            let m := mload(0x40)
            // Directly load `s` from the calldata.
            let s := calldataload(add(signature.offset, 0x20))

            switch signature.length
            case 64 {
                // Here, `s` is actually `vs` that needs to be recovered into `v` and `s`.
                // Compute `v` and store it in the scratch space.
                mstore(0x20, add(shr(255, s), 27))
                // prettier-ignore
                s := and(s, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)
            }
            case 65 {
                // Compute `v` and store it in the scratch space.
                mstore(
                    0x20,
                    byte(0, calldataload(add(signature.offset, 0x40)))
                )
            }

            // If `s` in lower half order, such that the signature is not malleable.
            // prettier-ignore
            if iszero(gt(s, 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0)) {
                mstore(0x00, hash)
                calldatacopy(0x40, signature.offset, 0x20) // Directly copy `r` over.
                mstore(0x60, s)
                pop(
                    staticcall(
                        gas(), // Amount of gas left for the transaction.
                        0x01, // Address of `ecrecover`.
                        0x00, // Start of input.
                        0x80, // Size of input.
                        0x40, // Start of output.
                        0x20 // Size of output.
                    )
                )
                // Restore the zero slot.
                mstore(0x60, 0)
                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.
                result := mload(sub(0x60, returndatasize()))
            }
            // Restore the free memory pointer.
            mstore(0x40, m)
        }
    }

    function toTypedDataHash(
        bytes32 domainSeparator,
        bytes32 structHash
    ) internal pure returns (bytes32 result) {
        assembly {
            // Load free memory pointer
            let memPtr := mload(64)

            mstore(
                memPtr,
                0x1901000000000000000000000000000000000000000000000000000000000000
            ) // EIP191 header
            mstore(add(memPtr, 2), domainSeparator) // EIP712 domain hash
            mstore(add(memPtr, 34), structHash) // Hash of struct

            // Compute hash
            result := keccak256(memPtr, 66)
        }
    }

    function toEthSignedMessageHash(
        bytes32 hash
    ) internal pure returns (bytes32 result) {
        assembly {
            // Store into scratch space for keccak256.
            mstore(0x20, hash)
            mstore(0x00, "\x00\x00\x00\x00\x19Ethereum Signed Message:\n32")
            // 0x40 - 0x04 = 0x3c
            result := keccak256(0x04, 0x3c)
        }
    }

    function toEthSignedMessageHash(
        bytes memory s
    ) internal pure returns (bytes32 result) {
        assembly {
            // We need at most 128 bytes for Ethereum signed message header.
            // The max length of the ASCII reprenstation of a uint256 is 78 bytes.
            // The length of "\x19Ethereum Signed Message:\n" is 26 bytes.
            // The next multiple of 32 above 78 + 26 is 128.

            // Instead of allocating, we temporarily copy the 128 bytes before the
            // start of `s` data to some variables.
            let m3 := mload(sub(s, 0x60))
            let m2 := mload(sub(s, 0x40))
            let m1 := mload(sub(s, 0x20))
            // The length of `s` is in bytes.
            let sLength := mload(s)

            let ptr := add(s, 0x20)

            // `end` marks the end of the memory which we will compute the keccak256 of.
            let end := add(ptr, sLength)

            // Convert the length of the bytes to ASCII decimal representation
            // and store it into the memory.
            for {
                let temp := sLength
                ptr := sub(ptr, 1)
                mstore8(ptr, add(48, mod(temp, 10)))
                temp := div(temp, 10)
            } temp {
                temp := div(temp, 10)
            } {
                ptr := sub(ptr, 1)
                mstore8(ptr, add(48, mod(temp, 10)))
            }

            // Move the pointer 32 bytes lower to make room for the string.
            // `start` marks the start of the memory which we will compute the keccak256 of.
            let start := sub(ptr, 32)
            // Copy the header over to the memory.
            mstore(
                start,
                "\x00\x00\x00\x00\x00\x00\x19Ethereum Signed Message:\n"
            )
            start := add(start, 6)

            // Compute the keccak256 of the memory.
            result := keccak256(start, sub(end, start))

            // Restore the previous memory.
            mstore(s, sLength)
            mstore(sub(s, 0x20), m1)
            mstore(sub(s, 0x40), m2)
            mstore(sub(s, 0x60), m3)
        }
    }
}


// File: oz-custom/contracts/oz/utils/cryptography/EIP712.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)

pragma solidity ^0.8.17;

import {ECDSA} from "./ECDSA.sol";

/**
 * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.
 *
 * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,
 * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding
 * they need in their contracts using a combination of `abi.encode` and `keccak256`.
 *
 * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding
 * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA
 * ({_hashTypedDataV4}).
 *
 * The implementation of the domain separator was designed to be as efficient as possible while still properly updating
 * the chain id to protect against replay attacks on an eventual fork of the chain.
 *
 * NOTE: This contract implements the version of the encoding known as "v4", as implemented by the JSON RPC method
 * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].
 *
 * _Available since v3.4._
 */
abstract contract EIP712 {
    /* solhint-disable var-name-mixedcase */
    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to
    // invalidate the cached domain separator if the chain id changes.
    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;
    uint256 private immutable _CACHED_CHAIN_ID;
    address private immutable _CACHED_THIS;

    bytes32 private immutable _HASHED_NAME;
    bytes32 private immutable _HASHED_VERSION;
    bytes32 private immutable _TYPE_HASH;

    /* solhint-enable var-name-mixedcase */

    /**
     * @dev Initializes the domain separator and parameter caches.
     *
     * The meaning of `name` and `version` is specified in
     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:
     *
     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.
     * - `version`: the current major version of the signing domain.
     *
     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart
     * contract upgrade].
     */
    constructor(string memory name, string memory version) payable {
        bytes32 hashedName = keccak256(bytes(name));
        bytes32 hashedVersion = keccak256(bytes(version));
        ///@dev 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f is equal to keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)")

        _HASHED_NAME = hashedName;
        _HASHED_VERSION = hashedVersion;
        _CACHED_CHAIN_ID = block.chainid;
        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(
            0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,
            hashedName,
            hashedVersion
        );
        _CACHED_THIS = address(this);
        _TYPE_HASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;
    }

    /**
     * @dev Returns the domain separator for the current chain.
     */
    function _domainSeparatorV4() internal view returns (bytes32) {
        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID)
            return _CACHED_DOMAIN_SEPARATOR;
        else
            return
                _buildDomainSeparator(
                    _TYPE_HASH,
                    _HASHED_NAME,
                    _HASHED_VERSION
                );
    }

    function _buildDomainSeparator(
        bytes32 typeHash,
        bytes32 nameHash,
        bytes32 versionHash
    ) private view returns (bytes32 domainSeparatorV4) {
        assembly {
            mstore(0, typeHash)
            mstore(32, nameHash)
            mstore(64, versionHash)
            mstore(96, chainid())
            mstore(128, address())
            domainSeparatorV4 := keccak256(0, 160)
        }
    }

    /**
     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this
     * function returns the hash of the fully encoded EIP712 message for this domain.
     *
     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:
     *
     * ```solidity
     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(
     *     keccak256("Mail(address to,string contents)"),
     *     mailTo,
     *     keccak256(bytes(mailContents))
     * )));
     * address signer = ECDSA.recover(digest, signature);
     * ```
     */
    function _hashTypedDataV4(
        bytes32 structHash
    ) internal view virtual returns (bytes32) {
        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);
    }
}


// File: oz-custom/contracts/oz/utils/introspection/ERC165.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)

pragma solidity ^0.8.17;

import {IERC165} from "./IERC165.sol";

/**
 * @dev Implementation of the {IERC165} interface.
 *
 * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
 * for the additional interface id that will be supported. For example:
 *
 * ```solidity
 * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 * }
 * ```
 *
 * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
 */
abstract contract ERC165 is IERC165 {
    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(
        bytes4 interfaceId
    ) public view virtual override returns (bool) {
        return interfaceId == type(IERC165).interfaceId;
    }
}


// File: oz-custom/contracts/oz/utils/introspection/IERC165.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)

pragma solidity ^0.8.17;

/**
 * @dev Interface of the ERC165 standard, as defined in the
 * https://eips.ethereum.org/EIPS/eip-165[EIP].
 *
 * Implementers can declare support of contract interfaces, which can then be
 * queried by others ({ERC165Checker}).
 *
 * For an implementation, see {ERC165}.
 */
interface IERC165 {
    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30 000 gas.
     */
    function supportsInterface(
        bytes4 interfaceId
    ) external view returns (bool);
}


// File: oz-custom/contracts/oz/utils/structs/BitMaps.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/structs/BitMaps.sol)
pragma solidity ^0.8.17;

/**
 * @dev Library for managing uint256 to bool mapping in a compact and efficient way, providing the keys are sequential.
 * Largelly inspired by Uniswap's https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol[merkle-distributor].
 */
library BitMaps {
    struct BitMap {
        mapping(uint256 => uint256) map;
    }

    /**
     * @dev Returns whether the bit at `index` is set.
     */
    function get(
        BitMap storage bitmap,
        uint256 index
    ) internal view returns (bool isSet) {
        assembly {
            mstore(0, shr(8, index))
            mstore(32, bitmap.slot)
            // Assign isSet to whether the value is non zero.
            isSet := and(sload(keccak256(0, 64)), shl(and(index, 0xff), 1))
        }
    }

    /**
     * @dev Sets the bit at `index` to the boolean `value`.
     */
    function setTo(
        BitMap storage bitmap,
        uint256 index,
        bool shouldSet
    ) internal {
        assembly {
            mstore(0, shr(8, index))
            mstore(32, bitmap.slot)
            let mapKey := keccak256(0, 64)
            let value := sload(mapKey)

            // The following sets the bit at `shift` without branching.
            let shift := and(index, 0xff)
            // Isolate the bit at `shift`.
            let x := and(shr(shift, value), 1)
            // Xor it with `shouldSet`. Results in 1 if both are different, else 0.
            x := xor(x, shouldSet)
            // Shifts the bit back. Then, xor with value.
            // Only the bit at `shift` will be flipped if they differ.
            // Every other bit will stay the same, as they are xor'ed with zeroes.
            value := xor(value, shl(shift, x))

            sstore(mapKey, value)
        }
    }

    /**
     * @dev Sets the bit at `index`.
     */
    function set(BitMap storage bitmap, uint256 index) internal {
        assembly {
            mstore(0, shr(8, index))
            mstore(32, bitmap.slot)
            let key := keccak256(0, 64)
            let value := sload(key)
            value := or(value, shl(and(index, 0xff), 1))
            sstore(key, value)
        }
    }

    function setBatch(
        BitMap storage bitmap_,
        uint256[] calldata values_
    ) internal {
        assembly {
            let length := values_.length
            let i := add(calldataload(values_.offset), 0x20)
            mstore(0x20, bitmap_.slot)
            for {
                let end := add(i, shl(5, length))
            } lt(i, end) {
                i := add(i, 0x20)
            } {
                mstore(0x00, shr(8, mload(i)))
                let key := keccak256(0x00, 0x40)
                sstore(key, or(sload(key), shl(and(mload(i), 0xff), 1)))
            }
        }
    }

    /**
     * @dev Unsets the bit at `index`.
     */
    function unset(BitMap storage bitmap, uint256 index) internal {
        bitmap.map[index >> 8] &= ~(1 << (index & 0xff));
    }
}


// File: oz-custom/contracts/presets/token/interfaces/IWNT.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import {IERC20} from "../../../oz/token/ERC20/IERC20.sol";

interface IWNT is IERC20 {
    event Deposit(address indexed from, uint256 amount);

    event Withdrawal(address indexed to, uint256 amount);

    function deposit() external payable;

    function withdraw(uint256 amount) external;
}

