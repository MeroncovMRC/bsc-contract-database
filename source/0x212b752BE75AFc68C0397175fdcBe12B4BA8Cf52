// SPDX-License-Identifier: MIT

pragma solidity >=0.8.0;


abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor() {
        _setOwner(_msgSender());
    }

    
    function owner() public view virtual returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

library Address {
    
    function isContract(address account) internal view returns (bool) {
        
        
        

        uint256 size;
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }

    
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCall(target, data, "Address: low-level call failed");
    }

    
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");

        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");

        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    
    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(isContract(target), "Address: delegate call to non-contract");

        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            
            if (returndata.length > 0) {
                

                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

library SafeMath {
    
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            uint256 c = a + b;
            if (c < a) return (false, 0);
            return (true, c);
        }
    }

    
    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b > a) return (false, 0);
            return (true, a - b);
        }
    }

    
    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            
            
            
            if (a == 0) return (true, 0);
            uint256 c = a * b;
            if (c / a != b) return (false, 0);
            return (true, c);
        }
    }

    
    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a / b);
        }
    }

    
    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a % b);
        }
    }

    
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return a - b;
    }

    
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        return a * b;
    }

    
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }

    
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return a % b;
    }

    
    function sub(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b <= a, errorMessage);
            return a - b;
        }
    }

    
    function div(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a / b;
        }
    }

    
    function mod(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a % b;
        }
    }
}

interface IERC20 {
    
    function totalSupply() external view returns (uint256);

    
    function balanceOf(address account) external view returns (uint256);

    
    function transfer(address recipient, uint256 amount) external returns (bool);

    
    function allowance(address owner, address spender) external view returns (uint256);

    
    function approve(address spender, uint256 amount) external returns (bool);

    
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface CommonInterface {

  

  function getUserReferrer(address userAddress) external view returns (address);

  

  function stake(address userAddress, uint256 amount, uint8 stakeTypeIdx) external;

  function tokensReceived(address userAddress) external view returns (uint256);

  

  function mint(address _receiver, uint256 _amount) external;

  function transfer(address recipient, uint256 amount) external returns (bool);

  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

}

contract InfinityIncome is Ownable {

  using SafeMath for uint256;

  struct User {
    uint256 id;
    address referrer;
    uint256 referralsCount;
    bool autoReinvest;
    uint8 stakeTypeIdx;
    uint256 tokensReceived;
  }

  enum AutoStart { UNREGISTERED, REGISTERED, QUALIFIED }
  mapping(address => AutoStart) autoStartProgram;
  mapping(address => uint32) public telegramIds;

  uint8 constant public STAKE_TYPES_COUNT = 3;

  mapping (address => mapping(uint8 => bool)) userActiveMatrixLevels;
  mapping (address => mapping(uint8 => MatrixStruct)) userMatrix;

  struct MatrixStruct {
    address currentReferrer;
    address[] firstLevelReferrals;
    address[] secondLevelReferrals;
    bool blocked;
    uint256 reinvestCount;
    uint256 time;
    uint256 passiveIncomeReceived;

    address closedPart;
  }

  address public ADMIN_ADDRESS = 0xfF669CCA4AcFA1f355da57C44736Af9F09E6C0f6;
  address public AUTOSTART_ORACLE_ADDRESS = 0x4493af742D1720c50a0aBD2bC42f34b3317cCAA3;
  address public BUSD_TOKEN_CONTRACT_ADDRESS = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56; 
  address public tokenContractAddress;
  address public stakingContractAddress;
  uint256 public goldMatrixRewardTokensAmount = 5000 * 10**18;

  mapping(address => MatrixStruct) public goldMatrix;
  uint256 public constant GOLD_MATRIX_PRICE = 500 ether;
  mapping(address => uint256) public pendingPayments;

  uint8 public constant LAST_LEVEL = 12;

  uint256 public constant PASSIVE_INCOME_DAILY_PERCENT = 100; 
  uint256 public constant PASSIVE_INCOME_DAILY_PERCENT_ONE_REFERRAL = 75; 
  uint256 public constant PASSIVE_INCOME_DAILY_PERCENT_NO_REFERRALS = 50; 
  uint256 public constant PASSIVE_INCOME_MAX_PROFIT_PERCENT = 120; 

  mapping(address => User) public users;
  mapping(uint256 => address) public idToAddress;

  uint256 public lastUserId = 1;

  uint256[LAST_LEVEL + 1] public levelPrice;
  mapping(uint8 => uint256) private commulativePrice;
  mapping(address => mapping(uint8 => uint256)) public matrixReferralsCount;

  uint256 uniqueIndex = 0;

  event Registration(address indexed user, address indexed referrer, uint256 indexed userId, uint256 referrerId, uint256 index, uint256 time);
  event AutoRegistration(address indexed userAddress, address indexed referrerAddress, uint8 levelTo, bool openGoldMatrix, uint32 linkId, uint256 index, uint256 time);
  event Reinvest(address indexed user, address indexed currentReferrer, address indexed caller, uint8 level, uint256 index, uint256 time);
  event Upgrade(address indexed user, address indexed referrer, uint8 level, uint256 index, uint256 time);
  event NewUserPlace(address indexed user, address indexed referrer, address indexed usersReferrer, uint8 level, uint8 place, uint256 index, uint256 time);
  event MissedBNBReceive(address indexed receiver, address indexed from, uint8 level, uint256 index, uint256 time);
  event SentBNBDividends(address indexed from, address indexed receiver, uint8 level, uint256 amount, uint256 index, uint256 time);
  event SentExtraBNBDividends(address indexed from, address indexed receiver, uint8 level, uint256 index, uint256 time);
  event AutoReinvestFlagSwitch(address indexed user, bool flag, uint256 time);
  event PassiveIncomeWithdrawn(address indexed receiver, uint8 level, uint256 amount, uint256 index, uint256 time);
  event MatrixClosed(address indexed referrer, uint8 level, uint256 reinvestCount, uint256 index, uint256 time);

  event SentRewardTokens(address indexed applicant, address indexed receiver, uint256 amount, bool isInstantPayment, uint256 index, uint256 time);
  event PendingPaymentHold(address indexed receiver, uint256 amount, uint256 index, uint256 time);

  event AutoStartStatusChanged(address indexed participant, AutoStart status, uint256 index, uint256 time);

  event TelegramIdSetted(address indexed user, uint32 indexed telegramId, uint256 index, uint256 time);

  constructor(address _tokenContractAddress) {
    tokenContractAddress = _tokenContractAddress;

    levelPrice[1] = 10 ether;
    commulativePrice[1] = levelPrice[1];
    for (uint8 i = 2; i <= LAST_LEVEL; i++) {
      levelPrice[i] = levelPrice[i-1] * 2;
      commulativePrice[i] = commulativePrice[i-1].add(levelPrice[i]);
    }

    initUser(0x7734189483aEb736f1081D72AC070eFEaBA867bf, address(0x0), LAST_LEVEL, true);
  }

  function initUser(address userAddress, address referrerAddress, uint256 levelTo, bool openGoldMatrix) private {
    User memory user = User({
      id: lastUserId,
      referrer: referrerAddress,
      referralsCount: 0,
      autoReinvest: true,
      stakeTypeIdx: 0,
      tokensReceived: 0
    });

    users[userAddress] = user;
    idToAddress[lastUserId] = userAddress;

    for (uint8 i = 1; i <= levelTo; i++) {
      userActiveMatrixLevels[userAddress][i] = true;
      userMatrix[userAddress][i].time = block.timestamp;

      if (referrerAddress != address(0x0)) {
        updateMatrixReferrer(userAddress, referrerAddress, i);
      }
    }

    lastUserId++;

    if (referrerAddress != address(0x0)) {
      users[referrerAddress].referralsCount++;
    }

    emit Registration(userAddress, referrerAddress, users[userAddress].id, users[referrerAddress].id, uniqueIndex++, block.timestamp);

    
    if (openGoldMatrix) {
      address freeMatrixReferrer = referrerAddress;
      if (referrerAddress != address(0x0)) {
        freeMatrixReferrer = findFreeGoldMatrixReferrer(userAddress);
        updateGoldMatrixReferrer(userAddress, freeMatrixReferrer);
      }

      userActiveMatrixLevels[userAddress][0] = true;

      emit Upgrade(userAddress, freeMatrixReferrer, 0, uniqueIndex++, block.timestamp);
    }
  }

  function autoRegistration(address userAddress, address referrerAddress, uint8 levelTo, bool openGoldMatrix, uint32 linkId) external {
    require(!isUserExists(userAddress), "03");
    require(isUserExists(referrerAddress), "04");

    uint256 price = commulativePrice[levelTo];
    if (openGoldMatrix) {
      price = price.add(GOLD_MATRIX_PRICE);
    }
    require(
      IERC20(BUSD_TOKEN_CONTRACT_ADDRESS).transferFrom(msg.sender, address(this), price),
      "01"
    );

    initUser(userAddress, referrerAddress, levelTo, openGoldMatrix);

    
    autoStartProgram[userAddress] = AutoStart.REGISTERED;
    emit AutoStartStatusChanged(userAddress, AutoStart.REGISTERED, uniqueIndex++, block.timestamp);

    telegramIds[userAddress] = linkId;
    emit AutoRegistration(userAddress, referrerAddress, levelTo, openGoldMatrix, linkId, uniqueIndex++, block.timestamp);
  }

  function registration(address referrerAddress) external {
    require(!isUserExists(msg.sender), "03");
    require(
      IERC20(BUSD_TOKEN_CONTRACT_ADDRESS).transferFrom(msg.sender, address(this), levelPrice[1]),
      "02"
    );
    if (referrerAddress == address(0x0) || referrerAddress == msg.sender || !isUserExists(referrerAddress)) {
      referrerAddress = owner();
    }

    User memory user = User({
      id: lastUserId,
      referrer: referrerAddress,
      referralsCount: 0,
      autoReinvest: true,
      stakeTypeIdx: 0,
      tokensReceived: 0
    });

    users[msg.sender] = user;
    idToAddress[lastUserId] = msg.sender;

    userActiveMatrixLevels[msg.sender][1] = true;
    userMatrix[msg.sender][1].time = block.timestamp;

    lastUserId++;

    users[referrerAddress].referralsCount++;

    updateMatrixReferrer(msg.sender, findFreeMatrixReferrer(msg.sender, 1), 1);

    emit Registration(msg.sender, referrerAddress, users[msg.sender].id, users[referrerAddress].id, uniqueIndex++, block.timestamp);
  }

  function newUserPlace(address user, address referrer, address usersReferrer, uint8 level, uint8 place) private {
    if (referrer == usersReferrer) {
      matrixReferralsCount[referrer][level]++;
    }

    emit NewUserPlace(user, referrer, usersReferrer, level, place, uniqueIndex++, block.timestamp);
  }

  function buyNewLevel(uint8 level) external {
    require(isUserExists(msg.sender), "05");
    require(level > 1 && level <= LAST_LEVEL, "06");
    require(
      IERC20(BUSD_TOKEN_CONTRACT_ADDRESS).transferFrom(msg.sender, address(this), levelPrice[level]),
      "02"
    );

    require(!userActiveMatrixLevels[msg.sender][level], "07");

    if (userMatrix[msg.sender][level-1].blocked) {
      userMatrix[msg.sender][level-1].blocked = false;
    }

    address freeMatrixReferrer = findFreeMatrixReferrer(msg.sender, level);

    userActiveMatrixLevels[msg.sender][level] = true;
    userMatrix[msg.sender][level].time = block.timestamp;
    updateMatrixReferrer(msg.sender, freeMatrixReferrer, level);

    emit Upgrade(msg.sender, freeMatrixReferrer, level, uniqueIndex++, block.timestamp);
  }

  function updateMatrixReferrer(address userAddress, address referrerAddress, uint8 level) private {
    require(userActiveMatrixLevels[referrerAddress][level], "08");

    if (userMatrix[referrerAddress][level].firstLevelReferrals.length < 2) {
      userMatrix[referrerAddress][level].firstLevelReferrals.push(userAddress);
      newUserPlace(userAddress, referrerAddress, users[userAddress].referrer, level, uint8(userMatrix[referrerAddress][level].firstLevelReferrals.length));

      
      userMatrix[userAddress][level].currentReferrer = referrerAddress;

      if (referrerAddress == owner()) {
        return sendBNBDividends(referrerAddress, userAddress, level, 0, false);
      }

      address ref = userMatrix[referrerAddress][level].currentReferrer;      
      userMatrix[ref][level].secondLevelReferrals.push(userAddress); 

      uint256 len = userMatrix[ref][level].firstLevelReferrals.length;

      if ((len == 2) && 
        (userMatrix[ref][level].firstLevelReferrals[0] == referrerAddress) &&
        (userMatrix[ref][level].firstLevelReferrals[1] == referrerAddress)) {
        if (userMatrix[referrerAddress][level].firstLevelReferrals.length == 1) {
          newUserPlace(userAddress, ref, users[userAddress].referrer, level, 5);
        } else {
          newUserPlace(userAddress, ref, users[userAddress].referrer, level, 6);
        }
      }  else if ((len == 1 || len == 2) &&
          userMatrix[ref][level].firstLevelReferrals[0] == referrerAddress) {
        if (userMatrix[referrerAddress][level].firstLevelReferrals.length == 1) {
          newUserPlace(userAddress, ref, users[userAddress].referrer, level, 3);
        } else {
          newUserPlace(userAddress, ref, users[userAddress].referrer, level, 4);
        }
      } else if (len == 2 && userMatrix[ref][level].firstLevelReferrals[1] == referrerAddress) {
        if (userMatrix[referrerAddress][level].firstLevelReferrals.length == 1) {
          newUserPlace(userAddress, ref, users[userAddress].referrer, level, 5);
        } else {
          newUserPlace(userAddress, ref, users[userAddress].referrer, level, 6);
        }
      }

      return updateMatrixReferrerSecondLevel(userAddress, ref, level);
    }

    userMatrix[referrerAddress][level].secondLevelReferrals.push(userAddress);

    if (userMatrix[referrerAddress][level].closedPart != address(0)) {
      if ((userMatrix[referrerAddress][level].firstLevelReferrals[0] == 
        userMatrix[referrerAddress][level].firstLevelReferrals[1]) &&
        (userMatrix[referrerAddress][level].firstLevelReferrals[0] ==
        userMatrix[referrerAddress][level].closedPart)) {

        updateMatrix(userAddress, referrerAddress, level, true);
        return updateMatrixReferrerSecondLevel(userAddress, referrerAddress, level);
      } else if (userMatrix[referrerAddress][level].firstLevelReferrals[0] == 
        userMatrix[referrerAddress][level].closedPart) {
        updateMatrix(userAddress, referrerAddress, level, true);
        return updateMatrixReferrerSecondLevel(userAddress, referrerAddress, level);
      } else {
        updateMatrix(userAddress, referrerAddress, level, false);
        return updateMatrixReferrerSecondLevel(userAddress, referrerAddress, level);
      }
    }

    if (userMatrix[referrerAddress][level].firstLevelReferrals[1] == userAddress) {
      updateMatrix(userAddress, referrerAddress, level, false);
      return updateMatrixReferrerSecondLevel(userAddress, referrerAddress, level);
    } else if (userMatrix[referrerAddress][level].firstLevelReferrals[0] == userAddress) {
      updateMatrix(userAddress, referrerAddress, level, true);
      return updateMatrixReferrerSecondLevel(userAddress, referrerAddress, level);
    }

    if (userMatrix[userMatrix[referrerAddress][level].firstLevelReferrals[0]][level].firstLevelReferrals.length <= 
      userMatrix[userMatrix[referrerAddress][level].firstLevelReferrals[1]][level].firstLevelReferrals.length) {
      updateMatrix(userAddress, referrerAddress, level, false);
    } else {
      updateMatrix(userAddress, referrerAddress, level, true);
    }

    updateMatrixReferrerSecondLevel(userAddress, referrerAddress, level);
  }

  function updateMatrix(address userAddress, address referrerAddress, uint8 level, bool x2) private {
    if (!x2) {
      userMatrix[userMatrix[referrerAddress][level].firstLevelReferrals[0]][level].firstLevelReferrals.push(userAddress);
      newUserPlace(userAddress, userMatrix[referrerAddress][level].firstLevelReferrals[0], users[userAddress].referrer, level, uint8(userMatrix[userMatrix[referrerAddress][level].firstLevelReferrals[0]][level].firstLevelReferrals.length));
      newUserPlace(userAddress, referrerAddress, users[userAddress].referrer, level, 2 + uint8(userMatrix[userMatrix[referrerAddress][level].firstLevelReferrals[0]][level].firstLevelReferrals.length));
      
      userMatrix[userAddress][level].currentReferrer = userMatrix[referrerAddress][level].firstLevelReferrals[0];
    } else {
      userMatrix[userMatrix[referrerAddress][level].firstLevelReferrals[1]][level].firstLevelReferrals.push(userAddress);
      newUserPlace(userAddress, userMatrix[referrerAddress][level].firstLevelReferrals[1], users[userAddress].referrer, level, uint8(userMatrix[userMatrix[referrerAddress][level].firstLevelReferrals[1]][level].firstLevelReferrals.length));
      newUserPlace(userAddress, referrerAddress, users[userAddress].referrer, level, 4 + uint8(userMatrix[userMatrix[referrerAddress][level].firstLevelReferrals[1]][level].firstLevelReferrals.length));
      
      userMatrix[userAddress][level].currentReferrer = userMatrix[referrerAddress][level].firstLevelReferrals[1];
    }
  }

  function updateMatrixReferrerSecondLevel(address userAddress, address referrerAddress, uint8 level) private {
    if (userMatrix[referrerAddress][level].secondLevelReferrals.length < 4) {
      
      return;
    }

    uint256 passiveIncomeReceived = 0;
    if (userMatrix[referrerAddress][level].reinvestCount == 0) {
      withdrawPassiveIncome(referrerAddress, level);
      passiveIncomeReceived = userMatrix[referrerAddress][level].passiveIncomeReceived;
    }

    if (!users[referrerAddress].autoReinvest || level == LAST_LEVEL) {
      userMatrix[referrerAddress][level].blocked = false;
      sendBNBDividends(referrerAddress, userAddress, level, passiveIncomeReceived, true);
    } else if (userActiveMatrixLevels[referrerAddress][level + 1]) {
      userMatrix[referrerAddress][level].blocked = false;
      sendBNBDividends(referrerAddress, userAddress, level, passiveIncomeReceived, true);
    } else { 
      
      
      if (level < LAST_LEVEL 
       && !userActiveMatrixLevels[referrerAddress][level + 1] 
       && passiveIncomeReceived == 0) { 
        if (userMatrix[referrerAddress][level].blocked) {
          userMatrix[referrerAddress][level].blocked = false;
        }

        address freeMatrixReferrer = findFreeMatrixReferrer(referrerAddress, level + 1);
        
        
        userActiveMatrixLevels[referrerAddress][level + 1] = true;
        userMatrix[referrerAddress][level + 1].time = block.timestamp;
        updateMatrixReferrer(referrerAddress, freeMatrixReferrer, level + 1);

        emit Upgrade(referrerAddress, freeMatrixReferrer, level + 1, uniqueIndex++, block.timestamp);
      } else {
        sendBNBDividends(referrerAddress, userAddress, level, passiveIncomeReceived, true);
      }
    }

    address[] memory x6 = userMatrix[userMatrix[referrerAddress][level].currentReferrer][level].firstLevelReferrals;

    if (x6.length == 2) {
      if (x6[0] == referrerAddress ||
        x6[1] == referrerAddress) {
        userMatrix[userMatrix[referrerAddress][level].currentReferrer][level].closedPart = referrerAddress;
      } else if (x6.length == 1) {
        if (x6[0] == referrerAddress) {
          userMatrix[userMatrix[referrerAddress][level].currentReferrer][level].closedPart = referrerAddress;
        }
      }
    }

    userMatrix[referrerAddress][level].firstLevelReferrals = new address[](0);
    userMatrix[referrerAddress][level].secondLevelReferrals = new address[](0);
    userMatrix[referrerAddress][level].closedPart = address(0);

    if (!userActiveMatrixLevels[referrerAddress][level+1] && level != LAST_LEVEL) {
      userMatrix[referrerAddress][level].blocked = true;
    }

    userMatrix[referrerAddress][level].reinvestCount++;
    emit MatrixClosed(referrerAddress, level, userMatrix[referrerAddress][level].reinvestCount, uniqueIndex++, block.timestamp);
    
    if (referrerAddress != owner()) {
      address freeReferrerAddress = findFreeMatrixReferrer(referrerAddress, level);

      emit Reinvest(referrerAddress, freeReferrerAddress, userAddress, level, uniqueIndex++, block.timestamp);
      updateMatrixReferrer(referrerAddress, freeReferrerAddress, level);
    } else {
      emit Reinvest(owner(), address(0), userAddress, level, uniqueIndex++, block.timestamp);
      sendBNBDividends(owner(), userAddress, level, 0, false);
    }
  }
  
  function findFreeMatrixReferrer(address userAddress, uint8 level) public view returns(address) {
    while (true) { 
      if (userActiveMatrixLevels[users[userAddress].referrer][level]) {
        return users[userAddress].referrer;
      }

      userAddress = users[userAddress].referrer;

      if (userAddress == address(0x0)) {
        return owner(); 
      }
    }

    return owner(); 
  }

  function buyGoldMatrix() external {
    require(isUserExists(msg.sender), "05");
    require(userActiveMatrixLevels[msg.sender][0] == false, "09");
    require(
      IERC20(BUSD_TOKEN_CONTRACT_ADDRESS).transferFrom(msg.sender, address(this), GOLD_MATRIX_PRICE),
      "02"
    );

    address freeMatrixReferrer = findFreeGoldMatrixReferrer(msg.sender);

    updateGoldMatrixReferrer(msg.sender, freeMatrixReferrer);

    userActiveMatrixLevels[msg.sender][0] = true;

    emit Upgrade(msg.sender, freeMatrixReferrer, 0, uniqueIndex++, block.timestamp); 
  }

  function updateGoldMatrixReferrer(address userAddress, address referrerAddress) private {
    require(userActiveMatrixLevels[referrerAddress][0], "10");

    if (goldMatrix[referrerAddress].firstLevelReferrals.length < 2) {
      goldMatrix[referrerAddress].firstLevelReferrals.push(userAddress);
      newUserPlace(userAddress, referrerAddress, users[userAddress].referrer, 0, uint8(goldMatrix[referrerAddress].firstLevelReferrals.length));

      
      goldMatrix[userAddress].currentReferrer = referrerAddress;

      if (referrerAddress == owner()) {
        return sendGoldMatrixBNBDividends(referrerAddress, userAddress);
      }

      address ref = goldMatrix[referrerAddress].currentReferrer;      
      goldMatrix[ref].secondLevelReferrals.push(userAddress); 

      uint256 len = goldMatrix[ref].firstLevelReferrals.length;

      if ((len == 2) && 
        (goldMatrix[ref].firstLevelReferrals[0] == referrerAddress) &&
        (goldMatrix[ref].firstLevelReferrals[1] == referrerAddress)) {
        if (goldMatrix[referrerAddress].firstLevelReferrals.length == 1) {
          newUserPlace(userAddress, ref, users[userAddress].referrer, 0, 5);
        } else {
          newUserPlace(userAddress, ref, users[userAddress].referrer, 0, 6);
        }
      }  else if ((len == 1 || len == 2) &&
          goldMatrix[ref].firstLevelReferrals[0] == referrerAddress) {
        if (goldMatrix[referrerAddress].firstLevelReferrals.length == 1) {
          newUserPlace(userAddress, ref, users[userAddress].referrer, 0, 3);
        } else {
          newUserPlace(userAddress, ref, users[userAddress].referrer, 0, 4);
        }
      } else if (len == 2 && goldMatrix[ref].firstLevelReferrals[1] == referrerAddress) {
        if (goldMatrix[referrerAddress].firstLevelReferrals.length == 1) {
          newUserPlace(userAddress, ref, users[userAddress].referrer, 0, 5);
        } else {
          newUserPlace(userAddress, ref, users[userAddress].referrer, 0, 6);
        }
      }

      return updateGoldMatrixReferrerSecondLevel(userAddress, ref);
    }

    goldMatrix[referrerAddress].secondLevelReferrals.push(userAddress);

    if (goldMatrix[referrerAddress].closedPart != address(0)) {
      if ((goldMatrix[referrerAddress].firstLevelReferrals[0] == 
        goldMatrix[referrerAddress].firstLevelReferrals[1]) &&
        (goldMatrix[referrerAddress].firstLevelReferrals[0] ==
        goldMatrix[referrerAddress].closedPart)) {

        updateGoldMatrix(userAddress, referrerAddress, true);
        return updateGoldMatrixReferrerSecondLevel(userAddress, referrerAddress);
      } else if (goldMatrix[referrerAddress].firstLevelReferrals[0] == 
        goldMatrix[referrerAddress].closedPart) {
        updateGoldMatrix(userAddress, referrerAddress, true);
        return updateGoldMatrixReferrerSecondLevel(userAddress, referrerAddress);
      } else {
        updateGoldMatrix(userAddress, referrerAddress, false);
        return updateGoldMatrixReferrerSecondLevel(userAddress, referrerAddress);
      }
    }

    if (goldMatrix[referrerAddress].firstLevelReferrals[1] == userAddress) {
      updateGoldMatrix(userAddress, referrerAddress, false);
      return updateGoldMatrixReferrerSecondLevel(userAddress, referrerAddress);
    } else if (goldMatrix[referrerAddress].firstLevelReferrals[0] == userAddress) {
      updateGoldMatrix(userAddress, referrerAddress, true);
      return updateGoldMatrixReferrerSecondLevel(userAddress, referrerAddress);
    }

    if (goldMatrix[goldMatrix[referrerAddress].firstLevelReferrals[0]].firstLevelReferrals.length <= 
      goldMatrix[goldMatrix[referrerAddress].firstLevelReferrals[1]].firstLevelReferrals.length) {
      updateGoldMatrix(userAddress, referrerAddress, false);
    } else {
      updateGoldMatrix(userAddress, referrerAddress, true);
    }

    updateGoldMatrixReferrerSecondLevel(userAddress, referrerAddress);
  }

  function updateGoldMatrix(address userAddress, address referrerAddress, bool x2) private {
    if (!x2) {
      goldMatrix[goldMatrix[referrerAddress].firstLevelReferrals[0]].firstLevelReferrals.push(userAddress);
      newUserPlace(userAddress, goldMatrix[referrerAddress].firstLevelReferrals[0], users[userAddress].referrer, 0, uint8(goldMatrix[goldMatrix[referrerAddress].firstLevelReferrals[0]].firstLevelReferrals.length));
      newUserPlace(userAddress, referrerAddress, users[userAddress].referrer, 0, 2 + uint8(goldMatrix[goldMatrix[referrerAddress].firstLevelReferrals[0]].firstLevelReferrals.length));
      
      goldMatrix[userAddress].currentReferrer = goldMatrix[referrerAddress].firstLevelReferrals[0];
    } else {
      goldMatrix[goldMatrix[referrerAddress].firstLevelReferrals[1]].firstLevelReferrals.push(userAddress);
      newUserPlace(userAddress, goldMatrix[referrerAddress].firstLevelReferrals[1], users[userAddress].referrer, 0, uint8(goldMatrix[goldMatrix[referrerAddress].firstLevelReferrals[1]].firstLevelReferrals.length));
      newUserPlace(userAddress, referrerAddress, users[userAddress].referrer, 0, 4 + uint8(goldMatrix[goldMatrix[referrerAddress].firstLevelReferrals[1]].firstLevelReferrals.length));
      
      goldMatrix[userAddress].currentReferrer = goldMatrix[referrerAddress].firstLevelReferrals[1];
    }
  }

  function updateGoldMatrixReferrerSecondLevel(address userAddress, address referrerAddress) private {
    if (goldMatrix[referrerAddress].secondLevelReferrals.length == 1) {
      pendingPayments[referrerAddress] = pendingPayments[referrerAddress].add(goldMatrixRewardTokensAmount);
      users[referrerAddress].tokensReceived = users[referrerAddress].tokensReceived.add(goldMatrixRewardTokensAmount);
      emit PendingPaymentHold(referrerAddress, goldMatrixRewardTokensAmount, uniqueIndex++, block.timestamp);

      return sendGoldMatrixBNBDividends(ADMIN_ADDRESS, userAddress);
    } else if (goldMatrix[referrerAddress].secondLevelReferrals.length < 4) {
      if (Address.isContract(stakingContractAddress)) {
        CommonInterface(tokenContractAddress).transfer(stakingContractAddress, goldMatrixRewardTokensAmount);
        CommonInterface(stakingContractAddress).stake(referrerAddress, goldMatrixRewardTokensAmount, users[referrerAddress].stakeTypeIdx);
        emit SentRewardTokens(referrerAddress, stakingContractAddress, goldMatrixRewardTokensAmount, false, uniqueIndex++, block.timestamp);
      } else {
        CommonInterface(tokenContractAddress).transfer(referrerAddress, goldMatrixRewardTokensAmount);
        emit SentRewardTokens(referrerAddress, referrerAddress, goldMatrixRewardTokensAmount, true, uniqueIndex++, block.timestamp);
      }
      users[referrerAddress].tokensReceived = users[referrerAddress].tokensReceived.add(goldMatrixRewardTokensAmount);

      return sendGoldMatrixBNBDividends(ADMIN_ADDRESS, userAddress);
    }

    address[] memory x6 = goldMatrix[goldMatrix[referrerAddress].currentReferrer].firstLevelReferrals;

    if (x6.length == 2) {
      if (x6[0] == referrerAddress ||
        x6[1] == referrerAddress) {
        goldMatrix[goldMatrix[referrerAddress].currentReferrer].closedPart = referrerAddress;
      } else if (x6.length == 1) {
        if (x6[0] == referrerAddress) {
          goldMatrix[goldMatrix[referrerAddress].currentReferrer].closedPart = referrerAddress;
        }
      }
    }

    goldMatrix[referrerAddress].firstLevelReferrals = new address[](0);
    goldMatrix[referrerAddress].secondLevelReferrals = new address[](0);
    goldMatrix[referrerAddress].closedPart = address(0);

    goldMatrix[referrerAddress].reinvestCount++;
    emit MatrixClosed(referrerAddress, 0, goldMatrix[referrerAddress].reinvestCount, uniqueIndex++, block.timestamp);

    emit Reinvest(ADMIN_ADDRESS, address(0), userAddress, 0, uniqueIndex++, block.timestamp);
    sendGoldMatrixBNBDividends(ADMIN_ADDRESS, userAddress);
  }

  function findFreeGoldMatrixReferrer(address userAddress) public view returns(address) {
    while (true) { 
      if (userActiveMatrixLevels[users[userAddress].referrer][0]) {
        return users[userAddress].referrer;
      }

      userAddress = users[userAddress].referrer;

      if (userAddress == address(0x0)) {
        return owner(); 
      }
    }

    return owner();
  }

  function usersActiveMatrixLevels(address userAddress, uint8 level) public view returns(bool) {
    return userActiveMatrixLevels[userAddress][level];
  }

  function usersMatrix(address userAddress, uint8 level) public view
    returns(
      address, address[] memory, address[] memory, bool, address, bool
    )
  {
    return (
      userMatrix[userAddress][level].currentReferrer,
      userMatrix[userAddress][level].firstLevelReferrals,
      userMatrix[userAddress][level].secondLevelReferrals,
      userMatrix[userAddress][level].blocked,
      userMatrix[userAddress][level].closedPart,
      userActiveMatrixLevels[userAddress][level]
    );
  }

  function getMatrixDetails(address userAddress, uint8 level) public view
    returns(
      uint256
    )
  {
    return (
      userMatrix[userAddress][level].reinvestCount
    );
  }

  function getMatrixesStatus(address userAddress) public view 
    returns(
      bool[13] memory status
    )
  {
    for (uint8 i = 0; i < 13; i++){
      status[i] = userActiveMatrixLevels[userAddress][i];
    }
  }

  function goldMatrixData(address userAddress) public view
    returns(
      address, address[] memory, address[] memory, bool, address, uint256
    )
  {
    return (
      goldMatrix[userAddress].currentReferrer,
      goldMatrix[userAddress].firstLevelReferrals,
      goldMatrix[userAddress].secondLevelReferrals,
      goldMatrix[userAddress].blocked,
      goldMatrix[userAddress].closedPart,
      goldMatrix[userAddress].time
    );
  }

  function isUserExists(address user) public view returns (bool) {
    return (users[user].id != 0);
  }

  function findBNBReceiver(address userAddress, address _from, uint8 level) private returns(address, bool) {
    address receiver = userAddress;
    bool isExtraDividends;
    while (true) { 
      if (userMatrix[receiver][level].blocked) {
        emit MissedBNBReceive(receiver, _from, level, uniqueIndex++, block.timestamp);
        isExtraDividends = true;
        receiver = userMatrix[receiver][level].currentReferrer;

        if (receiver == address(0x0)) {
          return (owner() , isExtraDividends);
        }
      } else {
        return (receiver, isExtraDividends);
      }
    }

    return (owner() , isExtraDividends);
  }

  function sendBNBDividends(address userAddress, address _from, uint8 level, uint256 passiveIncome, bool isNextLevel) private {
    (address receiver, bool isExtraDividends) = findBNBReceiver(userAddress, _from, level);

    uint256 amount = levelPrice[level];
    if (isNextLevel) {
      amount = amount.mul(2);
    }
    if (passiveIncome > 0) {
      if (amount > passiveIncome) {
        amount = amount.sub(passiveIncome);
      } else {
        amount = 0;
      }
    }

    if (amount > 0) {
      if (!IERC20(BUSD_TOKEN_CONTRACT_ADDRESS).transfer(receiver, amount)) {
        revert("00");
      }
    }
    emit SentBNBDividends(_from, receiver, level, amount, uniqueIndex++, block.timestamp);
    
    if (isExtraDividends) {
      emit SentExtraBNBDividends(_from, receiver, level, uniqueIndex++, block.timestamp);
    }
  }

  function findGoldMatrixBNBReceiver(address userAddress, address _from) private returns(address, bool) {
    address receiver = userAddress;
    bool isExtraDividends;
    while (true) { 
      if (goldMatrix[receiver].blocked) {
        emit MissedBNBReceive(receiver, _from, 0, uniqueIndex++, block.timestamp);
        isExtraDividends = true;
        receiver = goldMatrix[receiver].currentReferrer;

        if (receiver == address(0x0)) {
          return (owner() , isExtraDividends);
        }
      } else {
        return (receiver, isExtraDividends);
      }
    }

    return (owner() , isExtraDividends);
  }

  function sendGoldMatrixBNBDividends(address userAddress, address _from) private {
    (address receiver, bool isExtraDividends) = findGoldMatrixBNBReceiver(userAddress, _from);

    if (!IERC20(BUSD_TOKEN_CONTRACT_ADDRESS).transfer(receiver, GOLD_MATRIX_PRICE)) {
      revert("00");
    }
    emit SentBNBDividends(_from, receiver, 0, GOLD_MATRIX_PRICE, uniqueIndex++, block.timestamp);
    
    if (isExtraDividends) {
      emit SentExtraBNBDividends(_from, receiver, 0, uniqueIndex++, block.timestamp);
    }
  }

  
  function setAutoReinvest(bool _flag) public returns (bool) {
    if (users[msg.sender].autoReinvest != _flag) {
      users[msg.sender].autoReinvest = _flag;

      emit AutoReinvestFlagSwitch(msg.sender, _flag, block.timestamp);

      return true;
    }

    return false;
  }

  function getPassiveIncome(address userAddress, uint8 level) public view returns (uint256) {
    if (!userActiveMatrixLevels[userAddress][level]) {
      return 0;
    }

    if (userMatrix[userAddress][level].reinvestCount > 0) {
      return 0;
    }

    if (userMatrix[userAddress][level].time == 0) {
      return 0;
    }

    uint256 income = levelPrice[level]
      .mul(
        block.timestamp.sub(userMatrix[userAddress][level].time)
      )
      .mul(passiveIncomeDailyPercent(userAddress, level))
      .div(10000)
      .div(1 days);

    uint256 incomeLimit = (levelPrice[level].mul(PASSIVE_INCOME_MAX_PROFIT_PERCENT).div(100))
      .sub(userMatrix[userAddress][level].passiveIncomeReceived);
    if (income > incomeLimit) {
      income = incomeLimit;
    }

    return income;
  }

  function getPassiveIncomes(address userAddress) public view returns (uint256[13] memory incomes, uint256[13] memory incomesReceived, uint256[13] memory dailyPercents) {
    for (uint8 level = 1; level <= LAST_LEVEL; level++) {
      dailyPercents[level] = passiveIncomeDailyPercent(userAddress, level);
      incomesReceived[level] = userMatrix[userAddress][level].passiveIncomeReceived;

      incomes[level] = getPassiveIncome(userAddress, level);
    }

    return (incomes, incomesReceived, dailyPercents);
  }

  function withdrawPassiveIncome(address userAddress) private returns (uint256, uint256[13] memory) {
    uint256[13] memory incomes;
    uint256 income = 0;

    (incomes, ,) = getPassiveIncomes(userAddress);

    for (uint8 level = 1; level <= LAST_LEVEL; level++) {
      if (incomes[level] > 0) {
        userMatrix[userAddress][level].time = block.timestamp;
        userMatrix[userAddress][level].passiveIncomeReceived = userMatrix[userAddress][level].passiveIncomeReceived.add(incomes[level]);

        emit PassiveIncomeWithdrawn(userAddress, level, incomes[level], uniqueIndex++, block.timestamp);

        income = income.add(incomes[level]);
      }

      if (userMatrix[userAddress][level].time == 0) {
        userMatrix[userAddress][level].time = block.timestamp;
      }
    }

    if (income == 0) {
      return (0, incomes);
    }

    if (!IERC20(BUSD_TOKEN_CONTRACT_ADDRESS).transfer(userAddress, income)) {
      revert("00");
    }

    return (income, incomes);
  }

  function withdrawPassiveIncome(address userAddress, uint8 level) private returns (uint256) {
    uint256 income = getPassiveIncome(userAddress, level);

    if (userMatrix[userAddress][level].time == 0) {
      userMatrix[userAddress][level].time = block.timestamp;
    }

    if (income == 0) {
      return 0;
    }

    userMatrix[userAddress][level].time = block.timestamp;
    userMatrix[userAddress][level].passiveIncomeReceived = userMatrix[userAddress][level].passiveIncomeReceived.add(income);

    if (!IERC20(BUSD_TOKEN_CONTRACT_ADDRESS).transfer(userAddress, income)) {
      revert("00");
    }
    emit PassiveIncomeWithdrawn(userAddress, level, income, uniqueIndex++, block.timestamp);

    return income;
  }

  function withdrawPassiveIncome() public returns (uint256, uint256[13] memory) {
    return withdrawPassiveIncome(msg.sender);
  }

  function passiveIncomeDailyPercent(address userAddress, uint8 matrixLevel) private view returns (uint256) {
    if (matrixReferralsCount[userAddress][matrixLevel] > 1) {
      return PASSIVE_INCOME_DAILY_PERCENT;
    } else if (matrixReferralsCount[userAddress][matrixLevel] == 1) {
      return PASSIVE_INCOME_DAILY_PERCENT_ONE_REFERRAL;
    }

    return PASSIVE_INCOME_DAILY_PERCENT_NO_REFERRALS;
  }

  function setGoldMatrixRewardTokensAmount(uint256 _amount) external onlyAutoStartOracle {
    goldMatrixRewardTokensAmount = _amount.mul(10**18);
  }

  function setStakingContractAddress(address contractAddress) external onlyOwner {
    require(Address.isContract(contractAddress), "11");

    stakingContractAddress = contractAddress;
  }

  

  modifier onlyAutoStartOracle() {
    require(
      msg.sender == AUTOSTART_ORACLE_ADDRESS,
      "12"
    );
    _;
  }

  function changeAutoStartOracleAddress(address newOracleAddress) external onlyOwner {
    require(newOracleAddress != address(0x0), "13");
    require(newOracleAddress != AUTOSTART_ORACLE_ADDRESS, "14");

    AUTOSTART_ORACLE_ADDRESS = newOracleAddress;
  }

  function setAutoStartProgramStatus(address userAddress, AutoStart status) external onlyAutoStartOracle {
    require(userAddress != address(0x0), "15");

    autoStartProgram[userAddress] = status;
    emit AutoStartStatusChanged(userAddress, status, uniqueIndex++, block.timestamp);
  }

  function userAutoStartQualificationStatus(address userAddress) external view returns (AutoStart) {
    return autoStartProgram[userAddress];
  }

  function claimPendingPayment() external {
    require(
         autoStartProgram[msg.sender] == AutoStart.UNREGISTERED
      || autoStartProgram[msg.sender] == AutoStart.QUALIFIED,
      "16"
    );
    require(pendingPayments[msg.sender] > 0, "17");

    uint256 amount = pendingPayments[msg.sender];
    pendingPayments[msg.sender] = 0;

    CommonInterface(tokenContractAddress).transfer(msg.sender, amount);
    emit SentRewardTokens(msg.sender, msg.sender, amount, false, uniqueIndex++, block.timestamp);
  }

  

  function changeStakeType(uint8 stakeTypeIdx) external {
    require(stakeTypeIdx < STAKE_TYPES_COUNT, "18");

    users[msg.sender].stakeTypeIdx = stakeTypeIdx;
  }

  function tokensReceived(address userAddress) external view returns (uint256) {
    return users[userAddress].tokensReceived
      .add(CommonInterface(stakingContractAddress).tokensReceived(userAddress));
  }

  function connectTelegramId(uint32 telegramId) external {
    telegramIds[msg.sender] = telegramId;

    emit TelegramIdSetted(msg.sender, telegramId, uniqueIndex++, block.timestamp);
  }

  function getUserReferrer(address userAddress) external view returns (address) {
    return users[userAddress].referrer;
  }

}