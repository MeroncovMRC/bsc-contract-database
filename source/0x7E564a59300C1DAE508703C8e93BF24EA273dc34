
// File: ./contracts/Wormoon.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import "./libs/Address.sol";
import "./abstracts/BEP20WithBotProtection.sol";
import "./interfaces/IUniswapV2Factory.sol";
import "./interfaces/IUniswapV2Router02.sol";

contract Wormoon is BEP20WithBotProtection("Worminator v2 Protocol", "WRMNTOR") {
    using Address for address;

    address public WETHPair;

    constructor(address router) public {
        if (router != address(0)) {
            swapRouter = router;
            WETHPair = _createPair(router, IUniswapV2Router02(router).WETH());
        }

        _addSystemAddress(address(this));
        _addSystemAddress(_msgSender());
        _addSystemAddress(teamWallet);
        _addSystemAddress(farmVault);
        _addSystemAddress(rewardsVault);

        // minting 1b to the owner
        _mint(_msgSender(), 1_000_000_000e18);
    }

    receive() external payable {}

    function _createPair(address router, address token1) private returns (address) {
        address pair = IUniswapV2Factory(IUniswapV2Router02(router).factory()).createPair(address(this), token1);
        _addPairToTrack(pair);
        rewardsExcluded[pair] = true;
        _addSystemAddress(getPairVault(pair));
        return pair;
    }

    // --==[ Public functions ]==--
    function addPairToTrack(address pair) external onlyOwner {
        _addPairToTrack(pair);
        rewardsExcluded[pair] = true;
        _addSystemAddress(getPairVault(pair));
    }

    function setFarmVault(address vault) external onlyOwner {
        require(vault != address(0), "Farm vault can't be zero address");
        _addSystemAddress(vault);
        farmVault = vault;
    }

    function addSystemAddress(address system_address) external onlyOwner {
        _addSystemAddress(system_address);
    }

    function withdrawGarbageTokens(address receiver, address tokenAddress) external onlyOwner {
        require(tokenAddress != address(0), "Wormoon: token address is zero");
        require(IBEP20(tokenAddress).balanceOf(address(this)) > 0, "Wormoon: garbage token balance is 0");

        uint256 balance = IBEP20(tokenAddress).balanceOf(address(this));
        IBEP20(tokenAddress).transfer(receiver, balance);
    }

    function _addSystemAddress(address system_address) private {
        transferWhitelist[system_address] = true;
        botWhitelist[system_address] = true;
        rewardsExcluded[system_address] = true;
        setTaxless(system_address, true);
    }

    function burn(uint256 amount) external {
        _burn(_msgSender(), amount);
    }

    function burnFrom(address account, uint256 amount) external {
        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(
            amount, "BEP20: burn amount exceeds allowance"
        );

        _approve(account, _msgSender(), decreasedAllowance);
        _burn(account, amount);
    }
}


// File: ./contracts/libs/Address.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.

        uint256 size;
        // solhint-disable-next-line no-inline-assembly
        assembly { size := extcodesize(account) }
        return size > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * // solhint-disable-next-line
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects\
     * -interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value
        (bool success, ) = recipient.call{ value: amount }("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain`call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html\
     * ?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
      return functionCall(target, data, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data, string memory errorMessage)
    internal returns (bytes memory)
    {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage)
    internal returns (bytes memory)
    {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.call{ value: value }(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data)
    internal view returns (bytes memory)
    {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data, string memory errorMessage)
    internal view returns (bytes memory)
    {
        require(isContract(target), "Address: static call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.staticcall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage)
    private pure returns(bytes memory)
    {
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length > 0) {
                // The easiest way to bubble the revert reason is using memory via assembly

                // solhint-disable-next-line no-inline-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

// File: ./contracts/abstracts/BEP20WithBotProtection.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import "../libs/SafeMath.sol";
import "./BEP20WithTransferLock.sol";
import "../interfaces/IHoneyBotV0Token.sol";

abstract contract BEP20WithBotProtection is BEP20WithTransferLock, IHoneyBotV0Token {
    using SafeMath for uint256;

    // --==[ FEES ]==--
    // Fees numbers are multiplied by 100
    uint256 public botBuyFee = 2500; // 25% - to lure bots
    uint256 public botSellFee = 3500; // 35% - almost max slippage

    uint256 public botTokenHoldersPart = 5000; // 50%
    uint256 public botLpPart = 1500; // 15%
    uint256 public botBurnPart = 500; // 5%
    uint256 public botProjectPart = 3000; // 30%

    // --==[ WALLETS ]==--
    address public botLaunchpad;
    mapping(address => bool) public botWhitelist;
    mapping(address => bool) public botBlacklist;

    // --==[ PROTECTION ]==--
    bool public botProtectionIsActive = false;
    uint256 public botProtectionEndBlock = 0;
    address[] public bots;

    // --==[ Events ]==--
    event BotDetected(address indexed bot);

    modifier onlyLaunchpad() {
        require(botLaunchpad == _msgSender(), "BEP20WithBotProtection: only launchpad can call this function");
        _;
    }

    constructor(string memory name, string memory symbol) BEP20WithTransferLock(name, symbol) internal {
        botWhitelist[_msgSender()] = true;
    }

    function prepareForInitialLiquidity() external override onlyLaunchpad {
        isTransferLocked = false;
    }

    function warmupBotProtection(uint256 firewallBlockLength) external override onlyLaunchpad {
        require(!botProtectionIsActive, "BEP20WithBotProtection: bot protection is active");
        require(firewallBlockLength <= 50, "BEP20WithBotProtection: bot firewall is too long");
        _startBotProtection(firewallBlockLength);
    }

    function setBotFees(uint256 buyFee, uint256 sellFee) external onlyOwner {
        require(buyFee <= 10000, "BEP20WithBotProtection: buy fee is too high");
        require(sellFee <= 10000, "BEP20WithBotProtection: sell fee is too high");
        botBuyFee = buyFee;
        botSellFee = sellFee;
    }

    function setBotLaunchpad(address launchpad) external onlyOwner {
        require(botLaunchpad != launchpad, "BEP20WithBotProtection: launchpad is the same");
        botLaunchpad = launchpad;
    }

    function setBotWhitelist(address account, bool isWhitelisted) external onlyOwner {
        botWhitelist[account] = isWhitelisted;
        if (isWhitelisted) {
            botBlacklist[account] = false;
        }
    }

    function setBotBlacklist(address account, bool isBlacklisted) external onlyOwner {
        if (isBlacklisted) {
            _addToBotList(account);
        } else {
            botBlacklist[account] = false;
        }
    }

    function startBotProtection(uint256 firewallBlockLength) external onlyOwner {
        _startBotProtection(firewallBlockLength);
    }

    function haltBotProtection() external onlyOwner {
        botProtectionIsActive = false;
        botProtectionEndBlock = 0;
    }

    function _startBotProtection(uint256 firewallBlockLength) private {
        botProtectionIsActive = true;
        botProtectionEndBlock = block.number.add(firewallBlockLength);
    }

    // --==[ Overridden methods ]==--
    function _transfer(address from, address to, uint256 amount) override botProtected(from, to) internal {
        super._transfer(from, to, amount);
    }

    modifier botProtected(address from, address to) {
        bool isBotTransfer = isPotentialBot(from) || isPotentialBot(to);

        if (isBotTransfer) {
            require(isPair(from) || isPair(to), "BEP20WithBotProtection: Bots are only allowed to trade.");
            setBotFees();
        }

        _;
        if (isBotTransfer) restoreBotFees();
    }

    function isPotentialBot(address account) internal returns (bool) {
        if (!botProtectionIsActive) return false;
        if (isPair(account)) return false;
        if (botWhitelist[account]) return false;

        if (botProtectionEndBlock >= block.number) {
            _addToBotList(account);
        }

        return botBlacklist[account];
    }

    function _addToBotList(address bot) private {
        if (!botBlacklist[bot]) {
            botBlacklist[bot] = true;
            bots.push(bot);
        }

        emit BotDetected(bot);
    }

    uint256 private prevBuyFee;
    uint256 private prevSellFee;

    uint256 private prevTokenHoldersPart;
    uint256 private prevLpPart;
    uint256 private prevBurnPart;
    uint256 private prevProjectPart;

    function setBotFees() private {
        prevBuyFee = buyFee;
        prevSellFee = sellFee;
        prevTokenHoldersPart = tokenHoldersPart;
        prevLpPart = lpPart;
        prevBurnPart = burnPart;
        prevProjectPart = projectPart;

        buyFee = botBuyFee;
        sellFee = botSellFee;
        tokenHoldersPart = botTokenHoldersPart;
        lpPart = botLpPart;
        burnPart = botBurnPart;
        projectPart = botProjectPart;
    }

    function restoreBotFees() private {
        buyFee = prevBuyFee;
        sellFee = prevSellFee;
        tokenHoldersPart = prevTokenHoldersPart;
        lpPart = prevLpPart;
        burnPart = prevBurnPart;
        projectPart = prevProjectPart;
    }
}


// File: ./contracts/libs/SafeMath.sol
// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */
library SafeMath {
  /**
   * @dev Returns the addition of two unsigned integers, reverting on
   * overflow.
   *
   * Counterpart to Solidity's `+` operator.
   *
   * Requirements:
   * - Addition cannot overflow.
   */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a, "SafeMath: addition overflow");

    return c;
  }

  /**
   * @dev Returns the subtraction of two unsigned integers, reverting on
   * overflow (when the result is negative).
   *
   * Counterpart to Solidity's `-` operator.
   *
   * Requirements:
   * - Subtraction cannot overflow.
   */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    return sub(a, b, "SafeMath: subtraction overflow");
  }

  /**
   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
   * overflow (when the result is negative).
   *
   * Counterpart to Solidity's `-` operator.
   *
   * Requirements:
   * - Subtraction cannot overflow.
   */
  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
    require(b <= a, errorMessage);
    uint256 c = a - b;

    return c;
  }

  /**
   * @dev Returns the multiplication of two unsigned integers, reverting on
   * overflow.
   *
   * Counterpart to Solidity's `*` operator.
   *
   * Requirements:
   * - Multiplication cannot overflow.
   */
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
    if (a == 0) {
      return 0;
    }

    uint256 c = a * b;
    require(c / a == b, "SafeMath: multiplication overflow");

    return c;
  }

  /**
   * @dev Returns the integer division of two unsigned integers. Reverts on
   * division by zero. The result is rounded towards zero.
   *
   * Counterpart to Solidity's `/` operator. Note: this function uses a
   * `revert` opcode (which leaves remaining gas untouched) while Solidity
   * uses an invalid opcode to revert (consuming all remaining gas).
   *
   * Requirements:
   * - The divisor cannot be zero.
   */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    return div(a, b, "SafeMath: division by zero");
  }

  /**
   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
   * division by zero. The result is rounded towards zero.
   *
   * Counterpart to Solidity's `/` operator. Note: this function uses a
   * `revert` opcode (which leaves remaining gas untouched) while Solidity
   * uses an invalid opcode to revert (consuming all remaining gas).
   *
   * Requirements:
   * - The divisor cannot be zero.
   */
  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
    // Solidity only automatically asserts when dividing by 0
    require(b > 0, errorMessage);
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold

    return c;
  }

  /**
   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
   * Reverts when dividing by zero.
   *
   * Counterpart to Solidity's `%` operator. This function uses a `revert`
   * opcode (which leaves remaining gas untouched) while Solidity uses an
   * invalid opcode to revert (consuming all remaining gas).
   *
   * Requirements:
   * - The divisor cannot be zero.
   */
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
    return mod(a, b, "SafeMath: modulo by zero");
  }

  /**
   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
   * Reverts with custom message when dividing by zero.
   *
   * Counterpart to Solidity's `%` operator. This function uses a `revert`
   * opcode (which leaves remaining gas untouched) while Solidity uses an
   * invalid opcode to revert (consuming all remaining gas).
   *
   * Requirements:
   * - The divisor cannot be zero.
   */
  function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
    require(b != 0, errorMessage);
    return a % b;
  }
}


// File: ./contracts/abstracts/BEP20WithTransferLock.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import "../libs/SafeMath.sol";
import "./BEP20WithFarmRouter.sol";

abstract contract BEP20WithTransferLock is BEP20WithFarmRouter {
    using SafeMath for uint256;

    bool isTransferLocked = false;

    // --==[ WALLETS ]==--
    mapping(address => bool) public transferWhitelist;

    constructor(string memory name, string memory symbol) BEP20WithFarmRouter(name, symbol) internal {
        transferWhitelist[_msgSender()] = true;
    }

    function setTransferLocked(bool isLocked) external onlyOwner {
        isTransferLocked = isLocked;
    }

    function setTransferWhitelist(address account, bool isWhitelisted) external onlyOwner {
        transferWhitelist[account] = isWhitelisted;
    }

    // --==[ Overridden methods ]==--
    function _transfer(address from, address to, uint256 amount) override internal virtual {
        require(
            !isTransferLocked || transferWhitelist[from] || transferWhitelist[to],
            "BEP20WithTransferLock: transfer is locked"
        );
        super._transfer(from, to, amount);
    }
}


// File: ./contracts/abstracts/BEP20WithFarmRouter.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import "../libs/SafeMath.sol";
import "../libs/SwapUtilities.sol";
import "./BEP20WithFee.sol";

contract FarmVault {
    constructor() public {
    }
}

abstract contract BEP20WithFarmRouter is BEP20WithFee {
    using SafeMath for uint256;

    // --==[ Strategies ]==--
    uint256 private constant FARM_STRATEGY_SELL_DIRECTLY = 1;
    uint256 private constant FARM_STRATEGY_SELL_VIA_CONTRACT = 2;
    uint256 private farm_strategy;

    // --==[ FEES ]==--
    // Fees numbers are multiplied by 100
    uint256 public farmRewardDistribution = 5000; // 50%

    // --==[ WALLETS ]==--
    address public farmSink;
    address public farmVault;

    // --==[ Events ]==--
    event FarmRewarded(uint256 amount, uint256 strategy);

    bool public isFarmSinkActive = true;
    bool public isFarmRewardingActive = true;
    uint256 public farmNumberOfTokensToSell = 8888e18;

    constructor(string memory name, string memory symbol) BEP20WithFee(name, symbol) internal {
        farm_strategy = FARM_STRATEGY_SELL_DIRECTLY;
        farmSink = _msgSender();
        farmVault = address(new FarmVault());
    }

    function setFarmRewardDistribution(uint256 distribution) onlyOwner external {
        require(distribution <= 10000, "BEP20WithFarmRouter: distribution should be less than 100%");
        farmRewardDistribution = distribution;
    }

    function setFarmSink(address destination) onlyOwner external {
        require(destination != address(0), "BEP20WithFarmRouter: farm sink can't be zero address");
        farmSink = destination;
    }

    function setFarmStrategy(uint256 strategy) onlyOwner external {
        farm_strategy = strategy;
    }

    function setFarmSinkActive(bool isActive) onlyOwner external {
        isFarmSinkActive = isActive;
    }

    function setFarmRewardingActive(bool isActive) onlyOwner external {
        isFarmRewardingActive = isActive;
    }

    function setFarmNumberOfTokensToSell(uint256 numberOfTokens) onlyOwner external {
        farmNumberOfTokensToSell = numberOfTokens;
    }

    // --==[ Overridden methods ]==--
    function _transfer(address from, address to, uint256 amount) override internal virtual {
        bool overMinTokenBalance = BEP20.balanceOf(farmVault) >= farmNumberOfTokensToSell;
        bool internalSwap = (from == address(this) && isPair(to)); // don't trigger infinite loop

        if (
            isFarmRewardingActive &&
            !internalSwap &&
            !isPair(from) &&
            overMinTokenBalance &&
            !isLocked()
        ) {
            forwardRewardsToSink(farmNumberOfTokensToSell);
        }
        super._transfer(from, to, amount);
    }

    function addRewards(address from, uint256 amount) override internal {
        uint256 rewardAmount = amount;

        if (isFarmSinkActive) {
            uint256 farmAmount = amount.mul(farmRewardDistribution).div(10000);
            BEP20._transfer(from, farmVault, farmAmount);
            rewardAmount = amount.sub(farmAmount);
        }

        // transfer rewards from payer to contract address
        super.addRewards(from, rewardAmount);
    }

    // for testing purposes
    function triggerForwardRewardsToSink(uint256 amount) external onlyOwner {
        require(BEP20.balanceOf(farmVault) >= amount, "BEP20WithFarmRouter: insufficient vault balance");
        forwardRewardsToSink(amount);
    }

    function forwardRewardsToSink(uint256 amount) private lock {
        if (amount == 0 || farmSink == address(0) || swapRouter == address(0)) return;

        if (farm_strategy == FARM_STRATEGY_SELL_DIRECTLY) {
            farmRouterTransfer1(amount);
        } else if (farm_strategy == FARM_STRATEGY_SELL_VIA_CONTRACT) {
            farmRouterTransfer2(amount);
        }
    }

    function farmRouterTransfer1(uint256 amount) private {
        BEP20._transfer(farmVault, address(this), amount);
        _approve(address(this), swapRouter, amount);

        SwapUtilities.swapTokensForETH(swapRouter, address(this), farmSink, amount, swapRouterSellTimeout);

        emit FarmRewarded(amount, FARM_STRATEGY_SELL_DIRECTLY);
    }

    function farmRouterTransfer2(uint256 amount) private {
        BEP20._transfer(farmVault, address(this), amount);
        _approve(address(this), swapRouter, amount);

        uint256 balanceBeforeSwap = address(this).balance;
        SwapUtilities.swapTokensForETH(swapRouter, address(this), address(this), amount, swapRouterSellTimeout);
        uint256 rewardAmount = address(this).balance.sub(balanceBeforeSwap);

        payable(farmSink).transfer(rewardAmount);

        emit FarmRewarded(amount, FARM_STRATEGY_SELL_VIA_CONTRACT);
    }
}


// File: ./contracts/libs/SwapUtilities.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import "../interfaces/IUniswapV2Pair.sol";
import "../interfaces/IUniswapV2Router02.sol";
import "./SafeMath.sol";

library SwapUtilities {
    using SafeMath for uint256;

    function swapTokensForETH(
        address routerAddress,
        address tokenAddress,
        address receiver,
        uint256 tokenAmount,
        uint256 timeout
    ) internal {
        IUniswapV2Router02 router = IUniswapV2Router02(routerAddress);

        // generate the pancake pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = tokenAddress;
        path[1] = router.WETH();

        // make the swap
        router.swapExactTokensForETHSupportingFeeOnTransferTokens(
            tokenAmount,
            0, // accept any amount of BNB
            path,
            receiver,
            block.timestamp + timeout
        );
    }

    function addLiquidity(
        address routerAddress,
        address tokenAddress,
        address receiver,
        uint256 tokenAmount,
        uint256 ethAmount
    ) internal {
        IUniswapV2Router02 router = IUniswapV2Router02(routerAddress);

        // add the liquidity
        router.addLiquidityETH{value: ethAmount}(
            tokenAddress,
            tokenAmount,
            0, // slippage is unavoidable
            0, // slippage is unavoidable
            receiver,
            block.timestamp
        );
    }
}

// File: ./contracts/interfaces/IUniswapV2Pair.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

interface IUniswapV2Pair {
    function sync() external;
}


// File: ./contracts/interfaces/IUniswapV2Router02.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import "./IUniswapV2Router01.sol";

interface IUniswapV2Router02 is IUniswapV2Router01 {
    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountETH);

    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;

    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable;
}


// File: ./contracts/interfaces/IUniswapV2Router01.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

interface IUniswapV2Router01 {
    function factory() external pure returns (address);

    // solhint-disable-next-line func-name-mixedcase
    function WETH() external pure returns (address);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);

    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
}


// File: ./contracts/abstracts/BEP20WithFee.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import "../libs/SafeMath.sol";
import "../libs/SwapUtilities.sol";
import "./PairsHolder.sol";
import "./BEP20WithHoldersDistribution.sol";

abstract contract BEP20WithFee is BEP20WithHoldersDistribution, PairsHolder {
    using SafeMath for uint256;

    // --==[ Router ]==--
    address public swapRouter;
    uint256 public swapRouterSellTimeout = 0;

    // --==[ Strategies ]==--
    uint256 private constant LIQUIDITY_STRATEGY_SEND_TOKENS = 1;
    uint256 private constant LIQUIDITY_STRATEGY_SELL_LIQUIFY = 2;
    uint256 private liquidity_strategy;
    uint256 public liquidityVaultMinBalance = 8888e18;

    // --==[ FEES ]==--
    // Fees numbers are multiplied by 100
    uint256 public buyFee = 500; // 5%
    uint256 public sellFee = 1000; // 10%

    uint256 public tokenHoldersPart = 5000; // 50%
    uint256 public lpPart = 2500; // 25%
    uint256 public burnPart = 1000; // 10%
    uint256 public projectPart = 1500; // 15%

    // --==[ WALLETS ]==--
    address public teamWallet;
    mapping(address => bool) public taxless;

    bool public isFeeActive = true;
    bool public isRewardActive = true;
    uint256 public minPairBalanceToStartLiquify = 444444e18;

    // --==[ TOTALS ]==--
    uint256 public totalBurnFee;
    uint256 public totalLpFee;
    uint256 public totalProtocolFee;
    uint256 public totalHoldersFee;

    // --==[ Events ]==--
    event LpRewarded(address indexed lpPair, uint256 amount);
    event FeesUpdated(
        uint256 indexed buyFee,
        uint256 indexed sellFee,
        uint256 tokenHoldersPart,
        uint256 lpPart,
        uint256 burnPart,
        uint256 projectPart
    );

    bool private locked;
    modifier lock {
        require(!locked, "Locked");
        locked = true;
        _;
        locked = false;
    }

    function isLocked() internal view returns (bool) {
        return locked;
    }

    constructor(string memory name, string memory symbol) BEP20WithHoldersDistribution(name, symbol) internal {
        liquidity_strategy = LIQUIDITY_STRATEGY_SELL_LIQUIFY;
        teamWallet = _msgSender();
    }

    // --==[ External methods ]==--
    function setLiquidityStrategy(uint256 strategy) onlyOwner external {
        require(liquidity_strategy != strategy, "BEP20WithFee: liquidity strategy is the same");
        liquidity_strategy = strategy;
    }

    function setSwapRouter(address router) onlyOwner external {
        require(router != address(0), "BEP20WithFee: farm router can't be zero address");
        swapRouter = router;
    }

    function setSwapRouterSellTimeout(uint256 timeout) onlyOwner external {
        swapRouterSellTimeout = timeout;
    }

    function setLiquidityVaultMinBalance(uint256 amount) onlyOwner external {
        liquidityVaultMinBalance = amount;
    }

    function setFees(
        uint256 buyFee_,
        uint256 sellFee_,
        uint256 tokenHoldersPart_,
        uint256 lpPart_,
        uint256 burnPart_,
        uint256 projectPart_
    ) external onlyOwner {
        require(buyFee_ < 10000, "BEP20WithFee: Buy fee should be less than 100%");
        require(sellFee_ < 10000, "BEP20WithFee: Sell fee should be less than 100%");
        require(
            tokenHoldersPart_.add(lpPart_).add(burnPart_).add(projectPart_) == 10000,
            "BEP20WithFee: Sum of tokenHolders/lp/burn/project parts should be 10000 (100%)"
        );

        buyFee = buyFee_;
        sellFee = sellFee_;
        tokenHoldersPart = tokenHoldersPart_;
        lpPart = lpPart_;
        burnPart = burnPart_;
        projectPart = projectPart_;

        emit FeesUpdated(buyFee, sellFee, tokenHoldersPart, lpPart, burnPart, projectPart);
    }

    function setMinPairBalanceToStartLiquify(uint256 amount) external onlyOwner {
        minPairBalanceToStartLiquify = amount;
    }

    function setFeeActive(bool value) external onlyOwner {
        isFeeActive = value;
    }

    function setRewardActive(bool value) external onlyOwner {
        isRewardActive = value;
    }

    function setTaxless(address account, bool value) public onlyOwner {
        require(account != address(0), "Taxless is zero-address");
        taxless[account] = value;
    }

    function setTeamWallet(address account) external onlyOwner {
        require(account != address(0), "BEP20WithFee: Team wallet is zero-address");
        require(teamWallet != account, "BEP20WithFee: Team wallet is the same");

        // include old project wallet to rewards
        if (teamWallet != address(0)) {
            setTaxless(teamWallet, false);
            includeInRewards(teamWallet);
        }

        teamWallet = account;

        // exclude new team wallet from rewards
        setTaxless(teamWallet, true);
        excludeFromRewards(teamWallet);
    }

    function withdrawFees(address receiver, uint256 amount) external onlyOwner {
        require(receiver != address(0), "BEP20WithFee: receiver is zero-address");
        require(address(this).balance > amount, "BEP20WithFee: balance is less than amount");
        payable(receiver).transfer(amount);
    }

    // --==[ Overridden methods ]==--
    function _transfer(address from, address to, uint256 amount) override _distribute(from) internal virtual {
        checkAndLiquify(from, to);

        bool isTrading = isPair(from) || isPair(to);

        if (!isTrading || !isFeeActive || taxless[from] || taxless[to] || taxless[msg.sender]) {
            super._transfer(from, to, amount);
            return;
        }

        bool isBuying = from == msg.sender && isPair(from);
        (uint256 feePart, address lpPair, address feePayer) = isBuying ? (buyFee, from, to) : (sellFee, to, from);

        uint256 totalFees = amount.mul(feePart).div(10000);
        (uint256 holdersFee, uint256 lpFee, uint256 burnFee, uint256 projectFee) = calcFees(totalFees);

        {
            // increasing total values
            totalHoldersFee = totalHoldersFee.add(holdersFee);
            totalBurnFee = totalBurnFee.add(burnFee);
            totalLpFee = totalLpFee.add(lpFee);
            totalProtocolFee = totalProtocolFee.add(projectFee);
        }

        _processPayment(from, to, amount, holdersFee, lpFee, burnFee, projectFee, lpPair, feePayer);
    }

    function _processPayment(
        address from, address to, uint256 amount,
        uint256 holdersFee, uint256 lpFee, uint256 burnFee,
        uint256 projectFee, address lpPair, address feePayer
    ) private {
        // in the case of buying we should transfer all amount to buyer and then take fees from it
        if (feePayer == to) {
            super._transfer(from, to, amount);
        }

        if (isRewardActive) {
            // transfer holders fee part
            addRewards(feePayer, holdersFee);
        } else {
            // if rewards are not active — just burn excess
            super._burn(feePayer, holdersFee);
        }

        // transfer LP part
        super._transfer(feePayer, pair_vaults[lpPair], lpFee);
        // burn the burning fee part
        super._burn(feePayer, burnFee);
        // transfer project fee part
        super._transfer(feePayer, teamWallet, projectFee);

        // selling - fee is taken from the seller
        if (feePayer == from) {
            amount = amount.sub(holdersFee).sub(burnFee).sub(lpFee).sub(projectFee);
            super._transfer(from, to, amount);
        }
    }

    // --==[ Private methods ]==--
    function calcFees(uint256 amount)
    private view
    returns (uint256 holdersFee, uint256 lpFee, uint256 burnFee, uint256 projectFee)
    {
        // Calc TokenHolders part
        holdersFee = amount.mul(tokenHoldersPart).div(10000);
        lpFee = amount.mul(lpPart).div(10000);
        burnFee = amount.mul(burnPart).div(10000);
        projectFee = amount.mul(projectPart).div(10000);
    }

    function checkAndLiquify(address from, address to) private {
        if (isLocked()) return;

        uint256 pairs_length = pairsLength();

        // this loop is safe because pairs length would never been more than 25
        for (uint256 idx = 0; idx < pairs_length; idx++) {
            address pair = pairs[idx];
            address vault = getPairVault(pair);

            bool overMinTokenBalance = BEP20.balanceOf(vault) >= liquidityVaultMinBalance;
            bool internalSwap = (from == address(this) && isPair(to)); // don't trigger infinite loop

            if (
                !isLocked() &&
                !internalSwap &&
                overMinTokenBalance &&
                from != pair // couldn't liquify if sender is the same pair!
            ) {
                liquifyPair(vault, pair, liquidityVaultMinBalance);
            }
        }
    }

    function liquifyPair(address vault, address pair, uint256 amount) private lock {
        if (liquidity_strategy == LIQUIDITY_STRATEGY_SEND_TOKENS) {
            // only reward LP when token balance greater then minimum
            if (balanceOf(pair) >= minPairBalanceToStartLiquify) {
                liquifyPair1(vault, pair, amount);
            }
        } else if (liquidity_strategy == LIQUIDITY_STRATEGY_SELL_LIQUIFY) {
            liquifyPair2(vault, amount); // only liquify ETH-token pair
        }

        emit LpRewarded(pair, amount);
    }

    function liquifyPair1(address vault, address pair, uint256 amount) private {
        BEP20._transfer(vault, pair, amount);
        IUniswapV2Pair(pair).sync();
    }

    function liquifyPair2(address vault, uint256 amount) private {
        BEP20._transfer(vault, address(this), amount);
        _approve(address(this), address(swapRouter), amount);

        uint256 half_to_sell = amount.div(2);
        uint256 half_to_liquify = amount.sub(half_to_sell);

        uint256 balance_before_sell = address(this).balance;
        SwapUtilities.swapTokensForETH(swapRouter, address(this), address(this), half_to_sell, swapRouterSellTimeout);
        uint256 balance_to_liquify = address(this).balance.sub(balance_before_sell);
        SwapUtilities.addLiquidity(swapRouter, address(this), teamWallet, half_to_liquify, balance_to_liquify);
    }
}

// File: ./contracts/abstracts/PairsHolder.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

contract PairVault {
    constructor() public {
    }
}

abstract contract PairsHolder {
    mapping(address => address) internal pair_vaults;
    address[] public pairs;

    function _addPairToTrack(address pair) internal {
        require(!isPair(pair), "PairsHolder: already tracking");
        require(pairs.length < 25, "PairsHolder: maximum 25 LP Pairs reached");
        pair_vaults[pair] = address(new PairVault());
        pairs.push(pair);
    }

    function isPair(address account) public view returns (bool) {
        return getPairVault(account) != address(0);
    }

    function getPairVault(address pair) public view returns (address) {
        return pair_vaults[pair];
    }

    function pairsLength() public view returns (uint256) {
        return pairs.length;
    }
}


// File: ./contracts/abstracts/BEP20WithHoldersDistribution.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import "../libs/BEP20.sol";
import "../libs/SafeMath.sol";

contract RewardsVault {
    constructor() public {
    }
}

abstract contract BEP20WithHoldersDistribution is BEP20 {
    using SafeMath for uint256;

    address public rewardsVault;

    mapping(address => bool) public rewardsExcluded;
    mapping(address => uint256) public lastTotalDividends;

    constructor(string memory name, string memory symbol) BEP20(name, symbol) internal {
        rewardsVault = address(new RewardsVault());
        rewardsExcluded[_msgSender()] = true;
        rewardsExcluded[rewardsVault] = true;
    }

    function _calcRewards(address account) internal view virtual returns (uint256) {
        if (rewardsExcluded[account]) return 0;

        uint256 _balance = super.balanceOf(account);
        uint256 _dividends = super.balanceOf(rewardsVault);
        uint256 _lastTotalDividends = lastTotalDividends[account];

        // just to be safe.
        if (_dividends <= _lastTotalDividends) return 0;

        // difference between current dividends and last dividends represents hold time
        // then we multiply it by holder's % from total supply
        return _dividends.sub(_lastTotalDividends).mul(_balance).div(totalSupply());
    }

    modifier _distribute(address account) {
        uint256 rewards = _calcRewards(account);
        BEP20._transfer(rewardsVault, account, rewards);
        lastTotalDividends[account] = super.balanceOf(rewardsVault);
        _;
    }

    function excludeFromRewards(address account) _distribute(account) public onlyOwner {
        rewardsExcluded[account] = true;
    }

    function includeInRewards(address account) _distribute(account) public onlyOwner {
        delete rewardsExcluded[account];
    }

    function addRewards(address from, uint256 amount) internal virtual {
        BEP20._transfer(from, rewardsVault, amount);
    }

    /**
     * @dev See {BEP20-balanceOf}.
     */
    function balanceOf(address account) public view virtual override returns (uint256) {
        return super.balanceOf(account) + _calcRewards(account);
    }
}


// File: ./contracts/libs/BEP20.sol
// SPDX-License-Identifier: MIT
pragma solidity >=0.6.12;

import "./Context.sol";
import "./IBEP20.sol";
import "./Ownable.sol";
import "./SafeMath.sol";

/**
 * @dev Implementation of the {IBEP20} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 * For a generic mechanism see {BEP20PresetMinterPauser}.
 *
 * TIP: For a detailed writeup see our guide
 * https://forum.zeppelin.solutions/t/how-to-implement-BEP20-supply-mechanisms/226[How
 * to implement supply mechanisms].
 *
 * We have followed general OpenZeppelin guidelines: functions revert instead
 * of returning `false` on failure. This behavior is nonetheless conventional
 * and does not conflict with the expectations of BEP20 applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn't required by the specification.
 *
 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
 * functions have been added to mitigate the well-known issues around setting
 * allowances. See {IBEP20-approve}.
 */
contract BEP20 is Context, IBEP20, Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private _balances;

    mapping(address => mapping(address => uint256)) internal _allowances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;
    uint8 private _decimals;

    /**
     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with
     * a default value of 18.
     *
     * To select a different value for {decimals}, use {_setupDecimals}.
     *
     * All three of these values are immutable: they can only be set once during
     * construction.
     */
    constructor(string memory name, string memory symbol) internal {
        _name = name;
        _symbol = symbol;
        _decimals = 18;
    }

    /**
     * @dev Returns the bep token owner.
     */
    function getOwner() external override view returns (address) {
        return owner();
    }

    /**
     * @dev Returns the name of the token.
     */
    function name() public override view returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public override view returns (string memory) {
        return _symbol;
    }

    /**
    * @dev Returns the number of decimals used to get its user representation.
    */
    function decimals() public override view returns (uint8) {
        return _decimals;
    }

    /**
     * @dev See {BEP20-totalSupply}.
     */
    function totalSupply() public override view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {BEP20-balanceOf}.
     */
    function balanceOf(address account) public override virtual view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {BEP20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    /**
     * @dev See {BEP20-allowance}.
     */
    function allowance(address owner, address spender) public override view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {BEP20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 amount) public override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    /**
     * @dev See {BEP20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {BEP20};
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(
            sender,
            _msgSender(),
            _allowances[sender][_msgSender()].sub(amount, "BEP20: transfer amount exceeds allowance")
        );
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {BEP20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {BEP20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(
            _msgSender(),
            spender,
            _allowances[_msgSender()][spender].sub(subtractedValue, "BEP20: decreased allowance below zero")
        );
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        if (amount == 0) return;
        require(sender != address(0), "BEP20: transfer from the zero address");
        require(recipient != address(0), "BEP20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount, "BEP20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "BEP20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 amount) internal {
        require(account != address(0), "BEP20: burn from the zero address");

        _balances[account] = _balances[account].sub(amount, "BEP20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), "BEP20: approve from the zero address");
        require(spender != address(0), "BEP20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See {_burn} and {_approve}.
     */
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(
            account,
            _msgSender(),
            _allowances[account][_msgSender()].sub(amount, "BEP20: burn amount exceeds allowance")
        );
    }
}


// File: ./contracts/libs/Context.sol
// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;
/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with GSN meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
contract Context {
    // Empty internal constructor, to prevent people from mistakenly deploying
    // an instance of this contract, which should be used via inheritance.
    constructor () internal {}

    function _msgSender() internal view returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view returns (bytes memory) {
        // silence state mutability warning without generating bytecode -
        // see https://github.com/ethereum/solidity/issues/2691
        this;
        return msg.data;
    }
}

// File: ./contracts/libs/IBEP20.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

interface IBEP20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the token decimals.
     */
    function decimals() external view returns (uint8);

    /**
     * @dev Returns the token symbol.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the token name.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the bep token owner.
     */
    function getOwner() external view returns (address);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address _owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}


// File: ./contracts/libs/Ownable.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import "./Context.sol";
/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
contract Ownable is Context {
  address private _owner;

  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

  /**
   * @dev Initializes the contract setting the deployer as the initial owner.
   */
  constructor () internal {
    address msgSender = _msgSender();
    _owner = msgSender;
    emit OwnershipTransferred(address(0), msgSender);
  }

  /**
   * @dev Returns the address of the current owner.
   */
  function owner() public view returns (address) {
    return _owner;
  }

  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(_owner == _msgSender(), "Ownable: caller is not the owner");
    _;
  }

  /**
   * @dev Leaves the contract without owner. It will not be possible to call
   * `onlyOwner` functions anymore. Can only be called by the current owner.
   *
   * NOTE: Renouncing ownership will leave the contract without an owner,
   * thereby removing any functionality that is only available to the owner.
   */
  function renounceOwnership() public onlyOwner {
    emit OwnershipTransferred(_owner, address(0));
    _owner = address(0);
  }

  /**
   * @dev Transfers ownership of the contract to a new account (`newOwner`).
   * Can only be called by the current owner.
   */
  function transferOwnership(address newOwner) public onlyOwner {
    _transferOwnership(newOwner);
  }

  /**
   * @dev Transfers ownership of the contract to a new account (`newOwner`).
   */
  function _transferOwnership(address newOwner) internal {
    require(newOwner != address(0), "Ownable: new owner is the zero address");
    emit OwnershipTransferred(_owner, newOwner);
    _owner = newOwner;
  }
}

// File: ./contracts/interfaces/IHoneyBotV0Token.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

interface IHoneyBotV0Token {
    /**
     * @dev Called before the liquidity is added.
     */
    function prepareForInitialLiquidity() external;

    /**
     * @dev Called immediately after the liquidity is added.
     */
    function warmupBotProtection(uint256 firewallBlockLength) external;
}

// File: ./contracts/interfaces/IUniswapV2Factory.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

interface IUniswapV2Factory {
    function createPair(address tokenA, address tokenB) external returns (address pair);
}

