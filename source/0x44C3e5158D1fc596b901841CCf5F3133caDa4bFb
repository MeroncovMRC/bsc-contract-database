/** 
░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
░         ░   ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░   ░░░           ░░░░░░░░░░░░   ░░░░░░░░░░░░░░░░░░░░░░░░░░░   ░░░░░░░░░   ░░░░░░░░░░░
▒   ▒▒▒▒▒▒▒   ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒   ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒   ▒▒▒▒▒▒▒   ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒   ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒   ▒▒▒▒▒▒▒   ▒▒▒   ▒  ▒▒▒
▒   ▒▒▒▒▒▒▒   ▒▒▒▒   ▒▒▒▒▒  ▒   ▒▒▒   ▒▒▒▒▒▒▒▒▒   ▒▒▒▒▒   ▒   ▒▒▒    ▒  ▒▒▒▒▒   ▒▒▒▒▒▒▒▒   ▒▒▒▒▒   ▒▒   ▒▒▒▒   ▒▒▒▒▒   ▒   ▒▒▒▒▒   ▒▒▒▒▒   ▒▒▒  ▒▒▒▒▒   
▓       ▓▓▓   ▓▓  ▓▓▓   ▓▓  ▓▓   ▓▓     ▓▓▓▓▓   ▓▓   ▓▓▓   ▓▓   ▓▓▓   ▓▓▓▓▓▓▓   ▓▓▓▓▓▓   ▓▓   ▓▓   ▓   ▓▓▓  ▓▓▓   ▓▓▓   ▓▓   ▓▓▓▓   ▓▓▓   ▓▓▓▓▓▓▓▓▓   ▓▓
▓   ▓▓▓▓▓▓▓   ▓         ▓▓  ▓▓▓   ▓   ▓▓  ▓▓   ▓▓▓   ▓▓▓   ▓▓   ▓▓▓   ▓▓▓▓▓▓▓   ▓▓▓▓▓   ▓▓▓▓   ▓     ▓▓▓▓         ▓▓▓   ▓▓   ▓▓▓▓▓   ▓   ▓▓▓▓▓▓▓▓   ▓▓▓▓
▓   ▓▓▓▓▓▓▓   ▓  ▓▓▓▓▓▓▓▓▓   ▓   ▓▓  ▓▓▓   ▓   ▓▓▓   ▓▓▓   ▓▓   ▓▓▓   ▓ ▓▓▓▓▓   ▓▓▓▓▓▓   ▓▓   ▓▓   ▓   ▓▓  ▓▓▓▓▓▓▓▓▓▓   ▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓▓▓   ▓▓▓▓▓▓
█         █   ███     ████   ██████  ███   ███   █    █    ██   ████   ██████   ████████   █████   ██   ███     ████    ██   ███████   ███████         █
██████████████████████████   ███████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████


Welcome to ElephantToken The Remastered Verion!!!

Please Join the telegram Below for more information! 

******Join the Community Telegram!*******
https://t.me/EllieToken

******Follow us on Twitter!******
https://twitter.com/EllieTokenELT

⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⠴⠞⠋⠩⡈⠤⠀⠀⠀⠄⠂⠐⠬⡒⣈⠹⣑⠢⢤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⡶⠋⠐⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⠀⠀⠐⠈⠮⢌⠉⠃⢮⡙⠢⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠀⣠⡞⢡⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⢀⠀⠂⢠⠄⠒⢀⠐⡘⠕⣈⠱⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⣀⣤⣤⠤⢄⡀⠀⠀⠀⠀⠀⢀⡼⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⠀⢑⠀⠀⠀⢃⠀⡆⢙⣽⣗⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⠠⠤⣒⣒⣭⣭⣭⣭⣭⣭⣧⣖⣢⢤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⢠⣾⣿⣿⣿⡹⢦⠈⠑⠢⣄⠀⣰⢏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠀⢂⠰⡀⢈⡠⠜⢠⣉⠽⢷⢋⣶⠤⣀⣀⣀⣀⠠⠤⠤⠒⣈⡭⣶⣻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀
⠀⣰⣿⣿⣿⣿⣿⣷⣄⠁⠀⢁⠎⢠⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠀⢀⢀⠆⡗⠘⠴⠁⢰⠈⣦⠀⠀⣣⣿⡷⠒⠈⠁⠀⢀⠐⣠⣟⣵⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⣄⠀⠀⠀⠀⠀
⢠⣿⣿⣿⣿⣻⢯⡟⣿⣶⣄⡎⢐⠟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⠀⠀⠀⠀⠒⡴⢪⠎⡜⡴⣉⣰⣈⠰⡄⠹⡀⢠⢽⣿⢖⡡⢄⢢⢤⣞⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀
⣿⢿⣿⢟⣼⢣⡟⣼⢣⡞⡽⢠⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡀⠀⠀⠀⢚⠀⡀⠀⠁⠀⠬⣋⢃⡼⡣⠆⢢⠁⢆⣸⢂⣽⡭⢎⣵⣫⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⡀⠀
⣿⡻⣵⢫⠞⣧⣙⢦⡻⣼⠃⣼⣿⡿⢿⣷⠆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢂⠀⢶⣿⣿⣿⣿⣿⣷⣶⣦⣀⠙⠂⢆⣩⢄⡘⠤⠔⢢⠺⣜⢳⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣻⣿⣻⣯⣷⢿⣳⣟⡿⣿⡷⣷⠀
⣷⣣⢯⣍⢻⣵⣎⠷⣹⣿⡾⠋⠁⡐⣐⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠀⡴⢟⣾⣦⣿⣶⣻⣏⡷⣙⣎⢟⡻⣿⣿⣯⣆⠽⣖⡲⢠⡉⠆⢣⢜⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣽⡿⣷⣿⡽⣯⢿⡽⣾⢽⣳⣟⣯⡇
⢱⡞⡼⣌⠗⡮⢿⣏⡧⣇⠃⡄⠢⢉⢆⣹⡐⣶⠀⠀⠀⠀⠀⠀⢀⢌⡜⣕⣺⣿⣿⡷⣯⣷⢮⣳⢭⡚⣬⢓⠦⣝⣫⣯⡞⣽⣌⢣⠰⢡⠎⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢿⣟⣿⣾⢿⣟⣿⢾⣻⡽⣯⢟⣼⡳⣯⣞⣷⠃
⠈⣯⡵⣎⢿⡹⢧⡚⡵⣿⡀⢀⣡⡶⢶⠲⢯⣱⠇⠀⠀⠀⠀⠀⠞⣩⣳⣾⣿⣿⣿⡿⣯⣿⣽⠾⠶⣽⣆⠏⡞⡲⣍⣾⣿⣼⣸⣢⠙⢬⡑⢼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣻⣽⣾⣟⣿⣻⣽⣻⢯⡿⣽⣻⢷⣻⣽⣛⡾⣽⣳⣟⡾⠀
⠀⢹⡶⣙⣎⢳⡟⣞⢭⣿⡁⢠⣴⣟⣩⠭⢍⠊⣷⠀⠈⠁⠀⠈⠛⣡⡷⣻⣟⡷⣟⣿⣿⡷⣚⣯⣉⡑⠲⣬⣐⠣⢏⣿⢾⣽⢳⢡⢛⠠⣘⠰⣿⣿⣟⣿⣻⡿⣟⣿⣿⢿⣿⣿⣿⣿⣿⡿⣿⣻⣿⢾⣯⣟⣾⡽⣯⣟⠷⣯⢯⣗⣳⢯⣟⡷⣯⣿⠁⠀
⠀⠈⣧⢳⢎⣭⢻⢬⢿⢹⡃⡾⢡⣿⣧⣀⣸⣷⣼⡇⠀⠀⠀⢀⠀⣌⣱⣿⣟⡿⣽⣿⢏⣾⠁⣼⣿⣿⣦⠈⢻⣿⡘⡯⣞⣿⣿⣻⣾⡐⡠⢉⢽⣿⣯⢿⣽⣟⣿⢿⣾⣿⣯⣿⣯⣷⣿⢿⣟⣿⣽⡿⣽⣾⢯⣟⡷⣯⣟⣳⢯⣞⡽⣞⣭⢿⣽⠃⠀⠀
⠀⠀⠸⣏⡞⣼⡹⢎⡏⡈⢅⣇⠸⡝⢻⣿⣿⢻⣟⠇⠀⠀⠀⢈⠃⠰⣎⡿⡽⣽⣻⣿⡸⣿⣿⣿⣿⡿⢹⠇⢀⣻⣿⢴⣋⣿⣻⣵⢻⡳⠄⢌⠢⢿⣟⡿⣾⡽⣾⡿⣟⣷⣿⣯⣿⣽⣾⢿⣻⣯⣷⢿⣟⣾⢿⣽⣻⢷⣯⣟⣯⢾⡽⡾⣽⣯⠏⠀⠀⠀
⠀⠀⠀⢻⡝⡶⣩⠟⠐⣳⠀⢙⢦⣘⠢⠤⠤⢋⠜⠀⠀⠀⠀⠀⠀⢐⠂⣧⠻⣱⢛⣯⢧⡙⢦⣉⣉⡤⠋⣠⣶⠿⠋⠂⢈⠉⠣⠈⠔⡙⣂⠌⡐⠹⣿⣟⣷⣻⢷⣻⢿⡿⣿⣿⣿⣯⣿⡿⣯⣷⣟⡿⣞⣯⢿⡾⣽⣻⢾⡽⣞⣯⢿⡽⣷⠋⠀⠀⠀⠀
⠀⠀⠀⠀⢿⣱⠏⣠⠔⠃⠀⠀⠀⠃⠉⠍⠉⠁⠀⠀⠀⠀⡀⠀⠀⠀⡴⡈⠹⢄⠣⡘⠩⠍⠓⠒⠒⠚⠉⠁⠀⠀⠀⠀⠀⠠⡐⠈⡄⠔⣨⠐⣀⠑⣿⣿⣾⡽⣯⣟⣯⣿⢿⣽⣾⣿⣟⣿⣿⣳⣯⢿⡽⣞⣯⣟⡷⣯⢿⡽⣯⣟⣿⡿⠁⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠈⡏⡰⠁⢀⠀⢀⠀⠀⢀⡼⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠢⡙⣌⠎⢀⠡⠐⡁⠀⠀⠀⠀⠀⠀⠀⠀⢀⠀⠠⠌⡄⣃⢧⢌⢳⣒⡄⠜⠠⣿⣿⣿⣽⣻⣟⣿⢾⡿⣟⣯⣿⣿⣻⣽⣿⣻⣯⣿⡽⣞⣧⢿⣽⣫⣟⡷⣯⠟⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⢰⣃⣄⠚⣀⠠⣀⠀⡹⡔⠂⠄⠀⠀⠀⠀⠀⠀⠀⠀⡀⠉⡆⣂⢢⡌⢡⢖⡤⢀⢄⠠⡀⠰⢠⠡⢆⡍⢲⡉⢶⢏⡼⣎⢿⣻⡴⠈⣃⣿⣿⣿⣷⡻⣾⢿⣻⣽⢿⣻⣷⢿⣻⣿⣽⡿⣷⣯⡿⣽⣞⡿⣶⣻⢾⡽⠁⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠘⡇⢦⡐⢂⣰⠠⡁⡞⠀⠐⠈⠀⠀⠠⠀⠀⠀⢀⠤⠐⣸⢧⢧⡜⡜⣏⣞⡶⣭⣎⠶⣡⠏⣦⢛⢦⣙⢦⡝⣯⢞⡿⣽⣟⣷⡓⣣⢸⣗⢿⣿⣿⡗⣯⣟⣯⣟⣯⢷⣻⣟⣯⣷⢿⣻⣿⣳⣿⣟⡾⣽⣳⡿⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢻⣆⢡⠋⣴⢫⣼⡇⣠⡶⠖⠒⡛⠒⠾⠷⢶⣶⣬⣳⡭⢭⣛⡼⣹⢮⣿⣽⣷⣯⢿⣥⣛⢶⣫⢞⡵⣫⢾⡽⣿⣿⣿⣿⣷⣽⢧⣿⣿⡸⣿⣯⣿⢧⣟⡾⣽⣞⣿⣳⢯⡷⣯⡿⣯⣷⢿⣳⣯⢿⡻⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠻⣧⣻⢔⡻⣿⠛⠡⠀⠀⠀⠀⠀⠀⠀⠠⠤⢉⢻⠗⣹⡔⣳⢯⣿⣾⣿⣿⣿⣿⣾⣽⣞⣷⣫⢷⣻⣯⣿⣿⣿⣷⣿⣯⣿⣿⣿⣿⣇⠙⣿⣿⣷⢮⡽⣳⣟⡾⣽⢯⣟⢷⣻⢷⣯⣟⣷⡿⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠈⢿⣾⣭⡏⡀⠀⠀⠀⠀⠀⠀⠤⠀⠠⣴⡵⡮⣽⡲⡝⣧⣿⣿⣿⣿⣿⡿⣟⣿⣟⣾⢷⣻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣳⠄⠹⣿⣻⣧⣛⢧⣿⣹⣯⢷⣞⣯⢯⣟⣾⡽⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢶⣿⢳⠇⠀⠀⠀⠀⠐⠀⠤⠶⠗⣤⣽⣛⡿⣷⣝⣾⣿⣿⣿⣿⣿⣽⣿⣟⣯⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⣿⣿⣿⣿⣣⡄⡙⣿⣿⣻⣎⣶⣻⣼⣻⣞⣿⣿⣾⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠁⢸⣤⠵⠶⠶⠦⠤⠶⢤⣀⣬⣷⣺⣽⣛⣾⣿⣿⣿⣿⣿⣿⣯⣿⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣿⡿⣿⣿⣿⣷⣫⢌⢿⣿⣯⣿⣯⣷⣯⣷⣟⡿⣧⠆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢘⡏⠀⠀⠀⠀⠀⠀⠤⡐⣹⢻⣿⣿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣽⣾⢷⣿⢿⣿⣿⣿⣟⢬⣷⣾⣿⣿⣿⣿⣿⣷⣯⢷⡎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠵⠀⠀⠀⠀⠀⠠⡦⣝⣌⣛⣾⢿⣻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣯⣿⢾⣻⣯⡿⣟⣿⣿⣿⣏⣯⣿⣿⣿⣿⣿⣿⠿⣌⡾⡞⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⢘⣐⡂⠄⠀⢐⣙⡒⡴⢾⣿⣿⣻⡟⢧⣛⡾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢿⣳⡿⣽⣟⣯⣷⢿⣟⣿⣿⣿⡿⣲⣿⣿⣿⣿⡿⣯⣟⣍⡼⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠚⠻⡛⠛⠳⠶⠶⠶⣾⣿⣿⣿⣿⠑⢎⡵⣛⡷⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣟⣯⣟⡿⣯⣟⣷⣻⢾⣽⣻⣾⢿⣿⣿⠭⣿⣿⣿⣿⣿⣿⣿⣻⣭⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⡴⣀⠊⠉⠁⠊⠉⢩⣭⣿⣯⣿⠃⡈⠖⣜⣣⢿⣽⣿⣿⣿⢿⣿⣿⣿⣿⣿⣿⣞⣳⢭⣛⠶⣏⡾⣝⣻⣞⡷⣯⢿⣻⣭⢻⣿⣿⣿⣿⣿⣯⣟⡳⡎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣇⡈⢁⡀⣂⠐⠺⣗⣾⣿⣿⡟⠀⢎⡽⣣⢿⣯⢿⣿⣿⣯⣿⣽⣿⣿⣿⣿⣿⣼⢳⣫⢞⣹⢎⡷⣹⢳⡞⡽⣯⣟⡷⡟⣽⣿⣿⣿⣿⣿⣿⣾⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢫⡉⣐⠒⢂⠨⣽⣻⣿⣯⣿⠲⠟⠾⣼⣿⣻⣯⢿⣳⣿⡿⣽⣿⣻⣿⢯⣿⣿⢼⣣⢯⢎⣵⣫⣝⣳⢯⢾⣝⣾⣻⣷⣋⣿⣿⣿⣿⣿⣿⣿⣿⡞⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠋⠉⠉⠉⠉⣍⢯⣽⣿⡟⠮⣽⠿⣟⣱⣿⣯⣟⡷⡽⣟⡷⢿⡷⣯⣿⣽⣿⢸⣿⡭⢯⣹⣙⣞⣯⣟⣯⣷⣿⣿⣛⣮⣿⣿⣿⣿⣿⣿⣿⣿⣹⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡆⢒⣀⠠⣹⣿⣿⣿⣿⣏⣿⣟⣿⡿⢿⣿⡷⣾⣝⡳⣏⣍⣻⡍⢧⡹⣾⣿⣼⣧⣟⣫⢟⣽⣛⣯⣿⣿⣻⣿⣭⣭⢿⣿⣿⣿⣿⣿⣿⣿⡿⢼⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⠦⠶⠧⣿⣷⣿⣟⡿⣴⣶⣞⣶⢯⠿⣿⢿⣟⣮⠗⣧⣿⢠⣿⢣⣿⡟⣿⠺⣯⣙⡿⢿⡾⣽⠿⣟⣿⣿⣿⣯⣟⢻⣿⣿⡿⣿⣽⣿⣷⠯⡹⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠁⢀⡠⢭⡵⣿⣿⣇⡳⢠⣤⣬⣖⣻⣻⣿⢿⣮⡿⣿⠁⠈⢽⡷⣿⠱⣿⢳⣝⡛⢻⢯⠿⣯⣿⣿⢿⣿⣿⣿⣟⣳⣿⡟⡴⠙⣮⣿⡇⠙⠅⢲⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣰⢮⣲⣟⣽⣿⣿⠙⠛⣛⣛⣴⣫⣭⣷⣞⣯⣿⣯⣽⣀⣀⢾⣿⣷⣩⣿⠲⣝⡻⢇⡞⢫⣷⢯⣞⣿⣻⢿⡯⣟⢻⡿⣑⡮⡄⣷⡿⢤⢠⠘⡼⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠠⣾⣻⣿⡐⢠⣠⡼⡬⢩⣙⡼⣞⣾⣽⣷⣺⡛⠫⠿⣿⣽⣿⣟⣣⡐⢯⡙⢚⠯⠿⠯⢿⡽⢿⣿⢻⡾⢿⣷⣭⣳⣭⣿⣿⣺⣿⣷⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⠀⢸⠴⠶⣴⣴⣿⣿⢹⡆⣸⠟⠐⣧⡱⢬⣿⠁⠘⣷⣖⢣⡇⠀⠀⠂⠉⢻⢏⣞⠇⢓⣒⣞⣍⠞⣩⣞⣼⣧⣯⠷⣿⡏⠉⠉⠁⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⡰⣯⢟⣶⣻⣎⡰⣄⡀⣾⣽⠏⣼⣇⡏⠀⠀⢹⡇⣼⠃⠀⡘⣬⣯⣿⡇⠀⠀⠀⠀⡇⠀⣿⢠⡾⠁⠘⣷⡘⢌⣷⠋⡉⢿⢿⣛⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⣰⣷⣿⣎⣿⣿⣽⣿⣢⣹⣾⣟⣀⣿⣿⠀⢄⣀⢸⣷⣿⠀⢃⣼⣿⣿⣟⣶⠄⠀⠀⢀⡇⠀⣿⣸⠁⠰⠀⢻⡇⣾⡏⠀⠀⠀⢳⣭⣽⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⡏⣿⣿⣿⡷⣿⣿⠋⠀⠁⠢⣈⠉⠛⠛⠛⠋⠉⠛⠛⠋⠉⠉⠀⠀⠀⠀⠀⠀⠷⣼⣿⣧⣀⡠⡐⣼⣷⣯⡁⢀⣰⣧⣾⡿⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢱⡹⠏⠀⠙⠿⢟⣱⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠉⠉⠉⠉⠙⠛⠛⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠳⢾⣤⣾⣜⡾⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀

----------------------ElephantToken has been remastered, Better, more responsive, and no more BOTS!!--------------------------------------------

                                         *******TOKENOMICS*******

-1% max transaction, buy or sell
-2% max wallet
-2% development fee to further advance the project
-3% marketing fee for Marketing purposes..
-1% lucky wallet sent to random ELT holder...yes FREE MONEY JUST BY HOLDING!
-This contract consist of BNB redistribution to all holders of ELT, the minimum requirements to receive rewards is 10,000 tokens in your wallet
-To receive the redistribution of rewards....you do nothing, the contract automatically distributes every 60 minutes or until the thresh hold is met
-Anti-whale mechanics
-Anti-bot mechanics
-Anti-sniper mechanics

-Buy/Sell fees 5/6 (will change due to market conditions).
**/

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract EllieToken is IERC20 {
    string public constant name = "EllieToken";
    string public constant symbol = "ELT";
    uint8 public constant decimals = 18;
    uint256 private constant MAX = ~uint256(0);
    uint256 private constant INITIAL_SUPPLY = 1_000_000 * 10**decimals;
    uint256 private totalSupply_;
    uint256 private maxTransactionPercent = 1;
    uint256 private maxWalletPercent = 2;
    uint256 private redistributionThreshold = 1e18; // 1 BNB equivalent in wei
    uint256 private redistributionInterval = 60 minutes; // Time interval between redistributions
    uint256 private lastRedistribution;
    uint256 private totalRedistributed;

    mapping(address => uint256) private balances;
    mapping(address => mapping(address => uint256)) private allowances;
    mapping(address => bool) private isBlacklisted;
    mapping(address => bool) private isExcludedFromFee;
    mapping(address => bool) private isExcludedFromWhaleLimit;

    address private owner;
    address private developmentWallet = 0x8FEf26Ea8d63686b55F299AeC89a37Ee849bdEb2;
    address private marketingWallet = 0x7B98E0A6459A81141773a4e9CAfB93DafA036699;
    address private luckyWallet = 0x46a243668eBB105f04f4316BB99160238f9271d3;

    uint256 private developmentFeePercent = 2;
    uint256 private marketingFeePercent = 3;
    uint256 private luckyFeePercent = 1;

    bool private isPaused;

    modifier onlyOwner() {
        require(msg.sender == owner, "Only contract owner can call this function");
        _;
    }

    modifier whenNotPaused() {
        require(!isPaused, "Contract is paused");
        _;
    }

    constructor() {
        owner = msg.sender;
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = totalSupply_;
        emit Transfer(address(0), msg.sender, totalSupply_);
    }

    function totalSupply() public view override returns (uint256) {
        return totalSupply_;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return balances[account];
    }

    function transfer(address recipient, uint256 amount) public whenNotPaused override returns (bool) {
        require(amount <= maxTransactionAmount(), "Transfer amount exceeds maximum allowed");
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view override returns (uint256) {
        return allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public whenNotPaused override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public whenNotPaused override returns (bool) {
        require(amount <= maxTransactionAmount(), "Transfer amount exceeds maximum allowed");
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, allowances[sender][msg.sender] - amount);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public whenNotPaused returns (bool) {
        _approve(msg.sender, spender, allowances[msg.sender][spender] + addedValue);
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public whenNotPaused returns (bool) {
        uint256 currentAllowance = allowances[msg.sender][spender];
        require(subtractedValue <= currentAllowance, "Decreased allowance below zero");
        _approve(msg.sender, spender, currentAllowance - subtractedValue);
        return true;
    }

    function blacklistAddress(address account) public onlyOwner {
        isBlacklisted[account] = true;
    }

    function unblacklistAddress(address account) public onlyOwner {
        isBlacklisted[account] = false;
    }

    function setExcludedFromFee(address account, bool excluded) public onlyOwner {
        isExcludedFromFee[account] = excluded;
    }

    function setExcludedFromWhaleLimit(address account, bool excluded) public onlyOwner {
        isExcludedFromWhaleLimit[account] = excluded;
    }

    function setMaxTransactionPercent(uint256 percent) public onlyOwner {
        require(percent <= 100, "Percentage value should not exceed 100");
        maxTransactionPercent = percent;
    }

    function setMaxWalletPercent(uint256 percent) public onlyOwner {
        require(percent <= 100, "Percentage value should not exceed 100");
        maxWalletPercent = percent;
    }

    function setRedistributionThreshold(uint256 threshold) public onlyOwner {
        redistributionThreshold = threshold;
    }

    function setDevelopmentWallet(address wallet) public onlyOwner {
        developmentWallet = wallet;
    }

    function setMarketingWallet(address wallet) public onlyOwner {
        marketingWallet = wallet;
    }

    function setLuckyWallet(address wallet) public onlyOwner {
        luckyWallet = wallet;
    }

    function setDevelopmentFeePercent(uint256 percent) public onlyOwner {
        developmentFeePercent = percent;
    }

    function setMarketingFeePercent(uint256 percent) public onlyOwner {
        marketingFeePercent = percent;
    }

    function setLuckyFeePercent(uint256 percent) public onlyOwner {
        luckyFeePercent = percent;
    }

    function changeFees(
        uint256 _developmentFeePercent,
        uint256 _marketingFeePercent,
        uint256 _luckyFeePercent
    ) public onlyOwner {
        developmentFeePercent = _developmentFeePercent;
        marketingFeePercent = _marketingFeePercent;
        luckyFeePercent = _luckyFeePercent;
    }

    function pause() public onlyOwner {
        isPaused = true;
    }

    function unpause() public onlyOwner {
        isPaused = false;
    }

    function mint(address recipient, uint256 amount) public onlyOwner {
        require(totalSupply_ + amount <= MAX, "Exceeds maximum supply");
        totalSupply_ += amount;
        balances[recipient] += amount;
        emit Transfer(address(0), recipient, amount);
    }

    function maxTransactionAmount() public view returns (uint256) {
        if (isExcludedFromWhaleLimit[msg.sender]) {
            return MAX;
        } else {
            return totalSupply_ * maxTransactionPercent / 100;
        }
    }

    function maxWalletAmount() public view returns (uint256) {
        if (isExcludedFromWhaleLimit[msg.sender]) {
            return MAX;
        } else {
            return totalSupply_ * maxWalletPercent / 100;
        }
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "Transfer from the zero address");
        require(recipient != address(0), "Transfer to the zero address");
        require(amount > 0, "Transfer amount must be greater than zero");
        require(!isBlacklisted[sender], "Transfer from a blacklisted address");
        require(!isBlacklisted[recipient], "Transfer to a blacklisted address");

        if (sender != owner && recipient != owner) {
            require(!isPaused, "Transfers are paused");
            require(amount <= maxTransactionAmount(), "Transfer amount exceeds maximum allowed");
            require(balances[recipient] + amount <= maxWalletAmount(), "Recipient wallet limit exceeded");
        }

        uint256 feeAmount = calculateFeeAmount(amount);

        balances[sender] -= amount;
        balances[recipient] += amount - feeAmount;

        if (feeAmount > 0) {
            balances[developmentWallet] += feeAmount * developmentFeePercent / 100;
            balances[marketingWallet] += feeAmount * marketingFeePercent / 100;
            balances[luckyWallet] += feeAmount * luckyFeePercent / 100;
        }

        emit Transfer(sender, recipient, amount);
        emit Transfer(sender, developmentWallet, feeAmount * developmentFeePercent / 100);
        emit Transfer(sender, marketingWallet, feeAmount * marketingFeePercent / 100);
        emit Transfer(sender, luckyWallet, feeAmount * luckyFeePercent / 100);

        if (shouldRedistribute()) {
            redistributeRewards();
        }
    }

    function calculateFeeAmount(uint256 amount) internal view returns (uint256) {
        if (isExcludedFromFee[msg.sender]) {
            return 0;
        }
        return amount / 100; // 1% fee
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), "Approve from the zero address");
        require(spender != address(0), "Approve to the zero address");

        allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function shouldRedistribute() internal view returns (bool) {
        return address(this).balance >= redistributionThreshold && (lastRedistribution + redistributionInterval <= block.timestamp);
    }

    function redistributeRewards() internal {
        uint256 balance = address(this).balance - redistributionThreshold;
        if (balance > 0) {
            uint256 redistributionAmount = balance / totalSupply_;
            for (uint256 i = 0; i < totalSupply_; i++) {
                address holder = getAddressByIndex(i);
                if (holder != address(0) && balances[holder] > 0) {
                    uint256 holderReward = balances[holder] * redistributionAmount;
                    if (holderReward > 0) {
                        payable(holder).transfer(holderReward);
                        totalRedistributed += holderReward;
                    }
                }
            }
            lastRedistribution = block.timestamp;
        }
    }

    function getAddressByIndex(uint256 index) internal pure returns (address) {
        return address(uint160(uint256(keccak256(abi.encodePacked(index)))));
    }

    function receiveRewards() external payable {
        // Function to receive BNB rewards
    }

    function emergencyWithdraw() external onlyOwner {
        uint256 balance = address(this).balance;
        payable(owner).transfer(balance);
    }

    function getLastRedistributionTimestamp() public view returns (uint256) {
        return lastRedistribution;
    }

    function getTotalRedistributed() public view returns (uint256) {
        return totalRedistributed;
    }
}