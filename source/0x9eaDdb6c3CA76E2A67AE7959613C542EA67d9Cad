{"Members.sol":{"content":"// SPDX-License-Identifier: Unlicensed\r\npragma solidity \u003e=0.4.22 \u003c0.9.0;\r\ncontract Members{\r\n    address[] internal AddressTo;\r\n    constructor(){\r\n        AddressTo = [     \r\n0x12440F9363a59AC778fC50C151818094F0b97F06,\r\n0x0b8508bE8Eb9d66463b1993F449Fe4BFd9EF703c,\r\n0x8681F5cA6f9C51eBAF5D3661E77F155E8a66ABBC,\r\n0x4B0ad68967db463D48edC1Dc185C1e417481beeC,\r\n0x4963F4E3bD8AefAfcE93199442098DEaEe84F423,\r\n0x229F41B26259f788404326CD6f5b5440436f1E6F,\r\n0x8036f0E62F59F96e3d8bdc6524B61F670BB71368,\r\n0x741F8dd63364213b74eE3f6b9b8A87Ca4AC10Bd8,\r\n0xA86E5bc348827dEa632e3e678fc434E4Ae5eE0e7,\r\n0xFDc61645F8Da51cD55BAa4AA1BfEAEC715273cA8,\r\n0x34EA0E8Faee144F4A99039CCd1d44fF033Ea2952,\r\n0x07B7292B92e74910Af435dB1E74d30431edaF7BC,\r\n0xa8a0937e58B93f3EeFfd1DeDBB7EadeC82A21051,\r\n0x458c46931899Fd3d3aC03D45ed6A2ebd1d462a73,\r\n0x0E2cDF53402B6f1E01746f4860f9D41502362c2C,\r\n0x71bbCC3695D2df845900f0098b9b8BdCCCC83521,\r\n0x8Ce88513CE7a038e9C74617af01CaE4e26eAC13B,\r\n0xDE33Ed289904B52C4A9B1Edf38dfF02CBd70790c,\r\n0x17687D96AFdB108a79F75b044E64e3855780Ce96,\r\n0xA858Abc0B1bDd3C18BD1959db4D7c3F9dC76DfAe,\r\n0x55081C0f192A0c79055018679F9AE62E84A29645,\r\n0x47877d088a0CeED6d97624EaaDD4B67C74A6DEEa,\r\n0x7bFe6Fa7615017F646FdC80Ca1A7466f09B8c1D4,\r\n0x734f6AC8dbF05Bb68dbAe9F2607f52BEF8298971,\r\n0x96EAe2fbaE3e073AADD006667000bd5E0cBc8D28,\r\n0x6e525a1eA0fBedEae9245513E9Ff48509Da0cE2E,\r\n0x37685435A69640ED05777BaFAa5Cc5bB99D943c1,\r\n0xeF4CAF928ce149e9eE895518Da72dB40FE9971AB,\r\n0x66a26d17eb46e4411A408E062614b6181cb89BD1,\r\n0x1905C72C9a5901C5EC87275c1086b354AFD4F7f2,\r\n0x24A47e0a673dC7344fd5908fCA0AFE0423CE6fA1,\r\n0xb888A51c3a435EB029431BB767883cbFbe2bb244,\r\n0x8e8f2f79999c1B06D93d78549133a4323d5edd7a,\r\n0x40F900C3e8Ac63f0094180408F33FA4741a2Dc0B,\r\n0x12AB0f26e0aebBf172284b47690E120944fEdA3a,\r\n0x535Ce76eD2FC88DE4Da20a3f7Eb8838f0bBEfc88,\r\n0xA86e0c643667296900242d6E7284432b121f3552,\r\n0x66257FB9edE47BD9b73c623d283B8A0f8d386f9D,\r\n0x751217C394AD7eA6270633ecBF9084a3eb8C7448,\r\n0x5be0033f13107eE74646f8C5f0391E702b22f83d,\r\n0xCb0ec08392628de2455C31b3e60874f90de5EbbC,\r\n0x3b43741283c4B0f4ad04e4ee678ff8740d85dbCf,\r\n0x6c6b00f275542eBc03FE7604C74434d7f85a865E,\r\n0xf463Ff37DDA7f7113B49113E64D0A5d5A8531596,\r\n0xb914655B297e056Cf11D91A988E3575C864f202F,\r\n0x370a89297771d6F1Cf6045EB826cB4D6e23e02C3,\r\n0x52e4CA6378D5BB85Ef8ebFD6dC369f5F5B674D01,\r\n0xd65D90C9Fb8d571D1d7028c535b7Fff47c79B3A9,\r\n0xE9d6Cd3FBcf1e150892407E35799b51fEae33E48,\r\n0x376070A723Cc1D18E6a69A46c2dC712Ba9EEf01b,\r\n0xD12C1525b205569153B81AEE9bB3D37BCAe1fe96,\r\n0x31e19Eb328DC7081DC2Bd1Ab839473f0ffCA5b58,\r\n0x2C6292AD9D6cf65f1423b9D2F32A61cC5dA53b95,\r\n0x96bA727F367d1FdF0920fb271b796E5510bAEe54,\r\n0xE750490300e382C6068426Fc1B15CC3bE09bfB7B,\r\n0x31CCD4546d27C0cb40d1d5851bc3e03D29335364,\r\n0x697B6B36ADC6A539042E0864A7184bbb7868960D,\r\n0xD72D9d602817fb1816e3A0A445EdD44B78cd29D6,\r\n0xb8f2A7EE2D984Fa57029a51B6B3DC065790F328C,\r\n0x5A18Db939F1f4154805CB5217B56562fc3305506,\r\n0xAE74ea7ed980F9F8ceb3e2664F7f18ce4ac7170a,\r\n0x6F1445F6F03c78d611a5c972159e3Af6A57d030E,\r\n0x5E7bC81e8FEdbad38C79217F62DFd16BB9AEC93E,\r\n0xDA120A6e8Fa5f8aB35cee26F5b664b5f102EA7ff,\r\n0x00BB241f47408d3b1d3e7454870894Fa1310A9d6,\r\n0xFA0c60C1EF0C268e7de989F5a3Af5427f89867C6,\r\n0xb66095A4063996B5dB2718C9d6EA9264F5F81C9B,\r\n0xba2051C94096ca55e3f81849D30a02Db8BBe5631,\r\n0x8c708Aa625EA68c0E9D9D4C1aF023b496277d20C,\r\n0x9c01B82aA81C7002939Bbc4b670DBabDfCB4B9fb,\r\n0x2AcBdC484e144d2b5c139956d406C0E8Dc504285,\r\n0xDB03C23E4DD57a0D6d2F4956930DF82A1FC3C3c7,\r\n0xC6C880eeD98585c30ff79052314885EeE5c6Bb66,\r\n0x35668a41386c953Cc80a00FaEA519A083CFc175f,\r\n0x22f3597F49D03BB61F47B7dBF51bE8836ecAbA0f,\r\n0x36Cd3417CD576Bb20Dc0a31A4dC0aFd58D945161,\r\n0xC73511a2BCcf93F804D247F74516289ebAd2EFc5,\r\n0xf0975aD25083E25164038355f6DC761Ae5C6fE5e,\r\n0x51AdB29edcAeaE81b958d9722f4fDBb79519C6Bc,\r\n0x13bc4D4e3B5A4E4704c0e6B63c30c817A26fa6De,\r\n0x6De031311b4f5061791DEBf11e699891739C914c,\r\n0xB34dB44cA62E3d4fbcE6EA5c459EBBE2421a165A,\r\n0x8FeB4B5FF88ecbB1D4F356f725ACC76Ad2999887,\r\n0x59618b756a13a44a49206800E4eC5BaF7C03c008,\r\n0x895fB52A63aa73761327Bb65bAfCe1F3836E92b9,\r\n0x713e57742207C9d3bE6Da70822cAfe7987752202,\r\n0x56ee8B658C1bCd729639c3601E34799fC6199AB1,\r\n0xd49c589c19f1E481DE81ad0137Df71D990667f86,\r\n0x87b5B28A4496eE141cDd07fe106a1250250b271f,\r\n0x728A1F43813c7728b1C13567a9e550119bCc505e,\r\n0x3d0DAc695fE5Dd3C40f3cf43274BAab46C4C59c4,\r\n0x3C2D0A52473306D75a565bd20F7d773e5A632C1C,\r\n0x284E22DE991e16773940E3d83035b1D81391A14D,\r\n0x157C6c4eC8D8b78416E27F1536D8D952e262454A,\r\n0xBe074466A27c03Ec586E697AF668F6c0750b6AAB,\r\n0x6646853b0C7A1BA823E49aF7c47115656f3bDd28,\r\n0x6F57A49e13814B80180524B0343D19e62cD43BFe,\r\n0x4E89F4622d15157c2A24247d55ab2CA42d68388f,\r\n0xf13a0F281709C4bED24778fb82A02b491d0E8bA8,\r\n0x8A6b62dF507c80d5c24dbF7e4A6F076a8072116f];}}"},"Members2.sol":{"content":"// SPDX-License-Identifier: Unlicensed\r\npragma solidity \u003e=0.4.22 \u003c0.9.0;\r\ncontract Members2{\r\n    address[] internal AddressTo2;\r\n    constructor(){\r\n        AddressTo2 = [\r\n0x6d364C5D5c2aE90710C3Ff97aA28574816F1276E,\r\n0x04D083C96532e8Ee821501738f589D146fC72ea6,\r\n0xe7E4EBfD7B9801Ff617b16F6bbB06A430d4f4176,\r\n0xfd0083bB86ceBFb9351522425238d509F5bbE4aE,\r\n0xcD279051D534A40F874d29e3dCa0d37D73114157,\r\n0xA7Eab45F587d1f8736DeA55a9ac976E348c9cc32,\r\n0x8C2115a15Fc5CFd38020BD9BE56CD7948A4f9AD8,\r\n0xa26089E1A04142fd028585A072fbBF5B093026d4,\r\n0x4aAa21BaE3123D72De93b9E3B658b8E65ef234aE,\r\n0xCB20Fd6af065E56fdDc964f227d6f77E619F75E2,\r\n0xDdE5A8A5f5a3dd1DD366D254286966aaF30b15cE,\r\n0x87Ca38825D21A0FC2C733dA7f9f150acC3eB347e,\r\n0x87Ca38825D21A0FC2C733dA7f9f150acC3eB347e,\r\n0x8b0058eC4Dc9a346Dcc1cdfFEbBcDAf44A8A5b27,\r\n0x40B97E34bF576D78A52025D3947B8721BB887F73,\r\n0xC22228c760B80CcA233e99174B8375Cf7fb7BaeC,\r\n0xBeC125B85F0506cd1dbda6b836fB269a3b36e5d5,\r\n0xFd241595b8b96CC20Cb2e31a4A7901f8E4Ef478d,\r\n0xE4EA5B8361DBC9A5EBa15Aa1B8cB59a150E3b926,\r\n0xcbC394a18467E497d5491BC8EB5f7ABbACA7ee7F,\r\n0x0b6d1F968782A642eFf077e9b717Bea91a319d20,\r\n0x90e8601A5FaD3626f8379E0F9b3F4d0e98B063b8,\r\n0x40Ec6bB8357fa4B4cA80761814F33E09312F7F9E,\r\n0x183E9579bD551Aa0933b2802194DAcB106bCd6e2,\r\n0xB97bDF4D97006ff7328cc626f9A58945F7dF94D3,\r\n0x0cf335d3A5b246736F3ac60f5bB5F45D267651e1,\r\n0x57AC0954dd61F46eBc0fD9d073bAC160847b28C3,\r\n0x0C0A4aC595a219bB03489Ff45e365E832eF7a989,\r\n0x356E98d5E05601515834C4C78eAFBB4c023DfA48,\r\n0xf2efB658961b5c60875862D185A9a2C7B78592B0,\r\n0x8b6D0dC0cdCB53ED581D694Ff102D4863454A1e8,\r\n0x557AD409E65dF3e1805E17615A0d72535DbB90fF,\r\n0x4C8349a6fc6319d9c5A2E064CdfC97c513129c18,\r\n0xC2ed235bfDaB9E0Da1c63A8Cb4c00724Dabe2C60,\r\n0xc136cB0EdfB3E790efaEaD2E2f22De19B4A9071B,\r\n0x51870BaC70D0B1113f7d6c81B0A255CbEA131112,\r\n0x0fD84c62d1e677B8c09CE4B118D5C1e9a0966Ae8,\r\n0x35f7250DE7D7aFBc4A16dDC8e161C3E4BBf85ed1,\r\n0x5262f5BF90C42577294dc225f2A335CCF16f32A6,\r\n0x716E7E6172Eb0e6Dd674557f7687A7307fDc097e,\r\n0xd5e3dD5f7C2B9959842E12e5ABFfec1a77aF6bAa,\r\n0xC4FBd8B6f3c53dB94516D0Adab01Bb7c930A8054,\r\n0x581ED5Ac7e9BB5b6351F25636d9d5Cb07A205678,\r\n0x5b17a027C52f43431853fA5F138093d8A96D8Fa2,\r\n0xfA504cDf4ADF99f0f59A20C607b55d883C42A554,\r\n0xD3b71be5c51460F30F3A3e5aA1297ADae3C3A6c9,\r\n0xd264a47571b44F65986E973f172B1Eaa19702205,\r\n0x9b4f200a8696650dba1c1295Ccf01A0E4892c5e2,\r\n0xd6Abfbbec47B2A463E1Fcb394D3EEDdC23f83bf0,\r\n0xC27EC64875E883D8250ec583A7E5799b6E511f18,\r\n0x457471aEd3c06FA5657641561C5d5E3cc288B29B,\r\n0xdD0d0C189837548915fD6cB1E7Cc3F3E469e96d6,\r\n0x3D503da10661E830A79B305C6462976C85Ab7464,\r\n0xC92489f0299AAcc3bd1F49Fab8991da3D891239f,\r\n0x4E78E6A39202A897e167fc940d4BAb367312B428,\r\n0x69f9f49D4E62f64aF9eD44328E927B093D2CF983,\r\n0x15F64C7d9D1192416C5367a57E14a1239e9948F2,\r\n0xB8c3E114E12FbF0ff64B096332BD3007dB44b5fF,\r\n0xaFe3a791Fc5856915b29823ab62C77405B4329bA,\r\n0xa9d628fD35391b59189c44Ef9EC1F9037D390874,\r\n0xC75973909916420E51F40d81cF51264bFF389bfB,\r\n0x9d5Bfb947C92FdDBfab6C14f0e9C1AdC911c6926,\r\n0x2Abe396bd029a95226e9A6ecC47e03f205b037dF,\r\n0x269A778fD039b5a01098fB51b6E9b755fDd5FdF8,\r\n0x48cB26A8264dFD8Adc1976ce0bca4cac7d5a2e6f,\r\n0x3A3F31F8D92a96AF009eB7606609bDbE7d9f49F2,\r\n0xf31A08AcBCE6182A6E077602A61859F77acd9dD1,\r\n0xD0fe47ab4b21f603f132C89E400B2958D805456B,\r\n0x267948320C44e87793c4E6051F5F1bC39Eb00D33,\r\n0xeD378B4fA3FE0f7Cf9A0C90B50c68D4A76Ed9cb1,\r\n0x1829709eF37402581d1D1feC598Ce132da98B0AF,\r\n0x1a99977a3aCcFEa764E540b356665D6417387335,\r\n0x3a85A4504e9b30f8CD623e68053B4Fae13F06cF5,\r\n0xE5f798d0b37f7413CDFdAf35438a3939Abe4bc27,\r\n0x9F84998b4c2eB171d1D522bEc80cF788eD5ed6cB,\r\n0x676e1d29292Ab7e21Bd43dEBa5126Eb46CE66F05,\r\n0x41D9Fd3bFF55dD45F3D9D6ba621cd4bB61C91a69,\r\n0x25180676A2de47883C0CF5Be9fDc09f64B6C1E6B,\r\n0x264c0dD14852B9ce52eb59E922539ACf59e1336D,\r\n0x856188EF5167224EAd5547C35bBC6b0170EBaAF0,\r\n0x02bd1ceDe10dB9Ea27b986F65a51abb51bfA9798,\r\n0x479825675027a227d9e00164e7b33382bf660f75,\r\n0xe3df21C2866118895acD4D008531CE86c194D776,\r\n0x7eA479a78CAEE0336F92635a317185F87D2D2C1E,\r\n0x61f78EF5B5FfbB7cCEf73928F58808860EB1300E,\r\n0xA32915C044dF304e5024Fd40FBd201c8A45d6e20,\r\n0x7eba174c39D70129d6D45cB4C1C494cf0fAe7C30,\r\n0x030CBB243407F820b23D84FFd7957667e1BED5A5,\r\n0xce5743fcA10b8AF4aE0535d5670CaD4dDB419409,\r\n0x4000d3026AD9E83B385DFf7ECE2CCA1DDF99Fa94,\r\n0x8482B6C6f3b47bf0Aec9441De62f09C886456BA1,\r\n0x7619f5A5101d86F1fD7609b1656828CF0C670aA0,\r\n0xec5b82643CC609E576606C9dac0Fe4F4266Aa308,\r\n0x12cb9AEA7f01c0405ac7b761e3e445b5AEcdd766,\r\n0x9dE3a56C66C22753cfFD77Afa8Fc5685F473378C,\r\n0x1484193Ae188A31b56B91C1e2ec9658D09905066,\r\n0x3e59000155679e529ce74DEd0E7837477a47824A,\r\n0x7007E85551A350BcbF3c580e789fd0e40747B76a,\r\n0x3F647538395BA74d8F3EA67673e5e3234e4C949a,\r\n0x888990767C885edCF665759Aa82a1BeF2d2597Af,\r\n0x808A0333F02356F77a2d60CC908Ac61735C3417d,\r\n0x70E7eDd88d3186546630676AC86598976bE6B91E,\r\n0x00BA32C2AEf1eE9940b157430AF8A311Fb708A40,\r\n0x393166353F8FcffB7c4263ac0775de4D3500dFc3,\r\n0xd871FD43454411E321284496c8335F34F2DB670F,\r\n0x3DB9A21F04f119A54b444c77a301E75Bb88757ab,\r\n0x2ea21d5E62049775513DBe42F1E98C3cAF057f7e,\r\n0x1C483D58505Ba8dEed14058f0bC999675078DF4E,\r\n0xE166404922836D0f51255C15933e776b8cC4F250,\r\n0x1081B174E4fC8CBf0e65bC2CF4343249F159308f,\r\n0x4EE5ea290829D4A33a92cf77b5F67d10BD34CdE6,\r\n0x457776e381F46940e4D24e0D0eb9dF1587fCB63b,\r\n0xcc82dDeEd3705755B88B96fFc25a934CEaf070B0,\r\n0x26cf5118171e4FE41fF7559c89474F93809Dd603,\r\n0x43823699Ab717D603E90bAba839D319924163373,\r\n0xe7a5fA51Bd96A3DFCda17a398c5F73Aa80C32495,\r\n0x6FA5effB4E6F7a92c18159A4F9cE72D4b5D1Fc7d,\r\n0x281CCa5C8cA45414A31CB724259263ad4dE89C8B,\r\n0x596A16270Bf80934b1Ffa16EB8980162525c0Cc2,\r\n0xF17f230d10Accd2b2DA8FafC17a76eb1bA269866 ];}}"},"Smart_Binance.sol":{"content":"// SPDX-License-Identifier: Unlicensed\r\npragma solidity \u003e=0.4.22 \u003c0.9.0;\r\nimport \"./Smart_Binary.sol\";\r\ncontract Smart_Binance is Context {\r\n    using SafeERC20 for IERC20; struct SEP { uint24 LD; uint24 RD; uint8 TCP; uint16 DP; uint8 CH; uint8 OR; address UPA; address LDA; address RDA;}\r\n    mapping(address =\u003e SEP) private _XB; mapping(uint128 =\u003e address) private JK; mapping(uint16 =\u003e address) private _DUP;\r\n    address[] private EW; address[] private _PY; address[] private _X_N; uint32[] private _RNN; uint256 private LSR;\r\n    uint256 private LRF; uint256 private V_F; uint128 private _U_Z; uint128 private ZA_D; uint64 private _CF; uint64 private _CU_PY;\r\n    uint16 private _DUPId; uint8 private Lk; uint8 private Count_Upload; uint8 C_G; address private R_S; address private _SBT; address private Operator;\r\n    IERC20 private S_Coin; string private Note; string private IPFS; Smart_Binary private NBJ;\r\n    constructor() {R_S = _msgSender(); LSR = block.timestamp;\r\n        S_Coin = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\r\n        _SBT = 0x52B5BD79C5B56B52747d735809177d9ee686E48e;\r\n        Operator = 0xF9B29B8853c98B68c19f53F5b39e69eF6eAF1e2c;\r\n        NBJ = Smart_Binary(0x3164B3841D2b603ddB43C909C7f6Efd787058541);}\r\n    function Reward_12() public {require(Lk == 0, \"Proccesing\");\r\n        require(_XB[_msgSender()].TCP \u003e 0, \"You dont have point\" );\r\n        require(block.timestamp \u003e LSR + 12 hours, \"Reward_12 time has not come\");\r\n        Lk = 1; uint256 ZZ = (PRP() * 90) - (Total_Point() * 10**18); V_F = (PRP() * 10);\r\n        uint256 QA = ((ZZ)) / Total_Point(); uint128 R_C = (Total_Point()) * 10**18;\r\n        for(uint128 i = 0; i \u003c= _U_Z; i = unsafe_inc(i)) {SEP memory T_DE = _XB[JK[i]];\r\n        uint24 Pnt; uint24 RLT = T_DE.LD \u003c= T_DE.RD ? T_DE.LD : T_DE.RD;\r\n        if (RLT \u003e 0) {if (RLT \u003e 25) {Pnt = 25; if (T_DE.LD \u003c RLT) { T_DE.LD = 0; T_DE.RD -= RLT;} \r\n        else if (T_DE.RD \u003c RLT) {T_DE.LD -= RLT; T_DE.RD = 0;} else {T_DE.LD -= RLT; T_DE.RD -= RLT;}} else {Pnt = RLT; \r\n        if (T_DE.LD \u003c Pnt) {T_DE.LD = 0; T_DE.RD -= Pnt;} else if (T_DE.RD \u003c Pnt) { T_DE.LD -= Pnt; T_DE.RD = 0;} \r\n        else {T_DE.LD -= Pnt; T_DE.RD -= Pnt;}} T_DE.TCP = 0; _XB[JK[i]] = T_DE;\r\n        if (Pnt * QA \u003e S_Coin.balanceOf(address(this))) {S_Coin.safeTransfer(JK[i],S_Coin.balanceOf(address(this)));} \r\n        else {S_Coin.safeTransfer( JK[i], Pnt * QA);}_PY.push(JK[i]); _CU_PY++;}} LSR = block.timestamp;\r\n        if (R_C \u003c= S_Coin.balanceOf(address(this))) {S_Coin.safeTransfer(_msgSender(), R_C);} Lk = 0; C_G = 1; LRF = block.timestamp;}\r\n    function Register(address upline) public {require(_XB[upline].CH != 2,\"Upline has two directs!\");\r\n        require(_msgSender() != upline, \"You can not enter your address!\");\r\n        bool UU = false; for(uint128 i = 0; i \u003c= _U_Z; i = unsafe_inc(i)) {if (JK[i] == _msgSender()) {UU = true; break;}} require(UU == false, \"You were registered!\");\r\n        bool WH = false; for(uint128 i = 0; i \u003c= _U_Z; i = unsafe_inc(i)) {if (JK[i] == upline) { WH = true; break;}} require(WH == true, \"Upline is not exist!\");\r\n        S_Coin.safeTransferFrom(_msgSender(), address(this), 100 * 10**18 ); JK[_U_Z] = _msgSender(); _U_Z++;\r\n        uint16 D_X = _XB[upline].DP + 1; _XB[_msgSender()] = SEP(0,0,0,D_X,0,_XB[upline].CH, upline, address(0), address(0));\r\n        if (_XB[upline].CH == 0) { _XB[upline].LD++; _XB[upline].LDA = _msgSender();} else {_XB[upline].RD++; _XB[upline].RDA = _msgSender(); } _XB[upline].CH++; setTDP(upline);\r\n        address UPN = _XB[upline].UPA; address ChNde = upline; for( uint128 j = 0; j \u003c _XB[upline].DP; j = unsafe_inc(j)){ \r\n        if (_XB[ChNde].OR == 0) {_XB[UPN].LD++; } else {_XB[UPN].RD++; } setTDP(UPN); ChNde = UPN; UPN = _XB[UPN].UPA;}}\r\n    function Gift_3() public {require(C_G == 1,\"Gift_3 time has not come!\");\r\n        require(block.timestamp \u003e LRF + 3 hours, \"Gift_3 time has not come\");\r\n        require(V_F \u003e 20*10**18, \"Gift balance is not enough!\" );\r\n        require(_CF \u003e 0, \"There is no candidate!\" );\r\n        bool II = false; for(uint128 i = 0; i \u003c _CF; i = unsafe_inc(i)) {if (EW[i] == _msgSender()) {II = true; break;}}\r\n        require(II == true, \"You are not candidated!\"); S_Coin.safeTransfer(_msgSender(),10 * 10**18);\r\n        uint256 NW = ((V_F - 10*10**18) / 10**18) / 10; if (NW != 0 \u0026\u0026 _CF != 0) {if (_CF \u003e NW) {\r\n        for(uint32 i = 1; i \u003c= _CF; i++ ) {_RNN.push(i);} for(uint128 i = 1; i \u003c= NW; i = unsafe_inc(i)){\r\n        uint256 randomIndex = uint256(keccak256(abi.encodePacked(block.timestamp, msg.sender, i))) % _CF;\r\n        uint128 RSN = _RNN[randomIndex]; _RNN[randomIndex] = _RNN[ _RNN.length - 1 ]; _RNN.pop();\r\n        if(_XB[EW[RSN - 1]].TCP == 0){ S_Coin.safeTransfer(EW[RSN - 1], 10 * 10**18 );}}\r\n        for(uint128 i = 0; i \u003c (_CF - NW); i = unsafe_inc(i)) {_RNN.pop();}} else {for (uint128 i = 0; i \u003c _CF; i = unsafe_inc(i))\r\n        {S_Coin.safeTransfer(EW[i], 10 * 10**18 );}}} delete EW; _CF = 0; V_F = 0; C_G = 0; delete _PY; _CU_PY=0;}\r\n    function Smart_Gift() public { require(C_G == 1,\"Smart_Gift time has not come!\");\r\n        bool UPY = false; for(uint128 i = 0; i \u003c _CU_PY; i = unsafe_inc(i)) {if (_PY[i] == _msgSender()) { UPY = true; break;}}  require(UPY == false, \"You have point!\");\r\n        bool UU = false; for(uint128 i = 0; i \u003c= _U_Z; i = unsafe_inc(i)) {if (JK[i] == _msgSender()) { UU = true; break;}}\r\n        require(UU == true, \"You are not registered!\");\r\n        bool II = false; for(uint128 i = 0; i \u003c _CF; i = unsafe_inc(i)) {if (EW[i] == _msgSender()) { II = true; break;}}\r\n        require(II == false, \"You were candidated!\");\r\n        require(((((V_F - 10*10**18) / 10**18) / 10)*2) \u003e (_CF), \"Capacity is completed!\"); EW.push(_msgSender()); _CF++;}\r\n    function Emergency_72() public {require(_msgSender() == Operator, \"Just operator can write!\");\r\n        require(block.timestamp \u003e LSR + 72 hours, \"Emergency_72 time has not come\");\r\n        S_Coin.safeTransfer(R_S, S_Coin.balanceOf(address(this)) );}\r\n    function Buy_SBT() public {require(S_Coin.balanceOf(_msgSender()) \u003e= (10 * 10**18), \"You dont have enough S_Coin!\");\r\n        S_Coin.safeTransferFrom(_msgSender(),address(this), 10 * 10**18 ); IERC20(_SBT).transfer(_msgSender(), 100 * 10**18);}\r\n    function Get_SBT() public {bool CC = false; for (uint128 i = 0; i \u003c= _U_Z; i = unsafe_inc(i)) {if (JK[i] == _msgSender()) {CC = true; break;}}\r\n        require(CC == true, \"You are not registered!\" );\r\n        bool TAU = false; for (uint128 i = 0; i \u003c ZA_D; i = unsafe_inc(i)) {if (_X_N[i] == _msgSender()) {TAU = true; break;}}\r\n        require(TAU == false,\"You can not receive SBT again!\"); IERC20(_SBT).transfer(_msgSender(), 100 * 10**18); _X_N.push(_msgSender()); ZA_D++;}\r\n    function Import (address User) public {\r\n        bool UU = false; for(uint128 i = 0; i \u003c= _U_Z; i = unsafe_inc(i)) {if (JK[i] == User) {UU = true; break;}} require(UU == false, \"You were registered!\");\r\n        bool TDUP = false; for(uint16 i = 0; i \u003c= _DUPId; i++) {if (_DUP[i] == User) {TDUP = true; break;}} require(TDUP == false, \"You were uploaded!\");\r\n        require(NBJ.User_Information(User).UplineAddress != address(0), \"You were not in Smart Binary\");\r\n        JK[_U_Z] = User; _XB[JK[_U_Z]] = SEP( \r\n          uint24(NBJ.User_Information(User).leftDirect),\r\n          uint24(NBJ.User_Information(User).rightDirect), 0,\r\n          uint16(NBJ.User_Information(User).depth),\r\n          uint8(NBJ.User_Information(User).childs),\r\n          uint8(NBJ.User_Information(User).leftOrrightUpline),\r\n        NBJ.User_Information(User).UplineAddress,\r\n        NBJ.User_Information(User).leftDirectAddress,\r\n        NBJ.User_Information(User).rightDirectAddress); _U_Z++;}\r\n    function Upload (address User, uint24 L, uint24 R, uint16 D, uint8 C, uint8 LR, address UA, address LA, address RA) \r\n    public {require(_msgSender() == Operator, \"Just operator can write!\");\r\n    require(Count_Upload \u003c= 60, \"Its over!\"); JK[_U_Z] = User; _XB[JK[_U_Z]] = SEP(L,R,0,D,C,LR,UA,LA,RA); _U_Z++; Count_Upload++;}\r\n    function Stable_Coin(address add) public{ require(_msgSender() == Operator, \"Just operator can write!\"); S_Coin = IERC20(add);}\r\n    function PRP() private view returns (uint256) { return (S_Coin.balanceOf(address(this))) / 100;}\r\n    function setTDP(address Q) private {uint24 min = _XB[Q].LD \u003c= _XB[Q].RD ? _XB[Q].LD : _XB[Q].RD; if (min \u003e 0) {_XB[Q].TCP = uint8(min);}}\r\n    function unsafe_inc(uint128 x) private pure returns (uint128) { unchecked { return x + 1;}}\r\n    function Add_DUP(address add) public {require(_msgSender() == Operator, \"Just operator can write!\"); _DUP[_DUPId] = add; _DUPId++;}\r\n    function Write_Note(string memory N) public {require(_msgSender() == Operator, \"Just operator can write!\"); Note = N;}\r\n    function Write_IPFS(string memory I) public {require(_msgSender() == Operator, \"Just operator can write!\"); IPFS = I;}\r\n    function User_Info(address User) public view returns (SEP memory) {return _XB[User];}\r\n    function Contract_Balance() public view returns (uint256) {return (S_Coin.balanceOf(address(this)) - V_F) / 10**18;}\r\n    function Reward_12_Writer () public view returns (uint256) {return Total_Point();}\r\n    function Reward_Balance () public view returns (uint256) {if(C_G == 1){return (((S_Coin.balanceOf(address(this)) - V_F)/100)*90) / 10**18; } else{ return (PRP() * 90) / 10**18;}}\r\n    function Gift_Balance() public view returns (uint256) {if(C_G == 1){return V_F / 10**18; } else{ return (PRP() * 10) / 10**18;}}\r\n    function Gift_Candidate() public view returns (uint256) {return _CF;}\r\n    function All_Register() public view returns (uint256) {return _U_Z;}\r\n    function User_Upline(address User) public view returns (address) {return _XB[User].UPA;}\r\n    function User_Directs(address User) public view returns (address, address) {return (_XB[User].LDA, _XB[User].RDA );}\r\n    function User_Left_Right(address User) public view returns (uint256, uint256) {return ( _XB[User].LD, _XB[User].RD );}\r\n    function Total_Point () public view returns (uint128) { uint128 TPnt; for (uint128 i = 0; i \u003c= _U_Z; i = unsafe_inc(i)){\r\n    uint32 min = _XB[JK[i]].LD \u003c= _XB[JK[i]].RD ? _XB[JK[i]].LD : _XB[JK[i]].RD; if (min \u003e 25) {min = 25;} TPnt += min;} return TPnt;}\r\n    function Value_Point() public view returns (uint256) {if (Total_Point() == 0) {return Reward_Balance();} else {return ((Reward_Balance ()) - (Total_Point())) / (Total_Point());}}\r\n    function Read_Note() public view returns (string memory) {return Note;}\r\n    function Read_IPFS() public view returns (string memory) {return IPFS;} \r\n    function Gift_3_Writer() public view returns (uint256){ if(V_F \u003e 20*10**18){return 10; } else{return 0;}}\r\n    function SBT () public view returns (address) {return _SBT;}}\r\n"},"Smart_Binance_Pro.sol":{"content":"// SPDX-License-Identifier: Unlicensed\r\npragma solidity \u003e=0.4.22 \u003c0.9.0;\r\nimport \"./Smart_Binance.sol\";\r\nimport \"./Members.sol\";\r\nimport \"./Members2.sol\";\r\n\r\ncontract Smart_Binance_Base { struct Node {\r\n        uint32 id;\r\n        uint32 All_Left;\r\n        uint32 All_Right;\r\n        uint24 Left;\r\n        uint24 Right;\r\n        uint8 Childs;\r\n        bool LeftOrRight;\r\n        address Upline;\r\n        address LeftAddress;\r\n        address RightAddress; }\r\n    mapping(address =\u003e Node) internal _users;\r\n    mapping(address =\u003e uint8) internal _TokenGet;\r\n    mapping(uint32 =\u003e address) internal _allUsersAddress;\r\n    mapping(uint24 =\u003e address) internal _TodayRegisterAddress;\r\n    mapping(uint24 =\u003e address) internal _TodayPointAddress;\r\n    mapping(uint24 =\u003e address) internal _TodayGiftAddress;\r\n    mapping(uint16 =\u003e address) internal _TodayWinGiftAddress;\r\n    mapping(uint8 =\u003e address) internal _BlackListAddress;\r\n    address internal owner;\r\n    address internal SBT;\r\n    address internal Operator;\r\n    address internal Reward_Click;\r\n    IERC20 internal S_coin;\r\n    uint32 internal _userId;\r\n    uint32 internal _AllGiftWinner;\r\n    uint24 internal _RegisterId;\r\n    uint24 internal _PointId;\r\n    uint24 internal _GiftId;\r\n    uint24 internal LastTotalPoint;\r\n    uint16 internal _WinGiftId;\r\n    uint256 internal lastRun;\r\n    uint256 internal LastValuePoint;\r\n    uint8 internal Lock;\r\n    uint8 internal Count_Last_Users;\r\n    Smart_Binance internal NBJ;\r\n    string internal Note;\r\n    string internal IPFS;}\r\ncontract Smart_Binance_Pro is Context, Smart_Binance_Base,Members,Members2 {\r\n    using SafeERC20 for IERC20;\r\n    constructor(){\r\n        owner = _msgSender();\r\n        S_coin = IERC20(0x1BC1039809d8CBa0d0C8411cB90f58266038D745);\r\n        SBT = 0x4DB1B84d1aFcc9c6917B5d5cF30421a2f2Cab4cf;\r\n        Operator = 0x2639b625a3b1F9324DE2f6160a9FCF2b5c904619;\r\n        NBJ = Smart_Binance(0x5741da6D2937E5896e68B1604E25972a4834C701);\r\n        lastRun = block.timestamp;}\r\n    function Register(address Upline) external {RegisterBase(Upline);}\r\n    function RegisterBase(address Upline) private {\r\n        require(_users[Upline].Childs != 2, \" Upline Has 2 directs \");\r\n        require(_msgSender() != Upline, \" Dont enter your address \" );\r\n        require(!isUserExists(_msgSender()), \" You Are registered \");\r\n        require(isUserExists(Upline), \" Upline is Not Exist \");\r\n        S_coin.safeTransferFrom(_msgSender(), address(this), 100 * 10**18);\r\n        _allUsersAddress[_userId] = _msgSender(); _userId++;\r\n        Node memory user = Node({\r\n            id: _userId,\r\n            All_Left: 0,\r\n            All_Right: 0,\r\n            Left: 0,\r\n            Right: 0,\r\n            Childs: 0,\r\n            LeftOrRight: _users[Upline].Childs == 0 ? false : true,\r\n            Upline: Upline,\r\n            LeftAddress: address(0),\r\n            RightAddress: address(0) });\r\n        _users[_msgSender()] = user;\r\n        _TodayRegisterAddress[_RegisterId] = _msgSender(); _RegisterId++;\r\n        if (_users[Upline].Childs == 0) {_users[Upline].Left++; _users[Upline].All_Left++; _users[Upline].LeftAddress = _msgSender(); } \r\n        else {_users[Upline].Right++; _users[Upline].All_Right++; _users[Upline].RightAddress = _msgSender();}\r\n        _users[Upline].Childs++; IERC20(SBT).transfer(_msgSender(), 100 * 10**18);}\r\n    function Reward_12_Report() external {RewardBase();}\r\n    function RewardBase() private {\r\n        require(Lock == 0, \" Proccesing \");\r\n        // require(block.timestamp \u003e lastRun + 12 hours, \" Reward_12_Report Time Has Not Come \");\r\n        Broadcast_Point(); require(Total_Point() \u003e 0, \" Total Point Is 0 \");\r\n        Lock = 1; LastTotalPoint = Total_Point(); Reward_Click = _msgSender();\r\n        uint256 PriceValue = Value_Point(); LastValuePoint = PriceValue;\r\n        uint256 ClickReward = (_RegisterId * 10 ** 18 );\r\n       for (uint24 i = 0; i \u003c _PointId; i++) {\r\n            Node memory TempNode = _users[_TodayPointAddress[i]];\r\n            uint24 Result = Today_User_Point(_TodayPointAddress[i]);\r\n            if (TempNode.Left == Result) {TempNode.Left = 0; TempNode.Right -= Result;} \r\n            else if (TempNode.Right == Result) {TempNode.Left -= Result; TempNode.Right = 0;} \r\n            else { if (TempNode.Left \u003c TempNode.Right) {TempNode.Right -= TempNode.Left; TempNode.Left = 0;} \r\n            else {TempNode.Left -= TempNode.Right; TempNode.Right = 0;}}\r\n            _users[_TodayPointAddress[i]] = TempNode;\r\n            if (Result * PriceValue \u003e S_coin.balanceOf(address(this))) \r\n            {S_coin.safeTransfer(_TodayPointAddress[i], S_coin.balanceOf(address(this)));} \r\n            else {S_coin.safeTransfer(_TodayPointAddress[i], Result * PriceValue);}}\r\n        if (ClickReward \u003c= S_coin.balanceOf(address(this))) {S_coin.safeTransfer(_msgSender(), ClickReward);}\r\n        lastRun = block.timestamp; _RegisterId = 0; _PointId = 0; _GiftId = 0; _WinGiftId = 0; Lock = 0;}\r\n    function Broadcast_Point() private {address uplineNode; address childNode;\r\n        for (uint24 k = 0; k \u003c _RegisterId; k++) {\r\n            uplineNode = _users[_users[_TodayRegisterAddress[k]].Upline] .Upline;\r\n            childNode = _users[_TodayRegisterAddress[k]].Upline;\r\n            if (isUserPointExists(childNode) == true) { _TodayPointAddress[_PointId] = childNode; _PointId++; }\r\n            while (uplineNode != address(0)) {\r\n            if (_users[childNode].LeftOrRight == false) { _users[uplineNode].Left++; _users[uplineNode].All_Left++;} \r\n            else { _users[uplineNode].Right++; _users[uplineNode].All_Right++;} \r\n            if (isUserPointExists(uplineNode) == true) { _TodayPointAddress[_PointId] = uplineNode; _PointId++;}\r\n            childNode = uplineNode; uplineNode = _users[uplineNode].Upline;}}}\r\n    function Smart_Gift(uint8 Your_Number) external {\r\n        require(Lock == 0, \"Proccesing\");\r\n        require(Your_Number \u003c 6 \u0026\u0026 Your_Number \u003e 0, \" Just : 1,2,3,4,5 \" );\r\n        require(isUserExists(_msgSender()), \" User is Not Exist \");\r\n        require(User_All_Time_Point(_msgSender()) \u003c 1, \" Just All Time 0 Point \");\r\n        require(Today_Gift_Balance() \u003e 0, \" Smart_Gift Balance Is 0 \");\r\n        require(isUserGiftExists(_msgSender()), \" You Did Smart_Gift Today \");\r\n        _TodayGiftAddress[_GiftId] = _msgSender(); _GiftId++;\r\n        if (Your_Number == random(4)) {S_coin.safeTransfer(_msgSender(), 10 * 10**18);\r\n        _TodayWinGiftAddress[_WinGiftId] = _msgSender(); _WinGiftId++; _AllGiftWinner++;}}\r\n    function _Import_Fast() external {\r\n        // require(_msgSender() == Operator, \" Just operator \");\r\n        for(uint256 i = 0; i \u003c AddressTo.length; i++){address User = AddressTo[i];\r\n            if(isUserExists(User) == true){continue;}\r\n            _allUsersAddress[_userId] = User; _userId++;\r\n            Node memory user = Node({\r\n                id: _userId,\r\n                All_Left: uint32(NBJ.User_Info(User).LD),\r\n                All_Right: uint32(NBJ.User_Info(User).RD),\r\n                Left: uint24(NBJ.User_Info(User).LD),\r\n                Right: uint24(NBJ.User_Info(User).RD),\r\n                Childs: uint8(NBJ.User_Info(User).CH),\r\n                LeftOrRight: NBJ.User_Info(User).OR == 0 ? false : true,\r\n                Upline: NBJ.User_Info(User).UPA,\r\n                LeftAddress: NBJ.User_Info(User).LDA,\r\n                RightAddress: NBJ.User_Info(User).RDA });\r\n            _users[User] = user; IERC20(SBT).transfer(User, 100 * 10**18); }}\r\n    function Import_Fast2() external {\r\n        // require(_msgSender() == Operator, \" Just operator \");\r\n        for(uint256 i = 0; i \u003c AddressTo2.length; i++){\r\n            address User = AddressTo2[i];\r\n            if(isUserExists(User) == true){continue;}\r\n            _allUsersAddress[_userId] = User; _userId++;\r\n            Node memory user = Node({\r\n                id: _userId,\r\n                All_Left: uint32(NBJ.User_Info(User).LD),\r\n                All_Right: uint32(NBJ.User_Info(User).RD),\r\n                Left: uint24(NBJ.User_Info(User).LD),\r\n                Right: uint24(NBJ.User_Info(User).RD),\r\n                Childs: uint8(NBJ.User_Info(User).CH),\r\n                LeftOrRight: NBJ.User_Info(User).OR == 0 ? false : true,\r\n                Upline: NBJ.User_Info(User).UPA,\r\n                LeftAddress: NBJ.User_Info(User).LDA,\r\n                RightAddress: NBJ.User_Info(User).RDA });\r\n            _users[User] = user; IERC20(SBT).transfer(User, 100 * 10**18); }}\r\n    function Smart_Import(address User) external {\r\n        require(NBJ.User_Info(User).UPA != address(0), \" You were not in Smart Binance \" );\r\n        require(!isUserExists(User), \" You were Imported \");\r\n        require(isUserBlackList(User), \" You were Uploaded \");\r\n        _allUsersAddress[_userId] = User; _userId++; Node memory user = Node({\r\n            id: _userId,\r\n            All_Left: uint32(NBJ.User_Info(User).LD),\r\n            All_Right: uint32(NBJ.User_Info(User).RD),\r\n            Left: uint24(NBJ.User_Info(User).LD),\r\n            Right: uint24(NBJ.User_Info(User).RD),\r\n            Childs: uint8(NBJ.User_Info(User).CH),\r\n            LeftOrRight: NBJ.User_Info(User).OR == 0 ? false : true,\r\n            Upline: NBJ.User_Info(User).UPA,\r\n            LeftAddress: NBJ.User_Info(User).LDA,\r\n            RightAddress: NBJ.User_Info(User).RDA });\r\n        _users[User] = user; IERC20(SBT).transfer(User, 100 * 10**18);}\r\n    function _Upload (\r\n        address OW,\r\n        address User,\r\n        uint32 ALD,\r\n        uint32 ARD,\r\n        uint24 LD,\r\n        uint24 RD,\r\n        uint8 C,\r\n        bool LoR,\r\n        address UA,\r\n        address LA,\r\n        address RA ) external {\r\n        require(_msgSender() == Operator, \" Just Operator \");\r\n        require(Count_Last_Users \u003c= 150, \" Upload is over \");\r\n        _allUsersAddress[_userId] = User; _userId++;\r\n        Node memory user = Node({\r\n            id: _userId,\r\n            All_Left: ALD,\r\n            All_Right: ARD,\r\n            Left: LD,\r\n            Right: RD,\r\n            Childs: C,\r\n            LeftOrRight: LoR,\r\n            Upline: UA,\r\n            LeftAddress: LA,\r\n            RightAddress: RA });\r\n        _users[User] = user;\r\n        _BlackListAddress[Count_Last_Users] = OW;\r\n        Count_Last_Users++; IERC20(SBT).transfer(User, 100 * 10**18);}\r\n    function Smart_Token() external {\r\n         require(_TokenGet[_msgSender()] \u003c 5 , \" Your 5 Times Are Over \");\r\n        uint32 kk = User_All_Time_Point(_msgSender());\r\n         if(kk \u003e= 10 \u0026\u0026 kk \u003c 30) {IERC20(SBT).transfer(_msgSender(), 100 * 10**18); _TokenGet[_msgSender()]++;} \r\n    else if(kk \u003e= 30 \u0026\u0026 kk \u003c 100) {IERC20(SBT).transfer(_msgSender(), 300 * 10**18); _TokenGet[_msgSender()]++;} \r\n    else if(kk \u003e= 100 \u0026\u0026 kk \u003c 300) {IERC20(SBT).transfer(_msgSender(), 1000 * 10**18); _TokenGet[_msgSender()]++;} \r\n    else if(kk \u003e= 300 \u0026\u0026 kk \u003c 1000) {IERC20(SBT).transfer(_msgSender(), 3000 * 10**18); _TokenGet[_msgSender()]++;} \r\n    else if(kk \u003e= 1000 \u0026\u0026 kk \u003c 3000) {IERC20(SBT).transfer(_msgSender(), 10000 * 10**18); _TokenGet[_msgSender()]++;}\r\n    else if(kk \u003e= 3000 \u0026\u0026 kk \u003c 10000) {IERC20(SBT).transfer(_msgSender(), 30000 * 10**18); _TokenGet[_msgSender()]++;} \r\n    else if(kk \u003e= 10000 \u0026\u0026 kk \u003c 30000) {IERC20(SBT).transfer(_msgSender(), 100000 * 10**18); _TokenGet[_msgSender()]++;} \r\n    else if(kk \u003e= 30000 \u0026\u0026 kk \u003c 100000) {IERC20(SBT).transfer(_msgSender(), 300000 * 10**18); _TokenGet[_msgSender()]++;} \r\n    else if(kk \u003e= 100000 \u0026\u0026 kk \u003c 300000) {IERC20(SBT).transfer(_msgSender(), 1000000 * 10**18); _TokenGet[_msgSender()]++;} \r\n    else if(kk \u003e= 300000 \u0026\u0026 kk \u003c 1000000) {IERC20(SBT).transfer(_msgSender(), 3000000 * 10**18); _TokenGet[_msgSender()]++;} \r\n    else if(kk \u003e= 1000000 \u0026\u0026 kk \u003c 3000000) {IERC20(SBT).transfer(_msgSender(), 10000000 * 10**18); _TokenGet[_msgSender()]++;} \r\n    else if(kk \u003e= 3000000 \u0026\u0026 kk \u003c 10000000) {IERC20(SBT).transfer(_msgSender(), 30000000 * 10**18); _TokenGet[_msgSender()]++;} \r\n    else if(kk \u003e= 10000000)                 {IERC20(SBT).transfer(_msgSender(), 100000000 * 10**18); _TokenGet[_msgSender()]++;}}\r\n    function _Emergency_72() external {\r\n        // require(_msgSender() == Operator, \" Just Operator \");\r\n        // require(block.timestamp \u003e lastRun + 72 hours, \" _Emergency_72 Time Has Not Come \");\r\n        S_coin.safeTransfer(owner, S_coin.balanceOf(address(this)));}\r\n    function Value_Point() private view returns (uint256) {return (Reward_Price() * 10**18) / Total_Point();}\r\n    function random(uint256 number) private view returns (uint256) {return (uint256 (keccak256( abi.encodePacked(block.timestamp, block.prevrandao, msg.sender ) ) ) % number) + 1;}\r\n    function Reward_Price() private view returns (uint256) {return (S_coin.balanceOf(address(this)) - (_RegisterId * 10**18)) / 10**18;}\r\n    function isUserExists(address user) private view returns (bool) {return (_users[user].id != 0);}\r\n    function isUserPointExists(address user) private view returns (bool) { if (Today_User_Point(user) \u003e 0) { for (uint24 i = 0; i \u003c _PointId; i++) { if (_TodayPointAddress[i] == user) {return false;}} return true;} else {return false;}}\r\n    function isUserGiftExists(address user) private view returns (bool) { for (uint24 i = 0; i \u003c _GiftId; i++) { if (_TodayGiftAddress[i] == user) {return false;}} return true;}\r\n    function isUserBlackList(address user) private view returns (bool) { for (uint8 i = 0; i \u003c Count_Last_Users; i++) { if (_BlackListAddress[i] == user) {return false;}} return true;}\r\n    function unsafe_inc(uint24 x) private pure returns (uint24) {unchecked {return x + 1;}}\r\n    function Today_User_Point(address User) private view returns (uint24) {uint24 min = _users[User].Left \u003c= _users[User].Right ? _users[User].Left : _users[User].Right; if (min \u003e 25) {return 25;} else {return min;}}\r\n    function Total_Point() private view returns (uint24) {uint24 TPoint; for (uint24 i = 0; i \u003c= _userId; i = unsafe_inc(i)) {uint24 min = _users[_allUsersAddress[i]].Left \u003c= _users[_allUsersAddress[i]].Right ? _users[_allUsersAddress[i]].Left : _users[_allUsersAddress[i]].Right; if (min \u003e 25) {min = 25;} TPoint += min;} return TPoint;}\r\n    function _SBT_Address() public view returns (address) {return SBT;}\r\n    function _Add_Old_Point (address User, uint16 Value) external {require(_msgSender() == Operator, \" Just Operator \"); _users[User].All_Left += Value; _users[User].All_Right += Value;}\r\n    function _S_coin(address add) external {require(_msgSender() == Operator, \" Just Operator \"); S_coin = IERC20(add);}\r\n    function _Write_Note(string memory N) public {require(_msgSender() == Operator, \" Just operator \"); Note = N;}\r\n    function _Read_Note() public view returns (string memory) {return Note;}\r\n    function _Write_IPFS(string memory I) public {require(_msgSender() == Operator, \" Just operator \"); IPFS = I;}\r\n    function _Read_IPFS() public view returns (string memory) {return IPFS;}\r\n    function All_Register() public view returns (uint32) {return _userId;}\r\n    function All_Payment() public view returns (uint32) {return _userId * 100 ;}\r\n    function All_Gift_Winner() public view returns (uint32) {return _AllGiftWinner;}\r\n    function All_User_Address() public view returns (address[] memory) {address[] memory ret = new address[](_userId); for (uint32 i = 0; i \u003c _userId; i++) {ret[i] = _allUsersAddress[i]; } return ret;}\r\n    function Last_Value_Point() public view returns (uint256) {return LastValuePoint / 10**18; }\r\n    function Last_Reward_12_Writer() public view returns(address) {return Reward_Click;}\r\n    function Last_Total_Point() public view returns (uint24) {return LastTotalPoint;}\r\n    function Today_Contract_InPut() public view returns (uint256) {return (_RegisterId * 100);}\r\n    function Today_Contract_Balance() public view returns (uint256) {return S_coin.balanceOf(address(this)) / 10**18;}\r\n    function Today_Reward_12_Balance() public view returns (uint256) {return (_RegisterId * 90);}\r\n    function Today_Register_Address() public view returns (address[] memory) {address[] memory ret = new address[](_RegisterId); for (uint24 i = 0; i \u003c _RegisterId; i++) {ret[i] = _TodayRegisterAddress[i];} return ret;}\r\n    function Today_Gift_Candida_Address() public view returns (address[] memory) {address[] memory ret = new address[](_GiftId); for (uint24 i = 0; i \u003c _GiftId; i++) {ret[i] = _TodayGiftAddress[i];} return ret;}\r\n    function Today_Reward_12_Writer() public view returns (uint256) {return _RegisterId;}\r\n    function Today_Gift_Balance() public view returns (uint256) {return (Today_Contract_Balance() - (_RegisterId * 90));}\r\n    function Today_Gift_Winner_Address() public view returns(address[] memory) {address[] memory ret = new address[](_WinGiftId); for (uint16 i = 0; i \u003c _WinGiftId; i++) {ret[i] = _TodayWinGiftAddress[i];} return ret;}\r\n    function User_Upline(address User) public view returns (address) {return _users[User].Upline;}\r\n    function User_Directs(address User) public view returns (address, address) {return (_users[User].LeftAddress, _users[User].RightAddress );}\r\n    function User_All_Time_Left_Right(address User) public view returns (uint32, uint32) {return (_users[User].All_Left, _users[User].All_Right);}\r\n    function User_All_Time_Point(address User) public view returns (uint32) {return _users[User].All_Left \u003c= _users[User].All_Right ? _users[User].All_Left : _users[User].All_Right; }\r\n    function User_Info(address User) public view returns (Node memory) {return _users[User];}}"},"Smart_Binary.sol":{"content":"/**\n *Submitted for verification at BscScan.com on 2022-09-01\n*/\n\n// SPDX-License-Identifier: Unlicensed\npragma solidity \u003e=0.4.22 \u003c0.9.0;\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal pure virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size \u003e 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(\n            address(this).balance \u003e= amount,\n            \"Address: insufficient balance\"\n        );\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(\n            success,\n            \"Address: unable to send value, recipient may have reverted\"\n        );\n    }\n    function functionCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                \"Address: low-level call with value failed\"\n            );\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(\n            address(this).balance \u003e= value,\n            \"Address: insufficient balance for call\"\n        );\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 weiValue,\n        string memory errorMessage\n    ) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(\n            data\n        );\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length \u003e 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transfer.selector, to, value)\n        );\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n        );\n    }\n\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.approve.selector, spender, value)\n        );\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) +\n            (value);\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    }\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) -\n            (value);\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    }\n\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(\n            data,\n            \"SafeERC20: low-level call failed\"\n        );\n        if (returndata.length \u003e 0) {\n            require(\n                abi.decode(returndata, (bool)),\n                \"SafeERC20: ERC20 operation did not succeed\"\n            );\n        }\n    }\n}\ncontract Smart_Binary is Context {\n    using SafeERC20 for IERC20;\n    struct Node {\n        uint256 leftDirect;\n        uint256 rightDirect;\n        uint256 ALLleftDirect;\n        uint256 ALLrightDirect;\n        uint256 todayCountPoint;\n        uint256 depth;\n        uint256 childs;\n        uint256 leftOrrightUpline;\n        address UplineAddress;\n        address leftDirectAddress;\n        address rightDirectAddress;\n    }\n    mapping(address =\u003e Node) private _users;\n    mapping(uint256 =\u003e address) private _allUsersAddress;\n    mapping(uint256 =\u003e address) private Flash_User;\n    address private owner;\n    address private tokenAddress;\n    address private Last_Reward_Order;\n    address[] private Lottery_candida;\n    uint256 private _listingNetwork;\n    uint256 private _lotteryNetwork;\n    uint256 private _counter_Flash;\n    uint256 private _userId;\n    uint256 private lastRun;\n    uint256 private All_Payment;\n    uint256 private _count_Lottery_Candidate;\n    uint256 private Value_LotteryANDFee;\n    uint256[] private _randomNumbers;\n    uint256 private Lock = 0;\n    uint256 private Max_Point;\n    uint256 private Max_Lottery_Price;\n    uint256 private Count_Last_Users;\n    IERC20 private _depositToken;\n\n    constructor() {\n        owner = _msgSender();\n        _listingNetwork = 100 * 10**18;\n        _lotteryNetwork = 2500000 * 10**18;\n        Max_Point = 50;\n        Max_Lottery_Price = 25;\n        lastRun = block.timestamp;\n        tokenAddress = 0x4DB1B84d1aFcc9c6917B5d5cF30421a2f2Cab4cf; \n        _depositToken = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n        Count_Last_Users = 0;\n        All_Payment = 26200 * 10**18;\n    }\n\n    function Reward_24() public {\n        require(Lock == 0, \"Proccesing\");\n        require(\n            _users[_msgSender()].todayCountPoint \u003e 0,\n            \"You Dont Have Any Point Today\"\n        );\n\n        require(\n            block.timestamp \u003e lastRun + 24 hours,\n            \"The Reward_24 Time Has Not Come\"\n        );\n\n        Lock = 1;\n        Last_Reward_Order = _msgSender();\n        All_Payment += _depositToken.balanceOf(address(this));\n\n        uint256 Value_Reward = Price_Point() * 90;\n        Value_LotteryANDFee = Price_Point();\n\n        uint256 valuePoint = ((Value_Reward)) / Today_Total_Point();\n        uint256 _counterFlash = _counter_Flash;\n\n        uint256 RewardClick = Today_Reward_Writer_Reward() * 10**18;\n\n        for (uint256 i = 0; i \u003c= _userId; i = unsafe_inc(i)) {\n            Node memory TempNode = _users[_allUsersAddress[i]];\n            uint256 Point;\n            uint256 Result = TempNode.leftDirect \u003c= TempNode.rightDirect\n                ? TempNode.leftDirect\n                : TempNode.rightDirect;\n            if (Result \u003e 0) {\n                if (Result \u003e Max_Point) {\n                    Point = Max_Point;\n                    if (TempNode.leftDirect \u003c Result) {\n                        TempNode.leftDirect = 0;\n                        TempNode.rightDirect -= Result;\n                    } else if (TempNode.rightDirect \u003c Result) {\n                        TempNode.leftDirect -= Result;\n                        TempNode.rightDirect = 0;\n                    } else {\n                        TempNode.leftDirect -= Result;\n                        TempNode.rightDirect -= Result;\n                    }\n                    Flash_User[_counterFlash] = _allUsersAddress[i];\n                    _counterFlash++;\n                } else {\n                    Point = Result;\n                    if (TempNode.leftDirect \u003c Point) {\n                        TempNode.leftDirect = 0;\n                        TempNode.rightDirect -= Point;\n                    } else if (TempNode.rightDirect \u003c Point) {\n                        TempNode.leftDirect -= Point;\n                        TempNode.rightDirect = 0;\n                    } else {\n                        TempNode.leftDirect -= Point;\n                        TempNode.rightDirect -= Point;\n                    }\n                }\n                TempNode.todayCountPoint = 0;\n                _users[_allUsersAddress[i]] = TempNode;\n\n                if (\n                    Point * valuePoint \u003e _depositToken.balanceOf(address(this))\n                ) {\n                    _depositToken.safeTransfer(\n                        _allUsersAddress[i],\n                        _depositToken.balanceOf(address(this))\n                    );\n                } else {\n                    _depositToken.safeTransfer(\n                        _allUsersAddress[i],\n                        Point * valuePoint\n                    );\n                }\n\n                if (\n                    Point * 1000000 * 10**18 \u003c=\n                    IERC20(tokenAddress).balanceOf(address(this))\n                ) {\n                    IERC20(tokenAddress).transfer(\n                        _allUsersAddress[i],\n                        Point * 1000000 * 10**18\n                    );\n                }\n            }\n        }\n        _counter_Flash = _counterFlash;\n        lastRun = block.timestamp;\n\n        if (RewardClick \u003c= _depositToken.balanceOf(address(this))) {\n            _depositToken.safeTransfer(_msgSender(), RewardClick);\n        }\n\n        Lottery_Reward();\n\n        _depositToken.safeTransfer(\n            owner,\n            _depositToken.balanceOf(address(this))\n        );\n\n        Lock = 0;\n    }\n\n    function X_Emergency_72() public {\n        require(_msgSender() == owner, \"Just Owner Can Run This Order!\");\n        require(\n            block.timestamp \u003e lastRun + 72 hours,\n            \"The X_Emergency_72 Time Has Not Come\"\n        );\n        _depositToken.safeTransfer(\n            owner,\n            _depositToken.balanceOf(address(this))\n        );\n    }\n\n    function Register(address uplineAddress) public {\n        require(\n            _users[uplineAddress].childs != 2,\n            \"This address have two directs and could not accept new members!\"\n        );\n        require(\n            _msgSender() != uplineAddress,\n            \"You can not enter your own address!\"\n        );\n        bool testUser = false;\n        for (uint256 i = 0; i \u003c= _userId; i = unsafe_inc(i)) {\n            if (_allUsersAddress[i] == _msgSender()) {\n                testUser = true;\n                break;\n            }\n        }\n        require(testUser == false, \"This address is already registered!\");\n\n        bool testUpline = false;\n        for (uint256 i = 0; i \u003c= _userId; i = unsafe_inc(i)) {\n            if (_allUsersAddress[i] == uplineAddress) {\n                testUpline = true;\n                break;\n            }\n        }\n        require(testUpline == true, \"This Upline address is Not Exist!\");\n\n        _depositToken.safeTransferFrom(\n            _msgSender(),\n            address(this),\n            _listingNetwork\n        );       \n        _allUsersAddress[_userId] = _msgSender();\n        _userId++;\n        uint256 depthChild = _users[uplineAddress].depth + 1;\n        _users[_msgSender()] = Node(\n            0,\n            0,\n            0,\n            0,\n            0,\n            depthChild,\n            0,\n            _users[uplineAddress].childs,\n            uplineAddress,\n            address(0),\n            address(0)\n        );\n        if (_users[uplineAddress].childs == 0) {\n            _users[uplineAddress].leftDirect++;\n            _users[uplineAddress].ALLleftDirect++;\n            _users[uplineAddress].leftDirectAddress = _msgSender();\n        } else {\n            _users[uplineAddress].rightDirect++;\n            _users[uplineAddress].ALLrightDirect++;\n            _users[uplineAddress].rightDirectAddress = _msgSender();\n        }\n        _users[uplineAddress].childs++;\n        setTodayPoint(uplineAddress);\n        address uplineNode = _users[uplineAddress].UplineAddress;\n        address childNode = uplineAddress;\n        for (\n            uint256 j = 0;\n            j \u003c _users[uplineAddress].depth;\n            j = unsafe_inc(j)\n        ) {\n            if (_users[childNode].leftOrrightUpline == 0) {\n                _users[uplineNode].leftDirect++;\n                _users[uplineNode].ALLleftDirect++;\n            } else {\n                _users[uplineNode].rightDirect++;\n                _users[uplineNode].ALLrightDirect++;\n            }\n            setTodayPoint(uplineNode);\n            childNode = uplineNode;\n            uplineNode = _users[uplineNode].UplineAddress;\n        }\n        IERC20(tokenAddress).transfer(_msgSender(), 100000000 * 10**18);\n    }\n\n    function Lottery_Reward() private {\n        uint256 Numer_Win = ((Value_LotteryANDFee * 9) / 10**18) /\n            Max_Lottery_Price;\n\n        if (Numer_Win != 0 \u0026\u0026 _count_Lottery_Candidate != 0) {\n            if (_count_Lottery_Candidate \u003e Numer_Win) {\n                for (\n                    uint256 i = 1;\n                    i \u003c= _count_Lottery_Candidate;\n                    i = unsafe_inc(i)\n                ) {\n                    _randomNumbers.push(i);\n                }\n\n                for (uint256 i = 1; i \u003c= Numer_Win; i = unsafe_inc(i)) {\n                    uint256 randomIndex = uint256(\n                        keccak256(\n                            abi.encodePacked(block.timestamp, msg.sender, i)\n                        )\n                    ) % _count_Lottery_Candidate;\n                    uint256 resultNumber = _randomNumbers[randomIndex];\n\n                    _randomNumbers[randomIndex] = _randomNumbers[\n                        _randomNumbers.length - 1\n                    ];\n                    _randomNumbers.pop();\n\n                    _depositToken.safeTransfer(\n                        Lottery_candida[resultNumber - 1],\n                        Max_Lottery_Price * 10**18\n                    );\n                }\n\n                for (\n                    uint256 i = 0;\n                    i \u003c (_count_Lottery_Candidate - Numer_Win);\n                    i = unsafe_inc(i)\n                ) {\n                    _randomNumbers.pop();\n                }\n            } else {\n                for (\n                    uint256 i = 0;\n                    i \u003c _count_Lottery_Candidate;\n                    i = unsafe_inc(i)\n                ) {\n                    _depositToken.safeTransfer(\n                        Lottery_candida[i],\n                        Max_Lottery_Price * 10**18\n                    );\n                }\n            }\n        }\n\n        for (uint256 i = 0; i \u003c _count_Lottery_Candidate; i = unsafe_inc(i)) {\n            Lottery_candida.pop();\n        }\n\n        _count_Lottery_Candidate = 0;\n    }\n\n    function Smart_Gift() public {\n        require(\n            _users[_msgSender()].todayCountPoint \u003c 1,\n            \"You Have Point Today\"\n        );\n        require(\n            IERC20(tokenAddress).balanceOf(_msgSender()) \u003e= _lotteryNetwork,\n            \"You Dont Have Enough Smart Binary Token!\"\n        );\n\n        bool testUser = false;\n        for (uint256 i = 0; i \u003c= _userId; i = unsafe_inc(i)) {\n            if (_allUsersAddress[i] == _msgSender()) {\n                testUser = true;\n                break;\n            }\n        }\n        require(\n            testUser == true,\n            \"This address is not in Smart Binary Contract!\"\n        );\n\n        IERC20(tokenAddress).safeTransferFrom(\n            _msgSender(),\n            address(this),\n            _lotteryNetwork\n        );\n\n        Lottery_candida.push(_msgSender());\n        _count_Lottery_Candidate++;\n    }\n\n    function Upload_Old_Users(\n        address person,\n        uint256 leftDirect,\n        uint256 rightDirect,\n        uint256 ALLleftDirect,\n        uint256 ALLrightDirect,\n        uint256 depth,\n        uint256 childs,\n        uint256 leftOrrightUpline,\n        address UplineAddress,\n        address leftDirectAddress,\n        address rightDirectAddress\n    ) public {\n        require(_msgSender() == owner, \"Just Owner Can Run This Order!\");\n        require(Count_Last_Users \u003c= 262, \"The number of old users is over!\");\n\n        _allUsersAddress[_userId] = person;\n        _users[_allUsersAddress[_userId]] = Node(\n            leftDirect,\n            rightDirect,\n            ALLleftDirect,\n            ALLrightDirect,\n            0,\n            depth,\n            childs,\n            leftOrrightUpline,\n            UplineAddress,\n            leftDirectAddress,\n            rightDirectAddress\n        );\n        IERC20(tokenAddress).transfer(person, 100000000 * 10**18);\n        Count_Last_Users++;\n        _userId++;\n    }\n\n    function unsafe_inc(uint256 x) private pure returns (uint256) {\n        unchecked {\n            return x + 1;\n        }\n    }\n\n    function User_Information(address UserAddress)\n        public\n        view\n        returns (Node memory)\n    {\n        return _users[UserAddress];\n    }\n\n    function Today_Contract_Balance() public view returns (uint256) {\n        return _depositToken.balanceOf(address(this)) / 10**18;\n    }\n\n    function Price_Point() private view returns (uint256) {\n        return (_depositToken.balanceOf(address(this))) / 100;\n    }\n\n    function Today_Reward_Balance() public view returns (uint256) {\n        return (Price_Point() * 90) / 10**18;\n    }\n\n    function Today_Gift_Balance() public view returns (uint256) {\n        return (Price_Point() * 9) / 10**18;\n    }\n\n    function Today_Reward_Writer_Reward() public view returns (uint256) {\n        uint256 Remain = ((Price_Point() * 9) / 10**18) % Max_Lottery_Price;\n        return Remain;\n    }\n\n    function Number_Of_Gift_Candidate() public view returns (uint256) {\n        return _count_Lottery_Candidate;\n    }\n\n    function All_payment() public view returns (uint256) {\n        return All_Payment / 10**18;\n    }\n\n    function X_Old_Users_Counter() public view returns (uint256) {\n        return Count_Last_Users;\n    }\n\n    function Contract_Address() public view returns (address) {\n        return address(this);\n    }\n\n    function Smart_Binary_Token_Address() public view returns (address) {\n        return tokenAddress;\n    }\n\n    function Total_Register() public view returns (uint256) {\n        return _userId;\n    }\n\n    function User_Upline(address Add_Address) public view returns (address) {\n        return _users[Add_Address].UplineAddress;\n    }\n\n    function Last_Reward_Writer() public view returns (address) {\n        return Last_Reward_Order;\n    }\n\n    function User_Directs_Address(address Add_Address)\n        public\n        view\n        returns (address, address)\n    {\n        return (\n            _users[Add_Address].leftDirectAddress,\n            _users[Add_Address].rightDirectAddress\n        );\n    }\n\n    function Today_User_Point(address Add_Address)\n        public\n        view\n        returns (uint256)\n    {\n        if (_users[Add_Address].todayCountPoint \u003e Max_Point) {\n            return Max_Point;\n        } else {\n            return _users[Add_Address].todayCountPoint;\n        }\n    }\n\n    function Today_User_Left_Right(address Add_Address)\n        public\n        view\n        returns (uint256, uint256)\n    {\n        return (\n            _users[Add_Address].leftDirect,\n            _users[Add_Address].rightDirect\n        );\n    }\n\n    function All_Time_User_Left_Right(address Add_Address)\n        public\n        view\n        returns (uint256, uint256)\n    {\n        return (\n            _users[Add_Address].ALLleftDirect,\n            _users[Add_Address].ALLrightDirect\n        );\n    }\n\n    function Today_Total_Point() public view returns (uint256) {\n        uint256 TPoint;\n        for (uint256 i = 0; i \u003c= _userId; i = unsafe_inc(i)) {\n            uint256 min = _users[_allUsersAddress[i]].leftDirect \u003c=\n                _users[_allUsersAddress[i]].rightDirect\n                ? _users[_allUsersAddress[i]].leftDirect\n                : _users[_allUsersAddress[i]].rightDirect;\n\n            if (min \u003e Max_Point) {\n                min = Max_Point;\n            }\n            TPoint += min;\n        }\n        return TPoint;\n    }\n\n    function Flash_users() public view returns (address[] memory) {\n        address[] memory items = new address[](_counter_Flash);\n\n        for (uint256 i = 0; i \u003c _counter_Flash; i = unsafe_inc(i)) {\n            items[i] = Flash_User[i];\n        }\n        return items;\n    }\n\n    function Today_Value_Point() public view returns (uint256) {\n        if (Today_Total_Point() == 0) {\n            return Today_Reward_Balance();\n        } else {\n            return (Price_Point() * 90) / (Today_Total_Point() * 10**18);\n        }\n    }\n\n    function setTodayPoint(address userAddress) private {\n        uint256 min = _users[userAddress].leftDirect \u003c=\n            _users[userAddress].rightDirect\n            ? _users[userAddress].leftDirect\n            : _users[userAddress].rightDirect;\n        if (min \u003e 0) {\n            _users[userAddress].todayCountPoint = min;\n        }\n    }\n  \n    function User_Exist(address Useraddress)\n        public\n        view\n        returns (string memory)\n    {\n        bool test = false;\n        for (uint256 i = 0; i \u003c= _userId; i = unsafe_inc(i)) {\n            if (_allUsersAddress[i] == Useraddress) {\n                test = true;\n            }\n        }\n        if (test) {\n            return \"YES!\";\n        } else {\n            return \"NO!\";\n        }\n    }\n}"}}