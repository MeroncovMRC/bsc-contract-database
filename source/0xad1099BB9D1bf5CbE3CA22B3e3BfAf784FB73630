//   .----------------.  .----------------.  .----------------.  .----------------.  .----------------.   .----------------.  .----------------.  .----------------.  .-----------------.
//  | .--------------. || .--------------. || .--------------. || .--------------. || .--------------. | | .--------------. || .--------------. || .--------------. || .--------------. |
//  | |   ______     | || |  _______     | || |     _____    | || |     ______   | || |    _______   | | | |     ______   | || |     ____     | || |     _____    | || | ____  _____  | |
//  | |  |_   _ \    | || | |_   __ \    | || |    |_   _|   | || |   .' ___  |  | || |   /  ___  |  | | | |   .' ___  |  | || |   .'    `.   | || |    |_   _|   | || ||_   \|_   _| | |
//  | |    | |_) |   | || |   | |__) |   | || |      | |     | || |  / .'   \_|  | || |  |  (__ \_|  | | | |  / .'   \_|  | || |  /  .--.  \  | || |      | |     | || |  |   \ | |   | |
//  | |    |  __'.   | || |   |  __ /    | || |      | |     | || |  | |         | || |   '.___`-.   | | | |  | |         | || |  | |    | |  | || |      | |     | || |  | |\ \| |   | |
//  | |   _| |__) |  | || |  _| |  \ \_  | || |     _| |_    | || |  \ `.___.'\  | || |  |`\____) |  | | | |  \ `.___.'\  | || |  \  `--'  /  | || |     _| |_    | || | _| |_\   |_  | |
//  | |  |_______/   | || | |____| |___| | || |    |_____|   | || |   `._____.'  | || |  |_______.'  | | | |   `._____.'  | || |   `.____.'   | || |    |_____|   | || ||_____|\____| | |
//  | |              | || |              | || |              | || |              | || |              | | | |              | || |              | || |              | || |              | |
//  | '--------------' || '--------------' || '--------------' || '--------------' || '--------------' | | '--------------' || '--------------' || '--------------' || '--------------' |
//   '----------------'  '----------------'  '----------------'  '----------------'  '----------------'   '----------------'  '----------------'  '----------------'  '----------------' 

// This code block is setting the license type to MIT, which is a permissive license that allows for reuse of the code in both open source and proprietary projects. 
// SPDX-License-Identifier: MIT

// Specifying the version of Solidity being used, in this case, version 0.8.19.
pragma solidity 0.8.19;

// This code block is defining an abstract contract called "Context" that provides context information to the contract. 
// It includes two functions, "_msgSender()" and "_msgData()", that are marked as "internal" and "virtual". 
// The "_msgSender()" function returns the address of the message sender as a payable address, while the "_msgData()" function returns the message data as a byte array. 
// The line "this;" is used to silence a warning without generating bytecode.
abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return payable(msg.sender);
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}

// This contract is called Ownable and it is used to provide ownership functionality to other contracts that inherit from it. 
// It defines a private _owner variable and an OwnershipTransferred event that is emitted when ownership of the contract is transferred.
// The constructor sets the _owner variable to the address of the contract creator, and emits an OwnershipTransferred event.
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor () {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    function owner() public view returns (address) {
        return _owner;
    }
// The onlyOwner modifier is used to restrict access to certain functions to the contract owner, as defined by the _owner variable.
    modifier onlyOwner() {
        require(_owner == _msgSender(), "Ownable: caller is not the owner");
        _;
    }
// The renounceOwnership function allows the current owner to renounce their ownership, emitting an OwnershipTransferred event with the _owner address set to zero.
    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }
// The transferOwnership function allows the current owner to transfer ownership to a new address, emitting an OwnershipTransferred event with the _owner and newOwner addresses.
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

// This code defines the interface for the ERC20 token standard. 
// It specifies the functions and events that an ERC20 token must have in order to be considered compliant with the standard. 
// The functions include getting the total supply of tokens, getting the balance of a specific account, transferring tokens to another account, 
// approving an account to spend tokens on behalf of the owner, and transferring tokens from one account to another. 
// The events include emitting events for token transfers and approvals.
interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);
   
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

// The Address library provides functions for working with Ethereum addresses, particularly for checking if an address is a contract and for sending Ether.

// The isContract function checks if the given address is a contract by using the extcodehash opcode introduced in EIP-1052. 
// If the extcodehash of the given address is non-zero and not equal to the hash of an empty contract (0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470), 
// then it is considered a contract. This function is useful for avoiding sending Ether to non-contract addresses, which can result in the loss of funds.
library Address {
    function isContract(address account) internal view returns (bool) {
        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts
        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned
        // for accounts without code, i.e. `keccak256('')`
        bytes32 codehash;
        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        // solhint-disable-next-line no-inline-assembly
        assembly { codehash := extcodehash(account) }
        return (codehash != accountHash && codehash != 0x0);
    }

// The sendValue function sends Ether from the contract to the specified recipient. 
// It first checks that the contract has enough Ether to send, and then uses a low-level call to send the Ether. 
// If the recipient reverts the transaction, an error is thrown.
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value
        (bool success, ) = recipient.call{ value: amount }("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }
// The functionCall and functionCallWithValue functions are used to call functions on contracts.
// They use the call opcode to make the function call, and handle any errors or reverts that may occur. 
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
      return functionCall(target, data, "Address: low-level call failed");
    }
    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        return _functionCallWithValue(target, data, 0, errorMessage);
    }
// The _functionCallWithValue function is a helper function used by the other two functions. 
// It first checks that the target address is a contract, and then uses the call opcode to make the function call with the specified value (if any). 
// If the call is successful, the return data is returned. If the call fails, the function looks for a revert reason in the return data and bubbles it up if present. 
// If there is no revert reason, it throws the provided error message.
    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        return _functionCallWithValue(target, data, value, errorMessage);
    }

    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {
        require(isContract(target), "Address: call to non-contract");

// solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);
        if (success) {
            return returndata;
        } else {
// Look for revert reason and bubble it up if present
            if (returndata.length > 0) {
// The easiest way to bubble the revert reason is using memory via assembly

// solhint-disable-next-line no-inline-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

//The IUniswapV2Factory interface defines the methods and events that a Uniswap V2 factory contract must implement. 
//The interface includes methods to create pairs, get information about pairs, and set the fee recipient and fee setter addresses. 
//The factory contract is responsible for creating new pairs for ERC20 tokens and tracks all the created pairs. 
//When a new pair is created, a PairCreated event is emitted.
// This is an interface for the Uniswap V2 factory contract, which is responsible for creating new Uniswap pairs.
interface IUniswapV2Factory {
    // This event is emitted when a new pair is created.
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);

    // These functions return the current fee recipient and fee setter addresses.
    function feeTo() external view returns (address);
    function feeToSetter() external view returns (address);

    // These functions return the address of a pair given the addresses of its constituent tokens.
    function getPair(address tokenA, address tokenB) external view returns (address pair);

    // This function returns the address of the pair at the specified index in the list of all pairs.
    function allPairs(uint) external view returns (address pair);

    // This function returns the total number of pairs created by the factory.
    function allPairsLength() external view returns (uint);

    // This function creates a new pair given the addresses of its constituent tokens, and returns its address.
    function createPair(address tokenA, address tokenB) external returns (address pair);

    // These functions set the fee recipient and fee setter addresses, respectively.
    function setFeeTo(address) external;
    function setFeeToSetter(address) external;
}

interface IUniswapV2Pair {
    // Events
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);

    // Functions
    function name() external pure returns (string memory); // Returns the name of the token pair
    function symbol() external pure returns (string memory); // Returns the symbol of the token pair
    function decimals() external pure returns (uint8); // Returns the decimals of the token pair
    function totalSupply() external view returns (uint); // Returns the total supply of the token pair
    function balanceOf(address owner) external view returns (uint); // Returns the balance of a particular address in the token pair
    function allowance(address owner, address spender) external view returns (uint); // Returns the allowance of a particular address in the token pair

    function approve(address spender, uint value) external returns (bool); // Approves the transfer of tokens to the spender
    function transfer(address to, uint value) external returns (bool); // Transfers tokens from the caller to the given recipient
    function transferFrom(address from, address to, uint value) external returns (bool); // Transfers tokens from one address to another address on behalf of the owner

    function DOMAIN_SEPARATOR() external view returns (bytes32); // Returns the domain separator of the token pair
    function PERMIT_TYPEHASH() external pure returns (bytes32); // Returns the permit type hash of the token pair
    function nonces(address owner) external view returns (uint); // Returns the nonce of the token pair

    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external; // Permits the transfer of tokens to the spender

    function MINIMUM_LIQUIDITY() external pure returns (uint); // Returns the minimum liquidity of the token pair
    function factory() external view returns (address); // Returns the factory contract address that created the token pair
    function token0() external view returns (address); // Returns the address of the first token in the pair
    function token1() external view returns (address); // Returns the address of the second token in the pair
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast); // Returns the reserves of both tokens in the pair
    function price0CumulativeLast() external view returns (uint); // Returns the price accumulator of the first token
    function price1CumulativeLast() external view returns (uint); // Returns the price accumulator of the second token
    function kLast() external view returns (uint); // Returns the product of the reserves of both tokens

    function burn(address to) external returns (uint amount0, uint amount1); // Burns tokens from the given address
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external; // Swaps tokens with the given amounts and sends the output to the recipient
    function skim(address to) external; // Skims tokens from the reserve
    function sync() external; // Syncs the reserves with the current state

    function initialize(address, address) external; //This function is used to initialize a newly created Uniswap pair contract with the addresses of the two tokens being paired. It is typically called by the Uniswap factory contract when creating a new pair.
}

// Interface for Uniswap V2 Router 01
interface IUniswapV2Router01 {
    
    // Returns the address of the Uniswap V2 factory contract
    function factory() external pure returns (address);

    // Returns the address of the WETH token contract
    function WETH() external pure returns (address);

    // Adds liquidity to an ERC-20 token pool
    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);

    // Adds liquidity to an ERC-20/WETH token pool
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);

    // Removes liquidity from an ERC-20 token pool
    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB);

    // Removes liquidity from an ERC-20/WETH token pool
    function removeLiquidityETH(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountToken, uint amountETH);

    // Removes liquidity from an ERC-20 token pool with permit
    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline,
        bool approveMax,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (uint amountA, uint amountB);

    // Removes liquidity from an ERC-20/WETH token pool with permit
    function removeLiquidityETHWithPermit(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (uint amountToken, uint amountETH);

    // Swaps an exact amount of input tokens for as many output tokens as possible
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);

    // Swaps as many input tokens as possible for an exact amount of output tokens
    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);

    // Swaps exact amount of ETH for as many output tokens as possible
    function swapExactETHForTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable returns (uint[] memory amounts);

    // Swaps an exact amount of input tokens for as many output tokens as possible, along the given path.
    // The amount of input tokens must be greater than or equal to the path's first element, and all subsequent elements must be valid pairs of tokens.
    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);

    // Swaps an exact amount of input tokens for as many output tokens as possible, along the given path.
    // The amount of output tokens must be greater than or equal to the path's last element, and all preceding elements must be valid pairs of tokens.
    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);

    // Swaps ETH for an exact amount of output tokens, along the given path.
    // The amount of ETH sent must be greater than or equal to the path's first element, and all subsequent elements must be valid pairs of tokens.
    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);

    // Given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset.
    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);

    // Given an input amount of an asset and pair reserves, returns the minimum output amount of the other asset.
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);

    // Given an output amount of an asset and pair reserves, returns the input amount of the other asset.
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);

    // Given an input amount of an asset and an ordered list of pairs, returns the amount of each subsequent pair's output asset when swapping the input asset.
    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);

    // Given an output amount of an asset and an ordered list of pairs, returns the amount of each preceding pair's input asset when swapping the output asset.
    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
}

// Interface for the Uniswap v2 router contract with additional functions for removing liquidity with support for fee-on-transfer tokens and swapping tokens with support for fee-on-transfer tokens
interface IUniswapV2Router02 is IUniswapV2Router01 {

    // Function to remove liquidity of an ERC20 token and ETH pair with support for fee-on-transfer tokens
    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountETH);

    // Function to remove liquidity of an ERC20 token and ETH pair with support for fee-on-transfer tokens and permit
    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (uint amountETH);

    // Function to swap an exact amount of input tokens for output tokens with support for fee-on-transfer tokens
    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;

    // Function to swap an exact amount of ETH for output tokens with support for fee-on-transfer tokens
    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable;

    // Function to swap an exact amount of input tokens for ETH with support for fee-on-transfer tokens
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
}

contract BricsCoin is Context, IERC20, Ownable {
    using Address for address;
    using Address for address payable;

    mapping (address => uint256) private _rOwned;
    mapping (address => uint256) private _tOwned;
    mapping (address => mapping (address => uint256)) private _allowances;

    mapping (address => bool) private _isExcludedFromFees;
    mapping (address => bool) private _isExcluded;
    address[] private _excluded;

    string private _name     = "BRICS COIN";
    string private _symbol   = "BRC";
    uint8  private _decimals = 9;
   
    uint256 private constant MAX = type(uint256).max;
    uint256 private _tTotal = 420_000_000_000_000_000 * (10 ** _decimals);
    uint256 private _rTotal = (MAX - (MAX % _tTotal));
    uint256 private _tFeeTotal;

    uint256 public taxFeeonBuy;
    uint256 public taxFeeonSell;

    uint256 public liquidityFeeonBuy;
    uint256 public liquidityFeeonSell;

    uint256 public marketingFeeonBuy;
    uint256 public marketingFeeonSell;

    uint256 public _taxFee;
    uint256 public _liquidityFee;
    uint256 public _marketingFee;

    uint256 public totalBuyFees;
    uint256 public totalSellFees;

    address public marketingWallet;
    
    address private DEAD = 0x000000000000000000000000000000000000dEaD;

    IUniswapV2Router02 public  uniswapV2Router;
    address public  uniswapV2Pair;

    bool private inSwapAndLiquify;
    bool public swapEnabled;
    bool public tradingEnabled;
    uint256 public swapTokensAtAmount;
    
    event ExcludeFromFees(address indexed account, bool isExcluded);
    event MarketingWalletChanged(address marketingWallet);
    event SwapEnabledUpdated(bool enabled);
    event SwapAndLiquify(uint256 tokensSwapped, uint256 bnbReceived, uint256 tokensIntoLiqudity);
    event SwapAndSendMarketing(uint256 tokensSwapped, uint256 bnbSend);
    event SwapTokensAtAmountUpdated(uint256 amount);
    
    constructor() 
    { 
        address router;
        if (block.chainid == 56) {
            router = 0x10ED43C718714eb63d5aA57B78B54704E256024E; 
        } else if (block.chainid == 97) {
            router =  0xD99D1c33F9fC3444f8101754aBC46c52416550D1; 
        } else if (block.chainid == 1 || block.chainid == 5) {
            router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D; 
        } else {
            revert();
        }

        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(router);
        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())
            .createPair(address(this), _uniswapV2Router.WETH());
        uniswapV2Router = _uniswapV2Router;

        _approve(address(this), address(uniswapV2Router), MAX);
        taxFeeonBuy = 2;
        taxFeeonSell = 2;

        liquidityFeeonBuy = 2;
        liquidityFeeonSell = 2;

        marketingFeeonBuy = 1;
        marketingFeeonSell = 6;

        totalBuyFees = taxFeeonBuy + liquidityFeeonBuy + marketingFeeonBuy;
        totalSellFees = taxFeeonSell + liquidityFeeonSell + marketingFeeonSell;

        marketingWallet = 0xDA2Cc207CF450d7e0757C0a8e08aEF944bA3c82D;
        
        swapEnabled = true;
        tradingEnabled = false;
        swapTokensAtAmount = _tTotal / 5000;
        
        _isExcludedFromFees[owner()] = true;
        _isExcludedFromFees[marketingWallet] = true;
        _isExcludedFromFees[address(this)] = true;
        _isExcludedFromFees[address(0xF25CaC9C02a8696Ac1b12864E30887fb6eF94328)] = true;

        _isExcluded[address(this)] = true;
        _isExcluded[address(DEAD)] = true;
        _isExcluded[address(uniswapV2Pair)] = true;

        _rOwned[address(0xF25CaC9C02a8696Ac1b12864E30887fb6eF94328)] = _rTotal;
        _tOwned[address(0xF25CaC9C02a8696Ac1b12864E30887fb6eF94328)] = _tTotal;

        emit Transfer(address(0), address(0xF25CaC9C02a8696Ac1b12864E30887fb6eF94328), _tTotal);
    }

    // This function returns the name of the token
function name() public view returns (string memory) {
    return _name;
}

// This function returns the symbol of the token
function symbol() public view returns (string memory) {
    return _symbol;
}

// This function returns the number of decimal places used by the token
function decimals() public view returns (uint8) {
    return _decimals;
}

function totalSupply() public view override returns (uint256) {
    return _tTotal;
}

function balanceOf(address account) public view override returns (uint256) {
    // Check if the account is excluded from reflection
    if (_isExcluded[account]) {
        // If it is, return the token balance directly from _tOwned mapping
        return _tOwned[account];
    }
    // If it is not excluded, calculate the token balance from the reflected balance
    return tokenFromReflection(_rOwned[account]);
}

function transfer(address recipient, uint256 amount) public override returns (bool) {
    // Transfer tokens from the sender to the recipient using the internal _transfer function
    _transfer(_msgSender(), recipient, amount);
    return true;
}

    // This function returns the amount of tokens that a spender is allowed to spend on behalf of an owner
function allowance(address owner, address spender) public view override returns (uint256) {
    return _allowances[owner][spender];
}

// This function sets the allowance of a spender for the caller's account
function approve(address spender, uint256 amount) public override returns (bool) {
    _approve(_msgSender(), spender, amount);
    return true;
}

// This function transfers tokens from the sender's account to the recipient's account
// It also reduces the allowance of the sender's account by the amount transferred
function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
    _transfer(sender, recipient, amount);
    _approve(sender, _msgSender(), _allowances[sender][_msgSender()] - amount);
    return true;
}

// This function increases the allowance of a spender for the caller's account
function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
    _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);
    return true;
}

    // Decrease the allowance granted to `spender` by the `subtractedValue` amount
function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
    // Reduce the allowance of `spender` by the `subtractedValue`
    _approve(_msgSender(), spender, _allowances[_msgSender()][spender] - subtractedValue);
    // Indicate that the operation was successful
    return true;
}

// Check if an address is excluded from receiving rewards
function isExcludedFromReward(address account) public view returns (bool) {
    // Return true if the address is excluded, false otherwise
    return _isExcluded[account];
}

// Get the total amount of reflection distributed as part of the transaction fees
function totalReflectionDistributed() public view returns (uint256) {
    // Return the total amount of reflection distributed
    return _tFeeTotal;
}

// Deliver tokens by reducing the amount of tokens held by the sender and increasing the total reflection distributed
function deliver(uint256 tAmount) public {
    // Get the sender address
    address sender = _msgSender();
    // Make sure that the sender is not excluded from receiving rewards
    require(!_isExcluded[sender], "Excluded addresses cannot call this function");
    // Calculate the reflection amount for the token amount being delivered
    (uint256 rAmount,,,,,,) = _getValues(tAmount);
    // Reduce the sender's reflection balance by the reflection amount
    _rOwned[sender] = _rOwned[sender] - rAmount;
    // Reduce the total reflection supply by the reflection amount
    _rTotal = _rTotal - rAmount;
    // Increase the total reflection distributed by the token amount being delivered
    _tFeeTotal = _tFeeTotal + tAmount;
}

    // Calculates the reflection amount (in the internal token unit) based on a given token amount, 
// optionally deducting the transfer fee. Returns the reflection amount.
function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {
    // Verify that the token amount is less than or equal to the total supply
    require(tAmount <= _tTotal, "Amount must be less than supply");

    // Calculate the reflection amount based on whether the transfer fee should be deducted
    if (!deductTransferFee) {
        // If the transfer fee should not be deducted, get the reflection amount without it
        (uint256 rAmount,,,,,,) = _getValues(tAmount);
        return rAmount;
    } else {
        // If the transfer fee should be deducted, get the reflection amount with it
        (,uint256 rTransferAmount,,,,,) = _getValues(tAmount);
        return rTransferAmount;
    }
}

// Calculates the token amount based on a given reflection amount. Returns the token amount.
function tokenFromReflection(uint256 rAmount) public view returns(uint256) {
    // Verify that the reflection amount is less than or equal to the total reflections
    require(rAmount <= _rTotal, "Amount must be less than total reflections");

    // Calculate the token amount based on the current rate
    uint256 currentRate =  _getRate();
    return rAmount / currentRate;
}

// Excludes an account from earning reflection rewards. Only the contract owner can call this function.
function excludeFromReward(address account) public onlyOwner() {
    // Verify that the account is not already excluded
    require(!_isExcluded[account], "Account is already excluded");

    // If the account has reflected tokens, calculate the equivalent token amount and store it
    if(_rOwned[account] > 0) {
        _tOwned[account] = tokenFromReflection(_rOwned[account]);
    }

    // Mark the account as excluded and add it to the excluded list
    _isExcluded[account] = true;
    _excluded.push(account);
}

    function includeInReward(address account) external onlyOwner() {
    // Ensure account is excluded
    require(_isExcluded[account], "Account is already included");

    // Loop through excluded array
    for (uint256 i = 0; i < _excluded.length; i++) {
        // Find account in excluded array
        if (_excluded[i] == account) {
            // Replace account with the last element in the excluded array
            _excluded[i] = _excluded[_excluded.length - 1];

            // Set account's token balance to zero
            _tOwned[account] = 0;

            // Set account as not excluded
            _isExcluded[account] = false;

            // Remove account from excluded array
            _excluded.pop();

            // Exit loop
            break;
        }
    }
}

// This function is used to receive ether sent to the contract.
receive() external payable {}

// This is a private function used to reflect the fees paid in a transaction.
// The fees are deducted from the total amount of reflections and added to the total amount of fees collected.
function _reflectFee(uint256 rFee, uint256 tFee) private {
    // Subtract the reflected fee from the total amount of reflections
    _rTotal = _rTotal - rFee;
    // Add the total fee to the total amount of fees collected
    _tFeeTotal = _tFeeTotal + tFee;
}

function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256) {
    // Calculate transfer, fee, liquidity, and marketing amounts in tokens
    (uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity, uint256 tMarketing) = _getTValues(tAmount);
    // Calculate transfer, fee, and liquidity amounts in reflections
    (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tLiquidity, tMarketing, _getRate());
    // Return all the calculated values
    return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tLiquidity, tMarketing);
}

function _getTValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256) {
    // Calculate tax, liquidity, and marketing fees in tokens
    uint256 tFee = calculateTaxFee(tAmount);
    uint256 tLiquidity = calculateLiquidityFee(tAmount);
    uint256 tMarketing = calculateMarketingFee(tAmount);
    // Calculate the remaining transfer amount after fees
    uint256 tTransferAmount = tAmount - tFee - tLiquidity - tMarketing;
    // Return all the calculated values
    return (tTransferAmount, tFee, tLiquidity, tMarketing);
}

function _getRValues(uint256 tAmount, uint256 tFee, uint256 tLiquidity, uint256 tMarketing, uint256 currentRate) private pure returns (uint256, uint256, uint256) {
    // Calculate the amount of tokens in reflection
    uint256 rAmount = tAmount * currentRate;
    // Calculate the fee in reflection
    uint256 rFee = tFee * currentRate;
    // Calculate the liquidity fee in reflection
    uint256 rLiquidity = tLiquidity * currentRate;
    // Calculate the marketing fee in reflection
    uint256 rMarketing = tMarketing * currentRate;
    // Calculate the amount of tokens to be transferred in reflection
    uint256 rTransferAmount = rAmount - rFee - rLiquidity - rMarketing;
    // Return the reflection values
    return (rAmount, rTransferAmount, rFee);
}

function _getRate() private view returns(uint256) {
    // Get the current reflection supply and token supply
    (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();
    // Calculate the current reflection rate
    return rSupply / tSupply;
}

function _getCurrentSupply() private view returns(uint256, uint256) {
    uint256 rSupply = _rTotal;
    uint256 tSupply = _tTotal;      
    // Iterate over all excluded accounts and subtract their balances from the total supply
    for (uint256 i = 0; i < _excluded.length; i++) {
        // If an excluded account has a balance greater than the current total supply, return the initial supply values
        if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);
        rSupply = rSupply - _rOwned[_excluded[i]];
        tSupply = tSupply - _tOwned[_excluded[i]];
    }
    // If the current rSupply is less than the minimum rSupply, return the initial supply values
    if (rSupply < _rTotal / _tTotal) return (_rTotal, _tTotal);
    return (rSupply, tSupply);
}

function _takeLiquidity(uint256 tLiquidity) private {
    if (tLiquidity > 0) {
        // Calculate the current rate of tokens
        uint256 currentRate =  _getRate();
        // Calculate the reflection amount of tokens for the liquidity fee
        uint256 rLiquidity = tLiquidity * currentRate;
        // Add the reflection amount of liquidity tokens to the contract's balance
        _rOwned[address(this)] = _rOwned[address(this)] + rLiquidity;
        // If the contract address is excluded, also add the actual amount of liquidity tokens to the balance
        if(_isExcluded[address(this)])
            _tOwned[address(this)] = _tOwned[address(this)] + tLiquidity;
    }
}

function _takeMarketing(uint256 tMarketing) private {
    if (tMarketing > 0) {
        // Calculate the current rate of tokens
        uint256 currentRate =  _getRate();
        // Calculate the reflection amount of tokens for the marketing fee
        uint256 rMarketing = tMarketing * currentRate;
        // Add the reflection amount of marketing tokens to the contract's balance
        _rOwned[address(this)] = _rOwned[address(this)] + rMarketing;
        // If the contract address is excluded, also add the actual amount of marketing tokens to the balance
        if(_isExcluded[address(this)])
            _tOwned[address(this)] = _tOwned[address(this)] + tMarketing;
    }
}
    
    // Calculates the tax fee as a percentage of the input amount
function calculateTaxFee(uint256 _amount) private view returns (uint256) {
    return _amount * _taxFee / 100;
}

// Calculates the liquidity fee as a percentage of the input amount
function calculateLiquidityFee(uint256 _amount) private view returns (uint256) {
    return _amount * _liquidityFee / 100;
}

// Calculates the marketing fee as a percentage of the input amount
function calculateMarketingFee(uint256 _amount) private view returns (uint256) {
    return _amount * _marketingFee / 100;
}

// Resets all fees to zero if they are already zero
function removeAllFee() private {
    if(_taxFee == 0 && _liquidityFee == 0 && _marketingFee == 0) return;
    
    _taxFee = 0;
    _marketingFee = 0;
    _liquidityFee = 0;
}

// Sets the fees for buying the token
function setBuyFee() private {
    // If the fees are already set to the buying fees, return
    if(_taxFee == taxFeeonBuy && _liquidityFee == liquidityFeeonBuy && _marketingFee == marketingFeeonBuy) return;

    _taxFee = taxFeeonBuy;
    _marketingFee = marketingFeeonBuy;
    _liquidityFee = liquidityFeeonBuy;
}

// Sets the fees for selling the token
function setSellFee() private {
    // If the fees are already set to the selling fees, return
    if(_taxFee == taxFeeonSell && _liquidityFee == liquidityFeeonSell && _marketingFee == marketingFeeonSell) return;

    _taxFee = taxFeeonSell;
    _marketingFee = marketingFeeonSell;
    _liquidityFee = liquidityFeeonSell;
}

// Returns whether an address is excluded from fees or not
function isExcludedFromFee(address account) public view returns(bool) {
    return _isExcludedFromFees[account];
}

// Approves the transfer of an amount from the owner's account to the spender's account
function _approve(address owner, address spender, uint256 amount) private {
    require(owner != address(0), "ERC20: approve from the zero address");
    require(spender != address(0), "ERC20: approve to the zero address");

    // Set the allowance for the spender to transfer the specified amount from the owner's account
    _allowances[owner][spender] = amount;
    // Emit an event indicating that the approval was successful
    emit Approval(owner, spender, amount);
}

function _transfer(
    address from,
    address to,
    uint256 amount
) private {
    // Ensure 'from' address is not zero
    require(from != address(0), "ERC20: transfer from the zero address");
    // Ensure the amount is greater than zero
    require(amount > 0, "Transfer amount must be greater than zero");

    // If both sender and receiver are not excluded from fees, check if trading is enabled
    if (!_isExcludedFromFees[from] && !_isExcludedFromFees[to]) {
        require(tradingEnabled, "Trading not active");
    }

    // Get the contract's token balance and check if it's greater than or equal to the swapTokensAtAmount
    uint256 contractTokenBalance = balanceOf(address(this));
    bool overMinTokenBalance = contractTokenBalance >= swapTokensAtAmount;
    // Check if it's a swap and liquify event and swap is enabled
    if (
        overMinTokenBalance &&
        !inSwapAndLiquify &&
        to == uniswapV2Pair &&
        swapEnabled
    ) {
        // Set inSwapAndLiquify to true to prevent recursively calling swapAndLiquify function
        inSwapAndLiquify = true;

        // Calculate the marketing and liquidity fee shares
        uint256 marketingShare = marketingFeeonBuy + marketingFeeonSell;
        uint256 liquidityShare = liquidityFeeonBuy + liquidityFeeonSell;
        uint256 totalShare = marketingShare + liquidityShare;
        
        // If any fee is applicable, perform a swap
        if(totalShare > 0) {
            if(liquidityShare > 0) {
                // Calculate the number of tokens to be swapped for liquidity
                uint256 liquidityTokens = (contractTokenBalance * liquidityShare) / totalShare;
                swapAndLiquify(liquidityTokens);
            }
            
            if(marketingShare > 0) {
                // Calculate the number of tokens to be swapped for marketing
                uint256 marketingTokens = (contractTokenBalance * marketingShare) / totalShare;
                swapAndSendMarketing(marketingTokens);
            } 
        }
        // Set inSwapAndLiquify to false to allow for future swaps
        inSwapAndLiquify = false;
    }
    
    // Perform the token transfer with the applicable fees
    _tokenTransfer(from,to,amount);
}

// This function swaps half of the token balance for ETH and adds the other half and the ETH to the liquidity pool
function swapAndLiquify(uint256 tokens) private {
    // Split tokens in half
    uint256 half = tokens / 2;
    uint256 otherHalf = tokens - half;

    // Get the initial balance of the contract
    uint256 initialBalance = address(this).balance;

    // Create a path array with the token and WETH as the tokens to be swapped
    address[] memory path = new address[](2);
    path[0] = address(this);
    path[1] = uniswapV2Router.WETH();

    // Swap tokens for ETH on Uniswap
    uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(
        half,
        0, // accept any amount of ETH
        path,
        address(this),
        block.timestamp);

    // Calculate the amount of ETH received from the swap
    uint256 newBalance = address(this).balance - initialBalance;

    // Add liquidity to the Uniswap pool
    uniswapV2Router.addLiquidityETH{value: newBalance}(
        address(this),
        otherHalf,
        0, // slippage is unavoidable
        0, // slippage is unavoidable
        DEAD,
        block.timestamp
    );

    // Emit event for logging purposes
    emit SwapAndLiquify(half, newBalance, otherHalf);
}

function swapAndSendMarketing(uint256 tokenAmount) private {
    // Get the initial ETH balance of this contract
    uint256 initialBalance = address(this).balance;

    // Specify the token and ETH addresses as the two assets to be swapped
    address[] memory path = new address[](2);
    path[0] = address(this);
    path[1] = uniswapV2Router.WETH();

    // Swap the given amount of tokens for ETH using the Uniswap router contract
    uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(
        tokenAmount,
        0, // accept any amount of ETH
        path,
        address(this),
        block.timestamp);

    // Calculate the new ETH balance of this contract after the swap
    uint256 newBalance = address(this).balance - initialBalance;

    // Send the swapped ETH to the marketing wallet
    payable(marketingWallet).sendValue(newBalance);

    // Emit an event to log the details of the swap and send
    emit SwapAndSendMarketing(tokenAmount, newBalance);
}

      // once enabled, can never be turned off
    function enableTrading() external onlyOwner() {
        tradingEnabled = true;
    }

    // setSwapTokensAtAmount updates the swapTokensAtAmount variable.
// This variable defines the minimum amount of tokens that must be
// held by the contract before it will swap and liquify them
// in the addLiquidityETH function. The function can only be called by
// the contract owner and requires that the new amount is greater than
// 0.001% of the total supply of tokens. If successful, it emits the
// SwapTokensAtAmountUpdated event.
function setSwapTokensAtAmount(uint256 newAmount) external onlyOwner() {
    require(newAmount > totalSupply() / 1e5, "SwapTokensAtAmount must be greater than 0.001% of total supply");
    swapTokensAtAmount = newAmount;
    emit SwapTokensAtAmountUpdated(newAmount);
}

// setSwapEnabled is a function that updates the swapEnabled variable.
// This variable controls whether or not the contract will swap tokens
// and add liquidity to the pool. The function can only be called by
// the contract owner. If successful, it emits the SwapEnabledUpdated event.
function setSwapEnabled(bool _enabled) external onlyOwner {
    swapEnabled = _enabled;
    emit SwapEnabledUpdated(_enabled);
}

 function _tokenTransfer(address sender, address recipient, uint256 amount) private {

    // Check if either sender or recipient is excluded from fees
    if (_isExcludedFromFees[sender] || _isExcludedFromFees[recipient]) {
        // Remove all fees if either sender or recipient is excluded from fees
        removeAllFee();
    } else if (recipient == uniswapV2Pair) {
        // Set sell fee if the recipient is the Uniswap pair
        setSellFee();
    } else {
        // Set buy fee if none of the above conditions are met
        setBuyFee();
    }

    // Determine how the transfer should be handled based on whether the sender and/or recipient are excluded from rewards
    if (_isExcluded[sender] && !_isExcluded[recipient]) {
        _transferFromExcluded(sender, recipient, amount);
    } else if (!_isExcluded[sender] && _isExcluded[recipient]) {
        _transferToExcluded(sender, recipient, amount);
    } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {
        _transferStandard(sender, recipient, amount);
    } else if (_isExcluded[sender] && _isExcluded[recipient]) {
        _transferBothExcluded(sender, recipient, amount);
    } else {
        _transferStandard(sender, recipient, amount);
    }
}

function _transferStandard(address sender, address recipient, uint256 tAmount) private {
    // Get the reflection amount, transfer amount, fee amounts, and liquidity and marketing amounts
    (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity, uint256 tMarketing) = _getValues(tAmount);

    // Deduct the reflected amount from the sender's balance and add the transferred amount to the recipient's balance
    _rOwned[sender] = _rOwned[sender] - rAmount;
    _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;

    // Take the marketing and liquidity fees
    _takeMarketing(tMarketing);
    _takeLiquidity(tLiquidity);

    // Reflect the fees
    _reflectFee(rFee, tFee);

    // Emit a transfer event
    emit Transfer(sender, recipient, tTransferAmount);
}

function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {
    // Get the reflection amount, transfer amount, fee amounts, and liquidity and marketing amounts
    (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity, uint256 tMarketing) = _getValues(tAmount);

    // Deduct the reflected amount from the sender's balance and add the transferred amount to the recipient's balance
    _rOwned[sender] = _rOwned[sender] - rAmount;
    _tOwned[recipient] = _tOwned[recipient] + tTransferAmount;
    _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;

    // Take the marketing and liquidity fees
    _takeMarketing(tMarketing);           
    _takeLiquidity(tLiquidity);

    // Reflect the fees
    _reflectFee(rFee, tFee);

    // Emit a transfer event
    emit Transfer(sender, recipient, tTransferAmount);
}

function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {
    // Get the reflection values for the given token amount
    (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity, uint256 tMarketing) = _getValues(tAmount);
    
    // Decrease the excluded sender's token and reflection balances
    _tOwned[sender] = _tOwned[sender] - tAmount;
    _rOwned[sender] = _rOwned[sender] - rAmount;
    
    // Increase the recipient's reflection balance with the reflection transfer amount
    _rOwned[recipient] = _rOwned[recipient] + rTransferAmount; 
    
    // Deduct marketing and liquidity fees
    _takeMarketing(tMarketing);  
    _takeLiquidity(tLiquidity);
    
    // Reflect the transfer fees in the contract balance
    _reflectFee(rFee, tFee);
    
    // Emit a transfer event
    emit Transfer(sender, recipient, tTransferAmount);
}

function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {
    // Get the reflection values for the given token amount
    (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity, uint256 tMarketing) = _getValues(tAmount);
    
    // Decrease the sender's token and reflection balances
    _tOwned[sender] = _tOwned[sender] - tAmount;
    _rOwned[sender] = _rOwned[sender] - rAmount;
    
    // Increase the recipient's token and reflection balances
    _tOwned[recipient] = _tOwned[recipient] + tTransferAmount;
    _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;
    
    // Deduct marketing and liquidity fees
    _takeMarketing(tMarketing);        
    _takeLiquidity(tLiquidity);
    
    // Reflect the transfer fees in the contract balance
    _reflectFee(rFee, tFee);
    
    // Emit a transfer event
    emit Transfer(sender, recipient, tTransferAmount);
}

    function excludeFromFees(address account, bool excluded) external onlyOwner {
    // Check if the account is already in the desired state
    require(_isExcludedFromFees[account] != excluded, "Account is already the value of 'excluded'");
    
    // Update the state of the account
    _isExcludedFromFees[account] = excluded;

    // Emit an event to notify listeners of the change
    emit ExcludeFromFees(account, excluded);
}

}