{"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller\u0027s account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}"},"ReentrancyGuard.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.19;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot\u0027s contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler\u0027s defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction\u0027s gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}"},"TransferHelper.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity \u003e= 0.6.0;\r\n\r\nimport \"./IERC20.sol\";\r\n\r\nlibrary TransferHelper {\r\n    /// @notice Transfers tokens from the targeted address to the given destination\r\n    /// @notice Errors with \u0027STF\u0027 if transfer fails\r\n    /// @param token The contract address of the token to be transferred\r\n    /// @param from The originating address from which the tokens will be transferred\r\n    /// @param to The destination address of the transfer\r\n    /// @param value The amount to be transferred\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) =\r\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\r\n        require(success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))), \u0027STF\u0027);\r\n    }\r\n\r\n    /// @notice Transfers tokens from msg.sender to a recipient\r\n    /// @dev Errors with ST if transfer fails\r\n    /// @param token The contract address of the token which will be transferred\r\n    /// @param to The recipient of the transfer\r\n    /// @param value The value of the transfer\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\r\n        require(success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))), \u0027ST\u0027);\r\n    }\r\n\r\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\r\n    /// @dev Errors with \u0027SA\u0027 if transfer fails\r\n    /// @param token The contract address of the token to be approved\r\n    /// @param to The target of the approval\r\n    /// @param value The amount of the given token the target will be allowed to spend\r\n    function safeApprove(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\r\n        require(success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))), \u0027SA\u0027);\r\n    }\r\n\r\n    /// @notice Transfers ETH to the recipient address\r\n    /// @dev Fails with `STE`\r\n    /// @param to The destination of the transfer\r\n    /// @param value The value to be transferred\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        require(success, \u0027STE\u0027);\r\n    }\r\n}"},"Web3DebitRouterV3Safe.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.19;\r\n\r\nimport \"./ReentrancyGuard.sol\";\r\nimport \"./TransferHelper.sol\";\r\n\r\n\r\ninterface IGateway {\r\n\r\n    function payment(\r\n        address _store,\r\n        address _token,\r\n        uint _amount,\r\n        uint _memo,\r\n        address _sender,\r\n        uint _source,\r\n        address _tokenin,\r\n        uint amountIn) external returns (bool);\r\n\r\n}\r\n\r\n\r\ninterface IStargateRouter {\r\n\r\n    struct lzTxObj {\r\n        uint256 dstGasForCall;\r\n        uint256 dstNativeAmount;\r\n        bytes dstNativeAddr;\r\n    }\r\n\r\n\r\n    function swap(\r\n        uint16 _dstChainId,\r\n        uint256 _srcPoolId,\r\n        uint256 _dstPoolId,\r\n        address payable _refundAddress,\r\n        uint256 _amountLD,\r\n        uint256 _minAmountLD,\r\n        lzTxObj memory _lzTxParams,\r\n        bytes calldata _to,\r\n        bytes calldata _payload\r\n    ) external payable;\r\n\r\n}\r\n\r\n\r\ninterface ISwapRouterUniswapV3 {\r\n\r\n    struct ExactOutputParams {\r\n        bytes path;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountOut;\r\n        uint256 amountInMaximum;\r\n    }\r\n\r\n\r\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint amountIn);\r\n\r\n\r\n    function refundETH() external payable;\r\n\r\n}\r\n\r\n\r\ncontract Web3DebitRouterV3Safe is ReentrancyGuard {\r\n\r\nIStargateRouter public immutable stargateRouter;\r\n\r\nuint public immutable source;\r\n\r\nIGateway public gateway;\r\naddress public owner;\r\nbool public locked;\r\n\r\nstruct DataToStargate {\r\n\r\n    uint16 dstChainId_;\r\n    uint256 srcPoolId_;\r\n    uint256 dstPoolId_;\r\n    uint256 amountLD_;\r\n    uint256 minAmountLD_;\r\n    uint256 gasfee_;\r\n    uint thememo_;    \r\n    address receiverAddress_;\r\n    address tokenincross_;\r\n    address thestore_;\r\n    address tokenoutcross_;\r\n\r\n}\r\n\r\nstruct DataToStargate1 {\r\n\r\n    address thetokenIn;\r\n    uint thetimeswap;\r\n    uint theamountInMaximum;\r\n    uint theamountpay;\r\n    address receiverAddress;\r\n    address tokenincross;\r\n    address thestore;\r\n    address tokenoutcross;\r\n    uint16 dstChainId;\r\n    uint256 srcPoolId;\r\n    uint256 dstPoolId;\r\n    uint256 amountLD;\r\n    uint256 minAmountLD;\r\n    uint256 gasfee;\r\n    uint thememo;    \r\n\r\n}\r\n\r\nstruct DataSwap {\r\n    address tokenIn;\r\n    address tokenOut;\r\n    uint timeswap;\r\n    uint amountOut;\r\n    uint amountInMaximum;\r\n    address store;\r\n    uint memo;\r\n}\r\n\r\nevent Routed(\r\n    address indexed store,\r\n    address indexed sender,\r\n    uint memo,\r\n    address tokenin,\r\n    address tokenout,\r\n    uint amountin,\r\n    uint amountout,\r\n    uint destchain,\r\n    uint srcpool,\r\n    uint dstpool,\r\n    uint amountoutfixed);\r\n\r\n\r\nevent ReceivedFromStargate(\r\n    uint _nonce,\r\n    address _token,                 \r\n    uint256 amountLD,\r\n    address indexed store,\r\n    address indexed sender,\r\n    uint amountout,\r\n    uint memo,\r\n    uint source);\r\n        \r\n\r\nconstructor(\r\n    IGateway _gateway,\r\n    IStargateRouter _stargateRouter,\r\n    uint _sourcechain,\r\n    address _owner) {\r\n        \r\n    require(_owner != address(0));\r\n    require(_sourcechain \u003e 0);\r\n\r\n    gateway = _gateway;\r\n    source = _sourcechain;\r\n    owner = _owner;\r\n    stargateRouter = _stargateRouter;\r\n}\r\n\r\n\r\nmodifier onlyOwner() {\r\n\r\n    require(msg.sender == owner);\r\n    _;\r\n\r\n}\r\n\r\n\r\nfunction transferOwner(address _newowner) external onlyOwner {\r\n\r\n    require(_newowner != address(0));\r\n    owner = _newowner;\r\n\r\n}\r\n\r\n\r\nfunction lockRouter() external onlyOwner {\r\n\r\n    if (locked) {\r\n        locked = false;\r\n    }\r\n\r\n    if (!locked) {\r\n        locked = true;\r\n    }\r\n\r\n}\r\n\r\n\r\nfunction changeGateway(IGateway _gateway) external onlyOwner {\r\n    \r\n    gateway = _gateway;\r\n\r\n}\r\n\r\n\r\nfunction noSwapPayOnChainSameERC20(address _tokenOut, uint256 _amountOut, address _store, uint _memo) external nonReentrant {\r\n\r\n    require(!locked);\r\n    require(_store != address(0));\r\n    require(_tokenOut != address(0));\r\n    require(_memo \u003e 0);\r\n    require(_amountOut \u003e 0);\r\n\r\n    require(IERC20(_tokenOut).balanceOf(msg.sender) \u003e= _amountOut);\r\n    require(IERC20(_tokenOut).allowance(msg.sender, address(this)) \u003e= _amountOut);\r\n        \r\n    TransferHelper.safeTransferFrom(_tokenOut, msg.sender, address(this), _amountOut);\r\n    TransferHelper.safeApprove(_tokenOut, address(gateway), _amountOut);\r\n\r\n    require(gateway.payment(_store, _tokenOut, _amountOut, _memo, msg.sender, source, _tokenOut, _amountOut));\r\n\r\n    emit Routed(\r\n        _store,\r\n        msg.sender,\r\n        _memo,\r\n        _tokenOut,\r\n        _tokenOut,\r\n        _amountOut,\r\n        _amountOut,\r\n        0,\r\n        0,\r\n        0,\r\n        0);\r\n\r\n}\r\n\r\n\r\nfunction swapExactOutputAndPayOnChainERC20(\r\n    ISwapRouterUniswapV3 _swapRouterUniswapV3,\r\n    bytes memory path,\r\n    address _tokenIn,\r\n    address _tokenOut,\r\n    uint256 _timeswap,\r\n    uint256 _amountOut,\r\n    uint256 _amountInMaximum,\r\n    address _store,\r\n    uint _memo) external nonReentrant {\r\n\r\n    require(!locked);\r\n    require(_store != address(0));\r\n    require(_tokenIn != address(0));\r\n    require(_tokenOut != address(0));\r\n    require(_timeswap \u003e block.timestamp);\r\n    require(_amountOut \u003e 0);\r\n    require(_amountInMaximum \u003e 0);\r\n    require(_memo \u003e 0);\r\n\r\n    DataSwap memory _dataswap = DataSwap(\r\n        _tokenIn,\r\n        _tokenOut,\r\n        _timeswap,\r\n        _amountOut,\r\n        _amountInMaximum,\r\n        _store,\r\n        _memo);\r\n\r\n    _swapExactOutputAndPayOnChainERC20(_dataswap, path, _swapRouterUniswapV3);\r\n\r\n}\r\n\r\n\r\nfunction _swapExactOutputAndPayOnChainERC20(\r\n    DataSwap memory _dataswap,\r\n    bytes memory path,\r\n    ISwapRouterUniswapV3 _swapRouterUniswapV3) internal {\r\n    \r\n    require(IERC20(_dataswap.tokenIn).balanceOf(msg.sender) \u003e= _dataswap.amountInMaximum);\r\n    require(IERC20(_dataswap.tokenIn).allowance(msg.sender, address(this)) \u003e= _dataswap.amountInMaximum);\r\n    \r\n    TransferHelper.safeTransferFrom(_dataswap.tokenIn, msg.sender, address(this), _dataswap.amountInMaximum);\r\n    TransferHelper.safeApprove(_dataswap.tokenIn, address(_swapRouterUniswapV3), _dataswap.amountInMaximum);\r\n        \r\n    uint balancestart = IERC20(_dataswap.tokenOut).balanceOf(address(this));\r\n\r\n    ISwapRouterUniswapV3.ExactOutputParams memory params =\r\n            ISwapRouterUniswapV3.ExactOutputParams({\r\n                path: path,\r\n                recipient: address(this),\r\n                deadline: _dataswap.timeswap,\r\n                amountOut: _dataswap.amountOut,\r\n                amountInMaximum: _dataswap.amountInMaximum\r\n            });\r\n\r\n    uint amountIn = _swapRouterUniswapV3.exactOutput(params);\r\n\r\n    require((IERC20(_dataswap.tokenOut).balanceOf(address(this)) - balancestart) == _dataswap.amountOut);\r\n        \r\n    if (amountIn \u003c _dataswap.amountInMaximum) {\r\n        \r\n        TransferHelper.safeApprove(_dataswap.tokenIn, address(_swapRouterUniswapV3), 0);\r\n        TransferHelper.safeTransfer(_dataswap.tokenIn, msg.sender, _dataswap.amountInMaximum - amountIn);\r\n        \r\n    }\r\n\r\n    TransferHelper.safeApprove(_dataswap.tokenOut, address(gateway), _dataswap.amountOut);\r\n        \r\n    require(gateway.payment(\r\n        _dataswap.store,\r\n        _dataswap.tokenOut,\r\n        _dataswap.amountOut,\r\n        _dataswap.memo,\r\n        msg.sender,\r\n        source,\r\n        _dataswap.tokenIn,\r\n        amountIn));\r\n\r\n    emit Routed(\r\n        _dataswap.store,\r\n        msg.sender,\r\n        _dataswap.memo,\r\n        _dataswap.tokenIn,\r\n        _dataswap.tokenOut,\r\n        amountIn,\r\n        _dataswap.amountOut,\r\n        0,\r\n        0,\r\n        0,\r\n        0);\r\n\r\n}\r\n\r\n\r\nfunction swapExactOutputAndPayOnChainNATIVE(\r\n    ISwapRouterUniswapV3 _swapRouterUniswapV3,\r\n    bytes memory path,\r\n    address _tokenIn,\r\n    address _tokenOut,\r\n    uint256 _timeswap,\r\n    uint256 _amountOut,\r\n    uint256 _amountInMaximum,\r\n    address _store,\r\n    uint _memo) external payable nonReentrant {\r\n\r\n    require(!locked);\r\n    require(_store != address(0));\r\n    require(_tokenIn != address(0));\r\n    require(_tokenOut != address(0));\r\n    require(_timeswap \u003e block.timestamp);\r\n    require(_amountOut \u003e 0);\r\n    require(_amountInMaximum \u003e 0);\r\n    require(_memo \u003e 0);\r\n\r\n    require(msg.value == _amountInMaximum);\r\n\r\n    DataSwap memory _dataswap = DataSwap(\r\n        _tokenIn,\r\n        _tokenOut,\r\n        _timeswap,\r\n        _amountOut,\r\n        _amountInMaximum,\r\n        _store,\r\n        _memo);\r\n\r\n    _swapExactOutputAndPayOnChainNATIVE(_dataswap, path, _swapRouterUniswapV3);\r\n\r\n}\r\n\r\n\r\nfunction _swapExactOutputAndPayOnChainNATIVE(\r\n    DataSwap memory _dataswap,\r\n    bytes memory path,\r\n    ISwapRouterUniswapV3 _swapRouterUniswapV3) internal {\r\n\r\n    uint balancestart = IERC20(_dataswap.tokenOut).balanceOf(address(this));\r\n\r\n    ISwapRouterUniswapV3.ExactOutputParams memory params =\r\n            ISwapRouterUniswapV3.ExactOutputParams({\r\n                path: path,\r\n                recipient: address(this),\r\n                deadline: _dataswap.timeswap,\r\n                amountOut: _dataswap.amountOut,\r\n                amountInMaximum: _dataswap.amountInMaximum\r\n            });\r\n\r\n    uint amountIn = _swapRouterUniswapV3.exactOutput{ value: msg.value }(params);\r\n\r\n    require((IERC20(_dataswap.tokenOut).balanceOf(address(this)) - balancestart) == _dataswap.amountOut);\r\n                \r\n    if (amountIn \u003c _dataswap.amountInMaximum) {\r\n        _swapRouterUniswapV3.refundETH();\r\n        (bool success,) = msg.sender.call{ value: _dataswap.amountInMaximum - amountIn }(\"\");\r\n    }\r\n      \r\n    TransferHelper.safeApprove(_dataswap.tokenOut, address(gateway), _dataswap.amountOut);  \r\n     \r\n    require(gateway.payment(\r\n        _dataswap.store,\r\n        _dataswap.tokenOut,\r\n        _dataswap.amountOut,\r\n        _dataswap.memo,\r\n        msg.sender,\r\n        source,\r\n        _dataswap.tokenIn,\r\n        amountIn));\r\n\r\n    emit Routed(\r\n        _dataswap.store,\r\n        msg.sender,\r\n        _dataswap.memo,\r\n        _dataswap.tokenIn,\r\n        _dataswap.tokenOut,\r\n        amountIn,\r\n        _dataswap.amountOut,\r\n        0,\r\n        0,\r\n        0,\r\n        0);\r\n\r\n}\r\n\r\n\r\nfunction withdrawEther() external payable onlyOwner nonReentrant {\r\n  \r\n    (bool sent,) = owner.call{value: address(this).balance}(\"\");\r\n    require(sent, \"Failed to send Ether\");\r\n\r\n}\r\n\r\n\r\nfunction balanceEther() external view returns (uint) {\r\n \r\n    return address(this).balance;\r\n\r\n}\r\n\r\n\r\nfunction swapToStargate(\r\n    uint16 dstChainId,\r\n    uint256 srcPoolId,\r\n    uint256 dstPoolId,\r\n    uint256 amountLD,\r\n    uint256 minAmountLD,\r\n    uint256 gasfee,\r\n    address receiverAddress,\r\n    address tokenincross,\r\n    address thestore,\r\n    uint thememo,    \r\n    address tokenoutcross,\r\n    uint theamountpay) external payable nonReentrant {\r\n\r\n    require(!locked);\r\n    require(msg.value \u003e 0);\r\n\r\n    require(amountLD \u003e 0);\r\n    require(minAmountLD \u003e 0);\r\n    require(dstChainId \u003e 0);\r\n    require(srcPoolId \u003e 0);\r\n    require(dstPoolId \u003e 0);\r\n    require(gasfee \u003e 0);\r\n    require(receiverAddress != address(0));\r\n    require(tokenincross != address(0));\r\n    require(thestore != address(0));\r\n    require(tokenoutcross != address(0));\r\n    require(thememo \u003e 0);\r\n    require(theamountpay \u003e 0);\r\n\r\n    DataToStargate memory _datastargate = DataToStargate(\r\n        dstChainId,\r\n        srcPoolId,\r\n        dstPoolId,\r\n        amountLD,\r\n        minAmountLD,\r\n        gasfee,\r\n        thememo,    \r\n        receiverAddress,\r\n        tokenincross,\r\n        thestore,\r\n        tokenoutcross);\r\n\r\n    _swapToStargate(_datastargate, theamountpay);\r\n    \r\n}\r\n\r\n\r\nfunction _swapToStargate(DataToStargate memory _datastargate, uint theamountpay) internal {\r\n    \r\n    require(IERC20(_datastargate.tokenincross_).balanceOf(msg.sender) \u003e= _datastargate.amountLD_);\r\n    require(IERC20(_datastargate.tokenincross_).allowance(msg.sender, address(this)) \u003e= _datastargate.amountLD_);\r\n        \r\n    TransferHelper.safeTransferFrom(_datastargate.tokenincross_, msg.sender, address(this), _datastargate.amountLD_);\r\n    TransferHelper.safeApprove(_datastargate.tokenincross_, address(stargateRouter), _datastargate.amountLD_);\r\n    \r\n    bytes memory data = abi.encode(\r\n        _datastargate.thestore_,\r\n        _datastargate.tokenoutcross_,\r\n        theamountpay,\r\n        _datastargate.thememo_,\r\n        msg.sender,\r\n        source,\r\n        _datastargate.tokenincross_,\r\n        _datastargate.amountLD_);\r\n\r\n    stargateRouter.swap{value:msg.value}(\r\n        _datastargate.dstChainId_,                          \r\n        _datastargate.srcPoolId_,                           \r\n        _datastargate.dstPoolId_,                           \r\n        payable(msg.sender),                      \r\n        _datastargate.amountLD_,                  \r\n        _datastargate.minAmountLD_,               \r\n        IStargateRouter.lzTxObj(_datastargate.gasfee_, 0, \"0x\"), \r\n        abi.encodePacked(_datastargate.receiverAddress_),    \r\n        data);                     \r\n\r\n    emit Routed(\r\n        _datastargate.thestore_,\r\n        msg.sender,\r\n        _datastargate.thememo_,\r\n        _datastargate.tokenincross_,\r\n        _datastargate.tokenoutcross_,\r\n        _datastargate.amountLD_,\r\n        theamountpay,\r\n        _datastargate.dstChainId_,\r\n        _datastargate.srcPoolId_,\r\n        _datastargate.dstPoolId_,\r\n        _datastargate.minAmountLD_);\r\n\r\n}\r\n\r\n\r\nfunction swapExactOutputAndPayCrossChainERC20(\r\n    ISwapRouterUniswapV3 _swapRouterUniswapV3,\r\n    bytes memory path,   \r\n    DataToStargate1 memory datastruct) external payable nonReentrant {   \r\n        \r\n    require(!locked);\r\n    require(msg.value \u003e 0);\r\n\r\n    DataToStargate1 memory data = datastruct;\r\n\r\n    require(data.thetokenIn != address(0));\r\n    require(data.thetimeswap \u003e 0);\r\n    require(data.theamountInMaximum \u003e 0);\r\n    require(data.theamountpay \u003e 0);\r\n    require(data.receiverAddress != address(0));\r\n    require(data.tokenincross != address(0));\r\n    require(data.thestore != address(0));\r\n    require(data.tokenoutcross != address(0));\r\n    require(data.dstChainId \u003e 0);\r\n    require(data.srcPoolId \u003e 0);\r\n    require(data.dstPoolId \u003e 0);\r\n    require(data.amountLD \u003e 0);\r\n    require(data.minAmountLD \u003e 0);\r\n    require(data.gasfee \u003e 0);\r\n    require(data.thememo \u003e 0);    \r\n\r\n    _swapExactOutputAndPayCrossChainERC20(data, path, _swapRouterUniswapV3);\r\n\r\n}\r\n\r\n\r\nfunction _swapExactOutputAndPayCrossChainERC20(\r\n    DataToStargate1 memory data,\r\n    bytes memory path,\r\n    ISwapRouterUniswapV3 _swapRouterUniswapV3) internal {\r\n\r\n    require(IERC20(data.thetokenIn).balanceOf(msg.sender) \u003e= data.theamountInMaximum);\r\n    require(IERC20(data.thetokenIn).allowance(msg.sender, address(this)) \u003e= data.theamountInMaximum);\r\n        \r\n    TransferHelper.safeTransferFrom(data.thetokenIn, msg.sender, address(this), data.theamountInMaximum);\r\n    TransferHelper.safeApprove(data.thetokenIn, address(_swapRouterUniswapV3), data.theamountInMaximum);\r\n    \r\n    uint balancestart = IERC20(data.tokenincross).balanceOf(address(this));\r\n    \r\n    ISwapRouterUniswapV3.ExactOutputParams memory params =\r\n            ISwapRouterUniswapV3.ExactOutputParams({\r\n                path: path,\r\n                recipient: address(this),\r\n                deadline: data.thetimeswap,\r\n                amountOut: data.amountLD,\r\n                amountInMaximum: data.theamountInMaximum\r\n            });\r\n\r\n    uint amountIn = _swapRouterUniswapV3.exactOutput(params);\r\n\r\n    require((IERC20(data.tokenincross).balanceOf(address(this)) - balancestart) == data.amountLD);\r\n        \r\n    if (amountIn \u003c data.theamountInMaximum) {\r\n        \r\n        TransferHelper.safeApprove(data.thetokenIn, address(_swapRouterUniswapV3), 0);\r\n        TransferHelper.safeTransfer(data.thetokenIn, msg.sender, data.theamountInMaximum - amountIn);\r\n        \r\n    }\r\n\r\n    TransferHelper.safeApprove(data.tokenincross, address(stargateRouter), data.amountLD);  \r\n        \r\n    _swapToStargateFromERC20(data, amountIn);\r\n\r\n}\r\n\r\n\r\nfunction _swapToStargateFromERC20(\r\n    DataToStargate1 memory data,\r\n    uint amountIn) internal {\r\n\r\n    bytes memory dataencoded = abi.encode(\r\n        data.thestore,\r\n        data.tokenoutcross,\r\n        data.theamountpay,\r\n        data.thememo,\r\n        msg.sender,\r\n        source,\r\n        data.thetokenIn,\r\n        amountIn);\r\n\r\n    stargateRouter.swap{value:msg.value}(\r\n        data.dstChainId,          \r\n        data.srcPoolId,           \r\n        data.dstPoolId,           \r\n        payable(msg.sender),                \r\n        data.amountLD,            \r\n        data.minAmountLD,         \r\n        IStargateRouter.lzTxObj(data.gasfee, 0, \"0x\"), \r\n        abi.encodePacked(data.receiverAddress),    \r\n        dataencoded);                     \r\n\r\n    emit Routed(\r\n        data.thestore,\r\n        msg.sender,\r\n        data.thememo,\r\n        data.thetokenIn,\r\n        data.tokenoutcross,\r\n        amountIn,\r\n        data.theamountpay,\r\n        data.dstChainId,\r\n        data.srcPoolId,\r\n        data.dstPoolId,\r\n        data.minAmountLD);\r\n\r\n}\r\n\r\n\r\nfunction swapExactOutputAndPayCrossChainNATIVE(\r\n    ISwapRouterUniswapV3 _swapRouterUniswapV3,\r\n    bytes memory path,   \r\n    DataToStargate1 memory datastruct) external payable nonReentrant {\r\n    \r\n    require(!locked);\r\n    require(msg.value \u003e 0);\r\n  \r\n    DataToStargate1 memory data = datastruct;\r\n\r\n    require(data.thetokenIn != address(0));\r\n    require(data.thetimeswap \u003e 0);\r\n    require(data.theamountInMaximum \u003e 0);\r\n    require(data.theamountpay \u003e 0);\r\n    require(data.receiverAddress != address(0));\r\n    require(data.tokenincross != address(0));\r\n    require(data.thestore != address(0));\r\n    require(data.tokenoutcross != address(0));\r\n    require(data.dstChainId \u003e 0);\r\n    require(data.srcPoolId \u003e 0);\r\n    require(data.dstPoolId \u003e 0);\r\n    require(data.amountLD \u003e 0);\r\n    require(data.minAmountLD \u003e 0);\r\n    require(data.gasfee \u003e 0);\r\n    require(data.thememo \u003e 0);    \r\n\r\n    _swapExactOutputAndPayCrossChainNATIVE(data, path, _swapRouterUniswapV3);\r\n\r\n}\r\n\r\n\r\nfunction _swapExactOutputAndPayCrossChainNATIVE(\r\n    DataToStargate1 memory data,\r\n    bytes memory path,\r\n    ISwapRouterUniswapV3 _swapRouterUniswapV3) internal {\r\n\r\n    uint balancestart = IERC20(data.tokenincross).balanceOf(address(this));\r\n\r\n    ISwapRouterUniswapV3.ExactOutputParams memory params =\r\n            ISwapRouterUniswapV3.ExactOutputParams({\r\n                path: path,\r\n                recipient: address(this),\r\n                deadline: data.thetimeswap,\r\n                amountOut: data.amountLD,\r\n                amountInMaximum: data.theamountInMaximum\r\n            });\r\n\r\n    uint amountIn = _swapRouterUniswapV3.exactOutput{ value: data.theamountInMaximum }(params);\r\n\r\n    require((IERC20(data.tokenincross).balanceOf(address(this)) - balancestart) == data.amountLD);\r\n\r\n    if (amountIn \u003c data.theamountInMaximum) {\r\n        _swapRouterUniswapV3.refundETH();\r\n        (bool success,) = msg.sender.call{ value: data.theamountInMaximum - amountIn }(\"\");\r\n    }\r\n    \r\n    TransferHelper.safeApprove(data.tokenincross, address(stargateRouter), data.amountLD);  \r\n        \r\n    _swapToStargateFromNATIVE(data, amountIn);\r\n\r\n}\r\n\r\n\r\nfunction _swapToStargateFromNATIVE(\r\n    DataToStargate1 memory data,\r\n    uint amountIn) internal {\r\n    \r\n    bytes memory dataencoded = abi.encode(\r\n        data.thestore,\r\n        data.tokenoutcross,\r\n        data.theamountpay,\r\n        data.thememo,\r\n        msg.sender,\r\n        source,\r\n        data.thetokenIn,\r\n        amountIn);\r\n\r\n    stargateRouter.swap{value:msg.value - data.theamountInMaximum}(\r\n        data.dstChainId,                         \r\n        data.srcPoolId,                          \r\n        data.dstPoolId,                          \r\n        payable(msg.sender),                      \r\n        data.amountLD,                  \r\n        data.minAmountLD,\r\n        IStargateRouter.lzTxObj(data.gasfee, 0, \"0x\"),\r\n        abi.encodePacked(data.receiverAddress),   \r\n        dataencoded);                     \r\n\r\n   emit Routed(\r\n        data.thestore,\r\n        msg.sender,\r\n        data.thememo,\r\n        data.thetokenIn,\r\n        data.tokenoutcross,\r\n        amountIn,\r\n        data.theamountpay,\r\n        data.dstChainId,\r\n        data.srcPoolId,\r\n        data.dstPoolId,\r\n        data.minAmountLD);\r\n\r\n}\r\n\r\n\r\nfunction sgReceive(\r\n    uint16 /*_srcChainId*/,            \r\n    bytes memory /*_srcAddress*/,      \r\n    uint256 _nonce,                  \r\n    address _token,                \r\n    uint256 amountLD,              \r\n    bytes memory payload) external nonReentrant {\r\n\r\n    require(msg.sender == address(stargateRouter)); \r\n\r\n    (address thestore,\r\n     address thetoken,\r\n     uint theamount,\r\n     uint thememo,\r\n     address thesender,\r\n     uint thesource,\r\n     address thetokenin,\r\n     uint theamountin) = abi.decode(payload, (address, address, uint, uint, address, uint, address, uint));\r\n\r\n \r\n    if (amountLD \u003e theamount) {\r\n        \r\n        TransferHelper.safeTransfer(thetoken, thesender, amountLD - theamount);\r\n        \r\n    }\r\n\r\n    TransferHelper.safeApprove(thetoken, address(gateway), theamount);  \r\n    \r\n    require(gateway.payment(thestore, thetoken, theamount, thememo, thesender, thesource, thetokenin, theamountin));\r\n\r\n    emit ReceivedFromStargate(\r\n        _nonce,\r\n        _token,\r\n        amountLD,\r\n        thestore,\r\n        thesender,\r\n        theamount,\r\n        thememo,\r\n        thesource);\r\n    \r\n}    \r\n\r\n\r\nreceive() payable external {}\r\n\r\n}"}}