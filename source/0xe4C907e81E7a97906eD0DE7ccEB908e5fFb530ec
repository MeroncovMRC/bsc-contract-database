{"AdminContext.sol":{"content":"\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"./Authorizer.sol\"; \nimport \"./Validator.sol\";\nimport \"./Interfaces.sol\"; \n\ncontract AdminContext {\n\n\tbool public _is_active; \n\tuint internal _integer_multiplier;\n\tuint internal _rewards_percentage_per_epoch;\n\tuint internal _stake_tax_percentage;\n\tuint internal _unstake_tax_percentage;\n\tuint internal _rewards_frequency_in_minutes;\n\tAuthorizer _contract_authorizer; \n\taddress private _staking_token; \n\n\tconstructor() {\n\t\t_contract_authorizer = new Authorizer(msg.sender);\n\t}\n\n\t// Modifiers\n\tmodifier isAuthorized() {\n\t\trequire(_contract_authorizer.getDeployer() == msg.sender, \"You do not have the authority for that.\"); \n\t\t_;\n\t}\n\n\tfunction GetAdminAddress() isAuthorized public view returns(address) {\n\t\treturn _contract_authorizer.getDeployer();\n\t}\n\n\t/**\n\t * Returns the available tokens for staking rewards in the contract\n\t */ \n\tfunction GetAvailableStakingBalance() isAuthorized public view returns(uint256) {\n\t\treturn IBEP20(_staking_token).balanceOf(address(this));\n\t}\n\n\tfunction GetIntegerMultiplier() public view returns(uint) {\n\t\treturn _integer_multiplier;\n\t}\n\n\tfunction GetRewardsFrequencyInMinutes() public view returns(uint) {\n\t\treturn _rewards_frequency_in_minutes;\n\t}\n\n\tfunction GetRewardsPercentagePerEpoch() public view returns(uint) {\n\t\treturn _rewards_percentage_per_epoch; \n\t}\n\n\tfunction GetStakingTokenAddress() public view returns(address) {\n\t\treturn _staking_token;\n\t}\n\n\tfunction GetStakeTaxPercentage() public view returns(uint) {\n\t\treturn _stake_tax_percentage;\n\t}\n\n\tfunction GetUnstakeTaxPercentage() public view returns(uint) {\n\t\treturn _unstake_tax_percentage;\n\t}\n\n\tfunction IsStakingActive() internal view returns(bool) {\n\t\treturn _is_active;\n\t}\n\n\t/**\n\t * Checks if the staking is active\n\t */ \n\tfunction Pause() isAuthorized public {\n\t\t_is_active = false;\n\t}\n\n\tfunction SetIntegerMultiplier(uint _value) isAuthorized public {\n\t\trequire(_value \u003e 0, \"Integer multiplier needs to be greater than 0\"); \n\t\t_integer_multiplier = _value; \n\t}\n\n\t/**\n\t * Sets reward frequency\n\t */\n\tfunction SetRewardsFrequency(uint _value) isAuthorized public {\n\t\trequire(_value \u003e 0, \"Rewarards frequency cannot be 0\");\n\t\t_rewards_frequency_in_minutes = _value;\n\t}\n\n\t/**\n\t * Set the percentage of reward \n\t */ \n\tfunction SetRewardsPercentage(uint _value) isAuthorized public {\n\t\trequire(_value \u003e 0, \"Rewards percentage value cannot be 0\");\n\t\t_rewards_percentage_per_epoch = _value; \n\t}\n\n\tfunction SetStakingTokenAddress(address input) isAuthorized public {\n\t\t// TODO: secure the value of input\n\t\t_staking_token = input;\n\t}\n\n\tfunction SetStakeTaxPercentage(uint _value) isAuthorized public {\n\t\trequire(_value \u003e 0, \"Tax percentage input needs to be more than 0\");\n\t\t_stake_tax_percentage =  _value; \n\t}\n\n\tfunction SetUnstakeTaxPercentage(uint _value) isAuthorized public {\n\t\trequire(_value \u003e 0, \"Tax percentage input needs to be more than 0\");\n\t\t_unstake_tax_percentage =  _value; \n\t}\n\n\t/**\n\t * Sets to start / unpause the staking\n\t */ \n\tfunction UnPause() isAuthorized public {\n\t\t_is_active = true; \n\t}\n}"},"Authorizer.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ncontract Authorizer {\n\taddress internal _deployer;\n\n\tconstructor(address owner) {\n\t\t_deployer = owner;\n\t}\n\n\t// Modifiiers\n\tmodifier isDeployer() {\n\t\trequire(_deployer == msg.sender, \"You have no authroity to interact with this contract\");\n\t\t_; \n\t}\n\n\tfunction getDeployer() public view returns(address) {\n\t\treturn _deployer;\n\t}\n\n}"},"Interfaces.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IBEP20 {\n\tfunction totalSupply() external view returns (uint256);\n\tfunction decimals() external view returns (uint8);\n\tfunction symbol() external view returns (string memory);\n\tfunction name() external view returns (string memory);\n\tfunction getOwner() external view returns (address);\n\tfunction balanceOf(address account) external view returns (uint256);\n\tfunction transfer(address recipient, uint256 amount) external returns (bool);\n\tfunction allowance(address _owner, address spender) external view returns (uint256);\n\tfunction approve(address spender, uint256 amount) external returns (bool);\n\tfunction transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n}"},"OPPAstaking.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"./AdminContext.sol\";\nimport \"./Authorizer.sol\";\nimport \"./Interfaces.sol\"; \nimport \"./StakerContext.sol\";\nimport \"./TaxerContext.sol\";\nimport \"./Validator.sol\";\t\n\n\ncontract OPPA_staking is AdminContext, StakerContext, TaxerContext {\n\tuint256 private _staking_tax_in_percentage = 0;\n\tuint256 private _untaking_tax_in_percentage = 0;\n\n\tValidator _validator; \n\n\tconstructor(address token, uint frequency, uint percentage, uint integerMultipler, uint stakingTax, uint unstakingTax ) {\n\t\t_validator = new Validator(); \n\t\tSetStakingTokenAddress(token);\n\t\tSetRewardsFrequency(frequency);\n\t\tSetRewardsPercentage(percentage); \n\t\tSetIntegerMultiplier(integerMultipler);\n\t\tSetStakeTaxPercentage(stakingTax);\n\t\tSetUnstakeTaxPercentage(unstakingTax);\n\t}\n\n\t\n\tstruct StakeSummary {\n\t\tuint block_time;\n\t\tuint256 total_rewards;\n\t\tuint start_time;\t\n\t\tuint difference; \n\t}\n\n\t// Events\n\tevent LogRewards(uint256 totalRewards);\n\n\t/**\n\t * Returns the following values\n\t * frequency - total number of iterations to generate\n\t */\n\tfunction _getFrequency(uint differenceInSeconds) private view returns(uint) {\n\t\tuint totalMinutes = differenceInSeconds / 60; \n\t\tuint frequency = totalMinutes / _rewards_frequency_in_minutes; \n\n\t\treturn frequency;\n\t}\n\n\t/**\n\t * Simple Interest formula\n\t * NOTE: at this point, the _rewards_percentage_per_epoch has already been multiplied with the multiplier, \n\t * therefore, the final result should be divided wite the multiplier for the actual count.\n\t */\n\tfunction _getRewards(uint256 principal, uint since) private view returns(uint256) {\n\t\treturn (((block.timestamp - since) / 15 minutes) * principal) / _rewards_percentage_per_epoch;\n\t}\n\n\t/**\n\t * Method to fetch all the stake holders in the contract\n\t */\n\tfunction GetAllStakeholders() isAuthorized public view returns(Stakeholder[] memory) {\n\t\treturn _stakeholders;\n\t}\n\n\t/**\n\t * Method to generate the stake summary\n\t */\n\tfunction GetStakeSummary() public view returns(StakeSummary memory) {\n\t\tStakeholder memory stakeholder = _stakeholders[stakes[msg.sender]]; \n\n\t\tuint startTime = stakeholder.address_stakes[0].since;\n\t\tuint256 stakedAmount = stakeholder.address_stakes[0].amount;\n\n\t\t// Iterations\n\t\tuint difference = block.timestamp - startTime;\n\t\tuint256 totalRewards;\n\t\t\n\t\tif((difference / 60) \u003e 2) {\n\t\t\ttotalRewards = _getRewards(stakedAmount, startTime);\n\t\t} else {\n\t\t\t// These are the default values that should be returned when there is no iteraton ( based on frequency ) \n\t\t\t// that has happened yet\n\t\t\ttotalRewards = 0; \n\t\t}\n\n\t\tStakeSummary memory summary = StakeSummary(\n\t\t\tblock.timestamp,\n\t\t\ttotalRewards,\n\t\t\tstartTime,\n\t\t\tdifference);\n\n\t\treturn summary; \n\t}\n\n\t/**\n\t * Returns the number of staholders in the contract\n\t */\n\tfunction GetStakeHolderCount() isAuthorized public view returns(uint) {\n\t\treturn _stakeholders.length;    \n\t}\n\n\t/**\n\t * Returns the current staking data of of the caller\n\t */\n\tfunction GetStakes() public view returns (Stake memory) {\n\t\tuint256 holder_index = stakes[msg.sender];\n\t\tStake memory current_stake = _stakeholders[holder_index].address_stakes[0];\n\n\t\treturn current_stake; \n\t}\n\n\tfunction GetTotalStaked() isAuthorized public view returns(uint256) {\n\n\t\tuint256 totalStaked; \n\n\t\tfor(uint i = 0; i \u003c _stakeholders.length; i++) {\n\t\t\tStake memory hodlerStake = _stakeholders[i].address_stakes[0]; // This is 0 for now because we are using only one slot at a time\n\n\t\t\ttotalStaked += hodlerStake.amount; \n\t\t}\n\n\t\treturn totalStaked;\n\t}\n\n\t/**\n\t * Initializes the process of staking tokens\n\t */\n\tfunction StakeTokens(uint256 amount) public returns(bool success){\n\t\trequire(IsStakingActive() == true, \"Staking is not active as of the moment.\");\n\t\trequire(amount \u003e 0, \"Cannot stake nothing\");\n\t\trequire(_validator.CanStake(msg.sender, GetStakingTokenAddress()) == true, \"Balance check failed.\");\n\n\t\tuint256 valueTostake = deductTax(_stake_tax_percentage, amount, _integer_multiplier);\n\t\t_initStake(valueTostake);\n\n\t\treturn true;\n\t}\n\n\tfunction UnstakeTokens() public returns (bool success) {\n\t\trequire(IBEP20(GetStakingTokenAddress()).balanceOf(address(this)) \u003e 0, \"The contract does not have any balance\"); \n\t\t// Checks to see if the holder is indeed a staker\n\t\tStake memory stake = GetStakes();\n\t\trequire(stake.holder != address(0), \"The sender is not a valid stake holder.\"); \n\n\t\tStakeSummary memory summary = GetStakeSummary();\n\n\t\tuint256 convertedRewards = summary.total_rewards / _integer_multiplier; \n\n\t\tuint256 stakePlusRewards = convertedRewards + stake.amount;\n\t\tuint256 totalMinusTax = deductTax(_unstake_tax_percentage, stakePlusRewards, _integer_multiplier);\n\n\t\trequire(totalMinusTax \u003e 0, \"Rewards to send must have a value\");\n\t\tIBEP20(GetStakingTokenAddress()).transfer(msg.sender, totalMinusTax);\n\n\t\t_initUnstake(msg.sender);\n\t\treturn true; \n\t}\n}"},"StakerContext.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ncontract StakerContext {\n\t// structures\n\tstruct Stake {\n\t\taddress holder;\n\t\tuint256 amount;\n\t\tuint256 since;\n\t}\n\n\tstruct Stakeholder {\n\t\taddress holder;\n\t\tStake[] address_stakes;\n\t}\n\n\tStakeholder[] internal _stakeholders;\t\n\n\t// Mappings\n\tmapping(address =\u003e uint256) internal stakes;\n\n\t// Events\n\tevent Staked(address indexed staker, uint256 amount, uint256 index, uint256 timestamp); \n\n\t/**\n\t * adds a new staker account in the array of stakeholers. \n\t */\n\tfunction _addStakeHolder(address staker) private returns (uint256) {\n\t\t// Push a empty item to the Array to make space for our new stakeholder\n\t\t_stakeholders.push();\n\t\t// Calculate the index of the last item in the array by Len-1\n\t\tuint256 holderIndex = _stakeholders.length - 1;\n\t\t// Assign the address to the new index\n\t\t_stakeholders[holderIndex].holder = staker;\n\t\t// Add index to the _stakeHolders\n\t\tstakes[staker] = holderIndex;\n\t\treturn holderIndex; \n\t}\n\n\t/**\n\t * Excutes the process of staking tokens\n\t */\n\tfunction _initStake(uint256 amount) internal returns(bool success) { \n\n\t\t// Mappings in solidity creates all values, but empty, so we can just check the address\n\t\tuint256 index = stakes[msg.sender];\n\t\t\n\t\t// block.timestamp = timestamp of the current block in seconds since the epoch\n\t\tuint256 timestamp = block.timestamp;\n\t\t\n\t\t// See if the staker already has a staked index or if its the first time\n\t\tif(index == 0){\n\t\t\t// This stakeholder stakes for the first time\n\t\t\t// We need to add him to the stakeHolders and also map it into the Index of the stakes\n\t\t\t// The index returned will be the index of the stakeholder in the stakeholders array\n\t\t\tindex = _addStakeHolder(msg.sender);\n\t\t}\n\n\t\t// Use the index to push a new Stake\n\t\t// push a newly created Stake with the current block timestamp.\n\t\t_stakeholders[index].address_stakes.push(Stake(msg.sender, amount, timestamp));\n\t\t// Emit an event that the stake has occured\n\t\temit Staked(msg.sender, amount, index,timestamp);\n\n\t\treturn true;\n\t}\n\n\tfunction _initUnstake(address holder) internal returns(bool success) {\n\t\tuint256 userIndex = stakes[holder];\n\t\tdelete _stakeholders[userIndex];\n\t\treturn true;\n\t}\n}\n"},"TaxerContext.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ncontract TaxerContext {\n\n\tfunction deductTax(uint256 tax, uint256 amount, uint intMultiplier ) internal pure returns(uint256) {\n\t\trequire(amount \u003e 0, \"You need a base value to deduct tax from\");\n\n\t\tif(tax == 0) { // returns the amount if tax is 0\n\t\t\treturn amount;\n\t\t} \n\n\t\tuint256 denominator = 100*intMultiplier;\n\n\t\t// At this point, \"tax\" has been multiplied by the multiplier use only integers\n\t\tuint256 valueToDeduct = (amount / denominator ) * tax; \n\t\treturn amount - valueToDeduct;\n\t}\n}"},"Validator.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"./Authorizer.sol\";\nimport \"./Interfaces.sol\";\n\ncontract Validator {\n\tuint256 private _minimum_balance = 1; \n\n\tfunction GetTokenBalance(address wallet, address token) public view returns(uint256) {\n\t\treturn IBEP20(token).balanceOf(wallet);\n\t}\n\n\tfunction CanStake(address wallet, address token) public view returns(bool success) {\n\t\trequire(GetTokenBalance(wallet, token) \u003e _minimum_balance, \"There is not enough balance for you to stake\"); \n\t\treturn true; \n\t}\n}"}}