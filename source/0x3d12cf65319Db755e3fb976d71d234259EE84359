// SPDX-License-Identifier: Unlicensed

pragma solidity ^0.8.15;

library SafeMath {
    

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return a - b;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        return a * b;
    }
    
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        unchecked {
            require(b <= a, errorMessage);
            return a - b;
        }
    }
    
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a / b;
        }
    }
    
}


contract FBOYpool { 
    using SafeMath for uint256;
    function owner() public view virtual returns (address) {
        return _owner;
    }
    modifier onlyOwner() {
        require(owner() == msg.sender, "Ownable: caller is not the owner");
        _;
    }

    
    mapping(address => bool) private _whiteList;
    address private _owner;
    address public Wallet_Fboy=0x8A3708EbDCA49b2324e1ef5dfE2421A350A14B0F;
    address payable public Wallet_USDT= payable(0x55d398326f99059fF775485246999027B3197955);
    address payable public  Wallet_SQ=payable(0xA2361ACb4BF405cC1AE7a5c1947545eCf59EdA06);
    address payable public Wallet_Project = payable(0x36f2dAE586cC46fA9fbfe10DdadBbBbfFd178AD8);
    
    address public Wallet_CakeLP=0xE76992ED0a780793C3DCF6906A6A910A031ECEcB;
    address public  FboyPair=0xE76992ED0a780793C3DCF6906A6A910A031ECEcB;

    address public Wallet_GoldPool=0x906E766c1686f18a9e067A8AD54acAD45c077d30;
    address payable public constant Wallet_Burn = payable(0x000000000000000000000000000000000000dEaD); 
    
    poolInterFace GoldPool;

    uint256 public totalSharepool;
    uint256 public totalPromotionpool;
    uint256 public totalFoundationpool;
    uint256 public  totalLPpool;
    uint256 public whiteUserCount; 
    uint256 public PromotionUserCount; 
    uint256 public FoundationUserCount; 
    uint256 public LPGivenBonus;
    uint8 private constant _decimals = 18;
    uint256 public totalLP; 
    uint256 public  totalMine;

    uint256 constant public TIME_STEP = 1 days;
    uint256 public totalpool; 
     uint256 public maxpool; 
     uint256 public  hgamount;
    
    uint256[15] public DynamicRate;
    
    uint256 public   preRate;
    uint256 public   curRate;
    uint256 public   Ratetime;

    uint256 public _startTime;  
     IUniswapV2Router02 public uniswapV2Router;
    uint256 public UsdtRate;
    uint256 public FboyRate;
    uint256 public SqRate;
    uint256 public ProjectfeeRate;
    uint256 public lcfeeRate;
    uint256 public fundfeeRate;
    uint256 public LPStopTime;

    uint256 constant public PERCENTS_DIVIDER = 1000;
     bool private swapping;
    

    struct User {
        address referrer;
        Deposit[] Minelists;
        address[] teams;
        uint256 Minecheckpoint;
        uint256 totalMine;
        uint256 Minewithdrawn;
        uint256 Minecanwithdrawn;
        uint256 DirectCount;
        uint256 DirectAmount;
        //uint256 TeamAmount;
       
    }
     struct LpUser {
        Deposit[] LPlists;
        uint256 LPcheckpoint;
        uint256 totalLP;
        uint256 LPwithdrawn;
        uint256 LPcanwithdrawn;

    }

    struct Deposit {
        uint256 amount;
        uint256 Deposittype;
        uint256 start;
    }
    struct ShareUser {
         uint256 SharePoint;
        uint256 PromotionPoint;
        uint256 FoundationPoint;
        uint256 LPSharePoint;
        uint256 whiteUser;
        bool PromotionUser;
        bool FoundationUser;
    }

   

    mapping(address => User) public Users;
    mapping(address => ShareUser) public ShareUsers;
    mapping(address => LpUser) public LpUsers;
    
    event WithdrawnPool(address indexed user, uint256 amount, uint256 pooltype);
    event AddLP(address indexed user, uint256 amount1, uint256 amount2);
    event RemoveLP(address indexed user, uint256 amount);
    event WithdrawnLP(address indexed user, uint256 amount);
    event WithdrawnMine(address indexed user, uint256 amount);
    event Mining(address indexed user, uint256 amount);
    
    constructor () {
        _owner=msg.sender;
        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E); 
        uniswapV2Router = _uniswapV2Router;
        LPGivenBonus=1100000 *10 ** _decimals;
        maxpool=100*10**_decimals;
        hgamount=5*10**_decimals;
        DynamicRate=[15,10,10,10,5,5,5,5,5,3,3,3,3,3,3];
        GoldPool=poolInterFace(Wallet_GoldPool);
        LPStopTime=1685462400;
        curRate=10;
        UsdtRate=400;
        FboyRate=400;
        SqRate=200;

        ProjectfeeRate=10;
        lcfeeRate=2;
        fundfeeRate=3;
        
        _whiteList[Wallet_Fboy] = true;

    }

    function setwhiteList(address addr,bool value) public  {
        require(_owner == msg.sender);
         _whiteList[addr] = value;
    }

    receive() external payable {}

    function addLP(address referrer,uint256 usdtAmount ) public   returns (bool){
       require( block.timestamp>_startTime , "It's not startTime1");
        
        require(IERC20(Wallet_USDT).balanceOf(msg.sender) >=usdtAmount, "have not enough USDT token.");   
        
        //uint256[] memory  FboyAmounts=getAmounts(Wallet_Fboy,usdtAmount);
        //uint256 FboyAmount=FboyAmounts[FboyAmounts.length - 1];
        uint256  FboyAmount=usdtAmount*10**_decimals/tokenPrice();
 
        require(FboyAmount > 0,'error1');
        
        require(IERC20(Wallet_Fboy).balanceOf(msg.sender) >=FboyAmount, "have not enough  FBOY token.");   
        LpUser storage user=LpUsers[msg.sender];
        //先计算可提现
        uint256 candwithdrawlp=CanWithdrawLP(msg.sender);
        user.LPcanwithdrawn=user.LPcanwithdrawn+candwithdrawlp;
        user.LPcheckpoint=block.timestamp;
        safeTransferFrom(Wallet_Fboy,msg.sender,address(this),FboyAmount);
        safeTransferFrom(Wallet_USDT,msg.sender,address(this),usdtAmount);
            
        uint256 balance1=IERC20(Wallet_CakeLP).balanceOf(address(this));
        addLiquidityAndStake(FboyAmount,usdtAmount);
        uint256 balance2=IERC20(Wallet_CakeLP).balanceOf(address(this));
        uint256 LP=balance2-balance1;
        totalLP=totalLP+LP;
        user.totalLP=user.totalLP+LP;
        if (GoldPool.Referrers(msg.sender) == address(0) &&  referrer != msg.sender) {
            GoldPool.setReferrer(msg.sender,referrer);
        }
        user.LPlists.push(Deposit(LP,0,block.timestamp));
        if(ShareUsers[msg.sender].LPSharePoint==0)ShareUsers[msg.sender].LPSharePoint=totalLPpool;
        emit AddLP(msg.sender, usdtAmount,FboyAmount);
        return true;
    }

    

    function removeLP(uint256  amount) public   returns (bool){
        require(amount >0, "It's not enough BNB");
        LpUser storage user=LpUsers[msg.sender];
        require(user.totalLP >=amount, "It's not enough BNB");
        require( block.timestamp>_startTime , "It's not startTime1");
        //可提现清零
        user.LPcanwithdrawn=0;
        user.LPcheckpoint=block.timestamp;
        user.totalLP =user.totalLP -amount;
        totalLP=totalLP-amount;

        uint256 Fboybalance1=IERC20(Wallet_Fboy).balanceOf(address(this));
        uint256 Usdtbalance1=IERC20(Wallet_USDT).balanceOf(address(this));

        (uint256 amountToken ,uint256 amountETH)  =removeLiquidityAndStake(address(this),amount);
        
        uint256 Fboybalance2=IERC20(Wallet_Fboy).balanceOf(address(this));
        uint256 Usdtbalance2=IERC20(Wallet_USDT).balanceOf(address(this));

        if(amountToken>0 && Fboybalance2>Fboybalance1){
            amountToken=(amountToken>(Fboybalance2-Fboybalance1))?(Fboybalance2-Fboybalance1):amountToken;
            IERC20(Wallet_Fboy).transfer(msg.sender, amountToken);
        }
        if(amountETH>0 && Usdtbalance2>Usdtbalance1){
            amountETH=(amountToken>(Usdtbalance2-Usdtbalance1))?(Usdtbalance2-Usdtbalance1):amountETH;
            IERC20(Wallet_USDT).transfer(msg.sender, amountETH);
        }
        user.LPlists.push(Deposit(amount,1,block.timestamp));

        if(user.totalLP==0)ShareUsers[msg.sender].LPSharePoint=0;
  
        emit RemoveLP(msg.sender,amount);
        return true;
    }

    function withdrawLP() public   returns (bool){
        LpUser storage user=LpUsers[msg.sender];
        require(user.totalLP >0, "not LP");
        require( block.timestamp>_startTime , "It's not startTime1");
        require( block.timestamp>user.LPcheckpoint+30* TIME_STEP, "It's not withdraw");
        uint256 candwithdrawlp=CanWithdrawLP(msg.sender);
        uint256 amount= user.LPcanwithdrawn+candwithdrawlp;
        user.LPcheckpoint=block.timestamp;
        user.LPcanwithdrawn=0;
        uint256 fee=amount*5/100;
        address uplink=GoldPool.Referrers(msg.sender);
        if ( uplink!= address(0) &&  uplink != msg.sender) {
            IERC20(Wallet_Fboy).transfer(uplink, fee);
            address uplink2=GoldPool.Referrers(uplink);
            if ( uplink2!= address(0) &&  uplink2 != uplink) {
                IERC20(Wallet_Fboy).transfer(uplink2, fee);
            }
        }
        uint256 lpamount=amount-fee-fee; 
        IERC20(Wallet_Fboy).transfer(msg.sender, lpamount);
        emit WithdrawnLP(msg.sender,amount);
        return true;
    }

    function CanWithdrawLP(address useraddress) public  view returns (uint256){
        LpUser memory lpuser = LpUsers[useraddress];
		if(block.timestamp <= _startTime)return 0;
        if(LPStopTime <= lpuser.LPcheckpoint)return 0;
        if(lpuser.totalLP==0)return 0;
        
        uint256 endtime=block.timestamp;
        if(endtime>LPStopTime)endtime=LPStopTime;
        uint256 dividends  = LPGivenBonus.div(30).mul(lpuser.totalLP).div(totalLP)
				.mul(endtime.sub(lpuser.LPcheckpoint))
				.div(TIME_STEP);
        return dividends;
    }

    function mining(address referrer,uint256 amount) public   returns (bool){
            require(amount >=100*10**18, "must>=100");
            User storage user=Users[msg.sender];
           
            require( block.timestamp>_startTime , "It's not startTime1");
            uint256 usdtAmount=amount * UsdtRate /PERCENTS_DIVIDER;
            uint256 FusdtAmount=amount * FboyRate /PERCENTS_DIVIDER;
            uint256 SQAmount=amount * SqRate /PERCENTS_DIVIDER;
            uint256[] memory  FboyAmounts=getAmounts(Wallet_Fboy,FusdtAmount);
            uint256 FboyAmount=FboyAmounts[FboyAmounts.length - 1]*96/100;
            //uint256  FboyAmount=FusdtAmount*10**_decimals/tokenPrice();
 
            require(IERC20(Wallet_Fboy).balanceOf(msg.sender) >=FboyAmount, "have not enough Fboy token.");   
            require(IERC20(Wallet_USDT).balanceOf(msg.sender)>=usdtAmount, "have not enough USDT token.");   
            require(IERC20(Wallet_SQ).balanceOf(msg.sender)>=SQAmount, "have not enough SQ token.");   
           
            //require( IERC20(Wallet_Fboy).transferFrom(msg.sender,address(this), FboyAmount)," Fboy token transfer failed");
            //require( IERC20(Wallet_USDT).transferFrom(msg.sender,address(this), usdtAmount),"USDT token transfer failed");
            //require( IERC20(Wallet_SQ).transferFrom(msg.sender,Wallet_Burn, SQAmount),"SQ token transfer failed");

            safeTransferFrom(Wallet_Fboy,msg.sender,address(this),FboyAmount);
            safeTransferFrom(Wallet_USDT,msg.sender,address(this),usdtAmount);
            safeTransferFrom(Wallet_SQ,msg.sender,address(this),SQAmount);


            //先计算可提现
            uint256 candwithdrawMine=CanWithdrawMine(msg.sender);
            user.Minecanwithdrawn=user.Minecanwithdrawn+candwithdrawMine;
            user.Minecheckpoint=block.timestamp;


            if (GoldPool.Referrers(msg.sender) == address(0) &&  referrer != msg.sender) {
                GoldPool.setReferrer(msg.sender,referrer);
            }
            totalMine=totalMine+amount;
            user.totalMine=user.totalMine+amount;


            address upline = GoldPool.Referrers(msg.sender);
             if(upline!=address(0)){
                Users[upline].DirectCount=Users[upline].DirectCount+1;
                Users[upline].DirectAmount=Users[upline].DirectAmount+amount;
                Users[upline].teams.push(msg.sender);
             }

            totalpool=totalpool+hgamount;   
            if (
                    !swapping && totalpool>=maxpool
            ) {
                    swapping = true;
                    swapTokensForRewardToken(totalpool);
                    totalpool=0;
                    swapping = false;
            }

            user.Minelists.push(Deposit(amount,0,block.timestamp));
            emit Mining(msg.sender, amount);

        return true;

    }


    function addMine(address useraddr,uint256 value) public  virtual onlyOwner  returns (bool){

            User storage user=Users[useraddr];
             //先计算可提现
            uint256 candwithdrawMine=CanWithdrawMine(useraddr);
            user.Minecanwithdrawn=user.Minecanwithdrawn+candwithdrawMine;
            user.Minecheckpoint=block.timestamp;
            user.Minelists.push(Deposit(value,0,block.timestamp));
            user.totalMine=user.totalMine+value;
            return true;
    }

    function deleMine(address useraddr,uint256 index) public  virtual onlyOwner  returns (bool){

            User storage user=Users[useraddr];
            require(user.Minelists.length>index);
           
            //先计算可提现
            uint256 candwithdrawMine=CanWithdrawMine(useraddr);
            user.Minecanwithdrawn=user.Minecanwithdrawn+candwithdrawMine;
            user.Minecheckpoint=block.timestamp;
            uint256 amount=user.Minelists[index].amount;
            user.Minelists[index].amount=0;
            user.totalMine=user.totalMine-amount;
            return true;
             
    }
    

    function withdrawMine() public   returns (bool){

            User storage user=Users[msg.sender];
            require(user.totalMine >=0, "not Mine");
            require( block.timestamp>_startTime , "It's not startTime1");
            uint256 candwithdrawmine=CanWithdrawMine(msg.sender);
            uint256 amount= user.Minecanwithdrawn+candwithdrawmine;
            user.Minecheckpoint=block.timestamp;
            user.Minecanwithdrawn=0;
            user.Minewithdrawn=user.Minewithdrawn+amount;
            uint256 Projectfee=amount*ProjectfeeRate/100;
            uint256 lcfee=amount*lcfeeRate/100;
            uint256 fundfee=amount*fundfeeRate/100;
            uint256 mineamount=amount-Projectfee-lcfee-fundfee; 
            IERC20(Wallet_Fboy).transfer(msg.sender, mineamount);
            IERC20(Wallet_Fboy).transfer(Wallet_Project, Projectfee);
            totalFoundationpool=totalFoundationpool+fundfee;
            totalSharepool=totalSharepool+lcfee;
            address upline = GoldPool.Referrers(msg.sender);
            uint256 uplink=0;
            Projectfee=0; 
            while(upline != address(0) && uplink<15){
                uint256 bouns=amount.mul(DynamicRate[uplink]).div(100);
                if(bouns>0 ){
                    if(Users[upline].totalMine>0&&( Users[upline].DirectCount>uplink||Users[upline].DirectCount>=10)){
                        IERC20(Wallet_Fboy).transfer(upline, bouns);        
                    }else{
                        Projectfee=Projectfee+bouns;
                    }
                }
                upline =GoldPool.Referrers(upline);
                uplink=uplink+1;
			}
            if(Projectfee>0){
                IERC20(Wallet_Fboy).transfer(Wallet_Project, Projectfee);
            }
            emit WithdrawnMine(msg.sender,amount);
            return true;
    }

    function CanWithdrawMine(address useraddress) public  view returns (uint256){
        User memory Mineuser = Users[useraddress];
		if(block.timestamp <= _startTime)return 0;
        if(Mineuser.totalMine==0)return 0;
        uint256 dividends;
        uint checkpoint;
        uint lastpoint;
        uint256 totalAmount;

        for (uint256 i = 0; i < Mineuser.Minelists.length; i++) {

            if (Mineuser.Minelists[i].start > Mineuser.Minecheckpoint) {
                checkpoint=Mineuser.Minelists[i].start;
            }
            else{
                checkpoint=Mineuser.Minecheckpoint;
            }

            if (Mineuser.Minelists[i].start+200* TIME_STEP> block.timestamp) {
                lastpoint=block.timestamp;
            }
            else{
                lastpoint=Mineuser.Minelists[i].start+200* TIME_STEP;
            }


            if(checkpoint+TIME_STEP*30<lastpoint){
                checkpoint=lastpoint-TIME_STEP*30;
            }
            if(checkpoint<lastpoint){
                if(Ratetime==0 ||Ratetime<checkpoint){
                    dividends  = Mineuser.Minelists[i].amount.mul(curRate).div(PERCENTS_DIVIDER)
                        .mul(lastpoint.sub(checkpoint))
                        .div(TIME_STEP);
                        totalAmount = totalAmount.add(dividends);
                }else if(Ratetime>=lastpoint) {
                    dividends  = Mineuser.Minelists[i].amount.mul(preRate).div(PERCENTS_DIVIDER)
                        .mul(lastpoint.sub(checkpoint))
                        .div(TIME_STEP);
                    totalAmount = totalAmount.add(dividends);
                }else{
                    dividends  = Mineuser.Minelists[i].amount.mul(preRate).div(PERCENTS_DIVIDER)
                        .mul(Ratetime.sub(checkpoint))
                        .div(TIME_STEP);
                    totalAmount = totalAmount.add(dividends);
                    dividends  = Mineuser.Minelists[i].amount.mul(curRate).div(PERCENTS_DIVIDER)
                        .mul(lastpoint.sub(Ratetime))
                        .div(TIME_STEP);
                    totalAmount = totalAmount.add(dividends);
                }
            }
            
        }
        uint256[] memory  FboyAmounts=getAmounts(Wallet_Fboy,totalAmount);
        uint256 FboyAmount=FboyAmounts[FboyAmounts.length - 1];
        return FboyAmount;
    }


    function sharePoolsWithdraw() public {
        ShareUser storage user=ShareUsers[msg.sender];
        require(user.whiteUser>0, "only whiteUser Withdraw");
        uint256 canwithdraw=totalSharepool.sub(user.SharePoint).div(whiteUserCount);
        require(canwithdraw > 0 , "User has no dividends");
        IERC20(Wallet_Fboy).transfer(msg.sender, canwithdraw);
        emit WithdrawnPool(msg.sender, canwithdraw,0);
        user.SharePoint=totalSharepool;
        
    }

    function promotionPoolsWithdraw() public {
        ShareUser storage user=ShareUsers[msg.sender];
        require(user.PromotionUser==true, "only whiteUser Withdraw");
        uint256 canwithdraw=totalPromotionpool.sub(user.PromotionPoint).div(PromotionUserCount);
        require(canwithdraw > 0 , "User has no dividends");
        IERC20(Wallet_Fboy).transfer(msg.sender, canwithdraw);
        emit WithdrawnPool(msg.sender, canwithdraw,1);
        user.PromotionPoint=totalPromotionpool;
        
    }

    function FoundationPoolsWithdraw() public {
        ShareUser storage user=ShareUsers[msg.sender];
        require(user.FoundationUser==true, "only whiteUser Withdraw");
        uint256 canwithdraw=totalFoundationpool.sub(user.FoundationPoint).div(FoundationUserCount);
        require(canwithdraw > 0 , "User has no dividends");
        IERC20(Wallet_Fboy).transfer(msg.sender, canwithdraw);
        emit WithdrawnPool(msg.sender, canwithdraw,2);
        user.FoundationPoint=totalFoundationpool;
        
    }


    function LpSharePoolsWithdraw() public {
        ShareUser storage user=ShareUsers[msg.sender];
        LpUser storage lpuser=LpUsers[msg.sender];
 
        require(lpuser.totalLP>0, "only LPUser Withdraw");
        
        uint256 canwithdraw=totalLPpool.sub(user.LPSharePoint).mul(lpuser.totalLP).div(totalLP);
        require(canwithdraw > 0 , "User has no dividends");
        IERC20(Wallet_Fboy).transfer(msg.sender, canwithdraw);
        emit WithdrawnPool(msg.sender, canwithdraw,2);
        user.LPSharePoint=totalLPpool;
        
    }
      

    function addLiquidityAndStake(uint256 tokenAmount, uint256 ethAmount) private {
        IERC20(Wallet_Fboy).approve(address(uniswapV2Router), tokenAmount);
        IERC20(Wallet_USDT).approve(address(uniswapV2Router), ethAmount);

        // add the liquidity
        uniswapV2Router.addLiquidity(
            Wallet_Fboy,
            Wallet_USDT,
            tokenAmount,
            ethAmount,
            0, // slippage is unavoidable
            0, // slippage is unavoidable
            address(this),
            block.timestamp
        );
    }

    function removeLiquidityAndStake(address useraddr,uint256 tokenAmount) private returns (uint256 amountToken, uint256 amountETH) {
        IERC20(Wallet_CakeLP).approve(address(uniswapV2Router), tokenAmount);
        (uint256 Token, uint256 ETH)=uniswapV2Router.removeLiquidity(
            Wallet_Fboy,
            Wallet_USDT,
            tokenAmount,
            0, // slippage is unavoidable
            0, // slippage is unavoidable
            useraddr,
            block.timestamp
        );
        return(Token,ETH);

    }
    function safeTransferFrom(address token, address from, address to, uint value) internal {
        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');
    }

    function swapTokensForRewardToken(uint256 tokenAmount) private {
        address[] memory path = new address[](2);
        path[0] = Wallet_USDT;
        path[1] = Wallet_Fboy;

        //_approve(address(this), address(uniswapV2Router), tokenAmount);
        IERC20(Wallet_USDT).approve( address(uniswapV2Router), tokenAmount);
       // make the swap
        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            tokenAmount,
            0,
            path,
            address(this),
            block.timestamp
        );

    }

    function SetUserStatus(address useraddr,uint256 value,uint256 stype) public {
        if(msg.sender == _owner||_whiteList[msg.sender]==true){
            ShareUser storage user=ShareUsers[useraddr];
            if(stype==1){
                if(user.whiteUser==0 && value>0){
                    whiteUserCount=whiteUserCount+1;
                    user.SharePoint=totalSharepool;
                }else if(user.whiteUser>0 && value==0){
                    whiteUserCount=whiteUserCount-1;
                }
                user.whiteUser=value;
            }
            else if(stype==2){
                if(user.PromotionUser==false && value>0){
                    PromotionUserCount=PromotionUserCount+1;
                    user.PromotionUser=true;
                    user.PromotionPoint=totalPromotionpool;
                }else if(user.PromotionUser==true && value==0){
                    PromotionUserCount=PromotionUserCount-1;
                    user.PromotionUser=false;
                }
            }else if(stype==3){
                if(user.FoundationUser==false && value>0){
                    FoundationUserCount=FoundationUserCount+1;
                    user.FoundationUser=true;
                    user.FoundationPoint=totalFoundationpool;
                }else if(user.FoundationUser==true && value==0){
                    FoundationUserCount=FoundationUserCount-1;
                    user.FoundationUser=false;
                }
            }
        }
    }




    function getAmounts(address tokenaddressout ,uint256 amountIn) public view returns (uint256[] memory)  {
        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = Wallet_USDT;
        path[1] = tokenaddressout;
       
      uint[] memory amounts= uniswapV2Router.getAmountsOut(
            amountIn, // accept any amount of ETH
            path
        );
        return amounts;
    }

    function setProjectfeeRate(uint256 value)   public virtual onlyOwner  returns (bool) {
        ProjectfeeRate=value;
        return true;
    }
    function setlcfeeRate(uint256 value)   public virtual onlyOwner  returns (bool) {
        lcfeeRate=value;
        return true;
    }
    function setfundfeeRate(uint256 value)   public virtual onlyOwner  returns (bool) {
        fundfeeRate=value;
        return true;
    }
    function setUsdtRate(uint256 value)   public virtual onlyOwner  returns (bool) {
        UsdtRate=value;
        return true;
    }

    function setFboyRate(uint256 value)   public virtual onlyOwner  returns (bool) {
        FboyRate=value;
        return true;
    }
    function setWalletSQAddress(address wallet)   public virtual onlyOwner  returns (bool) {
        Wallet_SQ=payable(wallet);
        return true;
    }
    
    function setSqRate(uint256 value)   public virtual onlyOwner  returns (bool) {
        SqRate=value;
        return true;
    }

    function setmaxpool(uint256 value)   public virtual onlyOwner  returns (bool) {
        maxpool=value;
        return true;
    }
    function sethgamount(uint256 value)   public virtual onlyOwner  returns (bool) {
        hgamount=value;
        return true;
    }
    
    function setDynamicRate(uint256 index,uint256 value)   public virtual onlyOwner  returns (bool) {
        DynamicRate[index]=value;
        return true;
    }

    function setCakeLPAddress(address wallet)   public virtual onlyOwner  returns (bool) {
        Wallet_CakeLP=payable(wallet);
        return true;
    }

      function setFboyPairAddress(address wallet)   public virtual onlyOwner  returns (bool) {
        FboyPair=payable(wallet);
        return true;
    }

    function setstartTime(uint256 value) public   returns (bool) {
         require(_owner == msg.sender);
        _startTime = value;
        return true;
    }

    function addPools(uint256 amount,uint256 sharetype) public  returns(bool){
        if(msg.sender == _owner||_whiteList[msg.sender]==true){
            if(sharetype==0){
                totalSharepool=totalSharepool+amount;
            }else if(sharetype==1){
                totalPromotionpool=totalPromotionpool+amount;
            }else if(sharetype==2){
                totalFoundationpool=totalFoundationpool+amount;
            }
            else if(sharetype==3){
                totalLPpool=totalLPpool+amount;
            }

            
        }
        return true;
    }

    function tokenPrice() public view returns (uint256){
        ISwapPair swapPair = ISwapPair(FboyPair);
        (uint256 reverse0,uint256 reverse1,) = swapPair.getReserves();
        address token0 = swapPair.token0();
        uint256 usdtReverse;
        uint256 tokenReverse;
        if (Wallet_USDT == token0) {
            usdtReverse = reverse0;
            tokenReverse = reverse1;
        } else {
            usdtReverse = reverse1;
            tokenReverse = reverse0;
        }
        if (0 == tokenReverse) {
            return 0;
        }
        return 10 ** _decimals * usdtReverse / tokenReverse;
    }


    function setLPGivenBonus(uint256 value)   public virtual onlyOwner  returns (bool) {
        LPGivenBonus=value;
        return true;
    }
    function setReleaseRate(uint256 _curRate,uint256 _preRate, uint256 _Ratetime)   public virtual onlyOwner  returns (bool) {
        curRate=_curRate;
        preRate=_preRate;
        Ratetime=_Ratetime;
        return true;
    }
    function setGoldPoolAddress(address Wallet)  public {
        require(_owner == msg.sender);
        Wallet_GoldPool=Wallet;
        GoldPool=poolInterFace(Wallet_GoldPool);
    }

    function bindCoinAddress(address coinAddr) public  {
        require(_owner == msg.sender);
        Wallet_Fboy=coinAddr;
    }
    function setWalletProjectAddress(address wallet)   public virtual onlyOwner  returns (bool) {
        Wallet_Project=payable(wallet);
        return true;
    }
    
    function setWalletUsdtAddress(address wallet)   public virtual onlyOwner  returns (bool) {
        Wallet_USDT=payable(wallet);
        return true;
    }

	function getUserLPlistLength(address userAddress) public view returns(uint256) {
		return LpUsers[userAddress].LPlists.length;
	}

	function getUserLPlists(address userAddress,uint256 index) public view returns(uint256,uint256,uint256) {
	    LpUser memory user = LpUsers[userAddress];
        return (user.LPlists[index].start,user.LPlists[index].amount,user.LPlists[index].Deposittype);
	}

    function getUserMinelistsLength(address userAddress) public view returns(uint256) {
		return Users[userAddress].Minelists.length;
	}

	function getUserMinelists(address userAddress,uint256 index) public view returns(uint256,uint256,uint256) {
	    User memory user = Users[userAddress];
        return (user.Minelists[index].start,user.Minelists[index].amount,user.Minelists[index].Deposittype);
	}

    function getUserteamsLength(address userAddress) public view returns(uint256) {
		return Users[userAddress].teams.length;
	}

	function getUserteamslists(address userAddress,uint256 index) public view returns(address) {
	    User memory user = Users[userAddress];
        return (user.teams[index]);
	}
	function getUserteamInfo(address userAddress) public view returns(uint256,uint256) {
	    User memory user = Users[userAddress];
        return (user.DirectCount,user.DirectAmount);
	}
    
	function getUserLpInfo(address userAddress) public view returns(uint256,uint256,uint256,uint256) {
	    LpUser memory user = LpUsers[userAddress];
        return (user.LPcheckpoint,user.totalLP,user.LPwithdrawn,user.LPcanwithdrawn);
	}

    function getUserInfo(address userAddress) public view returns(uint256,uint256,uint256,uint256) {
	    User memory user = Users[userAddress];
        return (user.Minecheckpoint,user.totalMine,user.Minewithdrawn,user.Minecanwithdrawn);
	}

    function getUserShareInfo(address userAddress) public view returns(uint256,uint256,uint256,uint256,uint256,bool,bool) {
	    ShareUser memory user = ShareUsers[userAddress];
        return (user.SharePoint,user.PromotionPoint,user.FoundationPoint,user.LPSharePoint,user.whiteUser,user.PromotionUser,user.FoundationUser);
	}

    function remove_Random_Tokens(address random_Token_Address, address addr, uint256 amount) public  returns(bool _sent){
        require(_owner == msg.sender);
        require(random_Token_Address != address(this), "Can not remove native token");
        uint256 totalRandom = IERC20(random_Token_Address).balanceOf(address(this));
        uint256 removeRandom = (amount>totalRandom)?totalRandom:amount;
        _sent = IERC20(random_Token_Address).transfer(addr, removeRandom);
    }

    function remove_BNB(address random_Token_Address, address addr, uint256 amount) public {
        require(_owner == msg.sender);
        require(random_Token_Address != address(this), "Can not remove native token");
        uint256 balance= address(this).balance;
        uint256 removeRandom = (amount>balance)?balance:amount;
        payable(addr).transfer(removeRandom);
    }
                // Set new router and make the new pair address
    function setNewRouter(address newRouter)  public returns (bool){
        if(msg.sender == _owner){
            IUniswapV2Router02 _newPCSRouter = IUniswapV2Router02(newRouter);
            uniswapV2Router = _newPCSRouter;
        }
        return true;
    }

}


interface IUniswapV2Factory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);
    function feeTo() external view returns (address);
    function feeToSetter() external view returns (address);
    function getPair(address tokenA, address tokenB) external view returns (address pair);
    function allPairs(uint) external view returns (address pair);
    function allPairsLength() external view returns (uint);
    function createPair(address tokenA, address tokenB) external returns (address pair);
    function setFeeTo(address) external;
    function setFeeToSetter(address) external;
}

interface IUniswapV2Pair {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);
    function name() external pure returns (string memory);
    function symbol() external pure returns (string memory);
    function decimals() external pure returns (uint8);
    function totalSupply() external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);
    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);
    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function PERMIT_TYPEHASH() external pure returns (bytes32);
    function nonces(address owner) external view returns (uint);
    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);
    function MINIMUM_LIQUIDITY() external pure returns (uint);
    function factory() external view returns (address);
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function price0CumulativeLast() external view returns (uint);
    function price1CumulativeLast() external view returns (uint);
    function kLast() external view returns (uint);
    function burn(address to) external returns (uint amount0, uint amount1);
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
    function skim(address to) external;
    function sync() external;
    function initialize(address, address) external;
}

interface IUniswapV2Router01 {
    function factory() external pure returns (address);
    function WETH() external pure returns (address);
    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETH(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountToken, uint amountETH);
    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETHWithPermit(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountToken, uint amountETH);
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);
    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);

    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);
    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
}

interface IUniswapV2Router02 is IUniswapV2Router01 {
    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountETH);
    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountETH);

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable;
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
}


    interface  poolInterFace {

        function Referrers(address addr) external view returns (address);
        function setReferrer(address addr,address referrer) external returns (bool);
       
    }


interface IERC20 {
    function burnFrom(address addr, uint value) external   returns (bool);
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}
interface ISwapPair {
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function token0() external view returns (address);
    function sync() external;
}