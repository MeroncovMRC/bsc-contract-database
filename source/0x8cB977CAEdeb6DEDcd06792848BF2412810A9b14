{"Auction.sol":{"content":"// SPDX-License-Identifier: --ðŸŒ²--\n\npragma solidity ^0.8.0;\n\nimport \"./Interface.sol\";\n\nimport \"./SafeMath.sol\";\n\n/**\n * @title Treedefi Marketplace \n *\n * @author treedefi\n */\ncontract Auction {\n\n  using SafeMath for uint256;\n  \n  // Link to different contracts\n  IBEP20Token private SEED;\n  IBEP20Token private TREE;\n  IBEP20Token private WBNB;\n  ITreedefiForest private NFTREE;\n  \n  // Addresses that manage the system\n  address private _admin;\n  address private _treasury;\n  address private _donation;\n  \n  // Default maximum duration\n  uint256 public _maxDuration = 240 hours;\n  \n  // Default minimum duration\n  uint256 public _minDuration = 10 hours;\n  \n  // List of tree Ids putted for auction\n  uint256[] public auctionList;\n\n  // Mapping from treeId to auction details\n    mapping(uint256 =\u003e Wood) public treeList;\n\n  // Mapping from treeId to user bids\n    mapping(uint256 =\u003e Bid[]) public auctionBids;\n\n  // Mapping from treeId to maximum duration allowed by admin\n    mapping(uint256 =\u003e uint256) public maxDuration;\n    \n  // Mapping from treeId to minimum duration allowed by admin\n    mapping(uint256 =\u003e uint256) public minDuration;    \n  \n  // Marketplace fee in percentage( with 10x value for precision) \n    Fee public _marketplaceFee;\n    \n  // Fee for place a bid in english auction\n    Fee public _bidFee;\n  \n  // Fee struct to hold fee details for different payment types \n    struct Fee {\n        uint256 _tree;\n        uint256 _seed;\n        uint256 _wbnb;\n    }\n    \n  // Wood struct to hold auction details of tree\n    struct Wood {\n        bool forAuction;\n        AuctionType auctionType;\n        PaymentType paymentType;\n        uint256 basePrice;\n        uint256 startPrice;\n        uint256 endPrice;\n        uint64 duration;\n        uint64 startedAt;\n    }\n\n  // Bid struct to hold bidder and amount\n    struct Bid {\n        address from;\n        uint256 amount;\n    }\n\n  // Enumeration for auction type\n  enum AuctionType { DUTCH, ENGLISH }\n  \n  // Enumeration for payment type\n  enum PaymentType { TREE_TOKEN, SEED_TOKEN, WBNB_TOKEN }\n  \n  /**\n\t * @dev Fired in buyTree() and acceptBid() when auction ends successfully \n\t *\n\t * @param _from an address of previous owner\n\t * @param _to an address of new owner\n\t * @param _id Id of tree\n\t * @param _value amount paid for purchase\n\t * @param _paymentType defines amount paid in perticular token\n\t */\n  event Purchase(\n        address indexed _from,\n        address indexed _to,\n        uint256 indexed _id,\n        uint256 _value,\n        PaymentType _paymentType\n  );\n  \n  /**\n\t * @dev Fired in listTreeForEnglishAuction() and listTreeForDutchAuction()\n\t *       when tree is listed for auction successfully\n\t *\n\t * @param _owner an address of tree owner\n\t * @param _id Id of tree\n\t * @param _auctionType defines type of auction\n\t * @param _duration defines duration of auction in number of seconds \n\t */\n  event Listing(\n        address indexed _owner,\n        uint256 indexed _id,\n        AuctionType _auctionType,\n        uint256 _duration\n  );\n  \n  /**\n\t * @dev Fired in bidOnAuction() when bid is placed\n\t *      for english auction successfully\n\t *\n\t * @param _from an address of bidder\n\t * @param _treeId Id of tree\n\t * @param _value defines bid amount to be paid\n\t * @param _paymentType defines bid amount in perticular token \n\t */\n  event BidSuccess(address indexed _from, uint _treeId, uint _value, PaymentType _paymentType);\n  \n  // Checks this contract is approved for given tree   \n  modifier isManager(uint256 _id) {\n    \n    address _approved = NFTREE.getApproved(_id);\n     \n    require(\n      address(this) == _approved,\n      \" Treedefi: Contract is not approved to manage token of this ID \"\n    );\n    \n    _;\n  \n  }\n  \n  // Checks given tree is listed for auction\n  modifier listed(uint256 _id) {\n    \n    require(\n      treeList[_id].forAuction,\n      \" Treedefi: TREE of this ID is not for listed for auction \"\n    );\n    \n    _;\n  \n  }\n  \n  // Checks duration falls into defined limit\n  modifier durationAllowed(uint256 _id, uint64 _duration) {\n    \n    uint256 _max = (maxDuration[_id] == 0) ? _maxDuration : maxDuration[_id];\n    \n    uint256 _min = (minDuration[_id] == 0) ? _minDuration : minDuration[_id];\n\n    require(\n      _max \u003e= _duration,\n      \" Treedefi: duration exceeds maximum limit defined by admin \"\n    );\n\n    require(\n      _duration \u003e= _min,\n      \" Treedefi: duration should be greater than minimum limit defined by admin \"\n    );\n    \n    _;\n  \n  }\n  \n   /**\n\t * @dev Creates/deploys treedefi marketplace\n\t *\n\t * @param _seedToken address of SEED token\n\t * @param _treeToken address of TREE token\n\t * @param _wbnb address of WBNB token\n\t * @param _nftree address of NFTREE V2 \n\t * @param _treasuryWallet address of treasury wallet \n\t * @param _donationWallet address of donation wallet\n\t */\n  constructor(\n      address _seedToken, \n      address _treeToken, \n      address _wbnb, \n      address _nftree,\n      address _treasuryWallet,\n      address _donationWallet\n    ) {\n\n      SEED = IBEP20Token(_seedToken);\n      TREE = IBEP20Token(_treeToken);\n      WBNB = IBEP20Token(_wbnb);\n      NFTREE = ITreedefiForest(_nftree);\n      _admin = NFTREE.getOwner();\n      _treasury = _treasuryWallet;\n      _donation = _donationWallet;\n      \n      // Initialize marketplace fee\n      // 0.5 percent for TREE \u0026 SEED, 3 percent for WBNB \n      _marketplaceFee = Fee(5, 5, 30);  \n      \n      \n      // Initialize bid Fee\n      // 0.001 for TREE \u0026 WBNB, 0.01 for SEED\n      _bidFee = Fee(1E15, 1E16, 1E15);\n  }\n  \n  /** @notice upgrades admin address to existing NFTREE V2 owner\n     *        as ownership of NFTREE V2 is transferable\n     */\n  function upgradeAdminAddress() external {\n  \n    _admin = NFTREE.getOwner();\n\n  }\n\n  /** @dev set maximum duration allowed for auction of perticular tree \n     *@param _id unsigned integer defines tokenID \n     *@param _duration unsigned integer defines maximum duration for auction\n     */\n  function setMaxDuration(uint256 _id, uint64 _duration) external {\n    \n    require(\n      msg.sender == _admin,\n      \" Treedefi: only admin can define maximum duration \"\n    );\n  \n    maxDuration[_id] = _duration;\n\n  }\n  \n  /** @dev set default maximum duration allowed for auction of all trees \n     *@param _duration unsigned integer defines maximum duration for auction\n     */\n  function setMaxDurationForAll(uint64 _duration) external {\n    \n    require(\n      msg.sender == _admin,\n      \" Treedefi: only admin can define maximum duration \"\n    );\n  \n    _maxDuration = _duration;\n\n  }\n  \n  /** @dev set minimum duration allowed for auction of perticular tree \n     *@param _id unsigned integer defines tokenID \n     *@param _duration unsigned integer defines minimum duration for auction\n     */\n  function setMinDuration(uint256 _id, uint64 _duration) external {\n    \n    require(\n      msg.sender == _admin,\n      \" Treedefi: only admin can define minimum duration \"\n    );\n  \n    minDuration[_id] = _duration;\n\n  }\n  \n  /** @dev set default minimum duration allowed for auction of all trees \n     *@param _duration unsigned integer defines minimum duration for auction\n     */\n  function setMinDurationForAll(uint64 _duration) external {\n    \n    require(\n      msg.sender == _admin,\n      \" Treedefi: only admin can define minimum duration \"\n    );\n  \n    _minDuration = _duration;\n\n  }\n  \n  /** @dev sets marketplace fee charged for finalize an auction\n    * @notice desired fee percentage should be multiply by 10 for precision   \n     *@param _tree unsigned integer defines percentage of TREE token charged as a fee\n     *@param _seed unsigned integer defines percentage of SEED token charged as a fee\n     *@param _wbnb unsigned integer defines percentage of WBNB token charged as a fee\n     */\n  function setMarketplaceFee(uint256 _tree, uint256 _seed, uint256 _wbnb) external {\n    \n    require(\n      msg.sender == _admin,\n      \" Treedefi: only admin can set fees \"\n    );\n  \n    _marketplaceFee = Fee(_tree, _seed, _wbnb);\n\n  }\n  \n  /** @dev sets fee for placing bid in english auction  \n     *@param _tree unsigned integer defines amount of TREE token charged as a fee\n     *@param _seed unsigned integer defines amount of SEED token charged as a fee\n     *@param _wbnb unsigned integer defines amount of WBNB token charged as a fee\n     */\n  function setBidFee(uint256 _tree, uint256 _seed, uint256 _wbnb) external {\n    \n    require(\n      msg.sender == _admin,\n      \" Treedefi: only admin can set fees \"\n    );\n  \n    _bidFee = Fee(_tree, _seed, _wbnb);\n\n  }\n  \n  /** @dev returns total number of auction count  \n     */\n  function auctionCount() external view returns (uint256) {\n      return auctionList.length;\n  }\n\n  /** @dev List Treedefi Forest NFT for english auction \n     *@param _id unsigned integer defines tokenID to list for auction\n     *@param _basePrice unsigned integer defines base price for the tokenID\n     *@param _duration unsigned integer defines duration for auction\n     *@param _paymentType unsigned integer defines payment type in terms of SEED/TREE/WBNB \n     */\n  function listTreeForEnglishAuction(\n    uint256 _id, \n    uint256 _basePrice, \n    uint64 _duration,\n    PaymentType _paymentType\n    ) \n    external \n    isManager(_id)\n    durationAllowed(_id, _duration)\n  {\n    \n    address _owner = NFTREE.ownerOf(_id);\n    \n    require(\n      msg.sender == _owner,\n      \" Treedefi: Only owner of token can list the token for auction \"\n    );\n\n    require(\n      treeList[_id].forAuction == false,\n      \" Treedefi: Tree already listed for auction \"\n    );\n     \n    treeList[_id] = Wood(true, AuctionType.ENGLISH, _paymentType, _basePrice, \n                    0, 0, _duration, uint64(block.timestamp));\n    \n    auctionList.push(_id);\n    \n    emit Listing(_owner, _id, AuctionType.ENGLISH, _duration);\n\n  }\n\n\n  /** @dev List Treedefi Forest NFT for dutch auction \n     *@param _id unsigned integer defines tokenID to list for auction\n     *@param _startPrice unsigned integer defines starting price \n     *@param _endPrice unsigned integer defines ending price \n     *@param _duration unsigned integer defines duration for auction\n     *@param _paymentType unsigned integer defines payment type in terms of SEED/TREE/WBNB \n     */\n  function listTreeForDutchAuction(\n    uint256 _id, \n    uint256 _startPrice,\n    uint256 _endPrice, \n    uint64 _duration,\n    PaymentType _paymentType\n    ) \n    external \n    isManager(_id)\n    durationAllowed(_id, _duration)\n  {\n    \n    address _owner = NFTREE.ownerOf(_id);\n\n    require(\n      msg.sender == _owner,\n      \" Treedefi: Only owner of token can list the token for auction \"\n    );\n\n    require(\n      treeList[_id].forAuction == false,\n      \" Treedefi: Tree already listed for auction \"\n    );\n    \n    require(\n      _startPrice \u003e _endPrice,\n      \" Treedefi: start price should be greater than end price \"\n    );\n     \n    treeList[_id] = Wood(true, AuctionType.DUTCH, _paymentType, 0, \n                        _startPrice, _endPrice, _duration, uint64(block.timestamp));\n\n    auctionList.push(_id);\n    \n    emit Listing(_owner, _id, AuctionType.DUTCH, _duration);\n\n  } \n  \n\n  /** @dev Buy Treedefi Forest NFT for current price listed in dutch auction \n     *@param _id unsigned integer defines tokenID to buy\n     *@param _value unsigned integer defines value of TREE/SEED/WBNB tokens to buy NFT \n     */\n  function buyTree(uint256 _id, uint256 _value) \n    external\n    isManager(_id)\n    listed(_id)\n  {\n     \n     address _owner = NFTREE.ownerOf(_id);\n     \n     IBEP20Token PaymentToken = getPaymentInterface(_id);\n\n     uint256 _currentPrice = getCurrentPrice(_id);\n\n      require(\n      treeList[_id].auctionType == AuctionType.DUTCH,\n      \" Treedefi: TREE of this ID is not listed for dutch auction \"\n      );\n     \n     require(\n      _currentPrice \u003c= _value,\n      \" Treedefi: Provided value is less than current price \"\n      );\n\n     require(\n      PaymentToken.balanceOf(msg.sender) \u003e= _value,\n      \" Treedefi : Buyer doesn\u0027t have enough balance to purchase token \"\n     );\n\n     require(\n      PaymentToken.allowance(msg.sender, address(this)) \u003e= _value,\n      \" Treedefi :  Contract is not approved to spend tokens of user \"\n     );\n     \n     require(\n      msg.sender != _owner,\n      \" Treedefi : Tree already own by address\"\n     );\n\n     uint256 _feePercentage = getMarketplaceFee(_id);\n\n     uint256 _fee = _value.mul(_feePercentage).div(1000);\n     uint256 _transferValue = _value.sub(_fee);                         \n     \n     PaymentToken.transferFrom(msg.sender, _owner, _transferValue);\n     PaymentToken.transferFrom(msg.sender, _admin, _fee);\n             \n     NFTREE.transferFrom(_owner, msg.sender, _id);\n    \n     PaymentType _paymentType = treeList[_id].paymentType;\n    \n     delete treeList[_id];\n\n     emit Purchase(_owner, msg.sender, _id, _value, _paymentType);\n  \n  }\n\n\n  /** @dev returns current price of NFTree listed in dutch auction \n     *@param _id unsigned integer defines tokenID \n     */\n  function getCurrentPrice(uint256 _id) public view returns (uint256) {\n\n      require(treeList[_id].startedAt \u003e 0);\n      \n      uint256 secondsPassed = 0;\n\n      secondsPassed = block.timestamp - treeList[_id].startedAt;\n\n      if (secondsPassed \u003e= treeList[_id].duration) {\n          \n          return treeList[_id].endPrice;\n      \n      } else {\n\n          int256 totalPriceChange = int256(treeList[_id].endPrice) - int256(treeList[_id].startPrice);\n\n          int256 currentPriceChange = totalPriceChange * int256(secondsPassed) / int64(treeList[_id].duration);\n\n          int256 currentPrice = int256(treeList[_id].startPrice) + currentPriceChange;\n\n          return uint256(currentPrice);\n      \n      }\n  }\n\n\n  /** @dev Bid for Treedefi Forest NFT listed in english auction \n     *@param _id unsigned integer defines tokenID \n     *@param _value unsigned integer defines value of TREE/SEED/WBNB tokens  \n     */\n  function bidOnAuction(uint256 _id, uint256 _value) \n    external\n    isManager(_id)\n    listed(_id)\n  {\n     address _owner = NFTREE.ownerOf(_id);    \n        \n     IBEP20Token PaymentToken = getPaymentInterface(_id);\n\n     uint256 _deadline = uint256(treeList[_id].startedAt)\n                        .add(uint256(treeList[_id].duration));\n\n     require(\n      treeList[_id].auctionType == AuctionType.ENGLISH,\n      \" Treedefi: TREE of this ID is not listed for english auction \"\n      );\n\n     require(\n      block.timestamp \u003c= _deadline,\n      \" Treedefi: auction duration expired \"\n      );\n\n     uint bidsLength = auctionBids[_id].length;\n     uint256 _lastBidPrice = treeList[_id].basePrice;\n     Bid memory lastBid; \n\n      // there are previous bids\n        if( bidsLength \u003e 0 ) {\n            lastBid = auctionBids[_id][bidsLength - 1];\n            _lastBidPrice = lastBid.amount;\n        }\n     \n     require(\n      _lastBidPrice \u003c _value,\n      \" Treedefi: Provided value is less than last bid price or base price \"\n      );\n\n     require(\n      PaymentToken.balanceOf(msg.sender) \u003e= _value,\n      \" Treedefi : Buyer doesn\u0027t have enough balance to purchase token \"\n     );\n     \n     // Get require fee to place a bid \n     uint256 _fee = getFeeForBid(_id);\n     \n     require(\n      PaymentToken.allowance(msg.sender, address(this)) \u003e= _value.add(_fee),\n      \" Treedefi :  Contract is not approved to spend tokens of user \"\n     );\n     \n     require(\n      msg.sender != _owner,\n      \" Treedefi : Tree already own by address\"\n     );\n     \n     // Transfer fee\n     if(_fee \u003e 0){\n        PaymentToken.transferFrom(msg.sender, _treasury, _fee.div(2));\n        PaymentToken.transferFrom(msg.sender, _donation, _fee.div(2));\n     }\n     \n     // Insert bid \n        Bid memory newBid;\n        newBid.from = msg.sender;\n        newBid.amount = _value;\n        auctionBids[_id].push(newBid);\n        PaymentType _paymentType = treeList[_id].paymentType;\n        emit BidSuccess(msg.sender, _id, _value, _paymentType);\n\n  }\n\n  /**\n    * @dev Accept bid for Treedefi Forest NFT listed in english auction \n    * @dev On success NFTree is transfered to bidder and auction owner gets the amount\n    * @param _id uint ID of NFTree\n    * @param _bidNumber uint serial number of bid to accept\n    */\n  function acceptBid(uint256 _id, uint256 _bidNumber) \n    external \n    isManager(_id)\n    listed(_id)\n  {\n    \n    address _owner = NFTREE.ownerOf(_id);\n     \n    IBEP20Token PaymentToken = getPaymentInterface(_id);\n\n    Bid memory bidInfo = auctionBids[_id][_bidNumber.sub(1)];\n\n    require(\n      msg.sender == _owner,\n      \" Treedefi: Only owner of token can accept bid for auction \"\n    );\n\n    require(\n      treeList[_id].auctionType == AuctionType.ENGLISH,\n      \" Treedefi: TREE of this ID is not listed for english auction \"\n    );\n\n    require(\n      PaymentToken.balanceOf(bidInfo.from) \u003e= bidInfo.amount,\n      \" Treedefi : Buyer doesn\u0027t have enough balance to purchase token \"\n    );\n\n    require(\n      PaymentToken.allowance(bidInfo.from, address(this)) \u003e= bidInfo.amount,\n      \" Treedefi :  Contract is not approved to spend tokens of Buyer \"\n    );\n\n    uint256 _feePercentage = getMarketplaceFee(_id);\n\n    uint256 _fee = bidInfo.amount.mul(_feePercentage).div(1000);\n    uint256 _transferValue = bidInfo.amount.sub(_fee);                         \n     \n    PaymentToken.transferFrom(bidInfo.from, _owner, _transferValue);\n    PaymentToken.transferFrom(bidInfo.from, _admin, _fee);\n             \n    NFTREE.transferFrom(_owner, bidInfo.from, _id);\n    \n    PaymentType _paymentType = treeList[_id].paymentType;\n\n    delete treeList[_id];\n\n    delete auctionBids[_id];                    \n\n    emit Purchase(_owner, bidInfo.from, _id, bidInfo.amount, _paymentType);\n        \n  }\n  \n  /** @dev returns bid count of NFTree listed in english auction \n     *@param _id unsigned integer defines tokenID \n     */\n  function getBidCount(uint256 _id) external view returns (uint256) {\n      return auctionBids[_id].length;\n  }      \n  \n  /**\n    * @dev Cancels pending auction by the owner\n    * @dev Bidder is refunded with the initial amount\n    * @param _id uint ID of NFTree\n    */\n  function cancelAuction(uint256 _id) \n    external\n    listed(_id)\n  {\n  \n      address _owner = NFTREE.ownerOf(_id);\n      \n      require(\n        msg.sender == _owner,\n        \" Treedefi: Only owner of token can cancel the auction \"\n      );\n      \n      if(treeList[_id].auctionType == AuctionType.ENGLISH){ \n        delete auctionBids[_id];\n      }\n      \n      delete treeList[_id];\n  \n  }\n\n\n  /** @dev returns payment interface of NFTree listed in auction \n     *@param _id unsigned integer defines tokenID \n     */\n  function getPaymentInterface(uint256 _id) internal view returns (IBEP20Token) {\n   \n    IBEP20Token PaymentToken;\n\n    if(treeList[_id].paymentType == PaymentType.TREE_TOKEN){\n      PaymentToken = TREE;\n    }else if(treeList[_id].paymentType == PaymentType.SEED_TOKEN){\n      PaymentToken = SEED;\n    }else if(treeList[_id].paymentType == PaymentType.WBNB_TOKEN){\n      PaymentToken = WBNB;\n    }\n\n    return PaymentToken;\n  \n  }\n  \n  /** @dev returns fee amount for placing a bid in english auction \n     *@param _id unsigned integer defines tokenID \n     */\n  function getFeeForBid(uint256 _id) internal view returns (uint256) {\n    uint256 _fee;\n    \n    if(treeList[_id].paymentType == PaymentType.TREE_TOKEN){\n      _fee = _bidFee._tree;\n    }else if(treeList[_id].paymentType == PaymentType.SEED_TOKEN){\n      _fee = _bidFee._seed;\n    }else if(treeList[_id].paymentType == PaymentType.WBNB_TOKEN){\n      _fee = _bidFee._wbnb;\n    }\n\n    return _fee;\n  \n  }\n  \n  /** @dev returns fee amount for placing a bid in english auction \n     *@param _id unsigned integer defines tokenID \n     */\n  function getMarketplaceFee(uint256 _id) internal view returns (uint256) {\n    uint256 _fee;\n    \n    if(treeList[_id].paymentType == PaymentType.TREE_TOKEN){\n      _fee = _marketplaceFee._tree;\n    }else if(treeList[_id].paymentType == PaymentType.SEED_TOKEN){\n      _fee = _marketplaceFee._seed;\n    }else if(treeList[_id].paymentType == PaymentType.WBNB_TOKEN){\n      _fee = _marketplaceFee._wbnb;\n    }\n\n    return _fee;\n  \n  }\n\n}"},"Interface.sol":{"content":"// SPDX-License-Identifier: --ðŸŒ²--\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\ninterface IBEP20Token {\r\n\r\n    function transferFrom(\r\n      address _from,\r\n      address _to,\r\n      uint256 _value\r\n    ) external returns (bool success);\r\n\r\n    function balanceOf(\r\n      address _owner\r\n    ) external returns (uint256);\r\n\r\n    function allowance(\r\n      address _owner,\r\n      address _spender\r\n    ) external returns (uint256);\r\n\r\n}\r\n\r\n\r\ninterface ITreedefiForest {\r\n\r\n    function transferFrom(\r\n      address _from,\r\n      address _to,\r\n      uint256 _id\r\n    ) external;\r\n\r\n\r\n    function ownerOf(\r\n      uint256 _id\r\n    ) external returns (address);\r\n\r\n\r\n    function getApproved(\r\n      uint256 tokenId\r\n    ) external returns (address);\r\n\r\n\r\n    function getOwner() external returns (address);\r\n\r\n}\r\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// CAUTION\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler\u0027s built in overflow checks.\r\n\r\n/**\r\n * @dev Wrappers over Solidity\u0027s arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c \u003c a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b \u003e a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n            // benefit is lost if \u0027b\u0027 is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b \u003c= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b \u003e 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b \u003e 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n"}}