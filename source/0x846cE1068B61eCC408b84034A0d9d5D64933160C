{"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller\u0027s account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}"},"ReentrancyGuard.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.19;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot\u0027s contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler\u0027s defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction\u0027s gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}"},"TransferHelper.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity \u003e= 0.6.0;\r\n\r\nimport \"./IERC20.sol\";\r\n\r\nlibrary TransferHelper {\r\n    /// @notice Transfers tokens from the targeted address to the given destination\r\n    /// @notice Errors with \u0027STF\u0027 if transfer fails\r\n    /// @param token The contract address of the token to be transferred\r\n    /// @param from The originating address from which the tokens will be transferred\r\n    /// @param to The destination address of the transfer\r\n    /// @param value The amount to be transferred\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) =\r\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\r\n        require(success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))), \u0027STF\u0027);\r\n    }\r\n\r\n    /// @notice Transfers tokens from msg.sender to a recipient\r\n    /// @dev Errors with ST if transfer fails\r\n    /// @param token The contract address of the token which will be transferred\r\n    /// @param to The recipient of the transfer\r\n    /// @param value The value of the transfer\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\r\n        require(success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))), \u0027ST\u0027);\r\n    }\r\n\r\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\r\n    /// @dev Errors with \u0027SA\u0027 if transfer fails\r\n    /// @param token The contract address of the token to be approved\r\n    /// @param to The target of the approval\r\n    /// @param value The amount of the given token the target will be allowed to spend\r\n    function safeApprove(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\r\n        require(success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))), \u0027SA\u0027);\r\n    }\r\n\r\n    /// @notice Transfers ETH to the recipient address\r\n    /// @dev Fails with `STE`\r\n    /// @param to The destination of the transfer\r\n    /// @param value The value to be transferred\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        require(success, \u0027STE\u0027);\r\n    }\r\n}"},"Web3DebitRouter0x.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.19;\r\n\r\nimport \"./ReentrancyGuard.sol\";\r\nimport \"./TransferHelper.sol\";\r\n\r\n\r\ninterface ERC20 {\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n}\r\n\r\n\r\ninterface IStargateRouter {\r\n\r\n    struct lzTxObj {\r\n        uint256 dstGasForCall;\r\n        uint256 dstNativeAmount;\r\n        bytes dstNativeAddr;\r\n    }\r\n\r\n\r\n    function swap(\r\n        uint16 _dstChainId,\r\n        uint256 _srcPoolId,\r\n        uint256 _dstPoolId,\r\n        address payable _refundAddress,\r\n        uint256 _amountLD,\r\n        uint256 _minAmountLD,\r\n        lzTxObj memory _lzTxParams,\r\n        bytes calldata _to,\r\n        bytes calldata _payload\r\n    ) external payable;\r\n\r\n}\r\n\r\n\r\ncontract Web3DebitRouter0x is ReentrancyGuard {\r\n\r\nIStargateRouter public stargateRouter;\r\nuint public immutable source;\r\naddress payable public exchangeProxy;\r\nuint public feeStore;\r\nuint public idPayment;\r\naddress public owner;\r\naddress public treasury;\r\nbool public locked;\r\n\r\n\r\nstruct DataStargate0x {\r\n    uint16 dstChainId;\r\n    uint256 srcPoolId;\r\n    uint256 dstPoolId;\r\n    uint256 amountLD;\r\n    uint256 minAmountLD;\r\n    uint256 gasfee;\r\n    address receiverAddress;\r\n    address tokenBridge;\r\n}\r\n\r\n\r\nstruct DataSwap0x {\r\n    bytes swapCallData;\r\n    address tokenIn;\r\n    address tokenOut;\r\n    uint amountOut;\r\n    uint amountInMaximum;\r\n    address store;\r\n    uint memo;\r\n    uint amountSold;\r\n    uint amountBought;\r\n}\r\n\r\n\r\nevent Routed(\r\n    uint indexed id,\r\n    address indexed store,\r\n    address indexed sender,\r\n    uint memo,\r\n    address tokenIn,\r\n    address tokenOut,\r\n    uint amountOut,\r\n    uint fee,\r\n    uint soldAmount,\r\n    uint boughtAmount,\r\n    uint destChain,\r\n    uint amountOutFixed,\r\n    address tokenBridge);\r\n\r\n\r\nevent ReceivedFromStargate(\r\n    uint nonce,\r\n    uint indexed id,\r\n    uint srcChain,\r\n    address indexed store,\r\n    address indexed sender,\r\n    address token,                 \r\n    uint256 amountIn,\r\n    uint amountPay,\r\n    uint fee);\r\n        \r\n\r\nconstructor(\r\n    IStargateRouter _stargateRouter,\r\n    address payable _exchangeProxy, \r\n    uint _source,\r\n    address _owner,\r\n    address _treasury) {\r\n        \r\n    require(_owner != address(0));\r\n    require(_treasury != address(0));\r\n    require(_source \u003e 0);\r\n    require(_exchangeProxy != address(0));\r\n\r\n    source = _source;\r\n    owner = _owner;\r\n    stargateRouter = _stargateRouter;\r\n    exchangeProxy = _exchangeProxy;\r\n    treasury = _treasury;\r\n}\r\n\r\n\r\nmodifier onlyOwner() {\r\n\r\n    require(msg.sender == owner);\r\n    _;\r\n\r\n}\r\n\r\n\r\nfunction transferOwner(address _owner) external onlyOwner {\r\n\r\n    require(_owner != address(0));\r\n    owner = _owner;\r\n\r\n}\r\n\r\n\r\nfunction transferTreasury(address _treasury) external {\r\n\r\n    require(msg.sender == treasury);\r\n    require(_treasury != address(0));\r\n    treasury = _treasury;\r\n\r\n}\r\n\r\n\r\nfunction lockRouter() external onlyOwner {\r\n\r\n    if (locked) {\r\n        locked = false;\r\n    }\r\n\r\n    if (!locked) {\r\n        locked = true;\r\n    }\r\n\r\n}\r\n\r\n\r\nfunction changeStargateRouter(IStargateRouter _stargateRouter) external onlyOwner {\r\n    \r\n    stargateRouter = _stargateRouter;\r\n\r\n}\r\n\r\n\r\nfunction changeExchangeProxy(address payable _exchangeProxy) external onlyOwner {\r\n    \r\n    require(_exchangeProxy != address(0));\r\n    exchangeProxy = _exchangeProxy;\r\n\r\n}\r\n\r\n\r\nfunction changeFeeStore(uint _feeStore) external onlyOwner {\r\n    \r\n    feeStore = _feeStore;\r\n\r\n}\r\n\r\n\r\nfunction noSwapPayOnChainSameERC20(\r\n    DataSwap0x calldata _dataSwap) external nonReentrant {\r\n\r\n    require(!locked);\r\n    require(_dataSwap.tokenIn != address(0));\r\n    require(_dataSwap.tokenOut != address(0));\r\n    require(_dataSwap.tokenIn == _dataSwap.tokenOut);\r\n    require(_dataSwap.amountOut \u003e 0);\r\n    require(_dataSwap.amountInMaximum \u003e 0);\r\n    require(_dataSwap.amountOut == _dataSwap.amountInMaximum);\r\n    require(_dataSwap.store != address(0));\r\n    require(_dataSwap.memo \u003e 0);\r\n    require(_dataSwap.amountSold \u003e 0);\r\n    require(_dataSwap.amountBought \u003e 0);\r\n    require(_dataSwap.amountSold == _dataSwap.amountBought);\r\n\r\n    idPayment += 1;\r\n\r\n    require(IERC20(_dataSwap.tokenIn).balanceOf(msg.sender) \u003e= _dataSwap.amountInMaximum);\r\n    require(IERC20(_dataSwap.tokenIn).allowance(msg.sender, address(this)) \u003e= _dataSwap.amountInMaximum);\r\n        \r\n    TransferHelper.safeTransferFrom(_dataSwap.tokenIn, msg.sender, address(this), _dataSwap.amountInMaximum);\r\n        \r\n    uint fee = _payment(_dataSwap.store, _dataSwap.tokenOut, _dataSwap.amountOut);    \r\n\r\n    emit Routed(\r\n        idPayment,\r\n        _dataSwap.store,\r\n        msg.sender,\r\n        _dataSwap.memo,\r\n        _dataSwap.tokenIn,\r\n        _dataSwap.tokenOut,\r\n        _dataSwap.amountOut,\r\n        fee,\r\n        _dataSwap.amountSold,\r\n        _dataSwap.amountBought,\r\n        0,\r\n        0,\r\n        address(0));\r\n\r\n}\r\n\r\n\r\nfunction swapAndPayOnChainERC20(\r\n    DataSwap0x calldata _dataSwap) external nonReentrant {\r\n\r\n    require(!locked);\r\n    require(_dataSwap.tokenIn != address(0));\r\n    require(_dataSwap.tokenOut != address(0));\r\n    require(_dataSwap.amountOut \u003e 0);\r\n    require(_dataSwap.amountInMaximum \u003e 0);\r\n    require(_dataSwap.store != address(0));\r\n    require(_dataSwap.memo \u003e 0);\r\n \r\n    idPayment += 1;\r\n\r\n    _swapAndPayOnChainERC20(_dataSwap);\r\n\r\n}\r\n\r\n\r\nfunction _swapAndPayOnChainERC20(\r\n    DataSwap0x calldata _dataSwap) internal {\r\n    \r\n    require(IERC20(_dataSwap.tokenIn).balanceOf(msg.sender) \u003e= _dataSwap.amountInMaximum);\r\n    require(IERC20(_dataSwap.tokenIn).allowance(msg.sender, address(this)) \u003e= _dataSwap.amountInMaximum);\r\n    \r\n    uint balanceStartTokenIn = IERC20(_dataSwap.tokenIn).balanceOf(address(this));\r\n    \r\n    TransferHelper.safeTransferFrom(_dataSwap.tokenIn, msg.sender, address(this), _dataSwap.amountInMaximum);\r\n    TransferHelper.safeApprove(_dataSwap.tokenIn, address(exchangeProxy), _dataSwap.amountInMaximum);\r\n        \r\n    uint balanceStartTokenOut = IERC20(_dataSwap.tokenOut).balanceOf(address(this));\r\n    \r\n    (bool success,) = exchangeProxy.call{value: 0}(_dataSwap.swapCallData);\r\n    require(success, \u0027SWAP_CALL_FAILED\u0027);\r\n\r\n    uint boughtAmount = IERC20(_dataSwap.tokenOut).balanceOf(address(this)) - balanceStartTokenOut;\r\n    require(boughtAmount \u003e= _dataSwap.amountOut);\r\n\r\n    uint soldAmount = balanceStartTokenIn + _dataSwap.amountInMaximum - IERC20(_dataSwap.tokenIn).balanceOf(address(this));\r\n\r\n    TransferHelper.safeApprove(_dataSwap.tokenIn, address(exchangeProxy), 0);\r\n        \r\n    if (soldAmount \u003c _dataSwap.amountInMaximum) {\r\n        TransferHelper.safeTransfer(_dataSwap.tokenIn, msg.sender, _dataSwap.amountInMaximum - soldAmount);\r\n    }\r\n\r\n    if (boughtAmount \u003e _dataSwap.amountOut) {\r\n        TransferHelper.safeTransfer(_dataSwap.tokenOut, msg.sender, boughtAmount - _dataSwap.amountOut);\r\n    }\r\n\r\n    uint fee = _payment(_dataSwap.store, _dataSwap.tokenOut, _dataSwap.amountOut);\r\n\r\n    emit Routed(\r\n        idPayment,\r\n        _dataSwap.store,\r\n        msg.sender,\r\n        _dataSwap.memo,\r\n        _dataSwap.tokenIn,\r\n        _dataSwap.tokenOut,\r\n        _dataSwap.amountOut,\r\n        fee,\r\n        soldAmount,\r\n        boughtAmount,\r\n        0,\r\n        0,\r\n        address(0));\r\n\r\n}\r\n\r\n\r\nfunction swapAndPayOnChainNATIVE(\r\n    DataSwap0x calldata _dataSwap) external payable nonReentrant {\r\n\r\n    require(!locked);\r\n    require(_dataSwap.amountInMaximum \u003e 0);\r\n    require(msg.value == _dataSwap.amountInMaximum);\r\n    require(_dataSwap.tokenOut != address(0));\r\n    require(_dataSwap.amountOut \u003e 0);\r\n    require(_dataSwap.store != address(0));\r\n    require(_dataSwap.memo \u003e 0);\r\n\r\n    idPayment += 1;\r\n\r\n    _swapAndPayOnChainNATIVE(_dataSwap);\r\n\r\n}\r\n\r\n\r\nfunction _swapAndPayOnChainNATIVE(\r\n    DataSwap0x calldata _dataSwap) internal {\r\n\r\n    uint balanceStartTokenOut = IERC20(_dataSwap.tokenOut).balanceOf(address(this));\r\n    uint balanceStartTokenIn = address(this).balance;\r\n\r\n    (bool success0x,) = exchangeProxy.call{value: msg.value}(_dataSwap.swapCallData);\r\n    require(success0x, \u0027SWAP_CALL_FAILED\u0027);\r\n\r\n    uint boughtAmount = IERC20(_dataSwap.tokenOut).balanceOf(address(this)) - balanceStartTokenOut;\r\n    require(boughtAmount \u003e= _dataSwap.amountOut);\r\n\r\n    uint soldAmount = balanceStartTokenIn - address(this).balance;\r\n    \r\n    if (soldAmount \u003c _dataSwap.amountInMaximum) {\r\n        (bool success,) = msg.sender.call{ value: _dataSwap.amountInMaximum - soldAmount }(\"\");\r\n    }\r\n\r\n    if (boughtAmount \u003e _dataSwap.amountOut) {\r\n        TransferHelper.safeTransfer(_dataSwap.tokenOut, msg.sender, boughtAmount - _dataSwap.amountOut);\r\n    }\r\n    \r\n    uint fee = _payment(_dataSwap.store, _dataSwap.tokenOut, _dataSwap.amountOut);\r\n\r\n    emit Routed(\r\n        idPayment,\r\n        _dataSwap.store,\r\n        msg.sender,\r\n        _dataSwap.memo,\r\n        _dataSwap.tokenIn,\r\n        _dataSwap.tokenOut,\r\n        _dataSwap.amountOut,\r\n        fee,\r\n        soldAmount,\r\n        boughtAmount,\r\n        0,\r\n        0,\r\n        address(0));\r\n\r\n}\r\n\r\n\r\nfunction swapToStargate(\r\n    DataSwap0x calldata _dataSwap,\r\n    DataStargate0x calldata _dataStargate) external payable nonReentrant {\r\n\r\n    require(!locked);\r\n    require(msg.value \u003e 0);\r\n\r\n    require(_dataStargate.dstChainId \u003e 0);\r\n    require(_dataStargate.srcPoolId \u003e 0);\r\n    require(_dataStargate.dstPoolId \u003e 0);\r\n    require(_dataStargate.amountLD \u003e 0);\r\n    require(_dataStargate.minAmountLD \u003e 0);\r\n    require(_dataStargate.gasfee \u003e 0);\r\n    require(_dataStargate.receiverAddress != address(0));\r\n    require(_dataStargate.tokenBridge != address(0));\r\n\r\n\r\n    require(_dataSwap.tokenIn != address(0));\r\n    require(_dataSwap.tokenOut != address(0));\r\n    require(_dataSwap.amountOut \u003e 0);\r\n    require(_dataSwap.store != address(0));\r\n    require(_dataSwap.memo \u003e 0);\r\n\r\n    idPayment += 1;\r\n\r\n    _swapToStargate(_dataSwap, _dataStargate);\r\n    \r\n}\r\n\r\n\r\nfunction _swapToStargate(\r\n    DataSwap0x calldata _dataSwap,\r\n    DataStargate0x calldata _dataStargate) internal {\r\n    \r\n    require(IERC20(_dataSwap.tokenIn).balanceOf(msg.sender) \u003e= _dataStargate.amountLD);\r\n    require(IERC20(_dataSwap.tokenIn).allowance(msg.sender, address(this)) \u003e= _dataStargate.amountLD);\r\n        \r\n    TransferHelper.safeTransferFrom(_dataSwap.tokenIn, msg.sender, address(this), _dataStargate.amountLD);\r\n    TransferHelper.safeApprove(_dataSwap.tokenIn, address(stargateRouter), _dataStargate.amountLD);\r\n    \r\n    bytes memory payload = abi.encode(\r\n        idPayment,\r\n        source,\r\n        _dataSwap.store,\r\n        _dataSwap.amountOut,\r\n        msg.sender);\r\n\r\n     stargateRouter.swap{value: msg.value }(\r\n        _dataStargate.dstChainId,                          \r\n        _dataStargate.srcPoolId,                           \r\n        _dataStargate.dstPoolId,                           \r\n        payable(msg.sender),                      \r\n        _dataStargate.amountLD,                  \r\n        _dataStargate.minAmountLD,               \r\n        IStargateRouter.lzTxObj(_dataStargate.gasfee, 0, \"0x\"), \r\n        abi.encodePacked(_dataStargate.receiverAddress),    \r\n        payload);                     \r\n\r\n    emit Routed(\r\n        idPayment,\r\n        _dataSwap.store,\r\n        msg.sender,\r\n        _dataSwap.memo,\r\n        _dataSwap.tokenIn,\r\n        _dataSwap.tokenOut,\r\n        _dataSwap.amountOut,\r\n        0,\r\n        _dataStargate.amountLD,\r\n        _dataStargate.amountLD,\r\n        _dataStargate.dstChainId,\r\n        _dataStargate.minAmountLD,\r\n        _dataStargate.tokenBridge);\r\n\r\n}\r\n\r\n\r\nfunction swapAndPayCrossChainERC20(\r\n    DataSwap0x calldata _dataSwap,\r\n    DataStargate0x calldata _dataStargate) external payable nonReentrant {   \r\n        \r\n    require(!locked);\r\n    require(msg.value \u003e 0);\r\n\r\n    require(_dataSwap.tokenIn != address(0));\r\n    require(_dataSwap.tokenOut != address(0));\r\n    require(_dataSwap.amountOut \u003e 0);\r\n    require(_dataSwap.amountInMaximum \u003e 0);\r\n    require(_dataSwap.store != address(0));\r\n    require(_dataSwap.memo \u003e 0);    \r\n    \r\n    require(_dataStargate.dstChainId \u003e 0);\r\n    require(_dataStargate.srcPoolId \u003e 0);\r\n    require(_dataStargate.dstPoolId \u003e 0);\r\n    require(_dataStargate.amountLD \u003e 0);\r\n    require(_dataStargate.minAmountLD \u003e 0);\r\n    require(_dataStargate.gasfee \u003e 0);\r\n    require(_dataStargate.receiverAddress != address(0));\r\n    require(_dataStargate.tokenBridge != address(0));\r\n    \r\n    idPayment += 1;\r\n\r\n    _swapAndPayCrossChainERC20(_dataSwap, _dataStargate);\r\n\r\n}\r\n\r\n\r\nfunction _swapAndPayCrossChainERC20(\r\n    DataSwap0x memory _dataSwap,\r\n    DataStargate0x calldata _dataStargate) internal {\r\n\r\n    require(IERC20(_dataSwap.tokenIn).balanceOf(msg.sender) \u003e= _dataSwap.amountInMaximum);\r\n    require(IERC20(_dataSwap.tokenIn).allowance(msg.sender, address(this)) \u003e= _dataSwap.amountInMaximum);\r\n\r\n    uint balanceStartTokenIn = IERC20(_dataSwap.tokenIn).balanceOf(address(this));    \r\n    \r\n    TransferHelper.safeTransferFrom(_dataSwap.tokenIn, msg.sender, address(this), _dataSwap.amountInMaximum);\r\n    TransferHelper.safeApprove(_dataSwap.tokenIn, address(exchangeProxy), _dataSwap.amountInMaximum);\r\n    \r\n    uint balanceStartTokenOut = IERC20(_dataStargate.tokenBridge).balanceOf(address(this));\r\n    \r\n    (bool success,) = exchangeProxy.call{value: 0}(_dataSwap.swapCallData);\r\n    require(success, \u0027SWAP_CALL_FAILED\u0027);\r\n\r\n    uint boughtAmount = IERC20(_dataStargate.tokenBridge).balanceOf(address(this)) - balanceStartTokenOut;\r\n    require(boughtAmount \u003e= _dataStargate.amountLD);\r\n\r\n    uint soldAmount = balanceStartTokenIn + _dataSwap.amountInMaximum - IERC20(_dataSwap.tokenIn).balanceOf(address(this));\r\n\r\n    TransferHelper.safeApprove(_dataSwap.tokenIn, address(exchangeProxy), 0);\r\n        \r\n    if (soldAmount \u003c _dataSwap.amountInMaximum) {\r\n        TransferHelper.safeTransfer(_dataSwap.tokenIn, msg.sender, _dataSwap.amountInMaximum - soldAmount);\r\n    }\r\n\r\n    if (boughtAmount \u003e _dataStargate.amountLD) {\r\n        TransferHelper.safeTransfer(_dataStargate.tokenBridge, msg.sender, boughtAmount - _dataStargate.amountLD);\r\n    }\r\n\r\n    TransferHelper.safeApprove(_dataStargate.tokenBridge, address(stargateRouter), _dataStargate.amountLD);  \r\n    \r\n    _dataSwap.amountSold = soldAmount;\r\n    _dataSwap.amountBought = boughtAmount;\r\n\r\n    _swapToStargateFromERC20(_dataSwap, _dataStargate);\r\n\r\n}\r\n\r\n\r\nfunction _swapToStargateFromERC20(\r\n    DataSwap0x memory _dataSwap,\r\n    DataStargate0x calldata _dataStargate) internal {\r\n\r\n    bytes memory payload = abi.encode(\r\n        idPayment,\r\n        source,\r\n        _dataSwap.store,\r\n        _dataSwap.amountOut,\r\n        msg.sender);\r\n\r\n    stargateRouter.swap{value: msg.value }(\r\n        _dataStargate.dstChainId,          \r\n        _dataStargate.srcPoolId,           \r\n        _dataStargate.dstPoolId,           \r\n        payable(msg.sender),                \r\n        _dataStargate.amountLD,            \r\n        _dataStargate.minAmountLD,         \r\n        IStargateRouter.lzTxObj(_dataStargate.gasfee, 0, \"0x\"), \r\n        abi.encodePacked(_dataStargate.receiverAddress),    \r\n        payload);                     \r\n\r\n    emit Routed(\r\n        idPayment,\r\n        _dataSwap.store,\r\n        msg.sender,\r\n        _dataSwap.memo,\r\n        _dataSwap.tokenIn,\r\n        _dataSwap.tokenOut,\r\n        _dataSwap.amountOut,\r\n        0,\r\n        _dataSwap.amountSold,\r\n        _dataSwap.amountBought,\r\n        _dataStargate.dstChainId,\r\n        _dataStargate.minAmountLD,\r\n        _dataStargate.tokenBridge);\r\n\r\n}\r\n\r\n\r\nfunction swapAndPayCrossChainNATIVE(\r\n    DataSwap0x calldata _dataSwap,\r\n    DataStargate0x calldata _dataStargate) external payable nonReentrant {\r\n    \r\n    require(!locked);\r\n    require(msg.value \u003e 0);\r\n  \r\n    require(_dataSwap.tokenIn != address(0));\r\n    require(_dataSwap.tokenOut != address(0));\r\n    require(_dataSwap.amountOut \u003e 0);\r\n    require(_dataSwap.amountInMaximum \u003e 0);\r\n    require(_dataSwap.store != address(0));\r\n    require(_dataSwap.memo \u003e 0);    \r\n    \r\n    require(_dataStargate.dstChainId \u003e 0);\r\n    require(_dataStargate.srcPoolId \u003e 0);\r\n    require(_dataStargate.dstPoolId \u003e 0);\r\n    require(_dataStargate.amountLD \u003e 0);\r\n    require(_dataStargate.minAmountLD \u003e 0);\r\n    require(_dataStargate.gasfee \u003e 0);\r\n    require(_dataStargate.receiverAddress != address(0));\r\n    require(_dataStargate.tokenBridge != address(0));\r\n\r\n    idPayment += 1;\r\n\r\n    _swapAndPayCrossChainNATIVE(_dataSwap, _dataStargate);\r\n\r\n}\r\n\r\n\r\nfunction _swapAndPayCrossChainNATIVE(\r\n    DataSwap0x memory _dataSwap,\r\n    DataStargate0x calldata _dataStargate) internal {\r\n      \r\n    uint balanceStartTokenOut = IERC20(_dataStargate.tokenBridge).balanceOf(address(this));\r\n    uint balanceStartTokenIn = address(this).balance;\r\n\r\n    (bool success0x,) = exchangeProxy.call{value: _dataSwap.amountInMaximum }(_dataSwap.swapCallData);\r\n    require(success0x, \u0027SWAP_CALL_FAILED\u0027);\r\n\r\n    uint boughtAmount = IERC20(_dataStargate.tokenBridge).balanceOf(address(this)) - balanceStartTokenOut;\r\n    require(boughtAmount \u003e= _dataStargate.amountLD);\r\n\r\n    uint soldAmount = balanceStartTokenIn - address(this).balance;\r\n        \r\n    if (soldAmount \u003c _dataSwap.amountInMaximum) {\r\n        (bool success,) = msg.sender.call{ value: _dataSwap.amountInMaximum - soldAmount }(\"\");\r\n    }\r\n\r\n    if (boughtAmount \u003e _dataStargate.amountLD) {\r\n        TransferHelper.safeTransfer(_dataStargate.tokenBridge, msg.sender, boughtAmount - _dataStargate.amountLD);\r\n    }\r\n\r\n    TransferHelper.safeApprove(_dataStargate.tokenBridge, address(stargateRouter), _dataStargate.amountLD);  \r\n\r\n    _dataSwap.amountSold = soldAmount;\r\n    _dataSwap.amountBought = boughtAmount;\r\n\r\n    _swapToStargateFromNATIVE(_dataSwap, _dataStargate);\r\n\r\n}\r\n\r\n\r\nfunction _swapToStargateFromNATIVE(\r\n    DataSwap0x memory _dataSwap,\r\n    DataStargate0x calldata _dataStargate) internal {\r\n    \r\n    bytes memory payload = abi.encode(\r\n        idPayment,\r\n        source,\r\n        _dataSwap.store,\r\n        _dataSwap.amountOut,\r\n        msg.sender);\r\n\r\n    stargateRouter.swap{value: msg.value - _dataSwap.amountInMaximum }(\r\n        _dataStargate.dstChainId,                         \r\n        _dataStargate.srcPoolId,                          \r\n        _dataStargate.dstPoolId,                          \r\n        payable(msg.sender),                      \r\n        _dataStargate.amountLD,                  \r\n        _dataStargate.minAmountLD,\r\n        IStargateRouter.lzTxObj(_dataStargate.gasfee, 0, \"0x\"),\r\n        abi.encodePacked(_dataStargate.receiverAddress),   \r\n        payload);                     \r\n\r\n   emit Routed(\r\n        idPayment,\r\n        _dataSwap.store,\r\n        msg.sender,\r\n        _dataSwap.memo,\r\n        _dataSwap.tokenIn,\r\n        _dataSwap.tokenOut,\r\n        _dataSwap.amountOut,\r\n        0,\r\n        _dataSwap.amountSold,\r\n        _dataSwap.amountBought,\r\n        _dataStargate.dstChainId,\r\n        _dataStargate.minAmountLD,\r\n        _dataStargate.tokenBridge);\r\n\r\n}\r\n\r\n\r\nfunction sgReceive(\r\n    uint16 /*_srcChainId*/,            \r\n    bytes memory /*_srcAddress*/,      \r\n    uint256 _nonce,                  \r\n    address _token,                \r\n    uint256 amountLD,              \r\n    bytes memory payload) external nonReentrant {\r\n\r\n    require(msg.sender == address(stargateRouter)); \r\n\r\n    (uint id,\r\n     uint sourceId,\r\n     address store,\r\n     uint amountOut,\r\n     address sender) = abi.decode(payload, (uint, uint, address, uint, address));\r\n \r\n    uint amountToPay;\r\n\r\n    if (amountLD \u003e amountOut) {\r\n        TransferHelper.safeTransfer(_token, sender, amountLD - amountOut);\r\n        amountToPay = amountOut;\r\n    }\r\n\r\n    if (amountLD \u003c= amountOut) {\r\n        amountToPay = amountLD;\r\n    }\r\n\r\n    uint fee = _payment(store, _token, amountToPay);\r\n\r\n    emit ReceivedFromStargate(\r\n        _nonce,\r\n        id,\r\n        sourceId,\r\n        store,\r\n        sender,\r\n        _token,\r\n        amountLD,\r\n        amountToPay,\r\n        fee);\r\n\r\n}    \r\n\r\n\r\nfunction _payment(\r\n    address _store,\r\n    address _tokenOut,\r\n    uint _amountOut) internal returns (uint) {\r\n\r\n    uint decimals = ERC20(_tokenOut).decimals();\r\n    \r\n    uint feeAmount = _amountOut * ((feeStore) * 10 ** decimals / 10000);\r\n    feeAmount = feeAmount / 10 ** decimals;\r\n\r\n    uint netAmount = _amountOut - feeAmount;\r\n    \r\n    TransferHelper.safeTransfer(_tokenOut, _store, netAmount);\r\n\r\n    if (feeAmount \u003e 0) {\r\n        TransferHelper.safeTransfer(_tokenOut, treasury, feeAmount);\r\n    }\r\n \r\n    return feeAmount;\r\n\r\n}\r\n\r\n\r\nfunction withdrawEther() external payable nonReentrant {\r\n  \r\n    require(msg.sender == treasury);\r\n    (bool sent,) = treasury.call{value: address(this).balance}(\"\");\r\n    \r\n}\r\n\r\n\r\nfunction balanceEther() external view returns (uint) {\r\n \r\n    return address(this).balance;\r\n\r\n}\r\n\r\n\r\nfunction balanceERC20(IERC20 _token) external view returns (uint) {\r\n \r\n    return _token.balanceOf(address(this));\r\n\r\n}\r\n\r\n\r\nfunction withdrawERC20(IERC20 _token) external nonReentrant {\r\n  \r\n    require(msg.sender == treasury);\r\n    TransferHelper.safeTransfer(address(_token), treasury, _token.balanceOf(address(this)));\r\n    \r\n}\r\n\r\n\r\nreceive() external payable {}\r\n\r\n\r\n}"}}