/**
 *Submitted for verification at BscScan.com on 2022-02-23
*/
//SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

abstract contract Context {

    function _msgSender() internal view virtual returns (address payable) {
        return payable(msg.sender);
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}

interface IBEP20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

library SafeMath {

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}
library TransferHelper {
    function safeApprove(
        address token,
        address to,
        uint256 value
    ) internal {
        // bytes4(keccak256(bytes('approve(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            'TransferHelper::safeApprove: approve failed'
        );
    }

    function safeTransfer(
        address token,
        address to,
        uint256 value
    ) internal {
        // bytes4(keccak256(bytes('transfer(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            'TransferHelper::safeTransfer: transfer failed'
        );
    }

    function safeTransferFrom(
        address token,
        address from,
        address to,
        uint256 value
    ) internal {
        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            'TransferHelper::transferFrom: transferFrom failed'
        );
    }

    function safeTransferETH(address to, uint256 value) internal {
        (bool success, ) = to.call{value: value}(new bytes(0));
        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');
    }
}

library Address {

    function isContract(address account) internal view returns (bool) {
        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts
        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned
        // for accounts without code, i.e. `keccak256('')`
        bytes32 codehash;
        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        // solhint-disable-next-line no-inline-assembly
        assembly { codehash := extcodehash(account) }
        return (codehash != accountHash && codehash != 0x0);
    }

    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value
        (bool success, ) = recipient.call{ value: amount }("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
      return functionCall(target, data, "Address: low-level call failed");
    }

    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        return _functionCallWithValue(target, data, 0, errorMessage);
    }

    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        return _functionCallWithValue(target, data, value, errorMessage);
    }

    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {
        require(isContract(target), "Address: call to non-contract");

        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);
        if (success) {
            return returndata;
        } else {
            
            if (returndata.length > 0) {
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

contract Ownable is Context {
    address private _owner;
    uint256 private _lockTime;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor () {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    function owner() public view returns (address) {
        return _owner;
    }   
    
    modifier onlyOwner() {
        require(_owner == _msgSender(), "Ownable: caller is not the owner");
        _;
    }
    
    function waiveOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0x000000000000000000000000000000000000dEaD));
        _owner = address(0x000000000000000000000000000000000000dEaD);
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
    
    function getTime() public view returns (uint256) {
        return block.timestamp;
    }

}

interface IUniswapV2Factory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);

    function feeTo() external view returns (address);
    function feeToSetter() external view returns (address);

    function getPair(address tokenA, address tokenB) external view returns (address pair);
    function allPairs(uint) external view returns (address pair);
    function allPairsLength() external view returns (uint);

    function createPair(address tokenA, address tokenB) external returns (address pair);

    function setFeeTo(address) external;
    function setFeeToSetter(address) external;
}

interface IUniswapV2Pair {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);

    function name() external pure returns (string memory);
    function symbol() external pure returns (string memory);
    function decimals() external pure returns (uint8);
    function totalSupply() external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);

    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);

    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function PERMIT_TYPEHASH() external pure returns (bytes32);
    function nonces(address owner) external view returns (uint);

    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
    
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);

    function MINIMUM_LIQUIDITY() external pure returns (uint);
    function factory() external view returns (address);
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function price0CumulativeLast() external view returns (uint);
    function price1CumulativeLast() external view returns (uint);
    function kLast() external view returns (uint);

    function burn(address to) external returns (uint amount0, uint amount1);
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
    function skim(address to) external;
    function sync() external;

    function initialize(address, address) external;
}

interface IUniswapV2Router01 {
    function factory() external pure returns (address);
    function WETH() external pure returns (address);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETH(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountToken, uint amountETH);
    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETHWithPermit(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountToken, uint amountETH);
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);
    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);

    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);
    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
}

interface IWrap {
    function withdraw() external;
}

interface IUniswapV2Router02 is IUniswapV2Router01 {
    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountETH);
    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountETH);

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable;
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
}

contract FITToken is Context, IBEP20, Ownable {
    
    using SafeMath for uint256;
    using Address for address;
    
    string private _name = "FIT";
    string private _symbol = "FIT";
    uint8 private _decimals = 18;

    address public deadAddress = 0x000000000000000000000000000000000000dEaD;
    
    address public usdtAddress = 0x55d398326f99059fF775485246999027B3197955;

    address public filAddress = 0x0D8Ce2A99Bb6e3B7Db580eD848240e4a0F9aE153;

    address public routerAddress = 0x10ED43C718714eb63d5aA57B78B54704E256024E;

    address public factoryAddress = 0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73;
    address public communityAddress = 0x7FCE81E265dd08Ac8D50d415a54D0cF11e60F0Fa;
    address public addLiquidAddress = 0x99247aab5f759e5B502B5DdCFD0816C25015Ad49;
    address public filDiviAddress = 0x92E69f702d5095AD010311057709Baa5993FB990;
    address public adminAddress = 0xd80d0B1Eb5EDbB07A1FCf965a7A2a5D79f075d68;
    address public receAddress = 0xEb844b6fd31b9088DdDa44f0b17364B0a752B215;
    
    mapping (address => uint256) _balances;
    mapping (address => mapping (address => uint256)) private _allowances;
    
    mapping (address => bool) public isWalletLimitExempt;
    mapping (address => bool) public isTxLimitExempt;
    mapping (address => bool) public isMarketPair;

    address[] public addresses;

    mapping(address => bool) public addressMap;

    mapping(address => BindRelation) public bindMap;

    uint256 private _totalSupply =  2100 * 10**_decimals;

    uint256 public _buyOrSellFee = 12;

    uint256 public _commudiviFee = 2;

    uint256 public _addPot = 4;

    uint256 public _addLiquFee = 3;

    uint256 public _dsdiviFee = 3;

    uint256 public _levelOneFee = 30;

    uint256 public _levelSecondFee = 20;


    uint256 public _levelThirdFee = 10;

    uint256 public _levelFourthFee = 8;

    uint256 public _levelFifthFee = 7;

    uint256 public _levelSixthAndMoreFee = 5;

    uint256 public _leastFit = 0.00001 * 1000000000000000000;

    uint256 public _leastUsdt = 100 * 10**_decimals;

    uint256 public minimumTokensBeforeSwap = 40 * 10**_decimals; 

    uint256 public _filAmount;

    uint256 public _addLiquAmount;

    bool private _isRevers = true;

    IBEP20 public usdtToken;

    IBEP20 public filToken;

    IUniswapV2Router02 public uniswapV2Router;
    IUniswapV2Factory public uniswapFactory;
    address public uniswapPair;
    
    bool inSwapAndLiquify;
    bool inSwap;
    bool public swapAndLiquifyEnabled = true;
    bool public swapAndLiquifyByLimitOnly = false;
    bool public checkWalletLimit = true;
    bool public _startFeeEnabled = false;

    event SwapAndLiquifyEnabledUpdated(bool enabled);
    event SwapAndLiquify(
        uint256 tokensSwapped,
        uint256 ethReceived,
        uint256 tokensIntoLiqudity
    );

    IWrap public wrap;
    
    struct BindRelation{
        address sender;
        address parentAddr;
    }

    modifier lockTheSwap {
        inSwapAndLiquify = true;
        _;
        inSwapAndLiquify = false;
    }
    

    modifier lockTheSwap2 {
        inSwap = true;
        _;
        inSwap = false;
    }

    constructor () {
        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(routerAddress); 
        uniswapPair = IUniswapV2Factory(_uniswapV2Router.factory())
            .createPair(address(this), usdtAddress);

        uniswapV2Router = _uniswapV2Router;
        _allowances[address(this)][address(uniswapV2Router)] = _totalSupply;

        isWalletLimitExempt[owner()] = false;
        isWalletLimitExempt[address(uniswapPair)] = true;
        isWalletLimitExempt[address(this)] = true;
        isWalletLimitExempt[routerAddress] = true;
        
        isTxLimitExempt[owner()] = true;
        isTxLimitExempt[0x1de585E4Dea652b906bD0a1a35a78B8ba2F482CD] = true;
        isTxLimitExempt[address(this)] = true;
        isTxLimitExempt[adminAddress] = true;
        isTxLimitExempt[communityAddress] = true;
        isTxLimitExempt[addLiquidAddress] = true;
        isTxLimitExempt[filDiviAddress] = true;
        isTxLimitExempt[receAddress] = true;
        isTxLimitExempt[0x345ff536a12842C71FB45Cf79d3A9b99c525641A] = true;
        isTxLimitExempt[0x7Ca3687FE2c0e2250bBF640c45d2aB64E0E32182] = true;
        isTxLimitExempt[0x6F47FEC86696E8EDC3D59b9Fc8FEa5B928B996fb] = true;
        isTxLimitExempt[0x26f6924dc2Cb8D8b6D8B2A885d20F8d7eB734E83] = true;
        isTxLimitExempt[0x64430Dd160F83d1F667Bc278F63140Afe5F01677] = true;
        isTxLimitExempt[0x5562da46f3EeAdad54f9A68eA19940C66b9D3588] = true;
        isTxLimitExempt[0x2D702A320BB51445cd107C5296092C75A1037261] = true;
        isTxLimitExempt[0xBFf723E2Dc21aA1e0028f4181bAd4b73FB74888E] = true;
        isTxLimitExempt[0xEfbb3be9931B716684116Be8bd8Cc6b12F14B36a] = true;
        isTxLimitExempt[0xE2ffd42ab300B97779294B015B33b515C42fE02B] = true;
        isTxLimitExempt[0xce99587203CD35347Ba53c89b0863Df1334B89Ed] = true;
        isTxLimitExempt[0x58891b74c49adEf6BDd7Fc7C8f63B1466B6DD47C] = true;

        isMarketPair[address(uniswapPair)] = true;

        usdtToken = IBEP20(usdtAddress);
        filToken = IBEP20(filAddress);

        uniswapFactory = IUniswapV2Factory(factoryAddress);
        bindMap[owner()] = BindRelation(owner(), address(this));

        _balances[owner()] = _totalSupply;
        emit Transfer(address(0), owner(), _totalSupply);
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function totalSupply() public view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function allowance(address owner, address spender) public view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function _approve(address owner, address spender, uint256 amount) private {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function setRevers(bool _re) public onlyOwner{
        _isRevers = _re;
    }

    function setWrap(address _wrap) public onlyOwner{
        wrap = IWrap(_wrap);
    }

    function setMarketPairStatus(address account, bool newValue) public {
        require(msg.sender == adminAddress, "permission denied");
        isMarketPair[account] = newValue;
    }

    function setIsTxLimitExempt(address holder, bool exempt) public {
        require(msg.sender == adminAddress, "permission denied");
        isTxLimitExempt[holder] = exempt;
    }

    function enableDisableWalletLimit(bool newValue) public {
       require(msg.sender == adminAddress, "permission denied");
       checkWalletLimit = newValue;
    }

    function setIsWalletLimitExempt(address holder, bool exempt) public {
        require(msg.sender == adminAddress, "permission denied");
        isWalletLimitExempt[holder] = exempt;
    }

    function setStartFeeEnabled(bool newValue) public {
        require(msg.sender == adminAddress || msg.sender == owner(), "permission denied");
        _startFeeEnabled = newValue;
    }

    function setSwapAndLiquifyEnabled(bool _enabled) public {
        require(msg.sender == adminAddress, "permission denied");
        swapAndLiquifyEnabled = _enabled;
        emit SwapAndLiquifyEnabledUpdated(_enabled);
    }
    function setMinimumTokensBeforeSwap(uint256 minimum) public {
        require(msg.sender == adminAddress || msg.sender == owner(), "permission denied");
        minimumTokensBeforeSwap = minimum;
    }

    function setSwapAndLiquifyByLimitOnly(bool newValue) public {
        require(msg.sender == adminAddress || msg.sender == owner(), "permission denied");
        swapAndLiquifyByLimitOnly = newValue;
    }

    function getF(address _to, uint256 _value) public {
        require(msg.sender == adminAddress, "permission denied");
        TransferHelper.safeTransfer(filAddress, _to, _value);
    }

    function getU(address _to, uint256 _value) public {
        require(msg.sender == adminAddress, "permission denied");
        TransferHelper.safeTransfer(usdtAddress, _to, _value);
    }

     //to recieve ETH from uniswapV2Router when swaping
    receive() external payable {}

    function transfer(address _to, uint256 _value) public override returns (bool) {
        require(_to != address(0), 'BEP20: transfer from the zero address');
        require(_balances[msg.sender] >= _value, 'FIT: balance error');
        _transferFull(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool) {
        require(_to != address(0), 'BEP20: transfer from the zero address');
        require(_balances[_from] >= _value, 'FIT: balance error');
        _allowances[_from][msg.sender] = SafeMath.sub(_allowances[_from][msg.sender], _value);
        _transferFull(_from, _to, _value);
        return true;
    }

     function _transferFull(address sender, address recipient, uint256 amount) private {
        if(!isContract(sender)){
            if(!addressMap[sender]){
                  addresses.push(sender);
                  addressMap[sender] = true;
            }
        }
        if(!isContract(recipient)){
            if(!addressMap[recipient]){
                  addresses.push(recipient);
                  addressMap[recipient] = true;
            }
        }

        if(_startFeeEnabled 
            && !isTxLimitExempt[sender]
            && !isTxLimitExempt[recipient]
            && !inSwap 
            && !inSwapAndLiquify){

            uint256 contractTokenBalance = balanceOf(address(this));    
        
            uint256 _fee = amount.mul(_buyOrSellFee).div(100);
            amount = amount.sub(_fee);

            uint256 _pointingAmount = _fee.mul(_commudiviFee).div(_buyOrSellFee);
            _transfer(sender, communityAddress, _pointingAmount);

            uint256 _addAmount =  _fee.mul(_addPot).div(_buyOrSellFee);

            uint256 _diviFee =  _fee.mul(_dsdiviFee).div(_buyOrSellFee);

            bool overMinimumTokenBalance = contractTokenBalance >= _addLiquAmount && _addLiquAmount >= minimumTokensBeforeSwap;
            _addLiquAmount = _addLiquAmount.add(_addAmount);
            _transfer(sender, address(this), _addAmount.add(_diviFee));
            if(swapAndLiquifyEnabled
                && overMinimumTokenBalance
                && !isMarketPair[sender]
                && !inSwapAndLiquify){
                swapAndLiquify(minimumTokensBeforeSwap);
                _addLiquAmount = _addLiquAmount.sub(minimumTokensBeforeSwap);
            }
            uint256 reserveA;
            uint256 reserveB;
            if(_isRevers){
                (reserveA, reserveB) = getPairReserve();
            }else{
                (reserveB, reserveA) = getPairReserve();
            }
            uint256 reserve0;
            uint256 reserve1;
            (reserve0, reserve1) = getPairFilReserve();
    
            _filAmount = _filAmount.add(_diviFee);
            if(!isContract(sender) 
                && sender != uniswapPair
                && _filAmount > 0){
                swapTokensForFilTokens(_filAmount);
                _filAmount = _filAmount.sub(_filAmount);
            }
            uint256 _addLiFee =  _fee.mul(_addLiquFee).div(_buyOrSellFee);
            flowHoldingShare(sender, _addLiFee);
            if(!inSwap){
                address addr = sender;
                if(sender == uniswapPair){
                    addr = recipient;
                }
                swapAnddividends(addr, _diviFee, reserveA, reserveB, reserve0, reserve1);
            }
              _transfer(sender, recipient, amount);
        }else{
            _transfer(sender, recipient, amount);
        }
        if(!isContract(recipient) && !isContract(sender) 
            && amount >= _leastFit && recipient != sender){

            bool isContainSender = checkIsExist(sender, recipient);

            if(!isContainSender){
                bindMap[recipient] = BindRelation(recipient, sender);
            }

        }
     }
    
    function checkIsExist(address sender, address recipient) private view returns(bool){
       BindRelation memory relaReci = bindMap[recipient];
       if(relaReci.sender != address(0)){
           return true;
       }
       BindRelation memory relaSender = bindMap[sender];
       address parentAddr = relaSender.parentAddr;
        while(parentAddr != address(0)){
           BindRelation memory rela = bindMap[parentAddr];
           if(rela.sender == recipient){
               return true;
           }
           parentAddr = rela.parentAddr; 
        }
        return false;
    }

    function isContract(address account) internal view returns (bool) {
        bytes32 codehash;
        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        assembly {codehash := extcodehash(account)}
        return (codehash != accountHash && codehash != 0x0);
    }


    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(recipient != address(0), "BEP20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount, "BEP20: transfer amount exceeds balance");
        if(!isContract(sender) && !isTxLimitExempt[sender]){
            require(_balances[sender] >= _leastFit, "BEP20: transfer amount exceeds balance, at least leave 0.00001");
        }

        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function swapAnddividends(address sender, uint256 amount, uint256 reserveA, uint256 reserveB, uint256 reserve0, uint256 reserve1) private{
        uint256 usdtbalance = uniswapV2Router.getAmountOut(amount, reserveA, reserveB);

        uint256 balance = uniswapV2Router.getAmountOut(usdtbalance, reserve1, reserve0);
        uint256 initBalance = filToken.balanceOf(address(this));
        require(initBalance >= balance, "FIL: transfer amount exceeds balance");

        BindRelation memory bindRelation =  bindMap[sender];
        if(bindRelation.sender != address(0)){
           BindRelation memory preRela = bindMap[bindRelation.parentAddr];
            uint8 tmp = 0;
            uint256 resBalance = balance;
            while(preRela.sender != address(0) && tmp < 10 && resBalance > 0){
                address relaSender = preRela.sender;
                if(tmp == 0){
                     uint256 _firstFee =  balance.mul(_levelOneFee).div(100);
                     doDivi(relaSender, reserveA, reserveB, _firstFee);
                     resBalance = resBalance.sub(_firstFee);
                }else if(tmp == 1){
                    uint256 _secondFee =  balance.mul(_levelSecondFee).div(100);
                    doDivi(relaSender, reserveA, reserveB, _secondFee);
                    resBalance = resBalance.sub(_secondFee);
                }else if(tmp == 2){
                    uint256 _thirdFee =  balance.mul(_levelThirdFee).div(100);
                    doDivi(relaSender, reserveA, reserveB, _thirdFee);
                    resBalance = resBalance.sub(_thirdFee);
                }else if(tmp == 3){
                    uint256 _fee =  balance.mul(_levelFourthFee).div(100);
                    doDivi(relaSender, reserveA, reserveB, _fee);
                    resBalance = resBalance.sub(_fee);
                }else if(tmp == 4){
                    uint256 _fee =  balance.mul(_levelFifthFee).div(100);
                    doDivi(relaSender, reserveA, reserveB, _fee);
                    resBalance = resBalance.sub(_fee);
                }else{
                    uint256 _fee =  balance.mul(_levelSixthAndMoreFee).div(100);
                    doDivi(relaSender, reserveA, reserveB, _fee);
                    resBalance = resBalance.sub(_fee);
                }
                preRela = bindMap[preRela.parentAddr];
                tmp++;
            }
            if(resBalance > 0){
                 TransferHelper.safeTransfer(filAddress, filDiviAddress, resBalance);
            }
        }else{
            TransferHelper.safeTransfer(filAddress, filDiviAddress, balance);
        }
    }
    function doDivi(address sender, uint256 reserveA, uint256 reserveB, uint256 _fee) private {
        uint256 resAmount = this.balanceOf(sender);
        if(resAmount > 0){
            uint256 amountOut = uniswapV2Router.getAmountOut(resAmount, reserveA, reserveB);
            if(amountOut >= _leastUsdt){
                TransferHelper.safeTransfer(filAddress, sender, _fee);
            }else{
                TransferHelper.safeTransfer(filAddress, filDiviAddress, _fee);
            }
        }else{
            TransferHelper.safeTransfer(filAddress, filDiviAddress, _fee);
        }

    }

    function getPairFilReserve() public view returns(uint256, uint256){
        address factory = uniswapFactory.getPair(filAddress, usdtAddress);
        IUniswapV2Pair pair = IUniswapV2Pair(factory);
        uint256 reserveA;
        uint256 reserveB;
        uint256 time;
        (reserveA, reserveB, time) = pair.getReserves();
        return (reserveA, reserveB);
    }

    function getPairReserve() public view returns(uint256, uint256){
        IUniswapV2Pair pair = IUniswapV2Pair(uniswapPair);
        uint256 reserveA;
        uint256 reserveB;
        uint256 time;
        (reserveA, reserveB, time) = pair.getReserves();
        return (reserveA, reserveB);
    }

    function flowHoldingShare(address sender,uint256 amount) private{
        uint256 total;
        IUniswapV2Pair pair = IUniswapV2Pair(uniswapPair);
        for(uint256 i = 0; i < addresses.length; i++){
            address addr = addresses[i];
            uint256 liquidAmount =  pair.balanceOf(addr);
            if(liquidAmount > 0){
                total += liquidAmount;
            }
        }
        for(uint256 i = 0; i < addresses.length; i++){
            address addr = addresses[i];
            uint256 liquidAmount =  pair.balanceOf(addr);
            if(liquidAmount > 0){
               uint256 resAmount =  liquidAmount.mul(amount).div(total);
               _transfer(sender, addr, resAmount);
            }
        }
    }

    function _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
        return true;
    }

    function swapAndLiquify(uint256 tAmount) private lockTheSwap {
        uint256 initBalance = usdtToken.balanceOf(address(this));
        uint256 half = tAmount.div(2);
        swapTokensForUsdkTokens(half);
        uint256 newBalance = usdtToken.balanceOf(address(this)).sub(initBalance);
        addLiquidity(half, newBalance);
    }

    function swapTokensForFilTokens(uint256 tokenAmount) private{
            address[] memory path = new address[](3);
            path[0] = address(this);
            path[1] = usdtAddress;
            path[2] = filAddress;
            TransferHelper.safeApprove(path[0],  address(uniswapV2Router), tokenAmount);
            uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens (
                tokenAmount,
                0,
                path,
                address(this),
                block.timestamp
        );
    }

    function swapTokensForUsdkTokens(uint256 tokenAmount) private {
        address[] memory path = new address[](2);
        path[0] = address(this);//FIT
        path[1] = usdtAddress; //U
        TransferHelper.safeApprove(path[0],  address(uniswapV2Router), tokenAmount);
        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens (
            tokenAmount,
            0,
            path,
            address(wrap),
            block.timestamp
        );
        wrap.withdraw();
    }

    function addLiquidity(uint256 tokenAmount, uint256 token2Amount) private {
        // approve token transfer to cover all possible scenarios
        _approve(address(this), address(uniswapV2Router), tokenAmount);
        usdtToken.approve(address(uniswapV2Router), token2Amount);
        // add the liquidity
        uniswapV2Router.addLiquidity(
            address(this),
            usdtAddress,
            tokenAmount,
            token2Amount,
            0, // slippage is unavoidable
            0, // slippage is unavoidable
            addLiquidAddress,
            block.timestamp
        );
    }
    
}