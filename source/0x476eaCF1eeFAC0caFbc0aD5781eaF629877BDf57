{"Fixed.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// Date: 26-03-22\r\n\r\npragma solidity ^0.8.10;\r\nimport \"./IERC20.sol\";\r\nimport \"./ownable.sol\";\r\nimport \"./launchpad.sol\";\r\nimport \"./idoToken.sol\";\r\n\r\ncontract FixedStaking is Ownable {\r\n    struct UserStake {\r\n        address user;\r\n        uint256 amount;\r\n        uint64 stakeTime;\r\n        uint64 lockedfor;\r\n        bool unstakecomp;\r\n        uint64 lastClaimed;\r\n    }\r\n    UserStake[] userStake;  // Can make this public to unpublic\r\n    uint64 public lockperiod = 3 minutes;\r\n    IERC20 public stakedToken;  // Address to add while deploying contract\r\n    IERC20 public rewardToken;  // Address to add while deploying contract\r\n    address public launchpadAddress; // Address will be updated by the owner of launchpad\r\n    IERC20 public idoToken;          // Address to add while deploying contract\r\n    uint256 public totalStaked;\r\n    uint256 public aprPercent;  // Update by the owner\r\n    uint256 public minStake = 0; // Update by the owner\r\n    uint256 public maxStake = 100000000000 * 1e18 * 1e18; // Update by the owner\r\n    uint256 public idoMulti = 1; // Update by the owner\r\n    uint256 per;\r\n    uint256 public contractEnd; // Update by the owner\r\n\r\n    // Fees and Penalty\r\n    uint256 public stakeFeePercent = 0;\r\n    uint256 public unStakeFeePercent = 0;\r\n    uint256 public collectedFees;\r\n    uint256 public collectedPenalty;\r\n    uint256 public penaltyPercent = 2500000000000000000;\r\n\r\n\r\n    \r\n    mapping(address =\u003e uint) public Userstaked;\r\n    mapping(address =\u003e uint) public idoBalance;\r\n    mapping(address =\u003e uint) public idoTransfer;\r\n    mapping(address =\u003e uint) public pendingRewards;\r\n    \r\n    constructor(IERC20 _rewardToken, IERC20 _stakedToken, IERC20 _idoToken) {\r\n        rewardToken = _rewardToken;\r\n        stakedToken = _stakedToken;\r\n        idoToken = _idoToken;\r\n    }\r\n\r\n    // Staking Fucntion for the user\r\n    function stake(uint256 _amount) external {\r\n        if (contractEnd != 0) {\r\n            require(contractEnd \u003e block.timestamp, \"Staking has been Stop\" );\r\n        }\r\n        require(minStake \u003c _amount \u0026\u0026 maxStake \u003e= _amount, \"Could not stake this amount\");\r\n        if (stakeFeePercent \u003e 0) {\r\n            uint256 fee = _amount * stakeFeePercent / 100000000000000000000;\r\n            _amount = _amount - fee;\r\n            collectedFees = collectedFees + fee;\r\n        }\r\n        userStake.push(UserStake(msg.sender, _amount,uint64(block.timestamp),lockperiod, false, uint64(block.timestamp)));\r\n        stakedToken.transferFrom(msg.sender, address(this), _amount);\r\n        Userstaked[msg.sender] = Userstaked[msg.sender] + _amount;\r\n        idoBalance[msg.sender] = idoBalance[msg.sender] + (_amount * idoMulti);\r\n        IDO(address(idoToken)).mint(address(this), (_amount * idoMulti));\r\n        totalStaked = totalStaked + _amount;\r\n    }\r\n    \r\n    // Unstaking Fucntion for the user\r\n    function unStake(uint256 _amount) external {\r\n        require(checkUserValid(msg.sender) != 0, \"Not a Valid User\");\r\n        require(_amount \u003e 0, \"Can\u0027t Unstake 0\");\r\n        require(idoBalance[msg.sender] \u003e= (_amount * idoMulti), \"Unstake failed! User dont haveSUFFICIENT IDO Token\");\r\n        require(checkUserValid(msg.sender) != 0, \"Not a Valid User\");\r\n        uint256 tempwithdraw = 0;\r\n        uint256 checkwithdraw = 0;\r\n        address _user = msg.sender;\r\n        pendingClaim(_user);\r\n        \r\n        for(uint256 i = 0; i \u003c userStake.length; i++) {\r\n            if (checkwithdraw \u003c _amount) {\r\n                if (userStake[i].user == _user \u0026\u0026 userStake[i].unstakecomp == false) {          \r\n                    if (userStake[i].stakeTime + userStake[i].lockedfor \u003c= block.timestamp) {           // Normal Unstake without Penalty\r\n                       if(userStake[i].amount \u003e= _amount) {\r\n                           tempwithdraw = tempwithdraw + _amount;\r\n                           userStake[i].amount = userStake[i].amount - _amount;\r\n                           idoBalance[msg.sender] = idoBalance[msg.sender] - (_amount * idoMulti); \r\n                           IDO(address(idoToken)).burn(address(this), (_amount * idoMulti));\r\n                           checkwithdraw = tempwithdraw;\r\n                           if (userStake[i].amount == 0) {\r\n                               userStake[i].unstakecomp = true;\r\n                           }\r\n                        }  \r\n                    } else {                                                            // This part of code get executed when user unstake before unlock\r\n                        if(userStake[i].amount \u003e= _amount) {\r\n                            // For the user with penalty for withdrwaing before unlock\r\n                            // amount 1000000000000000000000 * 2500000000000000000 / 100\r\n                            // 1000 * 2.5 / 100\r\n                            uint256 penalty = _amount * penaltyPercent / 100000000000000000000; \r\n                            collectedPenalty = collectedPenalty + penalty;\r\n                            uint256 tempamout = _amount - penalty;\r\n                            tempwithdraw = tempwithdraw + tempamout;\r\n                            userStake[i].amount = userStake[i].amount - _amount;\r\n                            idoBalance[msg.sender] = idoBalance[msg.sender] - (_amount * idoMulti);\r\n                            IDO(address(idoToken)).burn(address(this), (_amount * idoMulti));\r\n                            if (userStake[i].amount == 0) {\r\n                                userStake[i].unstakecomp = true;\r\n                            }\r\n                            checkwithdraw = checkwithdraw + _amount;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        require(tempwithdraw \u003e 0, \"Nothing to unstake\");\r\n        if (unStakeFeePercent \u003e 0) {\r\n            uint256 fee = tempwithdraw * unStakeFeePercent / 100000000000000000000;\r\n            tempwithdraw = tempwithdraw - fee;\r\n            collectedFees = collectedFees + fee;\r\n        }\r\n        stakedToken.transfer(msg.sender, tempwithdraw);\r\n        Userstaked[msg.sender] = Userstaked[msg.sender] - _amount;\r\n        totalStaked = totalStaked - _amount;\r\n    }\r\n\r\n    // Internal function to know how much pending rewards are there\r\n    function pendingClaim(address _user) internal {\r\n        uint256 userStakedIn = 0;\r\n        uint256 claimReward = 0;\r\n        uint64 userStakedTime = 0;\r\n        userStakedIn = getStakeValue(msg.sender);  // We can use direct the userstaked mapping also\r\n        userStakedTime = getStakeTime(msg.sender);\r\n        uint256 currentTimeTemp = block.timestamp;\r\n        if (contractEnd \u003e block.timestamp) {\r\n            currentTimeTemp = 0;\r\n            currentTimeTemp = contractEnd;\r\n        }\r\n        uint temp = currentTimeTemp - userStakedTime; \r\n        claimReward = getRewardValue(userStakedIn) * temp;\r\n        pendingRewards[msg.sender] = claimReward + pendingRewards[msg.sender];\r\n        updateClaimed(msg.sender);\r\n    }\r\n\r\n    // For the user to know how much token can be unstake this is for the frontend\r\n    function getUnstake(address _user) public view returns (uint256) {\r\n        uint256 userStakeable = 0;\r\n        for(uint256 i = 0; i \u003c userStake.length; i++) {\r\n            if (userStake[i].user == _user \u0026\u0026 userStake[i].unstakecomp == false) {\r\n                if (userStake[i].stakeTime + userStake[i].lockedfor \u003c= block.timestamp) {\r\n                    userStakeable = userStakeable + userStake[i].amount;\r\n                }\r\n            }\r\n        }\r\n        return userStakeable;\r\n    }\r\n    // Internal function to the contract to know how much user has staked in\r\n    function getStakeValue(address _user) internal returns (uint256) {\r\n        uint256 userClaimable = 0;\r\n        for(uint256 i = 0; i \u003c userStake.length; i++) {\r\n            if (userStake[i].user == _user \u0026\u0026 userStake[i].unstakecomp == false) {\r\n                userClaimable = userClaimable + userStake[i].amount;\r\n            }\r\n        }\r\n        return userClaimable;\r\n    }\r\n   // Internal function to the contract to know at what time user as started the stake\r\n    function getStakeTime(address _user) internal returns (uint64) {\r\n        uint64 userTime = 0;\r\n        for(uint256 i = 0; i \u003c userStake.length; i++) {\r\n                if (userStake[i].user == _user \u0026\u0026 userStake[i].unstakecomp == false) {\r\n                    userTime = userStake[i].lastClaimed;\r\n                    if (userTime == 0) {\r\n                        i = userStake.length + 1;\r\n                    }\r\n                }\r\n        }\r\n        return userTime;\r\n    }\r\n    // Internal function to check valid user or no\r\n    function checkUserValid(address _user) internal returns (uint256) {\r\n        uint256 count = 0;\r\n            for(uint256 i = 0; i \u003c userStake.length; i++) {\r\n                if (userStake[i].user == _user \u0026\u0026 userStake[i].unstakecomp == false) {\r\n                    count = count + 1;\r\n                }\r\n            }\r\n        return count;\r\n    }\r\n    // Internal function which update the time when user has claimed so it help to the next calculation time period\r\n    function updateClaimed(address _user) internal {\r\n        for(uint256 i = 0; i \u003c userStake.length; i++) {\r\n            if (userStake[i].user == _user \u0026\u0026 userStake[i].unstakecomp == false) {\r\n                 userStake[i].lastClaimed = uint64(block.timestamp);\r\n            }\r\n        }\r\n    }\r\n\r\n    // User function to know how much token user has earn and can withdraw\r\n    function getClaim(address _user) public view returns(uint) {\r\n        uint256 userStakedIn = 0;\r\n        uint256 claimReward = 0;\r\n        uint64 userStakedTime = 0;\r\n        uint256 userClaimable = 0;\r\n        for(uint256 i = 0; i \u003c userStake.length; i++) {\r\n            if (userStake[i].user == _user \u0026\u0026 userStake[i].unstakecomp == false) {\r\n                userClaimable = userClaimable + userStake[i].amount;\r\n            }\r\n        }\r\n        userStakedIn = userClaimable;  // We can use direct the userstaked mapping also\r\n        uint64 userTime = 0;\r\n        for(uint256 i = 0; i \u003c userStake.length; i++) {\r\n                if (userStake[i].user == _user \u0026\u0026 userStake[i].unstakecomp == false) {\r\n                    userTime = userStake[i].lastClaimed;\r\n                    if (userTime == 0) {\r\n                        i = userStake.length + 1;\r\n                    }\r\n                }\r\n        }\r\n        userStakedTime = userTime;\r\n        uint256 currentTimeTemp = block.timestamp;\r\n        if (contractEnd \u003e block.timestamp) {\r\n            currentTimeTemp = 0;\r\n            currentTimeTemp = contractEnd;\r\n        }\r\n        uint temp = currentTimeTemp - userStakedTime; \r\n        uint256 reward = 0; \r\n        userStakedIn = userStakedIn / 1e18;\r\n        uint _feePercent = per * 1e18;\r\n        reward = userStakedIn * ((_feePercent / 31557600) / 100);\r\n        claimReward = reward * temp;\r\n        claimReward = claimReward + pendingRewards[_user];\r\n        return claimReward;\r\n    }\r\n\r\n    // For user to claim the reward and take it to his weallet\r\n    function claim() external {\r\n        uint256 userStakedIn = 0;\r\n        uint256 claimReward = 0;\r\n        uint256 rewardInContract = 0;\r\n        uint64 userStakedTime = 0;\r\n        userStakedIn = getStakeValue(msg.sender);  // We can use direct the userstaked mapping also\r\n        userStakedTime = getStakeTime(msg.sender);\r\n        uint256 currentTimeTemp = block.timestamp;\r\n        if (contractEnd \u003e block.timestamp) {\r\n            currentTimeTemp = 0;\r\n            currentTimeTemp = contractEnd;\r\n        }\r\n        uint temp = currentTimeTemp - userStakedTime; \r\n        claimReward = getRewardValue(userStakedIn) * temp;\r\n        claimReward = claimReward + pendingRewards[msg.sender];\r\n        require(claimReward != 0, \"No Rewards to Claim\");\r\n        uint256 rewardTokenBalance = rewardToken.balanceOf(address(this));\r\n        if (rewardToken == stakedToken){\r\n            rewardInContract = rewardTokenBalance - totalStaked;\r\n        }\r\n        require(rewardInContract \u003e= claimReward, \"INSUFFICIENT Token to Transfer\");\r\n        require(rewardToken.transfer(msg.sender, claimReward), \"Transfer Failed\");\r\n        updateClaimed(msg.sender);\r\n        pendingRewards[msg.sender] = 0;\r\n\r\n    }\r\n\r\n    // Internal function to know the per second APR to calculate\r\n    function getRewardValue(uint _amount) internal returns(uint256) {\r\n        uint256 reward = 0; \r\n        _amount = _amount / 1e18;\r\n        uint _feePercent = per * 1e18;\r\n        reward = _amount * ((_feePercent / 31557600) / 100);\r\n        return reward;\r\n    } \r\n\r\n    // User function where IDO token gets transfer to Launchpad\r\n    function transferIDOToken(uint256 _amount) external {\r\n        address _user = msg.sender;\r\n        require(checkUserValid(_user) != 0, \"Not a Valid User\");\r\n        require(idoBalance[_user] \u003e= _amount, \"Transfering more than you have\");\r\n        require(idoToken.transfer(launchpadAddress, _amount), \"Transfer failed\");\r\n        idoTransfer[_user] = idoTransfer[_user] + _amount;\r\n        idoBalance[_user] = idoBalance[_user] - _amount;\r\n        launchpad(launchpadAddress).updateIDOInfoLaunch(address(this), _user);\r\n    }\r\n\r\n    // Contract to contract updation\r\n    function updateIDOInfoStaking(address _user) external {\r\n        uint tempValueFun;\r\n        tempValueFun = launchpad(launchpadAddress).getIDOTransferredTemp(_user  );\r\n        idoTransfer[_user] = idoTransfer[_user] - tempValueFun;\r\n        idoBalance[_user] = idoBalance[_user] + tempValueFun;\r\n    }\r\n\r\n    // For user to know how much token has been transfered\r\n    function getIDOTransferred(address _user) external view returns (uint256) {\r\n        return idoTransfer[_user];\r\n    }\r\n\r\n\r\n    // ALl the Owner function Starts from here\r\n\r\n    function setAPR(uint256 _per) external onlyOwner {\r\n        require(_per != 0, \"APR can\u0027t set as ZERO\");\r\n        per = _per;\r\n    }\r\n\r\n    function setIDORatio(uint256 _idoratio) external onlyOwner {\r\n        idoMulti = _idoratio;\r\n    }\r\n\r\n    function changeRewardToken(IERC20 _rewardToken) external onlyOwner {\r\n        rewardToken = _rewardToken;\r\n    }\r\n\r\n    function updateLaunchpad(address _launchpadAddress) external onlyOwner {\r\n        launchpadAddress = _launchpadAddress;\r\n    }\r\n\r\n    function updateMax(uint _max) external onlyOwner {\r\n        maxStake = _max; \r\n    }\r\n\r\n    function updateMin(uint _min) external onlyOwner {\r\n        minStake = _min; \r\n    }\r\n\r\n    function updatePenaltyPercent(uint _penaltyPercent) external onlyOwner {\r\n        penaltyPercent = _penaltyPercent; \r\n    }\r\n\r\n    function setStakeFee(uint256 fee) external onlyOwner {\r\n        stakeFeePercent = fee;\r\n    }\r\n\r\n    function setUnstakeFee(uint256 fee) external onlyOwner {\r\n        unStakeFeePercent = fee;\r\n    }\r\n\r\n    function withdrawFees() external onlyOwner {\r\n        stakedToken.transfer(msg.sender, collectedFees);\r\n        collectedFees = 0;\r\n    }\r\n\r\n    function withdrawPenalty() external onlyOwner {\r\n        stakedToken.transfer(msg.sender, collectedPenalty);\r\n        collectedFees = 0;\r\n    }\r\n\r\n    function setContractEnd(uint256 _time) external onlyOwner {\r\n        contractEnd = _time;\r\n    }\r\n\r\n    function updateIDOTokenAddress(IERC20 _idoaddress) external onlyOwner {\r\n        idoToken = _idoaddress;\r\n    }\r\n\r\n}"},"idoToken.sol":{"content":"// SPDX-License-Identifier: Unlicensed\r\n// Date: 26-03-22\r\n\r\npragma solidity ^0.8.6;\r\nimport \"./ownable.sol\";\r\nimport \"./IERC20.sol\";\r\n\r\n// import \"@openzeppelin/contracts/utils/Context.sol\"\r\nabstract contract Context {\r\n\r\n    constructor () { }\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n\r\n        return payable(msg.sender);\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n\r\n        this;\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n        uint256 c = a + b;\r\n        require(c \u003e= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n\r\n        require(b \u003c= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n\r\n        require(b \u003e 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract ERC20 is Context, IERC20, Ownable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address =\u003e uint256) private _balances;\r\n\r\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n    uint256 private duration=0;\r\n    uint256 private lastrun;\r\n    bool public tokenLock = false;\r\n\r\n    constructor () {\r\n        lastrun=block.timestamp;\r\n    }\r\n\r\n    function totalSupply() public override view returns (uint256) {\r\n\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public override view returns (uint256) {\r\n\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public override view returns (uint256) {\r\n\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n\r\n        // require(isTransferable() == true);\r\n        // require(isblockperiod() == true);\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n      function _mint(address account, uint256 amount) internal {\r\n\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal {\r\n\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _burnFrom(address account, uint256 amount) internal {\r\n\r\n        _burn(account, amount);\r\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\r\n    }\r\n}\r\n\r\ncontract IDO is ERC20 {\r\n\r\n    string constant public name = \"IDOToken\";\r\n    string constant public symbol = \"IDO\";\r\n    uint8 constant public decimals = 18;\r\n    address[] public ownerAddress;\r\n\r\n    function onlyMinter(address _user) internal view returns(bool) {\r\n        bool isOwner = false;\r\n        for(uint256 i=0; i \u003c ownerAddress.length; i++) {\r\n            if(ownerAddress[i] == _user) {\r\n                isOwner = true;\r\n            }\r\n        }\r\n        return isOwner;\r\n    }\r\n    \r\n    function mint(address _to, uint256 _amount) public {\r\n        require(onlyMinter(msg.sender) == true , \"Ownable: caller is not the owner\");\r\n        _mint(_to, _amount);\r\n    }\r\n\r\n    function burn(address _to, uint256 _amount) public {\r\n        require(onlyMinter(msg.sender) == true , \"Ownable: caller is not the owner\");\r\n        _burn(_to, _amount);\r\n    }\r\n\r\n    function updateOwnerAddress(address _ownerAddress) external onlyOwner {\r\n        ownerAddress.push(_ownerAddress);\r\n    }\r\n}"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// Date: 26-03-22\r\n\r\npragma solidity ^0.8.10;\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"},"launchpad.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// Date: 26-03-22\r\npragma solidity ^0.8.10;\r\nimport \"./Fixed.sol\";\r\nimport \"./ownable.sol\";\r\nimport \"./IERC20.sol\";\r\nimport \"./idoToken.sol\";\r\n\r\n\r\ncontract launchpad is Ownable {\r\n    struct UserStake {\r\n        address user;\r\n        uint256 amount;\r\n        uint256 stakeTime;\r\n        uint256 lockedfor;\r\n        bool unstakecomp;\r\n        uint256 lastClaimed;\r\n    }\r\n    \r\n    UserStake[] userStake;  \r\n    address[] public transferBackIDOAddress;\r\n    uint256 public lockperiod = 3 minutes;\r\n    IERC20 public stakedToken;\r\n    IERC20 public rewardToken;\r\n    IERC20 public idoToken;\r\n    uint256 public totalStaked;\r\n    uint256 public aprPercent;\r\n    uint256 public minStake = 0;\r\n    uint256 public maxStake = 100000000000 * 1e18 * 1e18;\r\n    uint256 public idoMulti = 1;\r\n    uint256 public tier1 = 200000 * 1e18;\r\n    uint256 public tier2 = 500000 * 1e18;\r\n    uint256 public tier3 = 1000000 * 1e18;\r\n    uint256 public tierPercent1 = 12500000000000000000;\r\n    uint256 public tierPercent2 = 17500000000000000000;\r\n    uint256 public tierPercent3 = 22500000000000000000;\r\n    uint256 per;\r\n    uint256 public contractEnd;\r\n\r\n    // Fees and Penalty\r\n    uint256 public stakeFeePercent = 0;\r\n    uint256 public unStakeFeePercent = 0;\r\n    uint256 public collectedFees;\r\n    uint256 public collectedPenalty;\r\n    uint256 public penaltyPercent = 2500000000000000000;\r\n\r\n\r\n    \r\n    mapping(address =\u003e uint) public Userstaked;\r\n    mapping(address =\u003e uint) public idoBalance;\r\n    mapping(address =\u003e uint) public idoTransfer;\r\n    mapping(address =\u003e uint) public tierLevel;\r\n    mapping(address =\u003e uint) public tierPercent;\r\n    mapping(address =\u003e uint) public idoTransferTemp;\r\n    mapping(address =\u003e uint) public pendingRewards;\r\n    \r\n    constructor(IERC20 _rewardToken, IERC20 _stakedToken, IERC20 _idoToken) {\r\n        rewardToken = _rewardToken;\r\n        stakedToken = _stakedToken;\r\n        idoToken = _idoToken;\r\n    }\r\n\r\n\r\n    function stake(uint256 _amount) external {\r\n        if (contractEnd != 0) {\r\n            require(contractEnd \u003e block.timestamp, \"Staking has been Stop\" );\r\n        }\r\n        require(minStake \u003c _amount \u0026\u0026 maxStake \u003e= _amount, \"Could not stake this amount\");\r\n        if (stakeFeePercent \u003e 0) {\r\n            uint256 fee = _amount * stakeFeePercent / 100000000000000000000;\r\n            _amount = _amount - fee;\r\n            collectedFees = collectedFees + fee;\r\n        }\r\n        userStake.push(UserStake(msg.sender, _amount,uint256(block.timestamp),lockperiod, false, uint256(block.timestamp)));\r\n        stakedToken.transferFrom(msg.sender, address(this), _amount);\r\n        Userstaked[msg.sender] = Userstaked[msg.sender] + _amount;\r\n        idoBalance[msg.sender] = idoBalance[msg.sender] + (_amount * idoMulti);\r\n        IDO(address(idoToken)).mint(address(this), (_amount * idoMulti));\r\n        totalStaked = totalStaked + _amount;\r\n    }\r\n\r\n    function unStake(uint256 _amount) external {\r\n        require(checkUserValid(msg.sender) != 0, \"Not a Valid User\");\r\n        require(_amount \u003e 0, \"Can\u0027t Unstake 0\");\r\n        require(idoBalance[msg.sender] \u003e= (_amount * idoMulti), \"Unstake failed! User dont have SUFFICIENT IDO Token\");\r\n        require(checkUserValid(msg.sender) != 0, \"Not a Valid User\");\r\n        uint256 tempwithdraw = 0;\r\n        uint256 checkwithdraw = 0;\r\n        address _user = msg.sender;\r\n        pendingClaim(_user);\r\n        \r\n        for(uint256 i = 0; i \u003c userStake.length; i++) {\r\n            if (checkwithdraw \u003c _amount) {\r\n                if (userStake[i].user == _user \u0026\u0026 userStake[i].unstakecomp == false) {          \r\n                    if (userStake[i].stakeTime + userStake[i].lockedfor \u003c= block.timestamp) {           // Normal Unstake without Penalty\r\n                       if(userStake[i].amount \u003e= _amount) {\r\n                           tempwithdraw = tempwithdraw + _amount;\r\n                           userStake[i].amount = userStake[i].amount - _amount;\r\n                           idoBalance[msg.sender] = idoBalance[msg.sender] - (_amount * idoMulti); \r\n                           IDO(address(idoToken)).burn(address(this), (_amount * idoMulti));\r\n                           checkwithdraw = tempwithdraw;\r\n                           if (userStake[i].amount == 0) {\r\n                               userStake[i].unstakecomp = true;\r\n                           }\r\n                        }  \r\n                    } else {                                                            // This part of code get executed when user unstake before unlock\r\n                        if(userStake[i].amount \u003e= _amount) {\r\n                            // For the user with penalty for withdrwaing before unlock\r\n                            // amount 1000000000000000000000 * 2500000000000000000 / 100\r\n                            // 1000 * 2.5 / 100\r\n                            uint256 penalty = _amount * penaltyPercent / 100000000000000000000;\r\n                            collectedPenalty = collectedPenalty + penalty;\r\n                            uint256 tempamout = _amount - penalty;\r\n                            tempwithdraw = tempwithdraw + tempamout;\r\n                            userStake[i].amount = userStake[i].amount - _amount;\r\n                            idoBalance[msg.sender]       = idoBalance[msg.sender] - (_amount * idoMulti);\r\n                            IDO(address(idoToken)).burn(address(this), (_amount * idoMulti));\r\n                            if (userStake[i].amount == 0) {\r\n                                userStake[i].unstakecomp = true;\r\n                            }\r\n                            checkwithdraw = checkwithdraw + _amount;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        require(tempwithdraw \u003e 0, \"Nothing to unstake\");\r\n        if (unStakeFeePercent \u003e 0) {\r\n            uint256 fee = tempwithdraw * unStakeFeePercent / 100000000000000000000;\r\n            tempwithdraw = tempwithdraw - fee;\r\n            collectedFees = collectedFees + fee;\r\n        }\r\n        stakedToken.transfer(msg.sender, tempwithdraw);\r\n        Userstaked[msg.sender] = Userstaked[msg.sender] - _amount;\r\n        totalStaked = totalStaked - _amount;\r\n    }\r\n\r\n    function pendingClaim(address _user) internal {\r\n        uint256 userStakedIn = 0;\r\n        uint256 claimReward = 0;\r\n        uint256 userStakedTime = 0;\r\n        userStakedIn = getStakeValue(msg.sender);  // We can use direct the userstaked mapping also\r\n        userStakedTime = getStakeTime(msg.sender);\r\n        uint256 currentTimeTemp = block.timestamp;\r\n        if (contractEnd \u003e block.timestamp) {\r\n            currentTimeTemp = 0;\r\n            currentTimeTemp = contractEnd;\r\n        }\r\n        uint temp = currentTimeTemp - userStakedTime; \r\n        claimReward = getRewardValue(userStakedIn) * temp;\r\n        pendingRewards[msg.sender] = claimReward + pendingRewards[msg.sender];\r\n        updateClaimed(msg.sender);\r\n    }\r\n\r\n    function getUnstake(address _user) public view returns (uint256) {\r\n        uint256 userStakeable = 0;\r\n        for(uint256 i = 0; i \u003c userStake.length; i++) {\r\n            if (userStake[i].user == _user \u0026\u0026 userStake[i].unstakecomp == false) {\r\n                if (userStake[i].stakeTime + userStake[i].lockedfor \u003c= block.timestamp) {\r\n                    userStakeable = userStakeable + userStake[i].amount;\r\n                }\r\n            }\r\n        }\r\n        return userStakeable;\r\n    }\r\n\r\n    function getStakeValue(address _user) internal returns (uint256) {\r\n        uint256 userClaimable = 0;\r\n        for(uint256 i = 0; i \u003c userStake.length; i++) {\r\n            if (userStake[i].user == _user \u0026\u0026 userStake[i].unstakecomp == false) {\r\n                userClaimable = userClaimable + userStake[i].amount;\r\n            }\r\n        }\r\n        return userClaimable;\r\n    }\r\n    \r\n    function getStakeTime(address _user) internal returns (uint256) {\r\n        uint256 userTime = 0;\r\n        for(uint256 i = 0; i \u003c userStake.length; i++) {\r\n                if (userStake[i].user == _user \u0026\u0026 userStake[i].unstakecomp == false) {\r\n                    userTime = userStake[i].lastClaimed;\r\n                    if (userTime == 0) {\r\n                        i = userStake.length + 1;\r\n                    }\r\n                }\r\n        }\r\n        return userTime;\r\n    }\r\n\r\n    function checkUserValid(address _user) internal returns (uint256) {\r\n        uint256 count = 0;\r\n            for(uint256 i = 0; i \u003c userStake.length; i++) {\r\n                if (userStake[i].user == _user \u0026\u0026 userStake[i].unstakecomp == false) {\r\n                    count = count + 1;\r\n                }\r\n            }\r\n        return count;\r\n    }\r\n\r\n    function updateClaimed(address _user) internal {\r\n        for(uint256 i = 0; i \u003c userStake.length; i++) {\r\n            if (userStake[i].user == _user \u0026\u0026 userStake[i].unstakecomp == false) {\r\n                 userStake[i].lastClaimed = uint256(block.timestamp);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getClaim(address _user) public view returns(uint) {\r\n        uint256 userStakedIn = 0;\r\n        uint256 claimReward = 0;\r\n        uint256 userStakedTime = 0;\r\n        uint256 userClaimable = 0;\r\n        for(uint256 i = 0; i \u003c userStake.length; i++) {\r\n            if (userStake[i].user == _user \u0026\u0026 userStake[i].unstakecomp == false) {\r\n                userClaimable = userClaimable + userStake[i].amount;\r\n            }\r\n        }\r\n        userStakedIn = userClaimable;  // We can use direct the userstaked mapping also\r\n        uint256 userTime = 0;\r\n        for(uint256 i = 0; i \u003c userStake.length; i++) {\r\n                if (userStake[i].user == _user \u0026\u0026 userStake[i].unstakecomp == false) {\r\n                    userTime = userStake[i].lastClaimed;\r\n                    if (userTime == 0) {\r\n                        i = userStake.length + 1;\r\n                    }\r\n                }\r\n        }\r\n        userStakedTime = userTime;\r\n        // userStakedIn = getRewardValue(Userstaked[msg.sender]);\r\n        uint256 currentTimeTemp = block.timestamp;\r\n        if (contractEnd \u003e block.timestamp) {\r\n            currentTimeTemp = 0;\r\n            currentTimeTemp = contractEnd;\r\n        }\r\n        uint temp = currentTimeTemp - userStakedTime; \r\n        // require(userStakedIn != 0, \"No Rewards\");\r\n        uint256 reward = 0; \r\n        userStakedIn = userStakedIn / 1e18;\r\n        uint _feePercent = per * 1e18;\r\n        reward = userStakedIn * ((_feePercent / 31557600) / 100);\r\n        // return reward;\r\n        claimReward = reward * temp;\r\n        claimReward = claimReward + pendingRewards[_user];\r\n        return claimReward;\r\n    }\r\n\r\n    function claim() external {\r\n        uint256 userStakedIn = 0;\r\n        uint256 claimReward = 0;\r\n        uint256 rewardInContract = 0;\r\n        uint256 userStakedTime = 0;\r\n        userStakedIn = getStakeValue(msg.sender);  // We can use direct the userstaked mapping also\r\n        userStakedTime = getStakeTime(msg.sender);\r\n        // userStakedIn = getRewardValue(Userstaked[msg.sender]);\r\n        uint256 currentTimeTemp = block.timestamp;\r\n        if (contractEnd \u003e block.timestamp) {\r\n            currentTimeTemp = 0;\r\n            currentTimeTemp = contractEnd;\r\n        }\r\n        uint temp = currentTimeTemp - userStakedTime;\r\n        claimReward = getRewardValue(userStakedIn) * temp;\r\n        claimReward = claimReward + pendingRewards[msg.sender];\r\n        require(claimReward != 0, \"No Rewards to Claim\");\r\n        uint256 rewardTokenBalance = rewardToken.balanceOf(address(this));\r\n        if (rewardToken == stakedToken){\r\n            rewardInContract = rewardTokenBalance - totalStaked;\r\n        }\r\n        require(rewardInContract \u003e= claimReward, \"INSUFFICIENT Token to Transfer\");\r\n        require(rewardToken.transfer(msg.sender, claimReward), \"Transfer Failed\");\r\n        updateClaimed(msg.sender);\r\n        pendingRewards[msg.sender] = 0;\r\n\r\n\r\n    }\r\n\r\n    function getRewardValue(uint _amount) internal returns(uint256) {\r\n        // require(_amount != 0, \"No Rewards\");\r\n        uint256 reward = 0; \r\n        _amount = _amount / 1e18;\r\n        uint _feePercent = per * 1e18;\r\n        reward = _amount * ((_feePercent / 31557600) / 100);\r\n        return reward;\r\n    }\r\n\r\n    function transferIDOToken(uint256 _amount) external {\r\n        address _user = msg.sender;\r\n        require(checkUserValid(_user) != 0, \"Not a Valid User\");\r\n        require(idoBalance[_user] \u003e= _amount, \"Transfering more than you have\");\r\n        require(idoToken.transfer(address(this), _amount), \"Transfer failed\");\r\n        idoTransfer[_user] = idoTransfer[_user] + _amount;\r\n        idoBalance[_user] = idoBalance[_user] - (_amount);\r\n        updateTier(_user);\r\n        \r\n    }\r\n\r\n    function updateIDOInfoLaunch(address updateContract, address _user) external {\r\n        idoTransfer[_user] = idoTransfer[_user] + FixedStaking(updateContract).getIDOTransferred(_user);\r\n        updateTier(_user);\r\n    }\r\n\r\n    function transferBackIDOToken(uint256 _pool, uint256 _amount) external {\r\n        // uint256 backIDO = transferBackIDOAddress[_pool].getIDOTransfereds(msg.sender);  // for fetching token from staking contract\r\n        address _user = msg.sender;\r\n        require(idoTransfer[_user]\u003e= _amount, \"No sufficient tokens\");\r\n        if (transferBackIDOAddress[_pool] == address(this)) {\r\n            require(idoToken.transfer(transferBackIDOAddress[_pool], _amount), \"Transfer Failed\");\r\n            idoTransfer[_user] = idoTransfer[_user] - _amount;\r\n            idoBalance[_user] = idoBalance[_user] + (_amount);\r\n            updateTier(_user);\r\n        } else {\r\n            require(idoToken.transfer(transferBackIDOAddress[_pool], _amount), \"Transfer Failed\");\r\n            idoTransfer[_user] = idoTransfer[_user] - _amount;\r\n            idoTransferTemp[_user] = _amount;\r\n            FixedStaking(transferBackIDOAddress[_pool]).updateIDOInfoStaking(_user);\r\n            idoTransferTemp[_user] = 0;\r\n\r\n        }\r\n    }\r\n\r\n    function getIDOTransferredTemp(address _user) public view returns (uint256) {\r\n        return idoTransferTemp[_user];\r\n    }\r\n    function getTier(address _user) public view returns (uint256) {\r\n        uint256 count = 0;\r\n        if (idoTransfer[_user] \u003e= tier1) {\r\n            count = 1;\r\n        }\r\n        if (idoTransfer[_user] \u003e= tier2) {\r\n            count = 2;\r\n        }\r\n        if (idoTransfer[_user] \u003e= tier3) {\r\n            count = 3;\r\n        }\r\n        return count;\r\n    }\r\n\r\n    function updateTier(address _user) public {\r\n        if(idoTransfer[_user] \u003e= tier1) {\r\n            if (idoTransfer[_user] \u003e= tier1) {\r\n                tierLevel[_user] = tier1;\r\n                tierPercent[_user] = tierPercent1;\r\n            } \r\n            if (idoTransfer[_user] \u003e= tier2) {\r\n                tierLevel[_user] = tier2;\r\n                tierPercent[_user] = tierPercent2;\r\n            }\r\n            if (idoTransfer[_user] \u003e= tier3) {\r\n                tierLevel[_user] = tier3;\r\n                tierPercent[_user] = tierPercent3;\r\n            }\r\n        }\r\n    }\r\n    \r\n\r\n    function setAPR(uint256 _per) external onlyOwner {\r\n        require(_per != 0, \"APR can\u0027t set as ZERO\");\r\n        per = _per;\r\n        // aprPercent = _per * 12;\r\n    }\r\n\r\n    function setIDORatio(uint256 _idoratio) external onlyOwner {\r\n        require(_idoratio != 0, \"IDORatio can\u0027t set as ZERO\");\r\n        idoMulti = _idoratio;\r\n    }\r\n\r\n    function changeRewardToken(IERC20 _rewardToken) external onlyOwner {\r\n        rewardToken = _rewardToken;\r\n    } \r\n\r\n    function updateMax(uint _max) external onlyOwner {\r\n        maxStake = _max; \r\n    }\r\n\r\n    function updateMin(uint _min) external onlyOwner {\r\n        minStake = _min; \r\n    }\r\n    function updateTierValue1(uint _tier1) external onlyOwner {\r\n        tier1 = _tier1; \r\n    }\r\n    function updateTierValue2(uint _tier2) external onlyOwner {\r\n        tier2 = _tier2; \r\n    }\r\n    function updateTierValue3(uint _tier3) external onlyOwner {\r\n        tier3 = _tier3; \r\n    }\r\n    function updateTierPercent1(uint _tierPercent1) external onlyOwner {\r\n        tierPercent1 = _tierPercent1; \r\n    }\r\n    function updateTierPercent2(uint _tierPercent2) external onlyOwner {\r\n        tierPercent2 = _tierPercent2; \r\n    }\r\n    function updateTierPercent3(uint _tierPercent3) external onlyOwner {\r\n        tierPercent3 = _tierPercent3; \r\n    }\r\n\r\n    function updateTransferBackAddress(uint256 _poolId, address _pooladdress) external onlyOwner {\r\n        transferBackIDOAddress[_poolId] = _pooladdress;\r\n    }\r\n\r\n    function addTransferBackAddress(address _pooladdress) external onlyOwner {\r\n        transferBackIDOAddress.push(_pooladdress);\r\n    }\r\n\r\n    function updatePenaltyPercent(uint _penaltyPercent) external onlyOwner {\r\n        penaltyPercent = _penaltyPercent; \r\n    }\r\n\r\n    function setStakeFee(uint256 fee) external onlyOwner {\r\n        stakeFeePercent = fee;\r\n    }\r\n\r\n    function setUnstakeFee(uint256 fee) external onlyOwner {\r\n        unStakeFeePercent = fee;\r\n    }\r\n\r\n    function withdrawFees() external onlyOwner {\r\n        stakedToken.transfer(msg.sender, collectedFees);\r\n        collectedFees = 0;\r\n    }\r\n\r\n    function withdrawPenalty() external onlyOwner {\r\n        stakedToken.transfer(msg.sender, collectedPenalty);\r\n        collectedFees = 0;\r\n    }\r\n    function setContractEnd(uint256 _time) external onlyOwner {\r\n        contractEnd = _time;\r\n    }\r\n\r\n    function updateIDOTokenAddress(IERC20 _idoaddress) external onlyOwner {\r\n        idoToken = _idoaddress;\r\n    }\r\n\r\n\r\n}  "},"ownable.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// Date: 26-03-22\r\n\r\npragma solidity ^0.8.10;\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(owner, address(0));\r\n        owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}"},"presale.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// Date: 26-03-22\r\n\r\npragma solidity ^0.8.10;\r\nimport \"./IERC20.sol\";\r\nimport \"./launchpad.sol\";\r\nimport \"./ownable.sol\";\r\n\r\n\r\nlibrary SafeMath0 {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        uint256 c = a + b;\r\n        if (c \u003c a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b \u003e a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003c= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003e 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003e 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003c= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003e 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003e 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract presaleContract is Ownable {\r\n    using SafeMath0 for uint256;\r\n\r\n    address _owner;\r\n    address tokenOwner;\r\n    string public name;\r\n    string public tokenSymbol;\r\n    uint256 public totalSupply;\r\n    IERC20 public rewardToken;\r\n    IERC20 public buyToken;\r\n    uint256 public swapRate = 1 * 1e18;\r\n    uint256 public saleStart;\r\n    uint256 public saleEnd;\r\n    uint256 public TGETime;\r\n    uint256 public TGEUnlockPercent = 10 * 1e18;\r\n    uint256 public lockTime = 0;\r\n    uint256 public rewardDuration = 3 * 1e18;\r\n    uint256 public rewardUnlockTime = 1 * 1e18;\r\n    bool public useTiers = true;\r\n    address public launchpadAddress;\r\n    bool public useEmergencyWithdraw = false;\r\n\r\n    uint256 public minimumDepositeAmount = 100 * 1e18;  \r\n    \r\n    uint256 public maximumDepositeAmount = 100000  * 1e18; \r\n\r\n    uint256 public tier1Max = 1000000 * 1e18;\r\n    uint256 public tier1Min = 50000 * 1e18;    \r\n    uint256 public tier2Max = 2000000 * 1e18;\r\n    uint256 public tier2Min = 150000 * 1e18;    \r\n    uint256 public tier3Max = 3000000 * 1e18;\r\n    uint256 public tier3Min = 250000 * 1e18;\r\n\r\n    uint256 public totalInvested = 0;\r\n    uint256 public totalRewardTokens = 0;\r\n    uint256 public totalRewardTokensDeposited = 0;\r\n    uint256 public allocation = 0;\r\n\r\n    mapping(address =\u003e uint256) public userInvestment;\r\n    mapping(address =\u003e bool) public whitelisted;\r\n    mapping(address =\u003e uint256) lastClaimedTime;\r\n    mapping(address =\u003e uint256) totalClaimableAmount;\r\n    mapping(address =\u003e uint256) public totalClaimed;\r\n    mapping(address =\u003e bool) TGEClaimed;\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _tokenSymbol,\r\n        uint256 _totalSupply,\r\n        IERC20 _buyToken,\r\n        IERC20 _rewardToken,\r\n        address _tokenOwner,\r\n        uint256 _allocation,\r\n        uint256 _swapRate\r\n    ){\r\n        name = _name;\r\n        tokenSymbol = _tokenSymbol;\r\n        totalSupply = _totalSupply;\r\n        buyToken = _buyToken;\r\n        rewardToken = _rewardToken;\r\n        _owner = msg.sender;\r\n        tokenOwner = _tokenOwner;\r\n        allocation = _allocation;\r\n        swapRate = _swapRate;\r\n    }\r\n\r\n    function getMinMaxDepositeAmount(address _user) public view returns(uint256, uint256) {\r\n        uint256 _maximumDepositeAmount = maximumDepositeAmount;\r\n        uint256 _minimumDepositeAmount = minimumDepositeAmount;\r\n        if(useTiers){\r\n            uint256 userTier = launchpad(launchpadAddress).getTier(_user);\r\n            if(userTier == 1){\r\n                _maximumDepositeAmount = tier1Max;\r\n                _minimumDepositeAmount = tier1Min;\r\n            }\r\n            if(userTier == 2){\r\n                _maximumDepositeAmount = tier2Max;\r\n                _minimumDepositeAmount = tier2Min;\r\n            }\r\n            if(userTier == 3){\r\n                _maximumDepositeAmount = tier3Max;\r\n                _minimumDepositeAmount = tier3Min;\r\n            }\r\n            if(whitelisted[_user] \u0026\u0026 _maximumDepositeAmount \u003c tier2Max){\r\n                _maximumDepositeAmount = tier2Max;\r\n                _minimumDepositeAmount = tier2Min;\r\n            }\r\n        }\r\n        return (_maximumDepositeAmount,_minimumDepositeAmount);\r\n    }\r\n\r\n    function getAllocation() external view returns(uint256){\r\n        return (allocation * swapRate) / 1000000000000000000;\r\n    }\r\n\r\n    function getNextRewardUnlockDate(address _user) public view returns(uint256) {\r\n        uint256 currentTime = block.timestamp;\r\n        uint256 _lastClaimedTime = lastClaimedTime[_user];\r\n        if(currentTime \u003c TGETime){\r\n            return TGETime;\r\n        }else if(currentTime \u003e rewardDuration){\r\n            return currentTime;\r\n        }\r\n        uint256 otherRewardStartDate = TGETime + lockTime;\r\n        if(currentTime \u003c otherRewardStartDate){\r\n            if(TGEClaimed[_user]){\r\n                return otherRewardStartDate + rewardUnlockTime;\r\n            }else{\r\n                return currentTime;\r\n            }\r\n        }else{\r\n            if(_lastClaimedTime \u003c otherRewardStartDate){\r\n                _lastClaimedTime = otherRewardStartDate;\r\n            }\r\n            uint256 expectedNextRewardDate = _lastClaimedTime + rewardUnlockTime;\r\n            if(currentTime \u003c expectedNextRewardDate){\r\n                return expectedNextRewardDate;\r\n            }else{\r\n                return currentTime;\r\n            }\r\n        }\r\n    }\r\n\r\n    function emergencyWithdraw(address _user, uint256 _amount) public {\r\n        require(useEmergencyWithdraw==true, \"Emergency withdraw is not enabled\");\r\n        require(block.timestamp \u003c saleEnd, \"Sale is ended\");\r\n        require(userInvestment[_user] \u003e= _amount, \"Not enough tokens to withdraw\");\r\n        uint256 _rewardTokenGenerated = (_amount * 1000000000000000000) / swapRate;\r\n        totalRewardTokens -= _rewardTokenGenerated;\r\n        totalClaimableAmount[_user] -= _rewardTokenGenerated;\r\n        totalInvested -= _amount;\r\n        userInvestment[_user] -= _amount;\r\n        require(buyToken.transfer(_user, _amount), \"Transfer Failed\");\r\n    }\r\n\r\n    function depositeRewardToken(uint256 _amount) public {\r\n        require(msg.sender == tokenOwner, \"You need to be the owner of the token\");\r\n        totalRewardTokensDeposited += _amount;\r\n        require(rewardToken.transferFrom(tokenOwner,address(this), _amount), \"Transfer Failed\");\r\n    }\r\n\r\n    function withdrawRewardTokens(uint256 _amount) public{\r\n        require(msg.sender == tokenOwner, \"You need to be the owner of the token\");\r\n        require(block.timestamp \u003e saleEnd, \"Sale is not ended yet\");\r\n        uint256 withdrawableAmount = totalRewardTokensDeposited - totalRewardTokens;\r\n        require(withdrawableAmount \u003e= _amount, \"Not enough tokens to withdraw\");\r\n        totalRewardTokensDeposited -= _amount;\r\n        require(rewardToken.transfer(tokenOwner,_amount), \"Transfer Failed\");\r\n    }\r\n\r\n    function buy(uint256 _amount) public {\r\n        require(block.timestamp \u003e= saleStart, \"Presale is not started yet!\");\r\n        require(block.timestamp \u003c= saleEnd, \"Presale is ended!\");\r\n        address _user = msg.sender;\r\n        (uint256 _maxAmount,uint256 _minAmount) = getMinMaxDepositeAmount(_user);\r\n        uint256 _currentInvestment = userInvestment[_user];\r\n        require(_currentInvestment + _amount \u003c= _maxAmount, \"You can\u0027t deposite more than maximum amount\");\r\n        require(_currentInvestment + _amount \u003e= _minAmount, \"You can\u0027t deposite less than minimum amount\");\r\n        uint256 _rewardTokensgenerated = (_amount * 1000000000000000000) / swapRate;\r\n        require(_rewardTokensgenerated + totalRewardTokens \u003c= allocation, \"Max allocation limit is touched\");\r\n        totalInvested += _amount;\r\n        totalRewardTokens += _rewardTokensgenerated;\r\n        totalClaimableAmount[_user] += _rewardTokensgenerated;\r\n        userInvestment[_user] += _amount;\r\n        require(buyToken.transferFrom(address(_user), address(this), _amount), \"Transfer Failed\");\r\n    }\r\n\r\n    function claim() public payable {\r\n        address _user = msg.sender;\r\n        uint256 currentTime = block.timestamp;\r\n        require(currentTime \u003e= TGETime, \"Can\u0027t claim before TGE\");\r\n        uint256 _amount = 0;\r\n        uint256 _totalRewardTokens = totalClaimableAmount[_user];\r\n        require(totalClaimed[_user] \u003c _totalRewardTokens, \"Nothing to claim\");\r\n        if(currentTime \u003e rewardDuration){\r\n            _amount = _totalRewardTokens - totalClaimed[_user];\r\n        }else{\r\n            uint256 _lockTime = TGETime + lockTime;\r\n            if(!TGEClaimed[_user]){\r\n                _amount += (_totalRewardTokens * TGEUnlockPercent) / 100000000000000000000;\r\n                TGEClaimed[_user] = true;\r\n            }\r\n            if(lastClaimedTime[_user] \u003c _lockTime){\r\n                lastClaimedTime[_user] = _lockTime;\r\n            }\r\n            if(currentTime \u003e _lockTime){\r\n                uint256 timeElapsed = currentTime - lastClaimedTime[_user];\r\n                uint256 totalRewardDurationInDays = rewardDuration - _lockTime;\r\n                uint256 _rewardUnlockPercent = (rewardUnlockTime * (100 * 1e18 - TGEUnlockPercent)) / (totalRewardDurationInDays);\r\n                uint256 _claimablePercent = (timeElapsed / rewardUnlockTime) * _rewardUnlockPercent;   \r\n                _amount += (_totalRewardTokens * _claimablePercent) / 100000000000000000000;\r\n                lastClaimedTime[_user] = lastClaimedTime[_user] + (timeElapsed - (timeElapsed % rewardUnlockTime));   \r\n            }\r\n            if(_amount + totalClaimed[_user] \u003e _totalRewardTokens){\r\n                _amount = _totalRewardTokens - totalClaimed[_user];\r\n            }\r\n        }\r\n        totalClaimed[_user] += _amount;\r\n        totalRewardTokens -= _amount;\r\n        rewardToken.transfer(_user, _amount);\r\n    }\r\n\r\n    function getUnlockTime() external view returns(uint256){\r\n        return (TGETime + lockTime);\r\n    }\r\n    \r\n    function getClaimableAmount(address _user) external view returns(uint256) {\r\n        uint256 currentTime = block.timestamp;\r\n        require(currentTime \u003e= TGETime, \"Can\u0027t claim before TGE\");\r\n        uint256 _amount = 0;\r\n        uint256 _totalRewardTokens = totalClaimableAmount[_user];\r\n        if(totalClaimed[_user] \u003e= _totalRewardTokens){\r\n            return _amount;\r\n        }\r\n        if(currentTime \u003e rewardDuration){\r\n            _amount = _totalRewardTokens - totalClaimed[_user];\r\n        }else{\r\n            uint256 _lockTime = TGETime + lockTime;\r\n            uint256 lastClaimed = lastClaimedTime[_user];\r\n            if(!TGEClaimed[_user]){\r\n                _amount += (_totalRewardTokens * TGEUnlockPercent) / 100000000000000000000;\r\n            }\r\n            if(lastClaimed \u003c _lockTime){\r\n                lastClaimed = _lockTime;\r\n            }\r\n            if(currentTime \u003e _lockTime){\r\n                uint256 timeElapsed = currentTime - lastClaimed;\r\n                uint256 totalRewardDurationInDays = rewardDuration - _lockTime;\r\n                uint256 _rewardUnlockPercent = (rewardUnlockTime * (100 * 1e18 - TGEUnlockPercent)) / (totalRewardDurationInDays);\r\n                uint256 _claimablePercent = (timeElapsed / rewardUnlockTime) * _rewardUnlockPercent;   \r\n                _amount += (_totalRewardTokens * _claimablePercent) / 100000000000000000000;\r\n            }\r\n            if(_amount + totalClaimed[_user] \u003e _totalRewardTokens){\r\n                _amount = _totalRewardTokens - totalClaimed[_user];\r\n            }\r\n        }\r\n        return _amount;\r\n    }\r\n\r\n    function getRewardBalance(address _user) external view returns(uint256) {\r\n        return totalClaimableAmount[_user] - totalClaimed[_user];\r\n    }\r\n\r\n    function withdrawAmount(uint256 _amount) external onlyOwner{\r\n        require(totalInvested \u003e= _amount, \"Insuffcient tokens in the contract\");\r\n        require(buyToken.transfer(owner, _amount), \"Transfer Failed\");\r\n        totalInvested -= _amount;\r\n    }\r\n\r\n    function setSaleStart(uint256 _saleStart) external onlyOwner {\r\n        saleStart = _saleStart;\r\n    }\r\n\r\n    function setSaleEnd(uint256 _saleEnd) external onlyOwner {\r\n        saleEnd = _saleEnd;\r\n    }\r\n\r\n    function setTGETime(uint256 _TGETime) external onlyOwner {\r\n        require(_TGETime \u003e saleEnd \u0026\u0026 saleEnd!=0, \"TGE can\u0027t be before end time\");\r\n        TGETime = _TGETime;\r\n    }\r\n\r\n    function setTGEUnlockPercent(uint256 _TGEUnlockPercent) external onlyOwner {\r\n        TGEUnlockPercent = _TGEUnlockPercent;\r\n    }\r\n\r\n    function setLockTime(uint256 _lockTime) external onlyOwner {\r\n        lockTime = _lockTime;\r\n    }\r\n\r\n    function setRewardDuration(uint256 _rewardDuration) external onlyOwner {\r\n        require(TGETime != 0, \"TGE Time is not set\");\r\n        require(_rewardDuration \u003e TGETime, \"Can\u0027t be before TGE Time\");\r\n        rewardDuration = _rewardDuration;\r\n    }\r\n\r\n    function setRewardUnlockTime(uint256 _rewardUnlockTime) external onlyOwner {\r\n        rewardUnlockTime = _rewardUnlockTime;\r\n    }\r\n\r\n    function updateUseTiers(bool _useTiers) external onlyOwner {\r\n        useTiers = _useTiers;\r\n    }\r\n\r\n    function updatEmergencyWithdraw(bool _emergencyWithdraw) external onlyOwner {\r\n        useEmergencyWithdraw = _emergencyWithdraw;\r\n    }\r\n\r\n    function updateLaunchpadAddress(address _launchpadAddress) external onlyOwner {\r\n        launchpadAddress = _launchpadAddress;\r\n    }\r\n\r\n    function updateMinimumDepositeAmount(uint256 _minimumDepositeAmount) external onlyOwner {\r\n        minimumDepositeAmount = _minimumDepositeAmount;\r\n    } \r\n\r\n    function updateMaximumDepositeAmount(uint256 _maximumDepositeAmount) external onlyOwner {\r\n        maximumDepositeAmount = _maximumDepositeAmount;\r\n    }\r\n\r\n    function updateTier1Max(uint256 _tier1Max) external onlyOwner {\r\n        tier1Max = _tier1Max;   \r\n    }\r\n\r\n    function updateTier2Max(uint256 _tier2Max) external onlyOwner {\r\n        tier2Max = _tier2Max;\r\n    }\r\n\r\n    function updateTier3Max(uint256 _tier3Max) external onlyOwner {\r\n        tier3Max = _tier3Max;\r\n    }\r\n\r\n    function updateTier1Min(uint256 _tier1Min) external onlyOwner {\r\n        tier1Min = _tier1Min;\r\n    }\r\n\r\n    function updateTier2Min(uint256 _tier2Min) external onlyOwner {\r\n        tier2Min = _tier2Min;\r\n    }\r\n\r\n    function updateTier3Min(uint256 _tier3Min) external onlyOwner {\r\n        tier3Min = _tier3Min;\r\n    }\r\n\r\n    function whitelistUser(address _user) external onlyOwner {\r\n        whitelisted[_user] = true;\r\n    }\r\n\r\n\r\n}"}}