{"IERC20.sol":{"content":"//SPDX-License-Identifier: UNLICENSED\n\npragma solidity \u003e=0.5.0;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n"},"IMasterChef.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\npragma experimental ABIEncoderV2;\n// \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\n\ninterface IMasterChef {\n    //using BoringERC20 for IERC20;\n   /* struct UserInfo {\n        uint256 amount;     // How many LP tokens the user has provided.\n        uint256 rewardDebt; // Reward debt. See explanation below.\n    }*/\n\n    struct UserInfo {\n        uint256 amount;\n        uint256 rewardDebt;\n        uint256 boostMultiplier;\n    }\n    \n    //mapping(uint256 =\u003e mapping(address =\u003e UserInfo)) public userInfo;\n\n  /*  struct PoolInfo {\n        IERC20 lpToken;           // Address of LP token contract.\n        uint256 allocPoint;       // How many allocation points assigned to this pool. SUSHI to distribute per block.\n        uint256 lastRewardBlock;  // Last block number that SUSHI distribution occurs.\n        uint256 accSushiPerShare; // Accumulated SUSHI per share, times 1e12. See below.\n    }*/\n\n    //function poolInfo(uint256 pid) external view returns (IMasterChef.PoolInfo memory);\n    //function userInfo(uint256 pid, address user) external view returns (IMasterChef.UserInfo memory);\n    function totalAllocPoint() external view returns (uint256);\n    function deposit(uint256 _pid, uint256 _amount) external;\n    function pendingCake(uint256 _pid, address _user) external view returns (uint256);\n    function emergencyWithdraw(uint256 _pid) external;\n    function withdraw(uint256 _pid, uint256 _amount) external;\n}"},"IPancakePair.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity \u003e=0.5.0;\n\ninterface IPancakePair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"},"IUniswapV2Factory.sol":{"content":"//SPDX-License-Identifier: UNLICENSED\n\npragma solidity \u003e=0.5.0;\n\ninterface IUniswapV2Factory {\n  event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\n  function allPairs(uint) external view returns (address pair);\n  function allPairsLength() external view returns (uint);\n  function feeTo() external view returns (address);\n  function feeToSetter() external view returns (address);\n  function createPair(address tokenA, address tokenB) external returns (address pair);\n}\n"},"IUniswapV2Router01.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity \u003e=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"},"IUniswapV2Router02.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity \u003e=0.6.2;\n\nimport \u0027./IUniswapV2Router01.sol\u0027;\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c \u003c a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b \u003e a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n            // benefit is lost if \u0027b\u0027 is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003c= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003e 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003e 0, errorMessage);\n            return a % b;\n        }\n    }\n}"},"ssCmp.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\n\nimport \u0027./IUniswapV2Router02.sol\u0027;\nimport \u0027./IUniswapV2Factory.sol\u0027;\nimport \u0027./IERC20.sol\u0027;\nimport \u0027./IPancakePair.sol\u0027;\nimport \u0027./IMasterChef.sol\u0027;\nimport \u0027./SafeMath.sol\u0027;\n\ncontract ssCompounder{\n    //O.Z. math lib\n    using SafeMath for uint256;\n    ///////////////////////////////////////////////////////////////////\n    ////////////////// Contract data //////////////////////////////////\n    ///////////////////////////////////////////////////////////////////\n    string  public  name       = \"ss-Compounder v.0.1.0\";\n    uint256 public  dev_fee    = 6;\n    address payable dev_marketing;\n    uint256         fees_collected    = 0;\n    uint256 public  AutoCompoundTimer = 0;\n    //Time between compounds\n    uint256         AUTO_TIMER = 15 minutes;\n    uint256 public  lpPid      = 108;\n    //Total Bnb contract has received (never decreases)\n    uint256 public totalBnb    = 0;\n    //Total LP over time. Decreases when users withdraw their funds\n    uint256 public totalLp     = 0;\n    //Future change LP \u0026 Farm\n    bool public freezeBuyin    = false;\n\n    struct Staking{\n        address tokenAddress;\n        string tokenName;\n    }\n    Staking[2] public stakeInfo;\n    IERC20 public tokenInstance0;\n    IERC20 public tokenInstance1;\n    //\n    address public pancakeRouterAddress;\n    IUniswapV2Router02 pancakeRouter;\n    //\n    address public pancakeMasterChefAddress;\n    IMasterChef pancakeMasterChef;\n    //\n    address public pancakePairAddress;\n    IPancakePair pancakePair;\n    //rewards are in cake\n    address cakeTokenAddress = 0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82;\n    IERC20 cakeTokenInstance;\n    //\n    ///////////////////////////////////////////////////////////////////\n    ///////////// Ownership data in order of usage ////////////////////\n    ///////////////////////////////////////////////////////////////////\n    //Token 0 \u0026 1 count on a single deposit, is always reset to 0\n    mapping(address =\u003e uint256) lpToken0Purchased; \n    mapping(address =\u003e uint256) lpToken1Purchased;\n    //Total Token 0 \u0026 1 total counter\n    mapping(address =\u003e uint256) public lpToken0Staked;\n    mapping(address =\u003e uint256) public lpToken1Staked;\n    //Liquidity Pool Token count on a single deposit, is always reset to 0\n    mapping(address =\u003e uint256) lpPurchased;\n    //Liquidity Pool Token total counter.\n    mapping(address =\u003e uint256) public lpPurchasedInFarm;\n    //User time between harvests\n    mapping(address =\u003e uint256) public userHarvestTimer;\n    \n    ///////////////////////////////////////////////////////////////////\n    //////////////////////// Event data ///////////////////////////////\n    ///////////////////////////////////////////////////////////////////\n    event BuyAndStakeAndFarm(address);\n    event NormalHarvest(address, uint256);\n    event CompoundedHarvest(address, uint256);\n    event WithdrawAll(address);\n    event AutoHarvesting();\n    \n    ///////////////////////////////////////////////////////////////////\n    ///////////// constructor data  ///////////////////////////////////\n    ///////////////////////////////////////////////////////////////////\n    constructor(){\n        //switch tokens to high apy pancake tokens\n        dev_marketing = payable(msg.sender);\n        \n        cakeTokenInstance = IERC20(cakeTokenAddress);\n        //Staking token 0\n        stakeInfo[0].tokenAddress  = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\n        stakeInfo[0].tokenName     = \"BUSD\";\n        tokenInstance0             = IERC20(stakeInfo[0].tokenAddress);\n        //Staking token 1\n        stakeInfo[1].tokenAddress  = 0xa865197A84E780957422237B5D152772654341F3;\n        stakeInfo[1].tokenName     = \"OLE\";\n        tokenInstance1             = IERC20(stakeInfo[1].tokenAddress);\n        //router for swapping tokens, adding \u0026 removing liquidity\n        pancakeRouterAddress       = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\n        pancakeRouter              = IUniswapV2Router02(pancakeRouterAddress);\n        //MasterChef for depositing \u0026 withdrawing LP\u0027s to farm\n        pancakeMasterChefAddress   = 0xa5f8C5Dbd5F286960b9d90548680aE5ebFf07652;\n        pancakeMasterChef          = IMasterChef(pancakeMasterChefAddress);\n        //pair address \n        pancakePairAddress         = 0xe9F369298565B60a0DC19A6fA93cEE934Fd1A58c;\n        pancakePair                = IPancakePair(pancakePairAddress); \n    }\n\n    ///////////////////////////////////////////////////////////////////\n    ///////////// read functions  /////////////////////////////////////\n    ///////////////////////////////////////////////////////////////////\n    function devFee(uint256 amount) private view returns(uint256) {\n        return SafeMath.div(SafeMath.mul(amount,dev_fee),100);\n    }\n\n    function pendingContractRewards() public view returns(uint256) {\n        uint256 reward = pancakeMasterChef.pendingCake(lpPid,address(this));\n        return reward;\n    }\n\n    function contractCakeBalance() public view returns(uint256) {\n        uint256 bal = cakeTokenInstance.balanceOf(address(this));\n        return bal;\n    }\n    ///////////////////////////////////////////////////////////////////\n    ///////////// Reward Calculators //////////////////////////////////\n    ///////////////////////////////////////////////////////////////////\n    \n    function readyUserRewards(address account) public view returns(uint256) {\n        uint256 reward = contractCakeBalance();\n        uint256 userReward = SafeMath.div(SafeMath.mul(reward,lpPurchasedInFarm[account]),totalLp);\n        return userReward;\n    }\n\n   function pendingUserRewards(address account) public view returns(uint256) {\n        uint256 reward = pendingContractRewards();\n        uint256 userReward = SafeMath.div(SafeMath.mul(reward,lpPurchasedInFarm[account]),totalLp);\n        return userReward;\n    }\n    \n    ///////////////////////////////////////////////////////////////////\n    ///////////// buy in functions  ///////////////////////////////////\n    ///////////////////////////////////////////////////////////////////\n    function BuyStakeFarm() public payable{\n        userHarvestTimer[msg.sender] = block.timestamp + AUTO_TIMER;\n        BuyLpTokens();\n        Stake();\n        Farm();\n        emit BuyAndStakeAndFarm(msg.sender);\n    }\n\n    // swap bnb for near equal amounts of the 2 LP\u0027s\n    function BuyLpTokens() public payable{\n        require(freezeBuyin == false, \"Buy in Froze. Pls cash out if you have invested.\");\n        require(msg.value \u003e= 0.001 ether, \"Minimum is 0.001 bnb\");\n        //set contract timer on first buy in.\n        if (totalBnb == 0)\n            {\n            AutoCompoundTimer = block.timestamp + AUTO_TIMER;\n            }\n        totalBnb += msg.value;\n        uint fee = devFee(msg.value);\n        uint deadline = block.timestamp + 10 minutes;\n        uint256 amountToSwap = SafeMath.sub(msg.value,fee);\n        uint256 amountInSwap = SafeMath.div(amountToSwap,2); \n        //token route\n        address[] memory path;\n        path = new address[](2);\n        path[0] = pancakeRouter.WETH();\n        path[1] = stakeInfo[0].tokenAddress;\n        uint256 [] memory amountOutMin = pancakeRouter.getAmountsOut(amountInSwap,path);\n        uint256 [] memory amountOut = pancakeRouter.swapExactETHForTokens{value: amountInSwap}(amountOutMin[1], path, address(this), deadline);\n        //tracks users deposits\n        lpToken0Purchased[msg.sender] = amountOut[1];\n        //second lp\n        path[1] = stakeInfo[1].tokenAddress;\n        amountOutMin = pancakeRouter.getAmountsOut(amountInSwap,path);\n        amountOut = pancakeRouter.swapExactETHForTokens{value: amountInSwap}(amountOutMin[1], path, address(this), deadline);\n        //\n        lpToken1Purchased[msg.sender] = amountOut[1];\n        (bool success,) = dev_marketing.call{value : fee}(\"\");\n        require(success, \"failed to send bnb\");\n        fees_collected += fee;\n    }\n\n    // staked the senders amount of each token in the liquidity pool\n    function Stake() public {\n        uint256 token0amount = lpToken0Purchased[msg.sender];\n        uint256 token1amount = lpToken1Purchased[msg.sender];\n        lpToken0Purchased[msg.sender] = 0;\n        lpToken1Purchased[msg.sender] = 0;\n        // approve tokens to be transfered by router\n        tokenInstance0.approve(pancakeRouterAddress, token0amount);\n        tokenInstance1.approve(pancakeRouterAddress, token1amount);\n        uint deadline = block.timestamp + 10 minutes;\n        (uint256 amountA, uint256 amountB, uint256 liquidity) = pancakeRouter.addLiquidity(stakeInfo[0].tokenAddress,stakeInfo[1].tokenAddress, token0amount, token1amount, 1, 1, address(this), deadline);\n        //ownership of LP \n        totalLp += liquidity;\n        lpToken0Staked[msg.sender] += amountA;\n        lpToken1Staked[msg.sender] += amountB;\n        lpPurchased[msg.sender] = liquidity;\n    }\n\n    function Farm() public {\n        //approve LP to be transfered by the Farm\n        uint256 toFarmAmount = lpPurchased[msg.sender];\n        lpPurchased[msg.sender] = 0;\n        pancakePair.approve(pancakeMasterChefAddress,toFarmAmount);\n        pancakeMasterChef.deposit(lpPid,toFarmAmount);\n        //\n        lpPurchasedInFarm[msg.sender] += toFarmAmount;\n    }\n    ///////////////////////////////////////////////////////////////////\n    //// Exit contract functions, Send token share to user  ///////////\n    ////////////////////////////////////////////////////////////////////\n    function withdrawLps() public {\n        withdrawLpFromFarm();\n        withdrawfromLp();\n        //dev/marketing fee\n        uint256 fee0 = devFee(lpToken0Staked[msg.sender]);\n        uint256 fee1 = devFee(lpToken1Staked[msg.sender]);\n        uint256 out0 = SafeMath.sub(lpToken0Staked[msg.sender], fee0);\n        uint256 out1 = SafeMath.sub(lpToken1Staked[msg.sender], fee1);\n        //ownership deleted\n        lpToken0Staked[msg.sender] = 0;\n        lpToken1Staked[msg.sender] = 0;\n        //fee\n        tokenInstance0.transfer(dev_marketing, fee0);\n        tokenInstance1.transfer(dev_marketing, fee1);\n        //send the rest of the tokens\n        tokenInstance0.transfer(msg.sender, out0);\n        tokenInstance1.transfer(msg.sender, out1);\n        //\n        emit WithdrawAll(msg.sender);\n    }\n    \n    //v1 ready exit farm\n    function withdrawLpFromFarm() public {\n        require(lpPurchasedInFarm[msg.sender] \u003e 0, \"You have not provided LPT\u0027s\");\n        pancakeMasterChef.withdraw(lpPid,lpPurchasedInFarm[msg.sender]);\n    }\n\n    //v1 ready exit lp\n    function withdrawfromLp() public {\n        require(lpPurchasedInFarm[msg.sender] \u003e 0, \"You have not provided LPT\u0027s\");\n        uint deadline = block.timestamp + 10 minutes;\n        uint256 fromLp = lpPurchasedInFarm[msg.sender];\n        totalLp -= fromLp;\n        lpPurchasedInFarm[msg.sender] = 0;\n        //approve lp to be burned by router\n        pancakePair.approve(pancakeRouterAddress,fromLp);\n        (uint amountA, uint amountB) = pancakeRouter.removeLiquidity(stakeInfo[0].tokenAddress,stakeInfo[1].tokenAddress, fromLp,1,1, address(this), deadline);\n        lpToken0Staked[msg.sender] = amountA;\n        lpToken1Staked[msg.sender] = amountB;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    /////////////////////////Harvest types /////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////////////////\n    function compoundHarvest() public {\n        require(pendingUserRewards(msg.sender) \u003e 0 || readyUserRewards(msg.sender) \u003e 0, \"No rewards ATM\");\n        require(block.timestamp \u003e userHarvestTimer[msg.sender], \"Wait to harvest\");\n        userHarvestTimer[msg.sender] = block.timestamp + AUTO_TIMER;\n        //check if its time for rewards. \n        if (block.timestamp \u003e AutoCompoundTimer ){\n            pancakeMasterChef.deposit(lpPid,0);\n            AutoCompoundTimer = block.timestamp + AUTO_TIMER;\n        }\n        require(cakeTokenInstance.balanceOf(address(this)) \u003e readyUserRewards(msg.sender), \"Contract insuffcient funds\");\n        //approve router to swap\n        cakeTokenInstance.approve(pancakeRouterAddress,readyUserRewards(msg.sender));\n        uint deadline = block.timestamp + 10 minutes;\n        uint256 amountToSwap = readyUserRewards(msg.sender);\n        uint256 amountInSwap = SafeMath.div(amountToSwap,2); \n        //token route\n        address[] memory path;\n        path = new address[](2);\n        path[0] = cakeTokenAddress;\n        path[1] = stakeInfo[0].tokenAddress;\n        uint256 [] memory amountOutMin = pancakeRouter.getAmountsOut(amountInSwap,path);\n        uint256 [] memory amountOut = pancakeRouter.swapExactTokensForTokens(amountInSwap,amountOutMin[1], path, address(this), deadline);\n        lpToken0Purchased[msg.sender] = amountOut[1];\n        //second lp\n        path[1] = stakeInfo[1].tokenAddress;\n        amountOutMin = pancakeRouter.getAmountsOut(amountInSwap,path);\n        amountOut = pancakeRouter.swapExactTokensForTokens(amountInSwap,amountOutMin[1], path, address(this), deadline);\n        lpToken1Purchased[msg.sender] = amountOut[1];\n        //LP\u0027s are here -\u003e call stake and farm next\n        Stake();\n        Farm();\n        emit CompoundedHarvest(msg.sender, lpPurchased[msg.sender]);\n    }\n    \n    //harvest can be done every x hours\n    function HarvestComplex() public {\n        require(pendingUserRewards(msg.sender) \u003e 0 || readyUserRewards(msg.sender) \u003e 0, \"No rewards ATM\");\n        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n        require(block.timestamp \u003e userHarvestTimer[msg.sender], \"Wait to harvest\");\n        userHarvestTimer[msg.sender] = block.timestamp + AUTO_TIMER;\n        //check if its time for rewards. Only the first user to compound (every 12 hours) will auto run it\n        if (block.timestamp \u003e AutoCompoundTimer ){\n            AutoCompoundTimer = block.timestamp + AUTO_TIMER;\n            pancakeMasterChef.deposit(lpPid,0);\n        }\n        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n        require(cakeTokenInstance.balanceOf(address(this)) \u003e readyUserRewards(msg.sender), \"Contract insuffcient funds\");\n        cakeTokenInstance.transfer(msg.sender,readyUserRewards(msg.sender));\n        //\n        emit NormalHarvest(msg.sender, readyUserRewards(msg.sender));\n    }\n\n    function HarvestBasic() public {\n        require(block.timestamp \u003e userHarvestTimer[msg.sender], \"Wait to harvest\");\n        require(readyUserRewards(msg.sender) \u003e 0, \"No rewards ATM\");\n        require(cakeTokenInstance.balanceOf(address(this)) \u003e readyUserRewards(msg.sender), \"Contract insuffcient funds\");\n        userHarvestTimer[msg.sender] = block.timestamp + AUTO_TIMER;\n        //\n        cakeTokenInstance.transfer(msg.sender,readyUserRewards(msg.sender));\n        emit NormalHarvest(msg.sender, readyUserRewards(msg.sender));\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    //////////////// Hopeful for v1 works with HarvestBasic ////////////////////////\n    //////////////////////////////////////////////////////////////////////////////// \n    //we are working to run a server to automate this function, saving users on gas. \n    //For now harvestcomplex takes care of this\n    function AutoHarvest() public {\n        require(msg.sender == dev_marketing, \"Only admin can autoharvest\");\n        pancakeMasterChef.deposit(lpPid,0);\n        AutoCompoundTimer = AutoCompoundTimer + AUTO_TIMER;\n        emit AutoHarvesting();\n    }\n\n    //Only for if funds get locked, bnb and tokens shouldn;t remain in the contract, as it should always be swapped for lps and farmed.\n    //Ex: Pennies worth may remain when addLiquity is called taking equvalent value amounts. \n    //These funds will be redistributed to holders at random.\n    function RemoveBnb(uint256 amount) public {\n        require(msg.sender == dev_marketing, \"Admin only\");\n        (bool success,) = dev_marketing.call{value : amount}(\"\");\n        require(success, \"failed to send bnb\");\n    }\n    function RemoveToken0(address account, uint256 amount) public {\n        require(msg.sender == dev_marketing, \"Admin only\");\n        tokenInstance0.transfer(account,amount);\n    }\n    function RemoveToken1(address account, uint256 amount) public {\n        require(msg.sender == dev_marketing, \"Admin only\");\n        tokenInstance1.transfer(account,amount);\n    }\n    function RemovePancake(address account, uint256 amount) public {\n        require(msg.sender == dev_marketing, \"Admin only\");\n        cakeTokenInstance.transfer(account,amount);\n    }\n    ////////////////////////////////////////////////////////////////////////////////\n    ////////////////// Future looking functions ////////////////////////////////////\n    //////////////////////////////////////////////////////////////////////////////// \n    function ChangeHarvestTimer(uint256 timer) public {\n        require(msg.sender == dev_marketing, \"Admin only\");\n        AUTO_TIMER = timer;   \n    } \n    function FreezeBuyIn() public {\n        require(msg.sender == dev_marketing, \"Admin only\");\n        freezeBuyin = true;\n    }\n    function unFreezeBuyIn() public {\n        require(msg.sender == dev_marketing, \"Admin only\");\n        freezeBuyin = false;\n    }\n    // Ability to change Farm.\n    function ChangeLp(address token0, address token1, address pair, uint256 pid) public {\n        require(msg.sender == dev_marketing, \"Admin only\");\n        require(freezeBuyin == true, \"Buy in must be frozen prior\");\n        stakeInfo[0].tokenAddress  = token0;\n        tokenInstance0             = IERC20(stakeInfo[0].tokenAddress);\n        stakeInfo[0].tokenName     = tokenInstance0.name();\n        //\n        stakeInfo[1].tokenAddress  = token1;\n        tokenInstance1             = IERC20(stakeInfo[1].tokenAddress);\n        stakeInfo[1].tokenName     = tokenInstance1.name();\n        //\n        pancakePairAddress         = pair;\n        pancakePair                = IPancakePair(pancakePairAddress); \n        //\n        lpPid = pid;\n    }\n\n}"}}