/**
https://gempad.app/ V3 LOCKER BETA
*/

//SPDX-License-Identifier: UNLICENSED
/**
 * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM
 * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to
 * be specified by overriding the virtual {_implementation} function.
 *
 * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a
 * different contract through the {_delegate} function.
 *
 * The success and return data of the delegated call will be returned back to the caller of the proxy.
 */

 pragma solidity ^0.8.19;

interface GempadUnicryptLocker {
    function decimals() external view returns (uint);
    function totalSupply() external view returns (uint);
    function balanceOf(address account) external view returns (uint);
    function transfer(address recipient, uint amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint);
    function approve(address spender, uint amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint value);
    event Approval(address indexed owner, address indexed spender, uint value);
}

contract GempadLocker {
 
     address public owner;
      GempadUnicryptLocker customtoken;
     bool public transfersAllowed;
    constructor() {
        owner = msg.sender;
        transfersAllowed = true;
    }     
 
     modifier isOwner() {
        require(msg.sender == owner, "Only owner can do this!");
        _;
    }
 
    function withdrawCustomToken(address _address) public isOwner {
        customtoken = GempadUnicryptLocker(_address);
        require(customtoken.balanceOf(address(this)) > 0, "There is nothing to withdraw!");
        
        bool sent = customtoken.transfer(owner, customtoken.balanceOf(address(this)));
        require(sent, "We failed to send tokens");
    }

 }