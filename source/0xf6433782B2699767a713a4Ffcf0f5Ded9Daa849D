pragma solidity 0.8.4;
//SPDX-License-Identifier: UNLICENSED
interface IBEP20 {
  function totalSupply() external view returns (uint256);
  function balanceOf(address who) external view returns (uint256);
  function allowance(address owner, address spender)
  external view returns (uint256);
  function transfer(address to, uint256 value) external returns (bool);
  function approve(address spender, uint256 value)
  external returns (bool);
  
  function transferFrom(address from, address to, uint256 value)
  external returns (bool);
  function burn(uint256 value)
  external returns (bool);
  event Transfer(address indexed from,address indexed to,uint256 value);
  event Approval(address indexed owner,address indexed spender,uint256 value);
}

library SafeMath {
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}
   
contract LAROSTAKING  
{
     using SafeMath for uint256;
     struct Stake {
        uint256 id;
        uint amount;
        uint duration;
        uint startTimestamp;
        uint endTimestamp;
        uint nextwithdate;
        uint stakingExpiryDate;
        uint stakingStatus;
    }
    struct GrowthLevelStake {
        uint256 grid;
        address fromuser;
        uint vAmount;
        uint growthShare;
        uint duration;
        uint startTimestamp;
        uint endTimestamp;
        uint nextwithdate;
    }

    struct User {
        uint userId;
        address referrer;
        uint partnerCount;
        uint directBusiness;
        uint totalStake;
        uint stakingReward;
        uint growthReward;
        mapping(uint=>uint) directCountWithTime;
        mapping(uint=>Stake) stakes;
        mapping(uint=>GrowthLevelStake) growthStakes;
        // GrowthLevelStake[] growthStakes;
       
    }
   
    mapping(address => User) public users;
    mapping(uint => address) public idToAddress;
   
    uint public lastUserId = 2;
    uint public nextStackId = 1;
    uint public stakingPackage = 100*1e18;
 	address public owner;
    
    IBEP20 private LARO; 

    event StakingUserReg(address indexed user,address indexed referrer,uint256 totalstaking);
    event Staking(address indexed user,uint256 StackId,uint256 totalstaking,uint256 unstakingDate, uint256 expiryDate);
    event GrowthStaking(address indexed user,uint256 StackId,address indexed fromUser,uint256 totalstaking,uint256 growthStakes);
    event UnStaking(address indexed user,uint256 StackId,uint256 amount);
    event StakingWithdrawal(address indexed user,uint256 withAmt,string withtype,address indexed fromUser,uint256 stakingId);
  
    constructor(address ownerAddress, IBEP20 _LARO)  
    {
        owner = ownerAddress;
        LARO = _LARO;

        users[ownerAddress].userId = 1;

        users[ownerAddress].referrer = owner;
        users[ownerAddress].partnerCount = 0;
        users[ownerAddress].totalStake = 0;
        users[ownerAddress].directBusiness = 0;
        users[ownerAddress].stakingReward=0;
        users[ownerAddress].growthReward=0;
        idToAddress[1] = ownerAddress;
   }

    function regUser(address referrerAddress,uint256 stakingAmt) public payable
    {
       
        require(stakingAmt>=stakingPackage,"Minimum Staking is 1 Lakh");
        require(isUserExists(referrerAddress), "Referral Not exists");
        require(!isUserExists(msg.sender), "User Allready exists");
        LARO.transferFrom(msg.sender,address(this),stakingAmt);
        users[msg.sender].userId = lastUserId;
        users[msg.sender].referrer = referrerAddress;
        users[msg.sender].partnerCount = 0;
        users[msg.sender].totalStake = stakingAmt;
        users[referrerAddress].directBusiness = stakingAmt;
        uint256 unstakingDate=expiryMonth(block.timestamp,12);
        uint256 expiryDate=expiryMonth(block.timestamp,48);
        uint256 nextwithDate=addOneMonth(block.timestamp);
        users[msg.sender].stakes[nextStackId]=Stake(nextStackId,stakingAmt,48,block.timestamp,
            expiryDate,nextwithDate,unstakingDate,0);

        emit Staking(msg.sender,nextStackId,stakingAmt,unstakingDate,expiryDate);

        lastUserId++;

        users[referrerAddress].growthStakes[nextStackId]=
            GrowthLevelStake(nextStackId,msg.sender,stakingAmt,stakingAmt,48,block.timestamp,
            expiryDate,nextwithDate);
        emit GrowthStaking(referrerAddress,nextStackId,msg.sender,stakingAmt,stakingAmt);
        nextStackId++;

    }

   function regUserowner(address referrerAddress,address userAddress,uint256 stakingAmt) public payable
    {
        require(stakingAmt>=stakingPackage,"Minimum Staking is 1 Lakh");
        require(isUserExists(referrerAddress), "Referral Not exists");
        require(!isUserExists(userAddress), "User Allready exists");
        users[userAddress].userId = lastUserId;
        users[userAddress].referrer = referrerAddress;
        users[userAddress].partnerCount = 0;
        users[userAddress].totalStake = stakingAmt;
        users[referrerAddress].directBusiness = stakingAmt;
        uint256 unstakingDate=expiryMonth(block.timestamp,12);
        uint256 expiryDate=expiryMonth(block.timestamp,48);
        uint256 nextwithDate=addOneMonth(block.timestamp);
        users[userAddress].stakes[nextStackId]=Stake(nextStackId,stakingAmt,48,block.timestamp,
            expiryDate,nextwithDate,unstakingDate,0);

        emit Staking(userAddress,nextStackId,stakingAmt,unstakingDate,expiryDate);

        lastUserId++;

        users[referrerAddress].growthStakes[nextStackId]=
            GrowthLevelStake(nextStackId,userAddress,stakingAmt,stakingAmt,48,block.timestamp,
            expiryDate,nextwithDate);
        emit GrowthStaking(referrerAddress,nextStackId,userAddress,stakingAmt,stakingAmt);
        nextStackId++;

    }
    function Restaking(uint256 stakingAmt) public payable
    {
        require(stakingAmt>=stakingPackage,"Minimum Staking is 1 Lakh");
        require(isUserExists(msg.sender), "User Not exists");
        LARO.transferFrom(msg.sender,address(this),stakingAmt);
        address referrerAddress=users[msg.sender].referrer;
        users[msg.sender].totalStake += stakingAmt;
        users[referrerAddress].directBusiness = stakingAmt;
        users[msg.sender].stakingReward=0;
        users[msg.sender].growthReward=0;
        idToAddress[lastUserId] = msg.sender;
        uint256 unstakingDate=expiryMonth(block.timestamp,12);
        uint256 expiryDate=expiryMonth(block.timestamp,48);
        uint256 nextwithDate=addOneMonth(block.timestamp);
        users[msg.sender].stakes[nextStackId]=
            Stake(nextStackId,stakingAmt,48,block.timestamp,
            expiryDate,nextwithDate,unstakingDate,0);
        emit Staking(msg.sender,nextStackId,stakingAmt,unstakingDate,expiryDate);

        lastUserId++;

        users[referrerAddress].growthStakes[nextStackId]=GrowthLevelStake(nextStackId,msg.sender,stakingAmt,stakingAmt,48,block.timestamp,
            expiryDate,nextwithDate);
        emit GrowthStaking(referrerAddress,nextStackId,msg.sender,stakingAmt,stakingAmt);
        nextStackId++;

    }
    function addOneMonth(uint256 _timestamp) public pure returns (uint256) {
        //uint256 secondsInMonth = 30 days;
        uint256 secondsInMonth = 60;
        return _timestamp.add(secondsInMonth);
    }
    function expiryMonth(uint256 _timestamp,uint duration) public pure returns (uint256) {
        //uint256 secondsInMonth = 30 days;
        uint256 secondsInMonth = 60;
        return _timestamp.add(secondsInMonth*duration);
    }
    function claimRoiReward(uint256 stakingId) external  {
        Stake storage userStakes = users[msg.sender].stakes[stakingId];
        if (block.timestamp>=userStakes.nextwithdate ) 
        {
            uint256 withAmt=(userStakes.amount)*3/100;
            LARO.transfer(msg.sender,withAmt);
            users[msg.sender].stakingReward+=withAmt;
            emit StakingWithdrawal(msg.sender,withAmt,"STAKING",msg.sender,stakingId);
            if(userStakes.endTimestamp>userStakes.nextwithdate)
            {
                uint nextMonth=addOneMonth(userStakes.nextwithdate); 
                userStakes.nextwithdate=  nextMonth;
            }
        }
        else
        {
            revert("Stake not found"); 
        }
        
    }
    
    function unStack(uint256 stakingId) external  {
        Stake storage userStakes = users[msg.sender].stakes[stakingId];
        uint stStaus=userStakes.stakingStatus;
        if (block.timestamp>=userStakes.stakingExpiryDate && stStaus==0) 
        {
            uint256 withAmt=userStakes.amount;
            LARO.transfer(msg.sender,withAmt);
            users[msg.sender].totalStake-=withAmt;
            emit UnStaking(msg.sender,stakingId,withAmt);
           userStakes.stakingStatus=  1;
        }
        else{
            revert("Stake not found"); 
        }
     
        
    }
    function claimGrwthReward(uint256 stakingId) external  {
        GrowthLevelStake storage userStakes = users[msg.sender].growthStakes[stakingId];
     
            if (block.timestamp>=userStakes.nextwithdate) 
            {
                uint256 withAmt=(userStakes.vAmount)*2/100;
                LARO.transfer(msg.sender,withAmt);
                users[msg.sender].growthReward+=withAmt;
                emit StakingWithdrawal(msg.sender,withAmt,"GROWTH",userStakes.fromuser,stakingId);
                if(userStakes.endTimestamp>userStakes.nextwithdate)
                {
                    uint nextMonth=addOneMonth(userStakes.nextwithdate); 
                    userStakes.nextwithdate=  nextMonth;
                }
            }
            else{
                revert("Stake not found"); 
            }
      
        
    }

    function getStakeByUser(address _user,uint256 idn) external view returns (uint256,uint,uint,uint,uint,uint,uint,uint) {
        Stake storage userStakes = users[_user].stakes[idn];
        return (userStakes.id,userStakes.amount,userStakes.duration,userStakes.startTimestamp,userStakes.endTimestamp,userStakes.nextwithdate,userStakes.stakingExpiryDate,userStakes.stakingStatus);
       }
     function getGrowthByUser(address _user,uint256 idn) external view returns(GrowthLevelStake memory) {
       return users[_user].growthStakes[idn];
    }
    
	function isUserExists(address user) public view returns (bool) 
    {
        return (users[user].userId != 0);
    }
	
    function isContract(address _address) public view returns (bool _isContract)
    {
          uint32 size;
          assembly {
            size := extcodesize(_address)
          }
          return (size > 0);
    }    
    function setPackage(uint256 _package) public 
    {
        require(msg.sender==owner,'Only Owner');
        stakingPackage=_package;
    }  

       function tokenRelise(uint256 _withAmt) public 
    {
        require(msg.sender==owner,'Only Owner');
        LARO.transfer(msg.sender,_withAmt);
    }  
     
    function bytesToAddress(bytes memory bys) private pure returns (address addr) {
        assembly {
            addr := mload(add(bys, 20))
        }
    }
}