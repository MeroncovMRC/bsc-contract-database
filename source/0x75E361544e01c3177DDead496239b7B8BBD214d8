// SPDX-License-Identifier: MIT

pragma solidity ^0.8.19;

interface IERC20 {
    function decimals() external view returns (uint8);

    function symbol() external view returns (string memory);

    function name() external view returns (string memory);

    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function transfer(address recipient, uint256 amount) external returns (bool);

    function allowance(address owner, address spender) external view returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor () {
        address msgSender = msg.sender;
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(_owner == msg.sender, "!o");
        _;
    }

    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "n0");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

contract Mint2Pool is Ownable {
    struct UserInfo {
        uint256 amount;
        uint256 rewardDebt;
        uint256 rewardDebt2;

        uint256 inviteAmount;
        uint256 inviteReward;
        uint256 inviteReward2;
    }

    struct PoolInfo {
        address lpToken;
        string lpSymbol;
        uint256 totalAmount;
        uint256 lastRewardBlock;

        address rewardToken;
        uint256 rewardPerBlock;
        uint256 accPerShare;
        uint256 accReward;
        uint256 totalReward;

        address rewardToken2;
        uint256 rewardPerBlock2;
        uint256 accPerShare2;
        uint256 accReward2;
        uint256 totalReward2;
    }

    PoolInfo[] private poolInfo;
    mapping(uint256 => mapping(address => UserInfo)) private userInfo;
    mapping(address => uint256) public poolLpBalances;
    uint256 public constant _rewardFactor = 1e18;

    uint256 public _inviteLen = 2;
    mapping(uint256 => uint256) public _inviteFee;
    mapping(address => bool) public _active;
    mapping(address => address) public _invitor;
    mapping(address => address[]) public _binder;

    constructor(){
        _inviteFee[0] = 800;
        _inviteFee[1] = 500;
    }

    function poolLength() public view returns (uint256) {
        return poolInfo.length;
    }

    function deposit(uint256 pid, uint256 amount, address invitor) external {
        require(amount > 0, "a0");
        _updatePool(pid);

        address account = msg.sender;
        if (!_active[account]) {
            if (_active[invitor]) {
                _invitor[account] = invitor;
                _binder[invitor].push(account);
            }
            _active[account] = true;
        }

        UserInfo storage user = userInfo[pid][account];
        _claim(pid, user, account);

        PoolInfo storage pool = poolInfo[pid];

        IERC20 lpToken = IERC20(pool.lpToken);
        uint256 beforeAmount = lpToken.balanceOf(address(this));
        _takeToken(address(lpToken), account, address(this), amount);
        uint256 afterAmount = lpToken.balanceOf(address(this));
        amount = afterAmount - beforeAmount;

        pool.totalAmount += amount;
        poolLpBalances[pool.lpToken] += amount;

        uint256 userAmount = user.amount;
        userAmount += amount;
        user.amount = userAmount;
        user.rewardDebt = userAmount * pool.accPerShare / _rewardFactor;
        user.rewardDebt2 = userAmount * pool.accPerShare2 / _rewardFactor;

        invitor = _invitor[account];
        if (invitor != address(0)) {
            userInfo[pid][invitor].inviteAmount += amount;
        }
    }

    function withdraw(uint256 pid) public {
        _withdraw(pid, true);
    }

    function claim(uint256 pid) public {
        _updatePool(pid);
        address account = msg.sender;
        UserInfo storage user = userInfo[pid][account];
        _claim(pid, user, account);
    }

    function _withdraw(uint256 pid, bool getReward) private {
        _updatePool(pid);

        address account = msg.sender;
        UserInfo storage user = userInfo[pid][account];
        if (getReward) {
            _claim(pid, user, account);
        }

        PoolInfo storage pool = poolInfo[pid];
        uint256 amount = user.amount;
        _giveToken(pool.lpToken, account, amount);

        pool.totalAmount -= amount;
        poolLpBalances[pool.lpToken] -= amount;

        user.amount = 0;
        user.rewardDebt = 0;
        user.rewardDebt2 = 0;

        address invitor = _invitor[account];
        if (invitor != address(0)) {
            userInfo[pid][invitor].inviteAmount -= amount;
        }
    }

    function addPool(
        address lpToken,
        string memory lpSymbol,
        address rewardToken,
        uint256 rewardPerBlock,
        uint256 totalReward
    ) external onlyOwner {
        poolInfo.push(PoolInfo({
        lpToken : lpToken,
        lpSymbol : lpSymbol,
        totalAmount : 0,
        lastRewardBlock : block.number,
        rewardToken : rewardToken,
        rewardPerBlock : rewardPerBlock,
        accPerShare : 0,
        accReward : 0,
        totalReward : totalReward,
        rewardToken2 : address(0),
        rewardPerBlock2 : 0,
        accPerShare2 : 0,
        accReward2 : 0,
        totalReward2 : 0
        }));
    }

    function addReward2(
        uint256 pid,
        address rewardToken2,
        uint256 rewardPerBlock2,
        uint256 totalReward2
    ) external onlyOwner {
        PoolInfo storage pool = poolInfo[pid];
        pool.rewardToken2 = rewardToken2;
        pool.rewardPerBlock2 = rewardPerBlock2;
        pool.totalReward2 = totalReward2;
    }

    function setRewardPerBlock(uint256 pid, uint256 rewardPerBlock) external onlyOwner {
        _updatePool(pid);
        poolInfo[pid].rewardPerBlock = rewardPerBlock;
    }

    function setRewardPerBlock2(uint256 pid, uint256 rewardPerBlock2) external onlyOwner {
        _updatePool(pid);
        poolInfo[pid].rewardPerBlock2 = rewardPerBlock2;
    }

    function setTotalReward(uint256 pid, uint256 totalReward) external onlyOwner {
        _updatePool(pid);
        poolInfo[pid].totalReward = totalReward;
    }

    function setTotalReward2(uint256 pid, uint256 totalReward2) external onlyOwner {
        _updatePool(pid);
        poolInfo[pid].totalReward2 = totalReward2;
    }

    function setPoolLP(uint256 pid, address lp) external onlyOwner {
        PoolInfo storage pool = poolInfo[pid];
        require(pool.totalAmount == 0, "started");
        pool.lpToken = lp;
    }

    function setRewardToken(uint256 pid, address token) external onlyOwner {
        PoolInfo storage pool = poolInfo[pid];
        pool.rewardToken = token;
    }

    function setRewardToken2(uint256 pid, address token2) external onlyOwner {
        PoolInfo storage pool = poolInfo[pid];
        pool.rewardToken2 = token2;
    }

    receive() external payable {

    }

    function _updatePool(uint256 pid) private {
        PoolInfo storage pool = poolInfo[pid];
        uint256 blockNum = block.number;
        uint256 lastRewardBlock = pool.lastRewardBlock;
        if (blockNum <= lastRewardBlock) {
            return;
        }
        pool.lastRewardBlock = blockNum;

        uint256 totalAmount = pool.totalAmount;
        if (0 == totalAmount) {
            return;
        }

        uint256 accReward = pool.accReward;
        uint256 totalReward = pool.totalReward;
        if (accReward < totalReward) {
            uint256 rewardPerBlock = pool.rewardPerBlock;
            if (0 < totalAmount && 0 < rewardPerBlock) {
                uint256 reward = rewardPerBlock * (blockNum - lastRewardBlock);
                uint256 remainReward = totalReward - accReward;
                if (reward > remainReward) {
                    reward = remainReward;
                }
                pool.accPerShare += reward * _rewardFactor / totalAmount;
                pool.accReward += reward;
            }
        }

        _updatePool2(pool, totalAmount, blockNum, lastRewardBlock);
    }

    function _updatePool2(PoolInfo storage pool, uint256 totalAmount, uint256 blockNum, uint256 lastRewardBlock) private {
        uint256 accReward = pool.accReward2;
        uint256 totalReward = pool.totalReward2;
        if (accReward < totalReward) {
            uint256 rewardPerBlock = pool.rewardPerBlock2;
            if (0 < totalAmount && 0 < rewardPerBlock) {
                uint256 reward = rewardPerBlock * (blockNum - lastRewardBlock);
                uint256 remainReward = totalReward - accReward;
                if (reward > remainReward) {
                    reward = remainReward;
                }
                pool.accPerShare2 += reward * _rewardFactor / totalAmount;
                pool.accReward2 += reward;
            }
        }
    }

    function _claim(uint256 pid, UserInfo storage user, address account) private {
        PoolInfo storage pool = poolInfo[pid];
        uint256 userAmount = user.amount;
        if (userAmount > 0) {
            uint256 accReward = userAmount * pool.accPerShare / _rewardFactor;
            uint256 pendingAmount = accReward - user.rewardDebt;
            if (pendingAmount > 0) {
                user.rewardDebt = accReward;
                address rewardTokenAddress = pool.rewardToken;
                if (address(0) != rewardTokenAddress) {
                    _giveToken(rewardTokenAddress, account, pendingAmount);
                    uint256 inviteLen = _inviteLen;
                    address current = account;
                    address invitor;
                    uint256 inviteReward;
                    for (uint256 i; i < inviteLen;) {
                        invitor = _invitor[current];
                        if (address(0) == invitor) {
                            break;
                        }
                        current = invitor;
                        inviteReward = pendingAmount * _inviteFee[i] / 10000;
                        userInfo[pid][invitor].inviteReward += inviteReward;
                        _giveToken(rewardTokenAddress, invitor, inviteReward);
                    unchecked{
                        ++i;
                    }
                    }
                }
            }

            _claim2(pid, pool, user, userAmount, account);
        }
    }

    function _claim2(uint256 pid, PoolInfo storage pool, UserInfo storage user, uint256 userAmount, address account) private {
        uint256 accReward = userAmount * pool.accPerShare2 / _rewardFactor;
        uint256 pendingAmount = accReward - user.rewardDebt2;
        if (pendingAmount > 0) {
            user.rewardDebt2 = accReward;
            address rewardToken2Address = pool.rewardToken2;
            if (address(0) != rewardToken2Address) {
                _giveToken(rewardToken2Address, account, pendingAmount);
                uint256 inviteLen = _inviteLen;
                address current = account;
                address invitor;
                uint256 inviteReward;
                for (uint256 i; i < inviteLen;) {
                    invitor = _invitor[current];
                    if (address(0) == invitor) {
                        break;
                    }
                    current = invitor;
                    inviteReward = pendingAmount * _inviteFee[i] / 10000;
                    userInfo[pid][account].inviteReward2 += inviteReward;
                    _giveToken(rewardToken2Address, invitor, inviteReward);
                unchecked{
                    ++i;
                }
                }
            }
        }
    }

    function _pendingReward(uint256 pid, address account) private view returns (
        uint256 reward, uint256 reward2
    ) {
        PoolInfo storage pool = poolInfo[pid];
        UserInfo storage user = userInfo[pid][account];
        uint256 amount = user.amount;

        if (amount > 0) {
            uint256 poolPendingReward;
            uint256 blockNum = block.number;
            uint256 lastRewardBlock = pool.lastRewardBlock;
            if (blockNum > lastRewardBlock) {
                poolPendingReward = pool.rewardPerBlock * (blockNum - lastRewardBlock);
                uint256 totalReward = pool.totalReward;
                uint256 accReward = pool.accReward;
                uint256 remainReward;
                if (totalReward > accReward) {
                    remainReward = totalReward - accReward;
                }
                if (poolPendingReward > remainReward) {
                    poolPendingReward = remainReward;
                }
            }
            uint256 totalAmount = pool.totalAmount;
            reward = user.amount * (pool.accPerShare + poolPendingReward * _rewardFactor / totalAmount) / _rewardFactor - user.rewardDebt;

            reward2 = _pendingReward2(pool, user, blockNum, lastRewardBlock, totalAmount, amount);
        }
    }

    function _pendingReward2(
        PoolInfo storage pool, UserInfo storage user, uint256 blockNum, uint256 lastRewardBlock, uint256 totalAmount, uint256 amount
    ) private view returns (uint256 reward) {
        uint256 poolPendingReward;
        if (blockNum > lastRewardBlock) {
            poolPendingReward = pool.rewardPerBlock2 * (blockNum - lastRewardBlock);
            uint256 totalReward = pool.totalReward2;
            uint256 accReward = pool.accReward2;
            uint256 remainReward;
            if (totalReward > accReward) {
                remainReward = totalReward - accReward;
            }
            if (poolPendingReward > remainReward) {
                poolPendingReward = remainReward;
            }
        }
        reward = amount * (pool.accPerShare2 + poolPendingReward * _rewardFactor / totalAmount) / _rewardFactor - user.rewardDebt2;
    }

    function getPoolInfo(uint256 pid) public view returns (
        address lpToken,
        string memory lpSymbol,
        uint256 lpTokenDecimals,
        uint256 totalAmount,
        uint256 lastRewardBlock
    ) {
        PoolInfo storage pool = poolInfo[pid];
        lpToken = pool.lpToken;
        lpSymbol = pool.lpSymbol;
        lpTokenDecimals = IERC20(pool.lpToken).decimals();
        totalAmount = pool.totalAmount;
        lastRewardBlock = pool.lastRewardBlock;

    }

    function getPoolRewardInfo(uint256 pid) public view returns (
        address rewardToken,
        uint256 rewardPerBlock,
        uint256 accPerShare,
        uint256 accReward,
        uint256 totalReward,
        uint256 rewardTokenDecimals,
        string memory rewardTokenSymbol
    ) {
        PoolInfo storage pool = poolInfo[pid];
        rewardToken = pool.rewardToken;
        rewardPerBlock = pool.rewardPerBlock;
        accPerShare = pool.accPerShare;
        accReward = pool.accReward;
        totalReward = pool.totalReward;
        if (address(0) != rewardToken) {
            rewardTokenDecimals = IERC20(rewardToken).decimals();
            rewardTokenSymbol = IERC20(rewardToken).symbol();
        }
    }

    function getPoolRewardInfo2(uint256 pid) public view returns (
        address rewardToken,
        uint256 rewardPerBlock,
        uint256 accPerShare,
        uint256 accReward,
        uint256 totalReward,
        uint256 rewardTokenDecimals,
        string memory rewardTokenSymbol
    ) {
        PoolInfo storage pool = poolInfo[pid];
        rewardToken = pool.rewardToken2;
        rewardPerBlock = pool.rewardPerBlock2;
        accPerShare = pool.accPerShare2;
        accReward = pool.accReward2;
        totalReward = pool.totalReward2;
        if (address(0) != rewardToken) {
            rewardTokenDecimals = IERC20(rewardToken).decimals();
            rewardTokenSymbol = IERC20(rewardToken).symbol();
        }
    }

    function getUserInfo(uint256 pid, address account) public view returns (
        uint256 amount,
        uint256 pending,
        uint256 pending2,
        uint256 lpBalance,
        uint256 lpAllowance,
        uint256 rewardDebt,
        uint256 rewardDebt2
    ) {
        UserInfo storage user = userInfo[pid][account];
        amount = user.amount;
        (pending, pending2) = _pendingReward(pid, account);
        lpBalance = IERC20(poolInfo[pid].lpToken).balanceOf(account);
        lpAllowance = IERC20(poolInfo[pid].lpToken).allowance(account, address(this));
        rewardDebt = user.rewardDebt;
        rewardDebt2 = user.rewardDebt2;
    }

    function getUserInviteInfo(uint256 pid, address account) public view returns (
        uint256 inviteAmount,
        uint256 inviteReward,
        uint256 inviteReward2
    ) {
        UserInfo storage user = userInfo[pid][account];
        inviteAmount = user.inviteAmount;
        inviteReward = user.inviteReward;
        inviteReward2 = user.inviteReward2;
    }

    function emergencyWithdraw(uint256 pid) external {
        _withdraw(pid, false);
    }

    function claimBalance(address to, uint256 amount) external onlyOwner {
        payable(to).transfer(amount);
    }

    function claimToken(address token, address to, uint256 amount) external onlyOwner {
        uint256 maxClaim = IERC20(token).balanceOf(address(this)) - poolLpBalances[token];
        if (amount > maxClaim) {
            amount = maxClaim;
        }
        _giveToken(token, to, amount);
    }

    function setInviteLen(uint256 l) external onlyOwner {
        _inviteLen = l;
    }

    function setInviteFee(uint256 i, uint256 f) external onlyOwner {
        _inviteFee[i] = f;
    }

    function _giveToken(address tokenAddress, address account, uint256 amount) private {
        if (0 == amount) {
            return;
        }
        IERC20 token = IERC20(tokenAddress);
        require(token.balanceOf(address(this)) >= amount, "PTNE");
        safeTransfer(tokenAddress, account, amount);
    }

    function _takeToken(address tokenAddress, address from, address to, uint256 tokenNum) private {
        IERC20 token = IERC20(tokenAddress);
        require(token.balanceOf(address(from)) >= tokenNum, "TNE");
        safeTransferFrom(tokenAddress, from, to, tokenNum);
    }

    function safeTransfer(address token, address to, uint value) internal {
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));
        if (success && data.length > 0) {

        }
    }

    function safeTransferFrom(address token, address from, address to, uint value) internal {
        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));
        if (success && data.length > 0) {

        }
    }

    function getAllPoolInfo() external view returns (
        address[] memory lpToken,
        string[] memory lpSymbol,
        uint256[] memory lpTokenDecimals,
        uint256[] memory totalAmount,
        uint256[] memory rewardTokenDecimals,
        string[] memory rewardTokenSymbol,
        uint256[] memory rewardTokenDecimals2,
        string[] memory rewardTokenSymbol2
    ){
        uint256 len = poolLength();
        lpToken = new address[](len);
        lpSymbol = new string[](len);
        lpTokenDecimals = new uint256[](len);
        totalAmount = new uint256[](len);
        rewardTokenDecimals = new uint256[](len);
        rewardTokenSymbol = new string[](len);
        rewardTokenDecimals2 = new uint256[](len);
        rewardTokenSymbol2 = new string[](len);
        for (uint256 i; i < len; ++i) {
            (lpToken[i], lpSymbol[i], lpTokenDecimals[i], totalAmount[i],) = getPoolInfo(i);
            (,,,,, rewardTokenDecimals[i], rewardTokenSymbol[i]) = getPoolRewardInfo(i);
            (,,,,, rewardTokenDecimals2[i], rewardTokenSymbol2[i]) = getPoolRewardInfo2(i);
        }
    }

    function getUserAllPoolInfo(address account) external view returns (
        uint256[] memory amount,
        uint256[]memory pending,
        uint256[]memory pending2,
        uint256[]memory lpBalance,
        uint256[]memory lpAllowance,
        uint256[]memory inviteAmount,
        uint256[]memory inviteReward,
        uint256[]memory inviteReward2
    ){
        uint256 len = poolLength();
        amount = new uint256[](len);
        pending = new uint256[](len);
        pending2 = new uint256[](len);
        lpBalance = new uint256[](len);
        lpAllowance = new uint256[](len);
        inviteAmount = new uint256[](len);
        inviteReward = new uint256[](len);
        inviteReward2 = new uint256[](len);
        for (uint256 i; i < len; ++i) {
            (amount[i], pending[i], pending2[i], lpBalance[i], lpAllowance[i],,) = getUserInfo(i, account);
            (inviteAmount[i], inviteReward[i], inviteReward2[i]) = getUserInviteInfo(i, account);
        }
    }

    function getBinderLength(address account) public view returns (uint256){
        return _binder[account].length;
    }

    function getUserExtInfo(address account) public view returns (
        bool active, address invitor, uint256 binderLength
    ){
        active = _active[account];
        invitor = _invitor[account];
        binderLength = getBinderLength(account);
    }
}