// SPDX-License-Identifier: Unlicensed

/*

    GGGGGGGGGGG  EEEEEEEEEEE  NNN     NNN  22222222222
    GGGGGGGGGGG  EEEEEEEEEEE  NNN     NNN  22222222222
    GGG          EEE          NNNN    NNN          222
    GGG  GGGGGG  EEEEEEEE     NNN NN  NNN  22222222222
    GGG  GGGGGG  EEEEEEEE     NNN NN  NNN  22222222222
    GGG     GGG  EEE          NNN  NN NNN  222
    GGG     GGG  EEE          NNN    NNNN  222
    GGGGGGGGGGG  EEEEEEEEEEE  NNN     NNN  22222222222
    GGGGGGGGGGG  EEEEEEEEEEE  NNN     NNN  22222222222
    
    Welcome to GEN2
    The Official Token for the GenTokens Community!
    

    Telegram Group: https://t.me/GenTokensShill (Tokens!)
    Telegram Group: https://t.me/GenTokens (Community Chat)
    YouTube: https://www.youtube.com/gentokens
    Reddit: https://www.reddit.com/r/GenTokens/
    Website: https://gentokens.com/
    Twitter: https://twitter.com/GenTokens
    
    What is GEN2?
    
    We have two official GEN tokens. This one (GEN2)
    and also the original GEN (0xd4294c0f64eba74089315d4b0278698f7181037e)
    
    They both provide holders with the same benefit.
    If you hold GEN OR GEN2 you will have early access 
    to all future tokens that are released via our LaunchPad.
    
    More on that later... but why GEN2?
    
    GEN (1) is renounced. I cannot micro-manage the tokenomics and it does not 
    provide any money for marketing.
    
    GEN2 will never be renounced! So I can adjust the tokenomics and micro-manage its 
    growth. It also has a marketing wallet that pays in BNB. Which will provide us 
    with plenty of money for promoting GEN and GEN2 going forward. 
    
    This puts us in a very unique position. We have 2 tokens, that give you 
    the same benefit for holding... but you get to choose, renounced or micro-managed! 
    
    So let's talk about the benefits of holding GEN or GEN2....
    
    The GenTokens Launch Pad!
    
    Have you ever watched the APE tool on poocoin? When a token pops up, if you buy
    first you could make a fortune! But... it's probably a scam, so you can't just 
    APE in, you have to do some checks first. 
    
    Checks take time.... and while you do your due diligence the price is going up! 
    Add even worse, after you've done all of your checks, the coin can still RUG!
    
    I'd guess that 95% of tokens that you see on the APE tool are scams. Maybe more.
    
    Imagine if you could just buy the token the moment it launches, knowing with 100% 
    confidence that it is safe...
    
    Well that's the GenTokens LaunchPad!
    
    We provide tokens that are guaranteed to be safe. You don't have to do any checks
    at all, you can APE in with total confidence and buy immediately after launch. 
    
    Our LaunchPad deploys tokens in 4 stages... 
    
    Stage 1
    
    Members of our 'Approved Community' buy first. Nobody else! No bots! No Strangers! No Risk! 
    How do you get to become a member of this elite community? Members are handpicked and added 
    personally by me, or a member of my very trusted team. We watch our community at GEN very 
    carefully, if we see that you are helping out, answering questions, offering support and 
    guidance to other members of the community we invite you in. 
    
    Oh, and there is one last very important check....
    
    My heart. 
    
    I trust my heart over EVERYTHING. If I get a bad feeling about you, you will not get in!
    My heart always has the final say. I am extremely intuitive and it has never let me down. 
    
    If you're a good, wholesome person, my heart will like you ;) 
    
    This inner core of members are people I trust completely. However, I still need to protect 
    non-members, so Stage 1 has a very strict holder limit. Nobody can buy more than 
    2% of a token supply, avoiding the risk of a whale wallet from within the community.
    
    As well as being hand picked for the 'Approved Community' all members must hold GEN or GEN2 
    in order to be able to buy.
    
    Stage 2 
    
    The next people that get to buy are the main GEN community members. These are the people in our 
    Telegram group, When it is time for them to buy I will announce the new token to the group and 
    anybody that wants to buy needs to send me their wallet address, so I can add it to the approved list. 
    
    Only wallets that I personally approve can buy. Again... no bots can touch us. And these people must
    hold GEN or GEN2 to be able to buy. 
    
    Stage 3 
    
    At stage 3 we open up to the entire GEN community. At this stage all people holding GEN or GEN2 can buy.
    But nobody else. I am aware that a bot user can hold GEN or GEN2 and potential buy at this stage. I personally 
    scrutinise all sales very carefully. Anybody using a bot will be blacklisted, and their tokens locked.
    
    Stage 4 
    
    We open up to the public. Anybody can buy... and we watch the transactions very carefully. If necessary, we 
    pause the contract to blacklist bots! 
    
    We take these measures to ensure a safe launch. We want to protect our community from the bots, and from 
    each other! So no whale wallets, and no bots! By restricting our launches to good people that we trust we
    give our tokens the very best start.
    
    Our launches are discreet for a reason. We are not trying to create hype to get a 1000x token seconds after launch.
    This activity attracts a lot of attention from bot users! We deploy discreetly to a community we trust, and slowly 
    open up to a larger community at each stage.
    
    By the time bots can buy, they don't want to buy! They are only interested in getting in first. And that simply is
    not possible due to the way we deploy our contracts.
    
    Then we promote. 
    
    A final word on bots....
    
    If you use bots, then expect your wallet to be blacklisted. I use several ways of discreetly
    detecting bots (none of which are revealed in this contract) if I detect that you are using a bot 
    (on ANY contract, not just GEN or GEN2) I will blacklist your wallet. 
    
    This brings us on to our....
    
    TERMS OF SALE 
    
    If you use bots, you are not permitted to purchase GEN, GEN2 or any future token that launches via the
    GenTokens LaunchPad. Any purchase that you make will be considered a 100% donation to the GEN community.
    Your account will be locked and you will not be able to sell or swap your tokens. 
    
    We do not permit bots at all. Of ANY kind. If you use them, do not attempt to buy GEN or GEN2. You will 
    lose your money. 
    
    So... hopefully we only have the good, wholesome, and honest people left. 
    
    ....Hello Guys!!! :)
    
    So what is this LaunchPad thing???? 
    
    Well, you already know how the deployment works, but what about the tokens? 
    
    We use our LaunchPad to launch safe community and charity tokens that we hand over 
    to other people to promote and manage. This could be you! 
    
    Each token goes through the same strict deployment stages to ensure its safety before 
    you adopt it as your own. 
    
    We also support other teams by creating "use purpose", lottery, and giveaway tokens. 
    
    Full details of how the GenTokens LaunchPad works, and how you can have your very own 
    token launch safely using our system are provided on our website. 
    
    Now lets chat about GEN2
    
    Our tokenomics....
    
    Redistribution to Holders (Reflection)
    
    We have a redistribution fee of 3% on all transactions. 
    To get more GEN2, just buy and hold. Every transaction puts more GEN2 in your wallet 
    completely automatically 
    
    Auto-Liquidity 
    
    We have a 3% fee on all transactions that is added to the liquidity pool for GEN2
    
    Burned Liquidity 
    
    Our initial Liquidity is not locked... it is burned. We can never remove it. The auto 
    liquidity is also burned. Of course, GEN2 holders can add liquidity if they wish,
    but everything we add is burned! 
    
    Giveaways and Manual Burns 
    
    We have a 2% fee on all transactions that pays in GEN2 tokens into a very special wallet 
    We NEVER sell the tokens in this wallet! 
    
    We use them in 2 very clever ways.... 
    
    1. We use them for Giveaways, that we run via the Gleam.io platform
    live on YouTube, this helps to promote GEN and GEN2
    
    2. If the price of GEN2 drops, due to people selling or general market conditions, we 
    manually burn some tokens from this wallet to recover the $ value on GEN2
    
    When this wallet is holding more tokens than we need, we lower the fee to 0% and we 
    move the 2% to other places where it can be used most effectively. Either to the 
    Auto-Liquidity, the marketing wallet or to boost the redistribution to holders. 
    
    Finally, we have the marketing wallet. This takes a 3% fee on all transactions, it 
    is paid directly to the wallet in BNB and is used to cover all of our expenses and 
    pay for marketing of GEN and GEN2
    
    The initial Burn (What some people refer to as the Black Hole!) 
    
    The total supply of GEN2 at launch is 1000000000 * 10**6 * 10**9 
    We will burn 10% of the initial supply. This means that the burn wallet is counted as 
    a holder of GEN2, and is included in the redistribution reward. So every transaction
    some tokens are automatically burned. Burning tokens lowers the total supply,
    which increase the value of all remaining tokens... which you hold! 
    
    Transaction Limits 
    
    We have max transaction limits and max token holding limits.
    
    At launch, the max transaction limit is 1% of the total supply, and the 
    max holding limit is 2% of the total supply. These will be micro-managed as needed
    as GEN2 holders grow.
    
    All of our decisions have been made to make GEN, GEN2 and the GenTokens LaunchPad
    as safe, and profitable as possible for you.
    
    We are overwhelmed by the amazing support and goodness that we see within our 
    community. You are all really great people, and it is my wish that what we are
    doing will make you all very very rich! 
    
    Or at the very least.... recover any money you have ever lost in this crazy 
    world of crypto and ensure that you never lose any again! 
    
    Thank you for being a part of our community and making GenTokens Great! 
    
    GEN
    10th June 2021... in the middle of the night with some tea and biscuits.


 */

pragma solidity ^0.8.3;

interface IERC20 {
    
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

library SafeMath {
    
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            uint256 c = a + b;
            if (c < a) return (false, 0);
            return (true, c);
        }
    }
    
    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b > a) return (false, 0);
            return (true, a - b);
        }
    }
    
    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
            // benefit is lost if 'b' is also tested.
            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
            if (a == 0) return (true, 0);
            uint256 c = a * b;
            if (c / a != b) return (false, 0);
            return (true, c);
        }
    }
    
    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a / b);
        }
    }
    
    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a % b);
        }
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }


    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return a - b;
    }


    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        return a * b;
    }
    
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }


    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return a % b;
    }
    
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        unchecked {
            require(b <= a, errorMessage);
            return a - b;
        }
    }
    
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a / b;
        }
    }
    
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a % b;
        }
    }
}




abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}


library Address {
    
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }

    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");
        (bool success, ) = recipient.call{ value: amount }("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }
    
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
      return functionCall(target, data, "Address: low-level call failed");
    }
    
    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }
    
    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }
    
    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");
        (bool success, bytes memory returndata) = target.call{ value: value }(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }
    
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }
    
    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");
        (bool success, bytes memory returndata) = target.staticcall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }


    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }
    
    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        require(isContract(target), "Address: delegate call to non-contract");
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
        if (success) {
            return returndata;
        } else {
            if (returndata.length > 0) {
                 assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}



abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    constructor () {
        _owner = 0x627C95B6fD9026E00Ab2c373FB08CC47E02629a0;
        emit OwnershipTransferred(address(0), _owner);
    }
    
    function owner() public view virtual returns (address) {
        return _owner;
    }
    
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }
    
    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }


    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

interface IUniswapV2Factory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);
    function feeTo() external view returns (address);
    function feeToSetter() external view returns (address);
    function getPair(address tokenA, address tokenB) external view returns (address pair);
    function allPairs(uint) external view returns (address pair);
    function allPairsLength() external view returns (uint);
    function createPair(address tokenA, address tokenB) external returns (address pair);
    function setFeeTo(address) external;
    function setFeeToSetter(address) external;
}

interface IUniswapV2Pair {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);
    function name() external pure returns (string memory);
    function symbol() external pure returns (string memory);
    function decimals() external pure returns (uint8);
    function totalSupply() external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);
    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);
    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function PERMIT_TYPEHASH() external pure returns (bytes32);
    function nonces(address owner) external view returns (uint);
    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
    event Mint(address indexed sender, uint amount0, uint amount1);
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);
    function MINIMUM_LIQUIDITY() external pure returns (uint);
    function factory() external view returns (address);
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function price0CumulativeLast() external view returns (uint);
    function price1CumulativeLast() external view returns (uint);
    function kLast() external view returns (uint);
    function mint(address to) external returns (uint liquidity);
    function burn(address to) external returns (uint amount0, uint amount1);
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
    function skim(address to) external;
    function sync() external;
    function initialize(address, address) external;
}

interface IUniswapV2Router01 {
    function factory() external pure returns (address);
    function WETH() external pure returns (address);
    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETH(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountToken, uint amountETH);
    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETHWithPermit(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountToken, uint amountETH);
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);
    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);

    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);
    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
}

interface IUniswapV2Router02 is IUniswapV2Router01 {
    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountETH);
    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountETH);

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable;
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
}

contract GEN2 is Context, IERC20, Ownable {
    using SafeMath for uint256;
    using Address for address;

    mapping (address => uint256) private _rOwned;
    mapping (address => uint256) private _tOwned;
    mapping (address => mapping (address => uint256)) private _allowances;
    mapping (address => bool) private _isExcludedFromFee;
    mapping (address => bool) private _isExcluded;
    
    //_isCommunity = Can Buy at Launch! <-----for community 
    //_isBlacklisted = Can not buy or sell or transfer tokens at all <-----for bots! 
    mapping (address => bool) public _isCommunity;
    mapping (address => bool) public _isBlacklisted;
    
    //private launch - Only approved people can buy! 
    //need to add uniswapV2Pair address to communiity list in order to add liquidity 
    bool public onlyCommunity = true;
    
    address[] private _excluded;
    address payable private _promotionsWalletAddress = payable(0x5CAbbF2Bed506783038B48f51569Fe5b9283825b);
    uint256 private constant MAX = ~uint256(0);
    uint256 private _tTotal = 1000000000 * 10**6 * 10**9;
    uint256 private _rTotal = (MAX - (MAX % _tTotal));
    uint256 private _tFeeTotal;
    string private _name = "GenTokens.com";
    string private _symbol = "GEN2";
    uint8 private _decimals = 9;
    
    //refection fee
    uint256 public _reflectionFee = 3;
    uint256 private _previousReflectionFee = _reflectionFee;
    
    //token wallet fee for burns and giveaways
    uint256 public _tokenGiveawayFee = 2;
    uint256 private _previousTokenGiveawayFee = _tokenGiveawayFee;
    
    //setting the fees for auto LP and marketing wallet - Also need to change ratio if not 50/50
    uint256 public _liquidityFee = 3;
    uint256 public _promoFee = 3;
   
    //fee for the auto LP and the marketing wallet 
    uint256 private _liquidityAndPromoFee = _liquidityFee+_promoFee;
    uint256 private _previousLiquidityAndPromoFee = _liquidityAndPromoFee;
    
    //divide the token balance by this number to calculate the amount to swap for promo vs liquidity 
    //2 = 50/50, 3 = 1/3 to promo, 4 = 1/4 to promo 
    uint256 private _liqToPromoFraction = 2;
    
    //max wallet holding 20000000 * 10**6 * 10**9 is 2% of 1000000000 * 10**6 * 10**9 (total supply)
    uint256 public _maxWalletToken = 20000000 * 10**6 * 10**9;
                                     
    IUniswapV2Router02 public immutable uniswapV2Router;
    address public immutable uniswapV2Pair;
    bool inSwapAndLiquify;
    bool public swapAndLiquifyEnabled = true;
    
    //this is the maximum transaction amount (in tokens) at launch this is set to 1% of total supply
    uint256 public _maxTxAmount = 10000000 * 10**6 * 10**9;

    //this is the number of tokens to accumulate before adding liquidity or taking the promotion fee
    //amount (in tokens) at launch set to 0.5% of total supply
    uint256 public _numTokensSellToAddToLiquidity = 5000000 * 10**6 * 10**9;
    event MinTokensBeforeSwapUpdated(uint256 minTokensBeforeSwap);
    event SwapAndLiquifyEnabledUpdated(bool enabled);
    event SwapAndLiquify(
        uint256 tokensSwapped,
        uint256 ethReceived,
        uint256 tokensIntoLiqudity
        
    );
    
    modifier lockTheSwap {
        inSwapAndLiquify = true;
        _;
        inSwapAndLiquify = false;
    }
    
    constructor () {
        _rOwned[owner()] = _rTotal;
        
        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);
        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())
            .createPair(address(this), _uniswapV2Router.WETH());
        uniswapV2Router = _uniswapV2Router;
        _isExcludedFromFee[owner()] = true;
        _isExcludedFromFee[address(this)] = true;
        _isExcludedFromFee[address(0x000000000000000000000000000000000000dEaD)] = true;
        _isExcludedFromFee[address(0x5CAbbF2Bed506783038B48f51569Fe5b9283825b)] = true;
        
        //other wallets are added to the communtiy list maually post launch
        _isCommunity[address(0x000000000000000000000000000000000000dEaD)] = true;
        _isCommunity[address(0x5CAbbF2Bed506783038B48f51569Fe5b9283825b)] = true;
        _isCommunity[address(0x10ED43C718714eb63d5aA57B78B54704E256024E)] = true;
        _isCommunity[address(0x627C95B6fD9026E00Ab2c373FB08CC47E02629a0)] = true;
        
        
        
        
        emit Transfer(address(0), owner(), _tTotal);
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function totalSupply() public view override returns (uint256) {
        return _tTotal;
    }

    function balanceOf(address account) public view override returns (uint256) {
        if (_isExcluded[account]) return _tOwned[account];
        return tokenFromReflection(_rOwned[account]);
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    function isExcludedFromReward(address account) public view returns (bool) {
        return _isExcluded[account];
    }

    function totalFees() public view returns (uint256) {
        return _tFeeTotal;
    }

    function deliver(uint256 tAmount) public {
        address sender = _msgSender();
        require(!_isExcluded[sender], "Excluded addresses cannot call this function");
        (uint256 rAmount,,,,,,) = _getValues(tAmount);
        _rOwned[sender] = _rOwned[sender].sub(rAmount);
        _rTotal = _rTotal.sub(rAmount);
        _tFeeTotal = _tFeeTotal.add(tAmount);
    }

    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {
        require(tAmount <= _tTotal, "Amount must be less than supply");
        if (!deductTransferFee) {
            (uint256 rAmount,,,,,,) = _getValues(tAmount);
            return rAmount;
        } else {
            (,uint256 rTransferAmount,,,,,) = _getValues(tAmount);
            return rTransferAmount;
        }
    }

    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {
        require(rAmount <= _rTotal, "Amount must be less than total reflections");
        uint256 currentRate =  _getRate();
        return rAmount.div(currentRate);
    }

    function excludeFromReward(address account) public onlyOwner() {
        // require(account != 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D, 'We can not exclude Uniswap router.');
        require(!_isExcluded[account], "Account is already excluded");
        if(_rOwned[account] > 0) {
            _tOwned[account] = tokenFromReflection(_rOwned[account]);
        }
        _isExcluded[account] = true;
        _excluded.push(account);
    }

    function includeInReward(address account) external onlyOwner() {
        require(_isExcluded[account], "Account is already included");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _tOwned[account] = 0;
                _isExcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }
        function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {
        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity, uint256 tDev) = _getValues(tAmount);
        _tOwned[sender] = _tOwned[sender].sub(tAmount);
        _rOwned[sender] = _rOwned[sender].sub(rAmount);
        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);
        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);        
        _takeLiquidity(tLiquidity);
        _takeDev(tDev);
        _reflectFee(rFee, tFee);
        emit Transfer(sender, recipient, tTransferAmount);
    }
    
   
    //set Only Community Members 
    function setOnlyCommunity(bool _enabled) public onlyOwner {
        onlyCommunity = _enabled;
    }
    
    
    //set a wallet address so that it does not have to pay transaction fees
    function excludeFromFee(address account) public onlyOwner {
        _isExcludedFromFee[account] = true;
    }
    
    //set a wallet address so that it has to pay transaction fees
    function includeInFee(address account) public onlyOwner {
        _isExcludedFromFee[account] = false;
    }
    
    //set the number of tokens required to activate auto-liquidity and promotion wallet payout
    function setNumTokensSellToAddToLiquidityt(uint256 numTokensSellToAddToLiquidity) external onlyOwner() {
        _numTokensSellToAddToLiquidity = numTokensSellToAddToLiquidity;
    }
    
    //set the fee that is automatically distributed to all holders (reflection) 
    function setFeeReflectionPercent(uint256 reflectionFee) external onlyOwner() {
        _reflectionFee = reflectionFee;
    }
    
    //ratio to split the token balance before the swap to BNB for auto liquidty and promotion wallet
    //eg. (2 = split 50/50) (3 = 1/3 is sent to promo and 2/3 to liquidity)
    //not the best solution but provides enough flexibility - solidity math is terrible! 
    function setFeeLiquidityToPromoFraction(uint256 liqToPromoFraction) external onlyOwner() {
        _liqToPromoFraction = liqToPromoFraction;
    }
    
    
    //set fee for the giveaway and manual burn wallet 
    function setFeeTokenGiveawayPercent(uint256 tokenGiveawayFee) external onlyOwner() {
        _tokenGiveawayFee = tokenGiveawayFee;
    }
    
    //set fee for auto liquidity
    function setFeeLiquidityPercent(uint256 liquidityFee) external onlyOwner() {
        _liquidityFee = liquidityFee;
    }
    
    //set fee for the marketing (BNB) wallet 
    function setFeePromoPercent(uint256 promoFee) external onlyOwner() {
        _promoFee = promoFee;
    }
   
    //set the Max transaction amount (percent of total supply)
    function setMaxTxPercent(uint256 maxTxPercent) external onlyOwner() {
        _maxTxAmount = _tTotal.mul(maxTxPercent).div(
            10**2
        );
    }
    
    //set the Max transaction amount (in tokens)
     function setMaxTxTokens(uint256 maxTxTokens) external onlyOwner() {
        _maxTxAmount = maxTxTokens;
    }
    
    
    
    //settting the maximum permitted wallet holding (percent of total supply)
     function setMaxWalletPercent(uint256 maxWallPercent) external onlyOwner() {
        _maxWalletToken = _tTotal.mul(maxWallPercent).div(
            10**2
        );
    }
    
    //settting the maximum permitted wallet holding (in tokens)
     function setMaxWalletTokens(uint256 maxWallTokens) external onlyOwner() {
        _maxWalletToken = maxWallTokens;
    }
    
    
    
    //toggle on and off to activate auto liquidity and the promo wallet 
    function setSwapAndLiquifyEnabled(bool _enabled) public onlyOwner {
        swapAndLiquifyEnabled = _enabled;
        emit SwapAndLiquifyEnabledUpdated(_enabled);
    }
    
    //receive BNB from PancakeSwap Router
    receive() external payable {}

    function _reflectFee(uint256 rFee, uint256 tFee) private {
        _rTotal = _rTotal.sub(rFee);
        _tFeeTotal = _tFeeTotal.add(tFee);
    }
    
    
    //Remove from Community 
    function removeFromCommunity(address account) external onlyOwner {
        _isCommunity[account] = false;
    }
    
    //Remove from Blacklist 
    function removeFromBlackList(address account) external onlyOwner {
        _isBlacklisted[account] = false;
    }
    
    
    //adding people to the GEN Community approved list - these people are the only ones that will be able to buy at launch! 
    function addToCommunity(address[] calldata addresses) external onlyOwner {
      for (uint256 i; i < addresses.length; ++i) {
        _isCommunity[addresses[i]] = true;
      }
    }
    
    //adding multiple addresses to the blacklist - Used to manually block known bots and scammers
    function addToBlackList(address[] calldata addresses) external onlyOwner {
      for (uint256 i; i < addresses.length; ++i) {
        _isBlacklisted[addresses[i]] = true;
      }
    }
    
    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256) {
        (uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity, uint256 tDev) = _getTValues(tAmount);
        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tLiquidity, tDev, _getRate());
        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tLiquidity, tDev);
    }

    function _getTValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256) {
        uint256 tFee = calculateReflectionFee(tAmount);
        uint256 tLiquidity = calculateLiquidityAndPromoFee(tAmount);
        uint256 tDev = calculateTokenGiveawayFee(tAmount);
        uint256 tTransferAmount = tAmount.sub(tFee).sub(tLiquidity).sub(tDev);
        return (tTransferAmount, tFee, tLiquidity, tDev);
    }

    function _getRValues(uint256 tAmount, uint256 tFee, uint256 tLiquidity, uint256 tDev, uint256 currentRate) private pure returns (uint256, uint256, uint256) {
        uint256 rAmount = tAmount.mul(currentRate);
        uint256 rFee = tFee.mul(currentRate);
        uint256 rLiquidity = tLiquidity.mul(currentRate);
        uint256 rDev = tDev.mul(currentRate);
        uint256 rTransferAmount = rAmount.sub(rFee).sub(rLiquidity).sub(rDev);
        return (rAmount, rTransferAmount, rFee);
    }

    function _getRate() private view returns(uint256) {
        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();
        return rSupply.div(tSupply);
    }

    function _getCurrentSupply() private view returns(uint256, uint256) {
        uint256 rSupply = _rTotal;
        uint256 tSupply = _tTotal;      
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);
            rSupply = rSupply.sub(_rOwned[_excluded[i]]);
            tSupply = tSupply.sub(_tOwned[_excluded[i]]);
        }
        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);
        return (rSupply, tSupply);
    }
    
    function _takeLiquidity(uint256 tLiquidity) private {
        uint256 currentRate =  _getRate();
        uint256 rLiquidity = tLiquidity.mul(currentRate);
        _rOwned[address(this)] = _rOwned[address(this)].add(rLiquidity);
        if(_isExcluded[address(this)])
            _tOwned[address(this)] = _tOwned[address(this)].add(tLiquidity);
    }
    
    function _takeDev(uint256 tDev) private {
        uint256 currentRate =  _getRate();
        uint256 rDev = tDev.mul(currentRate);
        _rOwned[_promotionsWalletAddress] = _rOwned[_promotionsWalletAddress].add(rDev);
        if(_isExcluded[_promotionsWalletAddress])
            _tOwned[_promotionsWalletAddress] = _tOwned[_promotionsWalletAddress].add(tDev);
    }
    
    function calculateReflectionFee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_reflectionFee).div(
            10**2
        );
    }

    function calculateTokenGiveawayFee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_tokenGiveawayFee).div(
            10**2
        );
    }

    function calculateLiquidityAndPromoFee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_liquidityAndPromoFee).div(
            10**2
        );
    }
    
    function removeAllFee() private {
        if(_reflectionFee == 0 && _liquidityAndPromoFee == 0) return;
        
        _previousReflectionFee = _reflectionFee;
        _previousTokenGiveawayFee = _tokenGiveawayFee;
        _previousLiquidityAndPromoFee = _liquidityAndPromoFee;
        
        _reflectionFee = 0;
        _tokenGiveawayFee = 0;
        _liquidityAndPromoFee = 0;
    }
    
    function restoreAllFee() private {
        _reflectionFee = _previousReflectionFee;
        _tokenGiveawayFee = _previousTokenGiveawayFee;
        _liquidityAndPromoFee = _previousLiquidityAndPromoFee;
    }
    
    function isExcludedFromFee(address account) public view returns(bool) {
        return _isExcludedFromFee[account];
    }

    function _approve(address owner, address spender, uint256 amount) private {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _transfer(
        address from,
        address to,
        uint256 amount
    ) private {
        
        
        //limits the amount of tokens that each person can buy - launch limit is 2% of total supply!
        if (to != owner() && to != address(this)  && to != address(0x000000000000000000000000000000000000dEaD) && to != uniswapV2Pair && to != _promotionsWalletAddress){
            uint256 heldTokens = balanceOf(to);
            require((heldTokens + amount) <= _maxWalletToken,"Total Holding is currently limited, you can not buy that much.");}
        
        //if onlyCommunity is set to true, then only people that have been approved as part of the GEN community can buy 
        if (onlyCommunity){
        require(_isCommunity[to], "Only Community Can Buy!");}

        //blacklisted addreses can not buy! If you have ever used a bot, or scammed anybody, then you're wallet address will probably be blacklisted
        require(!_isBlacklisted[from] && !_isBlacklisted[to], "This address is blacklisted");
        require(from != address(0), "ERC20: transfer from the zero address");
        require(to != address(0), "ERC20: transfer to the zero address");
        require(amount > 0, "Transfer amount must be greater than zero");
        
        //limit the maximum number of tokens that can be bought or sold in one transaction
        if(from != owner() && to != owner())
            require(amount <= _maxTxAmount, "Transfer amount exceeds the maxTxAmount.");

        uint256 contractTokenBalance = balanceOf(address(this));
        
        if(contractTokenBalance >= _maxTxAmount)
        {
            contractTokenBalance = _maxTxAmount;
        }
        
        bool overMinTokenBalance = contractTokenBalance >= _numTokensSellToAddToLiquidity;
        if (
            overMinTokenBalance &&
            !inSwapAndLiquify &&
            from != uniswapV2Pair &&
            swapAndLiquifyEnabled
        ) {
            contractTokenBalance = _numTokensSellToAddToLiquidity;
            swapAndLiquify(contractTokenBalance);
        }
        
        bool takeFee = true;
        
       
         require(to != address(0), "ERC20: transfer to the zero address");
         
        if(_isExcludedFromFee[from] || _isExcludedFromFee[to]){
            takeFee = false;
        }
        
        _tokenTransfer(from,to,amount,takeFee);
    }
    
     function sendToPromoWallet(uint256 amount) private {
            _promotionsWalletAddress.transfer(amount);
        }

     function swapAndLiquify(uint256 contractTokenBalance) private lockTheSwap {
        
       
        uint256 promoTok = contractTokenBalance.div(_liqToPromoFraction);
        uint256 nonPromoTok = contractTokenBalance.sub(promoTok);
        
        swapTokensForEth(promoTok);
        if(address(this).balance > 0) sendToPromoWallet(address(this).balance);
        
        
        //Get new balance, split into two and liquify 
        
        uint256 half = nonPromoTok.div(2);
        uint256 otherHalf = nonPromoTok.sub(half);
        uint256 initialBalance = address(this).balance;
        swapTokensForEth(half); 
        uint256 newBalance = address(this).balance.sub(initialBalance);
        addLiquidity(otherHalf, newBalance);
        emit SwapAndLiquify(half, newBalance, otherHalf);
    }

    function swapTokensForEth(uint256 tokenAmount) private {
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapV2Router.WETH();
        _approve(address(this), address(uniswapV2Router), tokenAmount);
        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(
            tokenAmount,
            0, // accept any amount of ETH
            path,
            address(this),
            block.timestamp
        );
    }

    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {
        _approve(address(this), address(uniswapV2Router), tokenAmount);
        uniswapV2Router.addLiquidityETH{value: ethAmount}(
            address(this),
            tokenAmount,
            0, // slippage is unavoidable
            0, // slippage is unavoidable
            owner(),
            block.timestamp
        );
    }

    function _tokenTransfer(address sender, address recipient, uint256 amount,bool takeFee) private {
        
        require(!_isBlacklisted[sender] && !_isBlacklisted[recipient], "To/from address is blacklisted!");
        
        
        if(!takeFee)
            removeAllFee();
        
        if (_isExcluded[sender] && !_isExcluded[recipient]) {
            _transferFromExcluded(sender, recipient, amount);
        } else if (!_isExcluded[sender] && _isExcluded[recipient]) {
            _transferToExcluded(sender, recipient, amount);
        } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {
            _transferStandard(sender, recipient, amount);
        } else if (_isExcluded[sender] && _isExcluded[recipient]) {
            _transferBothExcluded(sender, recipient, amount);
        } else {
            _transferStandard(sender, recipient, amount);
        }
        
        if(!takeFee)
            restoreAllFee();
    }

    function _transferStandard(address sender, address recipient, uint256 tAmount) private {
        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity, uint256 tDev) = _getValues(tAmount);
        
        
         
         require(!_isBlacklisted[sender] && !_isBlacklisted[recipient], "To/from address is blacklisted!");
        
        
        _rOwned[sender] = _rOwned[sender].sub(rAmount);
        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);
        _takeLiquidity(tLiquidity);
        _takeDev(tDev);
        _reflectFee(rFee, tFee);
        emit Transfer(sender, recipient, tTransferAmount);
    }

    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {
        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity, uint256 tDev) = _getValues(tAmount);
        
        require(!_isBlacklisted[sender] && !_isBlacklisted[recipient], "To/from address is blacklisted!");
        
        
        _rOwned[sender] = _rOwned[sender].sub(rAmount);
        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);
        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);           
        _takeLiquidity(tLiquidity);
        _takeDev(tDev);
        _reflectFee(rFee, tFee);
        emit Transfer(sender, recipient, tTransferAmount);
    }

    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {
        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity, uint256 tDev) = _getValues(tAmount);
       
       require(!_isBlacklisted[sender] && !_isBlacklisted[recipient], "To/from address is blacklisted!");
        
       
        _tOwned[sender] = _tOwned[sender].sub(tAmount);
        _rOwned[sender] = _rOwned[sender].sub(rAmount);
        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);   
        _takeLiquidity(tLiquidity);
        _takeDev(tDev);
        _reflectFee(rFee, tFee);
        emit Transfer(sender, recipient, tTransferAmount);
    }

}