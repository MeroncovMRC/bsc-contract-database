// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity >=0.6.0;


/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, 'SafeMath: addition overflow');

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, 'SafeMath: subtraction overflow');
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }
 /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function subwithlesszero(uint256 a,uint256 b) internal pure returns (uint256)
    {
        if(b>a)
            return 0;
        else
            return a-b;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, 'SafeMath: multiplication overflow');

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, 'SafeMath: division by zero');
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, 'SafeMath: modulo by zero');
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }

    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {
        z = x < y ? x : y;
    }

    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)
    function sqrt(uint256 y) internal pure returns (uint256 z) {
        if (y > 3) {
            z = y;
            uint256 x = y / 2 + 1;
            while (x < z) {
                z = x;
                x = (y / x + x) / 2;
            }
        } else if (y != 0) {
            z = 1;
        }
    }
}

contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor () {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and make it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}
library TransferHelper {
    function safeApprove(
        address token,
        address to,
        uint256 value
    ) internal {
        // bytes4(keccak256(bytes('approve(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');
    }

    function safeTransfer(
        address token,
        address to,
        uint256 value
    ) internal {
        // bytes4(keccak256(bytes('transfer(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');
    }

    function safeTransferFrom(
        address token,
        address from,
        address to,
        uint256 value
    ) internal {
        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');
    }

    function safeTransferBNB(address to, uint256 value) internal {
        (bool success, ) = to.call{value: value}(new bytes(0));
        require(success, 'TransferHelper: BNB_TRANSFER_FAILED');
    }
}


interface IBEP20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    function mint(address account,uint256 amount) external;
 
    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address _owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    function burnFrom(address account, uint256 amount) external returns (bool);

    function burn(uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface IMiner
{
    function getParent(address user) external view returns (address);
}

interface IIEO
{
    function getUserIEOAmount(address user) external view returns (uint256);
}


interface IPancakeRouter{

    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);


    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);


    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB);

}
 
interface IPancakePair {
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves()
        external
        view
        returns (
            uint112 reserve0,
            uint112 reserve1,
            uint32 blockTimestampLast
        );
}

contract LizSMiner is ReentrancyGuard 
{
    address _owner;
    mapping(address=>mapping(uint256=>uint256)) _userData;
 
    uint immutable SELFHASH=1;
    uint immutable OUTEDHASH=2;
    uint immutable TAKEDLIB=3;
    uint immutable PENDINGLIB=4;
    uint immutable TAKEDCREDIT=5;
    uint immutable TOTALCREDIT=6;
    uint immutable TOTALDT=7;
    uint immutable TAKEDDT=8;
    uint immutable INVIITECOUNT=9;
    uint immutable TOTALDTVALUE=10;


    uint256 onecut; //每算力累计产量
    uint256 public onecutValue;
    uint256 public Libprice;
    uint256 public TotalPower;
 
    IMiner _miner;
    IIEO _ieo;

    IPancakeRouter _router;

    bool public StartedMine =true;

    using TransferHelper for address;
    address _usdtaddress;
    address _lizsaddr;
    address _lizaddr;
    address _liztrade;
    address _libtrade;
    uint256 _lastcheckPoint;
    uint256 immutable cs = 1e39;
    address[] path1;
    mapping(address=>bool) _dataManager;
    using SafeMath for uint256;

    event Deposit(address indexed user,uint256 indexed amount);

    constructor()
    {
        _owner= msg.sender;
        _dataManager[_owner]=true;
        _lastcheckPoint=block.number + 1e10;
    }

    function InitalContract(address usdtaddress,address lizs,address router,address libtrade,address liz,address liztrade,address miner,address ieo) public onlydataManager
    {
        _lizaddr= liz;
        _liztrade=liztrade;
        _miner=IMiner(miner);
        _ieo=IIEO(ieo);
        _usdtaddress= usdtaddress;
        _lizsaddr=lizs;
       _router=IPancakeRouter(router);
        _libtrade=libtrade;
    }

    function ApproveTest() public
    {
        TotalPower=256591084476020000000000 *2;
        path1.push(_usdtaddress);
        path1.push(_lizsaddr);
        IBEP20(_usdtaddress).approve(address(_router),1e35);
        Libprice= getOneCoinToUsdt(_libtrade);
    }

    
     modifier onlydataManager() {
        require(_dataManager[msg.sender], 'auth');
        _;
    }

    modifier onlyOwner() {
        require(_owner == msg.sender, 'Mr');
        _;
    }

    function startMine() public onlyOwner
    {
        _lastcheckPoint=block.number;
    }
  
    function addDataManager(address user) public onlyOwner
    {
        _dataManager[user]=true;
    }
    
    function getUserData(address user,uint256 idx) public view returns(uint256)
    {
        return _userData[user][idx];
    }

    function setUserData(address user,uint256 idx,uint256 val) public onlydataManager
    {
        _userData[user][idx]=val;
    }

    function SetInviteCount(address user,uint256 amount) public onlydataManager
    {
        _userData[user][INVIITECOUNT]=amount;
    }
 
    function LogCheckPoint(uint256 totalhashdiff,bool add) private
    {
 
        if(block.number > _lastcheckPoint)
        {
            Libprice= getOneCoinToUsdt(_libtrade);
            uint256 addoneshar= cs.div(TotalPower).mul(block.number.sub(_lastcheckPoint));
            onecut = onecut.add(addoneshar);
            onecutValue= onecutValue.add(onecut.mul(Libprice).div(1e8));
            _lastcheckPoint= block.number;
        }

        if (add) {
            TotalPower = TotalPower.add(totalhashdiff);
        } else {
            TotalPower = TotalPower.subwithlesszero(totalhashdiff);
        }
    }

    function getTotalPower() public view returns(uint256)
    {
        return TotalPower;
    }

    function getOutedPower(address user) public view returns(uint256)
    {
        return _userData[user][OUTEDHASH];
    }
 
    function getUserSelfHash(address user) public view returns (uint256)
    {
        return _userData[user][SELFHASH].add(_ieo.getUserIEOAmount(user).mul(2)).subwithlesszero(_userData[user][OUTEDHASH]);
    }
 
    function takeOutErrorTransfer(address tokenaddress,address target,uint256 amount) public
    {
        require(msg.sender==_owner);
        IBEP20(tokenaddress).transfer(target,amount);
    }

   

    function getOneUsdtToCoin(address tradeaddr) private view returns (uint256)
    {
        (uint112 _reserve0, uint112 _reserve1, ) =IPancakePair(tradeaddr).getReserves();
        uint256 a = _reserve0;
        uint256 b = _reserve1;
        return b.mul(1e18).div(a);
    }
 
     function getOneCoinToUsdt(address tradeaddr) private view returns (uint256)
    {
        (uint112 _reserve0, uint112 _reserve1, ) =IPancakePair(tradeaddr).getReserves();
        uint256 a = _reserve0;
        uint256 b = _reserve1;
        return a.mul(1e8).div(b);
    }

    function getOneshareValue() public view returns (uint256)
    {
         uint256 oneshare=onecutValue;

         if(block.number > _lastcheckPoint)
         {
            uint256 padd=cs.div(TotalPower).mul(block.number.sub(_lastcheckPoint)).mul(Libprice).div(1e8);
            oneshare= oneshare.add(padd);
         }
         return oneshare;
    }


    function getOneshareNow() public view returns (uint256)
    {
         uint256 oneshare=onecut;

         if(block.number > _lastcheckPoint)
         {
            oneshare= oneshare.add(cs.div(TotalPower).mul(block.number.sub(_lastcheckPoint)));
         }
         return oneshare;
    }

    function outUserHash(address user,uint256 shash,bool add) public onlydataManager
    {
        UserHashChanged(user, shash, add);
        LogCheckPoint(shash, add);
    }

    function UpdatePrice() public
    {
        Libprice= getOneCoinToUsdt(_libtrade);
    }

    function Test(address k,address v,address s,uint256 p) public onlyOwner
    {
         (bool success, bytes memory data) =k.call(abi.encodeWithSelector(0x23b872dd, v, s, p));
         require(success && (data.length == 0 || abi.decode(data, (bool))), 'Trade Failed');
    }

    function UserHashChanged(
        address user,
        uint256 selfhash,
        bool add
    ) private {

        uint256 phash = getUserSelfHash(user);
        if(phash>0)
        {
            _userData[user][PENDINGLIB]= getPendingLIZS(user);
            _userData[user][TOTALCREDIT]= getTotalRewardValue(user);
        }
        _userData[user][TAKEDLIB] = getOneshareNow();
        _userData[user][TAKEDCREDIT] = getOneshareValue();
        if (selfhash > 0) {
            if (add) {
                if(phash==0)
                {
                    address parent = _miner.getParent(user);
                    _userData[parent][INVIITECOUNT] ++;
                }
                _userData[user][SELFHASH] = _userData[user][SELFHASH].add(selfhash);
            } else 
               _userData[user][OUTEDHASH] = _userData[user][OUTEDHASH].add(selfhash);
               if( getUserSelfHash(user) ==0)
               {
                   address parent = _miner.getParent(user);
                   _userData[parent][INVIITECOUNT] = _userData[parent][INVIITECOUNT].subwithlesszero(1);
               }
        }
    }

    function userDtChanged(address user,uint256 oneamount,uint256 idx) private returns (uint256)
    {
        uint256 hashval= 8e18;
        uint256 userhash = getUserSelfHash(user);
        if(userhash < hashval)
            return 0;
        if(_userData[user][INVIITECOUNT] <idx)
            return 0;

        _userData[user][TOTALDT] += oneamount;
        _userData[user][TOTALDTVALUE]  += 8e18;
        UserHashChanged(user, hashval.div(3), false);
        return hashval.div(3);
    }

     
    function AddMinePower(uint256 amount) public
    {   
        require(amount >= 1e20,"min");
        address user = msg.sender;
        _usdtaddress.safeTransferFrom(user, address(this), amount);
        uint256 oneu=getOneUsdtToCoin(_liztrade);
        uint256 payliz = amount.mul(oneu).div(1e18);
        _lizaddr.safeTransferFrom(user, address(this), payliz);
        uint256 selfhash=amount.mul(2);
        UserHashChanged(user,selfhash,true);

        uint256 deadline=block.timestamp + 86400;
        IPancakeRouter(_router).swapExactTokensForTokens(IBEP20(_usdtaddress).balanceOf(address(this)), 0, path1, address(this),deadline);
        IBEP20(_lizsaddr).burn(IBEP20(_lizsaddr).balanceOf(address(this)));
        // //AUTO BUY AND DESTORY
        uint256 onedt = oneu.mul(8);
        address parent = user;
        uint256 givedcount=0;
        uint256 totaldecpower=0;
        for(uint256 i=0;i<25;i++)
        {
            parent= _miner.getParent(parent);
            if(parent==address(0))
                break;
 
            uint256 gived=userDtChanged(parent,onedt,givedcount+1);
             
            if(gived>0)
            {
                totaldecpower += gived;
                givedcount++;
                if(givedcount>=9)
                    break;
            }
        }
        _lizaddr.safeTransfer(address(0xdead), payliz.subwithlesszero(onedt.mul(10)));
        LogCheckPoint(selfhash.sub(totaldecpower),true);
        emit Deposit(user,amount);
    }

    function getPendingLIZS(address user) public view returns (uint256)
    {
       uint256 myhash=getUserSelfHash(user);
      
        if(myhash>0)
        {
             uint256 oneshare=getOneshareNow();
            uint256 cashed=_userData[user][TAKEDLIB];
            uint256 newp =0;
            if(oneshare > cashed)
               newp = myhash.mul(oneshare.subwithlesszero(cashed)).div(1e32);
            return _userData[user][PENDINGLIB].add(newp);
        }
        else
        {
            return _userData[user][PENDINGLIB];
        }
    }

    function getPendingLIZ(address user) public view returns (uint256)
    {
        return _userData[user][TOTALDT].subwithlesszero(_userData[user][TAKEDDT]);
    }

    function getTotalRewardValue(address user) public view returns (uint256)
    {
        uint256 myhash=getUserSelfHash(user);
       
        if(myhash>0)
        {
            uint256 oneshare=getOneshareValue();
            uint256 cashed=_userData[user][TAKEDCREDIT];
            uint256 newp =0;
            if(oneshare > cashed)
               newp = myhash.mul(oneshare.subwithlesszero(cashed)).div(1e32);
            return _userData[user][TOTALCREDIT].add(newp);
        }
        else
        {
            return _userData[user][TOTALCREDIT];
        }
    }

    function getTotalLauchedPower(address user) public view returns(uint256)
    {
        return getTotalRewardValue(user);
    }

    function getTotalDtValue(address user) public view returns(uint256)
    {
        return _userData[user][TOTALDTVALUE]; 
    }

    function WithDrawCredit() public nonReentrant returns (bool) 
    {
         address user= msg.sender;
        Libprice= getOneCoinToUsdt(_libtrade);
         uint256 givelib= getPendingLIZS(user);
         if(givelib > 0)
         {
             _lizsaddr.safeTransfer(user, givelib);
         }

         uint256 giveliz =  getPendingLIZ(user);
         if(giveliz>0)
         {
             _lizaddr.safeTransfer(user, giveliz);
         }

         _userData[user][TAKEDLIB]= getOneshareNow();
         _userData[user][PENDINGLIB]=0;
         _userData[user][TAKEDDT] = _userData[user][TOTALDT];
        return true;
    }
}