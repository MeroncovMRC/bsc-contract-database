// File: @openzeppelin/contracts/utils/introspection/IERC165.sol


// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC165 standard, as defined in the
 * https://eips.ethereum.org/EIPS/eip-165[EIP].
 *
 * Implementers can declare support of contract interfaces, which can then be
 * queried by others ({ERC165Checker}).
 *
 * For an implementation, see {ERC165}.
 */
interface IERC165 {
    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

// File: @openzeppelin/contracts/utils/introspection/ERC165.sol


// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)

pragma solidity ^0.8.0;


/**
 * @dev Implementation of the {IERC165} interface.
 *
 * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
 * for the additional interface id that will be supported. For example:
 *
 * ```solidity
 * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 * }
 * ```
 *
 * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
 */
abstract contract ERC165 is IERC165 {
    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IERC165).interfaceId;
    }
}

// File: @openzeppelin/contracts/utils/math/Math.sol


// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)

pragma solidity ^0.8.0;

/**
 * @dev Standard math utilities missing in the Solidity language.
 */
library Math {
    enum Rounding {
        Down, // Toward negative infinity
        Up, // Toward infinity
        Zero // Toward zero
    }

    /**
     * @dev Returns the largest of two numbers.
     */
    function max(uint256 a, uint256 b) internal pure returns (uint256) {
        return a > b ? a : b;
    }

    /**
     * @dev Returns the smallest of two numbers.
     */
    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }

    /**
     * @dev Returns the average of two numbers. The result is rounded towards
     * zero.
     */
    function average(uint256 a, uint256 b) internal pure returns (uint256) {
        // (a + b) / 2 can overflow.
        return (a & b) + (a ^ b) / 2;
    }

    /**
     * @dev Returns the ceiling of the division of two numbers.
     *
     * This differs from standard division with `/` in that it rounds up instead
     * of rounding down.
     */
    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
        // (a + b - 1) / b can overflow on addition, so we distribute.
        return a == 0 ? 0 : (a - 1) / b + 1;
    }

    /**
     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)
     * with further edits by Uniswap Labs also under MIT license.
     */
    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 denominator
    ) internal pure returns (uint256 result) {
        unchecked {
            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
            // variables such that product = prod1 * 2^256 + prod0.
            uint256 prod0; // Least significant 256 bits of the product
            uint256 prod1; // Most significant 256 bits of the product
            assembly {
                let mm := mulmod(x, y, not(0))
                prod0 := mul(x, y)
                prod1 := sub(sub(mm, prod0), lt(mm, prod0))
            }

            // Handle non-overflow cases, 256 by 256 division.
            if (prod1 == 0) {
                return prod0 / denominator;
            }

            // Make sure the result is less than 2^256. Also prevents denominator == 0.
            require(denominator > prod1);

            ///////////////////////////////////////////////
            // 512 by 256 division.
            ///////////////////////////////////////////////

            // Make division exact by subtracting the remainder from [prod1 prod0].
            uint256 remainder;
            assembly {
                // Compute remainder using mulmod.
                remainder := mulmod(x, y, denominator)

                // Subtract 256 bit number from 512 bit number.
                prod1 := sub(prod1, gt(remainder, prod0))
                prod0 := sub(prod0, remainder)
            }

            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
            // See https://cs.stackexchange.com/q/138556/92363.

            // Does not overflow because the denominator cannot be zero at this stage in the function.
            uint256 twos = denominator & (~denominator + 1);
            assembly {
                // Divide denominator by twos.
                denominator := div(denominator, twos)

                // Divide [prod1 prod0] by twos.
                prod0 := div(prod0, twos)

                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
                twos := add(div(sub(0, twos), twos), 1)
            }

            // Shift in bits from prod1 into prod0.
            prod0 |= prod1 * twos;

            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
            // four bits. That is, denominator * inv = 1 mod 2^4.
            uint256 inverse = (3 * denominator) ^ 2;

            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
            // in modular arithmetic, doubling the correct bits in each step.
            inverse *= 2 - denominator * inverse; // inverse mod 2^8
            inverse *= 2 - denominator * inverse; // inverse mod 2^16
            inverse *= 2 - denominator * inverse; // inverse mod 2^32
            inverse *= 2 - denominator * inverse; // inverse mod 2^64
            inverse *= 2 - denominator * inverse; // inverse mod 2^128
            inverse *= 2 - denominator * inverse; // inverse mod 2^256

            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
            // is no longer required.
            result = prod0 * inverse;
            return result;
        }
    }

    /**
     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.
     */
    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 denominator,
        Rounding rounding
    ) internal pure returns (uint256) {
        uint256 result = mulDiv(x, y, denominator);
        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
            result += 1;
        }
        return result;
    }

    /**
     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.
     *
     * Inspired by Henry S. Warren, Jr.'s "Hacker's Delight" (Chapter 11).
     */
    function sqrt(uint256 a) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
        //
        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
        //
        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
        //
        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
        uint256 result = 1 << (log2(a) >> 1);

        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
        // into the expected uint128 result.
        unchecked {
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            return min(result, a / result);
        }
    }

    /**
     * @notice Calculates sqrt(a), following the selected rounding direction.
     */
    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
        unchecked {
            uint256 result = sqrt(a);
            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);
        }
    }

    /**
     * @dev Return the log in base 2, rounded down, of a positive value.
     * Returns 0 if given 0.
     */
    function log2(uint256 value) internal pure returns (uint256) {
        uint256 result = 0;
        unchecked {
            if (value >> 128 > 0) {
                value >>= 128;
                result += 128;
            }
            if (value >> 64 > 0) {
                value >>= 64;
                result += 64;
            }
            if (value >> 32 > 0) {
                value >>= 32;
                result += 32;
            }
            if (value >> 16 > 0) {
                value >>= 16;
                result += 16;
            }
            if (value >> 8 > 0) {
                value >>= 8;
                result += 8;
            }
            if (value >> 4 > 0) {
                value >>= 4;
                result += 4;
            }
            if (value >> 2 > 0) {
                value >>= 2;
                result += 2;
            }
            if (value >> 1 > 0) {
                result += 1;
            }
        }
        return result;
    }

    /**
     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.
     * Returns 0 if given 0.
     */
    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
        unchecked {
            uint256 result = log2(value);
            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);
        }
    }

    /**
     * @dev Return the log in base 10, rounded down, of a positive value.
     * Returns 0 if given 0.
     */
    function log10(uint256 value) internal pure returns (uint256) {
        uint256 result = 0;
        unchecked {
            if (value >= 10**64) {
                value /= 10**64;
                result += 64;
            }
            if (value >= 10**32) {
                value /= 10**32;
                result += 32;
            }
            if (value >= 10**16) {
                value /= 10**16;
                result += 16;
            }
            if (value >= 10**8) {
                value /= 10**8;
                result += 8;
            }
            if (value >= 10**4) {
                value /= 10**4;
                result += 4;
            }
            if (value >= 10**2) {
                value /= 10**2;
                result += 2;
            }
            if (value >= 10**1) {
                result += 1;
            }
        }
        return result;
    }

    /**
     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.
     * Returns 0 if given 0.
     */
    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
        unchecked {
            uint256 result = log10(value);
            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);
        }
    }

    /**
     * @dev Return the log in base 256, rounded down, of a positive value.
     * Returns 0 if given 0.
     *
     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.
     */
    function log256(uint256 value) internal pure returns (uint256) {
        uint256 result = 0;
        unchecked {
            if (value >> 128 > 0) {
                value >>= 128;
                result += 16;
            }
            if (value >> 64 > 0) {
                value >>= 64;
                result += 8;
            }
            if (value >> 32 > 0) {
                value >>= 32;
                result += 4;
            }
            if (value >> 16 > 0) {
                value >>= 16;
                result += 2;
            }
            if (value >> 8 > 0) {
                result += 1;
            }
        }
        return result;
    }

    /**
     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.
     * Returns 0 if given 0.
     */
    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
        unchecked {
            uint256 result = log256(value);
            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);
        }
    }
}

// File: @openzeppelin/contracts/utils/Strings.sol


// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)

pragma solidity ^0.8.0;


/**
 * @dev String operations.
 */
library Strings {
    bytes16 private constant _SYMBOLS = "0123456789abcdef";
    uint8 private constant _ADDRESS_LENGTH = 20;

    /**
     * @dev Converts a `uint256` to its ASCII `string` decimal representation.
     */
    function toString(uint256 value) internal pure returns (string memory) {
        unchecked {
            uint256 length = Math.log10(value) + 1;
            string memory buffer = new string(length);
            uint256 ptr;
            /// @solidity memory-safe-assembly
            assembly {
                ptr := add(buffer, add(32, length))
            }
            while (true) {
                ptr--;
                /// @solidity memory-safe-assembly
                assembly {
                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
                }
                value /= 10;
                if (value == 0) break;
            }
            return buffer;
        }
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
     */
    function toHexString(uint256 value) internal pure returns (string memory) {
        unchecked {
            return toHexString(value, Math.log256(value) + 1);
        }
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
     */
    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = "0";
        buffer[1] = "x";
        for (uint256 i = 2 * length + 1; i > 1; --i) {
            buffer[i] = _SYMBOLS[value & 0xf];
            value >>= 4;
        }
        require(value == 0, "Strings: hex length insufficient");
        return string(buffer);
    }

    /**
     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.
     */
    function toHexString(address addr) internal pure returns (string memory) {
        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);
    }
}

// File: @openzeppelin/contracts/utils/Context.sol


// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)

pragma solidity ^0.8.0;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

// File: @openzeppelin/contracts/security/Pausable.sol


// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)

pragma solidity ^0.8.0;


/**
 * @dev Contract module which allows children to implement an emergency stop
 * mechanism that can be triggered by an authorized account.
 *
 * This module is used through inheritance. It will make available the
 * modifiers `whenNotPaused` and `whenPaused`, which can be applied to
 * the functions of your contract. Note that they will not be pausable by
 * simply including this module, only once the modifiers are put in place.
 */
abstract contract Pausable is Context {
    /**
     * @dev Emitted when the pause is triggered by `account`.
     */
    event Paused(address account);

    /**
     * @dev Emitted when the pause is lifted by `account`.
     */
    event Unpaused(address account);

    bool private _paused;

    /**
     * @dev Initializes the contract in unpaused state.
     */
    constructor() {
        _paused = false;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     *
     * Requirements:
     *
     * - The contract must not be paused.
     */
    modifier whenNotPaused() {
        _requireNotPaused();
        _;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is paused.
     *
     * Requirements:
     *
     * - The contract must be paused.
     */
    modifier whenPaused() {
        _requirePaused();
        _;
    }

    /**
     * @dev Returns true if the contract is paused, and false otherwise.
     */
    function paused() public view virtual returns (bool) {
        return _paused;
    }

    /**
     * @dev Throws if the contract is paused.
     */
    function _requireNotPaused() internal view virtual {
        require(!paused(), "Pausable: paused");
    }

    /**
     * @dev Throws if the contract is not paused.
     */
    function _requirePaused() internal view virtual {
        require(paused(), "Pausable: not paused");
    }

    /**
     * @dev Triggers stopped state.
     *
     * Requirements:
     *
     * - The contract must not be paused.
     */
    function _pause() internal virtual whenNotPaused {
        _paused = true;
        emit Paused(_msgSender());
    }

    /**
     * @dev Returns to normal state.
     *
     * Requirements:
     *
     * - The contract must be paused.
     */
    function _unpause() internal virtual whenPaused {
        _paused = false;
        emit Unpaused(_msgSender());
    }
}

// File: @openzeppelin/contracts/access/IAccessControl.sol


// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)

pragma solidity ^0.8.0;

/**
 * @dev External interface of AccessControl declared to support ERC165 detection.
 */
interface IAccessControl {
    /**
     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`
     *
     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
     * {RoleAdminChanged} not being emitted signaling this.
     *
     * _Available since v3.1._
     */
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);

    /**
     * @dev Emitted when `account` is granted `role`.
     *
     * `sender` is the account that originated the contract call, an admin role
     * bearer except when using {AccessControl-_setupRole}.
     */
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);

    /**
     * @dev Emitted when `account` is revoked `role`.
     *
     * `sender` is the account that originated the contract call:
     *   - if using `revokeRole`, it is the admin role bearer
     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
     */
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(bytes32 role, address account) external view returns (bool);

    /**
     * @dev Returns the admin role that controls `role`. See {grantRole} and
     * {revokeRole}.
     *
     * To change a role's admin, use {AccessControl-_setRoleAdmin}.
     */
    function getRoleAdmin(bytes32 role) external view returns (bytes32);

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function grantRole(bytes32 role, address account) external;

    /**
     * @dev Revokes `role` from `account`.
     *
     * If `account` had been granted `role`, emits a {RoleRevoked} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function revokeRole(bytes32 role, address account) external;

    /**
     * @dev Revokes `role` from the calling account.
     *
     * Roles are often managed via {grantRole} and {revokeRole}: this function's
     * purpose is to provide a mechanism for accounts to lose their privileges
     * if they are compromised (such as when a trusted device is misplaced).
     *
     * If the calling account had been granted `role`, emits a {RoleRevoked}
     * event.
     *
     * Requirements:
     *
     * - the caller must be `account`.
     */
    function renounceRole(bytes32 role, address account) external;
}

// File: @openzeppelin/contracts/access/AccessControl.sol


// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)

pragma solidity ^0.8.0;





/**
 * @dev Contract module that allows children to implement role-based access
 * control mechanisms. This is a lightweight version that doesn't allow enumerating role
 * members except through off-chain means by accessing the contract event logs. Some
 * applications may benefit from on-chain enumerability, for those cases see
 * {AccessControlEnumerable}.
 *
 * Roles are referred to by their `bytes32` identifier. These should be exposed
 * in the external API and be unique. The best way to achieve this is by
 * using `public constant` hash digests:
 *
 * ```
 * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");
 * ```
 *
 * Roles can be used to represent a set of permissions. To restrict access to a
 * function call, use {hasRole}:
 *
 * ```
 * function foo() public {
 *     require(hasRole(MY_ROLE, msg.sender));
 *     ...
 * }
 * ```
 *
 * Roles can be granted and revoked dynamically via the {grantRole} and
 * {revokeRole} functions. Each role has an associated admin role, and only
 * accounts that have a role's admin role can call {grantRole} and {revokeRole}.
 *
 * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
 * that only accounts with this role will be able to grant or revoke other
 * roles. More complex role relationships can be created by using
 * {_setRoleAdmin}.
 *
 * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to
 * grant and revoke this role. Extra precautions should be taken to secure
 * accounts that have been granted it.
 */
abstract contract AccessControl is Context, IAccessControl, ERC165 {
    struct RoleData {
        mapping(address => bool) members;
        bytes32 adminRole;
    }

    mapping(bytes32 => RoleData) private _roles;

    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;

    /**
     * @dev Modifier that checks that an account has a specific role. Reverts
     * with a standardized message including the required role.
     *
     * The format of the revert reason is given by the following regular expression:
     *
     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/
     *
     * _Available since v4.1._
     */
    modifier onlyRole(bytes32 role) {
        _checkRole(role);
        _;
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);
    }

    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {
        return _roles[role].members[account];
    }

    /**
     * @dev Revert with a standard message if `_msgSender()` is missing `role`.
     * Overriding this function changes the behavior of the {onlyRole} modifier.
     *
     * Format of the revert message is described in {_checkRole}.
     *
     * _Available since v4.6._
     */
    function _checkRole(bytes32 role) internal view virtual {
        _checkRole(role, _msgSender());
    }

    /**
     * @dev Revert with a standard message if `account` is missing `role`.
     *
     * The format of the revert reason is given by the following regular expression:
     *
     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/
     */
    function _checkRole(bytes32 role, address account) internal view virtual {
        if (!hasRole(role, account)) {
            revert(
                string(
                    abi.encodePacked(
                        "AccessControl: account ",
                        Strings.toHexString(account),
                        " is missing role ",
                        Strings.toHexString(uint256(role), 32)
                    )
                )
            );
        }
    }

    /**
     * @dev Returns the admin role that controls `role`. See {grantRole} and
     * {revokeRole}.
     *
     * To change a role's admin, use {_setRoleAdmin}.
     */
    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {
        return _roles[role].adminRole;
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     *
     * May emit a {RoleGranted} event.
     */
    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {
        _grantRole(role, account);
    }

    /**
     * @dev Revokes `role` from `account`.
     *
     * If `account` had been granted `role`, emits a {RoleRevoked} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     *
     * May emit a {RoleRevoked} event.
     */
    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {
        _revokeRole(role, account);
    }

    /**
     * @dev Revokes `role` from the calling account.
     *
     * Roles are often managed via {grantRole} and {revokeRole}: this function's
     * purpose is to provide a mechanism for accounts to lose their privileges
     * if they are compromised (such as when a trusted device is misplaced).
     *
     * If the calling account had been revoked `role`, emits a {RoleRevoked}
     * event.
     *
     * Requirements:
     *
     * - the caller must be `account`.
     *
     * May emit a {RoleRevoked} event.
     */
    function renounceRole(bytes32 role, address account) public virtual override {
        require(account == _msgSender(), "AccessControl: can only renounce roles for self");

        _revokeRole(role, account);
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event. Note that unlike {grantRole}, this function doesn't perform any
     * checks on the calling account.
     *
     * May emit a {RoleGranted} event.
     *
     * [WARNING]
     * ====
     * This function should only be called from the constructor when setting
     * up the initial roles for the system.
     *
     * Using this function in any other way is effectively circumventing the admin
     * system imposed by {AccessControl}.
     * ====
     *
     * NOTE: This function is deprecated in favor of {_grantRole}.
     */
    function _setupRole(bytes32 role, address account) internal virtual {
        _grantRole(role, account);
    }

    /**
     * @dev Sets `adminRole` as ``role``'s admin role.
     *
     * Emits a {RoleAdminChanged} event.
     */
    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
        bytes32 previousAdminRole = getRoleAdmin(role);
        _roles[role].adminRole = adminRole;
        emit RoleAdminChanged(role, previousAdminRole, adminRole);
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * Internal function without access restriction.
     *
     * May emit a {RoleGranted} event.
     */
    function _grantRole(bytes32 role, address account) internal virtual {
        if (!hasRole(role, account)) {
            _roles[role].members[account] = true;
            emit RoleGranted(role, account, _msgSender());
        }
    }

    /**
     * @dev Revokes `role` from `account`.
     *
     * Internal function without access restriction.
     *
     * May emit a {RoleRevoked} event.
     */
    function _revokeRole(bytes32 role, address account) internal virtual {
        if (hasRole(role, account)) {
            _roles[role].members[account] = false;
            emit RoleRevoked(role, account, _msgSender());
        }
    }
}

// File: @openzeppelin/contracts/token/ERC20/IERC20.sol


// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `from` to `to` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
}

// File: PandAIEarnV1.sol


/*
==================================================================================================================================
==== Terms of Use
==================================================================================================================================

1. INTRODUCTION
PandAI Corp Ltd. (collectively, “we,” “our,” “us”, or “PandAI” ) provide the following Terms of Use that, as they may be modified from time to time by PandAI in its sole discretion (the “Terms”) apply to our users (“you” or “User(s)”) and govern each User’s access to, and use of, PandAI’s services as well as our website(s), any software, programs, documentation, tools, hardware, internet-based services, components, and any updates (including software maintenance, service information, help content, bug fixes or maintenance releases) provided to you by PandAI, directly or indirectly, through our website, or any other online services we provide (each a “Service” and collectively the “Services”).
PLEASE CAREFULLY REVIEW THESE TERMS BEFORE USING, OR CONTINUING TO USE, ANY OF PANDAI’ SERVICES. THE TERMS INCLUDE IMPORTANT INFORMATION ABOUT YOUR RELATIONSHIP WITH PANDAI, INCLUDING MANDATORY ARBITRATION OF DISPUTES BETWEEN YOU AND PANDAI INSTEAD OF CLASS ACTIONS OR JURY TRIALS THE SERVICES ARE PROVIDED SOLELY FOR USE BY YOU, AND YOUR USE OF THE SERVICES IS EXPRESSLY CONDITIONED ON YOUR CONSENT TO, AND COMPLIANCE WITH, THE TERMS. BY ACCESSING OR USING OUR SERVICES, YOU AGREE TO BE BOUND BY THE TERMS. IF YOU DO NOT AGREE TO ANY OF THE PROVISIONS OF THESE TERMS YOU SHOULD IMMEDIATELY STOP USING THE SERVICES OR DO NOT START TO USE OUR SERVICES. IN ADDITION, READ OUR PRIVACY POLICY LOCATED AT: https://app.pandai.io/Privacy_Policy.pdf. WE ENCOURAGE YOU TO READ THE TERMS CAREFULLY AND USE THEM TO MAKE INFORMED DECISIONS.

TERMS APPLICABLE TO ALL USERS RESIDING IN THE UNITED STATES
IF YOU RESIDE IN THE UNITED STATES AND ARE NOT REGISTERED WITH PANDAI AS ACCREDITED INVESTORS (A “NON-ACCREDITED U.S. USER”) THE EARN SERVICE IS FORBIDEN TO USE. HOWEVER, YOU MAY USE OTHER SERVICES PROVIDED BY PANDAI.
IF YOU ARE A NON-ACCREDITED U.S. USER, ANY DIGITAL ASSET TRANSFERRED TO PANDAI WILL NOT EARN REWARDS AND NOT HAVE ACCESS TO THE EARN SERVICE.
IF YOU RESIDE IN THE UNITED STATES AND ARE REGISTERED WITH PANDAI AS AN ACCREDITED INVESTOR (AN “ACCREDITED U.S. USER”), YOU SHALL HAVE ACCESS TO THE EARN SERVICE SUBJECT TO THE TERMS HEREIN.
TERMS APPLICABLE TO USERS RESIDING OUTSIDE THE UNITED STATES AND OUTSIDE OF RESTRICTED COUNTRIES
IF YOU RESIDE OUTSIDE THE UNITED STATES AND OUTSIDE OF RESTRICTED COUNTRIES, YOU SHALL HAVE ACCESS TO THE EARN SERVICE SUBJECT TO THE TERMS HEREIN.

Please take further notice that PandAI may modify the Terms at any time and in its sole discretion by posting the revised Terms on the PandAI website. You shall be bound by such modifications effective immediately upon posting. It is your responsibility to review these Terms prior to each use of the Services.
PandAI reserves the right to implement, change, modify, or increase any fee, rates or other related cost in connection with the Services at any time. By accepting the Terms you hereby agree to pay all fees associated with or incurred by your use of the PandAI of the Services.

2. DEFINITIONS
Capitalized terms shall have the meanings assigned to them in these Terms, unless the context requires otherwise.

“PandAI Earn” or “Service” means a Service on the PandAI website, allowing a Client to view the Clients’s balance of Eligible Digital Assets loaned by the Client to PandAI, and any rewards gained on loaned Eligible Digital Assets, and manage the Clients’s personal information and Terms of Use. 
THE USE OF PANDAI SERVICES IS NOT A BANK ACCOUNT, DEPOSIT ACCOUNT, SAVINGS ACCOUNTS, CHECKING ACCOUNT, OR ANY OTHER TYPE OF ASSET ACCOUNT AND SHOULD NOT BE CHARACTERIZED AS A BANKING PRODUCT OR INVESTMENT ADVICE NOR INVESTMENT PRODUCT. THE USE OF TERMS SUCH AS “SERVICE” “BALANCE” “SETTLEMENT” AND SIMILAR LANGUAGE IN CONNECTION WITH THE EARN SERVICE DOES NOT IMPLY OR ESTABLISH, AND SHALL NOT BE TAKEN TO SUGGEST, ANY FORM OF CUSTODY RELATIONSHIP, AND SUCH LANGUAGE IS USED HEREIN AS TERMS OF CONVENIENCE ONLY IN REFERRING TO USERS’ LENDING OF DIGITAL ASSETS TO PANDAI AS PART OF THE EARN SERVICE, AND PANDAI’ OBLIGATION TO TRANSFER DIGITAL ASSETS TO USERS UPON THE TERMINATION OF SUCH LOANS IN CONNECTION WITH THESE SERVICES.

“AML” stands for Anti-Money Laundering, which means a set of procedures, laws, and regulations that are intended to stop the practice of generating income through illegal actions.
“Blockchain” means a system in which records of transactions made in Digital Assets are maintained across several computers that are linked in a peer-to-peer network.
“Digital Asset” means a digital representation of value in which encryption techniques are used to regulate the generation of digital units and verify the transfer of assets, operating independently from a central bank.
“Eligible Digital Assets” means the types of Digital Assets we may choose to designate for inclusion under our Services from time to time, which are subject to change and/or limitation in our sole discretion, based on business, regulatory and/or other considerations.
“Referral” a unique Referral Link for any address. If a new user follows Referral Link and makes his first deposit into PandAI Earn, his address is being linked with the address that provided the link, forever. The address providing the link is being rewarded.
“Unhosted Wallet” means a Virtual Wallet where all Eligible Digital Assets held therein are assets maintained by YOU provided by Third Party Service Provider.
“KYC” stands for Know Your Customer (or Client), which means the process of a business verifying the identity of its customers or clients and assessing potential risks of illegal intentions for the business relationship.
“Stablecoin” means a Digital Asset that is Pegged to a Fiat currency.
“Virtual Wallet” or “Virtual Wallet Address” means an on-Blockchain virtual address in which Digital Assets can be held and transferred.

3. ELIGIBILITY AND PROOF OF IDENTITY
In order to use the Services you must first select the duration of the services and connect your virtual wallet as described conditions of the Earn services subject to the terms herin.

In order to be eligible to access and use the Services, you must (i) be eighteen (18) years of age or older, (ii) have the legal ability to enter into and be bound by these Terms, (iii) comply with these Terms. PandAI is not obligated to accept any application from any applicant and has sole and absolute discretion to accept or reject applications to use PandAI earn services.
The Services are not available where prohibited by law or by PandAI policy, as updated from time to time; currently, such places include, but are not necessarily limited to, the Restricted countries list in table below:

Burkina Faso, Afghanistan, Albania, Barbados, Cuba, Burundi, Iran, Crimea Region, Haiti, Venezuela, Central African Republic, Iraq, Donetsk Region, Jamaica, Chad, Jordan, Gibraltar, Nicaragua , Comoros , Myanmar , Luhansk Region , Democratic Republic of the Congo , Pakistan , Equatorial Guinea , Philippines , Guinea - Bissau , Syria , Libya , The Democratic People’s Republic of Korea , Mali , Turkey , Mozambique , Turkmenistan , Niger , Yemen , Nigeria , Senegal , Somalia , South Africa , South Sudan , Sudan , Tanzania , Uganda

or any other country against which the United States, the United Kingdom or the European Union imposes financial sanctions or embargoes.
Be advised that in some jurisdictions, due to regulatory considerations, PandAI may not provide the Services.
Due to changing regulatory requirements and interpretations in the Digital Assets markets, PandAI may use its sole and absolute discretion to, among other things, reject specific applications to use PandAI services, therefore prohibit use of the Services. PandAI, in its sole and absolute discretion, has determined that regulatory or policy reasons prevent PandAI from being able to offer its Services.
PandAI is subject to AML, KYC, according to The FATF Recommendations, therefore, set an international standard, which countries should implement through measures adapted to their particular circumstances. The FATF Standards comprise the Recommendations themselves and their Interpretive Notes, together with the applicable definitions.  
Also with respect to and U.S. sanction requirements under the Bank Secrecy Act (“BSA”), Uniting and Strengthening America by Providing Appropriate Tools Required to Intercept and Obstruct Terrorism Act (“USA PATRIOT Act”), and the Office of Foreign Assets Control (“OFAC”).
EU's tools and objectives of the Common Foreign and Security Policy (CFSP). These include safe-guarding the EU's values, its fundamental interests and security; consolidating and supporting democracy, the rule of law, human rights and the principles of international law; preserving peace; preventing conflicts and strengthening international security.
On top of above PandAI is obligated to check Clients and business partners against all major lists of financial sanctions issued by regulators (UN Security List, EU Lists, OFAC, SDN, FinCEN, 311, Treasury, SECO, FDFA and Finma).
Under applicable AML rules, PandAI is obligated to maintain certain information about you, including User records and transaction history, for five years or a longer period as may be required under applicable laws. Under certain circumstances, PandAI is required to report to the competent authorities of any unusual transactions, or of any suspicion it may have that any Client might be involved in any financial crime or illicit activity.
PandAI is required to comply with applicable AML and KYC requirements before and after you use our Services. When you want to use our Service, we may ask for documentation and information, including but not limited to copies of your government-issued identification document (e.g. Passport, driver’s license). For corporate Clients of PandAI, we may require identification information related to the directors, officers, authorized representatives, or equity owners of the business. We may also gather and use information about you from third parties, to help us confirm your identity, perform our AML/KYC checks and/or determine your access to the Services You represent and warrant at all times that any and all information provided by you to us is true, accurate, and not misleading in any respect. If any such information changes, it is your obligation to provide the new information to us as soon as practicable following such change.

4. SERVICES
A. Overview of Services
You can use the services of PandAI trough official website at the address https://pandai.io/ or trough link send by any user of PandAI services trough refferal program. PandAI allows also gain of access to its services trough commercial link directed to PandAI Earn product.  Your PandAI Services are available to view upon visiting our website and connection of your Virual Wallet trough which you are able to Claim your interest from PandAI Earn Service provided to you by PandAI. You access the Services and conduct certain transactions online using your Virtual Wallet. You are solely responsible for the activities under your Virtual Wallet and for securing your Virtual Wallet seed prahse, hints, or any other codes that you use to access your Virtual Wallet and the Services of PandAI. PandAI is not responsible for any loss or compromise of your access information and/or your personal information, or for any loss that you may sustain due to compromise of your access information and/or personal information to your Virtual Wallet.

PANDAI MAY RESTRICT SERVICES IN CERTAIN JURISDICTIONS DUE TO APPLICABLE LAWS, REGULATIONS, AND BUSINESS CONSIDERATIONS, AT ITS SOLE DISCRETION. ANY SERVICES AVAILABLE TO YOU WILL BE THOSE ACCESSIBLE VIA PANDAI WEBSITE. IF YOU RESIDE IN THE UNITED STATES, THE SERVICES AVAILABLE TO YOU MAY DEPEND ON YOUR STATUS AS AN ACCREDITED INVESTOR OR GEOGRAPHIC LOCATION IF RESTRICTED COUNTRIES APPLY. PANDAI MAY REQUEST FROM YOU PROOF OF ACCREDITED INVESTOR STATUS OR GEOGRAHPIC LOCATION PERIODICALLY OR AT ANY TIME, IN PANDAI’ SOLE DISCRETION. THE FAILURE OF A CLIENT TO TIMELY RESPOND TO SUCH A REQUEST MAY RESULT IN THE TEMPORARY OR PERMANENT LOSS OF THAT CLIENT’S ABILITY TO USE A SERVICE. PANDAI IS NOT LIABLE TO ANY LOSS OR DAMAGE RESULTING FROM SUCH TEMPORARY OR PERMANENT LOSS OF USE TO ANY SERVICE.

We will not be liable for following any instruction we receive through your Virtual Wallet and Choosed Services, even if it was not authorized by you, or if it was entered by mistake or is otherwise inaccurate. To verify the authenticity of any instruction we receive through in accordance to our Services, at our sole discretion we may require your identification in any form we deem necessary. You agree to reimburse us (and we may charge you) for all claims, costs, losses, and damages, including reasonable attorneys’ fees, that result from our following instructions we receive through your ordered Services and take any action related to your ordered Services.
When you use our Services, the Services provided by PandAI are not a banking services, deposit account, savings accounts, checking account, investment advice, invesmtents product or any other type of asset account and should not be characterized as a banking or investments product or service. All Eligible Digital Asset loaned by you to PandAI, therefore, owned, held and/or controlled by PandAI (under the applicable Service, as further detailed herein), and subject to PandAI’ obligation to deliver such Digital Assets back to you upon the termination of the applicable Service.
PandAI may inform government and regulatory bodies if PandAI suspects your involvement in any fraudulent activity of any kind or other misuse of the Services, provision by you of inaccurate or misleading information, or your involvement in any money laundering or other financial crime related to you.

B. PandAI Earn Rewards
Our Earn Service allows you to gain interest from PandAI earn, referred to as “Rewards,” in the form of Digital Assets (based on the value of assets being deposited, with minimum deposit of $100.) In exchange for entering into Fixed duration loans of your Eligible Digital Assets to PandAI under the terms hereof. If our Earn Service is available to you, upon your election, you will lend your Eligible Digital Assets to PandAI and grant PandAI all rights and title to such Digital Assets, for PandAI to use in its sole discretion while using the Earn Service.
The value of Eligible Digital Assets loaned by you to PandAI, and any Rewards gained thereon (see further Section 9 below, “How Rewards are Calculated and Earned”) are visible via your Virtual Wallet connection with PandAI. Once such Eligible Digital Assets are received by PandAI into your Earn balance, they shall be PandAI’ property, in every sense and for all purposes, and you will immediately start accruing Rewards on such Digital Assets in accordance with the terms hereof, and the corresponding amount of Eligible Digital Assets shall be reflected in your Virtual Wallet balance. We reserve the right to reject entry into any loan transaction, and/or the right to repay any loan of Digital Asset already made, each at your expense.
You may claim your Reward to PandAI at any time with fee, and request that PandAI return the borrowed Eligible Digital Assets and deliver any Rewards accrued from the Earn Service, by transferring such Eligible Digital Assets and Claim Rewards to your external Virtual Wallet (in accordance with Section 9 below,”).
The Earn Service is not an investment program nor a speculative tool. Rather, you are earning Rewards as a financing fee on the loan of Eligible Digital Assets you have transferred to PandAI in connection with the Earn Service, and in accordance with the rates and terms published by PandAI from time to time, pursuant to these Terms.

5. VIRTUAL WALLET BALANCE
Your Virtual Wallet Balance is visible through the connection of your Virtual Wallet with PandAI and shall indicate, the balance of Eligible Digital Assets attributed to Earn Service, to the extent applicable and available. You can transfer additional Eligible Digital Assets to PandAI by transferring the same to the Virtual Wallet Address(es) provided to you in PandAI Service. Any Eligible Digital Asset received will be treated by us as being transferred for the purpose of PandAI Earn Service beginning on the date and at the time stamped on the Blockchain confirmation.
It is your sole responsibility to make sure that Digital Assets you wish to loan to PandAI are Eligible Digital Assets, and that your transfer of Eligible Digital Assets on the Blockchain is directed over the correct Blockchain and to the correct Virtual Wallet Address as provided to you by PandAI.

If you do not carefully follow these instructions, your Digital Assets may be irrevocably lost, and PandAI may not be able to assist you in retrieving them. PandAI will not be liable to you for any such loss and shall not be under any obligation to retrieve such Digital Assets.

6. OWNERSHIP OF DIGITAL ASSETS
You hereby represent and warrant to us that any Eligible Digital Asset transferred by you for the purpose of utilizing PandAI’ Services is owned by you or that you are fully permitted to carry out transactions using such Eligible Digital Assets without restriction or limitation, and that your use of the Services is solely for your own behalf and benefit, and not on behalf of any other person or entity. You further represent and warrant that all such Eligible Digital Assets are free from any claims, indebtedness, liens, or third party interests.

7. SETOFF AND SECURITY INTEREST
Your acceptance of these Terms serves as your consent to PandAI’ asserting its security interest or exercising its right of setoff should any laws governing your schoosed Services which require your consent. If the law restricts our ability to take, transfer, or setoff from any obligations to you, or if our Services are protected from attachment, levy, or legal process, you waive those conditions and limits to the full extent that you may do so by contract, and you authorize us to take any actions to offset your Obligations in the use of PandAI Earn Service.
We hereby agree that, to the extent permitted by applicable law, in the event that PandAI breaches its obligation under these Terms, you may set off assets or amounts we owe you with respect to your loan trough Earn Services, against your Obligations. If the law restricts your ability to take, transfer, or setoff our obligations to you, or if they are protected from attachment, levy, or legal process, we waive those conditions and limits to the full extent that we may do so by contract, and we authorize you to apply our obligations to you to your Obligations.

8. RISK DISCLOUSURE
Before using PandAI’ Services, you should ensure that you fully understand and can afford to undertake the risks involved. You should carefully read and make sure you understand the Risk of PandAI Services.
These Terms and your use of any of our Services do not create a fiduciary relationship between us and you; PandAI Earn Service is not a checking or savings account, and it is not covered by insurance against losses. PandAI has no duty to inquire into, supervise, or determine the suitability of any transaction you initiate involving Eligible Digital Assets in connection with PandAI Earn Service. We may lend, sell, pledge, hypothecate, assign, invest, use, commingle or otherwise dispose of assets and hold the Eligible Digital Assets with counterparties, and we will use our best commercial and operational efforts to prevent losses. By lending Eligible Digital Assets to PandAI while using the Earn Service, or otherwise using the Services, you will not be entitled to any profits or income PandAI may generate from any subsequent use of any Digital Assets (or otherwise), nor will you be exposed to any losses which PandAI may suffer as a result thereof. You agree and acknowledge that you are exposed to the possibility that PandAI may become unable to repay its obligations to you in part or in full, in which case any Digital Assets may be at risk of partial or total loss.

ELIGIBLE DIGITAL ASSETS ARE NOT LEGAL TENDER. PANDAI IS NOT A BANK OR DEPOSITORY INSTITUTION, AND USING PANDAI EARN SERVICES IS NOT A DEPOSIT ACCOUNT. ELIGIBLE DIGITAL ASSETS USED IN PANDAI SERVICE ARE NOT INSURED BY ANY PRIVATE OR GOVERNMENTAL INSURANCE PLAN, AND ARE NOT COVERED BY ANY COMPENSATION SCHEME. USING PANDAI SERVICE DOES NOT CONSTITUTE AN INVESTMENT CONTRACT OR A SECURITY, IS NOT TRANSFERABLE AND MAY NOT BE TRADED, EXCHANGED OR SOLD TO ANY THIRD PARTY UNDER ANY CIRCUMSTANCES.

PandAI does not provide any legal, tax or financial advice and you are strongly advised to obtain independent legal, tax or financial advice prior to making any decision using Digital Assets. There are significant risks associated with Digital Assets, and you are solely responsible to make sure you understand such risks and assess whether such risks are appropriate for you. PandAI does not make any offers, recommendations, or invitations for you to deal in Digital Assets or use any Services, and does not take into account your personal circumstances, financial situation, needs or goals. Before making any decision, you should carefully assess your financial situation and capacity, and only use funds that you can afford to lose. Before entering into any transaction or using any of the Services you should ensure that you understand and have made an independent assessment of the suitability and appropriateness of a transaction into which you are entering and the nature and extent of your exposure to risk of loss in light of your own objectives, financial and operational resources, and other relevant circumstances.
Legislative and regulatory changes or actions at the state, federal, or international level may adversely affect the use of Digital Assets. Transactions in Digital Assets may be irreversible, and, accordingly, losses due to fraudulent or accidental transactions may not be recoverable.
The nature of Digital Assets may lead to an increased risk of fraud or cyber-attack, including rollback attacks or Blockchain reorganizations. The nature of Digital Assets means that any technological difficulties experienced by PandAI or third parties may limit, delay or prevent the access or use of Digital Assets and/or cause losses of Digital Assets. Although PandAI takes precautionary measures to protect against cyber threats, circumstances may arise where losses or damages are incurred.
In light of these risks, which are only some of the risks involved in using the Services and do not constitute an exhaustive list of such risks, you should carefully consider whether Digital Assets in general and/or using our Services is suitable for you in light of your financial condition.

9. SETTLEMENT ANDREWARDS OF PANDAI EARN
Subject to these Terms, for any of your Eligible Digital Assets that you utilize in the Earn Service (if available to you), you have a call option on all loans made to PandAI to demand repayment of any loan at any time to your Virtual Wallet. Such payment will terminate in whole your loan to PandAI and you shall no longer accrue Rewards on the amount of loans as of the time of your exercise of the call option. If you exercise call option of all loans or partial loan to PandAI and demand repyment of any loan at any time to your Virtual Wallet, PandAI reserves the right to exercise the settlement within 14 days of such demand by you or upon expiration of Lockup period. PandAI initiates the settlement process immediately following expiration of Lockup period when possible in the consideration of the paragraph above. Everyone can entrust his assets to PandAI Earn, but when claiming the reward, there's a claim fee ≤10 % paid in PandAI Token that's being burned.
PandAI Earn is a product that introduces the PandAI Token burn mechanism to support token price and bring value to the whole PandAI ecosystem.

For PandAI Earn Rewards based on Lockup periods and claim fee see table below: 
There are several Tiers of PandAI Earn based on the value of assets being deposited, with minimum deposit of $100 and parameters defined in contract constructor.

Let's demonstrate Tier parameters on two examples
Example1: Client deposits d = $2,000 (it's his first deposit). 
He's in Tier 3, with Monthly Gain = 1.5 %. User returns in t = 3 months to claim his Clients Reward, which is (no compound interest)
There's 8 % Claim Fee in Tier 3 which means Client must pay 0.08 * 90 = $7.2 in PandAI Token when claiming the reward (those PandAI Tokens are being burned).

Example2: User deposits d = $10,000 (it's his first deposit). 
He's in Tier 5, with Monthly Gain = 2.2 %. User returns in t = 3 months to claim his Clients Reward, which is (compound interest)
There's 5 % Claim Fee in Tier 5 which means Client must pay 0.05 * 682.27 = $34.11 in PandAI Token when claiming the reward (those PandAI Tokens are being burned). 

IT IS POSSIBLE TO WITHDRAWING DEPOSIT BEFORE LOCKUP, BUT THIS COMES WITH ADDITIONAL WITHDRAW FEE PAID IN PANDAI TOKEN. IN CASE DEPOSIT IS WITHDRAWN AFTER LOCKUP, THERE IS NO WITHDRAW FEE APPLIED.

Withdrawal limits for Rewards on amounts Greater then 1000 USDT may apply, based on legal, regulatory and AML considerations. Our policies and procedures may require additional compliance checks that require additional time to complete. Any individual request to exceed withdrawal limits set by PandAI must be sent via email to info@pandai.com. 
Every transaction request shall be deemed pending until accepted by us. We may refuse to accept such request, or delay the processing of an approved request for any reasonable reason, including but not limited to inaccurate or misleading information provided by you, or any doubt or suspicion of fraud, misrepresentation, a sanctioned transaction, money laundering, terrorism financing or other financial crime related to your Assets used for PandAI Earn services.
PandAI and our third-party partners may experience cyber-attacks, extreme market conditions, or other operational or technical difficulties which could result in the immediate halt of transactions either temporarily or permanently. Provided that PandAI has taken reasonable commercial and operational measures to prevent such events in technical systems controlled by PandAI, PandAI is not and will not be responsible or liable for any loss or damage of any sort incurred by you as a result of such cyber-attacks, operational or technical difficulties or suspensions of transactions.

10. CONSENT TO PANDAI’ USE OF DIGITAL ASSETS
In consideration for the Rewards payable to you on the Eligible Digital Assets using the Earn Service, for us entering into any Loan Agreement, and the use of our Services, you grant PandAI, subject to applicable law and for the duration of the period during which you elect to utilize the Eligible Digital Assets in the Earn Service (if available to you) and thus loan such Eligible Digital Assets to us through PandAI Earn, all right and title to such Eligible Digital Assets, including ownership rights, and the right, without further notice to you, to hold such Digital Assets in PandAI’ own Virtual Wallet or elsewhere, and to pledge, re-pledge, hypothecate, rehypothecate, sell, lend, or otherwise transfer or use any amount of such Digital Assets, separately or together with other property, with all attendant rights of ownership, and for any period of time, and without retaining in PandAI’ possession and/or control a like amount of Digital Assets, and to use or invest such Digital Assets in PandAI’ full discretion. You acknowledge that with respect to Digital Assets used by PandAI pursuant to this paragraph:
You will not be able to exercise rights of ownership;
PandAI may receive compensation in connection with lending or otherwise using Digital Assets in its business to which you have no claim or entitlement; and
In the event that PandAI becomes bankrupt, enters liquidation or is otherwise unable to repay its obligations, any Eligible Digital Assets used in the Earn Service may not be recoverable, and you may not have any legal remedies or rights in connection with PandAI’ obligations to you other than your rights as a creditor of PandAI under any applicable laws.

11. TAXES
During using of PandAI services a record of the transactions related to your use of the Services which you may wish to use for the purposes of making any required tax filings or payments. It is your responsibility to determine what, if any, taxes apply to your use of the Services, and to collect, report, and remit the correct tax to the appropriate tax authority. We may deduct or make any tax withholdings or filings that we are required by law to make, but we are not responsible for determining whether and which taxes apply to your transaction, or for collecting, reporting, or remitting any taxes arising from any transaction or in connection with your use of PandAI services. You are responsible for complying with applicable law. You agree that PandAI is not responsible for determining whether or which laws may apply to your transactions, including tax law. You are solely responsible for reporting and paying any taxes arising from your use of the Services.

12. SERVICE ACTIVITY STATEMENTS
We will make all logs and records of activities concerning your use of the Services available to you by PandAI only. 

13. DISCLOSURE OF INFORMATION
We may disclose information to third parties about you, in regards to PandAI services, or the transactions you make:
* where it is necessary for the provision of our Services under these Terms;
* in order to verify the existence and condition of your use of PandAI services for a third party, such as a referral partner;
* for the purpose of conducting our AML and KYC checks and compliance with applicable laws;
* If you give us written authorization;
* In order to comply with any request or order by any government agency or competent court; 
* As described in our Privacy Policy located at: https://app.pandai.io/Privacy_Policy.pdf

14. CONFLICT/DISPUTES INVOLVING OUR SERVICES
We are not liable to you for errors that may result in a financial loss to you. We may take any action that is authorized or permitted by these Terms or applicable laws without liability to you, even if such action causes you to incur fees, expenses or damages. If third parties make claims or if we receive conflicting instructions from you, or if we become involved in or concerned about a dispute between you and any third party, we reserve the right to react in ways that we believe in good faith to be appropriate, delivering the Digital Assets available therein to you or to any third party, or interpleading assets to court, all as we reasonably deem appropriate under the circumstances. You are liable for all expenses and fees we incur for such conflicts or disputes, including internal costs and attorneys’ fees, and we may charge them to you.15. CHANGES IN TERMS
Please be aware that the terms and conditions governing the Services can change over time. We reserve the right to discontinue or make changes to any of the Services. We may change these Terms, and we may add to or delete from these Terms, and the updated version will supersede all prior versions.. The continued maintenance of PandAI services following the effective date of any change will constitute your acceptance of such change and subject to PandAI modified Terms.

==================================================================================================================================
==== Referral Terms of Use
==================================================================================================================================

PandAI Corp Ltd. (collectively, “we,” “our,” “us”, or “PandAI” ) provide the following Terms of Use.
The following Referral Program Terms of Use (the “Refferal Program Terms”) govern your participation in the PandAI’s afliate program (the “Refferal Program”).
These Refferal Program Terms supplement, and form part of, our standard terms of use, the current version of which is located at: https://app.pandai.io/Terms_of_Use.pdf (“Terms of Use”). Accordingly, capitalized terms used, but not defned in these Refferal Program Terms, have the meanings set out in the Terms of Use.
Please refer to our Privacy Policy located at: https://app.pandai.io/Privacy_Policy.pdf for information on how we collect, use and disclose information from our clients. You acknowledge and agree that your use of the Services is subject to our Privacy Policy.

Please consider the following important limitations before deciding whether to participate in the Refferal Program.
By entering the Refferal Program, you acknowledge that you have read, understand, and completely agree to these Refferal Program Terms, as updated and amended from time to time. If you wish not to be bound by these Refferal Program Terms, as updated and amended from time to time, you have to either: (1) never enter, generate or send a Referral Code (defned below), or (2) cease your participation in the Refferal Program by writing us and completing the process required by us.
Your participation in the Refferal Program is always entirely at PandAI’s discretion. You can be removed from the Afliate Program at any time for any reason or no reason. If you violate any of the Refferal Program Terms, you can be immediately removed from the Refferal Program and any amounts you may have been entitled to receive under it may be forfeited. PandAI reserves the right to review and investigate all Refferal Program activities and to suspend or modify any conditions in PandAI’s sole discretion as deemed fair and appropriate. PandAI will also be eligible to revoke all Afliate Program rewards for violations of these Afliate Program Terms, Terms of Use, as well as for fraud, refunds, cancellations, and chargebacks or a substantial change in business circumstances.

1. Description
1.1 The Refferal Program allows you to elect to participate in receiving revenue from Clients you refer to the Services of PandAI Earn, Client who uses PandAI Earn services using a Referral Code you provide (each a “Client”). You can participate in the Refferal Program by referring Client to the Services (each person so referring Client, an “Refferal”). Participation in the Refferal Program is entirely on your discretion and is not required to use the Site or Services.

2. Codes
2.1 Under the Refferal  Program, PandAI may provide you with a unique alphanumeric or other code (the “Referral Code”) to distribute to eligible individuals each to become an Client of PandAI Earn services. You acknowledge and agree that: (a) PandAI have the right to limit the number of times you may use or share your Referral Code, (b) you have no ownership rights in any form over the Referral Code, and (c) PandAI may reclaim, deactivate, invalidate or terminate your Referral Code at any time at PandAI sole discretion.

3. Restrictions
3.1 You may invite eligible individuals to become Clients of PandAI Earn services by distributing your Referral Code directly and instructing them to input your Referral Code during the sign-up process. Referral Codes should only be used for personal and non-commercial purposes. You must disclose that you are eligible to receive an Refferal Reward (defned below) in connection with a use of your Referral Code. You are prohibited from 'spamming' anyone with referral invitations.
3.2 No spamming. You agree that you will not 'spam' anyone with invitations to join the PandAI Earn Platform. Further, you acknowledge and agree that the following activities are prohibited under these Refferal Program Terms: (a) mass emailing, texting or messaging people you do not personally know or otherwise engaging in any other promotion that would constitute or appear to constitute unsolicited commercial email or 'spam', (b) use of automated systems or bots through any channel to distribute, post or respond to your Referral Code, and (c) use of scripts, programmed or automatic dialers to send invites or to communicate a Referral Code. Without limiting the foregoing, you agree to comply with all local, state and federal laws and regulations governing your obligations under these Refferal Program Terms, including but not limited to all applicable laws that govern marketing emails, including the anti-spam laws.
3.3 No Misrepresentations. You agree that you will not mislead or attempt to mislead anyone in connection with the Refferal Program, either by afrmative representation, implication, or omission. Further, you agree that you will not: 
(a) create fake webpages, profles, websites, or links, 
(b) misrepresent your relationship with PandAI or any other third party, including but not limited to suggesting an afliation or partnership exists with a third party where none exists,
(c) make misleading claims about PandAI, including but not limited to misleading claims about the specifcations, features of functionality of the Services provided by PandAI or the Refferal Program,
(d) act in an unfair or disruptive manner, or 
e) otherwise make any false or misleading statements to get a invitee to use your Referral Code. Further you agree that you will not undertake any deceptive or fraudulent methods to increase your Refferal Reward.
3.4 Prohibited content. You agree that you will not use the PandAI brand in connection with: (a) disparaging or defamatory content concerning PandAI or third parties, involved in providing Services to you; (b) ofensive, abusive, intimidating or harassing content; or (c) content that violates the law or rights of anyone else.
3.5 Using paid advertising with branded key-words. You agree that you will not use words such as “pandai.io”, “PandAI Earn”, “pandai” or any other look-alike, sound-alike, or other “PandAI“ branded terms in your advertising materials. It is necessary to prevent any confusion with the ofcial Pandai.io   domains. Do not post your own PandAI referral link as advertisements on search engines such as Google, Bing, Baidu, etc.
3.6 Sharing referral links using fake accounts. You agree that you will not create of use any fake webpages, profles in social media, making fraud actions or any other prohibited unlawful actions.

4. Responsibilities
4.1 You acknowledge that the purpose of the Refferal Program is to encourage new Users/Clients to the Site and Services. You agree to act in good faith in accordance with this intentions.
4.2 You must comply with all applicable laws in connection with your activities under the Refferal Program, including when referring Users/Clients to the Site or Services.
4.3 You should inform PandAI if you discover that any other third party makes fraud or other unlawful actions.
4.4 You should be responsible for covering any damage caused to PandAI by any kind of unlawful action, caused by yourself or any third party who was provided a Referral Code by you.
4.5 You are responsible for any costs or expenses associated with your activities referring Users to the Site or Services. You incur those costs and expenses entirely at your own risk.
4.6 You must ensure that any statements you make in connection with referring Users/Clients to the Site or services are (i) professional, accurate, and truthful; (ii) not misleading or deceptive (for example, do not embellish the nature of your relationship with PandAI); and (iii) not ofensive, illegal or obscene.
4.7 You agree not to engage in any electronic messaging that is prohibited by applicable laws, illegal solicitation, or fraudulent or deceptive solicitation.

5. Rewards
5.1 PandAI will transfer Rewards to your cryptocurrency wallet with a set percentage of fees on the transactions earned from the Clients using PandAI Earn services with your Referral Code. For clarity, those fees are the amounts actually collected from the Clients using services.
5.2 There are two types of rewards in PandAI Earn
- User Rewards derived from user's own deposit (defined in PandAI Earn Terms of use) and
- Referral Rewards.
Referral Rewards are derived from sum of deposited assets of users that joined PandAI Earn following given Referral Link, generates Monthly Gain g = 0.2% and comes with claim fee of 10%.
Let's demonstrate how Referral Reward is calculated on one example.

Example: Users that followed given Referral Link has deposited total D = $100,000. User that created the Referral Link returns in t = 3 months to claim his Referral Reward r, which is
r = D * g * t = 100000 * 0.002 * 3 = $600
There's 10% Claim Fee so the user must pay 0.1 * 600 = $60 in PandAI Token when claiming the referral reward (those PandAI Tokens are being burned).

6. Statistics
6.1 You can check the amount of the rewards you get on the PandAI Earn platform page. 
6.2 Information on the PandAI Earn platform page is updated in real-time.

7. Relationship
7.1 Both you and PandAI are independent contractors and nothing in this agreement will create any partnership, joint venture, franchise, sales representation, or employment relationship between you and PandAI.

8. Non-exclusive
8.1 The Refferal Program is not exclusive. Your participation in the Refferal Program does not grant you any additional right to use or continue to use the Site or Services.

9. Changes
9.1 PandAI may update or amend the Terms of Use, Refferal Program Terms, Site, Services, any Refferal Rewards, fees charged in connection with the Services or other elements of the transactions contemplated by these Refferal Program Terms at any time and from time to time (“Changes”). PandAI may make Changes for any reason or no reason. These Changes may make your participation in the Refferal Program more or less valuable to you and may result in you no longer being eligible to participate in the Refferal Program. Please be informed that your continued participation in the Refferal Program following a Change will constitute your binding acceptance of the Change.

10. Liability
10.1 In addition to the Limitation of Liability set out in the PandAI Earn Terms of Use, PandAI also assumes no liability or responsibility for and shall have no liability or responsibility for any losses directly or indirectly arising out of or related to:
10.1.1 these Refferal Program Terms;
10.1.2 the Refferal Program and your participation in it;
10.1.3 any breach of these Refferal Program Terms;
10.1.4 any failure by you to comply with applicable laws (including laws governing privacy or electronic messaging, disclosure laws, etc.); and
10.1.5 any negligent or intentional acts or omissions by you.
10.2 You hereby agree to release the PandAI from liability for any and all losses, and you shall indemnify and save and hold the PandAI harmless from and against all losses. The foregoing limitations of liability shall apply whether the alleged liability or losses are based on contract, negligence, tort, unjust enrichment, strict liability, violation of law or regulation, or any other basis, even if the PandAI have been advised of or should have known of the possibility of such losses and damages,

11. Term
11.1 These Refferal Program Terms will apply indefnitely after that, until your participation in the Refferal Program ends. If your participation in the Referal Program ends, all Refferal Rewards will end on the same date. These terms will continue to apply after your participation in the Refferal Program ends.
11.2 The Terms of Use apply in their entirety to these Refferal Program Terms.

Contact us
If you have any questions relating to these Refferal Program Terms, your rights and obligations arising from it and/or your use of the Site and the Service, or any other matter, please, contact info@pandai.io

PandAI Corp Ltd.
Address: House of Francis, Room 303, Ile du Port, Mahe, Seychelles
Website: https://pandai.io/ 
Email: info@pandai.com 
*/
pragma solidity 0.8.19;




interface IERC20Extended is IERC20 {
  function decimals() external view returns (uint8);
}

interface IERC20Burnable is IERC20Extended {
  function burnFrom(address account, uint amount) external;
}

contract PandAIEarnV1 is AccessControl, Pausable {

  IERC20Extended private immutable usdtToken;
  IERC20Burnable private immutable pandaiToken;
  
  address private lpAddress;

  bytes32 public constant UPDATER_ROLE = keccak256("UPDATER_ROLE");
  address private constant DEFAULT_REFERRAL = 0xeA51341bb930E2D8561ad2a4430873D6d18997BD;

  uint private constant BASE_PERIOD = 1 days;                        // base period for time (mainnet: 1 day, devnet: minutes)
  uint private constant WITHDRAW_PROCESSING_TIME = 14 * BASE_PERIOD; // user requests withdrawal -> 14 days waiting -> withdrawal can be executed
  uint private constant INTEREST_PERIOD = 30 * BASE_PERIOD;          // period for Tier.monthlyGainBps
  uint private constant DAILY_CLAIM_LIMIT = 1000;                    // daily claim limit of USDT for NotApproved users
  uint private constant MIRIAD = 10000;                              // helper for divisor
  uint private constant REFERRAL_MONTHLY_GAIN_BPS = 20;              // 0.2% reward for referrals
  uint private constant REFERRAL_CLAIM_FEE_BPS = 1000;               // 10% referral claim fee
  
  /**
    0: NotApproved (daily claim limit of $1000)
    1: Approved (no daily limit)
    2: Forbidden (claim forbidden)
  */
  enum ApprovalLevel{ NotApproved, Approved, Forbidden }

  mapping(uint8 => Tier) private tierMap;
  struct Tier {
    uint16 minDeposit;
    bool compoundInterest;     
    
    uint8 monthlyGainBps;
    uint16 claimFeeBps;

    uint lockupSeconds;
    uint16 lockupBreachFeeBps;
  }

  mapping(address => User) private userMap;
  struct User {
    address referral;                  // referral address for this account
    uint8 approvalLevel;               // approval level of this user (from ApprovalLevel enum)
    
    uint deposit;                      // usdt deposit of given user
    uint lastDepositTimestamp;         // last time of usdt deposit
    
    uint withdrawRequestAmount;        // usdt user request to withdraw
    uint withdrawPossibleTimestamp;    // time when the withdraw of requested amount can be done
    
    uint dailyClaim;                   // usdt user claimed today
    uint totalClaim;                   // usdt user claimed in total
    uint lastClaimTimestamp;           // last time when user called claim
   
    uint userPendingReward;            // user reward that hasn't been claimed because of deposit or request withdraw

    uint referralDeposit;              // sum of usdt deposits of users bellow this user (in referral program)
    uint referralPendingReward;        // pending referral reward (calculated in referralLastUpdateTimestamp)
    uint referralLastUpdateTimestamp;  // time when referalPendingReward was updated 
  }

  struct UserCalculated {
    uint8 tier;

    uint userPendingReward;
    uint userPendingPandaiBurn;

    uint referralPendingReward;
    uint referralPendingPandaiBurn;

    uint depositUnlockTimestamp;
  }

  event TreasuryWithdraw(uint usdtAmount);
  event TreasuryDeposit(uint usdtAmount);
  event LpAddressChanged(address indexed previousLp, address indexed newLp);
  event ApprovalLevelChanged(address indexed userAddress, ApprovalLevel previousApprovalLevel, ApprovalLevel newApprovalLevel);

  event UserDeposited(address indexed userAddress, uint usdtAmount);
  event UserRequestedWithdraw(address indexed userAddress, uint usdtAmount);
  event UserWithdrew(address indexed userAddress, uint usdtAmount);

  event PandaiBurnedForUserRewardClaim(address indexed userAddress, uint pandaiAmount);
  event PandaiBurnedForReferralRewardClaim(address indexed userAddress, uint pandaiAmount);
  event PandaiBurnedForWithdrawFee(address indexed userAddress, uint pandaiAmount);
  
  event UserRewardClaimed(address indexed userAddress, uint usdtAmount);
  event ReferralRewardClaimed(address indexed userAddress, uint usdtAmount);

  constructor(address usdtTokenAddress, address pandaiTokenAddress) {
    usdtToken = IERC20Extended(usdtTokenAddress);
    pandaiToken = IERC20Burnable(pandaiTokenAddress);

    tierMap[1] = Tier(  100, false, 100, 1000,   7 * BASE_PERIOD, 4000);
    tierMap[2] = Tier(  500, false, 125,  900,  30 * BASE_PERIOD, 3500);
    tierMap[3] = Tier( 1000, false, 150,  800,  60 * BASE_PERIOD, 3000);
    tierMap[4] = Tier( 5000,  true, 180,  650,  90 * BASE_PERIOD, 2500);
    tierMap[5] = Tier(10000,  true, 220,  500, 180 * BASE_PERIOD, 2000);

    _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
  }
 
  /**
    returns info about given user. Returns stored values (stored in mapping) and calculated values (contract calculates them from stored values)
  */
  function getUser(address userAddress) external view returns (User memory stored, UserCalculated memory calculated) {    
    require(userAddress != address(0), "empty address");    

    uint8 tier = getUserTier(userAddress);
    uint userReward = userMap[msg.sender].userPendingReward + getNewUserReward(userAddress, tier);
    uint referralReward = userMap[userAddress].referralPendingReward + getNewReferralReward(userAddress);
    return (
      userMap[userAddress],
      UserCalculated(
        tier,
        userReward,
        getUserRewardClaimFeePandai(userReward, tier),
        referralReward,
        getReferralRewardClaimFeePandai(referralReward),
        getDepositUnlockTimestamp(userAddress, tier)
      )
    );
  }

  /**
    returns info about given tier.
  */
  function getTier(uint8 tier) external view returns (Tier memory) {
    require(tier >= 1 && tier <= 5, "invalid tier");
    return tierMap[tier];
  }

  /**
    returns address of liquidty pool that swaps USDT and PANDAI. Used to define PANDAI price in USDT.
  */
  function getLpAddress() external view returns (address) {
    return lpAddress;
  }

  /**
    paused contract prohibits deposits
  */
  function pause() external onlyRole(DEFAULT_ADMIN_ROLE) {
    _pause();
  }

  /**
    unpauses paused contract
  */
  function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {
    _unpause();
  }

  /**
    sets address for liquidity pool
  */
  function setLpAddress(address newLpAddress) external onlyRole(DEFAULT_ADMIN_ROLE) {
    require(newLpAddress != address(0), "empty address");
    require(usdtToken.balanceOf(newLpAddress) > 0, "no usdt in lp");
    require(pandaiToken.balanceOf(newLpAddress) > 0, "no pandai in lp");
    
    address oldLpAddress = lpAddress;
    lpAddress = newLpAddress;
    emit LpAddressChanged(oldLpAddress, newLpAddress);
  }

  /**
    withdraws USDT from contract
  */
  function withdrawTreasury(uint usdtAmount) external onlyRole(DEFAULT_ADMIN_ROLE) {
    require(usdtToken.transfer(msg.sender, usdtAmount), "usdt transfer");
    emit TreasuryWithdraw(usdtAmount);
  }

  /**
    deposits USDT from contract. USDT can be sent in ordinary transaction, this event is helpful to use as it produces event.
  */
  function depositTreasury(uint usdtAmount) external onlyRole(DEFAULT_ADMIN_ROLE) {
    require(usdtToken.transferFrom(msg.sender, address(this), usdtAmount), "usdt transfer");
    emit TreasuryDeposit(usdtAmount);
  }

  /**
    sets ApprovalLevel of given address. 
  */
  function setUserApprovalLevel(address userAddress, ApprovalLevel newApprovalLevel) external onlyRole(UPDATER_ROLE) {
    ApprovalLevel oldApprovalLevel = ApprovalLevel(userMap[userAddress].approvalLevel);
    userMap[userAddress].approvalLevel = uint8(newApprovalLevel);
    emit ApprovalLevelChanged(userAddress, oldApprovalLevel, newApprovalLevel);
  }

  /**
    deposits USDT, default referral is used
  */
  function deposit(uint usdtDepositAmount) external {
    depositWithReferral(usdtDepositAmount, DEFAULT_REFERRAL);
  }

  /**
    deposits USDT, referralAddress is used only if no referral is set for address making deposit (the first deposit of the address).
  */
  function depositWithReferral(uint usdtDepositAmount, address referralAddress) public whenNotPaused {
    require(msg.sender == tx.origin, "calls from contract disallowed");
    require(userMap[msg.sender].deposit + usdtDepositAmount >= tierMap[1].minDeposit * (10 ** usdtToken.decimals()), "small deposit");
    require(referralAddress != address(0), "invalid referral");
    require(referralAddress != msg.sender, "invalid referral");

    // assign referral
    if (userMap[msg.sender].referral == address(0)) {
      userMap[msg.sender].referral = referralAddress;
    }

    // update user
    uint8 tier = getUserTier(msg.sender);
    if (tier > 0) {
      userMap[msg.sender].userPendingReward += getNewUserReward(msg.sender, tier);
    }

    userMap[msg.sender].deposit += usdtDepositAmount;
    userMap[msg.sender].lastDepositTimestamp = block.timestamp;
    if (!isToday(userMap[msg.sender].lastClaimTimestamp)) {
      userMap[msg.sender].dailyClaim = 0;
    }
    userMap[msg.sender].lastClaimTimestamp = block.timestamp;
    
    // update referral
    uint newReferralReward = getNewReferralReward(userMap[msg.sender].referral);
    userMap[userMap[msg.sender].referral].referralDeposit += usdtDepositAmount;
    userMap[userMap[msg.sender].referral].referralPendingReward += newReferralReward;
    userMap[userMap[msg.sender].referral].referralLastUpdateTimestamp = block.timestamp;
    
    // transfer USDT
    require(usdtToken.transferFrom(msg.sender, address(this), usdtDepositAmount), "usdt transfer");
    emit UserDeposited(msg.sender, usdtDepositAmount);
  }

  /**
    requests USDT withdraw. USDTs will be available for withdraw (other method) after WITHDRAW_PROCESSING_TIME.
    In case there's already a withdraw pending, it's increased by usdtWithdrawAmount and WITHDRAW_PROCESSING_TIME is reset.
  */
  function requestWithdraw(uint usdtWithdrawAmount) external {
    require(msg.sender == tx.origin, "calls from contract disallowed");
    require(usdtWithdrawAmount <= userMap[msg.sender].deposit, "withdraw bigger than deposit");
    if (usdtWithdrawAmount < userMap[msg.sender].deposit) {
      require(userMap[msg.sender].deposit - usdtWithdrawAmount >= tierMap[1].minDeposit * (10 ** usdtToken.decimals()), "small deposit remaining");
    }

    uint8 tier = getUserTier(msg.sender);
    require(tier > 0, "invalid tier");

    // if withdraw is called before lockup, there's a fee paid in PANDAI
    uint withdrawFeePandai;
    if (getDepositUnlockTimestamp(msg.sender, tier) > block.timestamp) {
      withdrawFeePandai = getPandaiWorthOf(usdtWithdrawAmount * tierMap[tier].lockupBreachFeeBps / MIRIAD);

      require(pandaiToken.balanceOf(msg.sender) >= withdrawFeePandai, "pandai balance");
      require(pandaiToken.allowance(msg.sender, address(this)) >= withdrawFeePandai, "pandai allowance");
    }

    // update user
    userMap[msg.sender].userPendingReward += getNewUserReward(msg.sender, tier);
    if (!isToday(userMap[msg.sender].lastClaimTimestamp)) {
      userMap[msg.sender].dailyClaim = 0;
    }
    userMap[msg.sender].lastClaimTimestamp = block.timestamp;

    userMap[msg.sender].deposit -= usdtWithdrawAmount;
    userMap[msg.sender].withdrawRequestAmount += usdtWithdrawAmount;
    userMap[msg.sender].withdrawPossibleTimestamp = block.timestamp + WITHDRAW_PROCESSING_TIME;
    
    // update referral
    userMap[userMap[msg.sender].referral].referralPendingReward += getNewReferralReward(userMap[msg.sender].referral);
    userMap[userMap[msg.sender].referral].referralDeposit -= usdtWithdrawAmount;
    userMap[userMap[msg.sender].referral].referralLastUpdateTimestamp = block.timestamp;

    // if needed, burn PANDAI
    if (withdrawFeePandai > 0) {
      pandaiToken.burnFrom(msg.sender, withdrawFeePandai);
      emit PandaiBurnedForWithdrawFee(msg.sender, withdrawFeePandai);
    }
    emit UserRequestedWithdraw(msg.sender, usdtWithdrawAmount);
  }

  /**
    withdraws requested amount of USDT
  */
  function withdraw() external {
    require(userMap[msg.sender].withdrawRequestAmount > 0, "no withdraw requested");
    require(userMap[msg.sender].withdrawPossibleTimestamp <= block.timestamp, "withdraw not possible yet");

    // update user
    uint usdtWithdrawAmount = userMap[msg.sender].withdrawRequestAmount;
    userMap[msg.sender].withdrawRequestAmount = 0;
    userMap[msg.sender].withdrawPossibleTimestamp = 0;

    // transfer USDT
    require(usdtToken.transfer(msg.sender, usdtWithdrawAmount), "usdt transfer");
    emit UserWithdrew(msg.sender, usdtWithdrawAmount);
  }

  /**
    claims user reward (derived from it's own deposit) and
    referral reward (derived from deposits of users with referral being the caller)
  */
  function claim() external whenNotPaused {
    require(msg.sender == tx.origin, "calls from contract disallowed");

    uint8 tier = getUserTier(msg.sender);
    uint userClaimUsdt = userMap[msg.sender].userPendingReward + getNewUserReward(msg.sender, tier);
    uint referralClaimUsdt = userMap[msg.sender].referralPendingReward + getNewReferralReward(msg.sender);
    require(userClaimUsdt + referralClaimUsdt > 0, "empty claim");
    require(canClaim(msg.sender, userClaimUsdt + referralClaimUsdt), "user cannot claim");
    
    uint userClaimFeePandai = getUserRewardClaimFeePandai(userClaimUsdt, tier);
    uint referralClaimFeePandai = getReferralRewardClaimFeePandai(referralClaimUsdt);
    require(pandaiToken.balanceOf(msg.sender) >= userClaimFeePandai + referralClaimFeePandai, "pandai balance");
    require(pandaiToken.allowance(msg.sender, address(this)) >= userClaimFeePandai + referralClaimFeePandai, "pandai allowance");

    // update user
    userMap[msg.sender].userPendingReward = 0;
    if (isToday(userMap[msg.sender].lastClaimTimestamp)) {
      userMap[msg.sender].dailyClaim += userClaimUsdt + referralClaimUsdt;
    } else {
      userMap[msg.sender].dailyClaim = userClaimUsdt + referralClaimUsdt;
    }
    userMap[msg.sender].totalClaim += userClaimUsdt + referralClaimUsdt;
    userMap[msg.sender].lastClaimTimestamp = block.timestamp;

    // update referral
    userMap[msg.sender].referralPendingReward = 0;
    userMap[msg.sender].referralLastUpdateTimestamp = block.timestamp;

    // transfer USDT, burn PANDAI
    require(usdtToken.transfer(msg.sender, userClaimUsdt + referralClaimUsdt), "usdt transfer");
    pandaiToken.burnFrom(msg.sender, userClaimFeePandai + referralClaimFeePandai);
    if (userClaimUsdt > 0) {
      emit UserRewardClaimed(msg.sender, userClaimUsdt);
      emit PandaiBurnedForUserRewardClaim(msg.sender, userClaimFeePandai);
    }
    if (referralClaimUsdt > 0) {
      emit ReferralRewardClaimed(msg.sender, referralClaimUsdt);
      emit PandaiBurnedForReferralRewardClaim(msg.sender, referralClaimFeePandai);
    }
  }

  /**
    checks whether given user is able claiming given amount of usdt. Depends on user approvalLevel and his dailyClaim
  */
  function canClaim(address userAddress, uint claimUsdt) private view returns (bool) {
    ApprovalLevel approvalLevel = ApprovalLevel(userMap[userAddress].approvalLevel);
    if (approvalLevel == ApprovalLevel.Approved) {
      return true;
    } else if (approvalLevel == ApprovalLevel.Forbidden) {
      return false;
    }
    if (isToday(userMap[userAddress].lastClaimTimestamp)) {
      claimUsdt += userMap[userAddress].dailyClaim;
    }
    return claimUsdt / (10 ** usdtToken.decimals()) <= DAILY_CLAIM_LIMIT;
  }

  /**
    simple check whether given timestamp falls into same day
  */
  function isToday(uint timestamp) private view returns (bool) {
    return block.timestamp / BASE_PERIOD == timestamp / BASE_PERIOD;
  }

  /**
    converts USDT into pandai according to current price in the liquity pool
  */
  function getPandaiWorthOf(uint usdtAmount) private view returns (uint) {
    if (usdtAmount == 0) {
      return 0;
    }
    uint usdtInLp = usdtToken.balanceOf(lpAddress);
    uint pandaiInLp = pandaiToken.balanceOf(lpAddress);
    require (usdtInLp * pandaiInLp > 0, "empty lp");

    return usdtAmount * pandaiInLp / usdtInLp;
  }

  /**
    gets user tier from his deposit
  */
  function getUserTier(address userAddress) private view returns (uint8) {
    uint userDeposit = userMap[userAddress].deposit / (10 ** usdtToken.decimals());
    for (uint8 i = 5; i >= 1; i--) {
      if (userDeposit >= tierMap[i].minDeposit) {
        return i;
      }
    }
    return 0;
  }

  /**
    claculates user reward that follows eiterh simple or compounc interest. 
    In case of compound iterest, the calculatio follows taylor series for exponential
  */
  function getNewUserReward(address userAddress, uint8 userTier) private view returns (uint) {
    if (userTier == 0) {
      return 0;
    }
    uint g = tierMap[userTier].monthlyGainBps;
    uint t = block.timestamp - userMap[userAddress].lastClaimTimestamp;
    uint f1 = userMap[userAddress].deposit * g * t / MIRIAD / INTEREST_PERIOD;
    if (!tierMap[userTier].compoundInterest) {
      return f1;
    }
    uint f2 = f1 * g * t / MIRIAD / INTEREST_PERIOD / 2;
    uint f3 = f2 * g * t / MIRIAD / INTEREST_PERIOD / 3;
    return f1 + f2 + f3;
  }

  /**
    how much PANDAI user in given tier should burn when claiming given user reward
  */
  function getUserRewardClaimFeePandai(uint userRewardUsdt, uint8 userTier) private view returns (uint) {
    if (userTier == 0) { // user withdrew everything
      userTier = 1;
    }
    return getPandaiWorthOf(userRewardUsdt * tierMap[userTier].claimFeeBps / MIRIAD);
  }

  /**
    calculates referral reward from time when the reward has been updated the last
  */
  function getNewReferralReward(address userAddress) private view returns (uint) {
    uint t = block.timestamp - userMap[userAddress].referralLastUpdateTimestamp;
    return userMap[userAddress].referralDeposit * REFERRAL_MONTHLY_GAIN_BPS * t / MIRIAD / INTEREST_PERIOD;
  }

  /**
    how much PANDAI user should burn when claiming given referral reward 
  */
  function getReferralRewardClaimFeePandai(uint referralRewardUsdt) private view returns (uint) {
    return getPandaiWorthOf(referralRewardUsdt * REFERRAL_CLAIM_FEE_BPS / MIRIAD);
  }

  /**
    timestamp when it's no longer required to burn PANDAI when requesting withdraw
  */
  function getDepositUnlockTimestamp(address userAddress, uint8 userTier) private view returns (uint) {
    if (userTier == 0) {
      return 0;
    }
    return userMap[userAddress].lastDepositTimestamp + tierMap[userTier].lockupSeconds;
  }

}