{"AggregatorInterface.sol":{"content":"// SPDX-License-Identifier: MIT\n// Creator: OpenZeppelin\n\npragma solidity 0.6.5;\n\n\ninterface AggregatorInterface {\n\n  function latestAnswer() external view returns (int256);\n  function latestTimestamp() external view returns (uint256);\n  function latestRound() external view returns (uint256);\n  function getAnswer(uint256 roundId) external view returns (int256);\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"},"ContextUpgradeSafe.sol":{"content":"// SPDX-License-Identifier: MIT\n// Creator: OpenZeppelin\n\npragma solidity ^0.6.5;\n\nimport \"./Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract ContextUpgradeSafe is Initializable {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n\n\n    }\n\n\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n\n    uint256[50] private __gap;\n}\n\n"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// Creator: OpenZeppelin\n\npragma solidity ^0.6.5;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"Initializable.sol":{"content":"// SPDX-License-Identifier: MIT\n// Creator: OpenZeppelin\n\npragma solidity ^0.6.5;\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    address self = address(this);\n    uint256 cs;\n    assembly { cs := extcodesize(self) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n// Creator: OpenZeppelin\n\npragma solidity ^0.6.5;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable  {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"},"PoolerChainlink.sol":{"content":"// SPDX-License-Identifier: MIT\n// Creator: Pooler Finance\n\npragma solidity 0.6.5;\n\nimport \"./ContextUpgradeSafe.sol\";\nimport \"./IERC20.sol\";\nimport \"./Initializable.sol\";\nimport \"./Ownable.sol\";\nimport \"./SafeMath.sol\";\nimport \"./AggregatorInterface.sol\";\n\n\ncontract PoolerChainlink is Ownable, Initializable, ContextUpgradeSafe {\n\n    using SafeMath for uint;\n\n    struct Pool {\n        address creator;\n        address token;\n        uint price;\n        uint minBet;\n        uint start;\n        uint startPeriod;\n        uint end;\n        uint endPeriod;\n    }\n\n    Pool[] public pools;\n    mapping (uint =\u003e uint) public bearsTotal;\n    mapping (uint =\u003e uint) public bullsTotal;\n    mapping (uint =\u003e uint) public taken;\n    mapping (uint =\u003e bool) public results;\n\n    mapping (address =\u003e mapping (address =\u003e uint)) public fees;\n    mapping (uint =\u003e mapping (address =\u003e uint[2])) public funds;\n    mapping (uint =\u003e AggregatorInterface) public feeds;\n    \n    event NewPool(uint id, address sender, address token, address feed, uint price, uint minBet, uint start, uint startPeriod, uint end, uint endPeriod);\n    event Bet(uint id, address sender, address asset, uint amount, bool isBull);\n    event Collect(uint id, address sender, uint amount);\n    event Trigger(uint id, uint price);\n    event Claim(address claimer, address asset, uint amount);\n    event Taken(uint id);\n\n\n    function __PoolerChainlink_init() internal initializer {\n        __Context_init_unchained();\n        __PoolerChainlink_init_unchained();\n    }\n\n    function __PoolerChainlink_init_unchained() internal initializer {\n    }\n\n    function initialize() public initializer {\n        __PoolerChainlink_init();\n    }\n\n    modifier canClaim(address user, address asset) {\n        require(fees[user][asset] \u003e 0, \"Accumulated fees are not zero\");\n        _;\n    }\n\n    function transfer(address from, address payable to, address asset, uint amount) internal {\n        if (asset == address(0)) {\n            if (address(this) != to) {\n                to.call.value(amount)(\"\");\n            }\n        } else {\n            if (from == address(this)) {\n                IERC20(asset).transfer(to, amount);\n            } else {\n                IERC20(asset).transferFrom(from, to, amount);\n            }\n        }\n    }\n\n    function createPool(address token, address feed, uint price, uint minBet, uint start, uint startPeriod, uint end, uint endPeriod) public {\n        require(block.number \u003c start \u0026\u0026 end \u003e start + startPeriod, \"Given periods are correct\");\n        uint id = pools.length;\n        Pool memory newPool = Pool(msg.sender, token, price, minBet, start, startPeriod, end, endPeriod);\n        pools.push(newPool);\n        feeds[id] = AggregatorInterface(feed);\n        emit NewPool(id, msg.sender, token, feed, price, minBet, start, startPeriod, end, endPeriod);\n    }\n\n    function bet(uint id, address asset, uint amount, bool isBull) public payable {\n        require(asset == pools[id].token, \"Sent asset is same as asset in which we collect bets\");\n        if (asset == address(0)) {\n            require(amount == msg.value, \"Sent value should be equal to the amount\");\n        }\n        require(amount \u003e 0 \u0026\u0026 amount \u003e= pools[id].minBet, \"Amount should be at least the minimal bet\");\n        uint start = pools[id].start;\n        uint poolBullsTotal = bullsTotal[id];\n        uint poolBearsTotal = bearsTotal[id];\n        require(block.number \u003e= start \u0026\u0026 block.number \u003c= start.add(pools[id].startPeriod), \"Acceptance period\");\n        uint fee = amount.div(500);\n        uint amt = amount.sub(fee);\n        if (isBull) {\n            bullsTotal[id] = poolBullsTotal.add(amt);\n            require(funds[id][msg.sender][1] == 0, \"Didn\u0027t place bet on bears\");\n            funds[id][msg.sender][0] = funds[id][msg.sender][0].add(amt);\n        } else {\n            bearsTotal[id] = poolBearsTotal.add(amt);\n            require(funds[id][msg.sender][0] == 0, \"Didn\u0027t place bet on bulls\");\n            funds[id][msg.sender][1] = funds[id][msg.sender][1].add(amt);\n        }\n        fees[owner()][asset] = fees[owner()][asset].add(fee);\n        transfer(msg.sender, payable(address(this)), asset, amount);\n        emit Bet(id, msg.sender, asset, amount, isBull);\n    }\n\n    function getPrice(uint id) public view returns (int)  {\n        int price = feeds[id].latestAnswer();\n        require(price \u003e 0, \"Price exists in the feed\");\n        return price;\n    }\n\n    function trigger(uint id) public {\n        uint end = pools[id].end;\n        require(block.number \u003e= end \u0026\u0026 block.number \u003c= end.add(pools[id].endPeriod), \"Price settlement period\");\n        int price = feeds[id].latestAnswer();\n        require(price \u003e 0, \"Price exists in the feed\");\n        if (uint(price) \u003e pools[id].price) {\n            results[id] = true;\n        }\n        emit Trigger(id, uint(price));\n    }\n\n    function collect(uint id) public {\n        uint timeToCollect = pools[id].end.add(pools[id].endPeriod);\n        require(block.number \u003e timeToCollect \u0026\u0026 block.number \u003c timeToCollect.add(60000), \"After price settlement period and not later than 2 days\");\n        uint amount = 0;\n        address owner = owner();\n        address token = pools[id].token;\n        if (results[id]) {\n            amount = funds[id][msg.sender][0];\n            require(amount \u003e 0, \"Has earnings\");\n            uint earnings = bearsTotal[id].mul(amount).div(bullsTotal[id]);\n            uint fee = earnings.div(20);\n            earnings = earnings.sub(fee);\n            amount = amount.add(earnings);\n            funds[id][msg.sender][0] = 0;\n            taken[id] = taken[id].add(amount.add(fee));\n            fees[owner][token] = fees[owner][token].add(fee);\n            transfer(address(this), msg.sender, token, amount);\n        } else {\n            amount = funds[id][msg.sender][1];\n            require(amount \u003e 0, \"Has earnings\");\n            uint earnings = bullsTotal[id].mul(amount).div(bearsTotal[id]);\n            uint fee = earnings.div(20);\n            earnings = earnings.sub(fee);\n            amount = amount.add(earnings);\n            funds[id][msg.sender][1] = 0;\n            taken[id] = taken[id].add(amount.add(fee));\n            fees[owner][token] = fees[owner][token].add(fee);\n            transfer(address(this), msg.sender, token, amount);\n        }\n        emit Collect(id, msg.sender, amount);\n    }\n\n    function claimNotTaken(uint id) public onlyOwner {\n        uint timeToCollect = pools[id].end.add(pools[id].endPeriod);\n        require(block.number \u003e= timeToCollect.add(60000), \"Time to collect funds from the pool expired\");\n        uint totalBearsBulls = bullsTotal[id].add(bearsTotal[id]);\n        transfer(address(this), msg.sender, pools[id].token, totalBearsBulls.sub(taken[id]));\n        emit Taken(id);\n    }\n\n    function claim(address asset) public canClaim(msg.sender, asset) {\n        uint amount = fees[msg.sender][asset];\n        fees[msg.sender][asset] = 0;\n        transfer(address(this), msg.sender, asset, amount);\n        emit Claim(msg.sender, asset, amount);\n    }\n\n    uint256[44] private __gap;\n}\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n// Creator: OpenZeppelin\n\npragma solidity ^0.6.5;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"}}