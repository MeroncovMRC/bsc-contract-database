{"Address.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\u0027s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"},"Buffer.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\n\n// https://github.com/ensdomains/buffer\n\npragma solidity ^0.7.0;\n\n/**\n * @dev A library for working with mutable byte buffers in Solidity.\n *\n * Byte buffers are mutable and expandable, and provide a variety of primitives\n * for writing to them. At any time you can fetch a bytes object containing the\n * current contents of the buffer. The bytes object should not be stored between\n * operations, as it may change due to resizing of the buffer.\n */\nlibrary Buffer {\n    /**\n     * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n     *      a capacity. The capacity may be longer than the current value, in\n     *      which case it can be extended without the need to allocate more memory.\n     */\n    struct buffer {\n        bytes buf;\n        uint capacity;\n    }\n\n    /**\n     * @dev Initializes a buffer with an initial capacity.a co\n     * @param buf The buffer to initialize.\n     * @param capacity The number of bytes of space to allocate the buffer.\n     * @return The buffer, for chaining.\n     */\n    function init(buffer memory buf, uint capacity) internal pure returns (buffer memory) {\n        if (capacity % 32 != 0) {\n            capacity += 32 - (capacity % 32);\n        }\n        // Allocate space for the buffer data\n        buf.capacity = capacity;\n        assembly {\n            let ptr := mload(0x40)\n            mstore(buf, ptr)\n            mstore(ptr, 0)\n            mstore(0x40, add(32, add(ptr, capacity)))\n        }\n        return buf;\n    }\n\n\n    /**\n     * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param off The start offset to write to.\n     * @param rawData The data to append.\n     * @param len The number of bytes to copy.\n     * @return The original buffer, for chaining.\n     */\n    function writeRawBytes(\n        buffer memory buf,\n        uint off,\n        bytes memory rawData,\n        uint offData,\n        uint len\n    ) internal pure returns (buffer memory) {\n        if (off + len \u003e buf.capacity) {\n            resize(buf, max(buf.capacity, len + off) * 2);\n        }\n\n        uint dest;\n        uint src;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Start address = buffer address + offset + sizeof(buffer length)\n            dest := add(add(bufptr, 32), off)\n            // Update buffer length if we\u0027re extending it\n            if gt(add(len, off), buflen) {\n                mstore(bufptr, add(len, off))\n            }\n            src := add(rawData, offData)\n        }\n\n        // Copy word-length chunks while possible\n        for (; len \u003e= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        uint mask = 256**(32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n\n        return buf;\n    }\n\n    /**\n     * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param off The start offset to write to.\n     * @param data The data to append.\n     * @param len The number of bytes to copy.\n     * @return The original buffer, for chaining.\n     */\n    function write(buffer memory buf, uint off, bytes memory data, uint len) internal pure returns (buffer memory) {\n        require(len \u003c= data.length);\n\n        if (off + len \u003e buf.capacity) {\n            resize(buf, max(buf.capacity, len + off) * 2);\n        }\n\n        uint dest;\n        uint src;\n        assembly {\n        // Memory address of the buffer data\n            let bufptr := mload(buf)\n        // Length of existing buffer data\n            let buflen := mload(bufptr)\n        // Start address = buffer address + offset + sizeof(buffer length)\n            dest := add(add(bufptr, 32), off)\n        // Update buffer length if we\u0027re extending it\n            if gt(add(len, off), buflen) {\n                mstore(bufptr, add(len, off))\n            }\n            src := add(data, 32)\n        }\n\n        // Copy word-length chunks while possible\n        for (; len \u003e= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        uint mask = 256**(32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n\n        return buf;\n    }\n\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, data, data.length);\n    }\n\n    function resize(buffer memory buf, uint capacity) private pure {\n        bytes memory oldbuf = buf.buf;\n        init(buf, capacity);\n        append(buf, oldbuf);\n    }\n\n    function max(uint a, uint b) private pure returns (uint) {\n        if (a \u003e b) {\n            return a;\n        }\n        return b;\n    }\n}\n"},"Context.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity \u003e=0.6.0 \u003c0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"ILayerZeroEndpoint.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity \u003e=0.5.0;\n\nimport \"./ILayerZeroUserApplicationConfig.sol\";\n\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n    // @param _dstChainId - the destination chain identifier\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n    // @param _payload - a custom bytes payload to send to the destination contract\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n    function send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\n\n    // @notice used by the messaging library to publish verified payload\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source contract (as bytes) at the source chain\n    // @param _dstAddress - the address on destination chain\n    // @param _nonce - the unbound message ordering nonce\n    // @param _gasLimit - the gas limit for external contract execution\n    // @param _payload - verified payload to send to the destination contract\n    function receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) external;\n\n    // @notice get the inboundNonce of a receiver from a source chain which could be EVM or non-EVM chain\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\n\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n    // @param _srcAddress - the source chain contract address\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\n\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n    // @param _dstChainId - the destination chain identifier\n    // @param _userApplication - the user app address on this EVM chain\n    // @param _payload - the custom message to send over LayerZero\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n    function estimateFees(uint16 _dstChainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParam) external view returns (uint nativeFee, uint zroFee);\n\n    // @notice get this Endpoint\u0027s immutable source identifier\n    function getChainId() external view returns (uint16);\n\n    // @notice the interface to retry failed message on this Endpoint destination\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    // @param _payload - the payload to be retried\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\n\n    // @notice query if any STORED payload (message blocking) at the endpoint.\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n    // @notice query if the _libraryAddress is valid for sending msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the _libraryAddress is valid for receiving msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the non-reentrancy guard for send() is on\n    // @return true if the guard is on. false otherwise\n    function isSendingPayload() external view returns (bool);\n\n    // @notice query if the non-reentrancy guard for receive() is on\n    // @return true if the guard is on. false otherwise\n    function isReceivingPayload() external view returns (bool);\n\n    // @notice get the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _userApplication - the contract address of the user application\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);\n\n    // @notice get the send() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getSendVersion(address _userApplication) external view returns (uint16);\n\n    // @notice get the lzReceive() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\n}\n"},"ILayerZeroMessagingLibrary.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity \u003e=0.7.0;\n\nimport \"./ILayerZeroUserApplicationConfig.sol\";\n\ninterface ILayerZeroMessagingLibrary {\n    // send(), messages will be inflight.\n    function send(address _userApplication, uint64 _lastNonce, uint16 _chainId, bytes calldata _destination, bytes calldata _payload, address payable refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\n\n    // estimate native fee at the send side\n    function estimateFees(uint16 _chainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParam) external view returns (uint nativeFee, uint zroFee);\n\n    //---------------------------------------------------------------------------\n    // setConfig / getConfig are User Application (UA) functions to specify Oracle, Relayer, blockConfirmations, libraryVersion\n    function setConfig(uint16 _chainId, address _userApplication, uint _configType, bytes calldata _config) external;\n\n    function getConfig(uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);\n}\n"},"ILayerZeroMessagingLibraryV2.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity \u003e=0.7.0;\n\nimport \"./ILayerZeroUserApplicationConfig.sol\";\nimport \"./ILayerZeroMessagingLibrary.sol\";\n\ninterface ILayerZeroMessagingLibraryV2 is ILayerZeroMessagingLibrary {\n    function getOutboundNonce(uint16 _chainId, bytes calldata _path) external view returns (uint64);\n}\n"},"ILayerZeroOracleV2.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity \u003e=0.7.0;\n\ninterface ILayerZeroOracleV2 {\n    // @notice query price and assign jobs at the same time\n    // @param _dstChainId - the destination endpoint identifier\n    // @param _outboundProofType - the proof type identifier to specify proof to be relayed\n    // @param _outboundBlockConfirmation - block confirmation delay before relaying blocks\n    // @param _userApplication - the source sending contract address\n    function assignJob(uint16 _dstChainId, uint16 _outboundProofType, uint64 _outboundBlockConfirmation, address _userApplication) external returns (uint price);\n\n    // @notice query the oracle price for relaying block information to the destination chain\n    // @param _dstChainId the destination endpoint identifier\n    // @param _outboundProofType the proof type identifier to specify the data to be relayed\n    // @param _outboundBlockConfirmation - block confirmation delay before relaying blocks\n    // @param _userApplication - the source sending contract address\n    function getFee(uint16 _dstChainId, uint16 _outboundProofType, uint64 _outboundBlockConfirmation, address _userApplication) external view returns (uint price);\n\n    // @notice withdraw the accrued fee in ultra light node\n    // @param _to - the fee receiver\n    // @param _amount - the withdrawal amount\n    function withdrawFee(address payable _to, uint _amount) external;\n}\n"},"ILayerZeroReceiver.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity \u003e=0.5.0;\n\ninterface ILayerZeroReceiver {\n    // @notice LayerZero endpoint will invoke this function to deliver the message on the destination\n    // @param _srcChainId - the source endpoint identifier\n    // @param _srcAddress - the source sending contract address from the source chain\n    // @param _nonce - the ordered message nonce\n    // @param _payload - the signed payload is the UA bytes has encoded to be sent\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) external;\n}\n"},"ILayerZeroRelayerV2.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity \u003e=0.7.0;\n\ninterface ILayerZeroRelayerV2 {\n    // @notice query price and assign jobs at the same time\n    // @param _dstChainId - the destination endpoint identifier\n    // @param _outboundProofType - the proof type identifier to specify proof to be relayed\n    // @param _userApplication - the source sending contract address. relayers may apply price discrimination to user apps\n    // @param _payloadSize - the length of the payload. it is an indicator of gas usage for relaying cross-chain messages\n    // @param _adapterParams - optional parameters for extra service plugins, e.g. sending dust tokens at the destination chain\n    function assignJob(uint16 _dstChainId, uint16 _outboundProofType, address _userApplication, uint _payloadSize, bytes calldata _adapterParams) external returns (uint price);\n\n    // @notice query the relayer price for relaying the payload and its proof to the destination chain\n    // @param _dstChainId - the destination endpoint identifier\n    // @param _outboundProofType - the proof type identifier to specify proof to be relayed\n    // @param _userApplication - the source sending contract address. relayers may apply price discrimination to user apps\n    // @param _payloadSize - the length of the payload. it is an indicator of gas usage for relaying cross-chain messages\n    // @param _adapterParams - optional parameters for extra service plugins, e.g. sending dust tokens at the destination chain\n    function getFee(uint16 _dstChainId, uint16 _outboundProofType, address _userApplication, uint _payloadSize, bytes calldata _adapterParams) external view returns (uint price);\n\n    // @notice withdraw the accrued fee in ultra light node\n    // @param _to - the fee receiver\n    // @param _amount - the withdrawal amount\n    function withdrawFee(address payable _to, uint _amount) external;\n}\n"},"ILayerZeroTreasury.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity \u003e=0.5.0;\n\ninterface ILayerZeroTreasury {\n    function getFees(bool payInZro, uint relayerFee, uint oracleFee) external view returns (uint);\n}\n"},"ILayerZeroUltraLightNodeV2.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity \u003e=0.7.0;\npragma abicoder v2;\n\ninterface ILayerZeroUltraLightNodeV2 {\n    // Relayer functions\n    function validateTransactionProof(uint16 _srcChainId, address _dstAddress, uint _gasLimit, bytes32 _lookupHash, bytes32 _blockData, bytes calldata _transactionProof) external;\n\n    // an Oracle delivers the block data using updateHash()\n    function updateHash(uint16 _srcChainId, bytes32 _lookupHash, uint _confirmations, bytes32 _blockData) external;\n\n    // can only withdraw the receivable of the msg.sender\n    function withdrawNative(address payable _to, uint _amount) external;\n\n    function withdrawZRO(address _to, uint _amount) external;\n\n    // view functions\n    function getAppConfig(uint16 _remoteChainId, address _userApplicationAddress) external view returns (ApplicationConfiguration memory);\n\n    function accruedNativeFee(address _address) external view returns (uint);\n\n    struct ApplicationConfiguration {\n        uint16 inboundProofLibraryVersion;\n        uint64 inboundBlockConfirmations;\n        address relayer;\n        uint16 outboundProofType;\n        uint64 outboundBlockConfirmations;\n        address oracle;\n    }\n\n    event HashReceived(uint16 indexed srcChainId, address indexed oracle, bytes32 lookupHash, bytes32 blockData, uint confirmations);\n    event RelayerParams(bytes adapterParams, uint16 outboundProofType);\n    event Packet(bytes payload);\n    event InvalidDst(uint16 indexed srcChainId, bytes srcAddress, address indexed dstAddress, uint64 nonce, bytes32 payloadHash);\n    event PacketReceived(uint16 indexed srcChainId, bytes srcAddress, address indexed dstAddress, uint64 nonce, bytes32 payloadHash);\n    event AppConfigUpdated(address indexed userApplication, uint indexed configType, bytes newConfig);\n    event AddInboundProofLibraryForChain(uint16 indexed chainId, address lib);\n    event EnableSupportedOutboundProof(uint16 indexed chainId, uint16 proofType);\n    event SetChainAddressSize(uint16 indexed chainId, uint size);\n    event SetDefaultConfigForChainId(uint16 indexed chainId, uint16 inboundProofLib, uint64 inboundBlockConfirm, address relayer, uint16 outboundProofType, uint64 outboundBlockConfirm, address oracle);\n    event SetDefaultAdapterParamsForChainId(uint16 indexed chainId, uint16 indexed proofType, bytes adapterParams);\n    event SetLayerZeroToken(address indexed tokenAddress);\n    event SetRemoteUln(uint16 indexed chainId, bytes32 uln);\n    event SetTreasury(address indexed treasuryAddress);\n    event WithdrawZRO(address indexed msgSender, address indexed to, uint amount);\n    event WithdrawNative(address indexed msgSender, address indexed to, uint amount);\n}\n"},"ILayerZeroUserApplicationConfig.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity \u003e=0.5.0;\n\ninterface ILayerZeroUserApplicationConfig {\n    // @notice set the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    // @param _config - configuration in the bytes. can encode arbitrary content.\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external;\n\n    // @notice set the send() LayerZero messaging library version to _version\n    // @param _version - new messaging library version\n    function setSendVersion(uint16 _version) external;\n\n    // @notice set the lzReceive() LayerZero messaging library version to _version\n    // @param _version - new messaging library version\n    function setReceiveVersion(uint16 _version) external;\n\n    // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\n    // @param _srcChainId - the chainId of the source chain\n    // @param _srcAddress - the contract address of the source contract at the source chain\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\n}\n"},"ILayerZeroValidationLibrary.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity \u003e=0.7.0;\npragma abicoder v2;\n\nimport \"./LayerZeroPacket.sol\";\n\ninterface ILayerZeroValidationLibrary {\n    function validateProof(bytes32 blockData, bytes calldata _data, uint _remoteAddressSize) external returns (LayerZeroPacket.Packet memory packet);\n}\n"},"LayerZeroPacket.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"./Buffer.sol\";\nimport \"./SafeMath.sol\";\n\nlibrary LayerZeroPacket {\n    using Buffer for Buffer.buffer;\n    using SafeMath for uint;\n\n    struct Packet {\n        uint16 srcChainId;\n        uint16 dstChainId;\n        uint64 nonce;\n        address dstAddress;\n        bytes srcAddress;\n        bytes32 ulnAddress;\n        bytes payload;\n    }\n\n    function getPacket(\n        bytes memory data,\n        uint16 srcChain,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) internal pure returns (LayerZeroPacket.Packet memory) {\n        uint16 dstChainId;\n        address dstAddress;\n        uint size;\n        uint64 nonce;\n\n        // The log consists of the destination chain id and then a bytes payload\n        //      0--------------------------------------------31\n        // 0   |  total bytes size\n        // 32  |  destination chain id\n        // 64  |  bytes offset\n        // 96  |  bytes array size\n        // 128 |  payload\n        assembly {\n            dstChainId := mload(add(data, 32))\n            size := mload(add(data, 96)) /// size of the byte array\n            nonce := mload(add(data, 104)) // offset to convert to uint64  128  is index -24\n            dstAddress := mload(add(data, sub(add(128, sizeOfSrcAddress), 4))) // offset to convert to address 12 -8\n        }\n\n        Buffer.buffer memory srcAddressBuffer;\n        srcAddressBuffer.init(sizeOfSrcAddress);\n        srcAddressBuffer.writeRawBytes(0, data, 136, sizeOfSrcAddress); // 128 + 8\n\n        uint payloadSize = size.sub(28).sub(sizeOfSrcAddress);\n        Buffer.buffer memory payloadBuffer;\n        payloadBuffer.init(payloadSize);\n        payloadBuffer.writeRawBytes(0, data, sizeOfSrcAddress.add(156), payloadSize); // 148 + 8\n        return LayerZeroPacket.Packet(srcChain, dstChainId, nonce, dstAddress, srcAddressBuffer.buf, ulnAddress, payloadBuffer.buf);\n    }\n\n    function getPacketV2(\n        bytes memory data,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) internal pure returns (LayerZeroPacket.Packet memory) {\n        // packet def: abi.encodePacked(nonce, srcChain, srcAddress, dstChain, dstAddress, payload);\n        // data def: abi.encode(packet) = offset(32) + length(32) + packet\n        //              if from EVM\n        // 0 - 31       0 - 31          |  total bytes size\n        // 32 - 63      32 - 63         |  location\n        // 64 - 95      64 - 95         |  size of the packet\n        // 96 - 103     96 - 103        |  nonce\n        // 104 - 105    104 - 105       |  srcChainId\n        // 106 - P      106 - 125       |  srcAddress, where P = 106 + sizeOfSrcAddress - 1,\n        // P+1 - P+2    126 - 127       |  dstChainId\n        // P+3 - P+22   128 - 147       |  dstAddress\n        // P+23 - END   148 - END       |  payload\n\n        // decode the packet\n        uint256 realSize;\n        uint64 nonce;\n        uint16 srcChain;\n        uint16 dstChain;\n        address dstAddress;\n        assembly {\n            realSize := mload(add(data, 64))\n            nonce := mload(add(data, 72)) // 104 - 32\n            srcChain := mload(add(data, 74)) // 106 - 32\n            dstChain := mload(add(data, add(76, sizeOfSrcAddress))) // P + 3 - 32 = 105 + size + 3 - 32 = 76 + size\n            dstAddress := mload(add(data, add(96, sizeOfSrcAddress))) // P + 23 - 32 = 105 + size + 23 - 32 = 96 + size\n        }\n\n        require(srcChain != 0, \"LayerZeroPacket: invalid packet\");\n\n        Buffer.buffer memory srcAddressBuffer;\n        srcAddressBuffer.init(sizeOfSrcAddress);\n        srcAddressBuffer.writeRawBytes(0, data, 106, sizeOfSrcAddress);\n\n        uint nonPayloadSize = sizeOfSrcAddress.add(32);// 2 + 2 + 8 + 20, 32 + 20 = 52 if sizeOfSrcAddress == 20\n        uint payloadSize = realSize.sub(nonPayloadSize);\n        Buffer.buffer memory payloadBuffer;\n        payloadBuffer.init(payloadSize);\n        payloadBuffer.writeRawBytes(0, data, nonPayloadSize.add(96), payloadSize);\n\n        return LayerZeroPacket.Packet(srcChain, dstChain, nonce, dstAddress, srcAddressBuffer.buf, ulnAddress, payloadBuffer.buf);\n    }\n\n    function getPacketV3(\n        bytes memory data,\n        uint sizeOfSrcAddress,\n        bytes32 ulnAddress\n    ) internal pure returns (LayerZeroPacket.Packet memory) {\n        // data def: abi.encodePacked(nonce, srcChain, srcAddress, dstChain, dstAddress, payload);\n        //              if from EVM\n        // 0 - 31       0 - 31          |  total bytes size\n        // 32 - 39      32 - 39         |  nonce\n        // 40 - 41      40 - 41         |  srcChainId\n        // 42 - P       42 - 61         |  srcAddress, where P = 41 + sizeOfSrcAddress,\n        // P+1 - P+2    62 - 63         |  dstChainId\n        // P+3 - P+22   64 - 83         |  dstAddress\n        // P+23 - END   84 - END        |  payload\n\n        // decode the packet\n        uint256 realSize = data.length;\n        uint nonPayloadSize = sizeOfSrcAddress.add(32);// 2 + 2 + 8 + 20, 32 + 20 = 52 if sizeOfSrcAddress == 20\n        require(realSize \u003e= nonPayloadSize, \"LayerZeroPacket: invalid packet\");\n        uint payloadSize = realSize - nonPayloadSize;\n\n        uint64 nonce;\n        uint16 srcChain;\n        uint16 dstChain;\n        address dstAddress;\n        assembly {\n            nonce := mload(add(data, 8)) // 40 - 32\n            srcChain := mload(add(data, 10)) // 42 - 32\n            dstChain := mload(add(data, add(12, sizeOfSrcAddress))) // P + 3 - 32 = 41 + size + 3 - 32 = 12 + size\n            dstAddress := mload(add(data, add(32, sizeOfSrcAddress))) // P + 23 - 32 = 41 + size + 23 - 32 = 32 + size\n        }\n\n        require(srcChain != 0, \"LayerZeroPacket: invalid packet\");\n\n        Buffer.buffer memory srcAddressBuffer;\n        srcAddressBuffer.init(sizeOfSrcAddress);\n        srcAddressBuffer.writeRawBytes(0, data, 42, sizeOfSrcAddress);\n\n        Buffer.buffer memory payloadBuffer;\n        if (payloadSize \u003e 0) {\n            payloadBuffer.init(payloadSize);\n            payloadBuffer.writeRawBytes(0, data, nonPayloadSize.add(32), payloadSize);\n        }\n\n        return LayerZeroPacket.Packet(srcChain, dstChain, nonce, dstAddress, srcAddressBuffer.buf, ulnAddress, payloadBuffer.buf);\n    }\n}\n"},"NonceContract.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\nimport \"./ILayerZeroEndpoint.sol\";\n\ncontract NonceContract {\n    ILayerZeroEndpoint public immutable endpoint;\n    // outboundNonce = [dstChainId][remoteAddress + localAddress]\n    mapping(uint16 =\u003e mapping(bytes =\u003e uint64)) public outboundNonce;\n\n    constructor(address _endpoint) {\n        endpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function increment(uint16 _chainId, address _ua, bytes calldata _path) external returns (uint64) {\n        require(endpoint.getSendLibraryAddress(_ua) == msg.sender, \"NonceContract: msg.sender is not valid sendlibrary\");\n        return ++outboundNonce[_chainId][_path];\n    }\n}\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"},"ReentrancyGuard.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\u0027s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\u0027s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\u0027s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"},"SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./IERC20.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \u0027safeIncreaseAllowance\u0027 and \u0027safeDecreaseAllowance\u0027\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\u0027s return data size checking mechanism, since\n        // we\u0027re implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c \u003c a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b \u003e a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003e 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003e 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        return a % b;\n    }\n}\n"},"UltraLightNodeV2.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./Ownable.sol\";\nimport \"./SafeMath.sol\";\nimport \"./ReentrancyGuard.sol\";\nimport \"./IERC20.sol\";\nimport \"./SafeERC20.sol\";\n\nimport \"./ILayerZeroValidationLibrary.sol\";\nimport \"./ILayerZeroReceiver.sol\";\nimport \"./ILayerZeroTreasury.sol\";\nimport \"./ILayerZeroEndpoint.sol\";\n// v2\nimport \"./ILayerZeroMessagingLibraryV2.sol\";\nimport \"./ILayerZeroOracleV2.sol\";\nimport \"./ILayerZeroUltraLightNodeV2.sol\";\nimport \"./ILayerZeroRelayerV2.sol\";\nimport \"./NonceContract.sol\";\n\ncontract UltraLightNodeV2 is ILayerZeroMessagingLibraryV2, ILayerZeroUltraLightNodeV2, ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n\n    // Application config\n    uint public constant CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION = 1;\n    uint public constant CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS = 2;\n    uint public constant CONFIG_TYPE_RELAYER = 3;\n    uint public constant CONFIG_TYPE_OUTBOUND_PROOF_TYPE = 4;\n    uint public constant CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS = 5;\n    uint public constant CONFIG_TYPE_ORACLE = 6;\n\n    // Token and Contracts\n    IERC20 public layerZeroToken;\n    ILayerZeroTreasury public treasuryContract;\n\n    mapping(address =\u003e uint) public nativeFees;\n    uint public treasuryZROFees;\n\n    // User Application\n    mapping(address =\u003e mapping(uint16 =\u003e ApplicationConfiguration)) public appConfig; // app address =\u003e chainId =\u003e config\n    mapping(uint16 =\u003e ApplicationConfiguration) public defaultAppConfig; // default UA settings if no version specified\n    mapping(uint16 =\u003e mapping(uint16 =\u003e bytes)) public defaultAdapterParams;\n\n    // Validation\n    mapping(uint16 =\u003e mapping(uint16 =\u003e address)) public inboundProofLibrary; // chainId =\u003e library Id =\u003e inboundProofLibrary contract\n    mapping(uint16 =\u003e uint16) public maxInboundProofLibrary; // chainId =\u003e inboundProofLibrary\n    mapping(uint16 =\u003e mapping(uint16 =\u003e bool)) public supportedOutboundProof; // chainId =\u003e outboundProofType =\u003e enabled\n    mapping(uint16 =\u003e uint) public chainAddressSizeMap;\n    mapping(address =\u003e mapping(uint16 =\u003e mapping(bytes32 =\u003e mapping(bytes32 =\u003e uint)))) public hashLookup; //[oracle][srcChainId][blockhash][datahash] -\u003e confirmation\n    mapping(uint16 =\u003e bytes32) public ulnLookup; // remote ulns\n\n    ILayerZeroEndpoint public immutable endpoint;\n    uint16 public immutable localChainId;\n    NonceContract public immutable nonceContract;\n\n    constructor(address _endpoint, address _nonceContract, uint16 _localChainId) {\n        require(_endpoint != address(0x0), \"LayerZero: endpoint cannot be zero address\");\n        require(_nonceContract != address(0x0), \"LayerZero: nonceContract cannot be zero address\");\n        ILayerZeroEndpoint lzEndpoint = ILayerZeroEndpoint(_endpoint);\n        localChainId = _localChainId;\n        endpoint = lzEndpoint;\n        nonceContract = NonceContract(_nonceContract);\n    }\n\n    // only the endpoint can call SEND() and setConfig()\n    modifier onlyEndpoint() {\n        require(address(endpoint) == msg.sender, \"LayerZero: only endpoint\");\n        _;\n    }\n\n    //----------------------------------------------------------------------------------\n    // PROTOCOL\n    function validateTransactionProof(uint16 _srcChainId, address _dstAddress, uint _gasLimit, bytes32 _lookupHash, bytes32 _blockData, bytes calldata _transactionProof) external override {\n        // retrieve UA\u0027s configuration using the _dstAddress from arguments.\n        ApplicationConfiguration memory uaConfig = _getAppConfig(_srcChainId, _dstAddress);\n\n        // assert that the caller == UA\u0027s relayer\n        require(uaConfig.relayer == msg.sender, \"LayerZero: invalid relayer\");\n\n        LayerZeroPacket.Packet memory _packet;\n        uint remoteAddressSize = chainAddressSizeMap[_srcChainId];\n        require(remoteAddressSize != 0, \"LayerZero: incorrect remote address size\");\n        {\n            // assert that the data submitted by UA\u0027s oracle have no fewer confirmations than UA\u0027s configuration\n            uint storedConfirmations = hashLookup[uaConfig.oracle][_srcChainId][_lookupHash][_blockData];\n            require(storedConfirmations \u003e 0 \u0026\u0026 storedConfirmations \u003e= uaConfig.inboundBlockConfirmations, \"LayerZero: not enough block confirmations\");\n\n            // decode\n            address inboundProofLib = inboundProofLibrary[_srcChainId][uaConfig.inboundProofLibraryVersion];\n            _packet = ILayerZeroValidationLibrary(inboundProofLib).validateProof(_blockData, _transactionProof, remoteAddressSize);\n        }\n\n        // packet content assertion\n        require(ulnLookup[_srcChainId] == _packet.ulnAddress \u0026\u0026 _packet.ulnAddress != bytes32(0), \"LayerZero: invalid _packet.ulnAddress\");\n        require(_packet.srcChainId == _srcChainId, \"LayerZero: invalid srcChain Id\");\n        // failsafe because the remoteAddress size being passed into validateProof trims the address this should not hit\n        require(_packet.srcAddress.length == remoteAddressSize, \"LayerZero: invalid srcAddress size\");\n        require(_packet.dstChainId == localChainId, \"LayerZero: invalid dstChain Id\");\n        require(_packet.dstAddress == _dstAddress, \"LayerZero: invalid dstAddress\");\n\n        // if the dst is not a contract, then emit and return early. This will break inbound nonces, but this particular\n        // path is already broken and wont ever be able to deliver anyways\n        if (!_isContract(_dstAddress)) {\n            emit InvalidDst(_packet.srcChainId, _packet.srcAddress, _packet.dstAddress, _packet.nonce, keccak256(_packet.payload));\n            return;\n        }\n\n        bytes memory pathData = abi.encodePacked(_packet.srcAddress, _packet.dstAddress);\n        emit PacketReceived(_packet.srcChainId, _packet.srcAddress, _packet.dstAddress, _packet.nonce, keccak256(_packet.payload));\n        endpoint.receivePayload(_srcChainId, pathData, _dstAddress, _packet.nonce, _gasLimit, _packet.payload);\n    }\n\n    function send(address _ua, uint64, uint16 _dstChainId, bytes calldata _path, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable override onlyEndpoint {\n        address ua = _ua;\n        uint16 dstChainId = _dstChainId;\n        require(ulnLookup[dstChainId] != bytes32(0), \"LayerZero: dstChainId does not exist\");\n\n        bytes memory dstAddress;\n        uint64 nonce;\n        // code block for solving \u0027Stack Too Deep\u0027\n        {\n            uint chainAddressSize = chainAddressSizeMap[dstChainId];\n            // path = remoteAddress + localAddress\n            require(chainAddressSize != 0 \u0026\u0026 _path.length == 20 + chainAddressSize, \"LayerZero: incorrect remote address size\");\n            address srcInPath;\n            bytes memory path = _path; // copy to memory\n            assembly {\n                srcInPath := mload(add(add(path, 20), chainAddressSize)) // chainAddressSize + 20\n            }\n            require(ua == srcInPath, \"LayerZero: wrong path data\");\n            dstAddress = _path[0:chainAddressSize];\n            nonce = nonceContract.increment(dstChainId, ua, path);\n        }\n\n        bytes memory payload = _payload;\n        ApplicationConfiguration memory uaConfig = _getAppConfig(dstChainId, ua);\n\n        // compute all the fees\n        uint relayerFee = _handleRelayer(dstChainId, uaConfig, ua, payload.length, _adapterParams);\n        uint oracleFee = _handleOracle(dstChainId, uaConfig, ua);\n        uint nativeProtocolFee = _handleProtocolFee(relayerFee, oracleFee, ua, _zroPaymentAddress);\n\n        // total native fee, does not include ZRO protocol fee\n        uint totalNativeFee = relayerFee.add(oracleFee).add(nativeProtocolFee);\n\n        // assert the user has attached enough native token for this address\n        require(totalNativeFee \u003c= msg.value, \"LayerZero: not enough native for fees\");\n        // refund if they send too much\n        uint amount = msg.value.sub(totalNativeFee);\n        if (amount \u003e 0) {\n            (bool success, ) = _refundAddress.call{value: amount}(\"\");\n            require(success, \"LayerZero: failed to refund\");\n        }\n\n        // emit the data packet\n        bytes memory encodedPayload = abi.encodePacked(nonce, localChainId, ua, dstChainId, dstAddress, payload);\n        emit Packet(encodedPayload);\n    }\n\n    function _handleRelayer(uint16 _dstChainId, ApplicationConfiguration memory _uaConfig, address _ua, uint _payloadSize, bytes memory _adapterParams) internal returns (uint relayerFee) {\n        if (_adapterParams.length == 0) {\n            _adapterParams = defaultAdapterParams[_dstChainId][_uaConfig.outboundProofType];\n        }\n        address relayerAddress = _uaConfig.relayer;\n        ILayerZeroRelayerV2 relayer = ILayerZeroRelayerV2(relayerAddress);\n        relayerFee = relayer.assignJob(_dstChainId, _uaConfig.outboundProofType, _ua, _payloadSize, _adapterParams);\n\n        _creditNativeFee(relayerAddress, relayerFee);\n\n        // emit the param events\n        emit RelayerParams(_adapterParams, _uaConfig.outboundProofType);\n    }\n\n    function _handleOracle(uint16 _dstChainId, ApplicationConfiguration memory _uaConfig, address _ua) internal returns (uint oracleFee) {\n        address oracleAddress = _uaConfig.oracle;\n        oracleFee = ILayerZeroOracleV2(oracleAddress).assignJob(_dstChainId, _uaConfig.outboundProofType, _uaConfig.outboundBlockConfirmations, _ua);\n\n        _creditNativeFee(oracleAddress, oracleFee);\n    }\n\n    function _handleProtocolFee(uint _relayerFee, uint _oracleFee, address _ua, address _zroPaymentAddress) internal returns (uint protocolNativeFee) {\n        // if no ZRO token or not specifying a payment address, pay in native token\n        bool payInNative = _zroPaymentAddress == address(0x0) || address(layerZeroToken) == address(0x0);\n        uint protocolFee = treasuryContract.getFees(!payInNative, _relayerFee, _oracleFee);\n\n        if (protocolFee \u003e 0) {\n            if (payInNative) {\n                address treasuryAddress = address(treasuryContract);\n                _creditNativeFee(treasuryAddress, protocolFee);\n                protocolNativeFee = protocolFee;\n            } else {\n                // zro payment address must equal the ua or the tx.origin otherwise the transaction reverts\n                require(_zroPaymentAddress == _ua || _zroPaymentAddress == tx.origin, \"LayerZero: must be paid by sender or origin\");\n\n                // transfer the LayerZero token to this contract from the payee\n                layerZeroToken.safeTransferFrom(_zroPaymentAddress, address(this), protocolFee);\n\n                treasuryZROFees = treasuryZROFees.add(protocolFee);\n            }\n        }\n    }\n\n    function _creditNativeFee(address _receiver, uint _amount) internal {\n        nativeFees[_receiver] = nativeFees[_receiver].add(_amount);\n    }\n\n    // Can be called by any address to update a block header\n    // can only upload new block data or the same block data with more confirmations\n    function updateHash(uint16 _srcChainId, bytes32 _lookupHash, uint _confirmations, bytes32 _blockData) external override {\n        uint storedConfirmations = hashLookup[msg.sender][_srcChainId][_lookupHash][_blockData];\n\n        // if it has a record, requires a larger confirmation.\n        require(storedConfirmations \u003c _confirmations, \"LayerZero: oracle data can only update if it has more confirmations\");\n\n        // set the new information into storage\n        hashLookup[msg.sender][_srcChainId][_lookupHash][_blockData] = _confirmations;\n\n        emit HashReceived(_srcChainId, msg.sender, _lookupHash, _blockData, _confirmations);\n    }\n\n    //----------------------------------------------------------------------------------\n    // Other Library Interfaces\n\n    // default to DEFAULT setting if ZERO value\n    function getAppConfig(uint16 _remoteChainId, address _ua) external view override returns (ApplicationConfiguration memory) {\n        return _getAppConfig(_remoteChainId, _ua);\n    }\n\n    function _getAppConfig(uint16 _remoteChainId, address _ua) internal view returns (ApplicationConfiguration memory) {\n        ApplicationConfiguration memory config = appConfig[_ua][_remoteChainId];\n        ApplicationConfiguration storage defaultConfig = defaultAppConfig[_remoteChainId];\n\n        if (config.inboundProofLibraryVersion == 0) {\n            config.inboundProofLibraryVersion = defaultConfig.inboundProofLibraryVersion;\n        }\n\n        if (config.inboundBlockConfirmations == 0) {\n            config.inboundBlockConfirmations = defaultConfig.inboundBlockConfirmations;\n        }\n\n        if (config.relayer == address(0x0)) {\n            config.relayer = defaultConfig.relayer;\n        }\n\n        if (config.outboundProofType == 0) {\n            config.outboundProofType = defaultConfig.outboundProofType;\n        }\n\n        if (config.outboundBlockConfirmations == 0) {\n            config.outboundBlockConfirmations = defaultConfig.outboundBlockConfirmations;\n        }\n\n        if (config.oracle == address(0x0)) {\n            config.oracle = defaultConfig.oracle;\n        }\n\n        return config;\n    }\n\n    function setConfig(uint16 _remoteChainId, address _ua, uint _configType, bytes calldata _config) external override onlyEndpoint {\n        ApplicationConfiguration storage uaConfig = appConfig[_ua][_remoteChainId];\n        if (_configType == CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION) {\n            uint16 inboundProofLibraryVersion = abi.decode(_config, (uint16));\n            require(inboundProofLibraryVersion \u003c= maxInboundProofLibrary[_remoteChainId], \"LayerZero: invalid inbound proof library version\");\n            uaConfig.inboundProofLibraryVersion = inboundProofLibraryVersion;\n        } else if (_configType == CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS) {\n            uint64 blockConfirmations = abi.decode(_config, (uint64));\n            uaConfig.inboundBlockConfirmations = blockConfirmations;\n        } else if (_configType == CONFIG_TYPE_RELAYER) {\n            address relayer = abi.decode(_config, (address));\n            uaConfig.relayer = relayer;\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_PROOF_TYPE) {\n            uint16 outboundProofType = abi.decode(_config, (uint16));\n            require(supportedOutboundProof[_remoteChainId][outboundProofType] || outboundProofType == 0, \"LayerZero: invalid outbound proof type\");\n            uaConfig.outboundProofType = outboundProofType;\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS) {\n            uint64 blockConfirmations = abi.decode(_config, (uint64));\n            uaConfig.outboundBlockConfirmations = blockConfirmations;\n        } else if (_configType == CONFIG_TYPE_ORACLE) {\n            address oracle = abi.decode(_config, (address));\n            uaConfig.oracle = oracle;\n        } else {\n            revert(\"LayerZero: Invalid config type\");\n        }\n\n        emit AppConfigUpdated(_ua, _configType, _config);\n    }\n\n    function getConfig(uint16 _remoteChainId, address _ua, uint _configType) external view override returns (bytes memory) {\n        ApplicationConfiguration storage uaConfig = appConfig[_ua][_remoteChainId];\n\n        if (_configType == CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION) {\n            if (uaConfig.inboundProofLibraryVersion == 0) {\n                return abi.encode(defaultAppConfig[_remoteChainId].inboundProofLibraryVersion);\n            }\n            return abi.encode(uaConfig.inboundProofLibraryVersion);\n        } else if (_configType == CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS) {\n            if (uaConfig.inboundBlockConfirmations == 0) {\n                return abi.encode(defaultAppConfig[_remoteChainId].inboundBlockConfirmations);\n            }\n            return abi.encode(uaConfig.inboundBlockConfirmations);\n        } else if (_configType == CONFIG_TYPE_RELAYER) {\n            if (uaConfig.relayer == address(0x0)) {\n                return abi.encode(defaultAppConfig[_remoteChainId].relayer);\n            }\n            return abi.encode(uaConfig.relayer);\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_PROOF_TYPE) {\n            if (uaConfig.outboundProofType == 0) {\n                return abi.encode(defaultAppConfig[_remoteChainId].outboundProofType);\n            }\n            return abi.encode(uaConfig.outboundProofType);\n        } else if (_configType == CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS) {\n            if (uaConfig.outboundBlockConfirmations == 0) {\n                return abi.encode(defaultAppConfig[_remoteChainId].outboundBlockConfirmations);\n            }\n            return abi.encode(uaConfig.outboundBlockConfirmations);\n        } else if (_configType == CONFIG_TYPE_ORACLE) {\n            if (uaConfig.oracle == address(0x0)) {\n                return abi.encode(defaultAppConfig[_remoteChainId].oracle);\n            }\n            return abi.encode(uaConfig.oracle);\n        } else {\n            revert(\"LayerZero: Invalid config type\");\n        }\n    }\n\n    // returns the native fee the UA pays to cover fees\n    function estimateFees(uint16 _dstChainId, address _ua, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParams) external view override returns (uint nativeFee, uint zroFee) {\n        ApplicationConfiguration memory uaConfig = _getAppConfig(_dstChainId, _ua);\n\n        // Relayer Fee\n        bytes memory adapterParams;\n        if (_adapterParams.length \u003e 0) {\n            adapterParams = _adapterParams;\n        } else {\n            adapterParams = defaultAdapterParams[_dstChainId][uaConfig.outboundProofType];\n        }\n        uint relayerFee = ILayerZeroRelayerV2(uaConfig.relayer).getFee(_dstChainId, uaConfig.outboundProofType, _ua, _payload.length, adapterParams);\n\n        // Oracle Fee\n        address ua = _ua; // stack too deep\n        uint oracleFee = ILayerZeroOracleV2(uaConfig.oracle).getFee(_dstChainId, uaConfig.outboundProofType, uaConfig.outboundBlockConfirmations, ua);\n\n        // LayerZero Fee\n        uint protocolFee = treasuryContract.getFees(_payInZRO, relayerFee, oracleFee);\n        _payInZRO ? zroFee = protocolFee : nativeFee = protocolFee;\n\n        // return the sum of fees\n        nativeFee = nativeFee.add(relayerFee).add(oracleFee);\n    }\n\n    //---------------------------------------------------------------------------\n    // Claim Fees\n\n    // universal withdraw ZRO token function\n    function withdrawZRO(address _to, uint _amount) external override nonReentrant {\n        require(msg.sender == address(treasuryContract), \"LayerZero: only treasury\");\n        treasuryZROFees = treasuryZROFees.sub(_amount);\n        layerZeroToken.safeTransfer(_to, _amount);\n        emit WithdrawZRO(msg.sender, _to, _amount);\n    }\n\n    // universal withdraw native token function.\n    // the source contract should perform all the authentication control\n    function withdrawNative(address payable _to, uint _amount) external override nonReentrant {\n        require(_to != address(0x0), \"LayerZero: _to cannot be zero address\");\n        nativeFees[msg.sender] = nativeFees[msg.sender].sub(_amount);\n\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        require(success, \"LayerZero: withdraw failed\");\n        emit WithdrawNative(msg.sender, _to, _amount);\n    }\n\n    //---------------------------------------------------------------------------\n    // Owner calls, configuration only.\n    function setLayerZeroToken(address _layerZeroToken) external onlyOwner {\n        require(_layerZeroToken != address(0x0), \"LayerZero: _layerZeroToken cannot be zero address\");\n        layerZeroToken = IERC20(_layerZeroToken);\n        emit SetLayerZeroToken(_layerZeroToken);\n    }\n\n    function setTreasury(address _treasury) external onlyOwner {\n        require(_treasury != address(0x0), \"LayerZero: treasury cannot be zero address\");\n        treasuryContract = ILayerZeroTreasury(_treasury);\n        emit SetTreasury(_treasury);\n    }\n\n    function addInboundProofLibraryForChain(uint16 _chainId, address _library) external onlyOwner {\n        require(_library != address(0x0), \"LayerZero: library cannot be zero address\");\n        uint16 libId = maxInboundProofLibrary[_chainId];\n        require(libId \u003c 65535, \"LayerZero: can not add new library\");\n        maxInboundProofLibrary[_chainId] = ++libId;\n        inboundProofLibrary[_chainId][libId] = _library;\n        emit AddInboundProofLibraryForChain(_chainId, _library);\n    }\n\n    function enableSupportedOutboundProof(uint16 _chainId, uint16 _proofType) external onlyOwner {\n        supportedOutboundProof[_chainId][_proofType] = true;\n        emit EnableSupportedOutboundProof(_chainId, _proofType);\n    }\n\n    function setDefaultConfigForChainId(uint16 _chainId, uint16 _inboundProofLibraryVersion, uint64 _inboundBlockConfirmations, address _relayer, uint16 _outboundProofType, uint64 _outboundBlockConfirmations, address _oracle) external onlyOwner {\n        require(_inboundProofLibraryVersion \u003c= maxInboundProofLibrary[_chainId] \u0026\u0026 _inboundProofLibraryVersion \u003e 0, \"LayerZero: invalid inbound proof library version\");\n        require(_inboundBlockConfirmations \u003e 0, \"LayerZero: invalid inbound block confirmation\");\n        require(_relayer != address(0x0), \"LayerZero: invalid relayer address\");\n        require(supportedOutboundProof[_chainId][_outboundProofType], \"LayerZero: invalid outbound proof type\");\n        require(_outboundBlockConfirmations \u003e 0, \"LayerZero: invalid outbound block confirmation\");\n        require(_oracle != address(0x0), \"LayerZero: invalid oracle address\");\n        defaultAppConfig[_chainId] = ApplicationConfiguration(_inboundProofLibraryVersion, _inboundBlockConfirmations, _relayer, _outboundProofType, _outboundBlockConfirmations, _oracle);\n        emit SetDefaultConfigForChainId(_chainId, _inboundProofLibraryVersion, _inboundBlockConfirmations, _relayer, _outboundProofType, _outboundBlockConfirmations, _oracle);\n    }\n\n    function setDefaultAdapterParamsForChainId(uint16 _chainId, uint16 _proofType, bytes calldata _adapterParams) external onlyOwner {\n        defaultAdapterParams[_chainId][_proofType] = _adapterParams;\n        emit SetDefaultAdapterParamsForChainId(_chainId, _proofType, _adapterParams);\n    }\n\n    function setRemoteUln(uint16 _remoteChainId, bytes32 _remoteUln) external onlyOwner {\n        require(ulnLookup[_remoteChainId] == bytes32(0), \"LayerZero: remote uln already set\");\n        ulnLookup[_remoteChainId] = _remoteUln;\n        emit SetRemoteUln(_remoteChainId, _remoteUln);\n    }\n\n    function setChainAddressSize(uint16 _chainId, uint _size) external onlyOwner {\n        require(chainAddressSizeMap[_chainId] == 0, \"LayerZero: remote chain address size already set\");\n        chainAddressSizeMap[_chainId] = _size;\n        emit SetChainAddressSize(_chainId, _size);\n    }\n\n    //----------------------------------------------------------------------------------\n    // view functions\n\n    function accruedNativeFee(address _address) external view override returns (uint) {\n        return nativeFees[_address];\n    }\n\n    function getOutboundNonce(uint16 _chainId, bytes calldata _path) external view override returns (uint64) {\n        return nonceContract.outboundNonce(_chainId, _path);\n    }\n\n    function _isContract(address addr) internal view returns (bool) {\n        uint size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size != 0;\n    }\n}\n"}}