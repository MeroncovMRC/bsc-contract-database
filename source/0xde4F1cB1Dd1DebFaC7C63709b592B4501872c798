{"Administrable.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.6.10;\n\ncontract Administrable {\n    /**\n     * @notice Administrator for this contract\n     */\n    address public admin;\n\n    /**\n     * @notice Pending administrator for this contract\n     */\n    address public pendingAdmin;\n\n    /**\n     * @notice Emitted when pendingAdmin is changed\n     */\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    /**\n     * @notice Emitted when pendingAdmin is accepted, which means admin is updated\n     */\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    constructor() internal {\n        // Set admin to caller\n        admin = msg.sender;\n    }\n\n    /**\n     * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @param newPendingAdmin New pending admin.\n     * @return uint 0=success, otherwise a revert\n     */\n    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            revert(\"unauthorized\");\n        }\n\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n        return 0;\n    }\n\n    /**\n     * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n     * @dev Admin function for pending admin to accept role and update admin\n     * @return uint 0=success, otherwise a revert\n     */\n    function _acceptAdmin() public returns (uint) {\n        // Check caller is pendingAdmin and pendingAdmin â‰  address(0)\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n            revert(\"unauthorized\");\n        }\n\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n\n        // Clear the pending value\n        pendingAdmin = address(0);\n\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n        return 0;\n    }\n}"},"IERC20Extended.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.6.10;\n\n/**\n * @title ERC 20 Token Standard Interface\n *  https://eips.ethereum.org/EIPS/eip-20\n */\ninterface IERC20 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"},"IExternalOracle.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.6.10;\n\ninterface IExternalOracle {\n    function decimals() external view returns (uint8);\n\n    function latestAnswer() external view returns (int256);\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n"},"PosterAccessControl.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.6.10;\n\nimport \"./Administrable.sol\";\n\ncontract PosterAccessControl is Administrable {\n    address public poster;\n\n    event NewPoster(address indexed oldPoster, address indexed newPoster);\n\n    constructor() internal {\n        _setPosterInternal(msg.sender);\n    }\n\n    function _setPoster(address newPoster) external {\n        require(msg.sender == admin, \"Unauthorized\");\n\n        _setPosterInternal(newPoster);\n    }\n\n    function _setPosterInternal(address newPoster) internal {\n        emit NewPoster(poster, newPoster);\n        poster = newPoster;\n    }\n}"},"UniswapConfig.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./Administrable.sol\";\n\ncontract UniswapConfig is Administrable {\n\n    /**\n     * @notice Emitted when tokenConfigs are updated (or initialized)\n     */\n    event ConfigUpdated(uint index, TokenConfig previousConfig, TokenConfig newConfig, address updatedBy);\n\n    /// @dev Describe how to interpret the fixedPrice in the TokenConfig.\n    enum PriceSource {\n        FIXED_USD,          /// implies the fixedPrice is a constant multiple of the USD price (which is 1)\n        UNISWAP,            /// implies the price is fetched from uniswap\n        POSTER,             /// implies the price is posted externally\n        EXTERNAL_ORACLE,    /// implies the price is read externally\n        REPOINT             /// implies the price is repointed to other asset\u0027s price\n    }\n\n    /// @dev Describe how the USD price should be determined for an asset.\n    ///  There should be 1 TokenConfig object for each supported asset.\n    struct TokenConfig {\n        address underlying;\n        bytes32 symbolHash;\n        uint256 baseUnit;\n        PriceSource priceSource;\n        uint256 fixedPrice;\n        address uniswapMarket;\n        bool isUniswapReversed;\n        bool isPairWithStablecoin;\n        address externalOracle;\n        address repointedAsset;\n        string symbol;\n    }\n\n    /// @notice The max number of tokens this contract is hardcoded to support\n    uint public constant maxTokens = 50;\n\n    /// @notice The number of tokens this contract currently supports\n    uint public numTokens;\n\n    mapping (uint =\u003e TokenConfig) internal tokenConfigs;\n\n    function _setConfigInternal(TokenConfig memory config) internal {\n        require(msg.sender == admin, \"unauthorized\");\n        require(numTokens \u003c maxTokens, \"too many configs\");\n        require(getUnderlyingIndex(config.underlying) == uint(-1), \"config exists\");\n        require(config.underlying != address(0), \"invalid config\");\n\n        emit ConfigUpdated(numTokens, tokenConfigs[uint(-1)], config, msg.sender);\n        tokenConfigs[numTokens] = config;\n        numTokens++;\n    }\n\n    function getUnderlyingIndex(address underlying) internal view returns (uint) {\n        for (uint i = 0; i \u003c numTokens; i++) {\n            if (underlying == tokenConfigs[i].underlying) return i;\n        }\n\n        return uint(-1);\n    }\n\n    function getSymbolHashIndex(bytes32 symbolHash) internal view returns (uint) {\n        for (uint i = 0; i \u003c numTokens; i++) {\n            if (symbolHash == tokenConfigs[i].symbolHash) return i;\n        }\n\n        return uint(-1);\n    }\n\n    /**\n     * @notice Get the i-th config, according to the order they were passed in originally\n     * @param i The index of the config to get\n     * @return The config object\n     */\n    function getTokenConfig(uint i) public view returns (TokenConfig memory) {\n        require(i \u003c numTokens, \"token config not found\");\n\n        return tokenConfigs[i];\n    }\n\n    /**\n     * @notice Get the config for symbol\n     * @param symbol The symbol of the config to get\n     * @return The config object\n     */\n    function getTokenConfigBySymbol(string memory symbol) public view returns (TokenConfig memory) {\n        return getTokenConfigBySymbolHash(keccak256(abi.encodePacked(symbol)));\n    }\n\n    /**\n     * @notice Get the config for the symbolHash\n     * @param symbolHash The keccack256 of the symbol of the config to get\n     * @return The config object\n     */\n    function getTokenConfigBySymbolHash(bytes32 symbolHash) public view returns (TokenConfig memory) {\n        uint index = getSymbolHashIndex(symbolHash);\n        if (index != uint(-1)) {\n            return getTokenConfig(index);\n        }\n\n        revert(\"token config not found\");\n    }\n\n    /**\n     * @notice Get the config for an underlying asset\n     * @param underlying The address of the underlying asset of the config to get\n     * @return The config object\n     */\n    function getTokenConfigByUnderlying(address underlying) public view returns (TokenConfig memory) {\n        uint index = getUnderlyingIndex(underlying);\n        if (index != uint(-1)) {\n            return getTokenConfig(index);\n        }\n\n        revert(\"token config not found\");\n    }\n}"},"UniswapHelper.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.6.10;\n\n// Based on code from https://github.com/Uniswap/uniswap-v2-periphery\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\nlibrary FixedPoint {\n    // range: [0, 2**112 - 1]\n    // resolution: 1 / 2**112\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    // returns a uq112x112 which represents the ratio of the numerator to the denominator\n    // equivalent to encode(numerator).div(denominator)\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\n        require(denominator \u003e 0, \"FixedPoint: DIV_BY_ZERO\");\n        return uq112x112((uint224(numerator) \u003c\u003c 112) / denominator);\n    }\n\n    // decode a uq112x112 into a uint with 18 decimals of precision\n    function decode112with18(uq112x112 memory self) internal pure returns (uint) {\n        // we only have 256 - 224 = 32 bits to spare, so scaling up by ~60 bits is dangerous\n        // instead, get close to:\n        //  (x * 1e18) \u003e\u003e 112\n        // without risk of overflowing, e.g.:\n        //  (x) / 2 ** (112 - lg(1e18))\n        return uint(self._x) / 5192296858534827;\n    }\n}\n\n// library with helper methods for oracles that are concerned with computing average prices\nlibrary UniswapV2OracleLibrary {\n    using FixedPoint for *;\n\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n    function currentBlockTimestamp() internal view returns (uint32) {\n        return uint32(block.timestamp % 2 ** 32);\n    }\n\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n    function currentCumulativePrices(\n        address pair\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\n        blockTimestamp = currentBlockTimestamp();\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\n        if (blockTimestampLast != blockTimestamp) {\n            // subtraction overflow is desired\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n            // addition overflow is desired\n            // counterfactual\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\n            // counterfactual\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\n        }\n    }\n}\n\ninterface IUniswapV2Pair {\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n}"},"UniswapOracleTWAP.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./UniswapConfig.sol\";\nimport \"./PosterAccessControl.sol\";\n\nimport \"./UniswapHelper.sol\";\nimport \"./IExternalOracle.sol\";\nimport \"./IERC20Extended.sol\";\n\nstruct Observation {\n    uint timestamp;\n    uint acc;\n}\n\ncontract UniswapOracleTWAP is UniswapConfig, PosterAccessControl {\n    using FixedPoint for *;\n\n    /// @notice The number of wei in 1 ETH\n    uint public constant ethBaseUnit = 1e18;\n\n    /// @notice A common scaling factor to maintain precision\n    uint public constant expScale = 1e18;\n\n    /// @notice The minimum amount of time in seconds required for the old uniswap price accumulator to be replaced\n    uint public immutable anchorPeriod;\n\n    /// @notice Official prices by symbol hash\n    mapping(bytes32 =\u003e uint) public prices;\n\n    /// @notice The old observation for each symbolHash\n    mapping(bytes32 =\u003e Observation) public oldObservations;\n\n    /// @notice The new observation for each symbolHash\n    mapping(bytes32 =\u003e Observation) public newObservations;\n\n    /// @notice Stores underlying address for different cTokens\n    mapping(address =\u003e address) public underlyings;\n\n    /// @notice The event emitted when the stored price is updated\n    event PriceUpdated(string symbol, uint price);\n\n    /// @notice The event emitted when the uniswap window changes\n    event UniswapWindowUpdated(bytes32 indexed symbolHash, uint oldTimestamp, uint newTimestamp, uint oldPrice, uint newPrice);\n\n    /// @notice The event emitted when the cToken underlying mapping is updated\n    event CTokenUnderlyingUpdated(address cToken, address underlying);\n\n    /// @notice The precision factor of base asset\u0027s (ETH) price \n    uint public basePricePrecision;\n\n    string ETH;\n    bytes32 public ethHash;\n\n    constructor(uint anchorPeriod_, string memory baseAsset_, uint basePricePrecision_) public {\n        require(basePricePrecision_ \u003c= 1e36, \"basePricePrecision_ max limit exceeded\");\n\n        anchorPeriod = anchorPeriod_;\n        ETH = baseAsset_;\n        ethHash = keccak256(abi.encodePacked(ETH));\n        basePricePrecision = basePricePrecision_;\n    }\n\n    function _setConfig(TokenConfig memory config) public {\n        // already performs some checks\n        _setConfigInternal(config);\n\n        require(config.baseUnit \u003e 0, \"baseUnit must be greater than zero\");\n        if (config.priceSource == PriceSource.UNISWAP) {\n            address uniswapMarket = config.uniswapMarket;\n            require(uniswapMarket != address(0), \"must have uni market\");\n            if (config.isPairWithStablecoin) {\n                uint8 decimals;\n                // verify precision of quote currency (stablecoin)\n                if (IUniswapV2Pair(uniswapMarket).token0() == config.underlying) {\n                    decimals = IERC20(IUniswapV2Pair(uniswapMarket).token1()).decimals();\n                } else {\n                    decimals = IERC20(IUniswapV2Pair(uniswapMarket).token0()).decimals();\n                }\n                require(10 ** uint256(decimals) == basePricePrecision, \"basePricePrecision mismatch\");\n            }\n            bytes32 symbolHash = config.symbolHash;\n            uint cumulativePrice = currentCumulativePrice(config);\n            oldObservations[symbolHash].timestamp = block.timestamp;\n            newObservations[symbolHash].timestamp = block.timestamp;\n            oldObservations[symbolHash].acc = cumulativePrice;\n            newObservations[symbolHash].acc = cumulativePrice;\n            emit UniswapWindowUpdated(symbolHash, block.timestamp, block.timestamp, cumulativePrice, cumulativePrice);\n        }\n        if (config.priceSource == PriceSource.FIXED_USD) {\n            require(config.fixedPrice != 0, \"fixedPrice must be greater than zero\");\n        }\n        if (config.priceSource == PriceSource.EXTERNAL_ORACLE) {\n            require(config.externalOracle != address(0), \"must have external oracle\");\n        }\n        if (config.priceSource == PriceSource.REPOINT) {\n            require(\n                getTokenConfigByUnderlying(config.repointedAsset)\n                    .priceSource != PriceSource.REPOINT,\n                \"repointed asset priceSource can\u0027t be REPOINT\"\n            );\n        }\n    }\n\n    function _setConfigs(TokenConfig[] memory configs) external {\n        for (uint i = 0; i \u003c configs.length; i++) {\n            _setConfig(configs[i]);\n        }\n    }\n\n    function _setPrice(address underlying, string memory symbol, uint priceMantissa) external {\n        require(msg.sender == poster, \"Unauthorized\");\n\n        TokenConfig memory config = getTokenConfigByUnderlying(underlying);\n        require(keccak256(abi.encodePacked(symbol)) == config.symbolHash, \"Invalid symbol\");\n\n        if (config.priceSource == PriceSource.POSTER) {\n            prices[config.symbolHash] = priceMantissa;\n            emit PriceUpdated(symbol, priceMantissa);\n        }\n    }\n\n    function _setUnderlyingForCToken(address cToken, address underlying) public {\n        require(msg.sender == admin, \"Unauthorized\");\n        require(underlyings[cToken] == address(0), \"underlying already exists\");\n        require(cToken != address(0) \u0026\u0026 underlying != address(0), \"invalid input\");\n\n        // token config for underlying must exist\n        TokenConfig memory config = getTokenConfigByUnderlying(underlying);\n\n        underlyings[cToken] = config.underlying;\n        emit CTokenUnderlyingUpdated(cToken, config.underlying);\n    }\n\n    function _setUnderlyingForCTokens(address[] memory _cTokens, address[] memory _underlyings) external {\n        require(_cTokens.length == _underlyings.length, \"length mismatch\");\n        for (uint i = 0; i \u003c _cTokens.length; i++) {\n            _setUnderlyingForCToken(_cTokens[i], _underlyings[i]);\n        }\n    }\n\n    /**\n     * @notice Get the official price for a symbol\n     * @param symbol The symbol to fetch the price of\n     * @return Price denominated in USD\n     */\n    function price(string memory symbol) external view returns (uint) {\n        TokenConfig memory config = getTokenConfigBySymbol(symbol);\n        return priceInternal(config);\n    }\n\n    /**\n     * @notice Get the official price for an underlying asset\n     * @param underlying The address to fetch the price of\n     * @return Price denominated in USD\n     */\n    function price(address underlying) public view returns (uint) {\n        TokenConfig memory config = getTokenConfigByUnderlying(underlying);\n        return priceInternal(config);\n    }\n\n    function priceInternal(TokenConfig memory config) internal view returns (uint) {\n        if (config.priceSource == PriceSource.UNISWAP) return prices[config.symbolHash];\n        if (config.priceSource == PriceSource.FIXED_USD) return config.fixedPrice;\n        if (config.priceSource == PriceSource.POSTER) return prices[config.symbolHash];\n        if (config.priceSource == PriceSource.EXTERNAL_ORACLE) {\n            uint8 oracleDecimals = IExternalOracle(config.externalOracle).decimals();\n            (, int256 answer, , , ) = IExternalOracle(config.externalOracle).latestRoundData();\n            return mul(uint256(answer), basePricePrecision) / (10 ** uint256(oracleDecimals));\n        }\n        if (config.priceSource == PriceSource.REPOINT) return price(config.repointedAsset);\n    }\n\n    /**\n     * @notice Get the underlying price of a cToken\n     * @dev Implements the PriceOracle interface for Compound v2.\n     * @param cToken The cToken address for price retrieval\n     * @return Price denominated in USD for the given cToken address\n     */\n    function getUnderlyingPrice(address cToken) external view returns (uint) {\n        TokenConfig memory config = getTokenConfigByUnderlying(underlyings[cToken]);\n        // Comptroller needs prices in the format: ${raw price} * 1e(36 - baseUnit)\n        uint factor = 1e36 / basePricePrecision;\n        return mul(factor, priceInternal(config)) / config.baseUnit;\n    }\n\n    /**\n     * @notice Update oracle prices\n     * @param cToken The cToken address\n     */\n    function updatePrice(address cToken) external {\n        address underlying = underlyings[cToken];\n        if (underlying != address(0)) {\n            updateUnderlyingPrice(underlying);\n        }\n    }\n\n    /**\n     * @notice Update oracle prices\n     * @param underlying The underlying address\n     */\n    function updateUnderlyingPrice(address underlying) public {\n        updateEthPrice();\n        TokenConfig memory config = getTokenConfigByUnderlying(underlying);\n\n        if (config.symbolHash != ethHash) {\n            uint ethPrice = prices[ethHash];\n            // Try to update the storage\n            updatePriceInternal(config.symbol, ethPrice);\n        }\n    }\n\n    /**\n     * @notice Update oracle prices\n     * @param symbol The underlying symbol\n     */\n    function updatePrice(string memory symbol) external {\n        updateEthPrice();\n        if (keccak256(abi.encodePacked(symbol)) != ethHash) {\n            uint ethPrice = prices[ethHash];\n            // Try to update the storage\n            updatePriceInternal(symbol, ethPrice);\n        }\n    }\n\n    /**\n     * @notice Open function to update all prices\n     */\n    function updateAllPrices() external {\n        for (uint i = 0; i \u003c numTokens; i++) {\n            updateUnderlyingPrice(getTokenConfig(i).underlying);\n        }\n    }\n\n    /**\n     * @notice Update ETH price, and recalculate stored price by comparing to anchor\n     */\n    function updateEthPrice() public {\n        uint ethPrice = fetchEthPrice();\n        // Try to update the storage\n        updatePriceInternal(ETH, ethPrice);\n    }\n\n    function updatePriceInternal(string memory symbol, uint ethPrice) internal {\n        TokenConfig memory config = getTokenConfigBySymbol(symbol);\n\n        if (config.priceSource == PriceSource.UNISWAP) {\n            bytes32 symbolHash = keccak256(abi.encodePacked(symbol));\n            uint anchorPrice;\n            if (symbolHash == ethHash) {\n                anchorPrice = ethPrice;\n            } else if (config.isPairWithStablecoin) {\n                anchorPrice = fetchAnchorPrice(config, ethBaseUnit);\n            } else {\n                anchorPrice = fetchAnchorPrice(config, ethPrice);\n            }\n\n            prices[symbolHash] = anchorPrice;\n            emit PriceUpdated(symbol, anchorPrice);\n        }\n        if (config.priceSource == PriceSource.REPOINT) {\n            // update price for repointed asset\n            updateUnderlyingPrice(config.repointedAsset);\n        }\n    }\n\n    /**\n     * @dev Fetches the current token/quoteCurrency price accumulator from uniswap.\n     */\n    function currentCumulativePrice(TokenConfig memory config) internal view returns (uint) {\n        (uint cumulativePrice0, uint cumulativePrice1,) = UniswapV2OracleLibrary.currentCumulativePrices(config.uniswapMarket);\n        if (config.isUniswapReversed) {\n            return cumulativePrice1;\n        } else {\n            return cumulativePrice0;\n        }\n    }\n\n    /**\n     * @dev Fetches the current eth/usd price from uniswap, with basePricePrecision as precision.\n     *  Conversion factor is 1e18 for eth/usd market, since we decode uniswap price statically with 18 decimals.\n     */\n    function fetchEthPrice() internal returns (uint) {\n        return fetchAnchorPrice(getTokenConfigBySymbolHash(ethHash), ethBaseUnit);\n    }\n\n    /**\n     * @dev Fetches the current token/usd price from uniswap, with basePricePrecision as precision.\n     */\n    function fetchAnchorPrice(TokenConfig memory config, uint conversionFactor) internal virtual returns (uint) {\n        (uint nowCumulativePrice, uint oldCumulativePrice, uint oldTimestamp) = pokeWindowValues(config);\n\n        // This should be impossible, but better safe than sorry\n        require(block.timestamp \u003e oldTimestamp, \"now must come after before\");\n        uint timeElapsed = block.timestamp - oldTimestamp;\n\n        // Calculate uniswap time-weighted average price\n        // Underflow is a property of the accumulators: https://uniswap.org/audit.html#orgc9b3190\n        FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(uint224((nowCumulativePrice - oldCumulativePrice) / timeElapsed));\n        uint rawUniswapPriceMantissa = priceAverage.decode112with18();\n        uint unscaledPriceMantissa = mul(rawUniswapPriceMantissa, conversionFactor);\n        uint anchorPrice;\n\n        // Adjust rawUniswapPrice according to the units of the non-ETH asset\n        // In the case of ETH, we would have to scale by 1e6 / USDC_UNITS, but since baseUnit2 is 1e6 (USDC), it cancels\n\n        // In the case of non-ETH tokens\n        // a. pokeWindowValues already handled uniswap reversed cases, so priceAverage will always be Token/ETH TWAP price.\n        // b. conversionFactor = ETH price * 1e6\n        // unscaledPriceMantissa = priceAverage(token/ETH TWAP price) * expScale * conversionFactor\n        // so -\u003e\n        // anchorPrice = priceAverage * tokenBaseUnit / ethBaseUnit * ETH_price * 1e6\n        //             = priceAverage * conversionFactor * tokenBaseUnit / ethBaseUnit\n        //             = unscaledPriceMantissa / expScale * tokenBaseUnit / ethBaseUnit\n        anchorPrice = mul(unscaledPriceMantissa, config.baseUnit) / ethBaseUnit / expScale;\n        return anchorPrice;\n    }\n\n    /**\n     * @dev Get time-weighted average prices for a token at the current timestamp.\n     *  Update new and old observations of lagging window if period elapsed.\n     */\n    function pokeWindowValues(TokenConfig memory config) internal returns (uint, uint, uint) {\n        bytes32 symbolHash = config.symbolHash;\n        uint cumulativePrice = currentCumulativePrice(config);\n\n        Observation memory newObservation = newObservations[symbolHash];\n\n        // Update new and old observations if elapsed time is greater than or equal to anchor period\n        uint timeElapsed = block.timestamp - newObservation.timestamp;\n        if (timeElapsed \u003e= anchorPeriod) {\n            oldObservations[symbolHash].timestamp = newObservation.timestamp;\n            oldObservations[symbolHash].acc = newObservation.acc;\n\n            newObservations[symbolHash].timestamp = block.timestamp;\n            newObservations[symbolHash].acc = cumulativePrice;\n            emit UniswapWindowUpdated(config.symbolHash, newObservation.timestamp, block.timestamp, newObservation.acc, cumulativePrice);\n        }\n        return (cumulativePrice, oldObservations[symbolHash].acc, oldObservations[symbolHash].timestamp);\n    }\n\n    function getSymbolHash(string memory symbol) external pure returns (bytes32) {\n        return keccak256(abi.encodePacked(symbol));\n    }\n\n    /// @dev Overflow proof multiplication\n    function mul(uint a, uint b) internal pure returns (uint) {\n        if (a == 0) return 0;\n        uint c = a * b;\n        require(c / a == b, \"multiplication overflow\");\n        return c;\n    }\n}"}}