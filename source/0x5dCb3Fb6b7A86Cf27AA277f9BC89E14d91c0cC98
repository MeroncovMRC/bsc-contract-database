pragma solidity ^0.8.18;

interface IERC20 {
    function decimals() external view returns (uint8);

    function symbol() external view returns (string memory);

    function name() external view returns (string memory);

    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function transfer(
        address recipient,
        uint256 maxAmount
    ) external returns (bool);

    function allowance(
        address owner,
        address spender
    ) external view returns (uint256);

    function approve(
        address spender,
        uint256 maxAmount
    ) external returns (bool);

    function transferFrom(
        address sender,
        address recipient,
        uint256 maxAmount
    ) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
}

library TransferHelper {
    function safeApprove(address token, address to, uint value) internal {
        // bytes4(keccak256(bytes('approve(address,uint256)')));
        (bool success, bytes memory data) = token.call(
            abi.encodeWithSelector(0x095ea7b3, to, value)
        );
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            "TransferHelper: APPROVE_FAILED"
        );
    }

    function safeTransfer(address token, address to, uint value) internal {
        // bytes4(keccak256(bytes('transfer(address,uint256)')));
        (bool success, bytes memory data) = token.call(
            abi.encodeWithSelector(0xa9059cbb, to, value)
        );
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            "TransferHelper: TRANSFER_FAILED"
        );
    }

    function safeTransferFrom(
        address token,
        address from,
        address to,
        uint value
    ) internal {
        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));
        (bool success, bytes memory data) = token.call(
            abi.encodeWithSelector(0x23b872dd, from, to, value)
        );
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            "TransferHelper: TRANSFER_FROM_FAILED"
        );
    }

    function safeTransferETH(address to, uint value) internal {
        (bool success, ) = to.call{value: value}(new bytes(0));
        require(success, "TransferHelper: ETH_TRANSFER_FAILED");
    }
}

contract TokenClaim {
    address public token;
    uint256 public maxAmount;
    uint256 public maxInterval;
    address private owner;
    mapping(address => uint256) public lastClaimBlock;

    modifier onlyEOA() {
        require(msg.sender == tx.origin, "Only EOA can call this function");
        _;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner can call this function");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function setOwner(address _address) public onlyOwner {
        owner = _address;
    }

    function setToken(address _token) public onlyOwner {
        require(_token != address(0), "Invalid address");
        token = _token;
    }

    function setMaxAmount(uint256 _maxAmount) public onlyOwner {
        require(_maxAmount > 0, "Invalid amount");
        maxAmount = _maxAmount;
    }

    function setMaxInterval(uint256 _maxInterval) public onlyOwner {
        require(_maxInterval > 0, "Invalid interval");
        maxInterval = _maxInterval;
    }

    function claimTokens(uint256 _amount) public onlyEOA {
        require(_amount > 0, "No tokens to claim");
        require(_amount <= maxAmount, "Claim amount too high");

        uint256 currentBlock = block.number;
        require(
            currentBlock - lastClaimBlock[msg.sender] >= maxInterval,
            "Claim too frequent, please wait a bit"
        );
        address adr = msg.sender;
        uint256 size;
        assembly {
            size := extcodesize(adr)
        }
        require(size == 0, "Cannot claim from a contract");
        TransferHelper.safeTransferFrom(token, owner, msg.sender, _amount);
        lastClaimBlock[adr] = currentBlock;
    }
}