{"BonusContract.sol":{"content":"// SPDX-License-Identifier: MIT\r\n/*\r\nhttps://dars.one/\r\n*/\r\npragma solidity 0.7.6;\r\nimport \"./IBEP20.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport \"./ECDSA.sol\";\r\nimport \"./TransferHelper.sol\";\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\ncontract BonusContract{\r\n\r\n    using SafeMath for uint256;\r\n    using ECDSA for bytes32;\r\n    using TransferHelper for IBEP20;\r\n\r\n    struct User {\r\n        uint128 id;\r\n        uint128 bonusNonce;\r\n        uint256 totalBuy;\r\n        uint256 totalBuyOutside;\r\n        uint256 totalBuySpecial;\r\n        uint256 affectedBuySpecial;\r\n        uint256 totalUpgrade;\r\n        uint256 totalBonus;  \r\n    }\r\n\r\n    struct Packet{\r\n        uint256 id;\r\n        uint256 packetType;\r\n        uint256 qty;\r\n        uint256 packetPrice;\r\n        address target;\r\n        bool upgradable;\r\n        bool affecting;\r\n        bool cartDependent;\r\n    }\r\n    mapping(bytes32=\u003ePacket) private packets;\r\n    mapping(address=\u003ebool) public migrated;\r\n    bytes32[] private allPackets;\r\n    \r\n    IBEP20 immutable public bonusToken;\r\n    address immutable public darsBasis;\r\n    uint256 immutable public chainId;\r\n    uint256 immutable public darsPercent;\r\n    address immutable public companyOwner;\r\n    address immutable public darsSigner;\r\n    address public companySigner;\r\n    address public migrationsAdmin;\r\n    uint256 public bonusPercent;\r\n    address public companyContract;\r\n    string  public darsName;\r\n    string  public Url;  \r\n    uint128 public lastUserId = 0;\r\n    uint128 public lastPacketId = 0;\r\n    bool public lowBalance = false;\r\n    bool public salesStopped = false;\r\n    uint256 public totalWithdrawBonus;\r\n    uint256 public totalBuy;\r\n    uint256 public totalBuyOutside;\r\n    uint256 public totalBuySpecial;\r\n    uint256 public totalUpgrade;\r\n    uint256 public lastWithdrawalTimestamp;\r\n    uint256 constant public maxTermWithoutCompanySignature = 10800;//180 days\r\n\r\n    \r\n\r\n    mapping(address =\u003e User) public users;\r\n    mapping(uint128 =\u003e address) private usersID;\r\n    \r\n    modifier onlyCompanyOwner() {\r\n        require(companyOwner == msg.sender, \"caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyDarsSigner() {\r\n        require(darsSigner == msg.sender, \"caller is not darsSigner\");\r\n        _;\r\n    }\r\n\r\n/*\r\n    function clear(uint amount) public onlyCompanyOwner {\r\n        //address payable _owner = payable(msg.sender);\r\n        bonusToken.safeTransfer((bonusToken.balanceOf(address(this))), amount);\r\n    }\r\n*/\r\n    event PacketAdded(uint256 id,\r\n                uint256 packetType,\r\n                uint256 qty,\r\n                uint256 packetPrice,\r\n                address targetContract,\r\n                bytes32 singlePacketUID,\r\n                bool upgradeable,\r\n                bool affecting,\r\n                bool cartDependent);\r\n\r\n    event PacketUpdated(uint256 id,\r\n                uint256 qty,\r\n                uint256 packetPrice,\r\n                address targetContract,\r\n                bytes32 singlePacketUID,\r\n                bool upgradeable,\r\n                bool affecting,\r\n                bool cartDependent);\r\n\r\n    event Migrations(address user, \r\n                    uint256 totalBuy,\r\n                    uint256 totalBuyOutside,\r\n                    uint256 totalBuySpecial,\r\n                    uint256 affectedBuySpecial,\r\n                    uint256 totalUpgrade);\r\n\r\n    event Withdraw(address user, uint256 amount,uint128 nextnonce);\r\n    event Registration(address user, uint128 userId);\r\n    event Buy(address user,uint256 price,bytes32 orderUID);\r\n    event BuyOutside(address user,uint256 price,uint256 marketing);\r\n    event BuySpecial(address user,uint256 price,bytes32 singlePacketUID);\r\n    event UpgradeSpecial(address user,uint256 price,bytes32 singlePacketUID);\r\n\r\n    constructor(address _companyOwner,\r\n                address _companySigner,\r\n                address _darsSigner,\r\n                address _companyContract,\r\n                address _bonusToken,\r\n                uint256 _darsPercent,\r\n                uint256 _bonusPercent,\r\n                string memory _darsName, \r\n                string memory _Url) {\r\n\r\n        darsBasis = msg.sender;//parent, Dars platform base contract\r\n        companyOwner = _companyOwner;\r\n        darsSigner = _darsSigner;\r\n        companySigner = _companySigner;\r\n        companyContract = _companyContract;\r\n        darsName = _darsName;\r\n        Url = _Url;\r\n        bonusPercent = _bonusPercent;\r\n        darsPercent = _darsPercent;\r\n        bonusToken=IBEP20(_bonusToken);\r\n        uint256 _chainId;\r\n        assembly {\r\n            _chainId := chainid()\r\n        }\r\n        chainId=_chainId;\r\n        lastWithdrawalTimestamp=block.timestamp;\r\n    }\r\n\r\n    function antiSabotage(bool _lowBalance) external onlyDarsSigner {\r\n       lowBalance=_lowBalance; \r\n    }\r\n\r\n    function withdrawBonus(uint256 amount, bytes calldata signatureDars,bytes calldata signatureCompany) external {\r\n        uint128 id=users[msg.sender].id;\r\n        require(id\u003e0,\"The user doesn\u0027t exist!\");\r\n        require(amount\u003e0,\"bonus must be greater than 0\");\r\n        bytes32 hash=createHash(id,amount,users[msg.sender].bonusNonce);\r\n        hash=hash.toEthSignedMessageHash();\r\n        require(hash.recover(signatureDars)==darsSigner,\"dars signature is wrong\");\r\n        bool isSolvent=bonusToken.balanceOf(address(this))\u003e=amount;\r\n        \r\n        if((block.timestamp-lastWithdrawalTimestamp)\u003cmaxTermWithoutCompanySignature){\r\n            require(hash.recover(signatureCompany)==companySigner,\"company signature is wrong\");\r\n            lastWithdrawalTimestamp=block.timestamp;\r\n        }else{\r\n            salesStopped=true;\r\n        }\r\n        \r\n        if(isSolvent){\r\n            users[msg.sender].bonusNonce++;\r\n            users[msg.sender].totalBonus=users[msg.sender].totalBonus.add(amount);\r\n            totalWithdrawBonus=totalWithdrawBonus.add(amount);\r\n            lowBalance=false;                     \r\n            bonusToken.safeTransfer(address(msg.sender), amount);\r\n            emit Withdraw(msg.sender,amount,users[msg.sender].bonusNonce);\r\n        }else{\r\n            require(lowBalance==false,\"low contract balance..Please contact to support of company.\");\r\n            lowBalance=true;\r\n        }\r\n\r\n    }\r\n\r\n\r\n    function dbMigrations(address _user,\r\n                        uint256 _totalBuy,\r\n                        uint256 _totalBuyOutside,\r\n                        uint256 _totalBuySpecial,\r\n                        uint256 _affectedBuySpecial,\r\n                        uint256 _totalUpgrade) external {\r\n        \r\n        require(migrationsAdmin==msg.sender,\"this caller is not a migration admin\");\r\n        require(migrated[_user]==false,\"this user already migrated\");                    \r\n        if(users[_user].id==0){\r\n            _registration(_user);\r\n        }\r\n        migrated[_user]=true;\r\n        User storage user = users[_user];\r\n        user.totalBuy=user.totalBuy.add(_totalBuy);\r\n        user.totalBuyOutside=user.totalBuyOutside.add(_totalBuyOutside);\r\n        user.totalBuySpecial=user.totalBuySpecial.add(_totalBuySpecial);\r\n        user.affectedBuySpecial=user.affectedBuySpecial.add(_affectedBuySpecial);\r\n        user.totalUpgrade=user.totalUpgrade.add(_totalUpgrade);\r\n        \r\n        emit Migrations(_user, \r\n                    user.totalBuy,\r\n                    user.totalBuyOutside,\r\n                    user.totalBuySpecial,\r\n                    user.affectedBuySpecial,\r\n                    user.totalUpgrade);\r\n\r\n    }\r\n\r\n    function _registration(address newUser) internal {\r\n\r\n        User memory user = User({\r\n            id: ++lastUserId,\r\n            bonusNonce: uint128(0),\r\n            totalBuy: 0,\r\n            totalBuyOutside:0,\r\n            totalBuySpecial: 0,\r\n            affectedBuySpecial:0,\r\n            totalUpgrade:0,\r\n            totalBonus: 0\r\n        });\r\n        users[newUser] = user;\r\n        usersID[lastUserId]=newUser;\r\n        emit Registration(newUser, lastUserId);\r\n\r\n    } \r\n\r\n    function _buy(address payer,uint256 price) internal {\r\n        \r\n        require(price \u003e 0, \"price must be greater than 0\");\r\n        require(!lowBalance, \"operations suspended, low balance for bonuses\");\r\n        require(!salesStopped, \"this company under liquidation, the sale is stopped\");\r\n        require(\r\n            bonusToken.allowance(payer, address(this)) \u003e=\r\n                price,\r\n            \"Increase the allowance first,call the approve method\"\r\n        );\r\n        \r\n        bonusToken.safeTransferFrom(\r\n            payer,\r\n            address(this),\r\n            price\r\n        );\r\n        uint256 toDarsAmount=price.mul(darsPercent).div(100);\r\n        uint256 toBonusAmount=price.mul(bonusPercent).div(100);\r\n        uint256 toCompanyAmount=price.sub(toDarsAmount.add(toBonusAmount));\r\n        \r\n        if(toDarsAmount\u003e0){\r\n            bonusToken.safeTransfer(darsBasis, toDarsAmount);\r\n        }\r\n\r\n        if(toCompanyAmount\u003e0){\r\n            bonusToken.safeTransfer(companyContract, toCompanyAmount);\r\n        }\r\n\r\n    }\r\n\r\n    //marketing 0-DEFAULT\r\n    function buyOutside(address user,uint256 price,uint256 marketing) external {\r\n        require(users[user].id\u003e0,\"user not exist\");\r\n        _buy(msg.sender,price);\r\n        totalBuyOutside=totalBuyOutside.add(price);       \r\n        users[user].totalBuyOutside=users[user].totalBuyOutside.add(price);\r\n        emit BuyOutside(user,price,marketing);\r\n    }\r\n\r\n    function buy(uint256 price,bytes32 orderUID) external {\r\n        _buy(msg.sender,price);\r\n        if(users[msg.sender].id==0){\r\n            _registration(msg.sender);\r\n        }\r\n        totalBuy=totalBuy.add(price);       \r\n        users[msg.sender].totalBuy=users[msg.sender].totalBuy.add(price);\r\n        emit Buy(msg.sender,price,orderUID);\r\n    }\r\n\r\n    function buySpecial(uint256 price,bytes32 singlePacketUID) external {\r\n\r\n        require(price \u003e 0 \u0026\u0026 packets[singlePacketUID].packetPrice==price,\"bad packet price or packet not avaible\");\r\n        _buy(msg.sender,price); \r\n        if(users[msg.sender].id==0){\r\n            _registration(msg.sender);\r\n        }\r\n        totalBuySpecial=totalBuySpecial.add(price);\r\n        users[msg.sender].totalBuySpecial=users[msg.sender].totalBuySpecial.add(price);\r\n\r\n        if(packets[singlePacketUID].affecting){\r\n            users[msg.sender].affectedBuySpecial=users[msg.sender].affectedBuySpecial.add(price);\r\n        }\r\n\r\n        if(packets[singlePacketUID].target!=address(0)){\r\n            (bool success,) = packets[singlePacketUID].target\r\n            .call(abi.encodeWithSignature(\"delivery(address,uint256,uint256,uint256,uint256)\",\r\n            msg.sender,packets[singlePacketUID].packetType,packets[singlePacketUID].qty,packets[singlePacketUID].id,price));\r\n            require(success,\"delivery call FAIL\");\r\n        }\r\n        \r\n        emit BuySpecial(msg.sender,price,singlePacketUID);\r\n    }\r\n\r\n    function upgradeSpecial(uint256 maxPrice,bytes32 singlePacketUID) external {\r\n        require(users[msg.sender].id\u003e0,\"user not exist\");\r\n\r\n        (bool success,uint256 price) = getUpgradePriceIfAvailable(msg.sender,singlePacketUID);\r\n        require(success,\"This upgrade is not available\");\r\n        require(price \u003c= maxPrice,\"bad upgrade price, maybe the packet price was changed\");\r\n        _buy(msg.sender,price);\r\n        totalUpgrade=totalUpgrade.add(price);\r\n        users[msg.sender].totalUpgrade=users[msg.sender].totalUpgrade.add(price);\r\n        \r\n        if(packets[singlePacketUID].affecting){\r\n            users[msg.sender].affectedBuySpecial=users[msg.sender].affectedBuySpecial.add(price);\r\n        }      \r\n\r\n        if(packets[singlePacketUID].target!=address(0)){\r\n            (success,) = packets[singlePacketUID].target\r\n            .call(abi.encodeWithSignature(\"upgradeDelivery(address,uint256,uint256,uint256,uint256)\",\r\n            msg.sender,packets[singlePacketUID].packetType,packets[singlePacketUID].qty,packets[singlePacketUID].id,price));\r\n            require(success,\"upgradeDelivery call FAIL\");\r\n        }\r\n        \r\n        emit UpgradeSpecial(msg.sender,price,singlePacketUID);\r\n\r\n    }\r\n\r\n    function getUpgradePriceIfAvailable(address user,bytes32 singlePacketUID) public view returns (bool,uint256) {\r\n\r\n        if(users[user].id \u003e 0 \u0026\u0026 packets[singlePacketUID].packetPrice\u003e0 \u0026\u0026 packets[singlePacketUID].upgradable){\r\n            uint256 affected=users[user].affectedBuySpecial;\r\n            if(packets[singlePacketUID].cartDependent){\r\n                affected = affected.add(users[user].totalBuy).add(users[user].totalBuyOutside);\r\n            }\r\n            if(packets[singlePacketUID].packetPrice\u003eaffected){\r\n                return (true,packets[singlePacketUID].packetPrice.sub(affected)); \r\n            }\r\n        }\r\n        return (false,0);\r\n    }\r\n\r\n    function getPacketsList() public view returns (bytes32[] memory) {\r\n        return allPackets;\r\n    }\r\n\r\n    function uidToId(bytes32 singlePacketUID) external view returns (uint256){\r\n        return packets[singlePacketUID].id;\r\n    }\r\n\r\n    function getPacketByUID(bytes32 singlePacketUID) external view returns (Packet memory){\r\n        \r\n        return packets[singlePacketUID];\r\n    }\r\n\r\n    function getPacketByID(uint256 packetId) external view returns (Packet memory){\r\n        require(packetId \u003e 0 \u0026\u0026 packetId \u003c= lastPacketId, \"wrong Id\");\r\n        bytes32 id = allPackets[packetId-1];\r\n        return packets[id];\r\n    }\r\n\r\n    function isPacketActive(bytes32 singlePacketUID) external view returns(bool){\r\n        return (packets[singlePacketUID].target != address(0));\r\n    } \r\n\r\n    function createHash(uint128 to, uint256 amount, uint128 nonce) internal view returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(chainId, this, to, amount, nonce));\r\n    }\r\n    \r\n    function isUserExists(address user) external view returns (bool) {\r\n        return (users[user].id \u003e 0);\r\n    }\r\n\r\n    function getUserNonce(address user) external view returns (uint128) {\r\n        return users[user].bonusNonce;\r\n    }\r\n\r\n    function addressToId(address user) external view returns (uint128) {\r\n        require(users[user].id\u003e0,\"The user doesn\u0027t exist!\");\r\n        return users[user].id;\r\n    }\r\n\r\n    function idToAddress(uint128 id) external view returns (address) {\r\n        require(id\u003e0 \u0026\u0026 id\u003c=lastUserId,\"The user doesn\u0027t exist!\");\r\n        return usersID[id];\r\n    }\r\n    /*\r\n        TYPE_PACKAGE = 1;\r\n        TYPE_ACTIVITY = 2;\r\n        TYPE_ONE_TIME_FEE = 3;\r\n    */\r\n    function addPacket(uint256 _qty,\r\n                    uint256 _packetType,\r\n                    uint256 _packetPrice, \r\n                    address _target,\r\n                    bytes32 singlePacketUID,\r\n                    bool _upgradable,\r\n                    bool _affecting,\r\n                    bool _cartDependent) external onlyCompanyOwner {\r\n        \r\n        if(_target!=address(0)){\r\n            uint32 size;\r\n            assembly {\r\n                size := extcodesize(_target)\r\n            }\r\n            require(size != 0, \"The target must be a contract or zero address\");\r\n        }\r\n        \r\n\r\n        if(packets[singlePacketUID].id\u003e0){\r\n            require(packets[singlePacketUID].packetType==_packetType,\"type change not available\");\r\n            packets[singlePacketUID].qty=_qty;\r\n            packets[singlePacketUID].packetPrice=_packetPrice;\r\n            packets[singlePacketUID].target=_target;\r\n            packets[singlePacketUID].upgradable=_upgradable;\r\n            packets[singlePacketUID].affecting=_affecting;\r\n            packets[singlePacketUID].cartDependent=_cartDependent;\r\n            emit PacketUpdated(packets[singlePacketUID].id,_qty,_packetPrice, _target, singlePacketUID,_upgradable,_affecting,_cartDependent);\r\n        }else{\r\n            packets[singlePacketUID]=Packet(\r\n            {id:++lastPacketId,\r\n            packetType:_packetType,\r\n            qty:_qty,\r\n            packetPrice:_packetPrice,\r\n            target:_target,\r\n            upgradable:_upgradable,\r\n            affecting:_affecting,\r\n            cartDependent:_cartDependent\r\n            });\r\n            allPackets.push(singlePacketUID);\r\n            emit PacketAdded(lastPacketId,_packetType,_qty,_packetPrice, _target, singlePacketUID,_upgradable,_affecting,_cartDependent);\r\n        }\r\n        \r\n    }\r\n\r\n    function setMigrationsAdmin(address _migrationsAdmin) external onlyCompanyOwner {\r\n        migrationsAdmin = _migrationsAdmin;\r\n    }\r\n\r\n    function setBonusPercent(uint256 newPercent) external onlyCompanyOwner {\r\n        require(newPercent\u003e0 \u0026\u0026 newPercent \u003c= uint256(100).sub(darsPercent),\"bad percent\");\r\n        bonusPercent = newPercent;\r\n    }\r\n    \r\n    function setCompanyUrl(string calldata _Url) external onlyCompanyOwner {\r\n        Url = _Url;\r\n    }\r\n    function setCompanyContract(address _companyContract) external onlyCompanyOwner {\r\n        companyContract = _companyContract;\r\n    }\r\n\r\n    function setCompanySigner(address _companySigner) external onlyCompanyOwner {\r\n        companySigner = _companySigner;\r\n    }\r\n}"},"ECDSA.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity \u003e=0.6.0 \u003c0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        if (signature.length != 65) {\n            revert(\"ECDSA: invalid signature length\");\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        return recover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover-bytes32-bytes-} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 \u003c s \u003c secp256k1n ? 2 + 1, and for v in (282): v ? {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(uint256(s) \u003c= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"ECDSA: invalid signature \u0027s\u0027 value\");\n        require(v == 27 || v == 28, \"ECDSA: invalid signature \u0027v\u0027 value\");\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n        return signer;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * replicates the behavior of the\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\n     * JSON-RPC method.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}"},"IBEP20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity \u003e=0.6.4 \u003c0.8.0;\n\ninterface IBEP20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the token decimals.\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Returns the token symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the token name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the bep token owner.\n     */\n    function getOwner() external view returns (address);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address _owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity \u003e=0.6.4 \u003c0.8.0;\n\n/**\n * Copyright (c) 2016-2019 zOS Global Limited\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"},"TransferHelper.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity \u003e=0.6.4 \u003c0.8.0;\nimport \"./IBEP20.sol\";\nimport \"./SafeMath.sol\";\n\nlibrary TransferHelper {\n    using SafeMath for uint256;\n\n    function safeTransfer(\n        IBEP20 token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) =\n            address(token).call(\n                abi.encodeWithSelector(token.transfer.selector, to, value)\n            );\n        require(\n            success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))),\n            \"TRANSFER_FAILED\"\n        );\n    }\n\n    function safeTransferFrom(\n        IBEP20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) =\n            address(token).call(\n                abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n            );\n        require(\n            success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))),\n            \"TRANSFER_FROM_FAILED\"\n        );\n    }\n\n    function safeIncreaseAllowance(\n        IBEP20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance =\n            token.allowance(address(this), spender).add(value);\n\n        (bool success, bytes memory data) =\n            address(token).call(\n                abi.encodeWithSelector(token.approve.selector,spender,newAllowance)\n            );\n        require(\n            success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))),\n            \"INCREASE_ALLOWANCE_FAILED\"\n        );     \n    }\n}"}}