{"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.14;\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function balanceOf(\r\n        address _account\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function transfer(\r\n        address _recipient,\r\n        uint256 _amount\r\n    )\r\n        external\r\n        returns (bool);\r\n\r\n    function approve(\r\n        address _spender,\r\n        uint256 _amount\r\n    )\r\n        external\r\n        returns (bool);\r\n\r\n    function transferFrom(\r\n        address _sender,\r\n        address _recipient,\r\n        uint256 _amount\r\n    )\r\n        external\r\n        returns (bool);\r\n\r\n    function decimals()\r\n        external\r\n        view\r\n        returns (uint8);\r\n}\r\n"},"IWISB.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.14; \r\n\r\ninterface IWISB {\r\n\r\n    function stakes (\r\n        address _input,\r\n        bytes16 _byteInput\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint64,\r\n            uint64,\r\n            uint64,\r\n            uint64,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            address,\r\n            bool\r\n        );\r\n\r\n    function generateID(\r\n        address _x,\r\n        uint256 _y,\r\n        bytes1 _z\r\n    )\r\n        external\r\n        view\r\n        returns (bytes16);\r\n\r\n    function globals()\r\n        external\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n\r\n    function currentWiseDay()\r\n        external\r\n        view\r\n        returns (uint64);\r\n\r\n    function LAUNCH_TIME()\r\n        external\r\n        returns (uint256);\r\n\r\n    function latestStakeID(\r\n        address _staker\r\n    )\r\n        external\r\n        view\r\n        returns(bytes16);\r\n\r\n    function checkMatureStake(\r\n        address _staker,\r\n        bytes16 _stakeID\r\n    )\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n"},"IWISBInsurance.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.14;\r\n\r\ninterface IWISBInsurance {\r\n\r\n    function publicReward(\r\n        address _user\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getStakeID(\r\n        address _staker,\r\n        uint256 _stakeIndex\r\n    )\r\n        external\r\n        view\r\n        returns (bytes16);\r\n\r\n    function checkOwnership(\r\n        address _staker,\r\n        uint256 _stakeIndex\r\n    )\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function getStakedAmount(\r\n        address _staker,\r\n        uint256 _stakeIndex\r\n    )\r\n        external\r\n        view\r\n        returns(uint256);\r\n\r\n\r\n    function insuranceStakes(\r\n        address _owner,\r\n        uint256 _index\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            bytes16,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            address,\r\n            bool\r\n    );\r\n}\r\n"},"OneDrop.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.14;\r\n\r\nimport \"./OneDropHelper.sol\";\r\n\r\n/**\r\n  * @title Airdrop-OneDrop\r\n  * @author Ren√© Hochmuth\r\n */\r\n\r\ncontract OneDrop is OneDropHelpers{\r\n\r\n    address public immutable INSURANCE_ADDRESS;\r\n\r\n    modifier onlyMaster() {\r\n\r\n        require(\r\n            msg.sender == masterAddress,\r\n            \"OneDrop: ACCESS_DENIED!\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier isRegisterAllowed() {\r\n\r\n        require(\r\n            registerAllowed == true,\r\n            \"Onedrop: REGISTER_NOT_ALLOWED\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier registerNotAllowed() {\r\n\r\n        require(\r\n            registerAllowed == false,\r\n            \"Onedrop: REGISTER_STILL_OPEN\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        address _rewardToken,\r\n        address _wisbToken,\r\n        address _insuranceAddress,\r\n        uint256 _maxStartDay\r\n    )\r\n\r\n    {\r\n        masterAddress = msg.sender;\r\n        latestTotalShares = 1;\r\n        MAX_START_DAY = _maxStartDay;\r\n\r\n        rewardToken = IERC20(\r\n            _rewardToken\r\n        );\r\n\r\n        wisbToken = IWISB(\r\n            _wisbToken\r\n        );\r\n\r\n        wisbInsurance = IWISBInsurance(\r\n            _insuranceAddress\r\n        );\r\n\r\n        INSURANCE_ADDRESS = _insuranceAddress;\r\n    }\r\n\r\n    function addAirdropRewards(\r\n        uint256 _amount\r\n    )\r\n        registerNotAllowed\r\n        onlyMaster\r\n        external\r\n        returns (bool)\r\n    {\r\n        require(\r\n            addRewardsAllowed == true,\r\n            \"Onedrop: ADDING_REWARDS_NOT_ALLOWED\"\r\n        );\r\n\r\n        _increaseTotalRewards(\r\n            _amount\r\n        );\r\n\r\n        rewardToken.transferFrom(\r\n            msg.sender,\r\n            address(this),\r\n            _amount\r\n        );\r\n\r\n        addRewardsAllowed = false;\r\n\r\n        return true;\r\n    }\r\n\r\n    function changeMaster(\r\n        address _newMaster\r\n    )\r\n        external\r\n        onlyMaster\r\n    {\r\n        masterAddress = _newMaster;\r\n    }\r\n\r\n    function findEligibleStakes(\r\n        address _user\r\n    )\r\n        external\r\n        view\r\n        returns (bytes16[] memory)\r\n    {\r\n        bytes16 lastID = wisbToken.latestStakeID(_user);\r\n\r\n        require(\r\n            lastID != ZERO_BYTES,\r\n            \"Onedrop: NO_STAKES_AT_ALL\"\r\n        );\r\n\r\n        uint256 counter;\r\n        uint256 counter2;\r\n        uint256 length =  _determineLengthStakeArray(\r\n            _user,\r\n            lastID\r\n        );\r\n\r\n        uint64 startDay;\r\n        uint64 lockdays;\r\n        uint64 finalDay;\r\n        uint64 closeDay;\r\n\r\n        bytes16[] memory rawIDs = new bytes16[](length);\r\n        bool[] memory rawBools = new bool[](length);\r\n\r\n        for (uint i= 0 ; i\u003c length; i++){\r\n\r\n            rawIDs[i] = wisbToken.generateID(\r\n                _user,\r\n                i,\r\n                0x01\r\n            );\r\n\r\n            (\r\n                ,\r\n                ,\r\n                ,\r\n                startDay,\r\n                lockdays,\r\n                finalDay,\r\n                closeDay,\r\n                ,\r\n                ,\r\n                ,\r\n                ,\r\n\r\n            )\r\n                = wisbToken.stakes(\r\n                    _user,\r\n                    rawIDs[i]\r\n                );\r\n\r\n            if (_investigateRequirements(\r\n                    lockdays,\r\n                    closeDay,\r\n                    finalDay,\r\n                    startDay,\r\n                    rawIDs[i]\r\n                )       == true) {\r\n\r\n                    rawBools[i] = true;\r\n                    counter +=1;\r\n                    continue;\r\n                }\r\n\r\n                rawBools[i] = false;\r\n        }\r\n\r\n        bytes16[] memory returnIDs = new bytes16[](counter);\r\n\r\n        for ( uint i = 0; i \u003c length; i++) {\r\n            if (rawBools[i] == true){\r\n                returnIDs[counter2] = rawIDs[i];\r\n                counter2 += 1;\r\n            }\r\n        }\r\n\r\n       return returnIDs;\r\n    }\r\n\r\n    function findEligibleInsuranceStakes(\r\n        address _user\r\n    )\r\n        external\r\n        view\r\n        returns (bytes16[] memory)\r\n    {\r\n        uint256 currentAmount = wisbInsurance.getStakedAmount(\r\n            _user,\r\n            0\r\n        );\r\n\r\n        require(\r\n            currentAmount \u003e 0,\r\n            \"OneDrop: NO_INSURANCE_STAKES\"\r\n        );\r\n\r\n        uint256 length = _determineLengthInsuranceStakeArray(\r\n            _user\r\n        );\r\n        uint256 counter;\r\n        uint256 counter2;\r\n        uint256 counter3;\r\n\r\n        uint64 startDay;\r\n        uint64 lockdays;\r\n        uint64 finalDay;\r\n        uint64 closeDay;\r\n\r\n        address owner;\r\n\r\n        bytes16[] memory rawIDs = new bytes16[](length);\r\n        bool[] memory rawBools = new bool[](length);\r\n\r\n        while (currentAmount \u003e 0) {\r\n\r\n        (\r\n            rawIDs[counter],\r\n            ,\r\n            ,\r\n            ,\r\n            ,\r\n            owner,\r\n        )\r\n            = wisbInsurance.insuranceStakes(\r\n                _user,\r\n                counter\r\n            );\r\n\r\n        (\r\n            ,\r\n            ,\r\n            ,\r\n            startDay,\r\n            lockdays,\r\n            finalDay,\r\n            closeDay,\r\n            ,\r\n            ,\r\n            ,\r\n            ,\r\n\r\n        )\r\n            = wisbToken.stakes(\r\n                INSURANCE_ADDRESS,\r\n                rawIDs[counter]\r\n            );\r\n\r\n        if ( (_investigateRequirements(\r\n                    lockdays,\r\n                    closeDay,\r\n                    finalDay,\r\n                    startDay,\r\n                    rawIDs[counter]\r\n                )\r\n                    \u0026\u0026 owner == _user\r\n\r\n                ) == true) {\r\n\r\n                    rawBools[counter] = true;\r\n                    counter2 += 1;\r\n                }\r\n\r\n                counter +=1;\r\n                currentAmount = wisbInsurance.getStakedAmount(\r\n                    _user,\r\n                    counter\r\n                );\r\n        }\r\n\r\n        bytes16[] memory returnIDs = new bytes16[](counter2);\r\n\r\n        for (uint256 i = 0; i \u003c length; i++) {\r\n\r\n            if (rawBools[i] == true) {\r\n                returnIDs[counter3] = rawIDs[i];\r\n                counter3 += 1;\r\n            }\r\n       }\r\n\r\n       return returnIDs;\r\n    }\r\n\r\n    function registerStake(\r\n        bytes16 _ID\r\n    )\r\n        isRegisterAllowed\r\n        public\r\n\r\n    {\r\n        (\r\n            uint256 stakesShares,\r\n            ,\r\n            ,\r\n            uint64 startDay,\r\n            uint64 lockdays,\r\n            uint64 finalDay,\r\n            uint64 closeDay,\r\n            ,\r\n            ,\r\n            ,\r\n            ,\r\n\r\n        ) = wisbToken.stakes(\r\n            msg.sender,\r\n            _ID\r\n        );\r\n\r\n        _checkRequirementsUpdateStakeMappings(\r\n            lockdays,\r\n            _ID,\r\n            false,\r\n            stakesShares,\r\n            finalDay,\r\n            startDay,\r\n            closeDay\r\n        );\r\n    }\r\n\r\n    function registerStakeBulk(\r\n        bytes16[] memory _ID\r\n    )\r\n        external\r\n    {\r\n        for (uint256 i = 0; i \u003c _ID.length; i++) {\r\n            registerStake(_ID[i]);\r\n        }\r\n    }\r\n\r\n    function registerInsuranceStake(\r\n        bytes16 _ID\r\n    )\r\n        isRegisterAllowed\r\n        public\r\n    {\r\n        uint256 firstStakeAmount = wisbInsurance.getStakedAmount(\r\n            msg.sender,\r\n            0\r\n        );\r\n        require(\r\n            firstStakeAmount \u003e 0,\r\n            \"OneDrop:NO_INSURANCE_STAKES_MADE\"\r\n        );\r\n\r\n        uint256 length = _determineLengthInsuranceStakeArray(\r\n            msg.sender\r\n        );\r\n\r\n        bytes16 actualID;\r\n\r\n        address actualOwner;\r\n\r\n        for (uint i=0; i \u003c length; i++) {\r\n\r\n            (\r\n                actualID,\r\n                ,\r\n                ,\r\n                ,\r\n                ,\r\n                actualOwner,\r\n            ) = wisbInsurance.insuranceStakes(\r\n                msg.sender,\r\n                i\r\n            );\r\n\r\n            if (actualID == _ID) break;\r\n        }\r\n\r\n        require(\r\n            actualID == _ID \u0026\u0026 actualOwner == msg.sender,\r\n            \"Airdrop: NOT_YOUR_STAKE\"\r\n        );\r\n\r\n        (\r\n            uint256 stakesShares,\r\n            ,\r\n            ,\r\n            uint64 startDay,\r\n            uint64 lockdays,\r\n            uint64 finalDay,\r\n            ,\r\n            ,\r\n            ,\r\n            ,\r\n            ,\r\n\r\n        ) = wisbToken.stakes(\r\n            INSURANCE_ADDRESS,\r\n            _ID\r\n        );\r\n\r\n        _checkRequirementsUpdateStakeMappings(\r\n            lockdays,\r\n            _ID,\r\n            true,\r\n            stakesShares,\r\n            finalDay,\r\n            startDay,\r\n            0\r\n        );\r\n    }\r\n\r\n    function registerInsuranceStakeBulk(\r\n        bytes16[] memory _ID\r\n    )\r\n        external\r\n    {\r\n        for (uint256 i = 0; i \u003c _ID.length; i++) {\r\n            registerInsuranceStake(\r\n                _ID[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    function showRewardUser(\r\n        address _user\r\n    )\r\n        external\r\n        view\r\n        returns (uint256 result)\r\n    {\r\n        result = _calculateRewardUser(\r\n            _user,\r\n            userShares[_user]\r\n        );\r\n    }\r\n\r\n    function getRewardUser()\r\n        external\r\n    {\r\n\r\n        uint256 amount = _calculateRewardUser(\r\n            msg.sender,\r\n            userShares[msg.sender]\r\n        );\r\n\r\n        reduktor[msg.sender] = totalRewards;\r\n\r\n        rewardToken.transfer(\r\n            msg.sender,\r\n            amount\r\n        );\r\n\r\n    }\r\n\r\n    function enableAddRewards()\r\n        onlyMaster\r\n        external\r\n    {\r\n        addRewardsAllowed = true;\r\n    }\r\n\r\n    function disableAddRewards()\r\n        onlyMaster\r\n        external\r\n    {\r\n        addRewardsAllowed = false;\r\n    }\r\n\r\n    function enableRegister()\r\n        onlyMaster\r\n        external\r\n    {\r\n        registerAllowed = true;\r\n    }\r\n\r\n    function disableRegister()\r\n        onlyMaster\r\n        external\r\n    {\r\n        registerAllowed = false;\r\n    }\r\n\r\n}\r\n"},"OneDropDeclaration.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.14;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./IWISB.sol\";\r\nimport \"./IWISBInsurance.sol\";\r\n\r\ncontract OneDropDeclarations {\r\n\r\n        address public masterAddress;\r\n\r\n        IERC20 public rewardToken;\r\n        IWISB public wisbToken;\r\n        IWISBInsurance public wisbInsurance;\r\n\r\n        uint256 constant SMALL_PRECISION = 10 ** 4;\r\n        uint256 constant MEDIUM_PRECISION = 10 ** 6;\r\n        uint256 constant PENALTY_ADJUSTED_PRECISION = 10 ** 14;\r\n        uint256 constant PRECISION_REDUCED = 10 ** 16;\r\n        uint256 constant PRECISION = 10 ** 18;\r\n        uint256 constant INSURANCE_PENALTY = 1111* 10 ** 15;\r\n        uint256 constant PRECISION_INCREASED = 10 ** 20;\r\n        uint256 constant PRECISION_SQ = PRECISION * PRECISION;\r\n        uint256 constant SECONDS_IN_DAY = 86400;\r\n        uint256 constant FIVE_YEARS = 1825;\r\n        uint256 constant ONE_YEAR = 365;\r\n        uint256 constant LENGTH_BONUS_PER_YEAR = 5;\r\n        uint256 constant BASIS_BONUS = 105;\r\n        uint256 constant PRECISION_ADJUSTED_RATIO = 15500;\r\n        uint256 constant LENGTH_BONUS_AFTER_5_YEARS = 1200;\r\n        uint256 constant SLOPE = 250000;\r\n        uint256 constant PRICE_DROP_CONSTANT = 155;\r\n        uint256 constant LINEAR_EQUATION_CONSTANT = 2500;\r\n        uint256 constant AIRDROP_WEIGHT_CONSTANT = 55;\r\n        uint256 constant TEN_PERCENT_PRECISION = 1000;\r\n        uint256 constant EIGHTY_PERCENT_PRECISION = 8000;\r\n\r\n        uint256 public MAX_START_DAY;\r\n        uint256 public totalRewards;\r\n        uint256 public latestTotalShares;\r\n\r\n        bool public registerAllowed;\r\n        bool public addRewardsAllowed;\r\n\r\n        bytes16 ZERO_BYTES;\r\n\r\n        mapping(address =\u003e uint256) public userShares;\r\n        mapping(address =\u003e uint256) public reduktor;\r\n        mapping(bytes16 =\u003e bool) public hasOwner;\r\n    }\r\n"},"OneDropHelper.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.14;\r\n\r\nimport \"./OneDropDeclaration.sol\";\r\n\r\ncontract OneDropHelpers is OneDropDeclarations {\r\n\r\n    function _getInsuranceStakeInfo(\r\n        uint256 _index,\r\n        address _user\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            bytes16 actualID,\r\n            address actualOwner\r\n        )\r\n    {\r\n        (\r\n            actualID,\r\n            ,\r\n            ,\r\n            ,\r\n            ,\r\n            actualOwner,\r\n        ) = wisbInsurance.insuranceStakes(\r\n            _user,\r\n            _index\r\n        );\r\n    }\r\n\r\n    function _setOwnerStatusOfStakeID(\r\n        bytes16 _ID\r\n    )\r\n        internal\r\n    {\r\n        hasOwner[_ID] = true;\r\n    }\r\n\r\n    function _calculateRewardUser(\r\n        address _user,\r\n        uint256 _shares\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 resultPrep = _shares\r\n            * PRECISION_SQ\r\n            / latestTotalShares;\r\n\r\n        return (totalRewards - reduktor[_user])\r\n            * resultPrep\r\n            / PRECISION_SQ;\r\n    }\r\n\r\n    function _calculateShares(\r\n        uint256 _lockdays,\r\n        uint256 _finalDay,\r\n        uint256 _shares,\r\n        uint256 _startDay,\r\n        uint256 _closeDay,\r\n        bool _insurance\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 lengthWeighted;\r\n        uint256 penalty = _calculatePenalty(\r\n            _lockdays,\r\n            _finalDay,\r\n            _closeDay,\r\n            _insurance\r\n        );\r\n\r\n        uint256 airdropFactor = _calcReceivedAirdropFactor(\r\n            _startDay\r\n        );\r\n\r\n        if (_lockdays \u003c= FIVE_YEARS) {\r\n\r\n            lengthWeighted = _determineLengthFactorShort(\r\n                _lockdays\r\n            );\r\n\r\n            return _determineAdjustedShares(\r\n                lengthWeighted,\r\n                penalty,\r\n                airdropFactor,\r\n                _shares\r\n            );\r\n\r\n        }\r\n\r\n        lengthWeighted = _determineLengthFactorLong(\r\n            _lockdays\r\n        );\r\n\r\n        return _determineAdjustedShares(\r\n            lengthWeighted,\r\n            penalty,\r\n            airdropFactor,\r\n            _shares\r\n        );\r\n    }\r\n\r\n    function _determineAdjustedShares(\r\n        uint256 _lengthWeighted,\r\n        uint256 _penalty,\r\n        uint256 _airdropFactor,\r\n        uint256 _shares\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n\r\n    uint256 numerator =\r\n        PRECISION*(\r\n            (\r\n                PRICE_DROP_CONSTANT*\r\n                PRECISION_REDUCED\r\n            )\r\n            + _penalty\r\n            - _lengthWeighted\r\n    );\r\n\r\n    uint256 denominator = AIRDROP_WEIGHT_CONSTANT*_airdropFactor;\r\n\r\n    uint256 kFactor = numerator/denominator;\r\n\r\n    return  kFactor*\r\n            _shares\r\n            /PRECISION_REDUCED;\r\n    }\r\n\r\n    function _determineLengthFactorShort(\r\n        uint256 _lockdays\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 lengthWeighted =\r\n            LENGTH_BONUS_PER_YEAR*\r\n            PRECISION*\r\n            _lockdays/\r\n            ONE_YEAR;\r\n\r\n        lengthWeighted += PRECISION_INCREASED;\r\n\r\n        return  lengthWeighted/\r\n                BASIS_BONUS;\r\n    }\r\n\r\n    function _determineLengthFactorLong(\r\n        uint256 _lockdays\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n\r\n    uint256 lengthWeighted =\r\n        SLOPE +\r\n            (\r\n                LENGTH_BONUS_AFTER_5_YEARS*\r\n                _lockdays/\r\n                ONE_YEAR\r\n            );\r\n\r\n    lengthWeighted += MEDIUM_PRECISION;\r\n\r\n    return  lengthWeighted*\r\n            PENALTY_ADJUSTED_PRECISION/\r\n            BASIS_BONUS;\r\n    }\r\n\r\n    function _calcReceivedAirdropFactor(\r\n        uint256 _startDay\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 currentDay = wisbToken.currentWiseDay();\r\n        uint256 value =\r\n            PENALTY_ADJUSTED_PRECISION*\r\n            _startDay*\r\n            LINEAR_EQUATION_CONSTANT/\r\n            currentDay;\r\n\r\n        value += PRECISION;\r\n\r\n        return value;\r\n    }\r\n\r\n    function _calculatePenalty(\r\n        uint256 _lockdays,\r\n        uint256 _finalDay,\r\n        uint256 _closeDay,\r\n        bool _insurance\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256 penalty)\r\n    {\r\n        uint256 currentDay = wisbToken.currentWiseDay();\r\n\r\n        if (_insurance == true) return INSURANCE_PENALTY;\r\n\r\n        if (_abilitiyToSell(\r\n            _closeDay,\r\n            _finalDay,\r\n            currentDay\r\n            )   == true ) return 0;\r\n\r\n        uint256 percentagePrep =\r\n\r\n            PRECISION*(\r\n                TEN_PERCENT_PRECISION+\r\n                (\r\n                    EIGHTY_PERCENT_PRECISION*\r\n                    (\r\n                        _finalDay-\r\n                        currentDay-\r\n                        1\r\n                    )\r\n                    /\r\n                    (\r\n                        _lockdays-\r\n                        1\r\n                    )\r\n                )\r\n        );\r\n\r\n        penalty =   percentagePrep/\r\n                    SMALL_PRECISION;\r\n    }\r\n\r\n    function _abilitiyToSell(\r\n        uint256 _closeDay,\r\n        uint256 _finalDay,\r\n        uint256 _currentDay\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return  _closeDay \u003e 0 || _finalDay \u003c= _currentDay;\r\n    }\r\n\r\n    function _determineLengthStakeArray(\r\n        address _user,\r\n        bytes16 _lastID\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n\r\n        bytes16 currentID;\r\n        uint256 counter;\r\n\r\n        while (currentID != _lastID){\r\n\r\n            currentID = wisbToken.generateID(\r\n                _user,\r\n                counter,\r\n                0x01\r\n            );\r\n\r\n            counter += 1;\r\n        }\r\n\r\n        return counter;\r\n    }\r\n\r\n    function _determineLengthInsuranceStakeArray(\r\n        address _user\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 amount = 1;\r\n        uint256 counter;\r\n\r\n        while (amount \u003e 0){\r\n\r\n            amount = wisbInsurance.getStakedAmount(\r\n                _user,\r\n                counter\r\n            );\r\n            if (amount == 0) break;\r\n            counter += 1;\r\n    }\r\n        return counter;\r\n    }\r\n\r\n    function _investigateRequirements(\r\n        uint64 _lockdays,\r\n        uint64 _closeDay,\r\n        uint64 _finalDay,\r\n        uint64 _startDay,\r\n        bytes16 _ID\r\n    )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        bool condition1 = _lockdays \u003e= 365;\r\n        bool condition2 = _determineEmergencyExit(\r\n            _closeDay,\r\n            _finalDay\r\n        )\r\n            == false;\r\n        bool condition3 = _startDay \u003c= MAX_START_DAY;\r\n        bool condition4 = hasOwner[_ID] == false;\r\n\r\n        if (\r\n            condition1 == condition2 == condition3 == condition4 == true\r\n        )       return true;\r\n\r\n        return false;\r\n    }\r\n\r\n    function _checkRequirementsUpdateStakeMappings(\r\n        uint64 _lockdays,\r\n        bytes16 _ID,\r\n        bool _insurance,\r\n        uint256 _stakesShares,\r\n        uint64 _finalDay,\r\n        uint64 _startDay,\r\n        uint64 _closeDay\r\n    )\r\n        internal\r\n    {\r\n\r\n        require(\r\n            _investigateRequirements(\r\n                _lockdays,\r\n                _closeDay,\r\n                _finalDay,\r\n                _startDay,\r\n                _ID\r\n            )\r\n                == true,\r\n            \"OnedropHelper: STAKE_DOESNT_FIT_REQ\"\r\n        );\r\n\r\n        uint256 scaledShares = _calculateShares(\r\n            _lockdays,\r\n            _finalDay,\r\n            _stakesShares,\r\n            _startDay,\r\n            _closeDay,\r\n            _insurance\r\n        );\r\n\r\n        _increaseUserShares(\r\n            scaledShares,\r\n            msg.sender\r\n        );\r\n\r\n        _increaseLatestTotalShares(\r\n            scaledShares\r\n        );\r\n\r\n        _setOwnerStatusOfStakeID(\r\n            _ID\r\n        );\r\n\r\n    }\r\n\r\n    function _determineEmergencyExit(\r\n        uint256 _closeDay,\r\n        uint256 _finalDay\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        if (_closeDay \u003e 0 \u0026\u0026 _closeDay \u003c _finalDay) return true;\r\n\r\n        return false;\r\n    }\r\n\r\n    function _increaseTotalRewards(\r\n        uint256 _amount\r\n    )\r\n        internal\r\n    {\r\n        totalRewards += _amount;\r\n    }\r\n\r\n    function _increaseLatestTotalShares(\r\n        uint256 _amount\r\n    )\r\n        internal\r\n    {\r\n        latestTotalShares += _amount;\r\n    }\r\n\r\n    function _increaseUserShares(\r\n        uint256 _amount,\r\n        address _user\r\n    )\r\n        internal\r\n    {\r\n        userShares[_user] += _amount;\r\n    }\r\n\r\n}\r\n"}}