{"Context.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}"},"DividendPayingToken.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport \"./SafeMathUint.sol\";\r\nimport \"./SafeMathInt.sol\";\r\nimport \"./DividendPayingTokenInterface.sol\";\r\nimport \"./DividendPayingTokenOptionalInterface.sol\";\r\nimport \"./Ownable.sol\";\r\n\r\ncontract DividendPayingToken is Ownable, DividendPayingTokenInterface, DividendPayingTokenOptionalInterface {\r\n    using SafeMath for uint256;\r\n    using SafeMathUint for uint256;\r\n    using SafeMathInt for int256;\r\n\r\n    address ERC20Token = 0x55d398326f99059fF775485246999027B3197955;\r\n    mapping(address =\u003e uint256) private _balances;\r\n    uint256 private _totalSupply;\r\n\r\n    uint256 constant internal magnitude = 2**128;\r\n\r\n    uint256 internal magnifiedDividendPerShare;\r\n    mapping(address =\u003e int256) internal magnifiedDividendCorrections;\r\n    mapping(address =\u003e uint256) internal withdrawnDividends;\r\n\r\n    uint256 public totalDividendsDistributed;\r\n\r\n    constructor() public {\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function distributeERC20Dividends(uint256 amount) public onlyOwner {\r\n        //require(totalSupply() \u003e 0);\r\n        uint total = totalSupply();\r\n        if (total == 0) {\r\n            total = 1;\r\n        }\r\n        if (amount \u003e 0) {\r\n            magnifiedDividendPerShare = magnifiedDividendPerShare.add(\r\n                (amount).mul(magnitude) / total\r\n            );\r\n            emit DividendsDistributed(msg.sender, amount);\r\n            totalDividendsDistributed = totalDividendsDistributed.add(amount);\r\n        }\r\n    }\r\n\r\n    function withdrawDividend() public virtual override {\r\n        _withdrawDividendOfUser(msg.sender);\r\n    }\r\n\r\n    function _withdrawDividendOfUser(address user) internal returns (uint256) {\r\n        uint256 _withdrawableDividend = withdrawableDividendOf(user);\r\n        if (_withdrawableDividend \u003e 0) {\r\n            withdrawnDividends[user] = withdrawnDividends[user].add(_withdrawableDividend);\r\n            emit DividendWithdrawn(user, _withdrawableDividend);\r\n\r\n            bool success = IERC20(ERC20Token).transfer(user, _withdrawableDividend);\r\n            if(!success) {\r\n                withdrawnDividends[user] = withdrawnDividends[user].sub(_withdrawableDividend);\r\n                return 0;\r\n            }\r\n            return _withdrawableDividend;\r\n        }\r\n        return 0;\r\n    }\r\n    \r\n    function dividendOf(address _owner) public view override returns(uint256) {\r\n        return withdrawableDividendOf(_owner);\r\n    }\r\n\r\n    function withdrawableDividendOf(address _owner) public view override returns(uint256) {\r\n        return accumulativeDividendOf(_owner).sub(withdrawnDividends[_owner]);\r\n    }\r\n\r\n    function withdrawnDividendOf(address _owner) public view override returns(uint256) {\r\n        return withdrawnDividends[_owner];\r\n    }\r\n\r\n    function accumulativeDividendOf(address _owner) public view override returns(uint256) {\r\n        return magnifiedDividendPerShare.mul(balanceOf(_owner)).toInt256Safe().add(magnifiedDividendCorrections[_owner]).toUint256Safe() / magnitude;\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal {\r\n\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n\r\n        magnifiedDividendCorrections[account] = magnifiedDividendCorrections[account]\r\n        .sub( (magnifiedDividendPerShare.mul(amount)).toInt256Safe() );\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal {\r\n        \r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n\r\n        magnifiedDividendCorrections[account] = magnifiedDividendCorrections[account]\r\n        .add( (magnifiedDividendPerShare.mul(amount)).toInt256Safe() );\r\n    }\r\n\r\n    function _setBalance(address account, uint256 newBalance) internal {\r\n        uint256 currentBalance = balanceOf(account);\r\n        if(newBalance \u003e currentBalance) {\r\n            uint256 mintAmount = newBalance.sub(currentBalance);\r\n            _mint(account, mintAmount);\r\n        } else if(newBalance \u003c currentBalance) {\r\n            uint256 burnAmount = currentBalance.sub(newBalance);\r\n            _burn(account, burnAmount);\r\n        }\r\n    }\r\n}"},"DividendPayingTokenInterface.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n/// @title Dividend-Paying Token Interface\r\n/// @author Roger Wu (https://github.com/roger-wu)\r\n/// @dev An interface for a dividend-paying token contract.\r\ninterface DividendPayingTokenInterface {\r\n  /// @notice View the amount of dividend in wei that an address can withdraw.\r\n  /// @param _owner The address of a token holder.\r\n  /// @return The amount of dividend in wei that `_owner` can withdraw.\r\n  function dividendOf(address _owner) external view returns(uint256);\r\n\r\n  /// @notice Withdraws the ether distributed to the sender.\r\n  /// @dev SHOULD transfer `dividendOf(msg.sender)` wei to `msg.sender`, and `dividendOf(msg.sender)` SHOULD be 0 after the transfer.\r\n  ///  MUST emit a `DividendWithdrawn` event if the amount of ether transferred is greater than 0.\r\n  function withdrawDividend() external;\r\n\r\n  /// @dev This event MUST emit when ether is distributed to token holders.\r\n  /// @param from The address which sends ether to this contract.\r\n  /// @param weiAmount The amount of distributed ether in wei.\r\n  event DividendsDistributed(\r\n    address indexed from,\r\n    uint256 weiAmount\r\n  );\r\n\r\n  /// @dev This event MUST emit when an address withdraws their dividend.\r\n  /// @param to The address which withdraws ether from this contract.\r\n  /// @param weiAmount The amount of withdrawn ether in wei.\r\n  event DividendWithdrawn(\r\n    address indexed to,\r\n    uint256 weiAmount\r\n  );\r\n}"},"DividendPayingTokenOptionalInterface.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n/// @title Dividend-Paying Token Optional Interface\r\n/// @author Roger Wu (https://github.com/roger-wu)\r\n/// @dev OPTIONAL functions for a dividend-paying token contract.\r\ninterface DividendPayingTokenOptionalInterface {\r\n  /// @notice View the amount of dividend in wei that an address can withdraw.\r\n  /// @param _owner The address of a token holder.\r\n  /// @return The amount of dividend in wei that `_owner` can withdraw.\r\n  function withdrawableDividendOf(address _owner) external view returns(uint256);\r\n\r\n  /// @notice View the amount of dividend in wei that an address has withdrawn.\r\n  /// @param _owner The address of a token holder.\r\n  /// @return The amount of dividend in wei that `_owner` has withdrawn.\r\n  function withdrawnDividendOf(address _owner) external view returns(uint256);\r\n\r\n  /// @notice View the amount of dividend in wei that an address has earned in total.\r\n  /// @dev accumulativeDividendOf(_owner) = withdrawableDividendOf(_owner) + withdrawnDividendOf(_owner)\r\n  /// @param _owner The address of a token holder.\r\n  /// @return The amount of dividend in wei that `_owner` has earned in total.\r\n  function accumulativeDividendOf(address _owner) external view returns(uint256);\r\n}"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"},"IterableMapping.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\nlibrary IterableMapping {\r\n    // Iterable mapping from address to uint;\r\n    struct Map {\r\n        address[] keys;\r\n        mapping(address =\u003e uint) values;\r\n        mapping(address =\u003e uint) indexOf;\r\n        mapping(address =\u003e bool) inserted;\r\n    }\r\n\r\n    function get(Map storage map, address key) public view returns (uint) {\r\n        return map.values[key];\r\n    }\r\n\r\n    function getIndexOfKey(Map storage map, address key) public view returns (int) {\r\n        if(!map.inserted[key]) {\r\n            return -1;\r\n        }\r\n        return int(map.indexOf[key]);\r\n    }\r\n\r\n    function getKeyAtIndex(Map storage map, uint index) public view returns (address) {\r\n        return map.keys[index];\r\n    }\r\n\r\n    function size(Map storage map) public view returns (uint) {\r\n        return map.keys.length;\r\n    }\r\n\r\n    function set(Map storage map, address key, uint val) public {\r\n        if (map.inserted[key]) {\r\n            map.values[key] = val;\r\n        } else {\r\n            map.inserted[key] = true;\r\n            map.values[key] = val;\r\n            map.indexOf[key] = map.keys.length;\r\n            map.keys.push(key);\r\n        }\r\n    }\r\n\r\n    function remove(Map storage map, address key) public {\r\n        if (!map.inserted[key]) {\r\n            return;\r\n        }\r\n\r\n        delete map.inserted[key];\r\n        delete map.values[key];\r\n\r\n        uint index = map.indexOf[key];\r\n        uint lastIndex = map.keys.length - 1;\r\n        address lastKey = map.keys[lastIndex];\r\n\r\n        map.indexOf[lastKey] = index;\r\n        delete map.indexOf[key];\r\n\r\n        map.keys[index] = lastKey;\r\n        map.keys.pop();\r\n    }\r\n}"},"MDAO.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./DividendPayingToken.sol\";\nimport \"./SafeMath.sol\";\nimport \"./IterableMapping.sol\";\nimport \"./Ownable.sol\";\nimport \"./IERC20.sol\";\n\ninterface IMDAO is IERC20 {\n    function uplines(address account) external view returns (address);\n}\n\ncontract MDAO is IERC20, Ownable {\n    using SafeMath for uint256;\n    mapping (address =\u003e uint256) private _balances;\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\n    uint256 private _totalSupply;\n    IERC20 public c_erc20 = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    DividendTracker public dividendTracker;\n    DividendTracker public dividendTrackerNode;\n    IMDAO public c_mdao = IMDAO(0xD1B0A5F8e6Ed9EB46b4fDbe175F100B45e6650D5);\n    mapping (address =\u003e bool) public ief;\n    mapping (uint256 =\u003e uint256) public rrr;\n    mapping(address =\u003e bool) public nodes;\n    address public pta = 0x1000000000000000000000000000000000000001;\n    address public uta = 0xFC7Fb55E769c122DB951c1D3313279D9A70DE4Db;\n    uint256 public swapTokensAtAmount = 1000000 * (10**18);\n    IUniswapV2Router02 public uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    address public pair;\n    bool public pairIsCreated = false;\n    uint256 public constant sba = 1000000000*10**18;\n    uint256 public constant na = 50000000*10**18;\n    address public market = 0xC9d94F2c4170eDc4615b32c47C3c16BCFb8E8202;\n    uint256 public minRefNum = 1;\n    mapping (address =\u003e address) public ups;\n    mapping (address =\u003e bool) public noups;\n\n    address[] public shareholders;\n    mapping(address =\u003e uint256) public shareholderIndexes;\n    mapping(address =\u003e bool) private _updated;\n    mapping(address =\u003e bool) isDividendExempt;\n    address private _destroyAddress = address(0x000000000000000000000000000000000000dEaD);\n    uint256 public minPeriod = 1 hours;\n    uint256 public dividendAtAmount = 500000 * (10**18);\n    uint256 public lastTimeDividend;\n    uint256 distributorGas = 400000;\n    uint256 currentIndex;\n    address public lpAddress = 0xf397f5D5f768b7Be68EC099c74de62744d17017C;\n\n    constructor() public {\n        uint256 total = 1000*10**8*10**18;\n        _balances[msg.sender] = total;\n        _totalSupply = total;\n        emit Transfer(address(0), msg.sender, total);\n        address _pair = pairFor(uniswapV2Router.factory(), address(this), address(c_erc20));\n        pair = _pair;\n        ief[address(this)] = true;\n        ief[msg.sender] = true;\n        noups[address(this)] = true;\n        noups[msg.sender] = true;\n        noups[address(uniswapV2Router)] = true;\n        noups[_pair] = true;\n        rrr[1] = 100;\n        rrr[2] = 25;\n        rrr[3] = 25;\n        rrr[4] = 25;\n        rrr[5] = 25;\n        rrr[6] = 25;\n        rrr[7] = 25;\n        rrr[8] = 25;\n        rrr[9] = 25;\n        dividendTracker = new DividendTracker();\n        excludeFromDividends(_pair);\n        excludeFromDividends(address(this));\n        excludeFromDividends(lpAddress);\n\n        dividendTrackerNode = new DividendTracker();\n\n        isDividendExempt[address(this)] = true;\n        isDividendExempt[address(0)] = true;\n        isDividendExempt[_destroyAddress] = true;\n        isDividendExempt[lpAddress] = true;\n    }\n\n    function setMP(uint256 mp) external onlyOwner {\n        minPeriod = mp;\n    }\n\n    function setDA(uint256 da) external onlyOwner {\n        dividendAtAmount = da;\n    }\n\n    function setDG(uint256 dg) external onlyOwner {\n        distributorGas = dg;\n    }\n\n    function getS() external view returns(uint256) {\n        return shareholders.length;\n    }\n\n    function symbol() external pure returns (string memory) {\n        return \"MDAO\";\n    }\n\n    function name() external pure returns (string memory) {\n        return \"meta dao\";\n    }\n\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal {\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        require(currentAllowance \u003e= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, msg.sender, currentAllowance - amount);\n\n        return true;\n    }\n\n    function _prd(address recipient) private {\n        uint256 newBalance = _balances[recipient];\n        dividendTracker.setBalance(recipient, newBalance);\n        if(nodes[recipient]) {\n            if(newBalance \u003c na) {\n                dividendTrackerNode.excludeFromDividends(recipient);\n                nodes[recipient] = false;\n            }else{\n                dividendTrackerNode.setBalance(recipient, na);\n            }\n        }\n    }\n\n    function _tfn(address sender, address recipient, uint256 amount) private {\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n        _prd(recipient);\n    }\n\n    function _tfns(address sender, address recipient, uint256 amount) private {\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n        _prd(recipient);\n\n        uint256 contractTokenBalance = balanceOf(address(this));\n        if(contractTokenBalance \u003e= swapTokensAtAmount) {\n            ssd(contractTokenBalance);\n            return;\n        }\n\n        try dividendTracker.pfn() {\n        } catch {\n        }\n    }\n\n    function _slp(address sender, address recipient) private {\n        if(!pairIsCreated) {\n            return;\n        }\n        if (!isDividendExempt[sender] \u0026\u0026 sender != pair)\n            setShare(sender);\n        if (!isDividendExempt[recipient] \u0026\u0026 recipient != pair)\n            setShare(recipient);\n\n        uint256 poolTempAmount = _balances[pta];\n        if (poolTempAmount \u003e= dividendAtAmount \u0026\u0026\n            sender != address(this) \u0026\u0026\n            lastTimeDividend.add(minPeriod) \u003c= block.timestamp) {\n            \n            process(distributorGas);\n            lastTimeDividend = block.timestamp;\n        }\n    }\n\n    function ssd(uint256 tokenAmount) private {\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = address(c_erc20);\n\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n\n        uint256[] memory amounts = uniswapV2Router.swapExactTokensForTokens(\n            tokenAmount,\n            0,\n            path,\n            uta,\n            block.timestamp\n        );\n        uint256 holdAmount = amounts[1]/2;\n        c_erc20.transferFrom(uta, address(dividendTracker), holdAmount);\n        dividendTracker.distributeERC20Dividends(holdAmount);\n        c_erc20.transferFrom(uta, address(dividendTrackerNode), amounts[1] - holdAmount);\n        dividendTrackerNode.distributeERC20Dividends(amounts[1] - holdAmount);\n    }\n\n    function _tfb(address sender, address recipient, uint256 amount) private {\n        \n        uint256 one = amount/10000;  \n        uint256 rewardBun = _refPayoutToken(sender, recipient, one);\n\n        uint256 liquidityAmount = 300*one;\n        _balances[pta] += liquidityAmount;\n        emit Transfer(sender, pta, liquidityAmount);\n\n        uint256 damount = 200*one;\n        _balances[address(this)] += damount;\n        emit Transfer(sender, address(this), damount);\n\n        uint256 receiveAmount = amount - liquidityAmount - rewardBun - damount;\n        _balances[recipient] += receiveAmount;\n        emit Transfer(sender, recipient, receiveAmount);\n\n        _prd(recipient);\n\n        try dividendTracker.pfn() {\n        } catch {\n        }\n    }\n\n    function _refPayoutToken(address sender, address recipient, uint256 amount) private returns(uint256){\n        address addr = sender;\n        if(sender == pair) {\n            addr = recipient;\n        }\n        address up = ups[addr];\n        uint256 rewardBun = 0;\n\n        for(uint8 i = 1; i \u003c 10; i++) {\n            if(up == address(0)) break;\n            uint256 reward = amount*rrr[i];\n            _balances[up] += reward;\n            rewardBun += reward;\n            emit Transfer(sender, up, reward);\n            up = ups[up];\n        }\n\n        if(totalSupply() \u003e sba) {\n            rewardBun = 400*amount - rewardBun;\n            _totalSupply -= rewardBun;\n            emit Transfer(sender, address(0), rewardBun);\n            return 400*amount;\n        }\n        return rewardBun;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance \u003e= amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[sender] = senderBalance - amount;\n        _prd(sender);\n        _register(sender, recipient, amount);\n        if(ief[sender] || ief[recipient]) {\n            _tfn(sender, recipient, amount);\n            _slp(sender, recipient);\n            return;\n        }\n        address _pair = pair;\n        if(sender != _pair \u0026\u0026 recipient != _pair) {\n            _tfns(sender, recipient, amount);\n            _slp(sender, recipient);\n            return;\n        }\n        if(recipient == _pair \u0026\u0026 sender != _pair) {\n            _tfb(sender, recipient, amount);\n            _slp(sender, recipient);\n            return;\n        }\n        if(sender == _pair \u0026\u0026 recipient != _pair) {\n            _tfb(sender, recipient, amount);\n            _slp(sender, recipient);\n            return;\n        }\n        _tfn(sender, recipient, amount);\n    }\n\n    function _register(address sender, address recipient, uint256 amount) internal { \n        if(ups[recipient]!=address(0) || noups[recipient]) {\n            return;\n        }\n        address up = c_mdao.uplines(recipient);\n        if(up != address(0)) {\n            ups[recipient] = up;\n            return;\n        }\n        if(sender == pair) {\n            ups[recipient] = owner();\n            return;\n        }\n        if(sender != recipient \u0026\u0026 amount \u003e= minRefNum) {\n            ups[recipient] = sender;\n        }\n    }\n\n    function setShare(address shareholder) private {\n        if (_updated[shareholder]) {\n            if (IERC20(pair).balanceOf(shareholder) == 0)\n                quitShare(shareholder);\n            return;\n        }\n        if (IERC20(pair).balanceOf(shareholder) == 0) return;\n        addShareholder(shareholder);\n        _updated[shareholder] = true;\n    }\n\n    function addShareholder(address shareholder) internal {\n        shareholderIndexes[shareholder] = shareholders.length;\n        shareholders.push(shareholder);\n    }\n\n    function quitShare(address shareholder) private {\n        removeShareholder(shareholder);\n        _updated[shareholder] = false;\n    }\n\n    function removeShareholder(address shareholder) internal {\n        shareholders[shareholderIndexes[shareholder]] = shareholders[\n            shareholders.length - 1\n        ];\n        shareholderIndexes[\n            shareholders[shareholders.length - 1]\n        ] = shareholderIndexes[shareholder];\n        shareholders.pop();\n    }\n\n    function process(uint256 gas) private {\n        uint256 shareholderCount = shareholders.length;\n\n        if (shareholderCount == 0) return;\n        uint256 nowbanance = _balances[pta];\n        uint256 gasUsed = 0;\n        uint256 gasLeft = gasleft();\n\n        uint256 iterations = 0;\n\n        while (gasUsed \u003c gas \u0026\u0026 iterations \u003c shareholderCount) {\n            if (currentIndex \u003e= shareholderCount) {\n                currentIndex = 0;\n            }\n\n            uint256 amount = nowbanance\n                .mul(\n                    IERC20(pair).balanceOf(shareholders[currentIndex])\n                )\n                .div(IERC20(pair).totalSupply() - IERC20(pair).balanceOf(lpAddress) );\n            if (_balances[pta] \u003c amount) return;\n            distributeDividend(shareholders[currentIndex], amount);\n\n            gasUsed = gasUsed.add(gasLeft.sub(gasleft()));\n            gasLeft = gasleft();\n            currentIndex++;\n            iterations++;\n        }\n    }\n\n    function distributeDividend(address shareholder, uint256 amount) internal {\n        _balances[pta] -= amount;\n        _balances[shareholder] += amount;\n        emit Transfer(pta, shareholder, amount);\n    }\n\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair_) {\n        (address token0, address token1) = tokenA \u003c tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        pair_ = address(uint160(uint(keccak256(abi.encodePacked(\n                hex\u0027ff\u0027,\n                factory,\n                keccak256(abi.encodePacked(token0, token1)),\n                hex\u002700fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5\u0027\n        )))));\n    }\n\n    function migrate(address[] memory addrs) external onlyOwner {\n        uint256 len = addrs.length;\n        for (uint256 i = 0; i \u003c len; i++) {\n            address addr = addrs[i];\n            uint256 amount = c_mdao.balanceOf(addr);\n            require(_balances[address(this)] \u003e= amount, \"sub err\");\n            _balances[address(this)] -= amount;\n            _balances[addr] += amount;\n            emit Transfer(address(this), addr, amount);\n\n            address up = c_mdao.uplines(addr);\n            if(up != address(0)) {\n                ups[addr] = up;\n            }\n        }\n    }\n\n    function getToken(address addr, uint256 amount) external onlyOwner {\n        require(_balances[address(this)] \u003e= amount, \"sub err\");\n        _balances[address(this)] -= amount;\n        _balances[addr] += amount;\n        emit Transfer(address(this), addr, amount);\n    }\n\n    function setPair(address pair_) public onlyOwner {\n        pair = pair_;\n    }\n\n    function setPairIsCreated(bool b) external onlyOwner {\n        pairIsCreated = b;\n    }\n\n    function setS(uint256 s) public onlyOwner {\n        swapTokensAtAmount = s;\n    }\n\n    function excludeFromFees(address account, bool b) public onlyOwner {\n        ief[account] = b;\n    }\n\n    function setFes(address[] memory addrs) public onlyOwner {\n        uint256 len = addrs.length;\n        for(uint256 i = 0; i \u003c len; i++){\n            ief[addrs[i]] = true;\n        }\n    }\n\n    function setNodes(address[] memory addrs) public onlyOwner {\n        uint256 len = addrs.length;\n        for(uint256 i = 0; i \u003c len; i++){\n            nodes[addrs[i]] = true;\n        }\n    }\n\n    function setNode(address addr, bool b) public onlyOwner {\n        nodes[addr] = b;\n    }\n\n    function updateClaimWaitNode(uint256 claimWait) external onlyOwner {\n        dividendTrackerNode.updateClaimWait(claimWait);\n    }\n\n    function excludeFromDividendsNode(address account) public onlyOwner{\n        dividendTrackerNode.excludeFromDividends(account);\n    }\n\n    function claimNode() external {\n        dividendTrackerNode.processAccount(msg.sender, false);\n    }\n\n    function processDividendTrackerNode(uint256 gas) external {\n        dividendTrackerNode.process(gas);\n    }\n\n    function updateMinNode(uint256 n) external onlyOwner {\n        dividendTrackerNode.updateMin(n);\n    }\n\n    function updateProcessNumNode(uint256 newProcessNum) external onlyOwner {\n        dividendTrackerNode.updateProcessNum(newProcessNum);\n    }\n\n    function updateClaimWait(uint256 claimWait) external onlyOwner {\n        dividendTracker.updateClaimWait(claimWait);\n    }\n\n    function excludeFromDividends(address account) public onlyOwner{\n        dividendTracker.excludeFromDividends(account);\n    }\n\n    function setE(address[] memory addrs) public onlyOwner {\n        uint256 len = addrs.length;\n        for(uint256 i = 0; i \u003c len; i++){\n            dividendTracker.excludeFromDividendsM(addrs[i]);\n        }\n    }\n\n    function claim() external {\n        dividendTracker.processAccount(msg.sender, false);\n    }\n\n    function processDividendTracker(uint256 gas) external {\n        dividendTracker.process(gas);\n    }\n\n    function updateMin(uint256 n) external onlyOwner {\n        dividendTracker.updateMin(n);\n    }\n\n    function updateProcessNum(uint256 newProcessNum) external onlyOwner {\n        dividendTracker.updateProcessNum(newProcessNum);\n    }\n\n    function getClaimWait() external view returns(uint256) {\n        return dividendTracker.claimWait();\n    }\n\n    function getTotalDividendsDistributed() external view returns (uint256) {\n        return dividendTracker.totalDividendsDistributed();\n    }\n\n    function withdrawableDividendOf(address account) public view returns(uint256) {\n        return dividendTracker.withdrawableDividendOf(account);\n    }\n\n    function dividendTokenBalanceOf(address account) public view returns (uint256) {\n        return dividendTracker.balanceOf(account);\n    }\n\n    function getAccountDividendsInfo(address account) external view returns (address,int256,int256,uint256,uint256,uint256,uint256,uint256) {\n        return dividendTracker.getAccount(account);\n    }\n\n    function getAccountDividendsInfoAtIndex(uint256 index) external view returns (address,int256,int256,uint256,uint256,uint256,uint256,uint256) {\n        return dividendTracker.getAccountAtIndex(index);\n    }\n\n    function getLastProcessedIndex() external view returns(uint256) {\n        return dividendTracker.lastProcessedIndex();\n    }\n\n    function getNumberOfDividendTokenHolders() external view returns(uint256) {\n        return dividendTracker.getNumberOfTokenHolders();\n    }\n}\n\ncontract DividendTracker is Ownable, DividendPayingToken {\n    using SafeMath for uint256;\n    using SafeMathInt for int256;\n    using IterableMapping for IterableMapping.Map;\n\n    IterableMapping.Map private tokenHoldersMap;\n    uint256 public lastProcessedIndex;\n\n    mapping (address =\u003e bool) public excludedFromDividends;\n\n    mapping (address =\u003e uint256) public lastClaimTimes;\n    uint256 public claimWait;\n    uint256 public minimumTokenBalanceForDividends;\n    uint256 public processNum;\n\n    event ExcludeFromDividends(address indexed account);\n    event Claim(address indexed account, uint256 amount, bool indexed automatic);\n\n    constructor() public {\n        claimWait = 3600;\n        minimumTokenBalanceForDividends = 20000000 * (10**18);\n        processNum = 5;\n    }\n\n    function withdrawDividend() public override {\n        require(false, \"Dividend_Tracker: withdrawDividend disabled\");\n    }\n\n    function excludeFromDividendsM(address account) external onlyOwner {\n        excludedFromDividends[account] = true;\n    }\n\n    function excludeFromDividends(address account) external onlyOwner {\n        //require(!excludedFromDividends[account]);\n        if(excludedFromDividends[account]) {\n            return;\n        }\n        excludedFromDividends[account] = true;\n\n        _setBalance(account, 0);\n        tokenHoldersMap.remove(account);\n        emit ExcludeFromDividends(account);\n    }\n\n    function updateClaimWait(uint256 newClaimWait) external onlyOwner {\n        claimWait = newClaimWait;\n    }\n\n    function updateMin(uint256 newMinimumTokenBalanceForDividends) external onlyOwner {\n        minimumTokenBalanceForDividends = newMinimumTokenBalanceForDividends;\n    }\n\n    function updateProcessNum(uint256 newProcessNum) external onlyOwner {\n        processNum = newProcessNum;\n    }\n\n    function canAutoClaim(uint256 lastClaimTime) private view returns (bool) {\n        if(lastClaimTime \u003e block.timestamp)  {\n            return false;\n        }\n        return block.timestamp.sub(lastClaimTime) \u003e= claimWait;\n    }\n\n    function setBalance(address account, uint256 newBalance) external onlyOwner {\n        if(excludedFromDividends[account]) {\n            return;\n        }\n        if(newBalance \u003e= minimumTokenBalanceForDividends) {\n            _setBalance(account, newBalance);\n            tokenHoldersMap.set(account, newBalance);\n        }else {\n            _setBalance(account, 0);\n            tokenHoldersMap.remove(account);\n        }\n        processAccount(account, true);\n    }\n\n    function pfn() public {\n        uint256 numberOfTokenHolders = tokenHoldersMap.keys.length;\n        if(numberOfTokenHolders == 0) {\n            return;\n        }\n        uint256 _lastProcessedIndex = lastProcessedIndex;\n        uint256 _processNum = processNum;\n        if(_processNum \u003e numberOfTokenHolders) {\n            _processNum = numberOfTokenHolders;\n        }\n\n        for(uint256 i = 0; i \u003c _processNum; i++) {\n            _lastProcessedIndex++;\n            if(_lastProcessedIndex \u003e= numberOfTokenHolders) {\n                _lastProcessedIndex = 0;\n            }\n            address account = tokenHoldersMap.keys[_lastProcessedIndex];\n            if(canAutoClaim(lastClaimTimes[account])) {\n                processAccount(account, true);\n            }\n        }\n\n        lastProcessedIndex = _lastProcessedIndex;\n    }\n\n    function process(uint256 gas) public returns (uint256, uint256, uint256) {\n        uint256 numberOfTokenHolders = tokenHoldersMap.keys.length;\n        if(numberOfTokenHolders == 0) {\n            return (0, 0, lastProcessedIndex);\n        }\n        uint256 _lastProcessedIndex = lastProcessedIndex;\n        uint256 gasUsed = 0;\n        uint256 gasLeft = gasleft();\n        uint256 iterations = 0;\n        uint256 claims = 0;\n\n        while(gasUsed \u003c gas \u0026\u0026 iterations \u003c numberOfTokenHolders) {\n            _lastProcessedIndex++;\n            if(_lastProcessedIndex \u003e= tokenHoldersMap.keys.length) {\n                _lastProcessedIndex = 0;\n            }\n            address account = tokenHoldersMap.keys[_lastProcessedIndex];\n            if(canAutoClaim(lastClaimTimes[account])) {\n                if(processAccount(account, true)) {\n                    claims++;\n                }\n            }\n            iterations++;\n            uint256 newGasLeft = gasleft();\n            if(gasLeft \u003e newGasLeft) {\n                gasUsed = gasUsed.add(gasLeft.sub(newGasLeft));\n            }\n            gasLeft = newGasLeft;\n        }\n\n        lastProcessedIndex = _lastProcessedIndex;\n        return (iterations, claims, lastProcessedIndex);\n    }\n\n    function processAccount(address account, bool automatic) public onlyOwner returns (bool) {\n        uint256 amount = _withdrawDividendOfUser(account);\n        if(amount \u003e 0) {\n            lastClaimTimes[account] = block.timestamp;\n            emit Claim(account, amount, automatic);\n            return true;\n        }\n        return false;\n    }\n\n    function getNumberOfTokenHolders() external view returns(uint256) {\n        return tokenHoldersMap.keys.length;\n    }\n\n    function getAccountAtIndex(uint256 index) public view returns (address,int256,int256,uint256,uint256,uint256,uint256,uint256){\n        if(index \u003e= tokenHoldersMap.size()) {\n            return (0x0000000000000000000000000000000000000000, -1, -1, 0, 0, 0, 0, 0);\n        }\n        address account = tokenHoldersMap.getKeyAtIndex(index);\n        return getAccount(account);\n    }\n\n    function getAccount(address _account) public view returns (address account, int256 index, int256 iterationsUntilProcessed, uint256 withdrawableDividends, uint256 totalDividends, \n        uint256 lastClaimTime, uint256 nextClaimTime, uint256 secondsUntilAutoClaimAvailable) {\n        account = _account;\n        index = tokenHoldersMap.getIndexOfKey(account);\n        iterationsUntilProcessed = -1;\n        if(index \u003e= 0) {\n            if(uint256(index) \u003e lastProcessedIndex) {\n                iterationsUntilProcessed = index.sub(int256(lastProcessedIndex));\n            } else {\n                uint256 processesUntilEndOfArray = tokenHoldersMap.keys.length \u003e lastProcessedIndex ? tokenHoldersMap.keys.length.sub(lastProcessedIndex) : 0;\n                iterationsUntilProcessed = index.add(int256(processesUntilEndOfArray));\n            }\n        }\n\n        withdrawableDividends = withdrawableDividendOf(account);\n        totalDividends = accumulativeDividendOf(account);\n        lastClaimTime = lastClaimTimes[account];\n        nextClaimTime = lastClaimTime \u003e 0 ? lastClaimTime.add(claimWait) : 0;\n        secondsUntilAutoClaimAvailable = nextClaimTime \u003e block.timestamp ? nextClaimTime.sub(block.timestamp) : 0;\n    }\n}\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\ninterface IPancakePair{\n    function sync() external;\n}"},"Ownable.sol":{"content":"pragma solidity 0.6.12;\r\n\r\n// SPDX-License-Identifier: MIT License\r\n\r\nimport \"./Context.sol\";\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () public {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003c= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003e 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}"},"SafeMathInt.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\n// Math operations for int256 with overflow safety checks.\r\nlibrary SafeMathInt {\r\n    int256 private constant MIN_INT256 = int256(1) \u003c\u003c 255;\r\n    int256 private constant MAX_INT256 = ~(int256(1) \u003c\u003c 255);\r\n\r\n    // Multiplies two int256 variables and fails on overflow.\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a * b;\r\n\r\n        // Detect overflow when multiplying MIN_INT256 with -1\r\n        require(c != MIN_INT256 || (a \u0026 MIN_INT256) != (b \u0026 MIN_INT256));\r\n        require((b == 0) || (c / b == a));\r\n        return c;\r\n    }\r\n\r\n    // Division of two int256 variables and fails on overflow.\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        // Prevent overflow when dividing MIN_INT256 by -1\r\n        require(b != -1 || a != MIN_INT256);\r\n\r\n        // Solidity already throws when dividing by 0.\r\n        return a / b;\r\n    }\r\n\r\n    // Subtracts two int256 variables and fails on overflow.\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b \u003e= 0 \u0026\u0026 c \u003c= a) || (b \u003c 0 \u0026\u0026 c \u003e a));\r\n        return c;\r\n    }\r\n\r\n    // Adds two int256 variables and fails on overflow.\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b \u003e= 0 \u0026\u0026 c \u003e= a) || (b \u003c 0 \u0026\u0026 c \u003c a));\r\n        return c;\r\n    }\r\n\r\n    // Converts to absolute value, and fails on overflow.\r\n    function abs(int256 a) internal pure returns (int256) {\r\n        require(a != MIN_INT256);\r\n        return a \u003c 0 ? -a : a;\r\n    }\r\n\r\n    function toUint256Safe(int256 a) internal pure returns (uint256) {\r\n        require(a \u003e= 0);\r\n        return uint256(a);\r\n    }\r\n}"},"SafeMathUint.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\nlibrary SafeMathUint {\r\n  function toInt256Safe(uint256 a) internal pure returns (int256) {\r\n    int256 b = int256(a);\r\n    require(b \u003e= 0);\r\n    return b;\r\n  }\r\n}"}}