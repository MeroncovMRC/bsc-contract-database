{"AgeOfEmperors.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\n// Website: V2.Ageofemperors.com\r\n// Telegram: @ageofemperors_chat\r\n\r\npragma solidity ^0.8.7;\r\npragma experimental ABIEncoderV2;\r\nimport \"./IERC20.sol\";\r\n\r\ncontract AgeOfEmperorsII {\r\n    struct Tower {\r\n        uint256 crystals;\r\n        uint256 money;\r\n        uint256 money2;\r\n        uint256 yield;\r\n        uint256 timestamp;\r\n        uint256 hrs;\r\n        address ref;\r\n        uint256 refs;\r\n        uint256 refDeps;\r\n        uint8   treasury;\r\n        uint8   market;\r\n        uint8[5] chefs;\r\n        bool[5] bounties;\r\n        bool king;\r\n    }\r\n\r\n    struct Stable {\r\n        uint256 stableBounty;\r\n        uint256 stableTimestamp;\r\n        uint256 stableHrs;\r\n        uint8   stable;\r\n    }\r\n\r\n    mapping(address =\u003e Tower) public towers;\r\n    mapping(address =\u003e Stable) public stables;\r\n\r\n    uint256 public totalChefs;\r\n    uint256 public totalTowers;\r\n    uint256 public totalKings;\r\n    uint256 public totalInvested;\r\n    address public manager;\r\n\r\n    IERC20 constant BUSD_TOKEN = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\r\n\r\n    uint256 immutable public denominator = 10;\r\n    bool public init;\r\n    uint256 public initTimestamp;\r\n\r\n    modifier initialized {\r\n      require(init, \u0027Not initialized\u0027);\r\n      _;\r\n    }\r\n\r\n    constructor(address manager_) {\r\n       manager = manager_;\r\n    }\r\n\r\n\r\n    function initialize() external {\r\n      require(manager == msg.sender);\r\n      require(!init);\r\n      init = true;\r\n      initTimestamp = block.timestamp;\r\n    }\r\n\r\n    function canUpgradeTower(address _addr) public view returns(bool) {\r\n        uint256 passedDays = (block.timestamp - initTimestamp) / 1 days;\r\n        uint256 currentChefs = towers[_addr].chefs[0] + towers[_addr].chefs[1] + towers[_addr].chefs[2] + towers[_addr].chefs[3] + towers[_addr].chefs[4];\r\n        if (currentChefs \u003e passedDays) return false;\r\n        return true;\r\n    }\r\n\r\n    function addCrystals(address ref, uint256 value) initialized external {\r\n        uint256 crystals = value / 2e17;\r\n        require(crystals \u003e 0, \"Zero stone\");\r\n        address user = msg.sender;\r\n        totalInvested += value;\r\n        if (towers[user].timestamp == 0) {\r\n            totalTowers++;\r\n            towers[ref].refs++;\r\n            towers[user].ref = ref;\r\n            towers[user].timestamp = block.timestamp;\r\n            towers[user].treasury = 0;\r\n            towers[user].market = 0;\r\n        }\r\n        ref = towers[user].ref;\r\n        uint8 marketId = towers[ref].market;\r\n        (,uint256 refCrystal, uint256 refGold) = getMarket(marketId);\r\n\r\n        towers[ref].crystals += (crystals * refCrystal) / 100;\r\n        towers[ref].money += (crystals * 100 * refGold) / 100;\r\n        towers[ref].refDeps += crystals;\r\n        towers[user].crystals += crystals;\r\n\r\n        BUSD_TOKEN.transferFrom(msg.sender, address(this), value);\r\n    }\r\n\r\n    function withdrawMoney(uint256 gold) initialized external {\r\n        address user = msg.sender;\r\n        require(gold \u003c= towers[user].money \u0026\u0026 gold \u003e 0);\r\n        towers[user].money -= gold;\r\n        uint256 amount = gold * 2e15;\r\n        BUSD_TOKEN.transfer(user, BUSD_TOKEN.balanceOf(address(this)) \u003c amount ? BUSD_TOKEN.balanceOf(address(this)) : amount);\r\n    }\r\n\r\n    function kingBounty() initialized external {\r\n        address user = msg.sender;\r\n        require(towers[user].king == false, \"Alread Claimed\");\r\n        require(towers[user].chefs[4] == 6 \u0026\u0026 towers[user].treasury == 4 \u0026\u0026 towers[user].market == 2 \u0026\u0026 stables[user].stable == 3, \"All building must be max level\");\r\n        syncTower(user);\r\n        towers[user].money += 250000;\r\n        towers[user].king = true;\r\n        totalKings += 1;\r\n    }\r\n\r\n    function collectMoney() public {\r\n        address user = msg.sender;\r\n        syncTower(user);\r\n        towers[user].hrs = 0;\r\n        towers[user].money += towers[user].money2;\r\n        towers[user].money2 = 0;\r\n    }\r\n    \r\n    function collectStableBounty() public {\r\n        address user = msg.sender;\r\n        syncStable(user);\r\n        stables[user].stableHrs = 0;\r\n        towers[user].money += stables[user].stableBounty;\r\n        stables[user].stableBounty = 0;\r\n    }\r\n\r\n    function claimAirdrop(uint256 towerId) initialized external {\r\n        address user = msg.sender;\r\n        syncTower(user);\r\n        require(towers[user].chefs[towerId] == 6, \"Not Max Level\");\r\n        require(towers[user].bounties[towerId] == false, \"Already Claimed\");\r\n        uint256 bounty = getBounty(towerId);\r\n        towers[user].money += bounty;\r\n        towers[user].bounties[towerId] = true;\r\n    }\r\n\r\n    function upgradeTower(uint256 towerId) initialized external {\r\n        require(towerId \u003c 5, \"Max 5 towers\");\r\n        address user = msg.sender;\r\n        require(canUpgradeTower(user), \"Should wait 1 day again\");\r\n        if (towerId \u003e 0) {\r\n            require(towers[user].chefs[towerId-1] == 6, \"Prev Tower not upgraded\");\r\n        }\r\n\r\n        syncTower(user);\r\n        towers[user].chefs[towerId]++;\r\n        totalChefs++;\r\n        uint256 chefs = towers[user].chefs[towerId];\r\n        towers[user].crystals -= getUpgradePrice(towerId, chefs) / denominator;\r\n        towers[user].yield += getYield(towerId, chefs);\r\n    }\r\n\r\n    function upgradeTowncenter() initialized external {\r\n      address user = msg.sender;\r\n      require(towers[user].chefs[0] == 6, \"Tower-1 should be Max Level\");\r\n      uint8 treasuryId = towers[user].treasury + 1;\r\n      syncTower(user);\r\n      require(treasuryId \u003c 5, \"Max 5 treasury\");\r\n      (uint256 price,) = getTreasure(treasuryId);\r\n      towers[user].crystals -= price / denominator; \r\n      towers[user].treasury = treasuryId;\r\n    }\r\n\r\n    function upgradeMarket() initialized external {\r\n      address user = msg.sender;\r\n      require(towers[user].chefs[1] == 6, \"Tower-2 should be Max Level\");\r\n      uint8 marketId = towers[user].market + 1;\r\n      require(marketId \u003c 3, \"Max 2 market\");\r\n      (uint256 price,,) = getMarket(marketId);\r\n      towers[user].crystals -= price / denominator; \r\n      towers[user].market = marketId;\r\n    }\r\n\r\n    function upgradeStable() initialized external {\r\n      address user = msg.sender;\r\n      uint8 stableId = stables[user].stable + 1;\r\n      require(stableId \u003c 4, \"Max 3 stable\");\r\n      (uint256 price,, uint256 towerId) = getStable(stableId);\r\n      require(towers[user].chefs[towerId] == 6, \"Tower should be Max Level\");\r\n      \r\n      towers[user].crystals -= price / denominator; \r\n      stables[user].stable = stableId;\r\n      stables[user].stableTimestamp = block.timestamp;\r\n    }\r\n\r\n    function compound() initialized external {\r\n        address user = msg.sender;\r\n        syncTower(user);\r\n        towers[user].crystals += 2 * towers[user].money / 100;\r\n        towers[user].money = 0;\r\n    }\r\n\r\n    function getChefs(address addr) external view returns (uint8[5] memory) {\r\n        return towers[addr].chefs;\r\n    }\r\n    \r\n    function getBounties(address addr) external view returns (bool[5] memory) {\r\n        return towers[addr].bounties;\r\n    }\r\n\r\n    function syncTower(address user) internal {\r\n        require(towers[user].timestamp \u003e 0, \"User is not registered\");\r\n        if (towers[user].yield \u003e 0) {\r\n            (, uint256 treasury) = getTreasure(towers[user].treasury);\r\n            uint256 hrs = block.timestamp / 3600 - towers[user].timestamp / 3600;\r\n            if (hrs + towers[user].hrs \u003e treasury) {\r\n                hrs = treasury - towers[user].hrs;\r\n            }\r\n            towers[user].money2 += hrs * towers[user].yield;\r\n            towers[user].hrs += hrs;\r\n        }\r\n        towers[user].timestamp = block.timestamp;\r\n    }\r\n\r\n    function syncStable(address user) internal {\r\n        require(stables[user].stableTimestamp \u003e 0, \"User Stable is not registered\");\r\n        uint8 stableId = stables[user].stable;\r\n        (,uint256 bounty,) = getStable(stableId);\r\n\r\n        if (bounty \u003e 0) {\r\n            uint256 hrs = block.timestamp / 3600 - stables[user].stableTimestamp / 3600;\r\n            if (hrs + stables[user].stableHrs \u003e 24) {\r\n                hrs = 24 - stables[user].stableHrs;\r\n            }\r\n            stables[user].stableBounty = (hrs + stables[user].stableHrs) / 24 * bounty;\r\n            stables[user].stableHrs += hrs;\r\n        }\r\n        stables[user].stableTimestamp = block.timestamp;\r\n    }\r\n\r\n    function getUpgradePrice(uint256 towerId, uint256 chefId) internal pure returns (uint256) {\r\n        if (chefId == 1) return [600, 9975, 25000, 40000, 55000][towerId];\r\n        if (chefId == 2) return [1145, 12425, 27500, 42500, 62500][towerId];\r\n        if (chefId == 3) return [2510, 15000, 30000, 45000, 67500][towerId];\r\n        if (chefId == 4) return [3960, 17525, 32500, 47500, 70000][towerId];\r\n        if (chefId == 5) return [5000, 20000, 35000, 50000, 77500][towerId];\r\n        if (chefId == 6) return [7500, 22500, 37500, 52500, 85000][towerId];\r\n        revert(\"Incorrect chefId\");\r\n    }\r\n\r\n    function getYield(uint256 towerId, uint256 chefId) internal pure returns (uint256) {\r\n        if (chefId == 1) return [5, 108, 333, 634, 1008][towerId];\r\n        if (chefId == 2) return [10, 140, 378, 691, 1173][towerId];\r\n        if (chefId == 3) return [23, 175, 425, 750, 1295][towerId];\r\n        if (chefId == 4) return [38, 212, 474, 812, 1372][towerId];\r\n        if (chefId == 5) return [50, 250, 525, 875, 1550][towerId];\r\n        if (chefId == 6) return [78, 291, 578, 940, 1735][towerId];\r\n        revert(\"Incorrect chefId\");\r\n    }\r\n\r\n    function getTreasure(uint256 treasureId) internal pure returns (uint256, uint256) {\r\n      if(treasureId == 0) return (0, 24); // price | hours\r\n      if(treasureId == 1) return (2000, 36);\r\n      if(treasureId == 2) return (2500, 48);\r\n      if(treasureId == 3) return (3000, 60);\r\n      if(treasureId == 4) return (4000, 72);\r\n      revert(\"Incorrect treasureId\");\r\n    }\r\n\r\n    function getMarket(uint256 marketId) internal pure returns (uint256, uint256, uint256) {\r\n      if(marketId == 0) return (0, 8, 4); // price | crystal Ref |  gold Ref\r\n      if(marketId == 1) return (2000, 10, 6);\r\n      if(marketId == 2) return (4000, 12, 8);\r\n      revert(\"Incorrect marketId\");\r\n    }\r\n\r\n    function getBounty(uint256 towerId) internal pure returns (uint256) {\r\n        return [10000, 50000, 80000, 140000, 210000][towerId];\r\n    }\r\n\r\n    function getStable(uint256 stableId) internal pure returns (uint256, uint256, uint256 ) {\r\n        if(stableId == 0) return (0, 0, 0); // price | gold bounty per 24hrs | tower id to max\r\n        if(stableId == 1) return (50000, 25000, 2);\r\n        if(stableId == 2) return (75000, 68750, 3);\r\n        if(stableId == 3) return (100000, 135000, 4);\r\n        revert(\"Incorrect stableId\");\r\n    }\r\n}"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller\u0027s account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}"}}