/*
BlindApe
Blind Ape
@BlindApeAI
http://t.me/BlindApe_Portal
Jungleblindape.cloud
https://t.me/BlindApe_Portal
ce upon a time there was a blind monkey who had to rely on his good sense of feeling and smell. This monkey was not inferior, no this monkey is the king in his forest. All monkeys trust him and follow him step by step. Blind ape stands for a safe investment and what is even better. Blind Ape offers an artificial intelligence with which you never have to worry about ape again.
APE TOGETHER STRONG!
What does this mean?
Great apes work together for a common good, goal, or in ways that benefit both parties. Blind Ape is not used to be alone, Blind Ape likes company, Blind Ape likes apes.

How to use?
To use the AI the user has to hold at least 0.2% of the total supply. 
The AI generates posts which includes solid apes analyzed by our AI to reduce the risk of scam or rugpull to almost zero.
On top of that our TG-Bot also provides you an overview of the latest apes plus gives you the opportuity to ape directly. 
We recommend to use a fresh wallet to connect to our App.
*/
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.19;

contract BlindApeToken {
    string public name = "BlindApe";
    string public symbol = "BlindApe";
    uint256 public totalSupply = 10000000000000000000000;
    uint8 public decimals = 9;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    event Approval(
        address indexed _ownerBlindApe,
        address indexed spenderBlindApe,
        uint256 _value
    );

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    address private owner;
    event OwnershipRenounced();

    constructor() {
        balanceOf[msg.sender] = totalSupply;
        owner = msg.sender;
    }


    function transfer(address _to, uint256 _value)
        public
        returns (bool success)
    {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address spenderBlindApe, uint256 _value)
        public
        returns (bool success)
    {
        require(address(0) != spenderBlindApe);
        allowance[msg.sender][spenderBlindApe] = _value;
        emit Approval(msg.sender, spenderBlindApe, _value);
        return true;
    }

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address _from,
        address _to,
        uint256 _value
    ) public returns (bool success) {
        require(_value <= balanceOf[_from]);
        require(_value <= allowance[_from][msg.sender]);
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }

    function renounceOwnership() public {
        require(msg.sender == owner);
        emit OwnershipRenounced();
        owner = address(0);
    }
}