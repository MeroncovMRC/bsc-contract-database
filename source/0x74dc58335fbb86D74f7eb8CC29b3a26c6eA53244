pragma solidity ^0.8.0;

// import "hardhat/console.sol";
// SPDX-License-Identifier: MIT
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this;
        // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}

abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _setOwner(_msgSender());
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(
            newOwner != address(0),
            "Ownable: new owner is the zero address"
        );
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

interface IMintContract {
    function ownerOf(uint256 id) external view returns (address);
}

contract claimContract is Ownable {
    function safeTransfer(address token, address to, uint256 value) internal {
        (bool success, bytes memory data) = token.call(
            abi.encodeWithSelector(0xa9059cbb, to, value)
        );
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            "TransferHelper: TRANSFER_FAILED"
        );
    }

    function safeTransferFrom(
        address token,
        address from,
        address to,
        uint256 value
    ) internal {
        (bool success, bytes memory data) = token.call(
            abi.encodeWithSelector(0x23b872dd, from, to, value)
        );
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            "TransferHelper: TRANSFER_FROM_FAILED"
        );
    }

    address public tokenAddress;
    uint256 public rewardAmount;

    uint256 public starttime;

    IMintContract public mintContract;
    uint256 ONE_DAY = 86400;
    uint256 ONE_MONTH = ONE_DAY * 30;
    uint256 rewardEndTime = ONE_MONTH * 5;

    struct Info {
        uint256 id;
        uint256 startTime;
        uint256 lastTime;
        bool closed;
    }
    mapping(uint256 => Info) public infos;

    event ClaimReward(
        address indexed account,
        uint256 indexed id,
        uint256 amount
    );

    //test
    function setTestOneDay(uint _oneDay) external onlyOwner {
        ONE_DAY = _oneDay;
        ONE_MONTH = ONE_DAY * 30;
        rewardEndTime = ONE_MONTH * 5;
    }

    //
    function setTokenAddress(address _token) external onlyOwner {
        tokenAddress = _token;
    }

    function setMintAddress(address _addr) external onlyOwner {
        mintContract = IMintContract(_addr);
    }

    function setRewardAmount(uint _amount) external onlyOwner {
        rewardAmount = _amount;
    }

    function setStartTime(uint _time) external onlyOwner {
        starttime = _time;
    }

    //

    modifier checkStart() {
        require(block.timestamp >= starttime, "not start");
        _;
    }

    function _claim(uint256 _id) internal returns (uint256) {
        require(msg.sender == mintContract.ownerOf(_id), "ownerOf");
        Info storage info = infos[_id];
        if (info.closed) {
            return 0;
        }
        (uint256 reward, , , uint256 nextTime) = getStatus(_id);
        if (info.id == 0) {
            info.id = _id;
            info.startTime = block.timestamp;
        }
        if (block.timestamp < nextTime) {
            return 0;
        }
        info.lastTime = block.timestamp;
        if (block.timestamp > info.startTime + rewardEndTime) {
            info.closed = true;
        }

        emit ClaimReward(msg.sender, _id, reward);
        return reward;
    }

    function claim(uint256[] memory ids) external checkStart {
        uint tmp = 0;
        for (uint i = 0; i < ids.length; i++) {
            tmp += _claim(ids[i]);
        }
        if (tmp > 0) {
            safeTransfer(tokenAddress, msg.sender, tmp);
        }
    }

    function perReward() internal view returns (uint256) {
        return (rewardAmount * 10) / 100;
    }

    //nextReward,remainingReward,lastTime,nextTime
    function getStatus(
        uint256 _id
    ) public view returns (uint256, uint256, uint256, uint256) {
        Info memory info = infos[_id];
        uint current = block.timestamp;
        if (info.startTime == 0) {
            return (rewardAmount / 2, rewardAmount, 0, starttime);
        }
        uint baseTime = info.startTime +
            ((info.lastTime - info.startTime) / ONE_MONTH) *
            ONE_MONTH;

        uint et = info.startTime + rewardEndTime;
        if (current > et) {
            current = et;
        }
        uint totalDay = (et - baseTime) / ONE_MONTH;
        uint day = (current - baseTime) / ONE_MONTH;
        uint per = perReward();
        if (day < totalDay) {
            day += 1;
        }
        return (day * per, totalDay * per, info.lastTime, baseTime + ONE_MONTH);
    }

    function getInfos(
        uint256[] memory ids
    ) external view returns (Info[] memory infoArr) {
        infoArr = new Info[](ids.length);
        for (uint i = 0; i < ids.length; i++) {
            infoArr[i] = infos[ids[i]];
        }
    }

    function getBlockTime() external view returns (uint) {
        return block.timestamp;
    }
}