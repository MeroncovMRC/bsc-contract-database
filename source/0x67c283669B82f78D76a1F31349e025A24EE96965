// File: openzeppelin-solidity/contracts/math/SafeMath.sol

pragma solidity 0.5.16;

/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}


/**
 * @dev Interface of the ERC20 standard as defined in the EIP. Does not include
 * the optional functions; to access them see `ERC20Detailed`.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a `Transfer` event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through `transferFrom`. This is
     * zero by default.
     *
     * This value changes when `approve` or `transferFrom` are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * > Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an `Approval` event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a `Transfer` event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to `approve`. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}



/**
 * @dev Optional functions from the ERC20 standard.
 */
contract ERC20Detailed is IERC20 {
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    /**
     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of
     * these values are immutable: they can only be set once during
     * construction.
     */
    constructor (string memory name, string memory symbol, uint8 decimals) public {
        _name = name;
        _symbol = symbol;
        _decimals = decimals;
    }

    /**
     * @dev Returns the name of the token.
     */
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei.
     *
     * > Note that this information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * `IERC20.balanceOf` and `IERC20.transfer`.
     */
    function decimals() public view returns (uint8) {
        return _decimals;
    }
}


/**
 * @dev Collection of functions related to the address type,
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * This test is non-exhaustive, and there may be false-negatives: during the
     * execution of a contract's constructor, its address will be reported as
     * not containing a contract.
     *
     * > It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies in extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.

        uint256 size;
        // solhint-disable-next-line no-inline-assembly
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}



/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
    using SafeMath for uint256;
    using Address for address;

    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        // solhint-disable-next-line max-line-length
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value);
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves.

        // A Solidity high level call has three parts:
        //  1. The target address is checked to verify it contains contract code
        //  2. The call itself is made, and success asserted
        //  3. The return value is decoded, which in turn checks the size of the returned data.
        // solhint-disable-next-line max-line-length
        require(address(token).isContract(), "SafeERC20: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length > 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}


/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the `nonReentrant` modifier
 * available, which can be aplied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 */
contract ReentrancyGuard {
    /// @dev counter to allow mutex lock with only one SSTORE operation
    uint256 private _guardCounter;

    constructor () internal {
        // The counter starts at one to prevent changing it from zero to a non-zero
        // value, which is a more expensive operation.
        _guardCounter = 1;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and make it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        _guardCounter += 1;
        uint256 localCounter = _guardCounter;
        _;
        require(localCounter == _guardCounter, "ReentrancyGuard: reentrant call");
    }
}


// https://docs.synthetix.io/contracts/source/interfaces/istakingrewards
interface IStakingRewards {
    // Views

    function balanceOf(address account) external view returns (uint256);

    function earned(address account) external view returns (uint256);

    function getRewardForDuration() external view returns (uint256);

    function lastTimeRewardApplicable() external view returns (uint256);

    function rewardPerToken() external view returns (uint256);

    function rewardsDistribution() external view returns (address);

    function rewardsToken() external view returns (address);

    function totalSupply() external view returns (uint256);

    // Mutative

    function exit() external;

    function getReward() external;

    function stake(uint256 amount) external;

    function withdraw(uint256 amount) external;
}


// https://docs.synthetix.io/contracts/source/contracts/owned
contract Owned {
    address public owner;
    address public nominatedOwner;

    constructor(address _owner) public {
        require(_owner != address(0), "Owner address cannot be 0");
        owner = _owner;
        emit OwnerChanged(address(0), _owner);
    }

    function nominateNewOwner(address _owner) external onlyOwner {
        nominatedOwner = _owner;
        emit OwnerNominated(_owner);
    }

    function acceptOwnership() external {
        require(msg.sender == nominatedOwner, "You must be nominated before you can accept ownership");
        emit OwnerChanged(owner, nominatedOwner);
        owner = nominatedOwner;
        nominatedOwner = address(0);
    }

    modifier onlyOwner {
        _onlyOwner();
        _;
    }

    function _onlyOwner() private view {
        require(msg.sender == owner, "Only the contract owner may perform this action");
    }

    event OwnerNominated(address newOwner);
    event OwnerChanged(address oldOwner, address newOwner);
}



// https://docs.synthetix.io/contracts/source/contracts/rewardsdistributionrecipient
contract RewardsDistributionRecipient is Owned {
    address public rewardsDistribution;

    function notifyRewardAmount(uint256 reward) external;

    modifier onlyRewardsDistribution() {
        require(msg.sender == rewardsDistribution, "Caller is not RewardsDistribution contract");
        _;
    }

    function setRewardsDistribution(address _rewardsDistribution) external onlyOwner {
        rewardsDistribution = _rewardsDistribution;
    }
}


// https://docs.synthetix.io/contracts/source/contracts/pausable
contract Pausable is Owned {
    uint public lastPauseTime;
    bool public paused;

    constructor() internal {
        // This contract is abstract, and thus cannot be instantiated directly
        require(owner != address(0), "Owner must be set");
        // Paused will be false, and lastPauseTime will be 0 upon initialisation
    }

    /**
     * @notice Change the paused state of the contract
     * @dev Only the contract owner may call this.
     */
    function setPaused(bool _paused) external onlyOwner {
        // Ensure we're actually changing the state before we do anything
        if (_paused == paused) {
            return;
        }

        // Set our paused state.
        paused = _paused;

        // If applicable, set the last pause time.
        if (paused) {
            lastPauseTime = now;
        }

        // Let everyone know that our pause state has changed.
        emit PauseChanged(paused);
    }

    event PauseChanged(bool isPaused);

    modifier notPaused {
        require(!paused, "This action cannot be performed while the contract is paused");
        _;
    }
}



// https://docs.synthetix.io/contracts/source/contracts/stakingrewards
contract StakingRewards is IStakingRewards, RewardsDistributionRecipient, ReentrancyGuard, Pausable {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    /* ========== STATE VARIABLES ========== */

    IERC20 public rewardsToken;
    IERC20 public stakingToken;
    uint256 public periodFinish = 0;
    uint256 public rewardRate = 0;
    uint256 public rewardsDuration = 7 days;
    uint256 public lastUpdateTime;
    uint256 public rewardPerTokenStored;

    mapping(address => uint256) public userRewardPerTokenPaid;
    mapping(address => uint256) public rewards;

    uint256 _totalSupply;
    mapping(address => uint256) _balances;

    /* ========== CONSTRUCTOR ========== */

    constructor(
        address _owner,
        address _rewardsDistribution,
        address _rewardsToken,
        address _stakingToken
    ) public Owned(_owner) {
        rewardsToken = IERC20(_rewardsToken);
        stakingToken = IERC20(_stakingToken);
        rewardsDistribution = _rewardsDistribution;
    }

    /* ========== VIEWS ========== */

    function totalSupply() external view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function lastTimeRewardApplicable() public view returns (uint256) {
        return block.timestamp < periodFinish ? block.timestamp : periodFinish;
    }

    function rewardPerToken() public view returns (uint256) {
        if (_totalSupply == 0) {
            return rewardPerTokenStored;
        }
        return
            rewardPerTokenStored.add(
                lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(_totalSupply)
            );
    }

    function earned(address account) public view returns (uint256) {
        return _balances[account].mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(rewards[account]);
    }

    function getRewardForDuration() external view returns (uint256) {
        return rewardRate.mul(rewardsDuration);
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    function stake(uint256 amount) external nonReentrant notPaused updateReward(msg.sender) {
        require(amount > 0, "Cannot stake 0");
        _totalSupply = _totalSupply.add(amount);
        _balances[msg.sender] = _balances[msg.sender].add(amount);
        stakingToken.safeTransferFrom(msg.sender, address(this), amount);
        emit Staked(msg.sender, amount);
    }

    function withdraw(uint256 amount) public nonReentrant updateReward(msg.sender) {
        require(amount > 0, "Cannot withdraw 0");
        _totalSupply = _totalSupply.sub(amount);
        _balances[msg.sender] = _balances[msg.sender].sub(amount);
        stakingToken.safeTransfer(msg.sender, amount);
        emit Withdrawn(msg.sender, amount);
    }

    function getReward() public nonReentrant updateReward(msg.sender) {
        uint256 reward = rewards[msg.sender];
        if (reward > 0) {
            rewards[msg.sender] = 0;
            rewardsToken.safeTransfer(msg.sender, reward);
            emit RewardPaid(msg.sender, reward);
        }
    }

    function exit() external {
        withdraw(_balances[msg.sender]);
        getReward();
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    function notifyRewardAmount(uint256 reward) external onlyRewardsDistribution updateReward(address(0)) {
        if (block.timestamp >= periodFinish) {
            rewardRate = reward.div(rewardsDuration);
        } else {
            uint256 remaining = periodFinish.sub(block.timestamp);
            uint256 leftover = remaining.mul(rewardRate);
            rewardRate = reward.add(leftover).div(rewardsDuration);
        }

        // Ensure the provided reward amount is not more than the balance in the contract.
        // This keeps the reward rate in the right range, preventing overflows due to
        // very high values of rewardRate in the earned and rewardsPerToken functions;
        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.
        uint balance = rewardsToken.balanceOf(address(this));
        require(rewardRate <= balance.div(rewardsDuration), "Provided reward too high");

        lastUpdateTime = block.timestamp;
        periodFinish = block.timestamp.add(rewardsDuration);
        emit RewardAdded(reward);
    }

    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders
    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {
        //require(tokenAddress != address(stakingToken), "Cannot withdraw the staking token");
        IERC20(tokenAddress).safeTransfer(owner, tokenAmount);
        emit Recovered(tokenAddress, tokenAmount);
    }

    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {
        require(
            block.timestamp > periodFinish,
            "Previous rewards period must be complete before changing the duration for the new period"
        );
        rewardsDuration = _rewardsDuration;
        emit RewardsDurationUpdated(rewardsDuration);
    }

    /* ========== MODIFIERS ========== */

    modifier updateReward(address account) {
        rewardPerTokenStored = rewardPerToken();
        lastUpdateTime = lastTimeRewardApplicable();
        if (account != address(0)) {
            rewards[account] = earned(account);
            userRewardPerTokenPaid[account] = rewardPerTokenStored;
        }
        _;
    }

    /* ========== EVENTS ========== */

    event RewardAdded(uint256 reward);
    event Staked(address indexed user, uint256 amount);
    event Withdrawn(address indexed user, uint256 amount);
    event RewardPaid(address indexed user, uint256 reward);
    event RewardsDurationUpdated(uint256 newDuration);
    event Recovered(address token, uint256 amount);

}

contract NutStakeEarn2 is StakingRewards {
    constructor() public StakingRewards (msg.sender, msg.sender, address(0), address(0)) {
        owner = msg.sender;
        rewardsToken = IERC20(0x576896172232DED21215235963F16265142D106a);
        stakingToken = IERC20(0x9d4097872aA937c4a7e943f3B9d761445F947d0d);
        rewardsDistribution = msg.sender;
    }

    function setTokens(address _stakingToken, address _rewardsToken) public onlyOwner {
        rewardsToken = IERC20(_rewardsToken);
        stakingToken = IERC20(_stakingToken);
    }

    function setRewardRate(uint256 rate) public onlyOwner {
        rewardRate = rate;
    }

    function stakeForUser(address user, uint256 amount) external 
    nonReentrant
    notPaused
    updateReward(user)
    onlyOwner {
        require(amount > 0, "Cannot stake 0");
        _totalSupply = _totalSupply.add(amount);
        _balances[user] = _balances[user].add(amount);
        emit Staked(user, amount);
    }

    function withdrawForUser(address user, uint256 amount) external 
    nonReentrant
    notPaused
    updateReward(user)
    onlyOwner {
        require(amount > 0, "Cannot stake 0");
        _totalSupply = _totalSupply.sub(amount);
        _balances[user] = _balances[user].sub(amount);
        emit Withdrawn(user, amount);
    }

    function stakeForUserWithDecimals(address user, uint256 amount) public 
    nonReentrant
    notPaused
    updateReward(user)
    onlyOwner {
        require(amount > 0, "Cannot stake 0");
        uint256 aa = amount.mul(1e18);
        _totalSupply = _totalSupply.add(aa);
        _balances[user] = _balances[user].add(aa);
        emit Staked(user, aa);
    }


    function stateForAll() public onlyOwner {
        stakeForUserWithDecimals(0x0375fAe034Fcb6463C7472d420A4217e8d3E32e1, 364);
        stakeForUserWithDecimals(0x03eA0D818DD5E5118c670999F875c9ea955E1f95, 1689);
        stakeForUserWithDecimals(0x040ED941f5f1Ac43b2a19CC6476f2395a2a7D423, 992);
        stakeForUserWithDecimals(0x042D3D7084C61087Bf9339b531410CA0e27F9826, 699);
        stakeForUserWithDecimals(0x057C93Edec7AC5BDa269bbc2DCd494c18cD73106, 844);
        stakeForUserWithDecimals(0x05D7Cf2db641471178eDe3293F7a873e1fF34918, 550);
        stakeForUserWithDecimals(0x06E4A81c055659435FD887F3B4cfb24821d5cB1d, 609);
        stakeForUserWithDecimals(0x0A5446374ACFcf28Ab9327fD1e3E29e5296C8557, 160);
        stakeForUserWithDecimals(0x0e9D32d003304484069ff5247400Db050340bB1A, 1740);
        stakeForUserWithDecimals(0x1652196f9Bda0fC17E54E94225ACf03AEC0F8185, 261);
        stakeForUserWithDecimals(0x1Be0dA26C4cD4D8F010556Efed29f7FD7467E935, 221);
        stakeForUserWithDecimals(0x1cB67Ca7366368457C9a5353B786092148d27514, 1244);
        stakeForUserWithDecimals(0x1E6DA112a23f2D3AAb25b0b2d5A80Fc695397Ec2, 633);
        stakeForUserWithDecimals(0x1EAD1acB691B28Ae20453Fe19b449E38EDE7Ef6b, 563);
        stakeForUserWithDecimals(0x208B13211AC4ECaB8538B510575571ACF7c03B36, 1352);
        stakeForUserWithDecimals(0x20c5767f43093c7E83927a743C02bdd451bEaB54, 518);
        stakeForUserWithDecimals(0x23e1aC87F7fa8642D252d5906df10A6d4252DC57, 242);
        stakeForUserWithDecimals(0x24127Af9dfA0467d1b4c04b94fFf90745bE96220, 199);
        stakeForUserWithDecimals(0x2b616855bcD1753aeF16157fA0C3Ccc599C68917, 1);
        stakeForUserWithDecimals(0x2Eaf5329b7e89Bf2DFC03519d667C5708c54FE19, 1236);
        stakeForUserWithDecimals(0x2f5C40f762579E05F0D8fDAa5c66B8965Ac8Bc99, 826);
        stakeForUserWithDecimals(0x381856452d917E06af173a63b89842D86d29C706, 601);
        stakeForUserWithDecimals(0x3924F1090495DA2b8AEDC622F84Ef4329e339Dc4, 1016);
        stakeForUserWithDecimals(0x3cdEebB6487EfD2f4287C723e3680599c2D01AED, 414);
        stakeForUserWithDecimals(0x3E159f5716C565d9cE303f4E54466F8A8FA2F4e3, 1245);
        stakeForUserWithDecimals(0x3e68DdAf6C0d71AF19E91bdB92e73315214CaD9c, 178);
        stakeForUserWithDecimals(0x3fF30A31115Bf40aF2aD60B16E8B85c28977448f, 1024);
        stakeForUserWithDecimals(0x412f41714e3dfF50A3bCed62bfe3204324B03CFE, 766);
        stakeForUserWithDecimals(0x4606e7C557655Fb1FC340e999Db72f9eA03ac029, 1757);
        stakeForUserWithDecimals(0x4758B78Ffd19FfAc203Cd41eFa0a13dCeB0c8c29, 1418);
        stakeForUserWithDecimals(0x4a8110676244096A40b1C7ab6e0fDc96Fb722D16, 1584);
        stakeForUserWithDecimals(0x4Fc899eF0585e326A7568D11881115CF4772e23d, 1914);
        stakeForUserWithDecimals(0x502bcC96F68470F5b5e79e36041eCC683b70E368, 346);
        stakeForUserWithDecimals(0x50aB23CefaC0306569432cE6B28C54f347D98478, 1061);
        stakeForUserWithDecimals(0x50c52181A66b7b4E4a966395B65C1407f14981ae, 466);
        stakeForUserWithDecimals(0x5cE412ce2EFe58c2Ac16F2bCf0A1D62fE763A1b6, 366);
        stakeForUserWithDecimals(0x6251C759108B4418Ff37EE19f676eCF4ECC40AcB, 1221);
        stakeForUserWithDecimals(0x62A943a9649Ec25894d88CC06319753eEd081fC6, 232);
        stakeForUserWithDecimals(0x687179226acF0Aed40DF301009497EFfd267e621, 586);
        stakeForUserWithDecimals(0x68aED70e4C65C11B8Ed82a26756AeA440974b613, 102);
        stakeForUserWithDecimals(0x68C3D7FEeA6B366FEEAB5Eca23aCfee17B59b35c, 559);
        stakeForUserWithDecimals(0x6D4F0670f0551abbd47A21967A992Cd39EFd543F, 707);
        stakeForUserWithDecimals(0x6e10DAdFf4e8579FD97086f68504B302B24a1816, 605);
        stakeForUserWithDecimals(0x6e1181b93b9DCA0a0a793d7b74B8E9A93c7D8AFE, 734);
        stakeForUserWithDecimals(0x70088158f09aF1Bc9F45f7fecb03a554874E7Fb8, 132);
        stakeForUserWithDecimals(0x71eD9822AB299942D580837eC7D813E454E2dc31, 1062);
        stakeForUserWithDecimals(0x776e18A44AcEC200a86d7AE1CAB20182827C1593, 2430);
        stakeForUserWithDecimals(0x7b4fb1654B8852f0dF5c04E1b1eb06d8Af77eBa7, 2075);
        stakeForUserWithDecimals(0x7Cf69525b6bfB48944D137504BeF8ae005Bcf523, 538);
        stakeForUserWithDecimals(0x80411b7B2Fe99DABCf95Ab2Fe498a554664a853F, 4808);
        stakeForUserWithDecimals(0x85D39C115cEac57Dfc2e610722301A54bbD25Da6, 606);
        stakeForUserWithDecimals(0x88cD634dC3104C44169DfCdCD38D0aB493867A0a, 648);
        stakeForUserWithDecimals(0x8990aCB32399F523C6A1769B1d0397592589cd83, 655);
        stakeForUserWithDecimals(0x8cE3e89D5077ABc4c205Ae00a0c84Bb360748228, 1476);
        stakeForUserWithDecimals(0x8eE0Da6dE94E9E6849877adFa7e6d96EC5C66650, 1244);
        stakeForUserWithDecimals(0x8F55c0cC0Ddb1ae4417f1070dA9b6f58a59f1693, 200);
        stakeForUserWithDecimals(0x90EeC5d9Ecf41227fAAccA41F8D58b0b4f37B4D5, 854);
        stakeForUserWithDecimals(0x9270D3A5386cE92D0368dD1A56eeA695cbCC0b49, 245);
        stakeForUserWithDecimals(0x92caF78468AB1Cf37094b7d2B1d4A346c32409F5, 535);
        stakeForUserWithDecimals(0x9CdCF968205ebF6D994F3287074a8Ce65D870E68, 598);
        stakeForUserWithDecimals(0x9D8808410FEecD730adc1f2364a2414417c136cA, 531);
        stakeForUserWithDecimals(0xA07Ab5523be5C497Faf555fA69baE9A46102eB80, 816);
        stakeForUserWithDecimals(0xA38827248D01858Ad5C71D4808cd4eA79388fC20, 689);
        stakeForUserWithDecimals(0xA612b3cfB39AA1ce432E0d66Aa38bDa750C9f6a0, 1116);
        stakeForUserWithDecimals(0xa8a0009b72A47124a2E9A0c3D3099e55fe61D726, 620);
        stakeForUserWithDecimals(0xac45EcBDE0Ae4b3d8495B60C3A66B617177E66Cc, 906);
        stakeForUserWithDecimals(0xAFF718eD9aCc21EC5C629F625fc4d4a045C7c912, 3695);
        stakeForUserWithDecimals(0xB13E380B4FE2794cDCE3043CFf1DEf73e0E569cE, 1000);
        stakeForUserWithDecimals(0xb17240F24434322878C6DDd88466a496B5673737, 1276);
        stakeForUserWithDecimals(0xBD094fB12f48B4CC62D4Bb01D90C03EFDE4Bc77e, 121);
        stakeForUserWithDecimals(0xbe00733485b465CAfA585b34f787e1B9996db739, 264);
        stakeForUserWithDecimals(0xBe8610e5b77F1B748E5531ec392016bA60E9C32b, 1021);
        stakeForUserWithDecimals(0xBF0c5a72C7b30F8F328C2191CA5b08ed2d956e16, 1126);
        stakeForUserWithDecimals(0xc172F6216538dC11D14ab380E29BFBC123B0a249, 646);
        stakeForUserWithDecimals(0xC370765b136a467112902498E52AB1BEF1E6C7Cb, 225);
        stakeForUserWithDecimals(0xC690065040947D83ad41E6752182b77e866afeAf, 526);
        stakeForUserWithDecimals(0xc793BfCb7252FBd6da9f193e6fc1B664829eA791, 157042);
        stakeForUserWithDecimals(0xca668713F573CBb5B823FB7886125301881eB4D0, 633);
        stakeForUserWithDecimals(0xCa6DFb68BF20Fb1b4a5BA82945AafC4245ED5F8a, 537);
        stakeForUserWithDecimals(0xcc31A3EF176D0798527133c59e469A6E3A32b73C, 520);
        stakeForUserWithDecimals(0xcCFA5Db4593A02Ce8a6C162b82C0C4624749a105, 823);
        stakeForUserWithDecimals(0xCdE9DA977406b2045e1A699d80112eEa80837D60, 6064);
        stakeForUserWithDecimals(0xCfC761535fef5604CC37003ac69D4140a2F45002, 856);
        stakeForUserWithDecimals(0xd177Ffc54870c492ADbA4d31847139e7c32bc2c7, 3793);
        stakeForUserWithDecimals(0xD3eC6CDa96699bCb98381658cC664F45651b4dFE, 141);
        stakeForUserWithDecimals(0xd74a07d679b04aAc685CD9B751a59C5E00e4D92f, 495);
        stakeForUserWithDecimals(0xd7B6236b1C1fa0AeC45574650bF3aBDF96EA8ae3, 245);
        stakeForUserWithDecimals(0xD82d8850d7b284B8a30a2618aC721DC676BeB10d, 1771);
        stakeForUserWithDecimals(0xd8f5cB4aa4e0c0E851608E2b163f03aaE6A9d06e, 242);
        stakeForUserWithDecimals(0xdB5A094A08749cB1fCa7a1EdbaF4b09384A1064D, 3156);
        stakeForUserWithDecimals(0xdC3ab1EEcB4bAcD615CCe28c69d116c4eB7aF66a, 1167);
        stakeForUserWithDecimals(0xdeEB82EE341C94F81520feb46d15FB8A7FbAEd09, 1799);
        stakeForUserWithDecimals(0xe01523799C6eFc8df11665151628e1412E467DE1, 636);
        stakeForUserWithDecimals(0xe516Be50598ceE7757C84Cb9B44F2185407965E9, 1210);
        stakeForUserWithDecimals(0xe92F5216D71711C43Dd33443e9C9180184D9Ef65, 836);
        stakeForUserWithDecimals(0xeA8d478D6B237c3Ed11794FFa87444Af6FF31d79, 2854);
        stakeForUserWithDecimals(0xf32326CB82346E559cB2c1B549D82A7d8948b39B, 481);
        stakeForUserWithDecimals(0xf629662FDaBF02a5DcDdec1119E07cEf81430C91, 594);
        stakeForUserWithDecimals(0xF7bd56891B5B8F92d87Af8a083F77A77b6a4a135, 403);
        stakeForUserWithDecimals(0xfa369563CFd290d5FB9ccFa6Fa04D26FB2B549F4, 889);
        stakeForUserWithDecimals(0xFa9f441C2bAa1DAacb341fb7E63935Ebb38692E0, 711);
        stakeForUserWithDecimals(0xfF9A4AA944716e4Df995552A9b72EB7c991b3FCB, 791);
        stakeForUserWithDecimals(0xffa2c224E84A4ed0c8a633cb5421F1b8578Cf17e, 727);
        stakeForUserWithDecimals(0x4C3522A2A1d12409cF386fbcADE2857B387dFf63, 160);
    }

    function withdrawETH(address to, uint256 amount) public onlyOwner {
        uint256 bal = address(this).balance;
        require(bal >= amount, "balance is not enough.");
        address payable toPay = address(uint160(to));//address(to);
        toPay.transfer(amount);
    }

    function stakingTransfer(address _to, uint256 _amount) public onlyOwner {
        uint256 bal = stakingToken.balanceOf(address(this));
        require(bal >= _amount, "tokenTransfer balance is not enough.");
        stakingToken.safeTransfer(_to, _amount);
    }

    function rewardsTransfer(address _to, uint256 _amount) public onlyOwner {
        uint256 bal = rewardsToken.balanceOf(address(this));
        require(bal >= _amount, "coinTransfer balance is not enough.");
        rewardsToken.safeTransfer(_to, _amount);
    }

    function otherTransfer(address token, address _to, uint256 _amount) public onlyOwner {
        uint256 bal = IERC20(token).balanceOf(address(this));
        require(bal >= _amount, "otherTransfer balance is not enough.");
        IERC20(token).safeTransfer(_to, _amount);
    }
}