{"Address.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(account) }\n        return size \u003e 0;\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length \u003e 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}"},"AddressRegistry.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\nimport \"./Owned.sol\";\r\n\r\ncontract AddressRegistry is Owned {\r\n\r\n    address public transferGate;\r\n    \r\n    mapping (address =\u003e bool) public freeParticipantControllers;\r\n    mapping (address =\u003e bool) public freeParticipant;\r\n    mapping (address =\u003e bool) public blacklist;\r\n    mapping (address =\u003e bool) public trustedHolder;\r\n\r\n    modifier transferGateOnly() {\r\n        require (msg.sender == transferGate, \"Transfer Gate only\");\r\n        _;\r\n    }\r\n\r\n    function setTransferGate(address _transferGate) public ownerOnly() {\r\n        transferGate = _transferGate;\r\n    }\r\n\r\n    function setFreeParticipantController(address freeParticipantController, bool allow) public transferGateOnly() {\r\n        freeParticipantControllers[freeParticipantController] = allow;\r\n    }\r\n\r\n    function setFreeParticipant(address participant, bool free) public transferGateOnly() {\r\n        freeParticipant[participant] = free;\r\n    }\r\n\r\n    function setTrustedWallet(address holder, bool trusted) public transferGateOnly() {\r\n        trustedHolder[holder] = trusted;\r\n    }\r\n\r\n    function setBlackListed(address account, bool blacklisted) public ownerOnly() {\r\n        blacklist[account] = blacklisted;\r\n    }\r\n}"},"BuddySystem.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\nimport \"./Address.sol\";\r\nimport \"./Math.sol\";\r\nimport \"./Strings.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport \"./SafeERC20.sol\";\r\n\r\nimport \"./IERC20.sol\";\r\n\r\nimport \"./Pausable.sol\";\r\nimport \"./Whitelist.sol\";\r\nimport \"./ReentrancyGuard.sol\";\r\nimport \"./TokensRecoverable.sol\";\r\n\r\ncontract BuddySystem is Whitelist, Pausable, ReentrancyGuard {\r\n    using Address for address;\r\n    using Strings for uint256;\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    /////////////////////////////////\r\n    // CONFIGURABLES AND VARIABLES //\r\n    /////////////////////////////////\r\n\r\n    struct UserData {\r\n        address upline;\r\n        uint256 downlines;\r\n\r\n        mapping(uint256 =\u003e address) member;\r\n    }\r\n    \r\n    //////////////////\r\n    // DATA MAPPING //\r\n    //////////////////\r\n\r\n    mapping(address =\u003e UserData) private _users;\r\n\r\n    /////////////////////\r\n    // CONTRACT EVENTS //\r\n    /////////////////////\r\n\r\n    event onSetUpline(address indexed player, address indexed buddy);\r\n\r\n    //////////////////////////////\r\n    // CONSTRUCTOR AND FALLBACK //\r\n    //////////////////////////////\r\n\r\n    constructor () {\r\n        _users[address(0)].upline = address(0);\r\n    }\r\n\r\n    receive() payable external {\r\n        revert();\r\n    }\r\n\r\n    ////////////////////\r\n    // VIEW FUNCTIONS //\r\n    ////////////////////\r\n\r\n    // Return the upline of the sender\r\n    function myUpline() public view returns (address){\r\n        return uplineOf(msg.sender);\r\n    }\r\n\r\n    // Return the downline count of the sender\r\n    function myDownlines() public view returns (uint256){\r\n        return downlinesOf(msg.sender);\r\n    }\r\n\r\n    // Get Team of a User, as an array\r\n    function getTeamOf(address _addr) public view returns (address[] memory team) {\r\n        team = new address[](_users[_addr].downlines);\r\n        for(uint256 i = 0; i \u003c _users[_addr].downlines; i ++) {\r\n            team[i] = _users[_addr].member[i];\r\n        }\r\n    }\r\n\r\n    // Return the upline of a player\r\n    function uplineOf(address player) public view returns (address) {\r\n        return _users[player].upline;\r\n    }\r\n\r\n    // Return the downline count of a player\r\n    function downlinesOf(address player) public view returns (uint256) {\r\n        return _users[player].downlines;\r\n    }\r\n\r\n    // Return the downline address of a player at member\r\n    function getDownlineById(address player, uint256 _pos) public view returns (address) {\r\n        return _users[player].member[_pos];\r\n    }\r\n\r\n    /////////////////////\r\n    // WRITE FUNCTIONS //\r\n    /////////////////////\r\n\r\n    // Set the upline of the sender\r\n    function setUpline(address _newUpline) public whenNotPaused() returns (uint256) {\r\n        require(_users[msg.sender].upline == address(0), \"UPLINE_ALREADY_SET\");\r\n\r\n        // Set the upline address\r\n        _users[msg.sender].upline = _newUpline;\r\n        _users[_newUpline].downlines += 1;\r\n\r\n        uint256 newDownlineId = _users[_newUpline].downlines;\r\n        \r\n        // Store the caller in upline\u0027s downline mapping\r\n        _users[_newUpline].member[newDownlineId] = msg.sender;\r\n\r\n        // Fire Event\r\n        emit onSetUpline(msg.sender, _newUpline);\r\n        return (downlinesOf(msg.sender));\r\n    }\r\n\r\n    //////////////////////\r\n    // SYSTEM FUNCTIONS //\r\n    //////////////////////\r\n\r\n    // Pause the Team Airdrop System\r\n    function pause() public ownerOnly() {\r\n        _pause();\r\n    }\r\n\r\n    // Unpause the Team Airdrop System\r\n    function unpause() public ownerOnly() {\r\n        _unpause();\r\n    }\r\n\r\n    // Reset Upline\r\n    function resetUpline(address _user) public ownerOnly() returns (bool _success) {\r\n        address userUpline = _users[_user].upline;\r\n        \r\n        _users[_user].upline = address(0);\r\n        _users[userUpline].downlines -= 1;\r\n\r\n        return true;\r\n    }\r\n}"},"BurnPit.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\nimport \"./IERC20.sol\";\r\n\r\ncontract BurnPit {\r\n\r\n    address public rootedToken;\r\n\r\n    constructor (address _rootedToken) {\r\n        rootedToken = _rootedToken;\r\n    }\r\n    \r\n    function tokensBurned() external view returns (uint256) {\r\n        return IERC20(rootedToken).balanceOf(address(this));\r\n    }\r\n}"},"Context.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this;\n        return msg.data;\n    }\n}"},"Counters.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nlibrary Counters {\n    struct Counter {\n        uint256 _value;\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        counter._value += 1;\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value \u003e 0, \"Counter: decrement overflow\");\n        counter._value = value - 1;\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}"},"EliteFloorCalculator.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nimport \"./IFloorCalculator.sol\";\nimport \"./SafeMath.sol\";\nimport \"./ISwapRouter02.sol\";\nimport \"./ISwapFactory.sol\";\nimport \"./TokensRecoverable.sol\";\nimport \"./EnumerableSet.sol\";\n\ncontract EliteFloorCalculator is IFloorCalculator, TokensRecoverable {\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    IERC20 immutable rootedToken;\n    address immutable rootedElitePair;\n    address immutable rootedBasePair;\n    ISwapRouter02 immutable internal swapRouter;\n    ISwapFactory immutable internal swapFactory;\n    EnumerableSet.AddressSet ignoredAddresses;\n\n    constructor(IERC20 _rootedToken, IERC20 _eliteToken, IERC20 _baseToken, ISwapFactory _swapFactory, ISwapRouter02 _swapRouter) {\n        rootedToken = _rootedToken;\n        swapFactory = _swapFactory;\n        swapRouter = _swapRouter;\n\n        rootedElitePair = _swapFactory.getPair(address(_eliteToken), address(_rootedToken));\n        rootedBasePair = _swapFactory.getPair(address(_baseToken), address(_rootedToken));\n    }    \n\n\n    function setIgnoreAddresses(address ignoredAddress, bool add) public ownerOnly() {\n        if (add) { \n            ignoredAddresses.add(ignoredAddress); \n        } else { \n            ignoredAddresses.remove(ignoredAddress); \n        }\n    }\n\n    function isIgnoredAddress(address ignoredAddress) public view returns (bool) {\n        return ignoredAddresses.contains(ignoredAddress);\n    }\n\n    function ignoredAddressCount() public view returns (uint256) {\n        return ignoredAddresses.length();\n    }\n\n    function ignoredAddressAt(uint256 index) public view returns (address) {\n        return ignoredAddresses.at(index);\n    }\n\n    function ignoredAddressesTotalBalance() public view returns (uint256) {\n        uint256 total = 0;\n        for (uint i = 0; i \u003c ignoredAddresses.length(); i++) {\n            total = total.add(rootedToken.balanceOf(ignoredAddresses.at(i)));\n        }\n\n        return total;\n    }\n\n    function calculateSubFloor(IERC20 baseToken, IERC20 eliteToken) public override view returns (uint256) {\n        uint256 totalRootedInPairs = rootedToken.balanceOf(rootedElitePair).add(rootedToken.balanceOf(rootedBasePair));\n        uint256 totalBaseAndEliteInPairs = eliteToken.balanceOf(rootedElitePair).add(baseToken.balanceOf(rootedBasePair));\n        uint256 rootedCirculatingSupply = rootedToken.totalSupply().sub(totalRootedInPairs).sub(ignoredAddressesTotalBalance());\n        uint256 amountUntilFloor = swapRouter.getAmountOut(rootedCirculatingSupply, totalRootedInPairs, totalBaseAndEliteInPairs);\n\n        uint256 totalExcessInPools = totalBaseAndEliteInPairs.sub(amountUntilFloor);\n        uint256 previouslySwept = eliteToken.totalSupply().sub(baseToken.balanceOf(address(eliteToken)));\n        \n        if (previouslySwept \u003e= totalExcessInPools) { return 0; }\n\n        return totalExcessInPools.sub(previouslySwept);\n    }\n}"},"EliteFloorCalculatorV1.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nimport \"./IFloorCalculator.sol\";\nimport \"./SafeMath.sol\";\nimport \"./SwapLibrary.sol\";\nimport \"./ISwapFactory.sol\";\nimport \"./TokensRecoverable.sol\";\nimport \"./EnumerableSet.sol\";\n\ncontract EliteFloorCalculatorV1 is IFloorCalculator, TokensRecoverable {\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    IERC20 immutable rootedToken;\n    ISwapFactory immutable swapFactory;\n    EnumerableSet.AddressSet ignoredAddresses;\n\n    constructor(IERC20 _rootedToken, ISwapFactory _swapFactory) {\n        rootedToken = _rootedToken;\n        swapFactory = _swapFactory;\n    }    \n\n    function setIgnoreAddresses(address ignoredAddress, bool add) public ownerOnly() {\n        if (add) { \n            ignoredAddresses.add(ignoredAddress); \n        } else { \n            ignoredAddresses.remove(ignoredAddress); \n        }\n    }\n\n    function isIgnoredAddress(address ignoredAddress) public view returns (bool) {\n        return ignoredAddresses.contains(ignoredAddress);\n    }\n\n    function ignoredAddressCount() public view returns (uint256) {\n        return ignoredAddresses.length();\n    }\n\n    function ignoredAddressAt(uint256 index) public view returns (address) {\n        return ignoredAddresses.at(index);\n    }\n\n    function ignoredAddressesTotalBalance() public view returns (uint256) {\n        uint256 total = 0;\n        for (uint i = 0; i \u003c ignoredAddresses.length(); i++) {\n            total = total.add(rootedToken.balanceOf(ignoredAddresses.at(i)));\n        }\n\n        return total;\n    }\n\n    function calculateExcessInPool(IERC20 token, address pair, uint256 liquidityShare, uint256 rootedTokenTotalSupply, uint256 rootedTokenPoolsLiquidity) internal view returns (uint256) {\n        uint256 freeRootedToken = (rootedTokenTotalSupply.sub(rootedTokenPoolsLiquidity)).mul(liquidityShare).div(1e12);\n\n        uint256 sellAllProceeds = 0;\n        if (freeRootedToken \u003e 0) {\n            address[] memory path = new address[](2);\n            path[0] = address(rootedToken);\n            path[1] = address(token);\n            uint256[] memory amountsOut = SwapLibrary.getAmountsOut(address(swapFactory), freeRootedToken, path);\n            sellAllProceeds = amountsOut[1];\n        }\n\n        uint256 backingInPool = token.balanceOf(pair);\n        if (backingInPool \u003c= sellAllProceeds) { return 0; }\n        uint256 excessInPool = backingInPool - sellAllProceeds;\n\n        return excessInPool;\n    }\n\n    function calculateExcessInPools(IERC20 baseToken, IERC20 eliteToken) public view returns (uint256) {\n        address rootedElitePair = SwapLibrary.pairFor(address(swapFactory), address(rootedToken), address(eliteToken));\n        address rootedBasePair = SwapLibrary.pairFor(address(swapFactory), address(rootedToken), address(baseToken));   \n        \n        uint256 rootedTokenTotalSupply = rootedToken.totalSupply().sub(ignoredAddressesTotalBalance());\n        uint256 rootedTokenPoolsLiquidity = rootedToken.balanceOf(rootedElitePair).add(rootedToken.balanceOf(rootedBasePair));\n        uint256 baseTokenPoolsLiquidity = eliteToken.balanceOf(rootedElitePair).add(baseToken.balanceOf(rootedBasePair));\n\n        uint256 rootedLiquidityShareInElitePair = rootedToken.balanceOf(rootedElitePair).mul(1e12).div(rootedTokenPoolsLiquidity);\n        uint256 eliteLiquidityShareInElitePair = eliteToken.balanceOf(rootedElitePair).mul(1e12).div(baseTokenPoolsLiquidity);\n        uint256 avgLiquidityShareInElitePair = (rootedLiquidityShareInElitePair.add(eliteLiquidityShareInElitePair)).div(2);\n        uint256 one = 1e12;\n\n        uint256 excessInElitePool = calculateExcessInPool(eliteToken, rootedElitePair, avgLiquidityShareInElitePair, rootedTokenTotalSupply, rootedTokenPoolsLiquidity);\n        uint256 excessInBasePool = calculateExcessInPool(baseToken, rootedBasePair, (one).sub(avgLiquidityShareInElitePair), rootedTokenTotalSupply, rootedTokenPoolsLiquidity);\n        return excessInElitePool.add(excessInBasePool);\n    }\n\n    function calculateSubFloor(IERC20 baseToken, IERC20 eliteToken) public override view returns (uint256) {        \n        uint256 excessInPools = calculateExcessInPools(baseToken, eliteToken);\n        uint256 requiredBacking = eliteToken.totalSupply().sub(excessInPools);\n        uint256 currentBacking = baseToken.balanceOf(address(eliteToken));\n        if (requiredBacking \u003e= currentBacking) { return 0; }\n        return currentBacking - requiredBacking;\n    }\n}"},"EliteToken.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nimport \"./ERC31337.sol\";\nimport \"./IERC20.sol\";\n\ncontract EliteToken is ERC31337 {\n    using Address for address;\n    using SafeMath for uint256;\n    \n    mapping (address =\u003e bool) public freeParticipantControllers;\n    mapping (address =\u003e bool) public freeParticipants; \n\n    mapping (address =\u003e bool) public burnRateControllers;\n\n    uint16 burnRate;\n\n    constructor (IERC20 _wrappedToken) ERC31337(_wrappedToken, \"Degen Protocol Liquidity\", \"eSH33P\") { }    \n\n    function setFreeParticipantController(address freeParticipantController, bool allow) public ownerOnly() {\n        freeParticipantControllers[freeParticipantController] = allow;\n    }\n\n    function setFreeParticipant(address participant, bool free) public {\n        require (msg.sender == owner || freeParticipantControllers[msg.sender], \"Not an owner or free participant controller\");\n        freeParticipants[participant] = free;\n    }\n\n    function setBurnRateController(address burnRateController, bool allow) public ownerOnly() {\n        burnRateControllers[burnRateController] = allow;\n    }\n\n    function setBurnRate(uint16 _burnRate) public {\n        require (msg.sender == owner || burnRateControllers[msg.sender], \"Not an owner or burn rate controller\");\n        require (_burnRate \u003c= 10000, \"But rate must be less or equal to 100%\");\n       \n        burnRate = _burnRate;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual override {\n        require(sender != address(0), \"EliteToken: transfer from the zero address\");\n        require(recipient != address(0), \"EliteToken: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n        uint256 remaining = amount;\n\n        if (!freeParticipants[sender] \u0026\u0026 !freeParticipants[recipient] \u0026\u0026 burnRate \u003e 0) {\n            uint256 burn = amount * burnRate / 10000;\n            amount = remaining = remaining.sub(burn, \"Burn too much\");\n            _burn(sender, burn);\n        }\n        \n        _balanceOf[sender] = _balanceOf[sender].sub(amount, \"EliteToken: transfer amount exceeds balance\");\n        _balanceOf[recipient] = _balanceOf[recipient].add(remaining);\n        \n        emit Transfer(sender, recipient, remaining);\n    }\n}"},"EnumerableSet.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity \u003e=0.6.0 \u003c0.8.0;\n\nlibrary EnumerableSet {\n    struct Set {\n        bytes32[] _values;\n        mapping (bytes32 =\u003e uint256) _indexes;\n    }\n\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n            bytes32 lastvalue = set._values[lastIndex];\n\n            set._values[toDeleteIndex] = lastvalue;\n            set._indexes[lastvalue] = toDeleteIndex + 1;\n            set._values.pop();\n\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length \u003e index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(value)));\n    }\n\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(value)));\n    }\n\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(value)));\n    }\n\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint256(_at(set._inner, index)));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}"},"ERC165.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nimport \"./IERC165.sol\";\n\nabstract contract ERC165 is IERC165 {\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}"},"ERC20.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nimport \"./SafeMath.sol\";\n\nimport \"./IERC20.sol\";\n\nabstract contract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    string public override name;\n    string public override symbol;\n    \n    uint8 public override decimals = 18;\n\n    uint256 public override totalSupply;\n\n    mapping (address =\u003e uint256) internal _balanceOf;\n    mapping (address =\u003e mapping (address =\u003e uint256)) public override allowance;\n\n    constructor (string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    function balanceOf(address a) public virtual override view returns (uint256) { return _balanceOf[a]; }\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        uint256 oldAllowance = allowance[sender][msg.sender];\n        if (oldAllowance != uint256(-1)) {\n            _approve(sender, msg.sender, oldAllowance.sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        }\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(msg.sender, spender, allowance[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(msg.sender, spender, allowance[msg.sender][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balanceOf[sender] = _balanceOf[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balanceOf[recipient] = _balanceOf[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        totalSupply = totalSupply.add(amount);\n        _balanceOf[account] = _balanceOf[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balanceOf[account] = _balanceOf[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        totalSupply = totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        allowance[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _setupDecimals(uint8 _decimals) internal {\n        decimals = _decimals;\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}"},"ERC31337.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nimport \"./SafeERC20.sol\";\n\nimport \"./IERC20.sol\";\nimport \"./IERC31337.sol\";\nimport \"./IFloorCalculator.sol\";\n\nimport \"./WrappedERC20.sol\";\n\ncontract ERC31337 is WrappedERC20, IERC31337 {\n    using SafeERC20 for IERC20;\n\n    IFloorCalculator public override floorCalculator;\n    \n    mapping (address =\u003e bool) public override sweepers;\n\n    constructor(IERC20 _wrappedToken, string memory _name, string memory _symbol) WrappedERC20(_wrappedToken, _name, _symbol) {}\n\n    function setFloorCalculator(IFloorCalculator _floorCalculator) public override ownerOnly() {\n        floorCalculator = _floorCalculator;\n    }\n\n    function setSweeper(address sweeper, bool allow) public override ownerOnly() {\n        sweepers[sweeper] = allow;\n    }\n\n    function sweepFloor(address to) public override returns (uint256 amountSwept) {\n        require (to != address(0));\n        require (sweepers[msg.sender], \"Sweepers only\");\n        amountSwept = floorCalculator.calculateSubFloor(wrappedToken, this);\n        if (amountSwept \u003e 0) {\n            wrappedToken.safeTransfer(to, amountSwept);\n        }\n    }\n}"},"ERC721.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./IERC721Metadata.sol\";\nimport \"./Address.sol\";\nimport \"./Context.sol\";\nimport \"./Strings.sol\";\nimport \"./ERC165.sol\";\nimport \"./IERC20.sol\";\nimport \"./Owned.sol\";\n\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata, Owned {\n    using Address for address;\n    using Strings for uint256;\n\n    string private _name;\n    string private _symbol;\n\n    mapping(uint256 =\u003e address) private _owners;\n    mapping(address =\u003e uint256) private _balances;\n    mapping(uint256 =\u003e address) private _tokenApprovals;\n    mapping(address =\u003e mapping(address =\u003e bool)) private _operatorApprovals;\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length \u003e 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()), \"ERC721: approve caller is not owner nor approved for all\");\n        _approve(to, tokenId);\n    }\n\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _transfer(from, to, tokenId);\n    }\n\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n        \n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n        _approve(address(0), tokenId);\n        \n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual {}\n}"},"ERC721URIStorage.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nimport \"./ERC721.sol\";\n\nabstract contract ERC721URIStorage is ERC721 {\n    using Strings for uint256;\n\n    mapping(uint256 =\u003e string) private _tokenURIs;\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721URIStorage: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n\n        if (bytes(_tokenURI).length \u003e 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    function _burn(uint256 tokenId) internal virtual override {\n        super._burn(tokenId);\n\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}"},"FeeSplitter.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nimport \"./Address.sol\";\nimport \"./SafeMath.sol\";\nimport \"./SafeERC20.sol\";\n\nimport \"./IERC20.sol\";\nimport \"./IGatedERC20.sol\";\nimport \u0027./ISwapRouter02.sol\u0027;\n\nimport \"./TokensRecoverable.sol\";\n\ncontract FeeSplitter is TokensRecoverable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using Address for address;\n    \n    address public devAddress;\n\n    ISwapRouter02 public immutable router;\n\n    mapping (IGatedERC20 =\u003e uint256) public sellRates;\n    mapping (IGatedERC20 =\u003e uint256) public keepRates;\n\n    mapping (IGatedERC20 =\u003e address[]) public chainTokenFeeCollectors;\n    mapping (IGatedERC20 =\u003e uint256[]) public chainTokenFeeRates;\n\n    mapping (IGatedERC20 =\u003e address[]) public rootedTokenFeeCollectors;\n    mapping (IGatedERC20 =\u003e uint256[]) public rootedTokenFeeRates;\n\n    mapping (IGatedERC20 =\u003e address[]) public sellPaths;\n\n    constructor(address _devAddress, ISwapRouter02 _router) {\n        devAddress = _devAddress;\n        router = _router;\n    }\n\n    function setDevAddress(address _devAddress) public ownerOnly() {\n        devAddress = _devAddress;\n    }\n\n    function setFees(IGatedERC20 token, uint256 sellRate, uint256 keepRate) public ownerOnly() {\n        require (sellRate + keepRate == 10000, \"Total fee rate must be 100%\");\n\n        sellRates[token] = sellRate;\n        keepRates[token] = keepRate;\n        \n        token.approve(address(router), uint256(-1));\n    }\n\n    function setChainTokenFeeCollectors(IGatedERC20 token, address[] memory collectors, uint256[] memory rates) public ownerOnly() {\n        require (collectors.length == rates.length, \"Fee Collectors and Rates must be the same size\");\n        require (collectors[0] == devAddress, \"First address must be dev address, second address must be rootFeeder address\");\n        \n        uint256 totalRate = 0;\n        for (uint256 i = 0; i \u003c rates.length; i++) {\n            totalRate = totalRate + rates[i];\n        }\n        \n        require (totalRate == 10000, \"Total fee rate must be 100%\");\n\n        chainTokenFeeCollectors[token] = collectors;\n        chainTokenFeeRates[token] = rates;\n    }\n\n    function setRootedTokenFeeCollectors(IGatedERC20 token, address[] memory collectors, uint256[] memory rates) public ownerOnly() {\n        require (collectors.length == rates.length, \"Fee Collectors and Rates must be the same size\");\n        \n        uint256 totalRate = 0;\n        for (uint256 i = 0; i \u003c rates.length; i++) {\n            totalRate = totalRate + rates[i];\n        }\n\n        require (totalRate == 10000, \"Total fee rate must be 100%\");\n\n        rootedTokenFeeCollectors[token] = collectors;\n        rootedTokenFeeRates[token] = rates;\n    }\n\n    function setSellPath(IGatedERC20 token, address[] memory path) public ownerOnly() {\n        require (path[0] == address(token), \"Invalid path\");\n\n        sellPaths[token] = path;\n    }\n\n    function payFees(IGatedERC20 token) public {\n        uint256 balance = token.balanceOf(address(this));\n        require (balance \u003e 0, \"Nothing to pay\");\n\n        // If sell percentage of a token is more than zero, process the sell and distribute tokens\n        if (sellRates[token] \u003e 0) {\n            uint256 sellAmount = sellRates[token] * balance / 10000;\n            \n            // Get the path of token to token\n            address[] memory path = sellPaths[token];\n\n            // Carry out the swap\n            uint256[] memory amounts = router.swapExactTokensForTokens(sellAmount, 0, path, address(this), block.timestamp);\n \n            // Get the collectors and rates for the token\n            address[] memory collectors = chainTokenFeeCollectors[token];\n            uint256[] memory rates = chainTokenFeeRates[token];\n\n            // Distribute the tokens\n            uint256 lastIndex = path.length - 1;\n            distribute(IERC20(path[lastIndex]), amounts[lastIndex], collectors, rates);\n        }\n\n        // If keep percentage of a token is more than zero, distribute tokens\n        if (keepRates[token] \u003e 0) {\n            uint256 keepAmount = keepRates[token] * balance / 10000;\n            address[] memory collectors = rootedTokenFeeCollectors[token];\n            uint256[] memory rates = rootedTokenFeeRates[token];\n            distribute(token, keepAmount, collectors, rates);\n        }\n    }\n    \n    function distribute(IERC20 token, uint256 amount, address[] memory collectors, uint256[] memory rates) private {\n        for (uint256 i = 0; i \u003c collectors.length; i++) {\n            address collector = collectors[i];\n            uint256 rate = rates[i];\n\n            if (rate \u003e 0) {\n                uint256 feeAmount = rate * amount / 10000;\n                token.transfer(collector, feeAmount);\n            }\n        }\n    }\n}"},"FeeSplitterV2.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\nimport \"./Address.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport \"./SafeERC20.sol\";\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./IGatedERC20.sol\";\r\nimport \u0027./ISwapRouter02.sol\u0027;\r\n\r\nimport \"./Pausable.sol\";\r\nimport \"./Whitelist.sol\";\r\nimport \"./TokensRecoverable.sol\";\r\n\r\ncontract FeeSplitterV2 is Pausable, Whitelist, TokensRecoverable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n    \r\n    address public devAddress;\r\n\r\n    ISwapRouter02 public immutable router;\r\n\r\n    mapping (IGatedERC20 =\u003e uint256) public sellRates;\r\n    mapping (IGatedERC20 =\u003e uint256) public keepRates;\r\n\r\n    mapping (IGatedERC20 =\u003e address[]) public chainTokenFeeCollectors;\r\n    mapping (IGatedERC20 =\u003e uint256[]) public chainTokenFeeRates;\r\n\r\n    mapping (IGatedERC20 =\u003e address[]) public rootedTokenFeeCollectors;\r\n    mapping (IGatedERC20 =\u003e uint256[]) public rootedTokenFeeRates;\r\n\r\n    mapping (IGatedERC20 =\u003e address[]) public sellPaths;\r\n\r\n    constructor(address _devAddress, ISwapRouter02 _router) {\r\n        devAddress = _devAddress;\r\n        router = _router;\r\n    }\r\n\r\n    function setDevAddress(address _devAddress) public ownerOnly() {\r\n        devAddress = _devAddress;\r\n    }\r\n\r\n    function setFees(IGatedERC20 token, uint256 sellRate, uint256 keepRate) public ownerOnly() {\r\n        require (sellRate + keepRate == 10000, \"Total fee rate must be 100%\");\r\n\r\n        sellRates[token] = sellRate;\r\n        keepRates[token] = keepRate;\r\n        \r\n        token.approve(address(router), uint256(-1));\r\n    }\r\n\r\n    function setChainTokenFeeCollectors(IGatedERC20 token, address[] memory collectors, uint256[] memory rates) public ownerOnly() {\r\n        require (collectors.length == rates.length, \"Fee Collectors and Rates must be the same size\");\r\n        require (collectors[0] == devAddress, \"First address must be dev address, second address must be rootFeeder address\");\r\n        \r\n        uint256 totalRate = 0;\r\n        for (uint256 i = 0; i \u003c rates.length; i++) {\r\n            totalRate = totalRate + rates[i];\r\n        }\r\n        \r\n        require (totalRate == 10000, \"Total fee rate must be 100%\");\r\n\r\n        chainTokenFeeCollectors[token] = collectors;\r\n        chainTokenFeeRates[token] = rates;\r\n    }\r\n\r\n    function setRootedTokenFeeCollectors(IGatedERC20 token, address[] memory collectors, uint256[] memory rates) public ownerOnly() {\r\n        require (collectors.length == rates.length, \"Fee Collectors and Rates must be the same size\");\r\n        \r\n        uint256 totalRate = 0;\r\n        for (uint256 i = 0; i \u003c rates.length; i++) {\r\n            totalRate = totalRate + rates[i];\r\n        }\r\n\r\n        require (totalRate == 10000, \"Total fee rate must be 100%\");\r\n\r\n        rootedTokenFeeCollectors[token] = collectors;\r\n        rootedTokenFeeRates[token] = rates;\r\n    }\r\n\r\n    function setSellPath(IGatedERC20 token, address[] memory path) public ownerOnly() {\r\n        require (path[0] == address(token), \"Invalid path\");\r\n\r\n        sellPaths[token] = path;\r\n    }\r\n\r\n    function payFees(IGatedERC20 token) public onlyWhitelisted() {\r\n        uint256 balance = token.balanceOf(address(this));\r\n        require (balance \u003e 0, \"Nothing to pay\");\r\n\r\n        // If sell percentage of a token is more than zero, process the sell and distribute tokens\r\n        if (sellRates[token] \u003e 0) {\r\n            uint256 sellAmount = sellRates[token] * balance / 10000;\r\n            \r\n            // Get the path of token to token\r\n            address[] memory path = sellPaths[token];\r\n\r\n            // Carry out the swap\r\n            uint256[] memory amounts = router.swapExactTokensForTokens(sellAmount, 0, path, address(this), block.timestamp);\r\n \r\n            // Get the collectors and rates for the token\r\n            address[] memory collectors = chainTokenFeeCollectors[token];\r\n            uint256[] memory rates = chainTokenFeeRates[token];\r\n\r\n            // Distribute the tokens\r\n            uint256 lastIndex = path.length - 1;\r\n            distribute(IERC20(path[lastIndex]), amounts[lastIndex], collectors, rates);\r\n        }\r\n\r\n        // If keep percentage of a token is more than zero, distribute tokens\r\n        if (keepRates[token] \u003e 0) {\r\n            uint256 keepAmount = keepRates[token] * balance / 10000;\r\n            address[] memory collectors = rootedTokenFeeCollectors[token];\r\n            uint256[] memory rates = rootedTokenFeeRates[token];\r\n            distribute(token, keepAmount, collectors, rates);\r\n        }\r\n    }\r\n    \r\n    function distribute(IERC20 token, uint256 amount, address[] memory collectors, uint256[] memory rates) private {\r\n        for (uint256 i = 0; i \u003c collectors.length; i++) {\r\n            address collector = collectors[i];\r\n            uint256 rate = rates[i];\r\n\r\n            if (rate \u003e 0) {\r\n                uint256 feeAmount = rate * amount / 10000;\r\n                token.transfer(collector, feeAmount);\r\n            }\r\n        }\r\n    }\r\n}"},"GatedERC20.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\npragma experimental ABIEncoderV2;\n\nimport \"./SafeMath.sol\";\n\nimport \"./IGatedERC20.sol\";\nimport \"./ITransferGate.sol\";\n\nimport \"./TokensRecoverable.sol\";\n\nimport \"./ERC20.sol\";\n\nabstract contract GatedERC20 is ERC20, TokensRecoverable, IGatedERC20 {\n    using SafeMath for uint256;\n\n    ITransferGate public override transferGate;\n\n    constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) {}\n\n    function setTransferGate(ITransferGate _transferGate) public override ownerOnly() {\n        transferGate = _transferGate;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual override {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        ITransferGate _transferGate = transferGate;\n        uint256 remaining = amount;\n        \n        if (address(_transferGate) != address(0)) {\n            address splitter = _transferGate.feeSplitter();\n            uint256 fees = _transferGate.handleTransfer(msg.sender, sender, recipient, amount);\n            if (fees \u003e 0) {\n               _balanceOf[splitter] = _balanceOf[splitter].add(fees);\n                emit Transfer(sender, splitter, fees);\n                remaining = remaining.sub(fees);\n            }\n        }\n\n        _balanceOf[sender] = _balanceOf[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balanceOf[recipient] = _balanceOf[recipient].add(remaining);\n        emit Transfer(sender, recipient, remaining);\n    }\n\n    function burn(uint256 amount) public override {\n        _burn(msg.sender, amount);\n    }\n}"},"IERC165.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}"},"IERC20.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\ninterface IERC20 {\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address _account) external view returns (uint256);\n    function transfer(address _recipient, uint256 _amount) external returns (bool);\n    function allowance(address _owner, address _spender) external view returns (uint256);\n    function approve(address _spender, uint256 _amount) external returns (bool);\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n}"},"IERC31337.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nimport \"./IWrappedERC20.sol\";\nimport \"./IFloorCalculator.sol\";\n\ninterface IERC31337 is IWrappedERC20 {\n    function floorCalculator() external view returns (IFloorCalculator);\n    function sweepers(address _sweeper) external view returns (bool);\n    \n    function setFloorCalculator(IFloorCalculator _floorCalculator) external;\n    function setSweeper(address _sweeper, bool _allow) external;\n    function sweepFloor(address _to) external returns (uint256 amountSwept);\n}"},"IERC721.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nimport \"./IERC165.sol\";\n\ninterface IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function setApprovalForAll(address operator, bool _approved) external;\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}"},"IERC721Metadata.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nimport \"./IERC721.sol\";\n\ninterface IERC721Metadata is IERC721 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}"},"IERC721Receiver.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\ninterface IERC721Receiver {\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}"},"IFloorCalculator.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nimport \"./IERC20.sol\";\n\ninterface IFloorCalculator {\n    function calculateSubFloor(IERC20 baseToken, IERC20 eliteToken) external view returns (uint256);\n}"},"IGatedERC20.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nimport \"./IERC20.sol\";\nimport \"./ITransferGate.sol\";\n\ninterface IGatedERC20 is IERC20 {\n    function transferGate() external view returns (ITransferGate);\n\n    function setTransferGate(ITransferGate _transferGate) external;\n    function burn(uint256 amount) external;\n}"},"ILiquidityController.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\ninterface ILiquidityController {\n    function balancePriceBase(uint256 amount) external;\n    function balancePriceElite(uint256 amount) external;\n    function removeBuyAndTax(uint256 amount, address token, uint16 tax, uint256 time) external;\n    function buyAndTax(address token, uint256 amountToSpend, uint16 tax, uint256 time) external;\n    function sweepFloor() external;\n    function zapEliteToBase(uint256 liquidity) external;\n    function zapBaseToElite(uint256 liquidity) external;\n    function wrapToElite(uint256 baseAmount) external;\n    function unwrapElite(uint256 eliteAmount) external;\n    function addLiquidity(address eliteOrBase, uint256 baseAmount) external;\n    function removeLiquidity(address eliteOrBase, uint256 tokens) external;    \n    function buyRooted(address token, uint256 amountToSpend) external;\n    function sellRooted(address token, uint256 amountToSpend) external;   \n}"},"ILiquidityLockedERC20.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nimport \"./ISwapPair.sol\";\n\ninterface ILiquidityLockedERC20 {\n    function setLiquidityLock(ISwapPair _liquidityPair, bool _locked) external;\n}"},"IMarketDistribution.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\ninterface IMarketDistribution {\n    function distributionComplete() external view returns (bool);\n    function vestingPeriodStartTime() external view returns (uint256); \n    function vestingPeriodEndTime() external view returns (uint256);\n    \n    function distribute() external;        \n    function claim(address account) external returns (uint256);\n    function claimReferralRewards(address account, uint256 referralShare) external;\n}"},"IMarketGeneration.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\ninterface IMarketGeneration {\n    function contribution(address) external view returns (uint256);\n    function referralPoints(address) external view returns (uint256);    \n    function totalContribution() external view returns (uint256);\n    function totalReferralPoints() external view returns (uint256);\n}"},"IOwned.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\ninterface IOwned {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function owner() external view returns (address);\n\n    function transferOwnership(address newOwner) external;\n    function claimOwnership() external;\n}"},"IStakingToken.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\ninterface IStakingToken {\r\n    function stake(uint256 amount) external returns (bool success);\r\n    function unstake(uint256 amount) external returns (bool success);\r\n}"},"IStakingVault.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\ninterface IStakingVault {\r\n    function addToRewards(uint256 amount) external;\r\n}"},"ISwapCallee.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity \u003e=0.5.0;\n\ninterface ISwapCallee {\n    function swapCall(address sender, uint amount0, uint amount1, bytes calldata data) external;\n}"},"ISwapERC20.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity \u003e=0.5.0;\n\ninterface ISwapERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n}"},"ISwapFactory.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\ninterface ISwapFactory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}"},"ISwapPair.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\ninterface ISwapPair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}"},"ISwapRouter01.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\ninterface ISwapRouter01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}"},"ISwapRouter02.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nimport \u0027./ISwapRouter01.sol\u0027;\n\ninterface ISwapRouter02 is ISwapRouter01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountETH);\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\n}"},"ITokensRecoverable.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nimport \"./IERC20.sol\";\n\ninterface ITokensRecoverable {\n    function recoverTokens(IERC20 token) external;\n}"},"ITransferGate.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\ninterface ITransferGate {\n    function feeSplitter() external view returns (address);\n    function handleTransfer(address msgSender, address from, address to, uint256 amount) external returns (uint256);\n}"},"IWBNB.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\ninterface IWBNB {    \n    function deposit() external payable;\n}"},"IWrappedERC20.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nimport \"./IERC20.sol\";\nimport \"./IWrappedERC20Events.sol\";\n\ninterface IWrappedERC20 is IERC20, IWrappedERC20Events {\n    function wrappedToken() external view returns (IERC20);\n    function depositTokens(uint256 _amount) external;\n    function withdrawTokens(uint256 _amount) external;\n}"},"IWrappedERC20Events.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\ninterface IWrappedERC20Events {\n    event Deposit(address indexed from, uint256 amount);\n    event Withdrawal(address indexed to, uint256 amount);\n}\n"},"LiquidityController.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nimport \"./TokensRecoverable.sol\";\nimport \"./IERC31337.sol\";\nimport \"./ISwapRouter02.sol\";\nimport \"./IERC20.sol\";\nimport \"./RootedTransferGate.sol\";\nimport \"./ISwapFactory.sol\";\nimport \"./SafeMath.sol\";\nimport \"./ILiquidityController.sol\";\nimport \"./IFloorCalculator.sol\";\n\ncontract LiquidityController is TokensRecoverable, ILiquidityController {\n    using SafeMath for uint256;\n\n    ISwapRouter02 immutable swapRouter;\n    ISwapFactory immutable swapFactory;\n    IERC20 immutable rooted;\n    IERC20 immutable base;\n    IERC31337 immutable elite;\n    IERC20 immutable rootedEliteLP;\n    IERC20 immutable rootedBaseLP;\n    IFloorCalculator public calculator;\n    RootedTransferGate public gate;\n    mapping(address =\u003e bool) public liquidityControllers;\n\n    constructor(ISwapRouter02 _swapRouter, IERC20 _base, IERC20 _rooted, IERC31337 _elite, IFloorCalculator _calculator, RootedTransferGate _gate) {\n        swapRouter = _swapRouter;\n        base = _base;\n        elite = _elite;\n        rooted = _rooted;\n        calculator = _calculator;\n        gate = _gate;\n\n        ISwapFactory _swapFactory = ISwapFactory(_swapRouter.factory());\n        swapFactory = _swapFactory;        \n        \n        _base.approve(address(_elite), uint256(-1));\n        _base.approve(address(_swapRouter), uint256(-1));\n        _rooted.approve(address(_swapRouter), uint256(-1));\n        IERC20 _rootedBaseLP = IERC20(_swapFactory.getPair(address(_base), address(_rooted)));\n        _rootedBaseLP.approve(address(_swapRouter), uint256(-1));\n        rootedBaseLP = _rootedBaseLP;\n        _elite.approve(address(_swapRouter), uint256(-1));\n        IERC20 _rootedEliteLP = IERC20(_swapFactory.getPair(address(_elite), address(_rooted)));\n        _rootedEliteLP.approve(address(_swapRouter), uint256(-1));\n        rootedEliteLP = _rootedEliteLP;\n    }\n\n    modifier liquidityControllerOnly() {\n        require(liquidityControllers[msg.sender], \"Not a Liquidity Controller\");\n        _;\n    }\n\n    // Owner function to enable other contracts or addresses to use the Liquidity Controller\n    function setLiquidityController(address controlAddress, bool controller) public ownerOnly() {\n        liquidityControllers[controlAddress] = controller;\n    }\n\n    function setCalculatorAndGate(IFloorCalculator _calculator, RootedTransferGate _gate) public ownerOnly() {\n        calculator = _calculator;\n        gate = _gate;\n    }\n\n    // Removes liquidity, buys from either pool, sets a temporary dump tax\n    function removeBuyAndTax(uint256 amount, address token, uint16 tax, uint256 time) public override liquidityControllerOnly() {\n        gate.setUnrestricted(true);\n        amount = removeLiq(token, amount);\n        buyRootedToken(token, amount);\n        gate.setDumpTax(tax, time);\n        gate.setUnrestricted(false);\n    }\n\n    // Use Base tokens held by this contract to buy from the Base Pool and sell in the Elite Pool\n    function balancePriceBase(uint256 amount) public override liquidityControllerOnly() {\n        amount = buyRootedToken(address(base), amount);\n        amount = sellRootedToken(address(elite), amount);\n        elite.withdrawTokens(amount);\n    }\n\n    // Use Base tokens held by this contract to buy from the Elite Pool and sell in the Base Pool\n    function balancePriceElite(uint256 amount) public override liquidityControllerOnly() {        \n        elite.depositTokens(amount);\n        amount = buyRootedToken(address(elite), amount);\n        amount = sellRootedToken(address(base), amount);\n    }\n\n    // Uses value in the controller to buy\n    function buyAndTax(address token, uint256 amountToSpend, uint16 tax, uint256 time) public override liquidityControllerOnly() {\n        buyRootedToken(token, amountToSpend);\n        gate.setDumpTax(tax, time);\n    }\n\n    // Sweeps the Base token under the floor to this address\n    function sweepFloor() public override liquidityControllerOnly() {\n        elite.sweepFloor(address(this));\n    }\n\n    // Move liquidity from Elite pool ---\u003e\u003e Base pool\n    function zapEliteToBase(uint256 liquidity) public override liquidityControllerOnly() {       \n        gate.setUnrestricted(true);\n        liquidity = removeLiq(address(elite), liquidity);\n        elite.withdrawTokens(liquidity);\n        addLiq(address(base), liquidity);\n        gate.setUnrestricted(false);\n    }\n\n    // Move liquidity from Base pool ---\u003e\u003e Elite pool\n    function zapBaseToElite(uint256 liquidity) public override liquidityControllerOnly() {\n        gate.setUnrestricted(true);\n        liquidity = removeLiq(address(base), liquidity);\n        elite.depositTokens(liquidity);\n        addLiq(address(elite), liquidity);\n        gate.setUnrestricted(false);\n    }\n\n    function wrapToElite(uint256 baseAmount) public override liquidityControllerOnly() {\n        elite.depositTokens(baseAmount);\n    }\n\n    function unwrapElite(uint256 eliteAmount) public override liquidityControllerOnly() {\n        elite.withdrawTokens(eliteAmount);\n    }\n\n    function addLiquidity(address eliteOrBase, uint256 baseAmount) public override liquidityControllerOnly() {\n        gate.setUnrestricted(true);\n        addLiq(eliteOrBase, baseAmount);\n        gate.setUnrestricted(false);\n    }\n\n    function removeLiquidity(address eliteOrBase, uint256 tokens) public override liquidityControllerOnly() {\n        gate.setUnrestricted(true);\n        removeLiq(eliteOrBase, tokens);\n        gate.setUnrestricted(false);\n    }\n\n    function buyRooted(address token, uint256 amountToSpend) public override liquidityControllerOnly() {\n        buyRootedToken(token, amountToSpend);\n    }\n\n    function sellRooted(address token, uint256 amountToSpend) public override liquidityControllerOnly() {\n        sellRootedToken(token, amountToSpend);\n    }\n\n    function transferTokens(address token, address to, uint256 amount) public liquidityControllerOnly() {\n        IERC20(token).transfer(to, amount);\n    }\n\n    function addLiq(address eliteOrBase, uint256 baseAmount) internal {\n        swapRouter.addLiquidity(address(eliteOrBase), address(rooted), baseAmount, rooted.balanceOf(address(this)), 0, 0, address(this), block.timestamp);\n    }\n\n    function removeLiq(address eliteOrBase, uint256 tokens) internal returns (uint256) {\n        (tokens, ) = swapRouter.removeLiquidity(address(eliteOrBase), address(rooted), tokens, 0, 0, address(this), block.timestamp);\n        return tokens;\n    }\n\n    function buyRootedToken(address token, uint256 amountToSpend) internal returns (uint256) {\n        uint256[] memory amounts = swapRouter.swapExactTokensForTokens(amountToSpend, 0, buyPath(token), address(this), block.timestamp);\n        amountToSpend = amounts[1];\n        return amountToSpend;\n    }\n\n    function sellRootedToken(address token, uint256 amountToSpend) internal returns (uint256) {\n        uint256[] memory amounts = swapRouter.swapExactTokensForTokens(amountToSpend, 0, sellPath(token), address(this), block.timestamp);\n        amountToSpend = amounts[1];\n        return amountToSpend;\n    }\n\n    function buyPath(address token) internal view returns (address[] memory) {\n        address[] memory path = new address[](2);\n        path[0] = address(token);\n        path[1] = address(rooted);\n        return path;\n    }\n\n    function sellPath(address token) internal view returns (address[] memory) {\n        address[] memory path = new address[](2);\n        path[0] = address(rooted);\n        path[1] = address(token);\n        return path;\n    }\n}"},"LiquidityLockedERC20.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nimport \"./ERC20.sol\";\n\nimport \"./ISwapPair.sol\";\nimport \"./ILiquidityLockedERC20.sol\";\n\nimport \"./Owned.sol\";\n\nimport \"./GatedERC20.sol\";\n\nabstract contract LiquidityLockedERC20 is GatedERC20, ILiquidityLockedERC20 {\n    mapping (ISwapPair =\u003e bool) public liquidityPairLocked;\n    mapping (address =\u003e bool) public liquidityController;\n\n    struct CallRecord {\n        address origin;\n        uint32 blockNumber;\n        bool transferFrom;\n    }\n\n    CallRecord balanceAllowed;\n\n    constructor(string memory _name, string memory _symbol) GatedERC20(_name, _symbol) { }\n\n    function setLiquidityLock(ISwapPair _liquidityPair, bool _locked) public override {\n        require (liquidityController[msg.sender], \"Liquidity controller only\");\n        require (_liquidityPair.token0() == address(this) || _liquidityPair.token1() == address(this), \"Unrelated pair\");\n        liquidityPairLocked[_liquidityPair] = _locked;\n    }\n\n    function setLiquidityController(address _liquidityController, bool _canControl) public ownerOnly() {\n        liquidityController[_liquidityController] = _canControl;\n    }\n\n    function balanceOf(address account) public override view returns (uint256) {\n        ISwapPair pair = ISwapPair(address(msg.sender));\n        if (liquidityPairLocked[pair]) {\n            CallRecord memory last = balanceAllowed;\n            require (last.origin == tx.origin \u0026\u0026 last.blockNumber == block.number, \"Liquidity is locked\");\n            if (last.transferFrom) {\n                (uint256 reserve0, uint256 reserve1,) = pair.getReserves();\n                IERC20 token0 = IERC20(pair.token0());\n                if (address(token0) == address(this)) {\n                    require (IERC20(pair.token1()).balanceOf(address(pair)) \u003c reserve1, \"Liquidity is locked\");\n                }\n                else {\n                    require (token0.balanceOf(address(pair)) \u003c reserve0, \"Liquidity is locked\");\n                }\n            }\n        }\n        return super.balanceOf(account);\n    }\n\n    function allowBalance(bool _transferFrom) private {\n        CallRecord memory last = balanceAllowed;\n        CallRecord memory allow = CallRecord({ \n            origin: tx.origin,\n            blockNumber: uint32(block.number),\n            transferFrom: _transferFrom\n        });\n        require (last.origin != allow.origin || last.blockNumber != allow.blockNumber || last.transferFrom != allow.transferFrom, \"Liquidity is locked (Please try again next block)\");\n        balanceAllowed = allow;\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {        \n        if (liquidityPairLocked[ISwapPair(address(msg.sender))]) {\n            allowBalance(false);\n        } else {\n            balanceAllowed = CallRecord({ origin: address(0), blockNumber: 0, transferFrom: false });\n        }\n        return super.transfer(recipient, amount);\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        if (liquidityPairLocked[ISwapPair(recipient)]) {\n            allowBalance(true);\n        } else {\n            balanceAllowed = CallRecord({ origin: address(0), blockNumber: 0, transferFrom: false });\n        }\n        return super.transferFrom(sender, recipient, amount);\n    }\n}"},"MarketDistribution.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nimport \"./IMarketDistribution.sol\";\nimport \"./IMarketGeneration.sol\";\nimport \"./RootedToken.sol\";\nimport \"./RootedTransferGate.sol\";\nimport \"./TokensRecoverable.sol\";\nimport \"./SafeMath.sol\";\nimport \"./IERC31337.sol\";\nimport \"./IERC20.sol\";\nimport \"./ISwapRouter02.sol\";\nimport \"./ISwapFactory.sol\";\nimport \"./ISwapPair.sol\";\nimport \"./SafeERC20.sol\";\n\ncontract MarketDistribution is TokensRecoverable, IMarketDistribution {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    bool public override distributionComplete;\n\n    ISwapRouter02 swapRouter;\n    ISwapFactory swapFactory;\n\n    IMarketGeneration public marketGeneration;\n    RootedToken public rootedToken;\n    IERC31337 public eliteToken;\n    IERC20 public baseToken;\n\n    address public devAddress;\n\n    address public userClaimContract;\n    address public liquidityController;\n    \n    ISwapPair public rootedEliteLP;\n    ISwapPair public rootedBaseLP;\n\n    uint256 public constant rootedTokenSupply = 1e24; // 1 million\n\n    uint256 public totalBaseTokenCollected;\n    uint256 public totalBoughtForContributors;\n\n    mapping (address =\u003e uint256) public claimTime;\n    mapping (address =\u003e uint256) public totalClaim;\n    mapping (address =\u003e uint256) public remainingClaim;\n    \n    uint256 public totalBoughtForReferrals;\n    uint256 public recoveryDate = block.timestamp + 2592000; // 1 Month\n\n    uint16 public preBuyForReferralsPercent;\n    uint16 public preBuyForContributorsPercent;\n    uint16 public preBuyForMarketStabilizationPercent;\n\n    uint256 public override vestingPeriodStartTime;\n    uint256 public override vestingPeriodEndTime; \n    \n    uint256 public vestingDuration;\n    uint256 public rootedBottom;\n\n    constructor(address _devAddress, address _userClaimContract) {\n        devAddress = _devAddress;\n        userClaimContract = _userClaimContract;\n    }\n\n    function init(\n        RootedToken _rootedToken, \n        IERC31337 _eliteToken, \n        address _liquidityController,\n        ISwapRouter02 _swapRouter, \n        IMarketGeneration _marketGeneration,\n        uint256 _vestingDuration, \n        uint16 _preBuyForReferralsPercent, \n        uint16 _preBuyForContributorsPercent, \n        uint16 _preBuyForMarketStabilizationPercent) public ownerOnly() {        \n        rootedToken = _rootedToken;\n        eliteToken = _eliteToken;\n        baseToken = _eliteToken.wrappedToken();\n        liquidityController = _liquidityController;\n        swapRouter = _swapRouter;\n        swapFactory = ISwapFactory(_swapRouter.factory());\n        marketGeneration = _marketGeneration;\n        vestingDuration = _vestingDuration;\n        preBuyForReferralsPercent = _preBuyForReferralsPercent;\n        preBuyForContributorsPercent = _preBuyForContributorsPercent;\n        preBuyForMarketStabilizationPercent = _preBuyForMarketStabilizationPercent;\n    }\n\n    function setupEliteRooted() public {\n        rootedEliteLP = ISwapPair(swapFactory.getPair(address(eliteToken), address(rootedToken)));\n        if (address(rootedEliteLP) == address(0)) \n        {\n            rootedEliteLP = ISwapPair(swapFactory.createPair(address(eliteToken), address(rootedToken)));\n            require (address(rootedEliteLP) != address(0));\n        }\n    }\n\n    function setupBaseRooted() public {\n        rootedBaseLP = ISwapPair(swapFactory.getPair(address(baseToken), address(rootedToken)));\n        if (address(rootedBaseLP) == address(0)) {\n            rootedBaseLP = ISwapPair(swapFactory.createPair(address(baseToken), address(rootedToken)));\n            require (address(rootedBaseLP) != address(0));\n        }\n    }\n\n    function completeSetup() public ownerOnly() {   \n        require (address(rootedEliteLP) != address(0), \"Rooted Elite pool is not created\");\n        require (address(rootedBaseLP) != address(0), \"Rooted Base pool is not created\");   \n\n        eliteToken.approve(address(swapRouter), uint256(-1));\n        rootedToken.approve(address(swapRouter), uint256(-1));\n        baseToken.safeApprove(address(swapRouter), uint256(-1));\n        baseToken.safeApprove(address(eliteToken), uint256(-1));\n        rootedBaseLP.approve(address(swapRouter), uint256(-1));\n        rootedEliteLP.approve(address(swapRouter), uint256(-1));\n    }\n\n    function distribute() public override {\n        require (msg.sender == address(marketGeneration), \"Unauthorized\");\n        require (!distributionComplete, \"Distribution complete\");\n   \n        vestingPeriodStartTime = block.timestamp;\n        vestingPeriodEndTime = block.timestamp + vestingDuration;\n        distributionComplete = true;\n\n        totalBaseTokenCollected = baseToken.balanceOf(address(marketGeneration));\n        baseToken.safeTransferFrom(msg.sender, address(this), totalBaseTokenCollected);  \n\n        RootedTransferGate gate = RootedTransferGate(address(rootedToken.transferGate()));\n\n        gate.setUnrestricted(true);\n        rootedToken.mint(rootedTokenSupply);\n\n        rootedToken.transfer(userClaimContract, 537000000000000000000000);\n\n        createRootedEliteLiquidity();\n\n        eliteToken.sweepFloor(address(this));        \n        eliteToken.depositTokens(baseToken.balanceOf(address(this)));\n                \n        buyTheBottom();\n        preBuyForReferrals();\n        preBuyForContributors();\n        sellTheTop();\n\n        uint256 devShare = totalBaseTokenCollected * 600 / 10000;\n        baseToken.transfer(devAddress, devShare);\n\n        baseToken.transfer(liquidityController, baseToken.balanceOf(address(this)));\n\n        createRootedBaseLiquidity();       \n\n        gate.setUnrestricted(false);\n    }\n    \n    function createRootedEliteLiquidity() private {\n        eliteToken.depositTokens(baseToken.balanceOf(address(this)));\n        swapRouter.addLiquidity(address(eliteToken), address(rootedToken), eliteToken.balanceOf(address(this)), rootedToken.balanceOf(address(this)), 0, 0, address(this), block.timestamp);\n    }\n\n    function buyTheBottom() private {\n        uint256 amount = totalBaseTokenCollected * preBuyForMarketStabilizationPercent / 10000;  \n        uint256[] memory amounts = swapRouter.swapExactTokensForTokens(amount, 0, eliteRootedPath(), address(this), block.timestamp);        \n        rootedBottom = amounts[1];\n    }\n\n    function sellTheTop() private {\n        uint256[] memory amounts = swapRouter.swapExactTokensForTokens(rootedBottom, 0, rootedElitePath(), address(this), block.timestamp);\n        uint256 eliteAmount = amounts[1];\n        eliteToken.withdrawTokens(eliteAmount);\n    }   \n    \n    function preBuyForReferrals() private {\n        uint256 amount = totalBaseTokenCollected * preBuyForReferralsPercent / 10000;\n        uint256[] memory amounts = swapRouter.swapExactTokensForTokens(amount, 0, eliteRootedPath(), address(this), block.timestamp);\n        totalBoughtForReferrals = amounts[1];\n    }\n\n    function preBuyForContributors() private {\n        uint256 preBuyAmount = totalBaseTokenCollected * preBuyForContributorsPercent / 10000;\n        uint256 eliteBalance = eliteToken.balanceOf(address(this));\n        uint256 amount = preBuyAmount \u003e eliteBalance ? eliteBalance : preBuyAmount;\n        uint256[] memory amounts = swapRouter.swapExactTokensForTokens(amount, 0, eliteRootedPath(), address(this), block.timestamp);\n        totalBoughtForContributors = amounts[1];\n    }\n\n    function createRootedBaseLiquidity() private {\n        uint256 elitePerLpToken = eliteToken.balanceOf(address(rootedEliteLP)).mul(1e18).div(rootedEliteLP.totalSupply());\n        uint256 lpAmountToRemove = baseToken.balanceOf(address(eliteToken)).mul(1e18).div(elitePerLpToken);\n        \n        (uint256 eliteAmount, uint256 rootedAmount) = swapRouter.removeLiquidity(address(eliteToken), address(rootedToken), lpAmountToRemove, 0, 0, address(this), block.timestamp);\n        \n        uint256 baseInElite = baseToken.balanceOf(address(eliteToken));\n        uint256 baseAmount = eliteAmount \u003e baseInElite ? baseInElite : eliteAmount;       \n        \n        eliteToken.withdrawTokens(baseAmount);\n        swapRouter.addLiquidity(address(baseToken), address(rootedToken), baseAmount, rootedAmount, 0, 0, liquidityController, block.timestamp);\n        rootedEliteLP.transfer(liquidityController, rootedEliteLP.balanceOf(address(this)));\n        eliteToken.transfer(liquidityController, eliteToken.balanceOf(address(this)));\n    }\n\n    function eliteRootedPath() private view returns (address[] memory) {\n        address[] memory path = new address[](2);\n        path[0] = address(eliteToken);\n        path[1] = address(rootedToken);\n        return path;\n    }\n\n    function rootedElitePath() private view returns (address[] memory) {\n        address[] memory path = new address[](2);\n        path[0] = address(rootedToken);\n        path[1] = address(eliteToken);\n        return path;\n    }\n    \n    function getTotalClaim(address account) public view returns (uint256) {\n        uint256 contribution = marketGeneration.contribution(account);\n        return contribution == 0 ? 0 : contribution.mul(totalBoughtForContributors).div(marketGeneration.totalContribution());\n    }\n\n    function getReferralClaim(address account) public view returns (uint256) {\n        uint256 referralShare = marketGeneration.referralPoints(account);\n        return referralShare == 0 ? 0 : referralShare.mul(totalBoughtForReferrals).div(marketGeneration.totalReferralPoints());\n    }\n\n    function claim(address account) public override returns (uint256) {\n        require (distributionComplete, \"Distribution is not completed\");\n        require (msg.sender == address(marketGeneration), \"Unauthorized\");\n\n        if (totalClaim[account] == 0) {\n            totalClaim[account] = remainingClaim[account] = getTotalClaim(account);\n        }\n\n        uint256 share = totalClaim[account];\n        uint256 endTime = vestingPeriodEndTime \u003e block.timestamp ? block.timestamp : vestingPeriodEndTime;\n\n        require (claimTime[account] \u003c endTime, \"Already claimed\");\n\n        uint256 claimStartTime = claimTime[account] == 0 ? vestingPeriodStartTime : claimTime[account];\n        share = (endTime.sub(claimStartTime)).mul(share).div(vestingDuration);\n        claimTime[account] = block.timestamp;\n        remainingClaim[account] -= share;\n        rootedToken.transfer(account, share);\n\n        return share;\n    }\n\n    function claimReferralRewards(address account, uint256 referralShare) public override {\n        require (distributionComplete, \"Distribution is not completed\");\n        require (msg.sender == address(marketGeneration), \"Unauthorized\");\n\n        uint256 share = referralShare.mul(totalBoughtForReferrals).div(marketGeneration.totalReferralPoints());\n        rootedToken.transfer(account, share);\n    }\n\n    function canRecoverTokens(IERC20 token) internal override view returns (bool) { \n        return block.timestamp \u003e recoveryDate || token != rootedToken;\n    }\n}"},"MarketGeneration.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nimport \"./IMarketDistribution.sol\";\nimport \"./IMarketGeneration.sol\";\nimport \"./TokensRecoverable.sol\";\nimport \"./SafeERC20.sol\";\nimport \"./SafeMath.sol\";\nimport \"./IERC20.sol\";\nimport \"./IWBNB.sol\";\n\ncontract MarketGeneration is TokensRecoverable, IMarketGeneration {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    modifier active() {\n        require (isActive, \"Distribution not active\");\n        _;\n    }\n\n    IERC20 public baseToken;\n    IMarketDistribution public marketDistribution;\n\n    address public immutable devAddress;    \n\n    bool public isActive;\n\n    uint256 public refundsAllowedUntil;\n\n    uint256 public override totalReferralPoints;\n    uint256 public override totalContribution;\n\n    mapping (address =\u003e uint256) public override contribution;\n    mapping (address =\u003e uint256) public override referralPoints;\n    \n    constructor(address _devAddress) {\n        devAddress = _devAddress;\n    }\n\n    receive() external payable active() {\n        contribute(address(0));\n    }\n\n    function init(IERC20 _baseToken) public ownerOnly() {\n        require (!isActive \u0026\u0026 block.timestamp \u003e= refundsAllowedUntil, \"Already activated\");\n        baseToken = _baseToken;\n    }\n\n    function activate(IMarketDistribution _marketDistribution) public ownerOnly() {\n        require (!isActive \u0026\u0026 block.timestamp \u003e= refundsAllowedUntil, \"Already activated\");        \n        require (address(_marketDistribution) != address(0));\n        marketDistribution = _marketDistribution;\n        isActive = true;\n    }\n\n    function setMarketDistribution(IMarketDistribution _marketDistribution) public ownerOnly() active() {\n        require (address(_marketDistribution) != address(0), \"Invalid market distribution\");\n        if (_marketDistribution == marketDistribution) { return; }\n        marketDistribution = _marketDistribution;\n        refundsAllowedUntil = block.timestamp + 86400;\n    }\n\n    function complete() public ownerOnly() active() {\n        require (block.timestamp \u003e= refundsAllowedUntil, \"Refund period is still active\");\n        isActive = false;\n        if (address(this).balance == 0) { return; }\n        IWBNB(address(baseToken)).deposit{ value: address(this).balance }();\n        baseToken.safeApprove(address(marketDistribution), uint256(-1));\n\n        marketDistribution.distribute();\n    }\n\n    function allowRefunds() public ownerOnly() active() {\n        isActive = false;\n        refundsAllowedUntil = uint256(-1);\n    }\n\n    function refund(uint256 amount) private {\n        (bool success,) = msg.sender.call{ value: amount }(\"\");\n        require (success, \"Refund transfer failed\");  \n          \n        totalContribution -= amount;\n        contribution[msg.sender] = 0;\n\n        uint256 refPoints = referralPoints[msg.sender];\n\n        if (refPoints \u003e 0) {\n            totalReferralPoints -= refPoints;\n            referralPoints[msg.sender] = 0;\n        }\n    }\n\n    function claim() public {\n        uint256 amount = contribution[msg.sender];\n        uint256 claimedAmount = 0;\n\n        require (amount \u003e 0, \"Nothing to claim\");\n        \n        if (refundsAllowedUntil \u003e block.timestamp) {\n            refund(amount);\n        } else {\n            claimedAmount = marketDistribution.claim(msg.sender);\n        }\n    }\n\n    function claimReferralRewards() public {\n        require (referralPoints[msg.sender] \u003e 0, \"No rewards to claim\");\n        \n        uint256 refShare = referralPoints[msg.sender];\n        referralPoints[msg.sender] = 0;\n        marketDistribution.claimReferralRewards(msg.sender, refShare);\n    }\n\n    function contribute(address referral) public payable active() {\n        if (referral == address(0) || referral == msg.sender) {\n            referralPoints[devAddress] += msg.value;\n            totalReferralPoints += msg.value;\n        } else {\n            referralPoints[msg.sender] += msg.value;\n            referralPoints[referral] += msg.value;\n            totalReferralPoints +=(msg.value + msg.value);\n        }\n\n        contribution[msg.sender] += msg.value;\n        totalContribution += msg.value;\n    }\n}"},"MarketingFundWallet.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\nimport \"./Address.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport \"./SafeERC20.sol\";\r\n\r\nimport \"./IERC20.sol\";\r\n\r\nimport \"./Whitelist.sol\";\r\nimport \"./TokensRecoverable.sol\";\r\n\r\ncontract MarketingFundWallet is Whitelist, TokensRecoverable {\r\n    using Address for address;\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    string constant public name = \"Marketing Fund Wallet\";\r\n\r\n    event onDeposit(address indexed token, address indexed from, uint256 amount, uint256 timestamp);\r\n    event onTransfer(address indexed from, address indexed to, uint256 amount, uint256 timestamp);\r\n    event onTransferTokens(address indexed from, address indexed to, address indexed token, uint256 amount, uint256 timestamp);\r\n\r\n    constructor() {\r\n        transferOwnership(msg.sender);\r\n    }\r\n\r\n    receive() external payable {\r\n        emit onDeposit(address(0), msg.sender, msg.value, block.timestamp);\r\n    }\r\n\r\n    function transfer(address _recipient, uint256 _amount) public onlyWhitelisted {\r\n        payable(_recipient).transfer(_amount);\r\n        emit onTransfer(msg.sender, _recipient, _amount, block.timestamp);\r\n    }\r\n\r\n    function transferTokens(address _token, address _recipient, uint256 _amount) public onlyWhitelisted {\r\n        require(IERC20(_token).transfer(_recipient, _amount));\r\n        emit onTransferTokens(msg.sender, _recipient, _token, _amount, block.timestamp);\r\n    }\r\n}"},"Math.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity \u003e=0.5.16;\n\nlibrary Math {\n    function min(uint x, uint y) internal pure returns (uint z) {\n        z = x \u003c y ? x : y;\n    }\n\n    function sqrt(uint y) internal pure returns (uint z) {\n        if (y \u003e 3) {\n            z = y;\n            uint x = y / 2 + 1;\n            while (x \u003c z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}"},"Migrations.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity \u003e=0.4.22 \u003c0.8.0;\n\ncontract Migrations {\n  address public owner = msg.sender;\n  uint public last_completed_migration;\n\n  modifier restricted() {\n    require(\n      msg.sender == owner,\n      \"This function is restricted to the contract\u0027s owner\"\n    );\n    _;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n}\n"},"NFTRewardsWallet.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\nimport \"./Address.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport \"./SafeERC20.sol\";\r\n\r\nimport \"./IERC20.sol\";\r\n\r\nimport \"./Whitelist.sol\";\r\nimport \"./TokensRecoverable.sol\";\r\n\r\ncontract NFTRewardsWallet is Whitelist, TokensRecoverable {\r\n    using Address for address;\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    string constant public name = \"NFT Rewards Wallet\";\r\n\r\n    event onDeposit(address indexed token, address indexed from, uint256 amount, uint256 timestamp);\r\n    event onTransfer(address indexed from, address indexed to, uint256 amount, uint256 timestamp);\r\n    event onTransferTokens(address indexed from, address indexed to, address indexed token, uint256 amount, uint256 timestamp);\r\n\r\n    constructor() {\r\n        transferOwnership(msg.sender);\r\n    }\r\n\r\n    receive() external payable {\r\n        emit onDeposit(address(0), msg.sender, msg.value, block.timestamp);\r\n    }\r\n\r\n    function transfer(address _recipient, uint256 _amount) public onlyWhitelisted {\r\n        payable(_recipient).transfer(_amount);\r\n        emit onTransfer(msg.sender, _recipient, _amount, block.timestamp);\r\n    }\r\n\r\n    function transferTokens(address _token, address _recipient, uint256 _amount) public onlyWhitelisted {\r\n        require(IERC20(_token).transfer(_recipient, _amount));\r\n        emit onTransferTokens(msg.sender, _recipient, _token, _amount, block.timestamp);\r\n    }\r\n}"},"Owned.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nimport \"./IOwned.sol\";\n\nabstract contract Owned is IOwned {\n    address public override owner = msg.sender;\n    address internal pendingOwner;\n\n    modifier ownerOnly() {\n        require (msg.sender == owner, \"Owner only\");\n        _;\n    }\n\n    function transferOwnership(address newOwner) public override ownerOnly() {\n        pendingOwner = newOwner;\n    }\n\n    function claimOwnership() public override {\n        require (pendingOwner == msg.sender);\n        pendingOwner = address(0);\n        emit OwnershipTransferred(owner, msg.sender);\n        owner = msg.sender;\n    }\n}"},"Pausable.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nimport \"./Context.sol\";\n\nabstract contract Pausable is Context {\n    event Paused(address account);\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    constructor() {\n        _paused = false;\n    }\n\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}"},"PieFundWallet.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\nimport \"./Address.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport \"./SafeERC20.sol\";\r\n\r\nimport \"./IERC20.sol\";\r\n\r\nimport \"./Whitelist.sol\";\r\nimport \"./TokensRecoverable.sol\";\r\n\r\ncontract PieFundWallet is Whitelist, TokensRecoverable {\r\n    using Address for address;\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    string constant public name = \"PIE Fund Wallet\";\r\n\r\n    event onDeposit(address indexed token, address indexed from, uint256 amount, uint256 timestamp);\r\n    event onTransfer(address indexed from, address indexed to, uint256 amount, uint256 timestamp);\r\n    event onTransferTokens(address indexed from, address indexed to, address indexed token, uint256 amount, uint256 timestamp);\r\n\r\n    constructor() {\r\n        transferOwnership(msg.sender);\r\n    }\r\n\r\n    receive() external payable {\r\n        emit onDeposit(address(0), msg.sender, msg.value, block.timestamp);\r\n    }\r\n\r\n    function transfer(address _recipient, uint256 _amount) public onlyWhitelisted {\r\n        payable(_recipient).transfer(_amount);\r\n        emit onTransfer(msg.sender, _recipient, _amount, block.timestamp);\r\n    }\r\n\r\n    function transferTokens(address _token, address _recipient, uint256 _amount) public onlyWhitelisted {\r\n        require(IERC20(_token).transfer(_recipient, _amount));\r\n        emit onTransferTokens(msg.sender, _recipient, _token, _amount, block.timestamp);\r\n    }\r\n}"},"ReentrancyGuard.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nabstract contract ReentrancyGuard {\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        _status = _NOT_ENTERED;\n    }\n\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}"},"RootedToken.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nimport \"./LiquidityLockedERC20.sol\";\n\ncontract RootedToken is LiquidityLockedERC20(\"Degen Protocol Elite\", \"SH33P\") {\n    address public minter;\n\n    function setMinter(address _minter) public ownerOnly() {\n        minter = _minter;\n    }\n\n    function mint(uint256 amount) public {\n        require(msg.sender == minter, \"Not a minter\");\n        require(this.totalSupply() == 0, \"Already minted\");\n        _mint(msg.sender, amount);\n    }\n}"},"RootedTransferGate.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\nimport \"./Address.sol\";\r\nimport \"./IERC20.sol\";\r\nimport \"./ISwapPair.sol\";\r\nimport \"./ILiquidityLockedERC20.sol\";\r\nimport \"./ISwapRouter02.sol\";\r\nimport \"./SafeERC20.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport \"./TokensRecoverable.sol\";\r\nimport \"./ITransferGate.sol\";\r\nimport \"./AddressRegistry.sol\";\r\n\r\ncontract RootedTransferGate is TokensRecoverable, ITransferGate {   \r\n    using Address for address;\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    ISwapPair public mainPool;\r\n    AddressRegistry public addressRegistry;\r\n\r\n    ISwapRouter02 immutable internal swapRouter;\r\n    ILiquidityLockedERC20 immutable internal rootedToken;\r\n\r\n    bool public unrestricted;\r\n    bool public tradingEnabled;\r\n\r\n    mapping (address =\u003e bool) public unrestrictedControllers;\r\n    mapping (address =\u003e bool) public feeControllers;\r\n    \r\n    mapping (address =\u003e uint256) public poolsTaxRates;\r\n    mapping (address =\u003e uint256) public recordedDebt;\r\n\r\n    mapping (address =\u003e bool) public isTradingPair;\r\n\r\n    address public override feeSplitter;\r\n\r\n    uint256 public transferTaxRate;\r\n    uint256 public dumpTaxStartRate;\r\n    \r\n    uint256 public dumpTaxDurationInSeconds;\r\n    uint256 public dumpTaxEndTimestamp;\r\n\r\n    constructor(ILiquidityLockedERC20 _rootedToken, ISwapRouter02 _swapRouter) {\r\n        rootedToken = _rootedToken;\r\n        swapRouter = _swapRouter;\r\n        tradingEnabled = false;\r\n    }\r\n\r\n    function setTradingEnabled(bool _tradingEnabled) public ownerOnly() {\r\n        tradingEnabled = _tradingEnabled;\r\n    }\r\n\r\n    function setIsTradingPair(address pair, bool isPair) public ownerOnly() {\r\n        isTradingPair[pair] = isPair;\r\n    }\r\n\r\n    function setFeeControllers(address feeController, bool allow) public ownerOnly() {\r\n        feeControllers[feeController] = allow;\r\n    }\r\n\r\n    function setUnrestrictedController(address unrestrictedController, bool allow) public ownerOnly() {\r\n        unrestrictedControllers[unrestrictedController] = allow;\r\n    }\r\n\r\n    function setFreeParticipantController(address freeParticipantController, bool allow) public ownerOnly() {\r\n        addressRegistry.setFreeParticipantController(freeParticipantController, allow);\r\n    }\r\n\r\n    function setTrustedWallet(address trustedWallet, bool allow) public ownerOnly() {\r\n        addressRegistry.setTrustedWallet(trustedWallet, allow);\r\n    }\r\n\r\n    function setFreeParticipant(address participant, bool free) public {\r\n        require (msg.sender == owner || addressRegistry.freeParticipantControllers(msg.sender), \"Not an owner or free participant controller\");\r\n        addressRegistry.setFreeParticipant(participant, free);\r\n    }\r\n\r\n    function setFeeSplitter(address _feeSplitter) public ownerOnly() {\r\n        feeSplitter = _feeSplitter;\r\n    }\r\n\r\n    function setUnrestricted(bool _unrestricted) public {\r\n        require (unrestrictedControllers[msg.sender], \"Not an unrestricted controller\");\r\n        unrestricted = _unrestricted;\r\n        rootedToken.setLiquidityLock(mainPool, !_unrestricted);\r\n    }\r\n\r\n    function setAddressRegistry(AddressRegistry _addressRegistry) public ownerOnly() {\r\n        addressRegistry = _addressRegistry;\r\n    }\r\n\r\n    function setMainPool(ISwapPair _mainPool) public ownerOnly() {\r\n        mainPool = _mainPool;\r\n    }\r\n\r\n     function setPoolTaxRate(address pool, uint256 taxRate) public ownerOnly() {\r\n        require (taxRate \u003c= 10000, \"Fee rate must be less than or equal to 100%\");\r\n        poolsTaxRates[pool] = taxRate;        \r\n    }\r\n\r\n    function setDumpTax(uint256 startTaxRate, uint256 durationInSeconds) public {\r\n        require (feeControllers[msg.sender] || msg.sender == owner, \"Not an owner or fee controller\");\r\n        require (startTaxRate \u003c= 10000, \"Dump tax rate must be less than or equal to 100%\");\r\n\r\n        dumpTaxStartRate = startTaxRate;\r\n        dumpTaxDurationInSeconds = durationInSeconds;\r\n        dumpTaxEndTimestamp = block.timestamp + durationInSeconds;\r\n    }\r\n\r\n    function getDumpTaxRate() public view returns (uint256) {\r\n        if (block.timestamp \u003e= dumpTaxEndTimestamp) {\r\n            return 0;\r\n        }\r\n        \r\n        return dumpTaxStartRate*(dumpTaxEndTimestamp - block.timestamp)*1e18/dumpTaxDurationInSeconds/1e18;\r\n    }\r\n\r\n    function setFees(uint256 _transferTaxRate) public {\r\n        require (feeControllers[msg.sender] || msg.sender == owner, \"Not an owner or fee controller\");\r\n        require (_transferTaxRate \u003c= 10000, \"Fee rate must be less than or equal to 100%\");\r\n        transferTaxRate = _transferTaxRate;\r\n    }\r\n\r\n    function setDebt(address _addr, uint256 _debtAmount) public {\r\n        require (feeControllers[msg.sender] || msg.sender == owner, \"Not an owner or fee controller\");\r\n        recordedDebt[_addr] = _debtAmount;\r\n    }\r\n\r\n    function batchSetDebts(address[] memory addrs, uint256[] memory amounts) public {\r\n        require (feeControllers[msg.sender] || msg.sender == owner, \"Not an owner or fee controller\");\r\n        require (addrs.length == amounts.length, \"Arrays must be of equal length\");\r\n        for (uint256 i = 0; i \u003c addrs.length; i++) {\r\n            recordedDebt[addrs[i]] = amounts[i];\r\n        }\r\n    }\r\n\r\n    function handleTransfer(address, address from, address to, uint256 amount) public virtual override returns (uint256 _totalFees) {\r\n\r\n        // Get User Debt (tokens owed to the project)\r\n        uint256 userDebt = recordedDebt[from];\r\n        uint256 payableDebt = 0;\r\n\r\n        uint256 poolTaxRate = poolsTaxRates[to];\r\n        uint256 dumpTaxRate = getDumpTaxRate();\r\n        uint256 totalTaxRate = 0;\r\n\r\n        // If from or to is blacklisted, then the amount is returned as fees.\r\n        if (addressRegistry.blacklist(from) || addressRegistry.blacklist(to)) {\r\n            return amount;\r\n        }\r\n\r\n        // If unrestricted, or \u0027from\u0027 or \u0027to\u0027 is a free participant, then no fees are charged.\r\n        if (unrestricted || addressRegistry.freeParticipant(from) || addressRegistry.freeParticipant(to)) {\r\n            return 0;\r\n        }\r\n\r\n        // If from or to is a trustedHolder, then dump tax is not in effect\r\n        if (addressRegistry.trustedHolder(from) || addressRegistry.trustedHolder(to)) {\r\n            dumpTaxRate = 0;\r\n        }\r\n\r\n        // If \u0027from\u0027 or \u0027to\u0027 isPair, then require that trading is enabled, or that the sender is a free participant\r\n        if (isTradingPair[from] || isTradingPair[to]) {\r\n            require (tradingEnabled || addressRegistry.freeParticipant(msg.sender), \"Trading is not enabled\");\r\n        }\r\n\r\n        // If \u0027to\u0027 is not the mainPool (not a sell), then dump tax is not in effect\r\n        if (!isTradingPair[to]) {\r\n            dumpTaxRate = 0;\r\n        }\r\n\r\n        // Collect user debt (if any and if capable)\r\n        // If the transferred amount (\u0027amount\u0027) is more than or equal to the user debt, then the user debt is cleared.\r\n        // Else, the user debt is reduced by the payableDebt.\r\n        if (amount \u003e= userDebt) {\r\n            payableDebt = userDebt; // Note how much debt is being paid\r\n            amount -= userDebt; // Reduce the amount by the debt\r\n            recordedDebt[from] = 0; // Clear the debt\r\n        } else {\r\n            payableDebt = amount; // Note how much debt is being paid\r\n            amount -= payableDebt; // Reduce the amount by the debt\r\n            recordedDebt[from] -= payableDebt; // Reduce the debt by the amount paid\r\n        }\r\n\r\n        // If poolTaxRate is higher than fee rate, then use the pool tax rate.\r\n        if (poolTaxRate \u003e transferTaxRate) {\r\n            totalTaxRate = dumpTaxRate + poolTaxRate;\r\n            return totalTaxRate \u003e= 10000 ? _totalFees = amount : _totalFees = payableDebt + (amount * totalTaxRate / 10000);\r\n        }\r\n\r\n        // Find the total tax rate and return the fee amount (plus any debt due)\r\n        totalTaxRate = dumpTaxRate + transferTaxRate;\r\n        _totalFees = payableDebt + (amount * totalTaxRate / 10000);\r\n    }\r\n}"},"SafeERC20.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nimport \"./Address.sol\";\nimport \"./SafeMath.sol\";\n\nimport \"./IERC20.sol\";\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {        \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n    \n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"},"StakingToken.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nimport \"./Address.sol\";\nimport \"./SafeMath.sol\";\nimport \"./SafeERC20.sol\";\n\nimport \"./IERC20.sol\";\nimport \"./RootedTransferGate.sol\";\n\nimport \"./ERC20.sol\";\n\nimport \"./Pausable.sol\";\nimport \"./TokensRecoverable.sol\";\n\ncontract StakingToken is ERC20(\"SH33P Staking\", \"xSH33P\"), Pausable, TokensRecoverable {\n    using Address for address;\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    ///////////////\n    // MODIFIERS //\n    ///////////////\n\n    // Can only stake if you have no debt\n    modifier zeroDebtOnly() {\n        require(rootedTransferGate.recordedDebt(msg.sender) == 0, \"PAY_DEBT_FIRST\");\n        _;\n    }\n\n    ///////////////////////////////\n    // CONFIGURABLES \u0026 VARIABLES //\n    ///////////////////////////////\n\n    IERC20 public immutable rooted;\n    RootedTransferGate public immutable rootedTransferGate;\n\n    uint256 public totalStakers;\n    uint256 public allTimeStaked;\n    uint256 public allTimeUnstaked;\n\n    /////////////////////\n    // DATA STRUCTURES //\n    /////////////////////\n\n    struct AddressRecords {\n        uint256 totalStaked;\n        uint256 totalUnstaked;\n        uint256 lastStakedPrice;\n        uint256 lastUnstakedPrice;\n    }\n\n    mapping(address =\u003e AddressRecords) public addressRecord;\n\n    /////////////////////\n    // CONTRACT EVENTS //\n    /////////////////////\n\n    event StakeTokens(address indexed _caller, uint256 _amount, uint256 _timestamp);\n    event UnstakeTokens(address indexed _caller, uint256 _amount, uint256 _timestamp);\n\n    ////////////////////////////\n    // CONSTRUCTOR \u0026 FALLBACK //\n    ////////////////////////////\n\n    constructor(IERC20 _rooted, address _transferGate) {\n        rooted = _rooted;\n        rootedTransferGate = RootedTransferGate(_transferGate);\n        _pause();\n    }\n\n    ////////////////////\n    // VIEW FUNCTIONS //\n    ////////////////////\n\n    // Get stats of an address\n    function statsOf(address _user) public view returns (uint256 _totalStaked, uint256 _totalUnstaked, uint256 _lastStakePrice, uint256 _lastUnstakePrice) {\n        return (\n            addressRecord[_user].totalStaked, \n            addressRecord[_user].totalUnstaked,\n            addressRecord[_user].lastStakedPrice,\n            addressRecord[_user].lastUnstakedPrice\n        );\n    }\n\n    // Rate of xSH33P per SH33P staked\n    function baseToStaked(uint256 _amount) public view returns (uint256 _stakedAmount) {\n        uint256 totalRooted = rooted.balanceOf(address(this));\n        uint256 totalShares = this.totalSupply();\n\n        if (totalShares == 0 || totalRooted == 0) {\n            return _amount;\n        } else {\n            return _amount.mul(totalShares).div(totalRooted);\n        }\n    }\n\n    // Rate of SH33P per xSH33P redeemed\n    function stakedToBase(uint256 _amount) public view returns (uint256 _baseAmount) {\n        uint256 totalShares = this.totalSupply();\n        return _amount.mul(rooted.balanceOf(address(this))).div(totalShares);\n    }\n\n    /////////////////////\n    // WRITE FUNCTIONS //\n    /////////////////////\n\n    // Stake SH33P, get xSH33P\n    function stake(uint256 amount) public zeroDebtOnly() whenNotPaused() returns (bool success) {\n        uint256 totalRooted = rooted.balanceOf(address(this));\n        uint256 totalShares = this.totalSupply();\n\n        if (addressRecord[msg.sender].totalStaked == 0) {\n            totalStakers += 1;\n        }\n\n        if (totalShares == 0 || totalRooted == 0) {\n            _mint(msg.sender, amount);\n        } else {\n            uint256 mintAmount = amount.mul(totalShares).div(totalRooted);\n            _mint(msg.sender, mintAmount);\n        }\n\n        rooted.transferFrom(msg.sender, address(this), amount);\n\n        addressRecord[msg.sender].lastStakedPrice = baseToStaked(1e18);\n        addressRecord[msg.sender].totalStaked += amount;\n        allTimeStaked += amount;\n\n        emit StakeTokens(msg.sender, amount, block.timestamp);\n        return true;\n    }\n\n    // Unstake xSH33P, get SH33P\n    function unstake(uint256 amount) public zeroDebtOnly() returns (bool success) {\n        uint256 totalShares = this.totalSupply();\n        uint256 unstakeAmount = amount.mul(rooted.balanceOf(address(this))).div(totalShares);\n\n        _burn(msg.sender, amount);\n        rooted.transfer(msg.sender, unstakeAmount);\n\n        addressRecord[msg.sender].lastUnstakedPrice = stakedToBase(1e18);\n        addressRecord[msg.sender].totalUnstaked += unstakeAmount;\n        allTimeUnstaked += unstakeAmount;\n\n        emit UnstakeTokens(msg.sender, amount, block.timestamp);\n        return true;\n    }\n\n    //////////////////////////\n    // OWNER-ONLY FUNCTIONS //\n    //////////////////////////\n\n    // Pause\n    function pause() public ownerOnly() {\n        _pause();\n    }\n\n    // Unpause\n    function unpause() public ownerOnly() {\n        _unpause();\n    }\n\n    ///////////////////////////////////\n    // INTERNAL \u0026 OVERRIDE FUNCTIONS //\n    ///////////////////////////////////\n\n    // Can recover any token except the staked token\n    // Can recover staked token if paused (EMERGENCY ONLY)\n    function canRecoverTokens(IERC20 token) internal override view returns (bool) {\n        if (paused() == true) {\n            return true;\n        } else {\n            return address(token) != address(rooted);\n        }\n    }\n}"},"StakingVault.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.4;\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly { size := extcodesize(account) }\r\n        return size \u003e 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length \u003e 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003c= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003e 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {        \r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length \u003e 0) {\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ninterface IOwned {\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    function owner() external view returns (address);\r\n\r\n    function transferOwnership(address newOwner) external;\r\n    function claimOwnership() external;\r\n}\r\n\r\ninterface IERC20 {\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address _account) external view returns (uint256);\r\n    function transfer(address _recipient, uint256 _amount) external returns (bool);\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n    function approve(address _spender, uint256 _amount) external returns (bool);\r\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\ninterface IBuddySystem {\r\n    function myUpline() external view returns (address);\r\n    function myMembers() external view returns (address);\r\n    function getTeamOf(address _addr) external view returns (address[] memory team);\r\n    function uplineOf(address player) external view returns (address);\r\n    function membersOf(address player) external view returns (uint256);\r\n    function getDownlineById(address player, uint256 _pos) external view returns (address);\r\n\r\n    function setUpline(address _newUpline) external returns (uint256);\r\n}\r\n\r\ninterface ITokenVault {\r\n    function withdraw(address _token, uint256 _amount) external;\r\n}\r\n\r\ninterface ITokensRecoverable {\r\n    function recoverTokens(IERC20 token, address _to) external;\r\n    function lockToken(IERC20 token, bool _locked) external;\r\n}\r\n\r\nabstract contract Owned is IOwned {\r\n    address public override owner = msg.sender;\r\n    address internal pendingOwner;\r\n\r\n    modifier ownerOnly() {\r\n        require (msg.sender == owner, \"Owner only\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public override ownerOnly() {\r\n        pendingOwner = newOwner;\r\n    }\r\n\r\n    function claimOwnership() public override {\r\n        require (pendingOwner == msg.sender);\r\n        pendingOwner = address(0);\r\n        emit OwnershipTransferred(owner, msg.sender);\r\n        owner = msg.sender;\r\n    }\r\n}\r\n\r\nabstract contract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    string public override name;\r\n    string public override symbol;\r\n    \r\n    uint8 public override decimals = 18;\r\n\r\n    uint256 public override totalSupply;\r\n\r\n    mapping (address =\u003e uint256) internal _balanceOf;\r\n    mapping (address =\u003e mapping (address =\u003e uint256)) public override allowance;\r\n\r\n    constructor (string memory _name, string memory _symbol) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n    }\r\n\r\n    function balanceOf(address a) public virtual override view returns (uint256) { return _balanceOf[a]; }\r\n\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        uint256 oldAllowance = allowance[sender][msg.sender];\r\n        if (oldAllowance != uint256(-1)) {\r\n            _approve(sender, msg.sender, oldAllowance.sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(msg.sender, spender, allowance[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        _approve(msg.sender, spender, allowance[msg.sender][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        _balanceOf[sender] = _balanceOf[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balanceOf[recipient] = _balanceOf[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        totalSupply = totalSupply.add(amount);\r\n        _balanceOf[account] = _balanceOf[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        _balanceOf[account] = _balanceOf[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        totalSupply = totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        allowance[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _setupDecimals(uint8 _decimals) internal {\r\n        decimals = _decimals;\r\n    }\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n}\r\n\r\nabstract contract Whitelist is Owned {\r\n\r\n    modifier onlyWhitelisted() {\r\n        if(active){\r\n            require(whitelist[msg.sender], \u0027not whitelisted\u0027);\r\n        }\r\n        _;\r\n    }\r\n\r\n    bool active = true;\r\n\r\n    mapping(address =\u003e bool) public whitelist;\r\n\r\n    event WhitelistedAddressAdded(address addr);\r\n    event WhitelistedAddressRemoved(address addr);\r\n\r\n    function activateDeactivateWhitelist() public ownerOnly() {\r\n        active = !active;\r\n    }\r\n\r\n    function addAddressToWhitelist(address addr) public ownerOnly() returns(bool success) {\r\n        if (!whitelist[addr]) {\r\n            whitelist[addr] = true;\r\n            emit WhitelistedAddressAdded(addr);\r\n            success = true;\r\n        }\r\n    }\r\n\r\n    function addAddressesToWhitelist(address[] calldata addrs) public ownerOnly() returns(bool success) {\r\n        for (uint256 i = 0; i \u003c addrs.length; i++) {\r\n            if (addAddressToWhitelist(addrs[i])) {\r\n                success = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    function removeAddressFromWhitelist(address addr) ownerOnly() public returns(bool success) {\r\n        if (whitelist[addr]) {\r\n            whitelist[addr] = false;\r\n            emit WhitelistedAddressRemoved(addr);\r\n            success = true;\r\n        }\r\n    }\r\n\r\n    function removeAddressesFromWhitelist(address[] calldata addrs) ownerOnly() public returns(bool success) {\r\n        for (uint256 i = 0; i \u003c addrs.length; i++) {\r\n            if (removeAddressFromWhitelist(addrs[i])) {\r\n                success = true;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == _ENTERED;\r\n    }\r\n}\r\n\r\nabstract contract TokensRecoverable is Owned, ITokensRecoverable {\r\n    using SafeERC20 for IERC20;\r\n\r\n    mapping (address =\u003e bool) internal locked_;\r\n\r\n    function recoverTokens(IERC20 token, address _to) public override ownerOnly() {\r\n        require (canRecoverTokens(token));\r\n        uint256 amountOut = token.balanceOf(address(this));\r\n        token.safeTransfer(_to, amountOut);\r\n    }\r\n\r\n    function lockToken(IERC20 token, bool _locked) public override ownerOnly() {\r\n        locked_[address(token)] = _locked;\r\n    }\r\n\r\n    function canRecoverTokens(IERC20 token) internal virtual view returns (bool) { \r\n        return locked_[address(token)];\r\n    }\r\n}\r\n\r\n/*\r\n|||||||||||||||||||||||||||||||||||||||||||||||\r\n|| ExtremisVault - Based on \u0027Bankroll Stack\u0027 ||\r\n|| V1.0 by Don Function | The Degen Protocol ||\r\n|||||||||||||||||||||||||||||||||||||||||||||||\r\n\r\n - Added ERC20 tokenomics\r\n - Dividends handling on transfer\r\n\r\n - Added referral scheme\r\n - Merged compound + withdraw into one action\r\n - On-chain storage for action percentages\r\n\r\n - Whitelisted addresses can do action for any address\r\n - Whitelisted addresses can set amounts for any address\r\n*/\r\n\r\ncontract StakingVault is ERC20, Whitelist, ReentrancyGuard, TokensRecoverable {\r\n    using Address for address;\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    IERC20 public token;\r\n    IBuddySystem public buddies;\r\n    \r\n    /////////////////////////////////\r\n    // CONFIGURABLES AND VARIABLES //\r\n    /////////////////////////////////\r\n\r\n    uint public users;\r\n    uint public totalTxs;\r\n    uint public totalClaims;\r\n    uint public totalAirdrops;\r\n    uint public totalDeposits;\r\n    uint public dripPoolBalance;\r\n    uint public lastPayoutTimestamp;\r\n    uint public lastDistributionTime;\r\n\r\n    uint256 internal profitPerShare_;\r\n\r\n    uint16 constant internal dripRate = 300;\r\n    uint16 constant internal refsFee = 300;\r\n    uint16 constant internal divsFee = 1000;\r\n    uint16 constant internal oneHundred = 10000;\r\n\r\n    uint256 constant internal magnitude = 2 ** 64;\r\n    uint256 constant internal payoutFrequency = 2 seconds;\r\n    uint256 constant internal distributionFrequency = 6 hours;\r\n\r\n    ////////////////////////////////////\r\n    // DATA STRUCTS \u0026 MAPPINGS        //\r\n    ////////////////////////////////////\r\n\r\n    struct Airdrop {\r\n        uint256 ready;\r\n        uint256 pending;\r\n        uint256 airdrops;\r\n        uint256 airdrops_received;\r\n        uint256 last_airdrop;\r\n    }\r\n\r\n    struct ActionConfig {\r\n        uint16 compound;\r\n        uint16 withdraw;\r\n        uint16 airdrop;\r\n    }\r\n\r\n    struct AddressStats {\r\n        uint deposited;\r\n        uint withdrawn;\r\n        uint compounded;\r\n        uint rewarded;\r\n        uint contributed;\r\n        uint transferredShares;\r\n        uint receivedShares;\r\n        \r\n        uint xInvested;\r\n        uint xCompounded;\r\n        uint xRewarded;\r\n        uint xContributed;\r\n        uint xWithdrawn;\r\n        uint xTransferredShares;\r\n        uint xReceivedShares;\r\n    }\r\n\r\n    mapping(address =\u003e Airdrop) internal airdrops;\r\n    mapping(address =\u003e  int256) internal payoutsOf_;\r\n    mapping(address =\u003e ActionConfig) internal actionCfg_;\r\n    mapping(address =\u003e AddressStats) internal accountOf_;\r\n    \r\n    ////////////////////////////////////\r\n    // EVENTS                         //\r\n    ////////////////////////////////////\r\n    \r\n    event onDeposit( address indexed caller, uint256 deposited,  uint256 tokensMinted, uint timestamp);\r\n    event onWithdraw(address indexed caller, uint256 liquidated, uint256 tokensEarned, uint timestamp);\r\n\r\n    event onSetAmounts(address indexed caller, uint16 compound, uint16 withdraw, uint16 airdrop, uint timestamp);\r\n    event onDoActions(address indexed caller, uint256 compounded, uint256 withdrawn, uint timestamp);\r\n    \r\n    event onAddRewards(address indexed caller, uint256 amount, uint timestamp);\r\n    event onAirdrop(address indexed from, uint256 totalAmount, uint256 timestamp);\r\n    event onDistribute(address indexed caller, uint256 balance, uint256 timestamp);\r\n    \r\n    ////////////////////////////////////\r\n    // CONSTRUCTOR \u0026 FALLBACK         //\r\n    ////////////////////////////////////\r\n\r\n    constructor(\r\n        string memory _name, \r\n        string memory _symbol, \r\n        address _tokenAddress, \r\n        address _buddySystem\r\n    ) ERC20(_name, _symbol) {\r\n        token = IERC20(_tokenAddress);\r\n        buddies = IBuddySystem(_buddySystem);\r\n        lastPayoutTimestamp = (block.timestamp);\r\n    }\r\n    \r\n    receive() payable external {\r\n        Address.sendValue(payable(owner), msg.value);\r\n    }\r\n\r\n    ////////////////////////////////////\r\n    // VIEW FUNCTIONS                 //\r\n    ////////////////////////////////////\r\n\r\n    function buyPrice() external pure returns (uint256) {\r\n        uint256 _tokens = 1e18;\r\n        uint256 _dividends = _tokens.mul(divsFee).div(oneHundred);\r\n        uint256 _taxedTokens = _tokens.add(_dividends);\r\n        return _taxedTokens;\r\n    }\r\n    \r\n    function sellPrice() external pure returns (uint256) {\r\n        uint256 _tokens = 1e18;\r\n        uint256 _dividends = _tokens.mul(divsFee).div(oneHundred);\r\n        uint256 _taxedTokens = _tokens.sub(_dividends);\r\n        return _taxedTokens;\r\n    }\r\n\r\n    function totalStaked() public view returns (uint256) {\r\n        return token.balanceOf(address(this));\r\n    }\r\n\r\n    function payoutsOf(address _user) public view returns (int256) {\r\n        return (payoutsOf_[_user]);\r\n    }\r\n\r\n    function earnRateOf(address _user) external view returns (uint256) {\r\n        uint256 userBalance = balanceOf(_user);\r\n        uint256 currentTotalStaked = totalStaked();\r\n\r\n        uint256 share = dripPoolBalance.mul(dripRate).div(oneHundred);\r\n        return (currentTotalStaked \u003e 0) ? share.mul(userBalance).div(currentTotalStaked) : 0;\r\n    }\r\n    \r\n    function dividendsOf(address _user) public view returns (uint256) {\r\n        uint256 userBalance = balanceOf(_user);\r\n        int256 userPayouts = payoutsOf(_user);\r\n        return (uint256) ((int256) (profitPerShare_ * userBalance) - userPayouts) / magnitude;\r\n    }\r\n\r\n    function statsOf(address _user) external view returns (uint256[14] memory){\r\n        AddressStats memory a = accountOf_[_user];\r\n        uint256[14] memory accountArray = [\r\n            a.deposited, \r\n            a.withdrawn, \r\n            a.rewarded, \r\n            a.compounded,\r\n            a.contributed, \r\n            a.transferredShares, \r\n            a.receivedShares, \r\n            a.xInvested, \r\n            a.xRewarded, \r\n            a.xContributed, \r\n            a.xWithdrawn, \r\n            a.xTransferredShares, \r\n            a.xReceivedShares, \r\n            a.xCompounded\r\n        ];\r\n        return accountArray;\r\n    }\r\n\r\n    function airdropBalanceOf(address _user) public view returns (uint256) {\r\n        return airdrops[_user].ready;\r\n    }\r\n\r\n    function getActionAmounts(address _user) public view returns (uint16 _compound, uint16 _withdraw, uint16 _airdrop) {\r\n        ActionConfig storage actionCfg = actionCfg_[_user];\r\n        return (actionCfg.compound, actionCfg.withdraw, actionCfg.airdrop);\r\n    }\r\n\r\n    function calculateSharesReceived(uint256 _amount) external pure returns (uint256) {\r\n        uint256 _divies = _amount.mul(divsFee).div(oneHundred);\r\n        uint256 _remains = _amount.sub(_divies);\r\n        uint256 _result = _remains;\r\n        return  _result;\r\n    }\r\n\r\n    function calculateTokensReceived(uint256 _amount) external view returns (uint256) {\r\n        uint256 currentTotalStaked = totalStaked();\r\n        require(_amount \u003c= currentTotalStaked);\r\n        uint256 _tokens  = _amount;\r\n        uint256 _divies  = _tokens.mul(divsFee).div(oneHundred);\r\n        uint256 _remains = _tokens.sub(_divies);\r\n        return _remains;\r\n    }\r\n    \r\n    ////////////////////////////////////\r\n    // WRITE FUNCTIONS                //\r\n    ////////////////////////////////////\r\n\r\n    // Add tokens to drip pool\r\n    function addToRewards(uint _amount) external returns (bool success) {\r\n        require(token.transferFrom(msg.sender, address(this), _amount));\r\n\r\n        dripPoolBalance += _amount;\r\n\r\n        emit onAddRewards(msg.sender, _amount, block.timestamp);\r\n        return true;\r\n    }\r\n\r\n    // Deposit tokens\r\n    function deposit(uint _amount) external returns (bool success)  {\r\n        success = depositTo(msg.sender, _amount);\r\n        require(success, \"DEPOSIT_FAILED\");\r\n        return true;\r\n    }\r\n\r\n    // Deposit tokens, giving vault tokens to an address\r\n    function depositTo(address _user, uint _amount) public returns (bool success)  {\r\n        \r\n        require(token.transferFrom(msg.sender, address(this), _amount));\r\n\r\n        totalDeposits += _amount;\r\n\r\n        address _upline = buddies.uplineOf(msg.sender);\r\n        require(_upline != address(0), \"SET_UPLINE_FIRST\");\r\n\r\n        uint256 airdropsPending = airdrops[_user].pending;\r\n        uint256 userShare = oneHundred - refsFee;\r\n\r\n        uint256 playerDepositAmount = _amount.mul(userShare).div(oneHundred);\r\n        uint256 uplineDepositAmount = _amount.mul(refsFee).div(oneHundred);\r\n\r\n        if (airdropsPending \u003e 0) {\r\n            playerDepositAmount += airdropsPending;\r\n            receiveAirdrops(_user, airdropsPending);\r\n        }\r\n\r\n        _depositTokens(_user, playerDepositAmount);\r\n        _depositTokens(_upline, uplineDepositAmount);\r\n\r\n        distribute();\r\n\r\n        return true;\r\n    }\r\n\r\n    // Withdraw tokens from vault\r\n    function withdraw(uint256 _amount) external {\r\n        address _user = msg.sender;\r\n        require(_amount \u003c= balanceOf(_user));\r\n        \r\n        // Calculate dividends and \u0027shares\u0027 (tokens)\r\n        uint256 _undividedDividends = _amount.mul(divsFee) / oneHundred;\r\n        uint256 _taxedTokens = _amount.sub(_undividedDividends);\r\n\r\n        // Subtract amounts from user and totals...\r\n        _burn(_user, _amount);\r\n\r\n        // Update the payment ratios for the user and everyone else...\r\n        int256 _updatedPayouts = (int256) (profitPerShare_ * _amount + (_taxedTokens * magnitude));\r\n        payoutsOf_[_user] -= _updatedPayouts;\r\n\r\n        // Serve dividends between the drip and instant divs (4:1)...\r\n        addToDripPool(_undividedDividends);\r\n        \r\n        // Tell the network, and trigger a distribution\r\n        emit onWithdraw( _user, _amount, _taxedTokens, block.timestamp);\r\n        \r\n        // Trigger a distribution for everyone, kind soul!\r\n        distribute();\r\n    }\r\n\r\n    // Set action percentages\r\n    function setActionAmounts(uint16 _compound, uint16 _withdraw, uint16 _airdrop) public returns (bool success) {\r\n        address _user = msg.sender;\r\n\r\n        require(_compound + _withdraw + _airdrop == oneHundred, \"SET_CORRECT_RATIO\");\r\n\r\n        _setAmounts(_user, _compound, _withdraw, _airdrop);\r\n\r\n        return true;\r\n    }\r\n\r\n    // Compound + Withdraw in one function. Forces users to take profits.\r\n    function doAction() external returns (bool success) {\r\n        address _user = msg.sender;\r\n        \r\n        success = _doActions(_user);\r\n        require(success, \"DO_ACTIONS_FAILED\");\r\n\r\n        return true;\r\n    }\r\n\r\n    // Send airdrop to an array of addresses\r\n    function airdrop(address[] memory _recipients, uint256 _amount) external returns (bool success) {\r\n\r\n        address _addr = msg.sender;\r\n        uint256 airdropBalance = airdropBalanceOf(_addr);\r\n        require(airdropBalance \u003e= _amount, \"INSUFFICIENT_FUNDS\");\r\n        uint256 airdropPerUser = _amount.div(_recipients.length);\r\n\r\n        for (uint i = 0; i \u003c _recipients.length; i++) {\r\n            airdrops[_recipients[i]].pending += airdropPerUser;\r\n        }\r\n\r\n        airdrops[_addr].airdrops += _amount;\r\n        airdrops[_addr].last_airdrop = block.timestamp;\r\n        airdrops[_addr].ready -= _amount;\r\n\r\n        emit onAirdrop(_addr, _amount, block.timestamp);\r\n        return true;\r\n    }\r\n\r\n    //////////////////////////\r\n    // RESTRICTED FUNCTIONS //\r\n    //////////////////////////\r\n\r\n    // Do action for another address, according to its preferences\r\n    function doActionFor(address _user) external onlyWhitelisted() returns (bool success) {\r\n        success = _doActions(_user);\r\n        require(success, \"DO_ACTIONS_FAILED\");\r\n    }\r\n\r\n    // Set amounts for another address, defining its preferences\r\n    function setAmountsFor(address _user, uint16 _compound, uint16 _withdraw, uint16 _airdrop) external onlyWhitelisted() returns (bool success) {\r\n        success = _setAmounts(_user, _compound, _withdraw, _airdrop);\r\n        require(success, \"SET_AMOUNTS_FAILED\");\r\n    }\r\n\r\n    ////////////////////////////////////\r\n    // PRIVATE / INTERNAL FUNCTIONS   //\r\n    ////////////////////////////////////\r\n\r\n    // Distribute rewards to all holders\r\n    function distribute() internal {\r\n        uint256 currentTotalStaked = totalStaked();\r\n        uint256 _currentTimestamp = (block.timestamp);\r\n        \r\n        // Log the event, if it\u0027s time to do so...\r\n        if (_currentTimestamp.sub(lastDistributionTime) \u003e distributionFrequency) {\r\n            \r\n            // Tell the network...\r\n            emit onDistribute(msg.sender, totalStaked(), _currentTimestamp);\r\n            \r\n            // Update the time this was last updated...\r\n            lastDistributionTime = _currentTimestamp;\r\n        }\r\n\r\n        // If there\u0027s any time difference...\r\n        if (_currentTimestamp.sub(lastPayoutTimestamp) \u003e payoutFrequency \u0026\u0026 currentTotalStaked \u003e 0) {\r\n            \r\n            // Calculate shares and profits...\r\n            uint256 share = dripPoolBalance.mul(dripRate).div(oneHundred).div(24 hours);\r\n            uint256 profit = share * _currentTimestamp.sub(lastPayoutTimestamp);\r\n            \r\n            // Subtract from drip pool balance and add to all user earnings\r\n            dripPoolBalance = dripPoolBalance.sub(profit);\r\n            profitPerShare_ = profitPerShare_.add((profit * magnitude) / currentTotalStaked);\r\n            \r\n            // Update the last payout timestamp\r\n            lastPayoutTimestamp = _currentTimestamp;\r\n        }\r\n    }\r\n\r\n    // Allocate fees to the drip pool\r\n    function addToDripPool(uint amount) internal {\r\n        dripPoolBalance = dripPoolBalance.add(amount);\r\n    }\r\n\r\n    // Do actions (compound \u0026 withdraw)\r\n    function _doActions(address _user) internal returns (bool) {\r\n        uint256 _dividends = dividendsOf(_user);\r\n\r\n        (uint16 _compound, uint16 _withdraw, uint16 _airdrop) = getActionAmounts(_user);\r\n\r\n        if (_compound == 0 \u0026\u0026 _withdraw == 0) {\r\n            _compound == 6000;\r\n            _withdraw == 4000;\r\n            _airdrop == 0;\r\n        }\r\n\r\n        uint256 toCompound = _dividends.mul(_compound).div(oneHundred);\r\n        uint256 toWithdraw = _dividends.mul(_withdraw).div(oneHundred);\r\n        uint256 toAirdrop = _dividends.mul(_airdrop).div(oneHundred);\r\n\r\n        if (toCompound \u003e 0) {\r\n            _compoundFor(_user, toCompound);\r\n        }\r\n\r\n        if (toWithdraw \u003e 0) {\r\n            _harvestFor(_user, toWithdraw);\r\n        }\r\n\r\n        if (toAirdrop \u003e 0) {\r\n            _addToAirdrops(_user, toAirdrop);\r\n        }\r\n\r\n        distribute();\r\n\r\n        emit onDoActions(msg.sender, toCompound, toWithdraw, block.timestamp);\r\n        return true;\r\n    }\r\n\r\n    // Send specified token amount supplying an upline referral\r\n    function receiveAirdrops(address _to, uint256 _amount) internal {\r\n\r\n        //User stats\r\n        airdrops[_to].pending = 0;\r\n        airdrops[_to].airdrops_received += _amount;\r\n\r\n        //Keep track of overall stats\r\n        totalAirdrops += _amount;\r\n    }\r\n\r\n    // Set amounts (compound \u0026 withdraw ratio)\r\n    function _setAmounts(address _user, uint16 _compound, uint16 _withdraw, uint16 _airdrop) internal returns (bool) {\r\n        ActionConfig storage actionCfg = actionCfg_[_user];\r\n\r\n        actionCfg.compound = _compound;\r\n        actionCfg.withdraw = _withdraw;\r\n        actionCfg.airdrop = _airdrop;\r\n\r\n        emit onSetAmounts(msg.sender, _compound, _withdraw, _airdrop, block.timestamp);\r\n        return true;\r\n    }\r\n    \r\n    // Deposit Tokens to an address\r\n    function _depositTokens(address _recipient, uint256 _amount) internal returns (uint256) {\r\n\r\n        uint256 currentTotalStaked = totalStaked();\r\n        uint256 _undividedDividends = _amount.mul(divsFee).div(oneHundred);\r\n        uint256 _tokens = _amount.sub(_undividedDividends);\r\n\r\n        // There needs to be something being added in this call...\r\n        require(_tokens \u003e 0 \u0026\u0026 _tokens.add(currentTotalStaked) \u003e currentTotalStaked);\r\n        \r\n        // Allocate fees, and balance to the recipient\r\n        addToDripPool(_undividedDividends);\r\n\r\n        _mint(_recipient, _tokens);\r\n        \r\n        // Updated payouts...\r\n        int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens);\r\n        \r\n        // Update stats...\r\n        payoutsOf_[_recipient] += _updatedPayouts;\r\n        accountOf_[_recipient].deposited += _amount;\r\n        accountOf_[_recipient].xInvested += 1;\r\n\r\n        // Successful function - how many \"shares\" generated?\r\n        emit onDeposit(_recipient, _amount, _tokens, block.timestamp);\r\n        return _tokens;\r\n    }\r\n\r\n    // Compound earnings for an address\r\n    function _compoundFor(address _user, uint256 _dividends) internal {\r\n        payoutsOf_[_user] += (int256) (_dividends * magnitude);\r\n        \r\n        _depositTokens(msg.sender, _dividends);\r\n        \r\n        // Then update the stats...\r\n        accountOf_[_user].compounded = accountOf_[_user].compounded.add(_dividends);\r\n        accountOf_[_user].xCompounded += 1;\r\n    }\r\n\r\n    // Harvest earnings for an address\r\n    function _harvestFor(address _user, uint256 _dividends) internal {\r\n        \r\n        // Calculate the payout, add it to the user\u0027s total paid out accounting...\r\n        payoutsOf_[_user] += (int256) (_dividends * magnitude);\r\n        \r\n        // Pay the user their tokens to their wallet\r\n        token.transfer(_user, _dividends);\r\n\r\n        // Update accounting for user/total withdrawal stats...\r\n        accountOf_[_user].withdrawn = accountOf_[_user].withdrawn.add(_dividends);\r\n        accountOf_[_user].xWithdrawn += 1;\r\n        \r\n        // Update total Tx\u0027s and claims stats\r\n        totalTxs += 1;\r\n        totalClaims += _dividends;\r\n    }\r\n\r\n    // Add amount to airdroppable balance for an address\r\n    function _addToAirdrops(address _user, uint256 _amount) internal {\r\n        // Add _amount to _user\u0027s airdroppable balance\r\n        airdrops[_user].ready += _amount;\r\n    }\r\n\r\n    // Before transfer override\r\n    function _beforeTokenTransfer(address from, address to, uint256) internal override {\r\n        uint256 senderDividends = dividendsOf(from);\r\n        uint256 receiverDividends = dividendsOf(to);\r\n\r\n        if (senderDividends \u003e 0) {\r\n            _harvestFor(from, senderDividends);\r\n        }\r\n\r\n        if (receiverDividends \u003e 0) {\r\n            _harvestFor(to, receiverDividends);\r\n        }\r\n\r\n        // Count user if they\u0027re new...\r\n        if (accountOf_[to].deposited == 0 \u0026\u0026 accountOf_[to].receivedShares == 0) {\r\n            users += 1;\r\n        }\r\n    }\r\n\r\n    // After transfer override\r\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal override {\r\n        // Adjust payout ratios to match the new balances...\r\n        payoutsOf_[from] -= (int256) (profitPerShare_ * amount);\r\n        payoutsOf_[to] += (int256) (profitPerShare_ * amount);\r\n        \r\n        // Update stats...\r\n        accountOf_[from].xTransferredShares += 1;\r\n        accountOf_[from].transferredShares += amount;\r\n        accountOf_[to].receivedShares += amount;\r\n        accountOf_[to].xReceivedShares += 1;\r\n        \r\n        // Add this to the Tx counter...\r\n        totalTxs += 1;\r\n    }\r\n\r\n    // Can recover any token except the staked token\r\n    function canRecoverTokens(IERC20 _token) internal override view returns (bool) { \r\n        return address(_token) != address(token); \r\n    }\r\n}"},"Strings.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp \u003e\u003e= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i \u003e 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value \u0026 0xf];\n            value \u003e\u003e= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}"},"SwapLibrary.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\nimport \"./SafeMath.sol\";\r\n\r\nimport \"./ISwapPair.sol\";\r\n\r\nlibrary SwapLibrary {\r\n    using SafeMath for uint;\r\n\r\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\r\n        require(tokenA != tokenB, \u0027SwapLibrary: IDENTICAL_ADDRESSES\u0027);\r\n        (token0, token1) = tokenA \u003c tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), \u0027SwapLibrary: ZERO_ADDRESS\u0027);\r\n    }\r\n\r\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\r\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\r\n        pair = address(uint(keccak256(abi.encodePacked(\r\n                hex\u0027ff\u0027,\r\n                factory,\r\n                keccak256(abi.encodePacked(token0, token1)),\r\n                hex\u002700fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5\u0027 // init code hash\r\n            ))));\r\n    }\r\n\r\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\r\n        (address token0,) = sortTokens(tokenA, tokenB);\r\n        pairFor(factory, tokenA, tokenB);\r\n        (uint reserve0, uint reserve1,) = ISwapPair(pairFor(factory, tokenA, tokenB)).getReserves();\r\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n    }\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\r\n        require(amountA \u003e 0, \u0027SwapLibrary: INSUFFICIENT_AMOUNT\u0027);\r\n        require(reserveA \u003e 0 \u0026\u0026 reserveB \u003e 0, \u0027SwapLibrary: INSUFFICIENT_LIQUIDITY\u0027);\r\n        amountB = amountA.mul(reserveB) / reserveA;\r\n    }\r\n\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\r\n        require(amountIn \u003e 0, \u0027SwapLibrary: INSUFFICIENT_INPUT_AMOUNT\u0027);\r\n        require(reserveIn \u003e 0 \u0026\u0026 reserveOut \u003e 0, \u0027SwapLibrary: INSUFFICIENT_LIQUIDITY\u0027);\r\n        uint amountInWithFee = amountIn.mul(998);\r\n        uint numerator = amountInWithFee.mul(reserveOut);\r\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\r\n        require(amountOut \u003e 0, \u0027SwapLibrary: INSUFFICIENT_OUTPUT_AMOUNT\u0027);\r\n        require(reserveIn \u003e 0 \u0026\u0026 reserveOut \u003e 0, \u0027SwapLibrary: INSUFFICIENT_LIQUIDITY\u0027);\r\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\r\n        uint denominator = reserveOut.sub(amountOut).mul(998);\r\n        amountIn = (numerator / denominator).add(1);\r\n    }\r\n\r\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\r\n        require(path.length \u003e= 2, \u0027SwapLibrary: INVALID_PATH\u0027);\r\n        amounts = new uint[](path.length);\r\n        amounts[0] = amountIn;\r\n        for (uint i; i \u003c path.length - 1; i++) {\r\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\r\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\r\n        }\r\n    }\r\n\r\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\r\n        require(path.length \u003e= 2, \u0027SwapLibrary: INVALID_PATH\u0027);\r\n        amounts = new uint[](path.length);\r\n        amounts[amounts.length - 1] = amountOut;\r\n        for (uint i = path.length - 1; i \u003e 0; i--) {\r\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\r\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\r\n        }\r\n    }\r\n}"},"TeamSplitter.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\nimport \"./Address.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport \"./SafeERC20.sol\";\r\n\r\nimport \"./TokensRecoverable.sol\";\r\nimport \"./Whitelist.sol\";\r\n\r\ncontract TeamSplitter is Whitelist, TokensRecoverable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n\r\n    mapping (IERC20 =\u003e address[]) public feeCollectors;\r\n    mapping (IERC20 =\u003e uint256[]) public feeRates;\r\n\r\n    constructor() {\r\n    }\r\n\r\n    function setFees(IERC20 token, uint256 burnRate, address[] memory collectors, uint256[] memory rates) public ownerOnly() {\r\n        \r\n        uint256 totalRate = burnRate;\r\n\r\n        for (uint256 i = 0; i \u003c rates.length; i++) {\r\n            totalRate = totalRate + rates[i];\r\n        }\r\n\r\n        require (totalRate == 10000, \"Total fee rate must be 100%\");\r\n        \r\n        if (token.balanceOf(address(this)) \u003e 0) {\r\n            distribute(token);\r\n        }\r\n\r\n        feeCollectors[token] = collectors;\r\n        feeRates[token] = rates;\r\n    }\r\n\r\n    function distribute(IERC20 token) public {\r\n        uint256 balance = token.balanceOf(address(this));\r\n        require (balance \u003e 0, \"Nothing to pay\");\r\n\r\n        address[] memory collectors = feeCollectors[token];\r\n        uint256[] memory rates = feeRates[token];\r\n\r\n        for (uint256 i = 0; i \u003c collectors.length; i++) {\r\n            address collector = collectors[i];\r\n            uint256 rate = rates[i];\r\n\r\n            if (rate \u003e 0) {\r\n                uint256 feeAmount = rate * balance / 10000;\r\n                token.transfer(collector, feeAmount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function canRecoverTokens(IERC20 token) internal override view returns (bool) {\r\n        address[] memory collectors = feeCollectors[IERC20(address(token))];\r\n        return address(token) != address(this) \u0026\u0026 collectors.length == 0; \r\n    }\r\n}"},"TokenMigrator.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nimport \u0027./Address.sol\u0027;\nimport \"./SafeMath.sol\";\nimport \"./SafeERC20.sol\";\n\nimport \u0027./IERC20.sol\u0027;\n\nimport \u0027./Owned.sol\u0027;\nimport \u0027./TokensRecoverable.sol\u0027;\n\ncontract TokenMigrator is Owned, TokensRecoverable {\n    using Address for address;\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public token;\n\n    struct UserData {\n        uint256 amount;\n        uint256 claimed;\n        uint256 lastClaimTimestamp;\n    }\n\n    uint256 public totalClaimed;\n    uint256 public totalClaimers;\n\n    mapping(address =\u003e UserData) public users;\n\n    /////////////////////\n    // CONTRACT EVENTS //\n    /////////////////////\n\n    event ClaimTokens(address indexed user, uint256 amount, uint256 timestamp);\n\n    ////////////////////////////\n    // CONSTRUCTOR \u0026 FALLBACK //\n    ////////////////////////////\n\n    constructor() {\n\n    }\n\n    receive() payable external {\n\n    }\n\n    ////////////////////\n    // VIEW FUNCTIONS //\n    ////////////////////\n\n    // Get balance of the distributed token in this contract\n    function tokenBalance() public view returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    // Get the amount of tokens available for a user to claim\n    function availableOf(address _user) public view returns (uint256) {\n        return (users[_user].amount.sub(users[_user].claimed));\n    }\n\n    // Get the total claimable amount of tokens for a user\n    function claimableOf(address _user) public view returns (uint256) {\n        return (users[_user].amount);\n    }\n\n    // Get the amount of tokens already claimed by a user\n    function claimedOf(address _user) public view returns (uint256) {\n        return (users[_user].claimed);\n    }\n\n    /////////////////////\n    // WRITE FUNCTIONS //\n    /////////////////////\n\n    // Claim tokens\n    function claim() public returns (bool _success) {\n        uint256 amount = availableOf(msg.sender);\n        require(amount \u003e 0, \"Nothing to claim\");\n        \n        users[msg.sender].claimed = users[msg.sender].claimed.add(amount);\n\n        token.transfer(msg.sender, amount);\n\n        totalClaimed = totalClaimed.add(amount);\n        totalClaimers = totalClaimers.add(1);\n\n        users[msg.sender].lastClaimTimestamp = block.timestamp;\n\n        emit ClaimTokens(msg.sender, amount, block.timestamp);\n        return true;\n    }\n\n    //////////////////////////\n    // RESTRICTED FUNCTIONS //\n    //////////////////////////\n\n    // Set token to be claimed\n    function setToken(address _token) public ownerOnly() {\n        token = IERC20(_token);\n    }\n\n    // Add users to the distribution\n    function batchAddUsers(address[] memory _users, uint256[] memory _amounts) public ownerOnly() {\n        require(_users.length == _amounts.length, \"Invalid input\");\n        for (uint256 i = 0; i \u003c _users.length; i++) {\n            _addUser(_users[i], _amounts[i]);\n        }\n    }\n\n    ////////////////////////\n    // INTERNAL FUNCTIONS //\n    ////////////////////////\n\n    function _addUser(address _user, uint256 _amount) internal {\n        users[_user].amount = users[_user].amount.add(_amount);\n    }\n}"},"TokensRecoverable.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nimport \"./SafeERC20.sol\";\n\nimport \"./IERC20.sol\";\nimport \"./ITokensRecoverable.sol\";\n\nimport \"./Owned.sol\";\n\nabstract contract TokensRecoverable is Owned, ITokensRecoverable {\n    using SafeERC20 for IERC20;\n\n    function recoverTokens(IERC20 token) public override ownerOnly() {\n        require (canRecoverTokens(token));\n        token.safeTransfer(msg.sender, token.balanceOf(address(this)));\n    }\n\n    function canRecoverTokens(IERC20 token) internal virtual view returns (bool) { \n        return address(token) != address(this); \n    }\n}"},"UQ112x112.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity \u003e=0.5.16;\n\nlibrary UQ112x112 {\n    uint224 constant Q112 = 2**112;\n\n    function encode(uint112 y) internal pure returns (uint224 z) {\n        z = uint224(y) * Q112;\n    }\n\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\n        z = x / uint224(y);\n    }\n}"},"VaultRewardsManager.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.4;\r\n\r\nimport \"./IStakingToken.sol\";\r\nimport \"./IStakingVault.sol\";\r\n\r\nimport \"./Whitelist.sol\";\r\nimport \"./TokensRecoverable.sol\";\r\n\r\ncontract VaultRewardsManager is Whitelist, TokensRecoverable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n\r\n    IERC20 public token;\r\n    IStakingToken public stake;\r\n\r\n    mapping (IERC20 =\u003e address[]) internal vaults_;\r\n    mapping (IERC20 =\u003e uint256[]) internal rates_;\r\n\r\n    event RewardsDistributed(address indexed token, uint256 amount);\r\n\r\n    constructor(address _token, address _stake) {\r\n        token = IERC20(_token);\r\n        stake = IStakingToken(_stake);\r\n    }\r\n\r\n    ////////////////////\r\n    // VIEW FUNCTIONS //\r\n    ////////////////////\r\n\r\n    function getVaults(address _token) external view returns (address[] memory) {\r\n        return vaults_[IERC20(_token)];\r\n    }\r\n\r\n    function getRates(address _token) external view returns (uint256[] memory) {\r\n        return rates_[IERC20(_token)];\r\n    }\r\n\r\n    //////////////////////\r\n    // PUBLIC FUNCTIONS //\r\n    //////////////////////\r\n\r\n    function prepareRewards() external returns (bool success) {\r\n        uint256 amount = token.balanceOf(address(this));\r\n        require(amount \u003e 0, \"Nothing to prepare\");\r\n\r\n        token.approve(address(stake), type(uint256).max);\r\n        \r\n        success = stake.stake(amount);\r\n        require(success, \"Stake failed\");\r\n    }\r\n\r\n    //////////////////////////\r\n    // RESTRICTED FUNCTIONS //\r\n    //////////////////////////\r\n\r\n    function distribute() external onlyWhitelisted() returns (bool success) {\r\n        uint256 availableRewards = token.balanceOf(address(this));\r\n        require (availableRewards \u003e 0, \"Nothing to pay\");\r\n\r\n        address[] memory vaults = vaults_[token];\r\n        uint256[] memory rates = rates_[token];\r\n\r\n        for (uint256 i = 0; i \u003c vaults.length; i++) {\r\n            address vault = vaults[i];\r\n            uint256 rate = rates[i];\r\n\r\n            if (rate \u003e 0) {\r\n                uint256 feeAmount = rate * availableRewards / 10000;\r\n                IStakingVault(vault).addToRewards(feeAmount);\r\n            }\r\n        }\r\n\r\n        emit RewardsDistributed(address(token), availableRewards);\r\n        return true;\r\n    }\r\n\r\n    //////////////////////////\r\n    // OWNER-ONLY FUNCTIONS //\r\n    //////////////////////////\r\n\r\n    function setToken(address _tokenAddress) public ownerOnly() {\r\n        token = IERC20(_tokenAddress);\r\n    }\r\n\r\n    function setStake(address _stakeAddress) public ownerOnly() {\r\n        stake = IStakingToken(_stakeAddress);\r\n    }\r\n\r\n    function setDistributionRates(address[] memory vaults, uint256[] memory rates) public ownerOnly() {\r\n        \r\n        uint256 points = 0;\r\n\r\n        for (uint256 i = 0; i \u003c rates.length; i++) {\r\n            points = points + rates[i];\r\n        }\r\n\r\n        require (points == 10000, \"Total fee rate must be 100%\");\r\n\r\n        for (uint256 i = 0; i \u003c vaults.length; i++) {\r\n            require (IERC20(address(stake)).approve(vaults[i], type(uint256).max), \"Invalid token\");\r\n        }\r\n\r\n        vaults_[token] = vaults;\r\n        rates_[token] = rates;\r\n    }\r\n}"},"Whitelist.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nimport \"./Owned.sol\";\n\ncontract Whitelist is Owned {\n\n    modifier onlyWhitelisted() {\n        if(active){\n            require(whitelist[msg.sender], \u0027not whitelisted\u0027);\n        }\n        _;\n    }\n\n    bool active = true;\n\n    mapping(address =\u003e bool) public whitelist;\n\n    event WhitelistedAddressAdded(address addr);\n    event WhitelistedAddressRemoved(address addr);\n\n    function activateDeactivateWhitelist() public ownerOnly() {\n        active = !active;\n    }\n\n    function addAddressToWhitelist(address addr) public ownerOnly() returns(bool success) {\n        if (!whitelist[addr]) {\n            whitelist[addr] = true;\n            emit WhitelistedAddressAdded(addr);\n            success = true;\n        }\n    }\n\n    function addAddressesToWhitelist(address[] calldata addrs) public ownerOnly() returns(bool success) {\n        for (uint256 i = 0; i \u003c addrs.length; i++) {\n            if (addAddressToWhitelist(addrs[i])) {\n                success = true;\n            }\n        }\n    }\n\n    function removeAddressFromWhitelist(address addr) ownerOnly() public returns(bool success) {\n        if (whitelist[addr]) {\n            whitelist[addr] = false;\n            emit WhitelistedAddressRemoved(addr);\n            success = true;\n        }\n    }\n\n    function removeAddressesFromWhitelist(address[] calldata addrs) ownerOnly() public returns(bool success) {\n        for (uint256 i = 0; i \u003c addrs.length; i++) {\n            if (removeAddressFromWhitelist(addrs[i])) {\n                success = true;\n            }\n        }\n    }\n}"},"WrappedERC20.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.4;\n\nimport \"./SafeMath.sol\";\nimport \"./SafeERC20.sol\";\n\nimport \"./IERC20.sol\";\nimport \"./IWrappedERC20.sol\";\n\nimport \"./TokensRecoverable.sol\";\n\nimport \"./ERC20.sol\";\n\ncontract WrappedERC20 is ERC20, IWrappedERC20, TokensRecoverable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    IERC20 public immutable override wrappedToken;\n\n    constructor (IERC20 _wrappedToken, string memory _name, string memory _symbol) ERC20(_name, _symbol) {        \n        if (_wrappedToken.decimals() != 18) {\n            _setupDecimals(_wrappedToken.decimals());\n        }\n        wrappedToken = _wrappedToken;\n    }\n\n    function depositTokens(uint256 _amount) public override {\n        _beforeDepositTokens(_amount);\n        uint256 myBalance = wrappedToken.balanceOf(address(this));\n        wrappedToken.safeTransferFrom(msg.sender, address(this), _amount);\n        uint256 received = wrappedToken.balanceOf(address(this)).sub(myBalance);\n        _mint(msg.sender, received);\n        emit Deposit(msg.sender, _amount);\n    }\n\n    function withdrawTokens(uint256 _amount) public override {\n        _beforeWithdrawTokens(_amount);\n        _burn(msg.sender, _amount);\n        uint256 myBalance = wrappedToken.balanceOf(address(this));\n        wrappedToken.safeTransfer(msg.sender, _amount);\n        require (wrappedToken.balanceOf(address(this)) == myBalance.sub(_amount), \"Transfer not exact\");\n        emit Withdrawal(msg.sender, _amount);\n    }\n\n    function canRecoverTokens(IERC20 token) internal virtual override view returns (bool) {\n        return token != this \u0026\u0026 token != wrappedToken;\n    }\n\n    function _beforeDepositTokens(uint256 _amount) internal virtual view { }\n    function _beforeWithdrawTokens(uint256 _amount) internal virtual view { }\n}"}}