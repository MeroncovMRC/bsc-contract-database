{"Btree.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.5;\r\n\r\nlibrary Btree {\r\n\r\n    struct Node {\r\n        uint parent;\r\n        uint left;\r\n        uint right;\r\n        bool red;\r\n    }\r\n\r\n    struct Tree {\r\n        uint root;\r\n        mapping(uint =\u003e Node) nodes;\r\n    }\r\n\r\n    uint private constant EMPTY = 0;\r\n\r\n    function first(Tree storage self) internal view returns (uint _key) {\r\n        _key = self.root;\r\n        if (_key != EMPTY) {\r\n            while (self.nodes[_key].left != EMPTY) {\r\n                _key = self.nodes[_key].left;\r\n            }\r\n        }\r\n    }\r\n    function last(Tree storage self) internal view returns (uint _key) {\r\n        _key = self.root;\r\n        if (_key != EMPTY) {\r\n            while (self.nodes[_key].right != EMPTY) {\r\n                _key = self.nodes[_key].right;\r\n            }\r\n        }\r\n    }\r\n    function next(Tree storage self, uint target) internal view returns (uint cursor) {\r\n        require(target != EMPTY);\r\n        if (self.nodes[target].right != EMPTY) {\r\n            cursor = treeMinimum(self, self.nodes[target].right);\r\n        } else {\r\n            cursor = self.nodes[target].parent;\r\n            while (cursor != EMPTY \u0026\u0026 target == self.nodes[cursor].right) {\r\n                target = cursor;\r\n                cursor = self.nodes[cursor].parent;\r\n            }\r\n        }\r\n    }\r\n    function prev(Tree storage self, uint target) internal view returns (uint cursor) {\r\n        require(target != EMPTY);\r\n        if (self.nodes[target].left != EMPTY) {\r\n            cursor = treeMaximum(self, self.nodes[target].left);\r\n        } else {\r\n            cursor = self.nodes[target].parent;\r\n            while (cursor != EMPTY \u0026\u0026 target == self.nodes[cursor].left) {\r\n                target = cursor;\r\n                cursor = self.nodes[cursor].parent;\r\n            }\r\n        }\r\n    }\r\n    function exists(Tree storage self, uint key) internal view returns (bool) {\r\n        return (key != EMPTY) \u0026\u0026 ((key == self.root) || (self.nodes[key].parent != EMPTY));\r\n    }\r\n    function isEmpty(uint key) internal pure returns (bool) {\r\n        return key == EMPTY;\r\n    }\r\n    function getEmpty() internal pure returns (uint) {\r\n        return EMPTY;\r\n    }\r\n    function getNode(Tree storage self, uint key) internal view returns (uint _returnKey, uint _parent, uint _left, uint _right, bool _red) {\r\n        require(exists(self, key));\r\n        return(key, self.nodes[key].parent, self.nodes[key].left, self.nodes[key].right, self.nodes[key].red);\r\n    }\r\n\r\n    function insert(Tree storage self, uint key) internal {\r\n        require(key != EMPTY);\r\n        require(!exists(self, key));\r\n        uint cursor = EMPTY;\r\n        uint probe = self.root;\r\n        while (probe != EMPTY) {\r\n            cursor = probe;\r\n            if (key \u003c probe) {\r\n                probe = self.nodes[probe].left;\r\n            } else {\r\n                probe = self.nodes[probe].right;\r\n            }\r\n        }\r\n        self.nodes[key] = Node({parent: cursor, left: EMPTY, right: EMPTY, red: true});\r\n        if (cursor == EMPTY) {\r\n            self.root = key;\r\n        } else if (key \u003c cursor) {\r\n            self.nodes[cursor].left = key;\r\n        } else {\r\n            self.nodes[cursor].right = key;\r\n        }\r\n        insertFixup(self, key);\r\n    }\r\n    function remove(Tree storage self, uint key) internal {\r\n        require(key != EMPTY);\r\n        require(exists(self, key));\r\n        uint probe;\r\n        uint cursor;\r\n        if (self.nodes[key].left == EMPTY || self.nodes[key].right == EMPTY) {\r\n            cursor = key;\r\n        } else {\r\n            cursor = self.nodes[key].right;\r\n            while (self.nodes[cursor].left != EMPTY) {\r\n                cursor = self.nodes[cursor].left;\r\n            }\r\n        }\r\n        if (self.nodes[cursor].left != EMPTY) {\r\n            probe = self.nodes[cursor].left;\r\n        } else {\r\n            probe = self.nodes[cursor].right;\r\n        }\r\n        uint yParent = self.nodes[cursor].parent;\r\n        self.nodes[probe].parent = yParent;\r\n        if (yParent != EMPTY) {\r\n            if (cursor == self.nodes[yParent].left) {\r\n                self.nodes[yParent].left = probe;\r\n            } else {\r\n                self.nodes[yParent].right = probe;\r\n            }\r\n        } else {\r\n            self.root = probe;\r\n        }\r\n        bool doFixup = !self.nodes[cursor].red;\r\n        if (cursor != key) {\r\n            replaceParent(self, cursor, key);\r\n            self.nodes[cursor].left = self.nodes[key].left;\r\n            self.nodes[self.nodes[cursor].left].parent = cursor;\r\n            self.nodes[cursor].right = self.nodes[key].right;\r\n            self.nodes[self.nodes[cursor].right].parent = cursor;\r\n            self.nodes[cursor].red = self.nodes[key].red;\r\n            (cursor, key) = (key, cursor);\r\n        }\r\n        if (doFixup) {\r\n            removeFixup(self, probe);\r\n        }\r\n        delete self.nodes[cursor];\r\n    }\r\n\r\n    function treeMinimum(Tree storage self, uint key) private view returns (uint) {\r\n        while (self.nodes[key].left != EMPTY) {\r\n            key = self.nodes[key].left;\r\n        }\r\n        return key;\r\n    }\r\n    function treeMaximum(Tree storage self, uint key) private view returns (uint) {\r\n        while (self.nodes[key].right != EMPTY) {\r\n            key = self.nodes[key].right;\r\n        }\r\n        return key;\r\n    }\r\n\r\n    function rotateLeft(Tree storage self, uint key) private {\r\n        uint cursor = self.nodes[key].right;\r\n        uint keyParent = self.nodes[key].parent;\r\n        uint cursorLeft = self.nodes[cursor].left;\r\n        self.nodes[key].right = cursorLeft;\r\n        if (cursorLeft != EMPTY) {\r\n            self.nodes[cursorLeft].parent = key;\r\n        }\r\n        self.nodes[cursor].parent = keyParent;\r\n        if (keyParent == EMPTY) {\r\n            self.root = cursor;\r\n        } else if (key == self.nodes[keyParent].left) {\r\n            self.nodes[keyParent].left = cursor;\r\n        } else {\r\n            self.nodes[keyParent].right = cursor;\r\n        }\r\n        self.nodes[cursor].left = key;\r\n        self.nodes[key].parent = cursor;\r\n    }\r\n    function rotateRight(Tree storage self, uint key) private {\r\n        uint cursor = self.nodes[key].left;\r\n        uint keyParent = self.nodes[key].parent;\r\n        uint cursorRight = self.nodes[cursor].right;\r\n        self.nodes[key].left = cursorRight;\r\n        if (cursorRight != EMPTY) {\r\n            self.nodes[cursorRight].parent = key;\r\n        }\r\n        self.nodes[cursor].parent = keyParent;\r\n        if (keyParent == EMPTY) {\r\n            self.root = cursor;\r\n        } else if (key == self.nodes[keyParent].right) {\r\n            self.nodes[keyParent].right = cursor;\r\n        } else {\r\n            self.nodes[keyParent].left = cursor;\r\n        }\r\n        self.nodes[cursor].right = key;\r\n        self.nodes[key].parent = cursor;\r\n    }\r\n\r\n    function insertFixup(Tree storage self, uint key) private {\r\n        uint cursor;\r\n        while (key != self.root \u0026\u0026 self.nodes[self.nodes[key].parent].red) {\r\n            uint keyParent = self.nodes[key].parent;\r\n            if (keyParent == self.nodes[self.nodes[keyParent].parent].left) {\r\n                cursor = self.nodes[self.nodes[keyParent].parent].right;\r\n                if (self.nodes[cursor].red) {\r\n                    self.nodes[keyParent].red = false;\r\n                    self.nodes[cursor].red = false;\r\n                    self.nodes[self.nodes[keyParent].parent].red = true;\r\n                    key = self.nodes[keyParent].parent;\r\n                } else {\r\n                    if (key == self.nodes[keyParent].right) {\r\n                      key = keyParent;\r\n                      rotateLeft(self, key);\r\n                    }\r\n                    keyParent = self.nodes[key].parent;\r\n                    self.nodes[keyParent].red = false;\r\n                    self.nodes[self.nodes[keyParent].parent].red = true;\r\n                    rotateRight(self, self.nodes[keyParent].parent);\r\n                }\r\n            } else {\r\n                cursor = self.nodes[self.nodes[keyParent].parent].left;\r\n                if (self.nodes[cursor].red) {\r\n                    self.nodes[keyParent].red = false;\r\n                    self.nodes[cursor].red = false;\r\n                    self.nodes[self.nodes[keyParent].parent].red = true;\r\n                    key = self.nodes[keyParent].parent;\r\n                } else {\r\n                    if (key == self.nodes[keyParent].left) {\r\n                      key = keyParent;\r\n                      rotateRight(self, key);\r\n                    }\r\n                    keyParent = self.nodes[key].parent;\r\n                    self.nodes[keyParent].red = false;\r\n                    self.nodes[self.nodes[keyParent].parent].red = true;\r\n                    rotateLeft(self, self.nodes[keyParent].parent);\r\n                }\r\n            }\r\n        }\r\n        self.nodes[self.root].red = false;\r\n    }\r\n\r\n    function replaceParent(Tree storage self, uint a, uint b) private {\r\n        uint bParent = self.nodes[b].parent;\r\n        self.nodes[a].parent = bParent;\r\n        if (bParent == EMPTY) {\r\n            self.root = a;\r\n        } else {\r\n            if (b == self.nodes[bParent].left) {\r\n                self.nodes[bParent].left = a;\r\n            } else {\r\n                self.nodes[bParent].right = a;\r\n            }\r\n        }\r\n    }\r\n    function removeFixup(Tree storage self, uint key) private {\r\n        uint cursor;\r\n        while (key != self.root \u0026\u0026 !self.nodes[key].red) {\r\n            uint keyParent = self.nodes[key].parent;\r\n            if (key == self.nodes[keyParent].left) {\r\n                cursor = self.nodes[keyParent].right;\r\n                if (self.nodes[cursor].red) {\r\n                    self.nodes[cursor].red = false;\r\n                    self.nodes[keyParent].red = true;\r\n                    rotateLeft(self, keyParent);\r\n                    cursor = self.nodes[keyParent].right;\r\n                }\r\n                if (!self.nodes[self.nodes[cursor].left].red \u0026\u0026 !self.nodes[self.nodes[cursor].right].red) {\r\n                    self.nodes[cursor].red = true;\r\n                    key = keyParent;\r\n                } else {\r\n                    if (!self.nodes[self.nodes[cursor].right].red) {\r\n                        self.nodes[self.nodes[cursor].left].red = false;\r\n                        self.nodes[cursor].red = true;\r\n                        rotateRight(self, cursor);\r\n                        cursor = self.nodes[keyParent].right;\r\n                    }\r\n                    self.nodes[cursor].red = self.nodes[keyParent].red;\r\n                    self.nodes[keyParent].red = false;\r\n                    self.nodes[self.nodes[cursor].right].red = false;\r\n                    rotateLeft(self, keyParent);\r\n                    key = self.root;\r\n                }\r\n            } else {\r\n                cursor = self.nodes[keyParent].left;\r\n                if (self.nodes[cursor].red) {\r\n                    self.nodes[cursor].red = false;\r\n                    self.nodes[keyParent].red = true;\r\n                    rotateRight(self, keyParent);\r\n                    cursor = self.nodes[keyParent].left;\r\n                }\r\n                if (!self.nodes[self.nodes[cursor].right].red \u0026\u0026 !self.nodes[self.nodes[cursor].left].red) {\r\n                    self.nodes[cursor].red = true;\r\n                    key = keyParent;\r\n                } else {\r\n                    if (!self.nodes[self.nodes[cursor].left].red) {\r\n                        self.nodes[self.nodes[cursor].right].red = false;\r\n                        self.nodes[cursor].red = true;\r\n                        rotateLeft(self, cursor);\r\n                        cursor = self.nodes[keyParent].left;\r\n                    }\r\n                    self.nodes[cursor].red = self.nodes[keyParent].red;\r\n                    self.nodes[keyParent].red = false;\r\n                    self.nodes[self.nodes[cursor].left].red = false;\r\n                    rotateRight(self, keyParent);\r\n                    key = self.root;\r\n                }\r\n            }\r\n        }\r\n        self.nodes[key].red = false;\r\n    }\r\n}"},"Potionlab.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.5;\r\n\r\nimport \"./Btree.sol\";\r\n\r\ncontract POTIONMINER {\r\n\r\n\tusing Btree for Btree.Tree;\r\n\tmodifier NonReentrant() { require(!LOCKED, \u0027NonReentrant\u0027); LOCKED = true; _; LOCKED = false; }\r\n\tmodifier AdminOnly() { require( msg.sender == PROJECT, \u0027Admin only\u0027 ); _; }\r\n\tmodifier ValidUser() { require( sys_isUser(msg.sender), \u0027Invalid user\u0027 ); _; }\r\n\r\n\tstruct TUser {\r\n\t\tTPlan[]\t\tplans;\r\n\t\tuint\t\tpotions;\r\n\t\tuint\t\textraMult;\r\n\t\tuint\t\tethRewards;\r\n\t\taddress\t\treferrer;\r\n\t\tuint[3]\t\trefCount;\r\n\t\tuint\t\trefRewards;\r\n\t\tuint\t\tsysIngNum;\r\n\t\tuint\t\tsysIngTst;\r\n\t\tuint\t\tingLvlRewarded;\r\n\t\tTUserLot[]\tlots;\r\n\t\tuint\t\tlotsCount;\r\n\t}\r\n\r\n\tstruct TPlan {\r\n\t\tuint\t\tmult;\r\n\t\tuint\t\tworkers;\r\n\t\tuint\t\tworkersInitial;\r\n\t\tuint\t\tstartTime;\r\n\t\tuint\t\tcheckpoint;\r\n\t\tuint\t\ttakenProfitEth;\r\n\t\tuint\t\tfinalProfitEth;\r\n\t}\r\n\r\n\tstruct TUserLot {\r\n\t\tuint\t\tprice;\r\n\t\tuint\t\tgidx;\r\n\t\tuint\t\tcreated;\r\n\t}\r\n\r\n\tstruct TPlayer {\r\n\t\taddress\t\taddr;\r\n\t\tstring\t\tdata;\r\n\t}\r\n\r\n\tstruct TLottery {\r\n\t\tbool\t\tisFinished;\r\n\t\tuint\t\textraMult;\r\n\t\tuint\t\tethReward;\r\n\t\tTPlayer[]\tplayers;\r\n\t\tTPlayer[]\twinners;\r\n\t\tuint\t\tplayersCnt;\r\n\t}\r\n\r\n\tstruct TAuctionLot {\r\n\t\taddress\t\towner;\r\n\t\tuint\t\tprice;\r\n\t\tuint\t\tuidx;\r\n\t\tuint\t\tcreated;\r\n\t}\r\n\r\n\tstruct THistoryDeposit {\r\n\t\taddress\t\tuser;\r\n\t\tuint\t\tmult;\r\n\t\tuint\t\tamount;\r\n\t\tuint\t\ttimestamp;\r\n\t}\r\n\r\n\tstruct THistoryAuction {\r\n\t\taddress\t\tseller;\r\n\t\taddress\t\tbuyer;\r\n\t\tuint\t\tprice;\r\n\t\tuint\t\ttimestamp;\r\n\t}\r\n\r\n\tbool private\t\t\t\t\t\t\tLOCKED;\r\n\tuint private\t\t\t\t\t\t\tLAUNCHED;\r\n\taddress private\t\t\t\t\t\t\tPROJECT;\r\n\tuint private\t\t\t\t\t\t\tDIVIDER =\t\t\t\t\t\t\t1000;\r\n\tuint private\t\t\t\t\t\t\tMINIMAL_DEPOSIT_AMOUNT =\t\t\t10000000000000000;\r\n\tuint private\t\t\t\t\t\t\tPOTION_BASE =\t\t\t\t\t\t1 ether;\r\n\tuint private\t\t\t\t\t\t\tPOTION_RATE =\t\t\t\t\t\t1 ether;\r\n\tuint private\t\t\t\t\t\t\tPOTION_ROOF =\t\t\t\t\t\t1250000000000000000;\r\n\tuint private\t\t\t\t\t\t\tMODEL_POINT_0 =\t\t\t\t\t\t333;\r\n\tuint private\t\t\t\t\t\t\tMODEL_POINT_1 =\t\t\t\t\t\t4095000000;\r\n\tuint private\t\t\t\t\t\t\tMODEL_POINT_2 =\t\t\t\t\t\t934;\r\n\tuint[3] private\t\t\t\t\t\t\tPER_REFERRAL =\t\t\t\t\t\t[70, 30, 20];\r\n\tuint private\t\t\t\t\t\t\tDEFAULT_PLAN_MULT =\t\t\t\t\t2;\r\n\tuint private\t\t\t\t\t\t\tBURN_EXTRAMULT_NUMBER =\t\t\t\t3;\r\n\tuint private\t\t\t\t\t\t\tDEFAULT_PLAN_LENGTH =\t\t\t\t30 days;\r\n\tuint private\t\t\t\t\t\t\tDEFAULT_PLAN_UPGRADE_MULTIPLIER =\t1050;\r\n\tuint private\t\t\t\t\t\t\tINGREDIENT_COOLDOWN_TIME =\t\t\t2 days;\r\n\tuint private\t\t\t\t\t\t\tINGREDIENT_REWARD_TIMEOUT =\t\t\t1 days;\r\n\tuint private\t\t\t\t\t\t\tPER_DEPOSIT_AVG_REWARD_BORDER =\t\t300;\r\n\tuint[6] private\t\t\t\t\t\t\tPER_INGR_DEBUFF =\t\t\t\t\t[0, 300, 400, 500, 600, 800];\r\n\tuint private\t\t\t\t\t\t\tFEE_PROJECT_DEPOSIT_ETH =\t\t\t60;\r\n\tuint private\t\t\t\t\t\t\tFEE_PROJECT_WITHDRAW_ETH =\t\t\t60;\r\n\tmapping (address =\u003e TUser) private\t\tUSERS;\r\n\r\n\tuint private\t\t\t\t\t\t\tLOTTERY_LAST_CREATED;\r\n\tuint private\t\t\t\t\t\t\tLOTTERY_ROUND = 0;\r\n\tmapping(uint =\u003e TLottery) private\t\tLOTTERY;\r\n\tuint private\t\t\t\t\t\t\tLOTTERY_MAX_REWARD =\t\t\t\t10 ether;\r\n\tuint private\t\t\t\t\t\t\tLOTTERY_MAX_EXTRAMULT =\t\t\t\t1;\r\n\tuint private\t\t\t\t\t\t\tLOTTERY_COOLDOWN_TIME =\t\t\t\t3 days;\r\n\r\n\tBtree.Tree\t\t\t\t\t\t\t\tTREE;\r\n\tmapping(uint =\u003e TAuctionLot[]) private\tLOTS;\r\n\tmapping(uint =\u003e uint) private\t\t\tLOTScount;\r\n\r\n\tuint private\t\t\t\t\t\t\tTRAILING_TIMESTEP =\t1 days;\r\n\tmapping (uint =\u003e int) private\t\t\tTRAILING_IO;\r\n\tmapping (uint =\u003e uint) private\t\t\tTRAILING_DEPOSIT;\r\n\r\n\tuint private\t\t\t\t\t\t\tCIRCULATING_POTIONS;\r\n\tuint private\t\t\t\t\t\t\tCIRCULATING_EARNINGS;\r\n\tuint private\t\t\t\t\t\t\tCIRCULATING_WORKERS;\r\n\tuint private\t\t\t\t\t\t\tCIRCULATING_EXTRAMULT;\r\n\tuint private\t\t\t\t\t\t\tCIRCULATING_LOTS;\r\n\r\n\tuint private\t\t\t\t\t\t\tHT_USERS_COUNT;\r\n\tuint private\t\t\t\t\t\t\tHT_TOTAL_DEPOSIT_AMOUNT;\r\n\tuint private\t\t\t\t\t\t\tHT_TOTAL_DEPOSIT_COUNT;\r\n\tuint private\t\t\t\t\t\t\tHT_TOTAL_EARNING_PAYOUT;\r\n\tuint private\t\t\t\t\t\t\tHT_TOTAL_REFERRAL_REWARDS;\r\n\tTHistoryDeposit[] private\t\t\t\tHT_DEPOSIT_HISTORY;\r\n\tTHistoryAuction[] private\t\t\t\tHT_AUCTION_HISTORY;\r\n\r\n\tevent referralAdopted(address referrer, address user);\r\n\tevent referralReward(address user, uint potions);\r\n\tevent ingredientsIdleRewardApplied(uint sysIngNum);\r\n\tevent ingredientsUpgradeOnDeposit();\r\n\tevent ingredientsUpgradeOnRecycle();\r\n\tevent planProfitsCalculated(uint ingredients, uint earnedEth);\r\n\tevent planUpgraded(uint workers, uint addWorkers);\r\n\tevent planDrained();\r\n\tevent lotAdded(address user, uint price);\r\n\tevent lotBought(address buyer, address seller, uint price);\r\n\tevent lotDeleted(address user, uint uidx);\r\n\r\n\tconstructor(address _project) {\r\n\t\tPROJECT = _project;\r\n\t\tsys_lottery_end();\r\n\t}\r\n\r\n\tfunction usr_deposit(address _referrer) public payable NonReentrant {\r\n\t\trequire(msg.value \u003e= MINIMAL_DEPOSIT_AMOUNT, \u0027Deposit amount is too low\u0027);\r\n\t\tif(LAUNCHED == 0) {\r\n\t\t\trequire( msg.sender == PROJECT, \u0027The project is not launched\u0027 );\r\n\t\t\tLAUNCHED = block.timestamp;\r\n\t\t}\r\n\t\tif(!sys_isUser(msg.sender)) {\r\n\t\t\tHT_USERS_COUNT++;\r\n\t\t}\r\n\t\tTUser storage user = USERS[msg.sender];\r\n\t\tsys_setReferrer(msg.sender, _referrer);\r\n\t\tsys_applyUserIngredientsIdleReward(user);\r\n\t\tuint extraMult = ( BURN_EXTRAMULT_NUMBER \u003e 0 ) ? min( user.extraMult, BURN_EXTRAMULT_NUMBER ) : user.extraMult;\r\n\t\tTPlan memory plan = sys_makePlan(extraMult, msg.value);\r\n\t\tsys_createPlan( msg.sender, plan, extraMult );\r\n\t\tsys_upgradeIngedientsOnDeposit( msg.sender, msg.value );\r\n\t\tsys_logTrailingDeposit(msg.value);\r\n\t\tuint fee = msg.value * FEE_PROJECT_DEPOSIT_ETH / DIVIDER;\r\n\t\tpayable(PROJECT).transfer(fee);\r\n\t\tsys_logIncomeOutcome(msg.value - fee, true);\r\n\t\tHT_DEPOSIT_HISTORY.push( THistoryDeposit(msg.sender,plan.mult,msg.value,plan.startTime) );\r\n\t\tHT_TOTAL_DEPOSIT_AMOUNT += msg.value;\r\n\t\tHT_TOTAL_DEPOSIT_COUNT++;\r\n\t\tsys_rate();\r\n\t}\r\n\r\n\tfunction usr_withdraw() public ValidUser NonReentrant {\r\n\t\tTUser storage user = USERS[msg.sender];\r\n\t\tuint ingredients = sys_applyUserIngredientsIdleReward(user);\r\n\t\tuint earnedEth;\r\n\t\tuint earnedPtn;\r\n\t\tfor(uint i=0; i\u003cuser.plans.length; i++) {\r\n\t\t\tTPlan storage plan = user.plans[i];\r\n\t\t\t(uint eth, uint ptn)  = sys_calcPlanProfits( plan, ingredients, true );\r\n\t\t\tplan.takenProfitEth += eth;\r\n\t\t\tplan.checkpoint = block.timestamp;\r\n\t\t\tearnedEth += eth;\r\n\t\t\tearnedPtn += ptn;\r\n\t\t\tif(sys_planDrained(plan)) {\r\n\t\t\t\tsys_burnWorkers(plan);\r\n\t\t\t\temit planDrained();\r\n\t\t\t}\r\n\t\t}\r\n\t\temit planProfitsCalculated(ingredients, earnedEth);\r\n\t\tsys_burnEarnings( earnedEth );\r\n\t\tearnedEth += sys_ptnToEth( user.potions );\r\n\t\tearnedPtn += user.potions;\r\n\t\tsys_burnPotions(msg.sender, user.potions);\r\n\t\tsys_referralRewards( user.referrer, earnedPtn );\r\n\t\tuser.sysIngNum = PER_INGR_DEBUFF.length-1;\r\n\t\tuser.sysIngTst = block.timestamp;\r\n\t\tpayable(msg.sender).transfer( earnedEth );\r\n\t\tuser.ethRewards += earnedEth;\r\n\t\tuint fee = earnedEth * FEE_PROJECT_WITHDRAW_ETH / DIVIDER;\r\n\t\tpayable(PROJECT).transfer(fee);\r\n\t\tsys_logIncomeOutcome(earnedEth + fee, false);\r\n\t\tHT_TOTAL_EARNING_PAYOUT += earnedEth;\r\n\t\tsys_rate();\r\n\t}\r\n\r\n\tfunction usr_recycle() public ValidUser NonReentrant {\r\n\t\tTUser storage user = USERS[msg.sender];\r\n\t\tuint ingredients = sys_applyUserIngredientsIdleReward(user);\r\n\t\tuint earnedPtn;\r\n\t\tuint totalWorkers;\r\n\t\tfor(uint i=0; i\u003cuser.plans.length; i++) {\r\n\t\t\tTPlan storage plan = user.plans[i];\r\n\t\t\t(uint eth,uint ptn)  = sys_calcPlanProfits( plan, ingredients, false );\r\n\t\t\tplan.finalProfitEth += sys_mintEarnings(eth);\r\n\t\t\tplan.checkpoint = block.timestamp;\r\n\t\t\tearnedPtn += ptn;\r\n\t\t\ttotalWorkers += plan.workers;\r\n\t\t}\r\n\t\tearnedPtn += user.potions;\r\n\t\tsys_burnPotions(msg.sender, user.potions);\r\n\t\tsys_referralRewards( user.referrer, earnedPtn );\r\n\t\tsys_upgradeIngedientsOnRecycle(msg.sender);\r\n\t\tfor(uint i=0; i\u003cuser.plans.length; i++) {\r\n\t\t\tif(!sys_planDrained(user.plans[i])) {\r\n\t\t\t\tuint addWorkers = sys_mintWorkers( sys_ptnToWrk( ( earnedPtn * user.plans[i].workers * DEFAULT_PLAN_UPGRADE_MULTIPLIER ) / ( DIVIDER * totalWorkers  ) ) );\r\n\t\t\t\temit planUpgraded(user.plans[i].workers, addWorkers);\r\n\t\t\t\tuser.plans[i].workers += addWorkers;\r\n\t\t\t}\r\n\t\t}\r\n\t\tsys_rate();\r\n\t}\r\n\r\n\tfunction usr_auction_add(uint _price) public ValidUser NonReentrant {\r\n\t\tTUser storage user = USERS[msg.sender];\r\n\t\trequire( user.extraMult \u003e 0, \u0027You have no extra mult\u0027 );\r\n\t\trequire( _price \u003e 0 , \u0027Price is too low\u0027 ); \r\n\t\tuser.extraMult -= 1;\r\n\t\tsys_addLot( _price, msg.sender );\r\n\t\temit lotAdded(msg.sender, _price);\r\n\t}\r\n\r\n\tfunction usr_auction_del(uint _uidx) public ValidUser NonReentrant {\r\n\t\tsys_delLot( msg.sender, _uidx, true );\r\n\t\temit lotDeleted(msg.sender, _uidx);\r\n\t}\r\n\r\n\tfunction usr_auction_buy(uint _price) public payable ValidUser NonReentrant {\r\n\t\trequire( msg.value \u003e= _price, \u0027Insufficient amount\u0027 );\r\n\t\trequire( LOTScount[_price] \u003e 0, \u0027No lots with such price\u0027 );\r\n\t\tpayable(LOTS[_price][0].owner).transfer( _price );\r\n\t\tUSERS[msg.sender].extraMult += 1;\r\n\t\tHT_AUCTION_HISTORY.push( THistoryAuction( LOTS[_price][0].owner, msg.sender, _price, block.timestamp ) );\r\n\t\temit lotBought(msg.sender, LOTS[_price][0].owner, _price);\r\n\t\tsys_delLot( LOTS[_price][0].owner, LOTS[_price][0].uidx, false  );\r\n\t}\r\n\r\n\tfunction adm_lottery_end() public AdminOnly {\r\n\t\tsys_lottery_end();\r\n\t}\r\n\r\n\tfunction adm_lottery_new(uint _ethReward, uint _extraMult) public AdminOnly {\r\n\t\trequire( block.timestamp - LOTTERY_LAST_CREATED \u003e= LOTTERY_COOLDOWN_TIME, \u0027Lottery cooldown\u0027 );\r\n\t\trequire( (_ethReward\u003e0) || (_extraMult\u003e0) , \u0027Either Reward or Extramult should be specified\u0027 );\r\n\t\trequire( (_ethReward \u003c= LOTTERY_MAX_REWARD) \u0026\u0026 (_extraMult \u003c= LOTTERY_MAX_EXTRAMULT) , \u0027Reward or Extramult is to high\u0027 );\r\n\t\tLOTTERY_LAST_CREATED = block.timestamp;\r\n\t\tLOTTERY[LOTTERY_ROUND].isFinished = true;\r\n\t\tLOTTERY_ROUND++;\r\n\t\tTLottery storage lottery = LOTTERY[LOTTERY_ROUND];\r\n\t\tlottery.ethReward = _ethReward;\r\n\t\tlottery.extraMult = _extraMult;\r\n\t}\r\n\r\n\tfunction adm_lottery_add(address _user, string calldata _data) public AdminOnly {\r\n\t\tTLottery storage lottery = LOTTERY[LOTTERY_ROUND];\r\n\t\trequire( (LOTTERY_ROUND\u003e0) \u0026\u0026 (!lottery.isFinished), \u0027Lottery is finished\u0027 );\r\n\t\trequire( sys_isUser(_user), \u0027Invalid user\u0027 );\r\n\t\tTPlayer memory newPlayer = TPlayer(_user,_data);\r\n\t\tif(lottery.playersCnt \u003e= lottery.players.length) {\r\n\t\t\tlottery.players.push( newPlayer );\r\n\t\t} else {\r\n\t\t\tlottery.players[lottery.playersCnt] = newPlayer;\r\n\t\t}\r\n\t\tlottery.playersCnt++;\r\n\t}\r\n\r\n\tfunction adm_lottery_del(address _user, bool _useIdx, uint _idx) public AdminOnly {\r\n\t\tTLottery storage lottery = LOTTERY[LOTTERY_ROUND];\r\n\t\tuint idx;\r\n\t\tif(!_useIdx) {\r\n\t\t\tbool found;\r\n\t\t\tfor(uint i=0;i\u003clottery.playersCnt;i++) {\r\n\t\t\t\tif(lottery.players[i].addr == _user) {\r\n\t\t\t\t\tfound = true;\r\n\t\t\t\t\tidx = i;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\trequire(found, \u0027User not found\u0027 );\r\n\t\t}\r\n\t\telse {\r\n\t\t\tidx = _idx;\r\n\t\t}\r\n\t\tif(idx != lottery.playersCnt-1) {\r\n\t\t\tlottery.players[idx] = lottery.players[lottery.playersCnt-1];\r\n\t\t}\r\n\t\tlottery.playersCnt--;\r\n\t}\r\n\r\n\tfunction adm_lottery_run() public AdminOnly {\r\n\t\tTLottery storage lottery = LOTTERY[LOTTERY_ROUND];\r\n\t\trequire( (LOTTERY_ROUND\u003e0) \u0026\u0026 (!lottery.isFinished), \u0027Lottery is finished\u0027 );\r\n\t\tuint idx = sys_randomBetween(0,lottery.playersCnt-1);\r\n\t\tTPlayer storage winner = lottery.players[idx];\r\n\t\tlottery.winners.push(winner);\r\n\t\tif(lottery.extraMult \u003e 0) {\r\n\t\t\tsys_mintExtramult( USERS[winner.addr], lottery.extraMult );\r\n\t\t}\r\n\t\tif(lottery.ethReward \u003e 0) {\r\n\t\t\tpayable(winner.addr).transfer(lottery.ethReward);\r\n\t\t}\r\n\t\tadm_lottery_del(winner.addr, true, idx);\r\n\t}\r\n\r\n\tstruct TAuctionData {\r\n\t\tTAuctionLot[20] lots;\r\n\t\tuint\t\t\tcount;\r\n\t\tuint\t\t\ttotal;\r\n\t}\r\n\r\n\tstruct TDATA_OBS {\r\n\t\tuint\t\t\t\ttimestamp;\r\n\t\tuint\t\t\t\tbalance;\r\n\t\tuint\t\t\t\tMINIMAL_DEPOSIT_AMOUNT;\r\n\t\tuint\t\t\t\tINGREDIENT_COOLDOWN_TIME;\r\n\t\tuint\t\t\t\tINGREDIENT_REWARD_TIMEOUT;\r\n\t\tuint\t\t\t\tPOTION_RATE;\r\n\t\tuint\t\t\t\tDEPOSIT_AVG_BORDER;\r\n\t\tuint\t\t\t\tHT_USERS_COUNT;\r\n\t\tTHistoryDeposit[50]\tHT_DEPOSIT_HISTORY;\r\n\t\tTHistoryAuction[50]\tHT_AUCTION_HISTORY;\r\n\t\tuint\t\t\t\tHT_TOTAL_DEPOSIT_AMOUNT;\r\n\t\tuint\t\t\t\tHT_TOTAL_DEPOSIT_COUNT;\r\n\t\tuint\t\t\t\tHT_TOTAL_EARNING_PAYOUT;\r\n\t\tuint\t\t\t\tHT_TOTAL_REFERRAL_REWARDS;\r\n\t}\r\n\r\n\tfunction pub_dashboard_OBS() public view returns(TDATA_OBS memory o_MAIN, TAuctionData memory o_AUCTION, TLottery memory o_LOTTERY) {\r\n\t\tTHistoryDeposit[50] memory historyDepositTail;\r\n\t\tif(HT_DEPOSIT_HISTORY.length \u003e 0) {\r\n\t\t\tuint dlast = HT_DEPOSIT_HISTORY.length-1;\r\n\t\t\tfor(uint i=0; i\u003c50; i++) {\r\n\t\t\t\tif(dlast\u003ci) break;\r\n\t\t\t\thistoryDepositTail[i] = HT_DEPOSIT_HISTORY[dlast-i];\r\n\t\t\t}\r\n\t\t}\r\n\t\tTHistoryAuction[50] memory historyAuctionTail;\r\n\t\tif(HT_AUCTION_HISTORY.length \u003e 0) {\r\n\t\t\tuint alast = HT_AUCTION_HISTORY.length-1;\r\n\t\t\tfor(uint i=0; i\u003c50; i++) {\r\n\t\t\t\tif(alast\u003ci) break;\r\n\t\t\t\thistoryAuctionTail[i] = HT_AUCTION_HISTORY[alast-i];\r\n\t\t\t}\r\n\t\t}\r\n\t\to_MAIN = TDATA_OBS(\r\n\t\t\tblock.timestamp,\r\n\t\t\taddress(this).balance,\r\n\t\t\tMINIMAL_DEPOSIT_AMOUNT,\r\n\t\t\tINGREDIENT_COOLDOWN_TIME,\r\n\t\t\tINGREDIENT_REWARD_TIMEOUT,\r\n\t\t\tPOTION_RATE,\r\n\t\t\tsys_getDepositAvg()*PER_DEPOSIT_AVG_REWARD_BORDER/DIVIDER,\r\n\t\t\tHT_USERS_COUNT,\r\n\t\t\thistoryDepositTail,\r\n\t\t\thistoryAuctionTail,\r\n\t\t\tHT_TOTAL_DEPOSIT_AMOUNT,\r\n\t\t\tHT_TOTAL_DEPOSIT_COUNT,\r\n\t\t\tHT_TOTAL_EARNING_PAYOUT,\r\n\t\t\tHT_TOTAL_REFERRAL_REWARDS\r\n\t\t);\r\n\t\tuint price = TREE.first();\r\n\t\twhile( (price\u003e0) \u0026\u0026 (o_AUCTION.count\u003c20) ) {\r\n\t\t\to_AUCTION.lots[o_AUCTION.count] = LOTS[price][0];\r\n\t\t\to_AUCTION.count++;\r\n\t\t\tprice = TREE.next(price);\r\n\t\t}\r\n\t\to_AUCTION.total = CIRCULATING_LOTS;\r\n\t\treturn ( o_MAIN, o_AUCTION, LOTTERY[LOTTERY_ROUND] );\r\n\t}\r\n\r\n\tstruct TPlanProfits {\r\n\t\tuint ethLeftProfits;\r\n\t\tuint ethF;\r\n\t\tuint ptnF;\r\n\t\tuint ethD;\r\n\t\tuint ptnD;\r\n\t}\r\n\r\n\tstruct TUserAuction {\r\n\t\tTUserLot[] lots;\r\n\t\tuint count;\r\n\t}\r\n\r\n\tstruct TDATA_USR {\r\n\t\tuint\t\t\ttimestamp;\r\n\t\tbool\t\t\tisUser;\r\n\t\tuint\t\t\tpotions;\r\n\t\tuint\t\t\tpotionsEthValue;\r\n\t\tuint\t\t\textraMult;\r\n\t\tuint\t\t\tethRewards;\r\n\t\taddress\t\t\treferrer;\r\n\t\tuint[3]\t\t\trefCount;\r\n\t\tuint\t\t\trefRewards;\r\n\t\tuint\t\t\tsysIngNum;\r\n\t\tuint\t\t\tsysIngTst;\r\n\t\tuint\t\t\tingLvlRewarded;\r\n\t\tuint\t\t\tingredients;\r\n\t\tuint\t\t\tplanCount;\r\n\t\tuint\t\t\tplanWorkers;\r\n\t\tTPlanProfits\tplanProfits;\r\n\t}\r\n\r\n\tfunction pub_dashboard_USR() public view returns(TDATA_USR memory o_MAIN, TUserAuction memory o_AUCTION) {\r\n\t\tTUser storage user = USERS[msg.sender];\r\n\t\tTPlanProfits memory planProfits;\r\n\t\tuint ingredients = sys_userIngredients(msg.sender);\r\n\t\tuint pcnt;\r\n\t\tuint wcnt;\r\n\t\tfor(uint i=0;i\u003cuser.plans.length;i++) {\r\n\t\t\tif(sys_planDrained(user.plans[i])) { continue; }\r\n\t\t\tpcnt++;\r\n\t\t\twcnt += user.plans[i].workers;\r\n\t\t\tplanProfits.ethLeftProfits += (user.plans[i].finalProfitEth - user.plans[i].takenProfitEth);\r\n\t\t\t(uint eF, uint pF) = sys_calcPlanProfits( user.plans[i], 0, false );\r\n\t\t\t(uint eD, uint pD) = sys_calcPlanProfits( user.plans[i], ingredients, true );\r\n\t\t\tplanProfits.ethF += eF;\r\n\t\t\tplanProfits.ptnF += pF;\r\n\t\t\tplanProfits.ethD += eD;\r\n\t\t\tplanProfits.ptnD += pD;\r\n\t\t}\r\n\t\to_MAIN = TDATA_USR(\r\n\t\t\tblock.timestamp,\r\n\t\t\tsys_isUser(msg.sender),\r\n\t\t\tuser.potions,\r\n\t\t\tsys_ptnToEth(user.potions),\r\n\t\t\tuser.extraMult,\r\n\t\t\tuser.ethRewards,\r\n\t\t\tuser.referrer,\r\n\t\t\tuser.refCount,\r\n\t\t\tuser.refRewards,\r\n\t\t\tuser.sysIngNum,\r\n\t\t\tuser.sysIngTst,\r\n\t\t\tuser.ingLvlRewarded,\r\n\t\t\tingredients,\r\n\t\t\tpcnt,\r\n\t\t\twcnt,\r\n\t\t\tplanProfits\r\n\t\t);\r\n\t\to_AUCTION.lots = user.lots;\r\n\t\to_AUCTION.count = user.lotsCount;\r\n\t}\r\n\tstruct TActivePlan {\r\n\t\tuint\t\t\tmult;\r\n\t\tuint\t\t\tworkers;\r\n\t\tuint\t\t\tworkersInitial;\r\n\t\tuint\t\t\tstartTime;\r\n\t\tuint\t\t\tcheckpoint;\r\n\t\tuint\t\t\tfinalProfitEth;\r\n\t\tuint\t\t\ttakenProfitEth;\r\n\t\tTPlanProfits\tplanProfits;\r\n\t}\r\n\r\n\tfunction pub_dashboard_PLANS() public view returns(uint o_timestamp, uint o_count, TActivePlan[] memory o_plans) {\r\n\t\tTUser storage user = USERS[msg.sender];\r\n\t\tfor(uint i=0; i\u003cuser.plans.length; i++) {\r\n\t\t\tif(!sys_planDrained(user.plans[i])) { o_count++; }\r\n\t\t}\r\n\t\tTActivePlan[] memory activePlans = new TActivePlan[](o_count);\r\n\t\tuint cnt;\r\n\t\tuint ingredients = sys_userIngredients(msg.sender);\r\n\t\tfor(uint i=0; i\u003cuser.plans.length; i++) {\r\n\t\t\tTPlan storage p = user.plans[i];\r\n\t\t\tif(sys_planDrained(p)) { continue; }\r\n\t\t\tTPlanProfits memory planProfits;\r\n\t\t\tplanProfits.ethLeftProfits = (p.finalProfitEth - p.takenProfitEth);\r\n\t\t\t(planProfits.ethF, planProfits.ptnF) = sys_calcPlanProfits( p, 0, false );\r\n\t\t\t(planProfits.ethD, planProfits.ptnD) = sys_calcPlanProfits( p, ingredients, true );\r\n\t\t\tactivePlans[cnt] = TActivePlan( p.mult, p.workers, p.workersInitial, p.startTime, p.checkpoint, p.finalProfitEth, p.takenProfitEth, planProfits );\r\n\t\t\tcnt++;\r\n\t\t}\r\n\t\treturn (block.timestamp, o_count, activePlans);\r\n\t}\r\n\r\n\tfunction pub_getUserAvailable(address _user) public view returns(uint o_eth) {\r\n\t\tTUser storage user = USERS[msg.sender];\r\n\t\tuint ingredients = sys_userIngredients(_user);\r\n\t\tfor(uint i=0;i\u003cuser.plans.length;i++) {\r\n\t\t\tif(sys_planDrained(user.plans[i])) { continue; }\r\n\t\t\t(uint eth,) = sys_calcPlanProfits( user.plans[i], ingredients, true );\r\n\t\t\to_eth += eth;\r\n\t\t}\r\n\t\to_eth += sys_ptnToEth(user.potions);\r\n\t}\r\n\r\n\tstruct TStatsData {\r\n\t\tTUser\t\t\tUSERS;\r\n\t\tTLottery\t\tLOTTERY;\r\n\t\tTAuctionLot[]\tLOTS;\r\n\t\tuint\t\t\tLOTScount;\r\n\t\tint\t\t\t\tTRAILING_IO;\r\n\t\tuint\t\t\tTRAILING_DEPOSIT;\r\n\t\tuint\t\t\tCIRCULATING_POTIONS;\r\n\t\tuint\t\t\tCIRCULATING_EARNINGS;\r\n\t\tuint\t\t\tCIRCULATING_WORKERS;\r\n\t\tuint\t\t\tCIRCULATING_EXTRAMULT;\r\n\t\tuint\t\t\tCIRCULATING_LOTS;\r\n\t}\r\n\r\n\tfunction pub_dashboard_STATS(address _user, uint _lotteryRound, uint _lotsPrice, uint _trailingIdx) public view returns(uint o_timestamp, TStatsData memory o_MAIN) {\r\n\t\to_MAIN = TStatsData(\r\n\t\t\tUSERS[_user],\r\n\t\t\tLOTTERY[_lotteryRound],\r\n\t\t\tLOTS[_lotsPrice],\r\n\t\t\tLOTScount[_lotsPrice],\r\n\t\t\tTRAILING_IO[_trailingIdx],\r\n\t\t\tTRAILING_DEPOSIT[_trailingIdx],\r\n\t\t\tCIRCULATING_POTIONS,\r\n\t\t\tCIRCULATING_EARNINGS,\r\n\t\t\tCIRCULATING_WORKERS,\r\n\t\t\tCIRCULATING_EXTRAMULT,\r\n\t\t\tCIRCULATING_LOTS\r\n\t\t);\r\n\t\treturn (block.timestamp, o_MAIN);\r\n\t}\r\n\r\n\tfunction min(uint a, uint b) internal pure returns (uint) {\r\n\t\treturn ( a \u003c b ) ? a : b;\r\n\t}\r\n\r\n\tfunction max(uint a, uint b) internal pure returns (uint) {\r\n\t\treturn ( a \u003c b ) ? b : a;\r\n\t}\r\n\r\n\tfunction sys_randomBetween(uint _min, uint _max) internal view returns (uint o_rnd) {\r\n\t\treturn (uint(keccak256(abi.encodePacked(block.difficulty,block.timestamp,address(this).balance,POTION_RATE))) % (_max+1)) + _min;\r\n\t}\r\n\r\n\tfunction sys_ethToPtn(uint _ethAmt) internal view returns (uint o_ptnAmt) {\r\n\t\treturn (_ethAmt * POTION_BASE) / POTION_RATE;\r\n\t}\r\n\r\n\tfunction sys_ptnToEth(uint _ptnAmt) internal view returns (uint o_ethAmt) {\r\n\t\treturn (_ptnAmt * POTION_RATE) / POTION_BASE;\r\n\t}\r\n\r\n\tfunction sys_ptnToWrk(uint _ptnAmt) internal view returns (uint o_wrkAmt) {\r\n\t\treturn _ptnAmt / DEFAULT_PLAN_LENGTH;\r\n\t}\r\n\r\n\tfunction sys_mintPotions(address _user, uint _ptnAmt) internal {\r\n\t\tUSERS[_user].potions += _ptnAmt;\r\n\t\tCIRCULATING_POTIONS += _ptnAmt;\r\n\t}\r\n\r\n\tfunction sys_burnPotions(address _user, uint _ptnAmt) internal {\r\n\t\tUSERS[_user].potions -= _ptnAmt;\r\n\t\tCIRCULATING_POTIONS -= _ptnAmt;\r\n\t}\r\n\r\n\tfunction sys_mintWorkers(uint _wrkAmt) internal returns (uint) {\r\n\t\tCIRCULATING_WORKERS += _wrkAmt;\r\n\t\treturn _wrkAmt;\r\n\t}\r\n\r\n\tfunction sys_burnWorkers(TPlan storage _plan) internal {\r\n \r\n\t\tif(_plan.workers\u003e0) {\r\n\t\t\tCIRCULATING_WORKERS -= _plan.workers;\r\n\t\t\t_plan.workers = 0;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction sys_mintEarnings(uint _ethAmt) internal returns (uint) {\r\n\t\tCIRCULATING_EARNINGS += _ethAmt;\r\n\t\treturn _ethAmt;\r\n\t}\r\n\r\n\tfunction sys_burnEarnings(uint _ethAmt) internal {\r\n\t\tCIRCULATING_EARNINGS -= _ethAmt;\r\n\t}\r\n\r\n\tfunction sys_mintExtramult(TUser storage _user, uint _num) internal {\r\n\t\tCIRCULATING_EXTRAMULT += _num;\r\n\t\t_user.extraMult += _num;\r\n\t}\r\n\r\n\tfunction sys_burnExtramult(TUser storage _user, uint _num) internal {\r\n\t\tCIRCULATING_EXTRAMULT -= _num;\r\n\t\t_user.extraMult -= _num;\r\n\t}\r\n\r\n\tfunction sys_logIncomeOutcome(uint _ethAmt, bool _positive) internal {\r\n\t\tuint slotIdx = block.timestamp / TRAILING_TIMESTEP;\r\n\t\tif(_positive)\t{ TRAILING_IO[slotIdx] += int(_ethAmt); }\r\n\t\t\t\telse\t{ TRAILING_IO[slotIdx] -= int(_ethAmt); }\r\n\t}\r\n\r\n\tfunction sys_logTrailingDeposit(uint _ethAmt) internal {\r\n\t\tuint slotIdx = block.timestamp / TRAILING_TIMESTEP;\r\n\t\tif ( TRAILING_DEPOSIT[slotIdx] \u003c _ethAmt ) {\r\n\t\t\tTRAILING_DEPOSIT[slotIdx] = _ethAmt;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction sys_getDepositAvg() internal view returns (uint o_rangeAvg) {\r\n\t\tuint slotIdx = block.timestamp / TRAILING_TIMESTEP;\r\n\t\tuint totAmt;\r\n\t\tuint dayCnt;\r\n\t\tfor( uint i=0; i\u003c7; i++) {\r\n\t\t\tif(TRAILING_DEPOSIT[slotIdx-i] == 0) continue;\r\n\t\t\ttotAmt += TRAILING_DEPOSIT[slotIdx-i];\r\n\t\t\tdayCnt++;\r\n\t\t}\r\n\t\treturn ( dayCnt \u003e 0 ) ? ( totAmt / dayCnt ) : 0; \r\n\t}\r\n\r\n\tfunction sys_rate() internal {\r\n\t\tif(CIRCULATING_WORKERS==0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tuint span = ( (address(this).balance * DIVIDER) / CIRCULATING_WORKERS ) / DEFAULT_PLAN_LENGTH; \r\n\t\tuint mult = (span \u003c= MODEL_POINT_0) ? ( span**5 ) / MODEL_POINT_1 : (span/5 + MODEL_POINT_2);\r\n\t\tPOTION_RATE = min( POTION_ROOF, max(1, (POTION_BASE * mult) / DIVIDER )  );\r\n\t}\r\n\r\n\tfunction sys_isUser(address _user) internal view returns (bool) {\r\n\t\treturn USERS[_user].plans.length \u003e 0;\r\n\t}\r\n\r\n\tfunction sys_userIngredients(address _user) internal view returns (uint o_ingredients) {\r\n\t\tTUser storage user = USERS[_user];\r\n\t\tuint idleReward = (block.timestamp - user.sysIngTst) / INGREDIENT_COOLDOWN_TIME;\r\n\t\treturn ( user.sysIngNum \u003e idleReward ) ? ( user.sysIngNum - idleReward ) : 0 ;\r\n\t}\r\n\r\n\tfunction sys_setReferrer(address _user, address _referrer) internal returns (address o_referrer) {\r\n\t\tif (USERS[_user].referrer != address(0)) return USERS[_user].referrer;\r\n\t\tif (!sys_isUser(_referrer)) return address(0);\r\n\t\tif (_user == _referrer) return address(0);\r\n\t\tUSERS[_user].referrer = _referrer;\r\n\t\temit referralAdopted(_referrer, _user);\r\n\t\taddress upline = _referrer;\r\n\t\tfor (uint i=0; i \u003c PER_REFERRAL.length; i++) {\r\n\t\t\tif(upline==address(0)) break;\r\n\t\t\tUSERS[upline].refCount[i]++;\r\n\t\t\tupline = USERS[upline].referrer;\r\n\t\t}\r\n\t\treturn _referrer; \r\n\t}\r\n\r\n\tfunction sys_referralRewards(address _referrer, uint _fullPtnAmt) internal {\r\n\t\tuint totalAmt;\r\n\t\taddress upline = _referrer;\r\n\t\tfor (uint i=0; i \u003c PER_REFERRAL.length; i++) {\r\n\t\t\tif (upline == address(0)) break;\r\n\t\t\tuint potionAmt = _fullPtnAmt * PER_REFERRAL[i] / DIVIDER;\r\n\t\t\tsys_mintPotions(upline, potionAmt);\r\n\t\t\tUSERS[upline].refRewards += potionAmt;\r\n\t\t\temit referralReward(upline, potionAmt);\r\n\t\t\tupline = USERS[upline].referrer;\r\n\t\t\ttotalAmt += potionAmt;\r\n\t\t}\r\n\t\tHT_TOTAL_REFERRAL_REWARDS += totalAmt;\r\n\t}\r\n\r\n\tfunction sys_applyUserIngredientsIdleReward(TUser storage user) internal returns (uint o_ingredients) {\r\n\t\tif(user.sysIngTst == 0) {\r\n\t\t\tuser.sysIngNum = PER_INGR_DEBUFF.length-1;\r\n\t\t\tuser.sysIngTst = block.timestamp;\r\n\t\t\treturn user.sysIngNum;\r\n\t\t}\r\n\t\tuint idleReward = (block.timestamp - user.sysIngTst) / INGREDIENT_COOLDOWN_TIME;\r\n\t\tif(idleReward == 0) {\r\n\t\t\treturn user.sysIngNum;\r\n\t\t}\r\n\t\tuser.sysIngNum = ( user.sysIngNum \u003e idleReward ) ? ( user.sysIngNum - idleReward ) : 0 ;\r\n\t\tuser.sysIngTst += idleReward * INGREDIENT_COOLDOWN_TIME; \r\n\t\temit ingredientsIdleRewardApplied(user.sysIngNum);\r\n\t\treturn user.sysIngNum;\r\n\t}\r\n\r\n\tfunction sys_upgradeIngedientsOnDeposit(address _user, uint _ethAmt) internal {\r\n\t\tTUser storage user = USERS[_user];\r\n\t\tif( _ethAmt \u003e= sys_getDepositAvg()*PER_DEPOSIT_AVG_REWARD_BORDER/DIVIDER ) {\r\n\t\t\tif(user.sysIngNum \u003e 0) {\r\n\t\t\t\tuser.sysIngNum=0;\r\n\t\t\t}\r\n\t\t\tuser.sysIngTst = block.timestamp;\r\n\t\t\temit ingredientsUpgradeOnDeposit();\r\n\t\t}\r\n\t}\r\n\r\n\tfunction sys_upgradeIngedientsOnRecycle(address _user) internal {\r\n\t\tTUser storage user = USERS[_user];\r\n\t\tif( (block.timestamp - user.ingLvlRewarded \u003e= INGREDIENT_REWARD_TIMEOUT) \u0026\u0026 (user.sysIngNum \u003e 0) ) {\r\n\t\t\tuser.ingLvlRewarded = block.timestamp;\r\n\t\t\tuser.sysIngNum--;\r\n\t\t\tuser.sysIngTst = block.timestamp;\r\n\t\t\temit ingredientsUpgradeOnRecycle();\r\n\t\t}\r\n\t}\r\n\r\n\tfunction sys_planDrained(TPlan storage _plan) internal view returns (bool) {\r\n\t\treturn (_plan.takenProfitEth \u003e= _plan.finalProfitEth);\r\n\t}\r\n\r\n\tfunction sys_makePlan(uint _extraMult, uint _ethAmt) internal returns (TPlan memory o_plan) {\r\n\t\tuint mult = DEFAULT_PLAN_MULT + _extraMult;\r\n\t\tuint finalProfitEth = sys_mintEarnings( _ethAmt * mult );\r\n\t\tuint workers = sys_mintWorkers( finalProfitEth / DEFAULT_PLAN_LENGTH );\r\n\t\treturn TPlan( mult , workers , workers, block.timestamp, block.timestamp, 0, finalProfitEth );\r\n\t}\r\n\r\n\tfunction sys_createPlan(address _user, TPlan memory _plan, uint _burnExtraMult) internal {\r\n\t\tTUser storage user = USERS[_user];\r\n\t\tbool found;\r\n\t\tfor(uint i=0; i\u003cuser.plans.length; i++) {\r\n\t\t\tif(!sys_planDrained(user.plans[i])) continue;\r\n\t\t\tuser.plans[i] = _plan;\r\n\t\t\tfound = true;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tif(!found) {\r\n\t\t\tuser.plans.push( _plan );\r\n\t\t}\r\n\t\tsys_burnExtramult(user, _burnExtraMult);\r\n\t}\r\n\r\n\tfunction sys_calcPlanProfits(TPlan storage _plan, uint _ingrLevel, bool _debuff) internal view returns (uint o_eth, uint o_ptn) {\r\n\t\tif(sys_planDrained(_plan)) return (0,0);\r\n\t\tuint leftProfitEth = _plan.finalProfitEth - _plan.takenProfitEth;\r\n\t\tuint minedPotions = (block.timestamp - _plan.checkpoint) * _plan.workers;\r\n\t\tif(_debuff) {\r\n\t\t\tminedPotions -= minedPotions * PER_INGR_DEBUFF[_ingrLevel] / DIVIDER;\r\n\t\t}\r\n\t\to_eth = min( leftProfitEth , sys_ptnToEth(minedPotions) );\r\n\t\to_ptn = sys_ethToPtn(o_eth);\r\n\t}\r\n\r\n\tfunction sys_addLot(uint _price, address _owner) internal {\r\n\t\tTUser storage owner = USERS[_owner];\r\n\t\tif(!TREE.exists(_price)) {\r\n\t\t\tTREE.insert(_price);\r\n\t\t}\r\n\t\tuint new_gidx;\r\n\t\tTAuctionLot memory newALot = TAuctionLot( _owner, _price, 0, block.timestamp );\r\n\t\tif(LOTScount[_price] \u003e= LOTS[_price].length) {\r\n\t\t\tnew_gidx = LOTS[_price].length;\r\n\t\t\tLOTS[_price].push( newALot );\r\n\t\t} else {\r\n\t\t\tnew_gidx = LOTScount[_price];\r\n\t\t\tLOTS[_price][new_gidx] = newALot;\r\n\t\t}\r\n\t\tLOTScount[_price]++;\r\n\t\tuint new_uidx;\r\n\t\tTUserLot memory newULot = TUserLot( _price, new_gidx, block.timestamp );\r\n\t\tif(owner.lotsCount \u003e= owner.lots.length) {\r\n\t\t\tnew_uidx = owner.lots.length;\r\n\t\t\towner.lots.push( newULot );\r\n\t\t} else {\r\n\t\t\tnew_uidx = owner.lotsCount;\r\n\t\t\towner.lots[new_uidx] = newULot;\r\n\t\t}\r\n\t\towner.lotsCount++;\r\n\t\tLOTS[_price][new_gidx].uidx = new_uidx;\r\n\t\tCIRCULATING_LOTS++;\r\n\t}\r\n\r\n\tfunction sys_delLot(address _owner, uint _uidx, bool _ownerReturnMult) internal {\r\n\t\trequire( _uidx \u003c USERS[ _owner ].lotsCount, \u0027User lot index does not exist\u0027);\r\n\t\tTUser storage downer = USERS[ _owner ];\r\n\t\tTUserLot storage dulot = downer.lots[_uidx]; \r\n\t\tuint price = dulot.price;\r\n\t\tuint tgidx = LOTScount[price]-1;\r\n\t\tif(dulot.gidx != tgidx) {\r\n\t\t\tTUser storage towner = USERS[ LOTS[price][tgidx].owner ];\r\n\t\t\tTUserLot storage tulot = towner.lots[ LOTS[price][tgidx].uidx ];\r\n\t\t\ttulot.gidx = dulot.gidx;\r\n\t\t\tLOTS[price][dulot.gidx] = LOTS[price][tgidx];\r\n\t\t}\r\n\t\tLOTScount[price]--;\r\n\t\tif(LOTScount[price]==0) {\r\n\t\t\tTREE.remove(price);\r\n\t\t}\r\n\t\tif(_uidx != downer.lotsCount-1) {\r\n\t\t\tTUserLot storage tlot = downer.lots[downer.lotsCount-1];\r\n\t\t\tLOTS[tlot.price][tlot.gidx].uidx = _uidx;\r\n\t\t\tdowner.lots[_uidx] = tlot;\r\n\t\t}\r\n\t\tdowner.lotsCount--;\r\n\t\tif(_ownerReturnMult) {\r\n\t\t\tdowner.extraMult += 1;\r\n\t\t}\r\n\t\tCIRCULATING_LOTS--;\r\n\t}\r\n\r\n\tfunction sys_lottery_end() internal {\r\n\t\tLOTTERY[LOTTERY_ROUND].isFinished = true;\r\n\t}\r\n}"}}