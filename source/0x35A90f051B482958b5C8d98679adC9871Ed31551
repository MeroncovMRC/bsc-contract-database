{"pixel_prismatica.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity 0.8.18;\r\n\r\nimport \"./pixel_prismatica_utils.sol\";\r\nimport \"./standard_contract.sol\";\r\n\r\n// import \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\r\ninterface IERC1155MetadataURI is IERC1155 {\r\n    function uri(uint256 id) external view returns (string memory);\r\n}\r\n\r\n// import \"@openzeppelin/contracts/interfaces/IERC2981.sol\";\r\ninterface IERC2981 is IERC165 {\r\n    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address receiver, uint256 royaltyAmount);\r\n}\r\n\r\ncontract PixelPrismatica is StandardContract, IERC1155MetadataURI, IERC2981 {\r\n    /*\r\n    *\r\n    *\r\n        Errors\r\n    *\r\n    *\r\n    */\r\n\r\n    /// @notice The required minting fee has not been paid.\r\n    error MintFeeError(uint256 value, uint256 mintFee);\r\n\r\n    /// @notice There are no remaining NFT mints available.\r\n    error NoRemainingMintsError();\r\n\r\n    /// @notice The address does not own the NFT.\r\n    error NotNFTOwnerError(uint256 id, address _address, address nftOwner);\r\n\r\n    /*\r\n    *\r\n    *\r\n        Events\r\n    *\r\n    *\r\n    */\r\n\r\n    /// @notice A record of an NFT being minted.\r\n    event Mint(uint256 indexed id, address indexed mintAddress);\r\n\r\n    /*\r\n    *\r\n    *\r\n        Constants\r\n    *\r\n    *\r\n    */\r\n\r\n    // Helper Contracts\r\n    PixelPrismaticaUtils private constant UTILS = PixelPrismaticaUtils(0x44E0DA58B239D218164E3746E6b02372785A4413);\r\n\r\n    // Chain information.\r\n    uint256 private constant CHAIN_ID = 56;\r\n    uint256 private constant CHAIN_INITIAL_MINT_FEE = 0.1 ether;\r\n    string private constant CHAIN_NAME = \"Binance Smart Chain\";\r\n\r\n    // The number of different colors each tile cycles through. This is chosen experimentally so that the NFT will display in most sites.\r\n    uint256 private constant NUM_COLORS = 5;\r\n\r\n    // The max number of NFT mints available per network.\r\n    uint256 private constant MAX_MINTS = 100;\r\n\r\n    // Set in CTOR, but cannot be marked as immutable\r\n    mapping(uint256 =\u003e string) private map_animationDuration2AnimationDurationString;\r\n    mapping(uint256 =\u003e uint256) private map_animationDuration2AnimationDurationValue;\r\n    mapping(uint256 =\u003e string) private map_colorMode2ColorModeString;\r\n    mapping(uint256 =\u003e bytes4) private map_colorMode2ColorModeValue;\r\n    mapping(uint256 =\u003e string) private map_imageSize2ImageSizeString;\r\n    mapping(uint256 =\u003e uint256) private map_imageSize2ImageSizeValue;\r\n\r\n    /*\r\n    *\r\n    *\r\n        Private Variables\r\n    *\r\n    *\r\n    */\r\n\r\n    /*\r\n        NFT Variables\r\n    */\r\n\r\n    struct NFTConfig { \r\n        string animationDurationString;\r\n        uint256 animationDurationValue;\r\n\r\n        string colorModeString;\r\n        bytes4 colorModeValue;\r\n\r\n        string imageSizeString;\r\n        uint256 numRectX;\r\n        uint256 numRectY;\r\n        uint256 rectWidth;\r\n        uint256 rectHeight;\r\n    }\r\n\r\n    uint256 private currentID;\r\n    \r\n    uint256 private mintFee;\r\n    address private royaltyAddress;\r\n    uint256 private royaltyBasisPoints;\r\n    \r\n    string private storeDescription;\r\n    string private storeExternalLinkURI;\r\n    string private storeImageURI;\r\n    string private storeName;\r\n\r\n    mapping(uint256 =\u003e NFTConfig) private map_id2NFTConfig;\r\n    mapping(uint256 =\u003e address) private map_id2NFTOwnerAddress;\r\n\r\n    mapping(address =\u003e mapping(address =\u003e bool)) private map_address2OperatorAddress2IsApproved;\r\n    mapping(uint256 =\u003e mapping(address =\u003e uint256)) private map_id2Address2Balance;\r\n\r\n    /*\r\n    *\r\n    *\r\n        Contract Functions\r\n    *\r\n    *\r\n    */\r\n\r\n    /*\r\n        Built-In Functions\r\n    */\r\n\r\n    constructor() StandardContract() payable {\r\n        assert(block.chainid == CHAIN_ID);\r\n\r\n        // Set the initial mint fee. This will increase automatically as more NFTs are minted.\r\n        setMintFee(CHAIN_INITIAL_MINT_FEE);\r\n\r\n        // Defaults are set here, but these can be changed manually after the contract is deployed.\r\n        setRoyaltyAddress(address(this));\r\n        setRoyaltyBasisPoints(300);\r\n\r\n        setStoreName(string.concat(\"Pixel Prismatica NFT Collection (\", CHAIN_NAME, \")\"));\r\n        setStoreDescription(\"A collection of configurable NFT tokens featuring animated pixel art, capped at 100 per network. https://musicslayer.github.io/pixel_prismatica_dapp/\");\r\n        setStoreImageURI(\"https://raw.githubusercontent.com/musicslayer/pixel_prismatica_dapp/main/store_image.png\");\r\n        setStoreExternalLinkURI(\"https://musicslayer.github.io/pixel_prismatica_dapp/\");\r\n\r\n        // Store the data for all possible configuration options.\r\n        map_animationDuration2AnimationDurationString[0] = \"Short Animation Duration\";\r\n        map_animationDuration2AnimationDurationString[1] = \"Medium Animation Duration\";\r\n        map_animationDuration2AnimationDurationString[2] = \"Long Animation Duration\";\r\n        map_animationDuration2AnimationDurationString[3] = \"No Animation\";\r\n        map_animationDuration2AnimationDurationValue[0] = 4;\r\n        map_animationDuration2AnimationDurationValue[1] = 10;\r\n        map_animationDuration2AnimationDurationValue[2] = 20;\r\n        map_animationDuration2AnimationDurationValue[3] = 0;\r\n\r\n        map_colorMode2ColorModeString[0] = \"Rainbow Light Color Mode\";\r\n        map_colorMode2ColorModeString[1] = \"Rainbow Dark Color Mode\";\r\n        map_colorMode2ColorModeString[2] = \"Monochrome Color Mode\";\r\n        map_colorMode2ColorModeString[3] = \"Red Color Mode\";\r\n        map_colorMode2ColorModeString[4] = \"Green Color Mode\";\r\n        map_colorMode2ColorModeString[5] = \"Blue Color Mode\";\r\n        map_colorMode2ColorModeString[6] = \"Green \u0026 Blue Color Mode\";\r\n        map_colorMode2ColorModeString[7] = \"Red \u0026 Green Color Mode\";\r\n        map_colorMode2ColorModeString[8] = \"Red \u0026 Blue Color Mode\";\r\n        map_colorMode2ColorModeString[9] = \"Cyan Color Mode\";\r\n        map_colorMode2ColorModeString[10] = \"Yellow Color Mode\";\r\n        map_colorMode2ColorModeString[11] = \"Magenta Color Mode\";\r\n        map_colorMode2ColorModeValue[0] = UTILS.getRainbowLightColorString.selector;\r\n        map_colorMode2ColorModeValue[1] = UTILS.getRainbowDarkColorString.selector;\r\n        map_colorMode2ColorModeValue[2] = UTILS.getMonochromeColorString.selector;\r\n        map_colorMode2ColorModeValue[3] = UTILS.getRedColorString.selector;\r\n        map_colorMode2ColorModeValue[4] = UTILS.getGreenColorString.selector;\r\n        map_colorMode2ColorModeValue[5] = UTILS.getBlueColorString.selector;\r\n        map_colorMode2ColorModeValue[6] = UTILS.getGreenBlueColorString.selector;\r\n        map_colorMode2ColorModeValue[7] = UTILS.getRedGreenColorString.selector;\r\n        map_colorMode2ColorModeValue[8] = UTILS.getRedBlueColorString.selector;\r\n        map_colorMode2ColorModeValue[9] = UTILS.getCyanColorString.selector;\r\n        map_colorMode2ColorModeValue[10] = UTILS.getYellowColorString.selector;\r\n        map_colorMode2ColorModeValue[11] = UTILS.getMagentaColorString.selector;\r\n\r\n        map_imageSize2ImageSizeString[0] = \"Small Image Size\";\r\n        map_imageSize2ImageSizeString[1] = \"Medium Image Size\";\r\n        map_imageSize2ImageSizeString[2] = \"Large Image Size\";\r\n        map_imageSize2ImageSizeValue[0] = 10;\r\n        map_imageSize2ImageSizeValue[1] = 18;\r\n        map_imageSize2ImageSizeValue[2] = 24;\r\n    }\r\n\r\n    fallback() external payable {\r\n        // There is no legitimate reason for this fallback function to be called.\r\n        punish();\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    /*\r\n        Implementation Functions\r\n    */\r\n\r\n    // IERC165 Implementation\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, StandardContract) returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId\r\n            || interfaceId == type(IERC1155).interfaceId\r\n            || interfaceId == type(IERC1155MetadataURI).interfaceId \r\n            || interfaceId == type(IERC2981).interfaceId\r\n            || super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    // IERC1155 Implementation\r\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\r\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\r\n        return map_id2Address2Balance[id][account];\r\n    }\r\n\r\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids) public view virtual override returns (uint256[] memory) {\r\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\r\n\r\n        uint256[] memory batchBalances = new uint256[](accounts.length);\r\n\r\n        for(uint256 i = 0; i \u003c accounts.length; ++i) {\r\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\r\n        }\r\n\r\n        return batchBalances;\r\n    }\r\n\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        require(msg.sender != operator, \"ERC1155: setting approval status for self\");\r\n\r\n        map_address2OperatorAddress2IsApproved[msg.sender][operator] = approved;\r\n\r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\r\n        return map_address2OperatorAddress2IsApproved[account][operator];\r\n    }\r\n\r\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes memory data) public virtual override {\r\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\r\n        require(from == msg.sender || isApprovedForAll(from, msg.sender), \"ERC1155: caller is not token owner or approved\");\r\n\r\n        uint256 fromBalance = map_id2Address2Balance[id][from];\r\n        require(fromBalance \u003e= amount, \"ERC1155: insufficient balance for transfer\");\r\n\r\n        map_id2Address2Balance[id][from] = fromBalance - amount;\r\n        map_id2Address2Balance[id][to] += amount;\r\n\r\n        // For this token, the amount is always 1 per id, so we can keep track of the owner directly.\r\n        setNFTOwner(id, to);\r\n\r\n        emit TransferSingle(msg.sender, from, to, id, amount);\r\n\r\n        _doSafeTransferAcceptanceCheck(msg.sender, from, to, id, amount, data);\r\n    }\r\n\r\n    function safeBatchTransferFrom(address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) public virtual override {\r\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\r\n        require(from == msg.sender || isApprovedForAll(from, msg.sender), \"ERC1155: caller is not token owner or approved\");\r\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\r\n\r\n        for(uint256 i = 0; i \u003c ids.length; ++i) {\r\n            uint256 id = ids[i];\r\n            uint256 amount = amounts[i];\r\n\r\n            uint256 fromBalance = map_id2Address2Balance[id][from];\r\n            require(fromBalance \u003e= amount, \"ERC1155: insufficient balance for transfer\");\r\n\r\n            map_id2Address2Balance[id][from] = fromBalance - amount;\r\n            map_id2Address2Balance[id][to] += amount;\r\n\r\n            // For this token, the amount is always 1 per id, so we can keep track of the owner directly.\r\n            setNFTOwner(id, to);\r\n        }\r\n\r\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\r\n\r\n        _doSafeBatchTransferAcceptanceCheck(msg.sender, from, to, ids, amounts, data);\r\n    }\r\n\r\n    function _doSafeTransferAcceptanceCheck(address operator, address from, address to, uint256 id, uint256 amount, bytes memory data) private {\r\n        if(to.code.length \u003e 0) {\r\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\r\n                if(response != IERC1155Receiver.onERC1155Received.selector) {\r\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\r\n                }\r\n            }\r\n            catch Error(string memory reason) {\r\n                revert(reason);\r\n            }\r\n            catch {\r\n                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function _doSafeBatchTransferAcceptanceCheck(address operator, address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) private {\r\n        if(to.code.length \u003e 0) {\r\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (bytes4 response) {\r\n                if(response != IERC1155Receiver.onERC1155BatchReceived.selector) {\r\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\r\n                }\r\n            }\r\n            catch Error(string memory reason) {\r\n                revert(reason);\r\n            }\r\n            catch {\r\n                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");\r\n            }\r\n        }\r\n    }\r\n\r\n    // IERC1155MetadataURI Implementation\r\n    function uri(uint256 id) external view returns (string memory) {\r\n        // The JSON data is directly encoded here.\r\n        string memory name = createName(id);\r\n        string memory description = createDescription(id);\r\n        string memory imageURI = createImageURI(id);\r\n\r\n        string memory uriString = string.concat(\u0027{\"name\":\"\u0027, name, \u0027\", \"description\":\"\u0027, description, \u0027\", \"image\":\"\u0027, imageURI, \u0027\"}\u0027);\r\n        return string(abi.encodePacked(\u0027data:application/json;base64,\u0027, Base64.encode(abi.encodePacked(uriString))));\r\n    }\r\n\r\n    // IERC2981 Implementation\r\n    function royaltyInfo(uint256, uint256 salePrice) external view returns (address receiver, uint256 royaltyAmount) {\r\n        receiver = royaltyAddress;\r\n        royaltyAmount = (salePrice * royaltyBasisPoints) / 10000;\r\n    }\r\n\r\n    // OpenSea Standard\r\n    function contractURI() public view returns (string memory) {\r\n        // The JSON data is directly encoded here.\r\n        string memory uriString = string.concat(\u0027{\"name\":\"\u0027, storeName, \u0027\", \"description\":\"\u0027, storeDescription, \u0027\", \"image\":\"\u0027, storeImageURI, \u0027\", \"external_link\":\"\u0027, storeExternalLinkURI, \u0027\", \"seller_fee_basis_points\":\u0027, uint256ToString(royaltyBasisPoints), \u0027, \"fee_recipient\":\"\u0027, addressToString(royaltyAddress), \u0027\"}\u0027);\r\n        return string(abi.encodePacked(\"data:application/json;base64,\", Base64.encode(abi.encodePacked(uriString))));\r\n    }\r\n\r\n    /*\r\n        Action Functions\r\n    */\r\n\r\n    function applyConfig(uint256 _id, uint256 _colorMode, uint256 _animationDuration, uint256 _imageSize) private {\r\n        setColorMode(_id, _colorMode);\r\n        setAnimationDuration(_id, _animationDuration);\r\n        setImageSize(_id, _imageSize);\r\n    }\r\n\r\n    function mint(address _address, uint256 _colorMode, uint256 _animationDuration, uint256 _imageSize, bytes memory _data) private {\r\n        // This NFT is always minted one at a time.\r\n        require(_address != address(0), \"ERC1155: mint to the zero address\");\r\n\r\n        currentID++;\r\n\r\n        map_id2Address2Balance[currentID][_address] = 1;\r\n        setNFTOwner(currentID, _address);\r\n\r\n        // Fill in NFTConfig struct.\r\n        map_id2NFTConfig[currentID] = NFTConfig(\"\", 0, \"\", 0, \"\", 0, 0, 0, 0);\r\n        applyConfig(currentID, _colorMode, _animationDuration, _imageSize);\r\n\r\n        // Every time an NFT is minted, increase the minting cost for the next one.\r\n        uint256 newMintFee = getMintFee();\r\n        newMintFee = (newMintFee * 105) / 100;\r\n        newMintFee = (newMintFee / 0.0001 ether) * 0.0001 ether; // Truncate extra decimal places.\r\n        setMintFee(newMintFee);\r\n        \r\n        emit Mint(currentID, _address);\r\n        emit TransferSingle(msg.sender, address(0), _address, currentID, 1);\r\n\r\n        _doSafeTransferAcceptanceCheck(msg.sender, address(0), _address, currentID, 1, _data);\r\n    }\r\n\r\n    /*\r\n        Helper Functions\r\n    */\r\n\r\n    function createDescription(uint256 _id) private view returns (string memory) {\r\n        if(_id == 0 || _id \u003e currentID) {\r\n            return \"(Unminted)\";\r\n        }\r\n        else {\r\n            string memory colorModeString = map_id2NFTConfig[_id].colorModeString;\r\n            string memory animationDurationString = map_id2NFTConfig[_id].animationDurationString;\r\n            string memory imageSizeString = map_id2NFTConfig[_id].imageSizeString;\r\n            return string.concat(\"Configuration: \", colorModeString, \" - \", animationDurationString, \" - \", imageSizeString);\r\n        }\r\n    }\r\n\r\n    function createImageURI(uint256 _id) private view returns (string memory) {\r\n        if(_id == 0 || _id \u003e currentID) {\r\n            return \"\";\r\n        }\r\n\r\n        uint256[2] memory RND;\r\n        RND[0] = UTILS.getInitialSeed();\r\n        RND[1] = _id + (CHAIN_ID * 1000);\r\n\r\n        NFTConfig memory nftConfig = map_id2NFTConfig[_id];\r\n\r\n        bytes4 selector = nftConfig.colorModeValue;\r\n        uint256 width = nftConfig.rectWidth * nftConfig.numRectX;\r\n        uint256 height = nftConfig.rectHeight * nftConfig.numRectY;\r\n        string memory animationDurationString = string.concat(uint256ToStringFast(nftConfig.animationDurationValue), \"s\");\r\n\r\n        uint256 i = 0;\r\n        slice[] memory content = new slice[](14 + nftConfig.numRectX * nftConfig.numRectY * (13 + 2 * (NUM_COLORS - 1)));\r\n\r\n        content[i++] = slice_toSlice(\"\u003c?xml version=\\\"1.1\\\"?\u003e\");\r\n        content[i++] = slice_toSlice(\"\u003csvg width=\\\"\");\r\n        content[i++] = slice_toSlice(uint256ToStringFast(width));\r\n        content[i++] = slice_toSlice(\"\\\" height=\\\"\");\r\n        content[i++] = slice_toSlice(uint256ToStringFast(height));\r\n        content[i++] = slice_toSlice(\"\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"\u003e\");\r\n        content[i++] = slice_toSlice(\"\u003cdefs\u003e\");\r\n        content[i++] = slice_toSlice(\"\u003crect id=\\\"b\\\" width=\\\"\");\r\n        content[i++] = slice_toSlice(uint256ToStringFast(nftConfig.rectWidth));\r\n        content[i++] = slice_toSlice(\"\\\" height=\\\"\");\r\n        content[i++] = slice_toSlice(uint256ToStringFast(nftConfig.rectHeight));\r\n        content[i++] = slice_toSlice(\"\\\"/\u003e\");\r\n        content[i++] = slice_toSlice(\"\u003c/defs\u003e\");\r\n        \r\n        for(uint256 rectY = 0; rectY \u003c height; rectY += nftConfig.rectHeight) {\r\n            for(uint256 rectX = 0; rectX \u003c width; rectX += nftConfig.rectWidth) {\r\n                string memory first;\r\n                (first, RND) = UTILS.getColorString(selector, RND);\r\n\r\n                content[i++] = slice_toSlice(\"\u003cuse href=\\\"#b\\\" x=\\\"\");\r\n                content[i++] = slice_toSlice(uint256ToStringFast(rectX));\r\n                content[i++] = slice_toSlice(\"\\\" y=\\\"\");\r\n                content[i++] = slice_toSlice(uint256ToStringFast(rectY));\r\n                content[i++] = slice_toSlice(\"\\\" fill=\\\"\");\r\n                content[i++] = slice_toSlice(first);\r\n                content[i++] = slice_toSlice(\"\\\"\u003e\u003canimate attributeName=\\\"fill\\\" values=\\\"\");\r\n\r\n                content[i++] = slice_toSlice(first);\r\n                content[i++] = slice_toSlice(\";\");\r\n                for(uint256 ii = 0; ii \u003c NUM_COLORS - 1; ii++) {\r\n                    string memory colorString;\r\n                    (colorString, RND) = UTILS.getColorString(selector, RND);\r\n                    content[i++] = slice_toSlice(colorString);\r\n                    content[i++] = slice_toSlice(\";\");\r\n                }\r\n                content[i++] = slice_toSlice(first);\r\n\r\n                content[i++] = slice_toSlice(\"\\\" dur=\\\"\");\r\n                content[i++] = slice_toSlice(animationDurationString);\r\n                content[i++] = slice_toSlice(\"\\\" repeatCount=\\\"indefinite\\\"/\u003e\u003c/use\u003e\");\r\n            }\r\n        }\r\n\r\n        content[i++] = slice_toSlice(\"\u003c/svg\u003e\");\r\n\r\n        string memory contentString = slice_join(slice_toSlice(\"\"), content);\r\n        return string(abi.encodePacked(\"data:image/svg+xml;base64,\", Base64.encode(abi.encodePacked(contentString))));\r\n    }\r\n\r\n    function createName(uint256 _id) private pure returns (string memory) {\r\n        return string.concat(\"Pixel Prismatica NFT #\", uint256ToString(_id));\r\n    }\r\n\r\n    /*\r\n        Query Functions\r\n    */\r\n\r\n    function isMintFee(uint256 _value) private view returns (bool) {\r\n        return _value == getMintFee();\r\n    }\r\n\r\n    function isNFTOwner(uint256 _id, address _address) private view returns (bool) {\r\n        return _address == getNFTOwner(_id);\r\n    }\r\n\r\n    function isRemainingMints() private view returns (bool) {\r\n        return getRemainingMints() != 0;\r\n    }\r\n\r\n    /*\r\n        Require Functions\r\n    */\r\n\r\n    function requireMintFee(uint256 _value) private view {\r\n        if(!isMintFee(_value)) {\r\n            revert MintFeeError(_value, getMintFee());\r\n        }\r\n    }\r\n\r\n    function requireNFTOwner(uint256 _id, address _address) private view {\r\n        if(!isNFTOwner(_id, _address)) {\r\n            revert NotNFTOwnerError(_id, _address, getNFTOwner(_id));\r\n        }\r\n    }\r\n\r\n    function requireRemainingMints() private view {\r\n        if(!isRemainingMints()) {\r\n            revert NoRemainingMintsError();\r\n        }\r\n    }\r\n\r\n    /*\r\n        Get Functions\r\n    */\r\n\r\n    function getDescription(uint256 _id) private view returns (string memory) {\r\n        return createDescription(_id);\r\n    }\r\n\r\n    function getImageURI(uint256 _id) private view returns (string memory) {\r\n        return createImageURI(_id);\r\n    }\r\n\r\n    function getMintFee() private view returns (uint256) {\r\n        return mintFee;\r\n    }\r\n\r\n    function getName(uint256 _id) private pure returns (string memory) {\r\n        return createName(_id);\r\n    }\r\n\r\n    function getNFTOwner(uint256 _id) private view returns (address) {\r\n        return map_id2NFTOwnerAddress[_id];\r\n    }\r\n\r\n    function getOpenSeaData() private view returns (string memory) {\r\n        return contractURI();\r\n    }\r\n\r\n    function getRemainingMints() private view returns (uint256) {\r\n        return MAX_MINTS - currentID;\r\n    }\r\n\r\n    function getRoyaltyAddress() private view returns (address) {\r\n        return royaltyAddress;\r\n    }\r\n\r\n    function getRoyaltyBasisPoints() private view returns (uint256) {\r\n        return royaltyBasisPoints;\r\n    }\r\n\r\n    function getTotalMints() private view returns (uint256) {\r\n        return currentID;\r\n    }\r\n\r\n    /*\r\n        Set Functions\r\n    */\r\n\r\n    function setAnimationDuration(uint256 _id, uint256 _animationDuration) private {\r\n        if(_animationDuration \u003e 3) {\r\n            _animationDuration = 1; // Default to Medium\r\n        }\r\n        map_id2NFTConfig[_id].animationDurationString = map_animationDuration2AnimationDurationString[_animationDuration];\r\n        map_id2NFTConfig[_id].animationDurationValue = map_animationDuration2AnimationDurationValue[_animationDuration];\r\n    }\r\n\r\n    function setColorMode(uint256 _id, uint256 _colorMode) private {\r\n        if(_colorMode \u003e 11) {\r\n            _colorMode = 0; // Default to Rainbow Light\r\n        }\r\n        map_id2NFTConfig[_id].colorModeString = map_colorMode2ColorModeString[_colorMode];\r\n        map_id2NFTConfig[_id].colorModeValue = map_colorMode2ColorModeValue[_colorMode];\r\n    }\r\n\r\n    function setImageSize(uint256 _id, uint256 _imageSize) private {\r\n        if(_imageSize \u003e 2) {\r\n            _imageSize = 1; // Default to Medium\r\n        }\r\n        map_id2NFTConfig[_id].imageSizeString = map_imageSize2ImageSizeString[_imageSize];\r\n\r\n        // These are all the same value but are kept separate to make the code more understandable.\r\n        uint256 imageSizeValue = map_imageSize2ImageSizeValue[_imageSize];\r\n        map_id2NFTConfig[_id].numRectX = imageSizeValue;\r\n        map_id2NFTConfig[_id].numRectY = imageSizeValue;\r\n        map_id2NFTConfig[_id].rectWidth = imageSizeValue;\r\n        map_id2NFTConfig[_id].rectHeight = imageSizeValue;\r\n    }\r\n\r\n    function setMintFee(uint256 _mintFee) private {\r\n        mintFee = _mintFee;\r\n    }\r\n\r\n    function setNFTOwner(uint256 _id, address _address) private {\r\n        map_id2NFTOwnerAddress[_id] = _address;\r\n    }\r\n\r\n    function setRoyaltyAddress(address _royaltyAddress) private {\r\n        royaltyAddress = _royaltyAddress;\r\n    }\r\n\r\n    function setRoyaltyBasisPoints(uint256 _royaltyBasisPoints) private {\r\n        royaltyBasisPoints = _royaltyBasisPoints;\r\n    }\r\n\r\n    function setStoreDescription(string memory _storeDescription) private {\r\n        storeDescription = _storeDescription;\r\n    }\r\n\r\n    function setStoreExternalLinkURI(string memory _storeExternalLinkURI) private {\r\n        storeExternalLinkURI = _storeExternalLinkURI;\r\n    }\r\n\r\n    function setStoreImageURI(string memory _storeImageURI) private {\r\n        storeImageURI = _storeImageURI;\r\n    }\r\n\r\n    function setStoreName(string memory _storeName) private {\r\n        storeName = _storeName;\r\n    }\r\n\r\n    /*\r\n    *\r\n    *\r\n        External Functions\r\n    *\r\n    *\r\n    */\r\n\r\n    /*\r\n        Action Functions\r\n    */\r\n\r\n    /// @notice The NFT owner can configure their NFT.\r\n    /// @param _id The ID of the NFT.\r\n    /// @param _colorMode The new color mode.\r\n    /// @param _animationDuration The new animation duration.\r\n    /// @param _imageSize The new image size.\r\n    function action_applyConfig(uint256 _id, uint256 _colorMode, uint256 _animationDuration, uint256 _imageSize) external {\r\n        lock();\r\n\r\n        requireNFTOwner(_id, msg.sender);\r\n\r\n        applyConfig(_id, _colorMode, _animationDuration, _imageSize);\r\n\r\n        unlock();\r\n    }\r\n\r\n    /// @notice A user can mint an NFT.\r\n    /// @param _colorMode The initial color mode.\r\n    /// @param _animationDuration The initial animation duration.\r\n    /// @param _imageSize The initial image size.\r\n    /// @param _data Additional data with no specified format.\r\n    function action_mint(uint256 _colorMode, uint256 _animationDuration, uint256 _imageSize, bytes memory _data) external payable {\r\n        lock();\r\n\r\n        requireRemainingMints();\r\n        requireMintFee(msg.value);\r\n\r\n        mint(msg.sender, _colorMode, _animationDuration, _imageSize, _data);\r\n\r\n        unlock();\r\n    }\r\n\r\n    /// @notice The owner can trigger a mint for someone else.\r\n    /// @param _address The address that the owner is triggering the mint for.\r\n    /// @param _colorMode The initial color mode.\r\n    /// @param _animationDuration The initial animation duration.\r\n    /// @param _imageSize The initial image size.\r\n    /// @param _data Additional data with no specified format.\r\n    function action_mintOther(address _address, uint256 _colorMode, uint256 _animationDuration, uint256 _imageSize, bytes memory _data) external payable {\r\n        lock();\r\n\r\n        requireOwnerAddress(msg.sender);\r\n        requireRemainingMints();\r\n        requireMintFee(msg.value);\r\n        \r\n        mint(_address, _colorMode, _animationDuration, _imageSize, _data);\r\n\r\n        unlock();\r\n    }\r\n\r\n    /*\r\n        Query Functions\r\n    */\r\n\r\n    /// @notice Returns whether the amount is equal to the current mint fee.\r\n    /// @return Whether the amount is equal to the current mint fee.\r\n    function query_isMintFee(uint256 _value) external view returns (bool) {\r\n        return isMintFee(_value);\r\n    }\r\n\r\n    /// @notice Returns whether the address owns the NFT.\r\n    /// @param _id The ID of the NFT.\r\n    /// @param _address The address that we are checking.\r\n    /// @return Whether the address owns the NFT.\r\n    function query_isNFTOwner(uint256 _id, address _address) external view returns (bool) {\r\n        return isNFTOwner(_id, _address);\r\n    }\r\n\r\n    /// @notice Returns whether there are any remaining NFT mints available.\r\n    /// @return Whether there are any remaining NFT mints available.\r\n    function query_isRemainingMints() external view returns (bool) {\r\n        return isRemainingMints();\r\n    }\r\n\r\n    /*\r\n        Get Functions\r\n    */\r\n\r\n    /// @notice Returns the description of the NFT.\r\n    /// @param _id The ID of the NFT.\r\n    /// @return The description of the NFT.\r\n    function get_description(uint256 _id) external view returns (string memory) {\r\n        return getDescription(_id);\r\n    }\r\n\r\n    /// @notice Returns the image URI of the NFT.\r\n    /// @param _id The ID of the NFT.\r\n    /// @return The image URI of the NFT.\r\n    function get_imageURI(uint256 _id) external view returns (string memory) {\r\n        return getImageURI(_id);\r\n    }\r\n\r\n    /// @notice Returns the mint fee.\r\n    /// @return The mint fee.\r\n    function get_mintFee() external view returns (uint256) {\r\n        return getMintFee();\r\n    }\r\n\r\n    /// @notice Returns the name of the NFT.\r\n    /// @param _id The ID of the NFT.\r\n    /// @return The name of the NFT.\r\n    function get_name(uint256 _id) external pure returns (string memory) {\r\n        return getName(_id);\r\n    }\r\n\r\n    /// @notice Returns the address that owns the NFT.\r\n    /// @param _id The ID of the NFT.\r\n    /// @return The address that owns the NFT.\r\n    function get_nftOwner(uint256 _id) external view returns (address) {\r\n        return getNFTOwner(_id);\r\n    }\r\n\r\n    /// @notice Returns the OpenSea data.\r\n    /// @return The OpenSea data.\r\n    function get_openSeaData() external view returns (string memory) {\r\n        return getOpenSeaData();\r\n    }\r\n\r\n    /// @notice Returns the number of remaining NFT mints available.\r\n    /// @return The number of remaining NFT mints available.\r\n    function get_remainingMints() external view returns (uint256) {\r\n        return getRemainingMints();\r\n    }\r\n\r\n    /// @notice Returns the address that royalties will be paid to.\r\n    /// @return The address that royalties will be paid to.\r\n    function get_royaltyAddress() external view returns (address) {\r\n        return getRoyaltyAddress();\r\n    }\r\n\r\n    /// @notice Returns the royalty basis points.\r\n    /// @return The royalty basis points.\r\n    function get_royaltyBasisPoints() external view returns (uint256) {\r\n        return getRoyaltyBasisPoints();\r\n    }\r\n\r\n    /// @notice Returns the total number of NFTs that have been minted.\r\n    /// @return The total number of NFTs that have been minted.\r\n    function get_totalMints() external view returns (uint256) {\r\n        return getTotalMints();\r\n    }\r\n\r\n    /*\r\n        Set Functions\r\n    */\r\n\r\n    /// @notice The owner can set the address that royalties will be paid to.\r\n    /// @param _royaltyAddress The new address that royalties will be paid to.\r\n    function set_royaltyAddress(address _royaltyAddress) external {\r\n        lock();\r\n\r\n        requireOwnerAddress(msg.sender);\r\n\r\n        setRoyaltyAddress(_royaltyAddress);\r\n\r\n        unlock();\r\n    }\r\n\r\n    /// @notice The owner can set the royalty basis points.\r\n    /// @param _royaltyBasisPoints The new royalty basis points.\r\n    function set_royaltyBasisPoints(uint256 _royaltyBasisPoints) external {\r\n        lock();\r\n\r\n        requireOwnerAddress(msg.sender);\r\n\r\n        setRoyaltyBasisPoints(_royaltyBasisPoints);\r\n\r\n        unlock();\r\n    }\r\n\r\n    /// @notice The owner can set the store description.\r\n    /// @param _storeDescription The new store description.\r\n    function set_storeDescription(string memory _storeDescription) external {\r\n        lock();\r\n\r\n        requireOwnerAddress(msg.sender);\r\n\r\n        setStoreDescription(_storeDescription);\r\n\r\n        unlock();\r\n    }\r\n\r\n    /// @notice The owner can set the store external link URI.\r\n    /// @param _storeExternalLinkURI The new store external link URI.\r\n    function set_storeExternalLinkURI(string memory _storeExternalLinkURI) external {\r\n        lock();\r\n\r\n        requireOwnerAddress(msg.sender);\r\n\r\n        setStoreExternalLinkURI(_storeExternalLinkURI);\r\n\r\n        unlock();\r\n    }\r\n\r\n    /// @notice The owner can set the store image URI.\r\n    /// @param _storeImageURI The new store image URI.\r\n    function set_storeImageURI(string memory _storeImageURI) external {\r\n        lock();\r\n\r\n        requireOwnerAddress(msg.sender);\r\n\r\n        setStoreImageURI(_storeImageURI);\r\n\r\n        unlock();\r\n    }\r\n\r\n    /// @notice The owner can set the store name.\r\n    /// @param _storeName The new store name.\r\n    function set_storeName(string memory _storeName) external {\r\n        lock();\r\n\r\n        requireOwnerAddress(msg.sender);\r\n\r\n        setStoreName(_storeName);\r\n\r\n        unlock();\r\n    }\r\n}"},"pixel_prismatica_utils.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity 0.8.18;\r\n\r\n/*\r\n    String Slice Functions\r\n    Taken from @Arachnid/src/strings.sol\r\n*/\r\n\r\nstruct slice {\r\n    uint _len;\r\n    uint _ptr;\r\n}\r\n\r\nfunction slice_join(slice memory self, slice[] memory parts) pure returns (string memory) {\r\n    if (parts.length == 0)\r\n        return \"\";\r\n\r\n    uint length = self._len * (parts.length - 1);\r\n    for(uint i = 0; i \u003c parts.length; i++)\r\n        length += parts[i]._len;\r\n\r\n    string memory ret = new string(length);\r\n    uint retptr;\r\n    assembly { retptr := add(ret, 32) }\r\n\r\n    for(uint i = 0; i \u003c parts.length; i++) {\r\n        slice_memcpy(retptr, parts[i]._ptr, parts[i]._len);\r\n        retptr += parts[i]._len;\r\n        if (i \u003c parts.length - 1) {\r\n            slice_memcpy(retptr, self._ptr, self._len);\r\n            retptr += self._len;\r\n        }\r\n    }\r\n\r\n    return ret;\r\n}\r\n\r\nfunction slice_memcpy(uint dest, uint src, uint len) pure {\r\n    // Copy word-length chunks while possible\r\n    for(; len \u003e= 32; len -= 32) {\r\n        assembly {\r\n            mstore(dest, mload(src))\r\n        }\r\n        dest += 32;\r\n        src += 32;\r\n    }\r\n\r\n    // Copy remaining bytes\r\n    uint _mask = type(uint).max;\r\n    if (len \u003e 0) {\r\n        _mask = 256 ** (32 - len) - 1;\r\n    }\r\n    assembly {\r\n        let srcpart := and(mload(src), not(_mask))\r\n        let destpart := and(mload(dest), _mask)\r\n        mstore(dest, or(destpart, srcpart))\r\n    }\r\n}\r\n\r\nfunction slice_toSlice(string memory self) pure returns (slice memory) {\r\n    uint ptr;\r\n    assembly {\r\n        ptr := add(self, 0x20)\r\n    }\r\n    return slice(bytes(self).length, ptr);\r\n}\r\n\r\n/*\r\n    Utility Functions\r\n*/\r\n\r\nbytes16 constant HEX_SYMBOLS = \"0123456789ABCDEF\";\r\nfunction get3Hex(uint256 valueA, uint256 valueB, uint256 valueC) pure returns (string memory) {\r\n    // Each value must be \u003c 256.\r\n    bytes memory buffer = new bytes(7);\r\n    buffer[0] = \"#\";\r\n    buffer[1] = HEX_SYMBOLS[(valueA \u0026 0xf0) \u003e\u003e 4];\r\n    buffer[2] = HEX_SYMBOLS[valueA \u0026 0xf];\r\n    buffer[3] = HEX_SYMBOLS[(valueB \u0026 0xf0) \u003e\u003e 4];\r\n    buffer[4] = HEX_SYMBOLS[valueB \u0026 0xf];\r\n    buffer[5] = HEX_SYMBOLS[(valueC \u0026 0xf0) \u003e\u003e 4];\r\n    buffer[6] = HEX_SYMBOLS[valueC \u0026 0xf];\r\n\r\n    return string(buffer);\r\n}\r\n\r\nbytes16 constant DECIMAL_SYMBOLS = \"0123456789\";\r\nfunction uint256ToStringFast(uint256 _i) pure returns (string memory) {\r\n    // Only works for values \u003c 1000\r\n    bytes memory buffer;\r\n    if(_i \u003c 10) {\r\n        buffer = new bytes(1);\r\n        buffer[0] = DECIMAL_SYMBOLS[_i];\r\n    }\r\n    else if(_i \u003c 100) {\r\n        buffer = new bytes(2);\r\n        buffer[0] = DECIMAL_SYMBOLS[_i / 10];\r\n        buffer[1] = DECIMAL_SYMBOLS[_i % 10];\r\n    }\r\n    else {\r\n        buffer = new bytes(3);\r\n        buffer[0] = DECIMAL_SYMBOLS[(_i / 10) / 10];\r\n        buffer[1] = DECIMAL_SYMBOLS[(_i / 10) % 10];\r\n        buffer[2] = DECIMAL_SYMBOLS[_i % 10];\r\n    }\r\n\r\n    return string(buffer);\r\n}\r\n\r\ncontract PixelPrismaticaUtils {\r\n    /*\r\n        RNG Variables\r\n    */\r\n\r\n    uint256 private constant addend = 0xB;\r\n    uint256 private constant mask = (1 \u003c\u003c 48) - 1;\r\n    uint256 private constant multiplier = 0x5DEECE66D;\r\n    \r\n    uint256 private immutable rnd0;\r\n\r\n    constructor() {\r\n        // Initialize RNG seed.\r\n        rnd0 = ((uint256(blockhash(block.number - 1))) ^ multiplier) \u0026 mask;\r\n    }\r\n\r\n    /*\r\n        RNG Functions\r\n    */\r\n\r\n    function getInitialSeed() public view returns (uint256) {\r\n        return rnd0;\r\n    }\r\n\r\n    function nextInt(uint256 n, uint256[2] memory RND) public pure returns (uint256) {\r\n        // Return a random integer.\r\n        // Only call if n is not a power of 2.\r\n        RND[0] = (RND[0] * multiplier + addend + RND[1]) \u0026 mask;\r\n        return (RND[0] \u003e\u003e 17) % n;\r\n    }\r\n\r\n    function nextInt2P(uint256 n, uint256[2] memory RND) public pure returns (uint256) {\r\n        // Return a random integer.\r\n        // Only call if n is a power of 2.\r\n        RND[0] = (RND[0] * multiplier + addend + RND[1]) \u0026 mask;\r\n        return (n * (RND[0] \u003e\u003e 17)) \u003e\u003e 31;\r\n    }\r\n\r\n    /*\r\n        Color Functions\r\n    */\r\n\r\n    function getColorString(bytes4 _selector, uint256[2] memory RND) public view returns (string memory, uint256[2] memory) {\r\n        bytes memory data = abi.encodeWithSelector(_selector, RND);\r\n        (bool success, bytes memory returnData) = address(this).staticcall(data);\r\n        assert(success);\r\n        return abi.decode(returnData, (string, uint256[2]));\r\n    }\r\n\r\n    function getRainbowLightColorString(uint256[2] memory RND) public pure returns (string memory, uint256[2] memory) {\r\n        uint256 c = 255;\r\n        uint256 r = nextInt(6, RND);\r\n\r\n        string memory s;\r\n        if(r == 0) {\r\n            s = get3Hex(c, 0, 0);\r\n        }\r\n        else if(r == 1) {\r\n            s = get3Hex(0, c, 0);\r\n        }\r\n        else if(r == 2) {\r\n            s = get3Hex(0, 0, c);\r\n        }\r\n        else if(r == 3) {\r\n            s = get3Hex(0, c, c);\r\n        }\r\n        else if(r == 4) {\r\n            s = get3Hex(c, c, 0);\r\n        }\r\n        else if(r == 5) {\r\n            s = get3Hex(c, 0, c);\r\n        }\r\n        else {\r\n            s = \"?\";\r\n        }\r\n\r\n        return (s, RND);\r\n    }\r\n\r\n    function getRainbowDarkColorString(uint256[2] memory RND) public pure returns (string memory, uint256[2] memory) {\r\n        uint256 c = 128;\r\n        uint256 r = nextInt(6, RND);\r\n\r\n        string memory s;\r\n        if(r == 0) {\r\n            s = get3Hex(c, 0, 0);\r\n        }\r\n        else if(r == 1) {\r\n            s = get3Hex(0, c, 0);\r\n        }\r\n        else if(r == 2) {\r\n            s = get3Hex(0, 0, c);\r\n        }\r\n        else if(r == 3) {\r\n            s = get3Hex(0, c, c);\r\n        }\r\n        else if(r == 4) {\r\n            s = get3Hex(c, c, 0);\r\n        }\r\n        else if(r == 5) {\r\n            s = get3Hex(c, 0, c);\r\n        }\r\n        else {\r\n            s = \"?\";\r\n        }\r\n\r\n        return (s, RND);\r\n    }\r\n\r\n    function getMonochromeColorString(uint256[2] memory RND) public pure returns (string memory, uint256[2] memory) {\r\n        uint256 c = nextInt2P(256, RND);\r\n        return (get3Hex(c, c, c), RND);\r\n    }\r\n\r\n    function getRedColorString(uint256[2] memory RND) public pure returns (string memory, uint256[2] memory) {\r\n        uint256 c = nextInt2P(256, RND);\r\n        return (get3Hex(c, 0, 0), RND);\r\n    }\r\n\r\n    function getGreenColorString(uint256[2] memory RND) public pure returns (string memory, uint256[2] memory) {\r\n        uint256 c = nextInt2P(256, RND);\r\n        return (get3Hex(0, c, 0), RND);\r\n    }\r\n\r\n    function getBlueColorString(uint256[2] memory RND) public pure returns (string memory, uint256[2] memory) {\r\n        uint256 c = nextInt2P(256, RND);\r\n        return (get3Hex(0, 0, c), RND);\r\n    }\r\n\r\n    function getGreenBlueColorString(uint256[2] memory RND) public pure returns (string memory, uint256[2] memory) {\r\n        uint256 cA = nextInt2P(256, RND);\r\n        uint256 cB = nextInt2P(256, RND);\r\n        return (get3Hex(0, cA, cB), RND);\r\n    }\r\n\r\n    function getRedGreenColorString(uint256[2] memory RND) public pure returns (string memory, uint256[2] memory) {\r\n        uint256 cA = nextInt2P(256, RND);\r\n        uint256 cB = nextInt2P(256, RND);\r\n        return (get3Hex(cA, cB, 0), RND);\r\n    }\r\n\r\n    function getRedBlueColorString(uint256[2] memory RND) public pure returns (string memory, uint256[2] memory) {\r\n        uint256 cA = nextInt2P(256, RND);\r\n        uint256 cB = nextInt2P(256, RND);\r\n        return (get3Hex(cA, 0, cB), RND);\r\n    }\r\n\r\n    function getCyanColorString(uint256[2] memory RND) public pure returns (string memory, uint256[2] memory) {\r\n        uint256 c = nextInt2P(256, RND);\r\n        return (get3Hex(0, c, c), RND);\r\n    }\r\n\r\n    function getYellowColorString(uint256[2] memory RND) public pure returns (string memory, uint256[2] memory) {\r\n        uint256 c = nextInt2P(256, RND);\r\n        return (get3Hex(c, c, 0), RND);\r\n    }\r\n\r\n    function getMagentaColorString(uint256[2] memory RND) public pure returns (string memory, uint256[2] memory) {\r\n        uint256 c = nextInt2P(256, RND);\r\n        return (get3Hex(c, 0, c), RND);\r\n    }\r\n}"},"standard_contract.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity 0.8.18;\r\n\r\n// import \"@openzeppelin/contracts/utils/Base64.sol\";\r\nlibrary Base64 {\r\n    string internal constant _TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\n    function encode(bytes memory data) internal pure returns (string memory) {\r\n        if(data.length == 0) return \"\";\r\n        string memory table = _TABLE;\r\n        string memory result = new string(4 * ((data.length + 2) / 3));\r\n        assembly {\r\n            let tablePtr := add(table, 1)\r\n            let resultPtr := add(result, 32)\r\n            for {\r\n                let dataPtr := data\r\n                let endPtr := add(data, mload(data))\r\n            } lt(dataPtr, endPtr) {\r\n            } {\r\n                // Advance 3 bytes\r\n                dataPtr := add(dataPtr, 3)\r\n                let input := mload(dataPtr)\r\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\r\n                resultPtr := add(resultPtr, 1) // Advance\r\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\r\n                resultPtr := add(resultPtr, 1) // Advance\r\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\r\n                resultPtr := add(resultPtr, 1) // Advance\r\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\r\n                resultPtr := add(resultPtr, 1) // Advance\r\n            }\r\n            switch mod(mload(data), 3)\r\n            case 1 {\r\n                mstore8(sub(resultPtr, 1), 0x3d)\r\n                mstore8(sub(resultPtr, 2), 0x3d)\r\n            }\r\n            case 2 {\r\n                mstore8(sub(resultPtr, 1), 0x3d)\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\n// import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\ninterface IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\n// import \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// import \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\r\ninterface IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n    function approve(address to, uint256 tokenId) external;\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n}\r\n\r\n// import \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\r\ninterface IERC721Receiver {\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\r\n}\r\n\r\n// import \"@openzeppelin/contracts/token/ERC777/IERC777.sol\";\r\ninterface IERC777 {\r\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\r\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\r\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\r\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function granularity() external view returns (uint256);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address owner) external view returns (uint256);\r\n    function send(address recipient, uint256 amount, bytes calldata data) external;\r\n    function burn(uint256 amount, bytes calldata data) external;\r\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\r\n    function authorizeOperator(address operator) external;\r\n    function revokeOperator(address operator) external;\r\n    function defaultOperators() external view returns (address[] memory);\r\n    function operatorSend(address sender, address recipient, uint256 amount, bytes calldata data, bytes calldata operatorData) external;\r\n    function operatorBurn(address account, uint256 amount, bytes calldata data, bytes calldata operatorData) external;\r\n    event Sent(address indexed operator, address indexed from, address indexed to, uint256 amount, bytes data, bytes operatorData);\r\n}\r\n\r\n// import \"@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol\";\r\ninterface IERC777Recipient {\r\n    function tokensReceived(address operator, address from, address to, uint256 amount, bytes calldata userData, bytes calldata operatorData) external;\r\n}\r\n\r\n// import \"@openzeppelin/contracts/token/ERC777/IERC777Sender.sol\";\r\ninterface IERC777Sender {\r\n    function tokensToSend(address operator, address from, address to, uint256 amount, bytes calldata userData, bytes calldata operatorData) external;\r\n}\r\n\r\n// import \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\r\ninterface IERC1155 is IERC165 {\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n    event URI(string value, uint256 indexed id);\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\r\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\r\n}\r\n\r\n// import \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\r\ninterface IERC1155Receiver is IERC165 {\r\n    function onERC1155Received(address operator, address from, uint256 id, uint256 value, bytes calldata data) external returns (bytes4);\r\n    function onERC1155BatchReceived(address operator, address from, uint256[] calldata ids, uint256[] calldata values, bytes calldata data) external returns (bytes4);\r\n}\r\n\r\n// import \"@openzeppelin/contracts/utils/introspection/IERC1820Implementer.sol\";\r\ninterface IERC1820Implementer {\r\n    function canImplementInterfaceForAddress(bytes32 interfaceHash, address account) external view returns (bytes32);\r\n}\r\n\r\n// import \"@openzeppelin/contracts/utils/introspection/IERC1820Registry.sol\";\r\ninterface IERC1820Registry {\r\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\r\n    event ManagerChanged(address indexed account, address indexed newManager);\r\n    function setManager(address account, address newManager) external;\r\n    function getManager(address account) external view returns (address);\r\n    function setInterfaceImplementer(address account, bytes32 _interfaceHash, address implementer) external;\r\n    function getInterfaceImplementer(address account, bytes32 _interfaceHash) external view returns (address);\r\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\r\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\r\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\r\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\ncontract StandardContract is IERC721Receiver, IERC777Recipient, IERC777Sender, IERC1155Receiver, IERC1820Implementer {\r\n    /*\r\n    *\r\n    *\r\n        Errors\r\n    *\r\n    *\r\n    */\r\n\r\n    /// @notice The calling address is not the owner.\r\n    error NotOwnerError(address _address, address ownerAddress);\r\n\r\n    /// @notice The calling address is not the owner successor.\r\n    error NotOwnerSuccessorError(address _address, address ownerSuccessorAddress);\r\n\r\n    /*\r\n    *\r\n    *\r\n        Events\r\n    *\r\n    *\r\n    */\r\n\r\n    /// @notice A record of the owner address changing.\r\n    event OwnerChanged(address indexed oldOwnerAddress, address indexed newOwnerAddress);\r\n\r\n    /*\r\n    *\r\n    *\r\n        Constants\r\n    *\r\n    *\r\n    */\r\n\r\n    IERC1820Registry internal constant _ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\r\n\r\n    bytes32 internal constant _ERC1820_ACCEPT_MAGIC = keccak256(\"ERC1820_ACCEPT_MAGIC\");\r\n    bytes32 internal constant _TOKENS_RECIPIENT_INTERFACE_HASH = keccak256(\"ERC777TokensRecipient\");\r\n    bytes32 internal constant _TOKENS_SENDER_INTERFACE_HASH = keccak256(\"ERC777TokensSender\");\r\n\r\n    /*\r\n    *\r\n    *\r\n        Internal Variables\r\n    *\r\n    *\r\n    */\r\n\r\n    /*\r\n        Contract Variables\r\n    */\r\n\r\n    address internal ownerAddress;\r\n    address internal ownerSuccessorAddress;\r\n\r\n    bool internal lockFlag;\r\n\r\n    /*\r\n    *\r\n    *\r\n        Contract Functions\r\n    *\r\n    *\r\n    */\r\n\r\n    /*\r\n        Built-In Functions\r\n    */\r\n\r\n    constructor() payable {\r\n        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), _TOKENS_RECIPIENT_INTERFACE_HASH, address(this));\r\n        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), _TOKENS_SENDER_INTERFACE_HASH, address(this));\r\n\r\n        setOwnerAddress(msg.sender);\r\n        setOwnerSuccessorAddress(msg.sender);\r\n    }\r\n\r\n    /*\r\n        Implementation Functions\r\n    */\r\n\r\n    // IERC165 Implementation\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId\r\n            || interfaceId == type(IERC721Receiver).interfaceId\r\n            || interfaceId == type(IERC777Recipient).interfaceId\r\n            || interfaceId == type(IERC777Sender).interfaceId\r\n            || interfaceId == type(IERC1155Receiver).interfaceId\r\n            || interfaceId == type(IERC1820Implementer).interfaceId;\r\n    }\r\n\r\n    // IERC721Receiver Implementation\r\n    function onERC721Received(address, address, uint256, bytes memory) public virtual returns (bytes4) {\r\n        return this.onERC721Received.selector;\r\n    }\r\n\r\n    // IERC777Recipient Implementation\r\n    function tokensReceived(address operator, address from, address to, uint256 amount, bytes calldata userData, bytes calldata operatorData) external {}\r\n\r\n    // IERC777Sender Implementation\r\n    function tokensToSend(address operator, address from, address to, uint256 amount, bytes calldata userData, bytes calldata operatorData) external {}\r\n\r\n    // IERC1155Receiver Implementation\r\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) external pure returns (bytes4) {\r\n        return this.onERC1155Received.selector;\r\n    }\r\n\r\n    function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) external pure returns (bytes4) {\r\n        return this.onERC1155BatchReceived.selector;\r\n    }\r\n\r\n    // IERC1820Implementer Implementation\r\n    function canImplementInterfaceForAddress(bytes32 interfaceHash, address account) external view returns (bytes32) {\r\n        if(account == address(this) \u0026\u0026 (interfaceHash == _TOKENS_RECIPIENT_INTERFACE_HASH || interfaceHash == _TOKENS_SENDER_INTERFACE_HASH)) {\r\n            return _ERC1820_ACCEPT_MAGIC;\r\n        }\r\n        else {\r\n            return bytes32(0x0);\r\n        }\r\n    }\r\n\r\n    /*\r\n        Action Functions\r\n    */\r\n\r\n    function claimOwnerRole(address _address) internal {\r\n        setOwnerAddress(_address);\r\n    }\r\n\r\n    function offerOwnerRole(address _address) internal {\r\n        setOwnerSuccessorAddress(_address);\r\n    }\r\n\r\n    /*\r\n        Withdraw Functions\r\n    */\r\n\r\n    function withdrawCoins(address _address, uint256 _value) internal {\r\n        payable(_address).transfer(_value);\r\n    }\r\n\r\n    function withdrawERC20Tokens(address _tokenAddress, address _address, uint256 _value) internal {\r\n        // Take extra care to account for tokens that don\u0027t revert on failure or that don\u0027t return a value.\r\n        // A return value is optional, but if it is present then it must be true.\r\n        if(_tokenAddress.code.length == 0) {\r\n            revert(\"ERC20TokenContractError\");\r\n        }\r\n\r\n        bytes memory callData = abi.encodeWithSelector(IERC20(_tokenAddress).transfer.selector, _address, _value);\r\n        (bool success, bytes memory returnData) = _tokenAddress.call(callData);\r\n\r\n        if(!success || (returnData.length != 0 \u0026\u0026 !abi.decode(returnData, (bool)))) {\r\n            revert(\"ERC20TokenTransferError\");\r\n        }\r\n    }\r\n\r\n    function withdrawERC721Tokens(address _tokenAddress, uint256 _id, address _address) internal {\r\n        // Take extra care to account for tokens that don\u0027t revert on failure or that don\u0027t return a value.\r\n        // A return value is optional, but if it is present then it must be true.\r\n        if(_tokenAddress.code.length == 0) {\r\n            revert(\"ERC721TokenContractError\");\r\n        }\r\n\r\n        bytes memory callData = abi.encodeWithSelector(IERC721(_tokenAddress).transferFrom.selector, address(this), _address, _id);\r\n        (bool success, bytes memory returnData) = _tokenAddress.call(callData);\r\n\r\n        if(!success || (returnData.length != 0 \u0026\u0026 !abi.decode(returnData, (bool)))) {\r\n            revert(\"ERC721TokenTransferError\");\r\n        }\r\n    }\r\n\r\n    function withdrawERC777Tokens(address _tokenAddress, address _address, uint256 _value, bytes memory _data) internal {\r\n        // Take extra care to account for tokens that don\u0027t revert on failure or that don\u0027t return a value.\r\n        // A return value is optional, but if it is present then it must be true.\r\n        if(_tokenAddress.code.length == 0) {\r\n            revert(\"ERC777TokenContractError\");\r\n        }\r\n\r\n        bytes memory callData = abi.encodeWithSelector(IERC777(_tokenAddress).send.selector, _address, _value, _data);\r\n        (bool success, bytes memory returnData) = _tokenAddress.call(callData);\r\n\r\n        if(!success || (returnData.length != 0 \u0026\u0026 !abi.decode(returnData, (bool)))) {\r\n            revert(\"ERC777TokenTransferError\");\r\n        }\r\n    }\r\n\r\n    function withdrawERC1155Tokens(address _tokenAddress, uint256 _id, address _address, uint256 _value, bytes memory _data) internal {\r\n        // Take extra care to account for tokens that don\u0027t revert on failure or that don\u0027t return a value.\r\n        // A return value is optional, but if it is present then it must be true.\r\n        if(_tokenAddress.code.length == 0) {\r\n            revert(\"ERC1155TokenContractError\");\r\n        }\r\n\r\n        bytes memory callData = abi.encodeWithSelector(IERC1155(_tokenAddress).safeTransferFrom.selector, address(this), _address, _id, _value, _data);\r\n        (bool success, bytes memory returnData) = _tokenAddress.call(callData);\r\n\r\n        if(!success || (returnData.length != 0 \u0026\u0026 !abi.decode(returnData, (bool)))) {\r\n            revert(\"ERC1155TokenTransferError\");\r\n        }\r\n    }\r\n\r\n    /*\r\n        Query Functions\r\n    */\r\n\r\n    function isLocked() internal view returns (bool) {\r\n        return lockFlag;\r\n    }\r\n\r\n    function isOwnerAddress(address _address) internal view returns (bool) {\r\n        return _address == getOwnerAddress();\r\n    }\r\n\r\n    function isOwnerSuccessorAddress(address _address) internal view returns (bool) {\r\n        return _address == getOwnerSuccessorAddress();\r\n    }\r\n\r\n    /*\r\n        Require Functions\r\n    */\r\n\r\n    function requireOwnerAddress(address _address) internal view {\r\n        if(!isOwnerAddress(_address)) {\r\n            revert NotOwnerError(_address, getOwnerAddress());\r\n        }\r\n    }\r\n\r\n    function requireOwnerSuccessorAddress(address _address) internal view {\r\n        if(!isOwnerSuccessorAddress(_address)) {\r\n            revert NotOwnerSuccessorError(_address, getOwnerSuccessorAddress());\r\n        }\r\n    }\r\n\r\n    /*\r\n        Get Functions\r\n    */\r\n\r\n    function getOwnerAddress() internal view returns (address) {\r\n        return ownerAddress;\r\n    }\r\n\r\n    function getOwnerSuccessorAddress() internal view returns (address) {\r\n        return ownerSuccessorAddress;\r\n    }\r\n\r\n    /*\r\n        Set Functions\r\n    */\r\n\r\n    function setLocked(bool _isLocked) internal {\r\n        lockFlag = _isLocked;\r\n    }\r\n    \r\n    function setOwnerAddress(address _address) internal {\r\n        if(_address != ownerAddress) {\r\n            emit OwnerChanged(ownerAddress, _address);\r\n            ownerAddress = _address;\r\n        }\r\n    }\r\n\r\n    function setOwnerSuccessorAddress(address _address) internal {\r\n        ownerSuccessorAddress = _address;\r\n    }\r\n\r\n    /*\r\n        Reentrancy Functions\r\n    */\r\n\r\n    function lock() internal {\r\n        // Call this at the start of each external function that can change state to protect against reentrancy.\r\n        if(isLocked()) {\r\n            punish();\r\n        }\r\n        setLocked(true);\r\n    }\r\n\r\n    function unlock() internal {\r\n        // Call this at the end of each external function.\r\n        setLocked(false);\r\n    }\r\n\r\n    /*\r\n        Utility Functions\r\n    */\r\n\r\n    function addressToString(address _address) internal pure returns(string memory) {\r\n        // Convert the address to a checksum address string.\r\n        return getChecksum(_address);\r\n    }\r\n\r\n    function punish() internal pure {\r\n        // This operation will cause a revert but also consume all the gas. This will punish those who are trying to attack the contract.\r\n        assembly(\"memory-safe\") { invalid() }\r\n    }\r\n\r\n    function uint256ToString(uint256 _i) internal pure returns (string memory) {\r\n        if(_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 j = _i;\r\n        uint256 len;\r\n        while(j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint256 k = len;\r\n        while(_i != 0) {\r\n            k = k-1;\r\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\r\n            bytes1 b1 = bytes1(temp);\r\n            bstr[k] = b1;\r\n            _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    /*\r\n        Address Checksum Functions\r\n    */\r\n\r\n    function getChecksum(address account) internal pure returns (string memory accountChecksum) {\r\n        return _toChecksumString(account);\r\n    }\r\n\r\n    function _toChecksumString(address account) private pure returns (string memory asciiString) {\r\n        // convert the account argument from address to bytes.\r\n        bytes20 data = bytes20(account);\r\n\r\n        // create an in-memory fixed-size bytes array.\r\n        bytes memory asciiBytes = new bytes(40);\r\n\r\n        // declare variable types.\r\n        uint8 b;\r\n        uint8 leftNibble;\r\n        uint8 rightNibble;\r\n        bool leftCaps;\r\n        bool rightCaps;\r\n        uint8 asciiOffset;\r\n\r\n        // get the capitalized characters in the actual checksum.\r\n        bool[40] memory caps = _toChecksumCapsFlags(account);\r\n\r\n        // iterate over bytes, processing left and right nibble in each iteration.\r\n        for(uint256 i = 0; i \u003c data.length; i++) {\r\n            // locate the byte and extract each nibble.\r\n            b = uint8(uint160(data) / (2**(8*(19 - i))));\r\n            leftNibble = b / 16;\r\n            rightNibble = b - 16 * leftNibble;\r\n\r\n            // locate and extract each capitalization status.\r\n            leftCaps = caps[2*i];\r\n            rightCaps = caps[2*i + 1];\r\n\r\n            // get the offset from nibble value to ascii character for left nibble.\r\n            asciiOffset = _getAsciiOffset(leftNibble, leftCaps);\r\n\r\n            // add the converted character to the byte array.\r\n            asciiBytes[2 * i] = bytes1(leftNibble + asciiOffset);\r\n\r\n            // get the offset from nibble value to ascii character for right nibble.\r\n            asciiOffset = _getAsciiOffset(rightNibble, rightCaps);\r\n\r\n            // add the converted character to the byte array.\r\n            asciiBytes[2 * i + 1] = bytes1(rightNibble + asciiOffset);\r\n        }\r\n\r\n        return string.concat(\"0x\", string(asciiBytes));\r\n    }\r\n\r\n    function _toChecksumCapsFlags(address account) private pure returns (bool[40] memory characterCapitalized) {\r\n        // convert the address to bytes.\r\n        bytes20 a = bytes20(account);\r\n\r\n        // hash the address (used to calculate checksum).\r\n        bytes32 b = keccak256(abi.encodePacked(_toAsciiString(a)));\r\n\r\n        // declare variable types.\r\n        uint8 leftNibbleAddress;\r\n        uint8 rightNibbleAddress;\r\n        uint8 leftNibbleHash;\r\n        uint8 rightNibbleHash;\r\n\r\n        // iterate over bytes, processing left and right nibble in each iteration.\r\n        for(uint256 i; i \u003c a.length; i++) {\r\n            // locate the byte and extract each nibble for the address and the hash.\r\n            rightNibbleAddress = uint8(a[i]) % 16;\r\n            leftNibbleAddress = (uint8(a[i]) - rightNibbleAddress) / 16;\r\n            rightNibbleHash = uint8(b[i]) % 16;\r\n            leftNibbleHash = (uint8(b[i]) - rightNibbleHash) / 16;\r\n\r\n            characterCapitalized[2 * i] = (leftNibbleAddress \u003e 9 \u0026\u0026 leftNibbleHash \u003e 7);\r\n            characterCapitalized[2 * i + 1] = (rightNibbleAddress \u003e 9 \u0026\u0026 rightNibbleHash \u003e 7);\r\n        }\r\n    }\r\n\r\n    function _getAsciiOffset(uint8 nibble, bool caps) private pure returns (uint8 offset) {\r\n        // to convert to ascii characters, add 48 to 0-9, 55 to A-F, \u0026 87 to a-f.\r\n        if(nibble \u003c 10) {\r\n            offset = 48;\r\n        }\r\n        else if(caps) {\r\n            offset = 55;\r\n        }\r\n        else {\r\n            offset = 87;\r\n        }\r\n    }\r\n\r\n    // based on https://ethereum.stackexchange.com/a/56499/48410\r\n    function _toAsciiString(bytes20 data) private pure returns (string memory asciiString) {\r\n        // create an in-memory fixed-size bytes array.\r\n        bytes memory asciiBytes = new bytes(40);\r\n\r\n        // declare variable types.\r\n        uint8 b;\r\n        uint8 leftNibble;\r\n        uint8 rightNibble;\r\n\r\n        // iterate over bytes, processing left and right nibble in each iteration.\r\n        for(uint256 i = 0; i \u003c data.length; i++) {\r\n            // locate the byte and extract each nibble.\r\n            b = uint8(uint160(data) / (2 ** (8 * (19 - i))));\r\n            leftNibble = b / 16;\r\n            rightNibble = b - 16 * leftNibble;\r\n\r\n            // to convert to ascii characters, add 48 to 0-9 and 87 to a-f.\r\n            asciiBytes[2 * i] = bytes1(leftNibble + (leftNibble \u003c 10 ? 48 : 87));\r\n            asciiBytes[2 * i + 1] = bytes1(rightNibble + (rightNibble \u003c 10 ? 48 : 87));\r\n        }\r\n\r\n        return string(asciiBytes);\r\n    }\r\n\r\n    /*\r\n    *\r\n    *\r\n        External Functions\r\n    *\r\n    *\r\n    */\r\n\r\n    /*\r\n        Action Functions\r\n    */\r\n\r\n    /// @notice The owner successor can claim the owner role.\r\n    function action_claimOwnerRole() external {\r\n        lock();\r\n\r\n        requireOwnerSuccessorAddress(msg.sender);\r\n\r\n        claimOwnerRole(msg.sender);\r\n\r\n        unlock();\r\n    }\r\n\r\n    /// @notice The owner can offer the owner role to a successor address.\r\n    /// @param _address The owner successor address.\r\n    function action_offerOwnerRole(address _address) external {\r\n        lock();\r\n\r\n        requireOwnerAddress(msg.sender);\r\n\r\n        offerOwnerRole(_address);\r\n\r\n        unlock();\r\n    }\r\n\r\n    /*\r\n        Withdraw Functions\r\n    */\r\n\r\n    /// @notice The owner can withdraw any amount of coins.\r\n    /// @param _value The amount of coins to withdraw.\r\n    function withdraw_coins(uint256 _value) external {\r\n        lock();\r\n\r\n        requireOwnerAddress(msg.sender);\r\n\r\n        withdrawCoins(msg.sender, _value);\r\n\r\n        unlock();\r\n    }\r\n\r\n    /// @notice The owner can withdraw any amount of one kind of ERC20 token.\r\n    /// @param _tokenAddress The address where the ERC20 token\u0027s contract lives.\r\n    /// @param _value The amount of ERC20 tokens to withdraw.\r\n    function withdraw_erc20Tokens(address _tokenAddress, uint256 _value) external {\r\n        lock();\r\n\r\n        requireOwnerAddress(msg.sender);\r\n\r\n        withdrawERC20Tokens(_tokenAddress, msg.sender, _value);\r\n\r\n        unlock();\r\n    }\r\n\r\n    /// @notice The owner can withdraw an ERC721 token.\r\n    /// @param _tokenAddress The address where the ERC721 token\u0027s contract lives.\r\n    /// @param _id The ID of the ERC721 token.\r\n    function withdraw_erc721Tokens(address _tokenAddress, uint256 _id) external {\r\n        lock();\r\n\r\n        requireOwnerAddress(msg.sender);\r\n\r\n        withdrawERC721Tokens(_tokenAddress, _id, msg.sender);\r\n\r\n        unlock();\r\n    }\r\n\r\n    /// @notice The owner can withdraw any amount of one kind of ERC777 token.\r\n    /// @param _tokenAddress The address where the ERC777 token\u0027s contract lives.\r\n    /// @param _value The amount of ERC777 tokens to withdraw.\r\n    /// @param _data Additional data with no specified format.\r\n    function withdraw_erc777Tokens(address _tokenAddress, uint256 _value, bytes memory _data) external {\r\n        lock();\r\n\r\n        requireOwnerAddress(msg.sender);\r\n\r\n        withdrawERC777Tokens(_tokenAddress, msg.sender, _value, _data);\r\n\r\n        unlock();\r\n    }\r\n\r\n    /// @notice The owner can withdraw any amount of one kind of ERC1155 token.\r\n    /// @param _tokenAddress The address where the ERC1155 token\u0027s contract lives.\r\n    /// @param _id The ID of the ERC1155 token.\r\n    /// @param _value The amount of ERC1155 tokens to withdraw.\r\n    /// @param _data Additional data with no specified format.\r\n    function withdraw_erc1155Tokens(address _tokenAddress, uint256 _id, uint256 _value, bytes memory _data) external {\r\n        lock();\r\n\r\n        requireOwnerAddress(msg.sender);\r\n\r\n        withdrawERC1155Tokens(_tokenAddress, _id, msg.sender, _value, _data);\r\n\r\n        unlock();\r\n    }\r\n\r\n    /*\r\n        Query Functions\r\n    */\r\n\r\n    /// @notice Returns whether the contract is currently locked.\r\n    /// @return Whether the contract is currently locked.\r\n    function query_isLocked() external view returns (bool) {\r\n        return isLocked();\r\n    }\r\n\r\n    /// @notice Returns whether the address is the owner address.\r\n    /// @param _address The address that we are checking.\r\n    /// @return Whether the address is the owner address.\r\n    function query_isOwnerAddress(address _address) external view returns (bool) {\r\n        return isOwnerAddress(_address);\r\n    }\r\n\r\n    /// @notice Returns whether the address is the owner successor address.\r\n    /// @param _address The address that we are checking.\r\n    /// @return Whether the address is the owner successor address.\r\n    function query_isOwnerSuccessorAddress(address _address) external view returns (bool) {\r\n        return isOwnerSuccessorAddress(_address);\r\n    }\r\n\r\n    /*\r\n        Get Functions\r\n    */\r\n\r\n    /// @notice Returns the owner address.\r\n    /// @return The owner address.\r\n    function get_ownerAddress() external view returns (address) {\r\n        return getOwnerAddress();\r\n    }\r\n\r\n    /// @notice Returns the owner successor address.\r\n    /// @return The owner successor address.\r\n    function get_ownerSuccessorAddress() external view returns (address) {\r\n        return getOwnerSuccessorAddress();\r\n    }\r\n\r\n    /*\r\n        Fail-Safe Functions\r\n    */\r\n\r\n    /// @notice The owner can unlock the contract.\r\n    function failsafe_unlock() external {\r\n        requireOwnerAddress(msg.sender);\r\n\r\n        setLocked(false);\r\n    }\r\n\r\n    /*\r\n        Donate Functions\r\n    */\r\n\r\n    /// @notice Anyone can call this to donate funds to the contract.\r\n    function donate() external payable {}\r\n}"}}