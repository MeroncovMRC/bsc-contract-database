{"Address.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\n\r\n\r\nlibrary Address {\r\n\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256(\u0027\u0027)`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash \u0026\u0026 codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity\u0027s `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length \u003e 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n\r\n}"},"IERC20.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    \r\n    function symbol() external view returns(string memory);\r\n    \r\n    function name() external view returns(string memory);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n    \r\n    /**\r\n     * @dev Returns the number of decimal places\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"},"ISurge.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\n\r\n/**\r\n * Exempt Surge Interface\r\n */\r\ninterface ISurge {\r\n    function sell(uint256 amount) external;\r\n    function getUnderlyingAsset() external returns(address);\r\n}"},"ISurgeFund.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\n\r\n/**\r\n * Exempt Surge Interface\r\n */\r\ninterface ISurgeFund {\r\n    function remainingBnbToClaimForVictim(address victim) external view returns (uint256);\r\n}"},"IUniswapV2Router02.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\n\r\n\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}"},"ReentrantGuard.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status;\r\n    constructor () {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}"},"SafeMath.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003c= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003e 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}"},"SurgeFund.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./Address.sol\";\r\nimport \"./IERC20.sol\";\r\nimport \"./ReentrantGuard.sol\";\r\nimport \"./IUniswapV2Router02.sol\";\r\nimport \"./ISurgeFund.sol\";\r\nimport \"./ISurge.sol\";\r\n\r\ncontract SurgeFund is ReentrancyGuard, IERC20 {\r\n    \r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n    \r\n    // PCS Router\r\n    IUniswapV2Router02 router;\r\n\r\n    // initial amount of BNB needed to pay back\r\n    uint256 public initialPaybackAmount = 12600 * 10**18;\r\n\r\n    // Total Amount of BNB Needed To Give Back\r\n    uint256 public totalShares;\r\n\r\n    // Victims\r\n    mapping ( address =\u003e Victim ) victims;\r\n    mapping ( address =\u003e bool ) functionCaller;\r\n    mapping ( address =\u003e address ) surgeToUnderlying;\r\n    address[] surges;\r\n\r\n    struct Victim {\r\n        uint256 lastClaim;\r\n        uint256 totalToClaim;\r\n        uint256 totalExcluded;\r\n    }\r\n\r\n    // Total Dividends Per Share\r\n    uint256 dividends;\r\n    uint256 precision = 10**18;\r\n    \r\n    // how many block numbers until next claim\r\n    uint256 public claimWaitPeriod = 100;\r\n    // minimum claim 0.005 BNB\r\n    uint256 public minimumClaim = 5 * 10**15;\r\n\r\n    // LOCKS Certain Functions\r\n    bool public isLocked = false;\r\n    address public owner;\r\n\r\n    modifier onlyOwner() {require(msg.sender == owner, \u0027Only Owner\u0027); _;}\r\n    modifier onlyCaller() {require(functionCaller[msg.sender], \u0027Only Function Caller\u0027); _;}\r\n    modifier locked() { require(!isLocked, \u0027Function Is Locked\u0027); _; }\r\n\r\n    bool receiveDisabled;\r\n\r\n    ISurgeFund oldFund = ISurgeFund(0x95c8eE08b40107f5bd70c28c4Fd96341c8eaD9c7);\r\n\r\n    // surge bnb \r\n    address SBNB;\r\n    \r\n    constructor() {\r\n        router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n        owner = msg.sender;\r\n        functionCaller[msg.sender] = true;\r\n\r\n        _addSurgeToken(0xb68c9D9BD82BdF4EeEcB22CAa7F3Ab94393108a1, 0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c);\r\n        _addSurgeToken(0xbF6bB9b8004942DFb3C1cDE3Cb950AF78ab8A5AF, 0x3EE2200Efb3400fAbB9AacF31297cBdD1d435D47);\r\n        _addSurgeToken(0x254246331cacbC0b2ea12bEF6632E4C6075f60e2, 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\r\n\r\n    }\r\n\r\n    function totalSupply() external view override returns (uint256) { return totalShares; }\r\n    function balanceOf(address account) public view override returns (uint256) { return usersCurrentClaim(account); }\r\n    function allowance(address holder, address spender) external pure override returns (uint256) { return holder == spender ? 0 : 1; }\r\n    \r\n    function name() public pure override returns (string memory) {\r\n        return \"SurgeFund\";\r\n    }\r\n\r\n    function symbol() public pure override returns (string memory) {\r\n        return \"SurgeFund\";\r\n    }\r\n\r\n    function decimals() public pure override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public view override returns (bool) {\r\n        return spender != msg.sender \u0026\u0026 amount \u003e 0;\r\n    }\r\n  \r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        _claim(recipient);\r\n        return recipient == msg.sender || amount \u003e 0;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external pure override returns (bool) {\r\n        return sender != recipient || amount \u003e 0;\r\n    }\r\n\r\n\r\n    // CONTROL FUNCTIONS\r\n\r\n    function transferOwnership(address newOwner) external locked onlyOwner {\r\n        owner = newOwner;\r\n        emit TransferOwnership(newOwner);\r\n    }\r\n\r\n    function setMinimumClaim(uint256 minClaim) external locked onlyOwner {\r\n        minimumClaim = minClaim;\r\n    }\r\n\r\n    function setFunctionCaller(address user, bool isCaller) external locked onlyOwner {\r\n        functionCaller[user] = isCaller;\r\n    }\r\n\r\n    function addSurgeToken(address token, address underlying) external onlyOwner {\r\n        _addSurgeToken(token, underlying);\r\n    }\r\n\r\n    /** Adds Victims To The Fund, Cannot Be Accessed If Function is Locked */\r\n    function pullVictims(address[] calldata _victims) external locked onlyOwner {\r\n        for (uint i = 0; i \u003c _victims.length; i++) {\r\n\r\n            uint256 claim_ = oldFund.remainingBnbToClaimForVictim(_victims[i]);\r\n            if (claim_ \u003e 0 \u0026\u0026 victims[_victims[i]].totalToClaim == 0) {\r\n                addVictim(_victims[i], claim_);\r\n            }\r\n        }\r\n    }\r\n\r\n    function migrateVictim(address old, address newVictim) external locked onlyOwner {\r\n        require(victims[newVictim].totalToClaim == 0, \u0027NewVictim Already Victim\u0027);\r\n        require(victims[old].totalToClaim \u003e 0, \u0027Old Victim Not A Victim\u0027);\r\n\r\n        victims[newVictim].totalToClaim = victims[old].totalToClaim;\r\n        victims[newVictim].totalExcluded = victims[old].totalExcluded;\r\n\r\n        delete victims[old];\r\n        emit Transfer(old, newVictim, victims[newVictim].totalToClaim);\r\n    }\r\n\r\n    function adjustVictim(address victim, uint256 newClaim) external locked onlyOwner {\r\n\r\n        uint256 previousClaim = victims[victim].totalToClaim;\r\n        uint256 pending = usersCurrentClaim(victim);\r\n        totalShares = totalShares.add(newClaim).sub(previousClaim);\r\n\r\n        victims[victim].totalToClaim = newClaim;\r\n\r\n        if (pending \u003e 0) {\r\n            _distributeShares(pending);\r\n        }\r\n\r\n        victims[victim].totalExcluded = currentDividends(newClaim);\r\n\r\n        if (previousClaim \u003e newClaim) {\r\n            emit Transfer(victim, address(0), (previousClaim - newClaim));\r\n        } else {\r\n            emit Transfer(address(0), victim, (newClaim - previousClaim));\r\n        }\r\n\r\n    }\r\n    \r\n    /** Locks Out Specific Functions From Being Called */\r\n    function LockTheContract() external locked onlyOwner {\r\n        isLocked = true;\r\n        emit LockedContract(block.timestamp, block.number);\r\n    }\r\n\r\n    function sellAllTokenForBNB(address token) external onlyCaller {\r\n        uint256 tokenBalance = IERC20(token).balanceOf(address(this));\r\n        require(tokenBalance \u003e 0, \u0027cannot sell zero tokens\u0027);\r\n        _sellTokenForBNB(token, tokenBalance);\r\n    }\r\n    \r\n    function sellAllTokenForBNBSupportingFees(address token) external onlyCaller {\r\n        uint256 tokenBalance = IERC20(token).balanceOf(address(this));\r\n        require(tokenBalance \u003e 0, \u0027cannot sell zero tokens\u0027);\r\n        _sellTokenForBNBSupportingTransferFees(token, tokenBalance);\r\n    }\r\n    \r\n    function sellTokenForBNB(address token, uint256 tokenBalance) external onlyCaller {\r\n        require(tokenBalance \u003e 0 \u0026\u0026 tokenBalance \u003c= IERC20(token).balanceOf(address(this)), \u0027invalid token amount\u0027);\r\n        _sellTokenForBNB(token, tokenBalance);\r\n    }\r\n    \r\n    function sellTokenForBNBSupportingFees(address token, uint256 tokenBalance) external onlyCaller {\r\n        require(tokenBalance \u003e 0 \u0026\u0026 tokenBalance \u003c= IERC20(token).balanceOf(address(this)), \u0027invalid token amount\u0027);\r\n        _sellTokenForBNBSupportingTransferFees(token, tokenBalance);\r\n    }\r\n\r\n    function sellSurgeTokenForBNB(address surgetoken) external onlyCaller {\r\n\r\n        address underlying = surgeToUnderlying[surgetoken];\r\n        require(underlying != address(0), \u0027Zero Underlying\u0027);\r\n\r\n        _sellSurgeTokenForBNB(surgetoken, underlying);\r\n    }\r\n\r\n    function sellSurgeTokenForBNB(address surgetoken, address underlying) external onlyCaller {\r\n        _sellSurgeTokenForBNB(surgetoken, underlying);\r\n    }\r\n\r\n    function sellAllSurgesForBNB() external onlyCaller {\r\n        for (uint i = 0; i \u003c surges.length; i++) {\r\n            _sellSurgeTokenForBNB(surges[i], surgeToUnderlying[surges[i]]);\r\n        }\r\n    }\r\n\r\n    /** Sells Surge Tokens For Their Underlying Asset To Be Converted Into BNB */\r\n    function sellSurgeTokenForUnderlyingAsset(address surgeToken) external onlyCaller {\r\n        require(surgeToken != SBNB, \u0027Call SellSurgeBNB() function specifically\u0027);\r\n        uint256 bal = IERC20(surgeToken).balanceOf(address(this));\r\n        if (bal \u003e 0) {\r\n            ISurge(payable(surgeToken)).sell(bal);\r\n        }\r\n    }\r\n    \r\n    /** Sells Surge BNB Token For Its Underlying Asset (BNB) */\r\n    function sellSurgeBNB() external onlyCaller {\r\n        // make sure we. have set SBNB\r\n        require(SBNB != address(0), \u0027Must Declare SBNB First\u0027);\r\n        // SBNB token balances \r\n        uint256 tokenBalance = IERC20(SBNB).balanceOf(address(this));\r\n        // Make sure we have tokens to send\r\n        require(tokenBalance \u003e 1000, \u0027Cannot Sell Zero SurgeBNB\u0027);\r\n        // bnb balance\r\n        uint256 bnbBalanceBefore = address(this).balance;\r\n\r\n        receiveDisabled = true;\r\n        // sell SBNB Tokens\r\n        ISurge(payable(SBNB)).sell(tokenBalance);\r\n\r\n        receiveDisabled = false;\r\n\r\n        uint256 received = address(this).balance - bnbBalanceBefore;\r\n        _distributeShares(received);\r\n    }\r\n    \r\n    /** Sets The SurgeBNB Contract Address */\r\n    function setSurgeBNBAddress(address _sbnb) external onlyOwner {\r\n        require(SBNB == address(0), \u0027SBNB already set\u0027);\r\n        SBNB = _sbnb;\r\n        emit SetSurgeBNBAddress(_sbnb);\r\n    }\r\n    \r\n    /** In The Case Of A Fund Migration (due to error) Migrates Funds To Another Fund, CANNOT be Called If Locked */\r\n    function migrateToNewFundIfUnlocked(bool migrateBNB, address token, address recipient) external locked onlyOwner {\r\n        bool success;\r\n        uint256 amount = migrateBNB ? address(this).balance : IERC20(token).balanceOf(address(this));\r\n        // migrate bnb or tokens to new fund\r\n        if (migrateBNB) {\r\n            (success,) = payable(recipient).call{value: amount}(\"\");\r\n            require(success);\r\n        } else {\r\n            (success) = IERC20(token).transfer(recipient, amount);\r\n            // ensure migration worked\r\n            require(success, \u0027Withdrawal Failed\u0027);\r\n        }\r\n\r\n        // tell blockchain\r\n        emit FundMigration(migrateBNB, amount, token, recipient);\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n    \r\n    /** Opts Out Of Receive Surge Fund Rewards*/\r\n    function optOut(uint256 percent) external nonReentrant {\r\n        require(victims[msg.sender].totalToClaim \u003e 0, \u0027No Funds To Opt Out\u0027);\r\n        require(percent \u003c= 100 \u0026\u0026 percent \u003e 0, \u0027Invalid Percent\u0027);\r\n\r\n        // quantity user could have claimed\r\n        uint256 donation = victims[msg.sender].totalToClaim.mul(percent).div(100);\r\n\r\n        // pending rewards for user\r\n        uint256 pending = usersCurrentClaim(msg.sender);\r\n\r\n        // decrement total shares\r\n        totalShares = totalShares.sub(donation);\r\n\r\n        if (percent == 100) {\r\n            // delete struct\r\n            delete victims[msg.sender];\r\n\r\n            if (pending \u003e 0 \u0026\u0026 totalShares \u003e 0) {\r\n                _distributeShares(pending);\r\n            }\r\n\r\n        } else {\r\n            victims[msg.sender].totalToClaim -= donation;\r\n\r\n            if (pending \u003e 0 \u0026\u0026 totalShares \u003e 0) {\r\n                _distributeShares(pending);\r\n            }\r\n\r\n            victims[msg.sender].totalExcluded = currentDividends(victims[msg.sender].totalToClaim);\r\n        }\r\n        emit Transfer(msg.sender, address(0), donation);\r\n        // Tell Blockchain\r\n        emit OptOut(msg.sender, donation);\r\n    }\r\n\r\n    function claim() external nonReentrant {\r\n        _claim(msg.sender);\r\n    }\r\n\r\n    /** Claims Holdings Specific User Has Access To */\r\n    function _claim(address user) internal {\r\n\r\n        // Amount of BNB Sender Can Claim\r\n        uint256 toClaim = usersCurrentClaim(user);\r\n\r\n        // Make Sure We Sender Can Claim \r\n        require(victims[user].totalToClaim \u003e 0, \u0027No Claims To Make\u0027);\r\n        // Make Sure Enough Time Has Passed\r\n        require(victims[user].lastClaim \u003c block.number, \u0027Same Block Entry\u0027);\r\n        // Make Sure We Can Claim Above The Minimum Amount\r\n        require(toClaim \u003e= minimumClaim, \u0027Below Minimum Claim\u0027);\r\n\r\n        // update claim block\r\n        victims[user].lastClaim = block.number;\r\n\r\n\r\n        if (toClaim \u003e victims[user].totalToClaim) {\r\n            // only claim total amount, reflect the rest\r\n            uint256 prevClaim = victims[user].totalToClaim;\r\n\r\n            // amount to reflect\r\n            uint256 diff = toClaim - prevClaim;\r\n\r\n            // Subtract Claim Amount From Sender\r\n            delete victims[user];\r\n\r\n            // subtract from total shares\r\n            totalShares = totalShares.sub(prevClaim);\r\n\r\n            if (totalShares \u003e 0) {\r\n                // distribute difference\r\n                _distributeShares(diff);\r\n            }\r\n            \r\n            // update claim amount\r\n            toClaim = prevClaim;\r\n        \r\n        } else {\r\n\r\n            // Subtract Claim Amount From Sender\r\n            victims[user].totalToClaim = victims[user].totalToClaim.sub(toClaim, \u0027subtraction underflow on victim claims\u0027);\r\n            totalShares = totalShares.sub(toClaim);\r\n\r\n            // Remove Rest Of Claim If Below Minimum\r\n            if (victims[user].totalToClaim \u003c minimumClaim) {\r\n            \r\n                uint256 remainingClaim = victims[user].totalToClaim;\r\n                delete victims[user];\r\n                if (remainingClaim \u003e 0) {\r\n                    toClaim += remainingClaim;\r\n                    totalShares = totalShares.sub(remainingClaim);\r\n                }      \r\n            }\r\n        }\r\n\r\n        // update excluded rewards\r\n        victims[user].totalExcluded = currentDividends(victims[user].totalToClaim);\r\n\r\n        // Send BNB To Victim\r\n        (bool successful,) = payable(user).call{value: toClaim, gas: 2600}(\"\");\r\n        // Require A Successful Claim\r\n        require(successful, \u0027BNB Transfer Failed\u0027);\r\n        emit Transfer(user, address(0), toClaim);\r\n        // Tell Blockchain\r\n        emit Claim(user, toClaim);\r\n    }\r\n    \r\n    /** Adds Victim To The List Of Victims If Contract Is Unlocked */\r\n    function addVictim(address victim, uint256 victimClaim) private {\r\n        \r\n        if (victims[victim].totalToClaim \u003e 0 || victimClaim == 0) {\r\n            return;\r\n        } \r\n\r\n        totalShares = totalShares.add(victimClaim);\r\n\r\n        victims[victim].totalToClaim = victimClaim;\r\n        victims[victim].totalExcluded = currentDividends(victimClaim);\r\n        emit Transfer(address(0), victim, victimClaim);\r\n    }\r\n    \r\n    /** How Much BNB This User Has Left To Claim */\r\n    function bnbToClaimForVictim(address victim) external view returns (uint256) {\r\n        return victims[victim].totalToClaim;\r\n    }\r\n        \r\n    /** If Sender Has BNB Left To Claim */\r\n    function isVictim(address user) external view returns (bool) {\r\n        return victims[user].totalToClaim \u003e 0;\r\n    }\r\n\r\n     function _addSurgeToken(address token, address underlying) internal {\r\n        surgeToUnderlying[token] = underlying;\r\n        surges.push(token);\r\n    }\r\n\r\n    function _sellSurgeTokenForBNB(address surgeToken, address underlyingAsset) internal {\r\n        require(surgeToken != SBNB, \u0027Call SellSurgeBNB() function specifically\u0027);\r\n        uint256 bal = IERC20(surgeToken).balanceOf(address(this));\r\n        if (bal \u003e 0) {\r\n            ISurge(payable(surgeToken)).sell(bal);\r\n        }\r\n        uint256 tokenBalance = IERC20(underlyingAsset).balanceOf(address(this));\r\n        _sellTokenForBNBSupportingTransferFees(underlyingAsset, tokenBalance);\r\n    }\r\n    \r\n    /** Sell Donation Tokens For BNB */\r\n    function _sellTokenForBNB(address token, uint256 tokenBalance) private {\r\n        // path from TOKEN -\u003e BNB\r\n        address[] memory path = new address[](2);\r\n        path[0] = token;\r\n        path[1] = router.WETH();\r\n        // bnb balance before swap\r\n        uint256 before = address(this).balance;\r\n        // approve router\r\n        IERC20(token).approve(address(router), tokenBalance);\r\n\r\n        receiveDisabled = true;\r\n\r\n        // make the swap\r\n        router.swapExactTokensForETH(\r\n            tokenBalance,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp.add(30)\r\n        );\r\n        // how much BNB received from swap\r\n        uint256 bnbAdded = address(this).balance - before;\r\n\r\n        receiveDisabled = false;\r\n        if (totalShares \u003e 0) {\r\n            _distributeShares(bnbAdded);\r\n        }\r\n    }\r\n    \r\n    /** Sell Donation Tokens For BNB If Token Has Transfer Fee */\r\n    function _sellTokenForBNBSupportingTransferFees(address token, uint256 tokenBalance) private {\r\n\r\n        // path from TOKEN -\u003e BNB\r\n        address[] memory path = new address[](2);\r\n        path[0] = token;\r\n        path[1] = router.WETH();\r\n        // bnb balance before swap\r\n        uint256 before = address(this).balance;\r\n        // approve router\r\n        IERC20(token).approve(address(router), tokenBalance);\r\n\r\n        receiveDisabled = true;\r\n\r\n        // make the swap\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenBalance,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp.add(30)\r\n        );\r\n\r\n        // how much BNB received from swap\r\n        uint256 bnbAdded = address(this).balance.sub(before);\r\n        \r\n        receiveDisabled = false;\r\n        _distributeShares(bnbAdded);\r\n    }\r\n\r\n\r\n    function _distributeShares(uint256 numShares) internal {\r\n        dividends += numShares.mul(precision).div(totalShares);\r\n    }\r\n    \r\n    function currentDividends(uint256 share) internal view returns (uint256) {\r\n        return share.mul(dividends).div(precision);\r\n    }\r\n\r\n    function totalBNBPaidBack() external view returns (uint256) {\r\n        return initialPaybackAmount - totalShares;\r\n    }\r\n    \r\n    function usersCurrentClaim(address user) internal view returns (uint256) {\r\n        uint256 amount = victims[user].totalToClaim;\r\n        if(amount == 0){ return 0; }\r\n\r\n        uint256 shareholderTotalDividends = currentDividends(amount);\r\n        uint256 shareholderTotalExcluded = victims[user].totalExcluded;\r\n\r\n        if(shareholderTotalDividends \u003c= shareholderTotalExcluded){ return 0; }\r\n\r\n        return shareholderTotalDividends.sub(shareholderTotalExcluded);\r\n    }\r\n    \r\n    /** Register Donation On Receive */\r\n    receive() external payable {\r\n\r\n        if (receiveDisabled || msg.sender == address(router)) {\r\n            return;\r\n        }\r\n\r\n        _distributeShares(msg.value);\r\n    }\r\n    \r\n    // EVENTS\r\n    event OptOut(address generousUser, uint256 rewardGivenUp);\r\n    event LockedContract(uint256 timestamp, uint256 blockNumber);\r\n    event FundMigration(bool migratedBNB, uint256 amount, address token, address recipient);\r\n    event Claim(address claimer, uint256 amountBNB);\r\n    event SetSurgeBNBAddress(address newSurgeBNB);\r\n    event TransferOwnership(address newOwner);\r\n\r\n}"}}