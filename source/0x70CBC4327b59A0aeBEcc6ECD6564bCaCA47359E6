{"AggregatorV3Interface.sol":{"content":"/**\n *Submitted for verification on 2023-05-09\n*/\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}"},"Context.sol":{"content":"/**\n *Submitted for verification on 2023-05-09\n*/\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/**\n * @title Context\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n */\ncontract Context {\n    constructor () { }\n\n    /**\n     * @dev Returns the address of the account that initiated the transaction.\n     */\n    function _msgSender() internal view returns (address) {\n        return msg.sender;\n    }\n\n    /**\n     * @dev Returns the bytes that were sent with the transaction.\n     */\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}"},"MultiSigWallet.sol":{"content":"/**\n *Submitted for verification on 2023-05-09\n*/\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ncontract MultiSigWallet {\n    uint public minApprovals; // minimum number of required approvals for a transaction\n    address[] public owners; // list of owners who can approve transactions\n    mapping(address =\u003e bool) public isOwner; // mapping to check if an address is an owner\n    uint public transactionCount; // counter to keep track of the number of transactions\n    \n    struct Transaction {\n        address payable to;\n        uint amount;\n        uint approvals;\n        bool executed;\n        mapping(address =\u003e bool) hasApproved;\n    }\n    \n    mapping(uint =\u003e Transaction) public transactions; // mapping to store transactions\n    \n    event TransactionCreated(uint id, address from, address to, uint amount);\n    event ApprovalReceived(uint id, address approver);\n    event TransactionExecuted(uint id, address executor);\n    \n    constructor(uint _minApprovals, address[] memory _owners) {\n        require(_minApprovals \u003e 0 \u0026\u0026 _owners.length \u003e 0 \u0026\u0026 _minApprovals \u003c= _owners.length, \"Invalid input\");\n        minApprovals = _minApprovals;\n        for (uint i = 0; i \u003c _owners.length; i++) {\n            address owner = _owners[i];\n            require(owner != address(0) \u0026\u0026 !isOwner[owner], \"Invalid owner\");\n            owners.push(owner);\n            isOwner[owner] = true;\n        }\n    }\n    \n    function createTransaction(address payable _to, uint _amount) public onlyOwners {\n        require(_to != address(0), \"Invalid address\");\n        uint id = transactionCount++;\n        Transaction storage transaction = transactions[id];\n        transaction.to = _to;\n        transaction.amount = _amount;\n        transaction.approvals = 0;\n        transaction.executed = false;\n        emit TransactionCreated(id, msg.sender, _to, _amount);\n    }\n    \n    function approveTransaction(uint _id) public onlyOwners {\n        Transaction storage transaction = transactions[_id];\n        require(!transaction.executed \u0026\u0026 !transaction.hasApproved[msg.sender], \"Invalid transaction\");\n        transaction.hasApproved[msg.sender] = true;\n        transaction.approvals++;\n        emit ApprovalReceived(_id, msg.sender);\n        if (transaction.approvals \u003e= minApprovals) {\n            executeTransaction(_id);\n        }\n    }\n    \n    function executeTransaction(uint _id) public onlyOwners {\n        Transaction storage transaction = transactions[_id];\n        require(!transaction.executed \u0026\u0026 transaction.approvals \u003e= minApprovals, \"Invalid transaction\");\n        transaction.executed = true;\n        transaction.to.transfer(transaction.amount);\n        emit TransactionExecuted(_id, msg.sender);\n    }\n    \n    modifier onlyOwners {\n        require(isOwner[msg.sender], \"Not an owner\");\n        _;\n    }\n}"},"Ownable.sol":{"content":"/**\n *Submitted for verification on 2023-05-09\n*/\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n// This contract defines an owner, which can be transferred or renounced, and provides a modifier to restrict access to owner-only functionality.\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    // The constructor sets the initial owner as the deployer of the contract.\n    constructor() {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    // Returns the current owner of the contract.\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    // A modifier that requires the sender to be the current owner of the contract.\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    // Allows the current owner to relinquish control of the contract.\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    // Allows the current owner to transfer control of the contract to a new owner.\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}"},"Pausable.sol":{"content":"/**\n *Submitted for verification on 2023-05-09\n*/\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n// Importing the Ownable contract from another file\nimport \"./Ownable.sol\";\n\n// Defining a Pausable abstract contract, which is derived from the Ownable contract\nabstract contract Pausable is Ownable {\n\n    // Private boolean variable to keep track of whether the contract is paused or not\n    bool private _paused;\n\n    // Events that are emitted when the contract is paused or unpaused\n    event Paused(address account);\n    event Unpaused(address account);\n\n    // Constructor function that sets the initial value of _paused to false\n    constructor() {\n        _paused = false;\n    }\n\n    // Function to check whether the contract is paused or not\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    // Modifier that can be used to only allow function calls when the contract is not paused\n    modifier whenNotPaused() {\n        require(!_paused, \"Paused\");\n        _;\n    }\n\n    // Modifier that can be used to only allow function calls when the contract is paused\n    modifier whenPaused() {\n        require(_paused, \"Not paused\");\n        _;\n    }\n\n    // Function to pause the contract, which can only be called by the contract owner and only when the contract is not already paused\n    function pause() public onlyOwner whenNotPaused {\n        _paused = true;\n        emit Paused(msg.sender);\n    }\n\n    // Function to unpause the contract, which can only be called by the contract owner and only when the contract is already paused\n    function unpause() public onlyOwner whenPaused {\n        _paused = false;\n        emit Unpaused(msg.sender);\n    }\n}"},"ReentrancyGuard.sol":{"content":"/**\n *Submitted for verification on 2023-05-09\n*/\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/**\n * @title Helps contracts guard against reentrancy attacks.\n */\ncontract ReentrancyGuard {\n    bool private _notEntered;\n\n    constructor () {\n        // Storing an initial non-zero value makes deployment a bit more\n        // expensive, but in exchange the refund on every call to nonReentrant\n        // will be lower in amount. Since refunds are capped to a percetange of\n        // the total transaction\u0027s gas, it is best to keep the heavier operations\n        // at the beginning of the function so that the refund is larger.\n        _notEntered = true;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * @notice If you mark a function `nonReentrant`, you should also\n     * mark it `external`. Calling one nonReentrant function from\n     * another is not supported. Instead, you can implement a\n     * `private` function doing the actual work, and a `external`\n     * wrapper marked as `nonReentrant`.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _notEntered = false;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see: https://eips.ethereum.org/EIPS/eip-2200)\n        _notEntered = true;\n    }\n}"},"SafeMath.sol":{"content":"/**\n *Submitted for verification on 2023-05-09\n*/\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n// A library for performing arithmetic operations with overflow and underflow protection.\nlibrary SafeMath {\n    \n    // Adds two unsigned integers with overflow protection.\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        // If the result is smaller than one of the operands, overflow occurred.\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    // Subtracts two unsigned integers with underflow protection.\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        // If the second operand is greater than the first, underflow occurred.\n        require(b \u003c= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n        return c;\n    }\n\n    // Multiplies two unsigned integers with overflow protection.\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // If either operand is zero, the result is zero.\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        // If the result divided by the first operand is not equal to the second operand, overflow occurred.\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    // Divides two unsigned integers with zero division protection.\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // If the second operand is zero, division by zero occurred.\n        require(b \u003e 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        return c;\n    }\n}"},"SGold.sol":{"content":"/**\n *Submitted for verification on 2023-05-09\n*/\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n// SGold - a crypto token that emits the price of gold. \n// SGold - this token is a typical stable representation of the real virtual gold price in US dollars.\n// SGold - otherwise Smart Gold.\n// SGold - designed so that everyone can have \"Virtual Smart Gold\" on their cryptocurrency wallet in a simple, fast and secure way.\n// SGold - our project allows you to make a transaction via SGold crypto-token as the equivalent of 1:1 the price of physical gold given in the United States Dollar.\n\n// Importing external contracts\nimport \"./MultiSigWallet.sol\";\nimport \"./Ownable.sol\";\nimport \"./AggregatorV3Interface.sol\";\nimport \"./Context.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Pausable.sol\";\nimport \"./ReentrancyGuard.sol\";\n\ncontract SGold {\n    // Token metadata\n    string public constant name = \"SGold\";\n    string public constant symbol = \"SGOLD\";\n    uint8 public constant decimals = 18;\n    uint256 public totalSupply = 100000000 * 10 ** uint256(decimals); // maximum number of SGold token pool\n\n    // Token distribution\n    uint256 public pool;\n    uint256 public monthlySupply = 500000 * 10 ** uint256(decimals); // monthly number of tokens added to the general pool of SGold\n    uint256 public lastSupplyDate;\n    address[] public holders;\n    address public owner;\n    mapping(address =\u003e bool) public ownerships;\n    mapping(address =\u003e bool) public blocked;\n    mapping(address =\u003e mapping(address =\u003e uint256)) public allowed;\n\n    // Balances\n    mapping(address =\u003e uint256) public balances;\n\n    // Get token balance of an address\n    function balanceOf(address account) public view returns (uint256) {\n        return balances[account];\n    }\n\n    AggregatorV3Interface private priceFeed;\n    uint256 private sGoldPrice;\n\n    constructor() {\n        // Contract initialization...\n        priceFeed = AggregatorV3Interface(0x86896fEB19D8A607c3b11f2aF50A0f239Bd71CD0);\n        owner = msg.sender;\n        updateSGoldPrice();\n        pool = 40000000 * 10 ** uint256(decimals); // the starting number of SGold tokens released\n        balances[msg.sender] = pool;\n        lastSupplyDate = block.timestamp;\n        totalSupply = 100000000 * 10 ** uint256(decimals);\n        emit Transfer(address(0), msg.sender, pool);\n    }\n\n    function sendTokens() public onlyOwner {\n        require(totalSupply \u003c 100000000 * 10 ** uint256(decimals), \"Token supply limit reached\");\n        require(block.timestamp \u003e= lastSupplyDate + 200 days, \"Function can only be called once every 200 days\");\n\n        address[] memory eligibleAddresses = new address[](5);\n        uint256 count = 0;\n\n        // Find eligible addresses with at least 2 SGold balance\n        for (uint256 i = 0; i \u003c holders.length; i++) {\n            if (balanceOf(holders[i]) \u003e= 2 * 10 ** uint256(decimals)) {\n                eligibleAddresses[count] = holders[i];\n                count++;\n                if (count \u003e= 5) {\n                    break;\n                }\n            }\n        }\n\n        require(count \u003e= 5, \"Not enough eligible addresses\");\n\n        // Send 15 SGold to each eligible address\n        for (uint256 i = 0; i \u003c 5; i++) {\n            address recipient = eligibleAddresses[i];\n            balances[owner] -= 15 * 10 ** uint256(decimals);\n            balances[recipient] += 15 * 10 ** uint256(decimals);\n            emit Transfer(owner, recipient, 15 * 10 ** uint256(decimals));\n        }\n\n        lastSupplyDate = block.timestamp;\n    }\n    \n    // Function to update the SGold price based on Chainlink Aggregator\n    function updateSGoldPrice() internal {\n        (, int256 price, , , ) = priceFeed.latestRoundData();\n        require(price \u003e 0, \"Invalid price\");\n\n        sGoldPrice = uint256(price) * 10 ** (decimals - priceFeed.decimals());\n    }\n\n    // Function to get the current SGold price\n    function getSGoldPrice() public view returns (uint256) {\n        return sGoldPrice;\n    }\n\n    /**\n     * @dev Updates the price from Chainlink.\n     * @return The updated price of sGold.\n     */\n    function updatePrice() public view returns (uint256) {\n        (, int256 price, , , ) = priceFeed.latestRoundData();\n        require(price \u003e 0, \"Invalid price\");\n\n        // Process the price\n        uint256 updatedPrice = uint256(price) * 1e10; // Example conversion to sGold price (multiplier 1e10)\n\n        // Perform further operations with the new price...\n\n        return updatedPrice;\n    }\n\n    /**\n    * @dev Emitted when the price feed contract address is updated.\n    * @param newPriceFeed The new price feed contract address.\n    */\n    event PriceFeedSet(address indexed newPriceFeed);\n\n   // Function to continuously update the SGold price every 1 minute\n    function updatePriceEveryMinute() public {\n    require(msg.sender == owner, \"Only owner can call this function\");\n\n        while (true) {\n            updateSGoldPrice();\n            // Delay for 1 minute\n            uint256 endTime = block.timestamp + 60;\n            while (block.timestamp \u003c endTime) {\n                // Wait for 1 minute\n            }\n        }\n    }\n\n    /**\n    * @dev Sets the price feed address.\n    * @param newPriceFeed The new address of the price feed.\n    */\n    function setPriceFeed(address newPriceFeed) public onlyOwner {\n    require(newPriceFeed != address(0), \"Invalid price feed address\");\n\n    priceFeed = AggregatorV3Interface(newPriceFeed);\n    emit PriceFeedSet(newPriceFeed);\n    }\n\n    // Get the allowance for a spender to spend on behalf of an owner\n    function allowance(address ownerAddr, address spender) public view returns (uint256) {\n    return allowed[ownerAddr][spender];\n    }\n\n    /**\n     * @dev Internal function to set the allowance for a spender.\n    * @param tokenOwner The address of the token owner.\n    * @param spender The address of the token spender.\n    * @param amount The allowance amount to set.\n    */\n    function _approve(address tokenOwner, address spender, uint256 amount) internal {\n    require(tokenOwner != address(0), \"Invalid token owner address\");\n    require(spender != address(0), \"Invalid spender address\");\n\n    allowed[tokenOwner][spender] = amount;\n    emit Approval(tokenOwner, spender, amount);\n    }\n\n    /**\n    * @dev Increases the allowance for the spender to spend on behalf of the caller.\n    * @param spender The address of the spender.\n    * @param addedAmount The additional allowance amount to add.\n    * @return A boolean value indicating whether the operation was successful.\n    */\n    function increaseAllowance(address spender, uint256 addedAmount) public returns (bool) {\n    _approve(msg.sender, spender, allowed[msg.sender][spender] + addedAmount);\n    return true;\n    }\n\n    /**\n    * @dev Modifier that allows a function to be called only by the contract owner.\n    *\n    * This modifier checks if the caller of the function is the contract owner.\n    * If the caller is not the owner, it reverts the transaction with an error message.\n    * If the caller is the owner, it proceeds with the execution of the function.\n    */\n    modifier onlyOwner() {\n    require(msg.sender == owner, \"Only the contract owner can call this function\");\n    _;\n    }\n\n    // A function to retrieve the value of owner\n    function getOwner() public view returns (address) {\n        return owner;\n    }\n\n    /**\n    * @dev Decreases the allowance for the spender to spend on behalf of the caller.\n    * @param spender The address of the spender.\n    * @param subtractedAmount The subtracted allowance amount to subtract.\n    * @return A boolean value indicating whether the operation was successful.\n    */\n    function decreaseAllowance(address spender, uint256 subtractedAmount) public returns (bool) {\n    uint256 currentAllowance = allowed[msg.sender][spender];\n    require(subtractedAmount \u003c= currentAllowance, \"Exceeds allowed amount\");\n\n    _approve(msg.sender, spender, currentAllowance - subtractedAmount);\n    return true;\n    }\n\n    // Transfer tokens from sender to recipient\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        require(amount \u003c= balances[msg.sender], \"Insufficient balance\");\n        require(!blocked[msg.sender], \"Account is blocked\");\n\n        balances[msg.sender] -= amount;\n        balances[recipient] += amount;\n\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n    * @dev Transfers tokens from one account to another, if allowed by the spender.\n    * @param sender The address from which tokens will be transferred.\n    * @param recipient The address to which tokens will be transferred.\n    * @param amount The amount of tokens to be transferred.\n    * @return A boolean value indicating whether the operation was successful.\n    */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n    require(amount \u003c= balances[sender], \"Insufficient balance\");\n\n    uint256 allowedAmount = allowance(sender, msg.sender);\n    require(amount \u003c= allowedAmount, \"Exceeds allowed amount\");\n\n    balances[sender] -= amount;\n    balances[recipient] += amount;\n\n    emit Transfer(sender, recipient, amount);\n    return true;\n    }\n\n    // Burn tokens by sender, reducing total supply and pool\n    function burn(uint256 amount) public returns (bool) {\n        require(amount \u003c= balances[msg.sender], \"Insufficient balance\");\n\n        balances[msg.sender] -= amount;\n        pool -= amount;\n        totalSupply -= amount;\n\n        emit Burn(msg.sender, amount);\n        return true;\n    }\n\n    /**\n    * @dev Burns a specific amount of tokens from the specified account, if allowed by the spender.\n    * @param account The address from which tokens will be burned.\n    * @param amount The amount of tokens to be burned.\n    * @return A boolean value indicating whether the operation was successful.\n    */\n    function burnFrom(address account, uint256 amount) public returns (bool) {\n    require(amount \u003c= balances[account], \"Insufficient balance\");\n\n    uint256 allowedAmount = allowance(account, msg.sender);\n    require(amount \u003c= allowedAmount, \"Exceeds allowed amount\");\n\n    balances[account] -= amount;\n    pool -= amount;\n    totalSupply -= amount;\n\n    emit Burn(account, amount);\n    return true;\n    }\n\n    // Supply monthly tokens to the owner\n    function supplyMonthly() public onlyOwner {\n    require(ownerships[msg.sender], \"Only contract owner can call this function\");\n    require(block.timestamp - lastSupplyDate \u003e= 30 days, \"Monthly supply not yet due\");\n\n    uint256 newSupply = monthlySupply;\n    if (pool + monthlySupply \u003e totalSupply) {\n        newSupply = totalSupply - pool;\n    }\n\n    pool += newSupply;\n    balances[owner] += newSupply;\n    lastSupplyDate = block.timestamp;\n\n    emit Supply(newSupply);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new owner\n     * @param newOwner The address of the new owner\n     */\n    function transferOwnership(address newOwner) public {\n        require(ownerships[msg.sender], \"Only contract owner can call this function\");\n        require(newOwner != address(0), \"Invalid new owner address\");\n\n        owner = newOwner;\n\n        emit OwnershipTransferred(newOwner);\n    }\n\n    /**\n     * @dev Adds ownership of the contract to a new owner\n     * @param newOwner The address of the new owner\n     */\n    function addOwnership(address newOwner) public {\n        require(ownerships[msg.sender], \"Only contract owner can call this function\");\n        require(newOwner != address(0), \"Invalid new owner address\");\n\n        ownerships[newOwner] = true;\n\n        emit OwnershipAdded(newOwner);\n    }\n\n    /**\n     * @dev Removes ownership of the contract from an owner\n     * @param ownerToRemove The address of the owner to remove\n     */\n    function removeOwnership(address ownerToRemove) public {\n        require(ownerToRemove != address(0), \"Invalid owner address\");\n        require(ownerships[msg.sender], \"Only contract owner can call this function\");\n        require(ownerToRemove != owner, \"Cannot remove contract owner\");\n\n        ownerships[ownerToRemove] = false;\n\n        emit OwnershipRemoved(ownerToRemove);\n    }\n\n    /**\n    * @dev Blocks an account from making transfers\n    */\n    function blockAccount(address) public onlyOwner {\n    require(balanceOf(msg.sender) \u003e 0, \"Account balance is zero\");\n\n    blocked[msg.sender] = true;\n\n    emit AccountBlocked(msg.sender);\n    }\n\n    /**\n    * @dev Unblocks an account from making transfers\n     */\n    function unblockAccount(address) public onlyOwner {\n    blocked[msg.sender] = false;\n    }\n\n    // Events\n\n    /**\n     * @dev Emitted when tokens are transferred from one address to another\n     * @param from The address tokens are transferred from\n     * @param to The address tokens are transferred to\n     * @param value The amount of tokens transferred\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when tokens are burned from an address\n     * @param from The address tokens are burned from\n     * @param value The amount of tokens burned\n     */\n    event Burn(address indexed from, uint256 value);\n    \n    /**\n     * @dev Emitted when the total supply of tokens is updated\n     * @param value The updated total supply of tokens\n     */\n    event Supply(uint256 value);\n    \n    /**\n     * @dev Emitted when ownership of the contract is transferred to a new owner\n     * @param newOwner The address of the new owner\n     */\n    event OwnershipTransferred(address indexed newOwner);\n    \n    /**\n     * @dev Emitted when ownership of the contract is added to a new owner\n     * @param newOwner The address of the new owner\n     */\n    event OwnershipAdded(address indexed newOwner);\n    \n    /**\n     * @dev Emitted when ownership of the contract is removed from an owner\n     * @param ownerToRemove The address of the owner being removed\n      */\n    event OwnershipRemoved(address indexed ownerToRemove);\n    \n    /**\n     * @dev Emitted when an account is blocked from making transfers\n     * @param account The address of the blocked account\n     */\n    event AccountBlocked(address indexed account);\n\n    /**\n    * @dev Emitted when the allowance of a token owner is set or updated.\n    *\n    * This event is emitted when the `approve` function is called to set or update the allowance of a token owner\n    * for a specific spender. It provides information about the owner, spender, and the updated allowance value.\n    *\n    * @param owner The address of the token owner whose allowance is being set or updated.\n    * @param spender The address of the spender for whom the allowance is being set or updated.\n    * @param value The new allowance value for the spender.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"}}