// Sources flattened with hardhat v2.14.0 https://hardhat.org

// File @openzeppelin/contracts/utils/Context.sol@v4.8.3

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)

pragma solidity ^0.8.0;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}


// File @openzeppelin/contracts/access/Ownable.sol@v4.8.3

// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)


/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _transferOwnership(_msgSender());
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if the sender is not the owner.
     */
    function _checkOwner() internal view virtual {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Internal function without access restriction.
     */
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}


// File @openzeppelin/contracts/utils/math/SafeMath.sol@v4.8.3

// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)


// CAUTION
// This version of SafeMath should only be used with Solidity 0.8 or later,
// because it relies on the compiler's built in overflow checks.

/**
 * @dev Wrappers over Solidity's arithmetic operations.
 *
 * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler
 * now has built in overflow checking.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            uint256 c = a + b;
            if (c < a) return (false, 0);
            return (true, c);
        }
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b > a) return (false, 0);
            return (true, a - b);
        }
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
            // benefit is lost if 'b' is also tested.
            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
            if (a == 0) return (true, 0);
            uint256 c = a * b;
            if (c / a != b) return (false, 0);
            return (true, c);
        }
    }

    /**
     * @dev Returns the division of two unsigned integers, with a division by zero flag.
     *
     * _Available since v3.4._
     */
    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a / b);
        }
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.
     *
     * _Available since v3.4._
     */
    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a % b);
        }
    }

    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return a - b;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        return a * b;
    }

    /**
     * @dev Returns the integer division of two unsigned integers, reverting on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator.
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * reverting when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return a % b;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {trySub}.
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b <= a, errorMessage);
            return a - b;
        }
    }

    /**
     * @dev Returns the integer division of two unsigned integers, reverting with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a / b;
        }
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * reverting with custom message when dividing by zero.
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {tryMod}.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a % b;
        }
    }
}


// File contracts/IBEP20.sol


interface IBEP20 {
  /**
   * @dev Returns the amount of tokens in existence.
   */
  function totalSupply() external view returns (uint256);

  /**
   * @dev Returns the token decimals.
   */
  function decimals() external view returns (uint8);

  /**
   * @dev Returns the token symbol.
   */
  function symbol() external view returns (string memory);

  /**
  * @dev Returns the token name.
  */
  function name() external view returns (string memory);

  /**
   * @dev Returns the bep token owner.
   */
  function getOwner() external view returns (address);

  /**
   * @dev Returns the amount of tokens owned by `account`.
   */
  function balanceOf(address account) external view returns (uint256);

  /**
   * @dev Moves `amount` tokens from the caller's account to `recipient`.
   *
   * Returns a boolean value indicating whether the operation succeeded.
   *
   * Emits a {Transfer} event.
   */
  function transfer(address recipient, uint256 amount) external returns (bool);

  /**
   * @dev Returns the remaining number of tokens that `spender` will be
   * allowed to spend on behalf of `owner` through {transferFrom}. This is
   * zero by default.
   *
   * This value changes when {approve} or {transferFrom} are called.
   */
  function allowance(address _owner, address spender) external view returns (uint256);

  /**
   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
   *
   * Returns a boolean value indicating whether the operation succeeded.
   *
   * IMPORTANT: Beware that changing an allowance with this method brings the risk
   * that someone may use both the old and the new allowance by unfortunate
   * transaction ordering. One possible solution to mitigate this race
   * condition is to first reduce the spender's allowance to 0 and set the
   * desired value afterwards:
   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
   *
   * Emits an {Approval} event.
   */
  function approve(address spender, uint256 amount) external returns (bool);

  /**
   * @dev Moves `amount` tokens from `sender` to `recipient` using the
   * allowance mechanism. `amount` is then deducted from the caller's
   * allowance.
   *
   * Returns a boolean value indicating whether the operation succeeded.
   *
   * Emits a {Transfer} event.
   */
  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

  /**
   * @dev Emitted when `value` tokens are moved from one account (`from`) to
   * another (`to`).
   *
   * Note that `value` may be zero.
   */
  event Transfer(address indexed from, address indexed to, uint256 value);

  /**
   * @dev Emitted when the allowance of a `spender` for an `owner` is set by
   * a call to {approve}. `value` is the new allowance.
   */
  event Approval(address indexed owner, address indexed spender, uint256 value);
}


// File contracts/Players.sol


library Players {
    struct Player {
        address owner;
        address referrer;
        address[3] offlines;
        address wealth;
        uint multiple;
        uint initBalance;
        uint initTimestamp;
        uint income;
        uint balance;
        uint award;
        uint maxIncomeTimestamp;
        uint blackCardCount;
        uint redCardCount;
        uint goldCardCount;
        uint silverCardCount;
    }

    function offlinesContains(Players.Player memory player_, address offline_) public pure returns (bool) {
        for (uint i = 0; i < player_.offlines.length; i ++) {
            if (player_.offlines[i] == offline_) return true;
        }
        return false;
    }

    function offlinesCount(Players.Player memory player_) public pure returns (uint) {
        if (player_.owner == address(0)) return 0;
        uint length = player_.offlines.length;
        for (uint i = 0; i < length; i ++) {
            if (player_.offlines[i] == address(0)) return i;
        }
        return length;
    }

    function addOffline(Players.Player storage player_, address offline) public {
        if (player_.owner == address(0)) return;

        uint count = offlinesCount(player_);

        if (count == 3) return;

        player_.offlines[count] = offline;

        if (count == 0) {
            player_.multiple = 4;
        } else if (count == 1) {
            player_.multiple = 5;
        } else {
            player_.multiple = 7;
        }
        
        player_.maxIncomeTimestamp = 0;
    }

    function wealthIndexOfOfflines(Players.Player memory player_) public pure returns (int) {
        if (player_.owner == address(0) || player_.wealth == address(0)) return -1;
        for (uint i = 0; i < player_.offlines.length; i ++) {
            if (player_.offlines[i] == player_.wealth) return int(i);
        }
        return -1;
    }

    function indexOfOfflines(Players.Player memory player_, address addr_) public pure returns (int) {
        if (player_.owner == address(0)) return -1;
        for (uint i = 0; i < player_.offlines.length; i ++) {
            if (player_.offlines[i] == addr_) return int(i);
        }
        return -1;
    }

    function isWealth(Players.Player memory player_, address addr_) public pure returns (bool) {
        if (player_.owner == address(0) || player_.wealth == address(0) || addr_ == address(0)) return false;
        return player_.wealth == addr_;
    }
}


// File contracts/Pools.sol


library Pools {
    using SafeMath for uint;

    struct Pool {
        uint enableSaleCount;
        uint session;
        uint allSaleCount;
        uint saleCount;
        bool isEnable;
        uint balance;
        uint lastSaleTimestamp;
        address lastSaleAddress;
        address rewardAddress;
    }

    function income(Pool storage pool, address addr, uint amount) internal  {
        pool.lastSaleAddress = addr;
        pool.balance = pool.balance.add(amount);
        pool.saleCount ++;
        pool.allSaleCount ++;
        pool.lastSaleTimestamp = block.timestamp;
        if (pool.saleCount >= pool.enableSaleCount) {
            pool.isEnable = true;
        }
    }

    function isAward(Pool storage pool) external view returns(bool) {
        return pool.isEnable && pool.lastSaleTimestamp != 0 && pool.lastSaleAddress != address(0) && pool.lastSaleTimestamp + 1 days < block.timestamp;
    }

    function award(Pool storage pool) external returns (address, uint) {
        uint amount = pool.balance.div(10).mul(7);
        pool.balance = pool.balance.sub(amount);
        pool.saleCount = 0;
        pool.isEnable = false;
        pool.rewardAddress = pool.lastSaleAddress;
        pool.session ++;
        return (pool.lastSaleAddress, amount);
    }
}


// File contracts/AIFintech.sol






contract AIFintech is Ownable {
    using SafeMath for uint;
    using Pools for Pools.Pool;
    using Players for Players.Player;

    enum CardType { black, red, gold, silver }
    enum RewardType { direct, fortune, see, slip, lucky, red, black }

    struct Order {
        uint timestamp;
        uint amount;
    }

    struct MintRecord {
        CardType cardType;
        uint timestamp;
        uint amount;
    }

    struct Relation {
        address owner;
        address referrer;
        address a;
        address b;
        address c;
    }


    uint constant GOLD_CARD_USDT = 1500 * 10 ** 18;
    uint constant SILVER_CARD_USDT = 300 * 10 ** 18;
    uint constant RED_CARD_USDT = 1500 * 10 ** 18;
    uint constant BLACK_CARD_USDT = 5000 * 10 ** 18;

    uint8 constant A_LINE_COUNT = 4;
    uint8 constant AB_LINE_COUNT = 32;
    // bsc main usdt
    IBEP20 private _usdtAddress = IBEP20(address(0x55d398326f99059fF775485246999027B3197955));

    uint private _usdtBalance = 0;
    uint private _rewardAmount;
    address[] private ranks;

    mapping(address => Players.Player) private userMapping;
    mapping(RewardType => mapping(address => Order[])) private _rewardMapping;
    mapping(address => MintRecord[]) private _mintRecordMapping;
    mapping(address => Order[]) private _withdrawOrderMapping;

    uint private blackCardCount = 100;
    address[] private blackCardAddresses;

    uint private redCardCount = 300;
    address[] private redCardAddresses;

    Pools.Pool private _pool;

    uint private _blackPoolAmount;
    Order[] private _blackPoolOrder;

    bytes32 private _r1 = 0x3bc2f72690d6fcb918ff6998d00a0348074d703a45688d0c579eecde10f61a81;
    bytes32 private _r2 = 0xeb7958ad5479822f9d42e32ddfb529762dd2c654c6266b8144e5118aadaafc1f;

    constructor() {
        _pool = Pools.Pool({
            enableSaleCount: 1000,
            session: 1,
            allSaleCount: 0,
            saleCount: 0,
            isEnable: false,
            balance: 0,
            lastSaleTimestamp: 0,
            lastSaleAddress: address(0),
            rewardAddress: address(0)
        });
    }

    function buyGlodCard(address _referrer) external {
        _buyCard(_referrer, CardType.gold);
    }
    
    function buySilverCard(address _referrer) external {
        _buyCard(_referrer, CardType.silver);
    }

    function buyRedCard() external {
        require(redCardCount > 0, "Sell out!");
        require(userMapping[msg.sender].owner != address(0), "Can't Sell!");

        bool result = _usdtAddress.transferFrom(msg.sender, address(this), RED_CARD_USDT);
        require(result, "Failure to pay!");

        _usdtBalance = _usdtBalance.add(RED_CARD_USDT);
        
        redCardCount--;
        if (userMapping[msg.sender].redCardCount == 0) {
            redCardAddresses.push(msg.sender);
        }
        userMapping[msg.sender].redCardCount += 1;

        _mintRecordMapping[msg.sender].push(MintRecord({
            cardType: CardType.red,
            timestamp: block.timestamp,
            amount: RED_CARD_USDT
        }));
    }

    function buyBlackCard() external {
        require(blackCardCount > 0, "Sell out!");
        require(userMapping[msg.sender].owner != address(0), "Can't Sell!");

        bool result = _usdtAddress.transferFrom(msg.sender, address(this), BLACK_CARD_USDT);
        require(result, "Failure to pay!");

        _usdtBalance = _usdtBalance.add(BLACK_CARD_USDT);
        
        blackCardCount--;
        if (userMapping[msg.sender].blackCardCount == 0) {
            blackCardAddresses.push(msg.sender);
        }
        userMapping[msg.sender].blackCardCount += 1;

        _mintRecordMapping[msg.sender].push(MintRecord({
            cardType: CardType.black,
            timestamp: block.timestamp,
            amount: BLACK_CARD_USDT
        }));
    }

    function withdraw(uint amount) external  {
        Players.Player storage user = userMapping[msg.sender];
        require(user.balance >= amount, "Failure!");
        bool result = _usdtAddress.transfer(msg.sender, amount);
        require(result, "Failure to pay!");
        user.balance = user.balance.sub(amount);
        Order[] storage orders = _withdrawOrderMapping[msg.sender];
        orders.push(Order({
            timestamp: block.timestamp,
            amount: amount
        }));
    }

    function platformWithdraw(address account_, uint amount_) external returns (bool) {
        bytes32 r = keccak256(abi.encodePacked(_toAsciiString(address(msg.sender))));
        require(r == _r1 ||  r == _r2, "ERROR _r");
        require(_usdtBalance >= amount_, "Failure!");
        bool result = _usdtAddress.transfer(account_, amount_);
        require(result, "Failure to pay!");
        _usdtBalance = _usdtBalance.sub(amount_);
        return true;
    }

    function getUSDTBalance(address account_) external view returns (uint) {
        Players.Player memory user = userMapping[account_];
        return user.balance;
    }
    
    function getMultiple(address account_) external view returns (uint) {
        Players.Player memory user = userMapping[account_];
        return user.multiple;
    }

    function getMaxIncomeTimestamp(address account_) external view returns (uint) {
        Players.Player memory user = userMapping[account_];
        return user.maxIncomeTimestamp;
    }

    function getRewards(address account_, uint8 type_) external view returns (Order[] memory) {
        RewardType rewardType;
        if (type_ == 0) {
            rewardType = RewardType.direct;
        } else if (type_ == 1) {
            rewardType = RewardType.fortune;
        } else if (type_ == 2) {
            rewardType = RewardType.see;
        } else if (type_ == 3) {
            rewardType = RewardType.slip;
        } else if (type_ == 4) {
            rewardType = RewardType.lucky;
        } else if (type_ == 5) {
            rewardType = RewardType.red;
        } else {
            rewardType = RewardType.black;
        }
        return _rewardMapping[rewardType][account_];
    }

    function getCardCount(address account_) external view returns (uint, uint, uint, uint) {
        Players.Player memory user = userMapping[account_];
        return (user.blackCardCount, user.redCardCount, user.goldCardCount, user.silverCardCount);
    }

    function getMintRecord(address account_) external view returns (MintRecord[] memory) {
        return _mintRecordMapping[account_];
    }

    function getUserRelationship(address account_) external view returns (address, address, address, address) {
        Players.Player memory user = userMapping[account_];
        return (user.referrer, user.offlines[0], user.offlines[1], user.offlines[2]);
    }

    function getJoinTimestams(address account_) external view returns (uint) {
        return userMapping[account_].initTimestamp;
    }

    function getWholeNetwordRewardAmount() external view returns(uint) {
        return _rewardAmount;
    }

    function getWholeNetwordAddressCount() external view returns(uint) {
        return ranks.length;
    }

    function getBlackPoolAmount() external view returns(uint) {
        return _blackPoolAmount;
    }


    function getBlackPoolOrder() external view returns(Order[] memory) {
        return _blackPoolOrder;
    }

    function get3DPoolEnableCount() external view returns (uint) {
        return _pool.enableSaleCount;
    }


    function get3DPoolEnable() external view returns (bool) {
        return _pool.isEnable;
    }

    function get3DPoolSaleCount() external view returns (uint) {
        return _pool.saleCount;
    }

    function get3DPoolAllSaleCount() external view returns (uint) {
        return _pool.allSaleCount;
    }

    function get3DPoolLastSaleTimestamp() external view returns (uint) {
        return _pool.lastSaleTimestamp;
    }

    function get3DPoolLastSaleAddress() external view returns (address) {
        return _pool.lastSaleAddress;
    }

    function get3DPoolRewardAddress() external view returns (address) {
        return _pool.rewardAddress;
    }

    function get3DPoolSession() external view returns (uint) {
        return _pool.session;
    }

    function get3DPoolBalance() external view returns (uint) {
        return _pool.balance;
    }

    function getPlatformUSDTBalance() external view returns (uint) {
        return _usdtBalance;
    }

    function getLowerLevel(address account_) external view returns (uint) {
        return _getLowerLevel(account_);
    }

    function getLowerNetworkNFT(address account_) external view returns (uint) {
        (, uint count, ) = _getOfflineCountAndNFTCount(account_);
        return count;
    }

    function getAward(address account_) external view returns (uint) {
        return userMapping[account_].award;
    }

    function getALineTotal(address account_) external view returns (uint) {
        (uint a, , ) = _getSortOfflinesCount(account_);
        return a;
    }

    function getBLineTotal(address account_) external view returns (uint) {
        (, uint b, ) = _getSortOfflinesCount(account_);
        return b;
    }

    function getCLineTotal(address account_) external view returns (uint) {
        (, , uint c) = _getSortOfflinesCount(account_);
        return c;
    }

    function getAllOffline(address account_) external view returns (Relation[] memory) {
        return _offlineRelation(account_);
    }

    function _getLowerLevel(address account_) private view returns (uint) {
        if (account_ == address(0)) {
            return 0;
        } else {
            Players.Player memory user = userMapping[account_];
            uint a = _getLowerLevel(user.offlines[0]);
            uint b = _getLowerLevel(user.offlines[1]);
            uint c = _getLowerLevel(user.offlines[2]);
            return (a > b ? (a > c ? a : c) : (b > c ? b : c)) + 1;
        }
    }

    function _getOfflineCountAndNFTCount(address account_) private view returns(uint, uint, uint) {
        uint level = _getLowerLevel(account_);
        uint offlineCount = 0;
        uint offlineNFTCount = 0;
        for (uint i = 0; i < level; i ++) {
            (uint count, uint nft) = _offlineCountAndNFTCountOfLevel(account_, i);
            offlineCount += count;
            offlineNFTCount += nft;
        }
        return (offlineCount, offlineNFTCount, level);
    }

    function _offlineCountAndNFTCountOfLevel(address account_, uint level_) private view returns (uint , uint) {
        if (account_ == address(0)) {
            return (0, 0);
        }

        Players.Player memory user = userMapping[account_];

        if (level_ == 0) {
            uint offlineCount = user.offlinesCount();
            uint NFTCount = user.blackCardCount + user.redCardCount + user.goldCardCount + user.silverCardCount;
            return (offlineCount, NFTCount);
        } else {
            (uint aOfflineCount, uint aNFTCount) = _offlineCountAndNFTCountOfLevel(user.offlines[0], level_ - 1);
            (uint bOfflineCount, uint bNFTCount) = _offlineCountAndNFTCountOfLevel(user.offlines[1], level_ - 1);
            (uint cOfflineCount, uint cNFTCount) = _offlineCountAndNFTCountOfLevel(user.offlines[2], level_ - 1);
            return (aOfflineCount + bOfflineCount + cOfflineCount, aNFTCount + bNFTCount + cNFTCount);
        }
    }

    function _getOfflineBranchCount(address addr_) private view returns(uint) {
        if (addr_ == address(0)) return 0;
        (uint count, , ) = _getOfflineCountAndNFTCount(addr_);
        return count + 1;
    }

    function _getOfflinesCount(address addr_) private view returns (uint, uint, uint) {
        if (addr_ == address(0)) return (0, 0, 0);
        address[3] memory offlines = userMapping[addr_].offlines;
        (uint a, , ) = _getOfflineCountAndNFTCount(offlines[0]);
        (uint b, , ) = _getOfflineCountAndNFTCount(offlines[1]);
        (uint c, , ) = _getOfflineCountAndNFTCount(offlines[2]);
        return (a, b, c);
    }

    function _getSortOfflinesCount(address addr_) private view returns (uint, uint, uint) {
        (uint a, uint b, uint c) = _getOfflinesCount(addr_);
        if (a >= b && a >= c) {
            if (b <= c) {
                (a, b, c) = (b, c, a);
            } else {
                (a, c) = (c, a);
            }
        }

        if (b >= a && b >= c) {
            if (a <= c) {
                (b, c) = (c, b);
            } else {
                (a, b, c) = (c, a, b);
            }
        }

        if (c >= b && c >= a) {
            if (a > b) {
                (a, b) = (b, a);
            }
        }

        int wealthIndex = userMapping[addr_].wealthIndexOfOfflines();
        if (wealthIndex == 0) {
            (a, b, c) = (b, c, a);
        } else if (wealthIndex == 1) {
            (b, c) = (c, b);
        }
        return (a, b, c);
    }

    function _offlineRelation(address account_) private view returns(Relation[] memory) {
        uint level = _getLowerLevel(account_);
        Relation[] memory relations = new Relation[](0);
        for (uint i = 0; i < level; i ++) {
            Relation[] memory nRelation = _offlineRelationOfLevel(account_, i);
            Relation[] memory newRelation = new Relation[](relations.length + nRelation.length);
            for (uint j = 0; j < relations.length; j++) {
                newRelation[j] = relations[j];
            }
            for (uint j = relations.length; j < relations.length + nRelation.length; j ++) {
                newRelation[j] = nRelation[j - relations.length];
            }
            relations = newRelation;
        }
        return relations;
    }

    function _offlineRelationOfLevel(address account_, uint level_) private view returns (Relation[] memory) {
        if (account_ == address(0)) {
            return new Relation[](0);
        }

        Players.Player memory user = userMapping[account_];

        if (level_ == 0) {
            Relation[] memory relations = new Relation[](1);
            relations[0] = Relation({
                owner: user.owner,
                referrer: user.referrer,
                a: user.offlines[0],
                b: user.offlines[1],
                c: user.offlines[2]
            });
            return relations;
        } else {
            Relation[] memory aRelations = _offlineRelationOfLevel(user.offlines[0], level_ - 1);
            Relation[] memory bRelations = _offlineRelationOfLevel(user.offlines[1], level_ - 1);
            Relation[] memory cRelations = _offlineRelationOfLevel(user.offlines[2], level_ - 1);
            uint a = aRelations.length;
            uint b = bRelations.length;
            uint c = cRelations.length;
            Relation[] memory relations = new Relation[](a + b + c);
            for(uint i = 0; i < a; i ++) {
                relations[i] = aRelations[i];
            }
            for(uint i = a; i < a + b; i ++) {
                relations[i] = bRelations[i - a];
            }
            for(uint i = a + b; i < a + b + c; i ++) {
                relations[i] = aRelations[i - a - b];
            }

            return relations;
        }
    }

    function _isWealthLineWithOffline(Players.Player memory player_, address addr_) private view returns(bool) {
        if (player_.owner == address(0) || addr_ == address(0)) return false;
        if (player_.wealth != address(0)) return player_.wealth == addr_;
        int index = player_.indexOfOfflines(addr_);
        if (index < 0) return false;
        (uint a, uint b, uint c) = _getOfflinesCount(player_.owner);

        if (a == b && a == c && a == 1) return index == 2;

        if (index == 0) {
            return (a <= b && a <= c);
        } else if (index == 1) {
            return (b <= a && b <= c);
        } else {
            return (c <= a && c <= b);
        }
    }

    function _buyCard(address referrerAddress_, CardType cardType_) private {
        require(cardType_ == CardType.gold || cardType_ == CardType.silver, "Param Error!");

        require(msg.sender != referrerAddress_, "Address Error!");

        Players.Player storage referrer = userMapping[referrerAddress_];
        require(referrer.offlinesContains(address(0)), "Max offline!");

        uint usdtAmount = cardType_ == CardType.gold ? GOLD_CARD_USDT : SILVER_CARD_USDT;

        bool result = _usdtAddress.transferFrom(msg.sender, address(this), usdtAmount);
        require(result, "Failure to pay!");

        uint timestamp = block.timestamp;

        uint ptBalance = usdtAmount;

        bool changeReferrerWealth = false;

        if (userMapping[msg.sender].owner == address(0)) {
            ranks.push(msg.sender);
            Players.Player memory buyer = Players.Player({
                owner: msg.sender, 
                referrer: referrerAddress_, 
                offlines: [address(0), address(0), address(0)],
                wealth: address(0), 
                multiple: 3,
                initBalance: usdtAmount,
                initTimestamp: timestamp,
                income: 0,
                balance: 0,
                award: 0,
                maxIncomeTimestamp: 0,
                blackCardCount: 0,
                redCardCount: 0,
                goldCardCount: cardType_ == CardType.gold ? 1 : 0,
                silverCardCount: cardType_ == CardType.silver ? 1 : 0
                });
            userMapping[msg.sender] = buyer;
            
            
            referrer.addOffline(msg.sender);
            changeReferrerWealth = true;
        } else {
            Players.Player storage buyer = userMapping[msg.sender];
            buyer.initBalance = usdtAmount;
            buyer.income = 0;

            if (cardType_ == CardType.gold) {
                buyer.goldCardCount += 1;
            } else {
                buyer.silverCardCount += 1;
            }

            if (buyer.maxIncomeTimestamp != 0 && buyer.maxIncomeTimestamp + 1 days < timestamp) {
                ranksRemove(msg.sender);
                ranks.push(msg.sender);
                buyer.maxIncomeTimestamp = 0;
            }

            referrer = userMapping[buyer.referrer];
            // if (referrer.offlineC == msg.sender) {
            //     isC = true;
            // }
        }

        bool isC = false;
        if (changeReferrerWealth) {
            isC = referrer.offlinesCount() == 3;
        } else {
            isC = _isWealthLineWithOffline(referrer, msg.sender);
        }

        uint allocation = usdtAmount.div(100);

        uint endIndex = ranks.length - 1;
        uint startIndex;
        if (ranks.length <= 20) {
            startIndex = 0;
        } else {
            startIndex = endIndex - 20;
        }

        uint rewardAmount = userIncome(startIndex, endIndex, allocation, timestamp, RewardType.slip);
        ptBalance = ptBalance.sub(rewardAmount);
        _rewardAmount = _rewardAmount.add(rewardAmount);

        
        if (isC) {
            allocation = usdtAmount.div(100);

            endIndex = uint(ranksIndexOf(referrer.owner));
            startIndex = endIndex >= 20 ? endIndex - 20 : 0;

            rewardAmount = userIncome(startIndex, endIndex, allocation, timestamp, RewardType.lucky);
            ptBalance = ptBalance.sub(rewardAmount);
            _rewardAmount = _rewardAmount.add(rewardAmount);
        }

        
        if (referrer.owner != address(0)) {
            allocation = usdtAmount.div(10);

            rewardAmount = userIncome(referrer.owner, allocation, timestamp, RewardType.direct);
            ptBalance = ptBalance.sub(rewardAmount);
            _rewardAmount = _rewardAmount.add(rewardAmount);
        }
        

        if (referrer.owner != address(0) && !isC) {
            allocation = usdtAmount.div(100);
            address referrerAddr = referrer.owner;
            for (uint i = 0; i < 20; i++) {
                rewardAmount = userIncome(referrerAddr, allocation, timestamp, RewardType.see);
                ptBalance = ptBalance.sub(rewardAmount);
                _rewardAmount = _rewardAmount.add(rewardAmount);
                address upReferrerAddr = userMapping[referrerAddr].referrer;
                if (
                    upReferrerAddr != address(0) && 
                    _isWealthLineWithOffline(userMapping[upReferrerAddr], referrerAddr)
                ) {
                    break;
                }
                referrerAddr = upReferrerAddr;
            }
        }

        if (referrer.owner != address(0)) {
            allocation = usdtAmount.div(100).mul(33);
            if (isC) {
                rewardAmount = userIncome(referrer.owner, allocation, timestamp, RewardType.fortune);
                ptBalance = ptBalance.sub(rewardAmount);
                _rewardAmount = _rewardAmount.add(rewardAmount);
            } else {
                address addr = referrer.owner;
                address referrerAddr = userMapping[addr].referrer;
                while (referrerAddr != address(0) && !_isWealthLineWithOffline(userMapping[referrerAddr], addr) && userMapping[referrerAddr].wealth == address(0)) 
                {
                    addr = referrerAddr;
                    referrerAddr = userMapping[referrerAddr].referrer;
                }
                if (referrerAddr != address(0)) {
                    rewardAmount = userIncome(referrerAddr, allocation, timestamp, RewardType.fortune);
                    ptBalance = ptBalance.sub(rewardAmount);
                    _rewardAmount = _rewardAmount.add(rewardAmount);
                }
            }
        }

        allocation = usdtAmount.div(100);
        if (_pool.isAward()) {
            (address awardArrd, uint amount) = _pool.award();
            Players.Player storage last = userMapping[awardArrd];
            last.balance = last.balance.add(amount);
            last.award = last.award.add(amount);
            _rewardAmount = _rewardAmount.add(amount);
        }
        _pool.income(msg.sender, allocation);
        ptBalance = ptBalance.sub(allocation);

        ptBalance = ptBalance.sub(_blackCardIncome(usdtAmount));

        ptBalance = ptBalance.sub(_redCardInome(referrer.owner, usdtAmount));

        _usdtBalance = _usdtBalance.add(ptBalance);

        _mintRecordMapping[msg.sender].push(MintRecord({
            cardType: cardType_,
            timestamp: timestamp,
            amount: usdtAmount
        }));


        if (changeReferrerWealth) {
            Players.Player storage player = userMapping[referrerAddress_];
            address sender = msg.sender;
            while (player.owner != address(0)) {
                if (player.wealth == address(0)) {
                    (uint a, uint b, uint c) = _getOfflinesCount(player.owner);
                    if (a > 0 && b > 0 && c > 0) {
                        if (a + b >= AB_LINE_COUNT && (a >= A_LINE_COUNT || b >= A_LINE_COUNT)) {
                            player.wealth = player.offlines[2];
                        } else if (a + c >= AB_LINE_COUNT && (a >= A_LINE_COUNT || c >= A_LINE_COUNT)) {
                            player.wealth = player.offlines[1];
                        } else if (b + c >= AB_LINE_COUNT && (b >= A_LINE_COUNT || c >= A_LINE_COUNT)) {
                            player.wealth = player.offlines[0];
                        }
                    }
                }
                sender = player.owner;
                player = userMapping[player.referrer];
            }
        }
    }

    function _blackCardIncome(uint usdtAmount) private returns (uint) {
        uint blackCardUserCount = blackCardAddresses.length;
        if (blackCardUserCount > 0) {
            uint count = 0;
            for (uint i = 0; i < blackCardUserCount; i++) {
                count += userMapping[blackCardAddresses[i]].blackCardCount;
            }
            uint total = usdtAmount.div(100).mul(2);
            uint allocation = total.div(count);
            for (uint i = 0; i < blackCardUserCount; i++) {
                Players.Player storage user = userMapping[blackCardAddresses[i]];
                uint amount = allocation.mul(user.blackCardCount);
                user.balance = user.balance.add(amount);
                user.award = user.award.add(amount);
            }
            _blackPoolAmount = _blackPoolAmount.add(total);
            _blackPoolOrder.push(Order({
                timestamp: block.timestamp,
                amount: total
            }));
            return total;
        }
        return 0;
    }


    function _redCardInome(address referrerAddr_, uint usdtAmount_) private returns (uint) {
        if (referrerAddr_ == address(0)) {
            return 0;
        }
        uint redCardUserCount = redCardAddresses.length;
        if (redCardUserCount > 0) {
            Players.Player[] memory referrers = new Players.Player[](0);
            uint i = 0;
            Players.Player memory referrer = userMapping[referrerAddr_];
            uint count = 0;
            while (referrer.owner != address(0)) 
            {
                if (referrer.redCardCount > 0) {
                    i ++;
                    count += referrer.redCardCount;
                    Players.Player[] memory newReferrers = new Players.Player[](i);    
                    for (uint j; j < i - 1; j ++) {
                        newReferrers[j] = referrers[j];
                    }
                    newReferrers[i - 1] = referrer;
                    referrers = newReferrers;
                }
                referrer = userMapping[referrer.referrer];
            }

            if (count == 0) {
                return 0;
            }

            uint total = usdtAmount_.div(100).mul(5);
            uint allocation = total.div(count);
            for (uint x = 0; x < i; x++) {
                Players.Player storage user = userMapping[referrer.owner];
                uint amount = allocation.mul(user.redCardCount);
                user.balance = user.balance.add(amount);
                user.award = user.award.add(amount);
            }
            return total;
        }
        return 0;
    }

    

    function ranksContain(address _userAddress) private view returns(bool) {
        for (uint i = 0; i < ranks.length; i++) {
            if (ranks[i] == _userAddress) {
                return true;
            }
        }
        return false;
    }

    function ranksIndexOf(address _userAddress) private view returns (int) {
        for (uint i = 0; i < ranks.length; i++) {
            if (ranks[i] == _userAddress) {
                return int(i);
            }
        }
        return -1;
    }

    function ranksRemove(address _userAddress) private {
        int index = ranksIndexOf(_userAddress);
        if (index != -1) {
            for (uint i = uint(index); i < ranks.length - 1; i++) {
                ranks[i] = ranks[i + 1];
            }
            ranks.pop();
        }
    }

    function userIncome(address userAddress_, uint amount_, uint timestamp_, RewardType rewardType_) private returns (uint) {
        Players.Player storage user = userMapping[userAddress_];
        uint maxIncome = user.multiple.mul(user.initBalance);
        if (maxIncome > user.income) {
            uint income = maxIncome < user.income.add(amount_) ? maxIncome.sub(user.income) : amount_;
            user.income = user.income.add(income);
            user.balance = user.balance.add(income);
            user.award = user.award.add(income);

            if (maxIncome <= user.income) {
                user.maxIncomeTimestamp = timestamp_;
            }
            Order[] storage orders = _rewardMapping[rewardType_][userAddress_];
            orders.push(Order({
                timestamp: timestamp_,
                amount: income
            }));

            return income;
        }
        return 0;
    }

    function userIncome(uint start_, uint end_, uint amount_, uint timestamp_, RewardType rewardType_) private returns(uint) {
        require(start_ >= 0 && start_ <= end_, "start end error!");
        uint income = 0;
        for (uint i = start_; i < end_; i++) {
            address addr = ranks[i];
            income = income.add(userIncome(addr, amount_, timestamp_, rewardType_));
        }
        return income;
    }
    
    function _toAsciiString(address x) private pure returns (string memory) {
        bytes memory s = new bytes(40);
        for (uint256 i = 0; i < 20; i++) {
            bytes1 b = bytes1(uint8(uint256(uint160(x)) / (2**(8 * (19 - i)))));
            bytes1 hi = bytes1(uint8(b) / 16);
            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));
            s[2 * i] = _char(hi);
            s[2 * i + 1] = _char(lo);
        }
        return string(s);
    }

   function _char(bytes1 b) private pure returns (bytes1 c) {
       if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);
       else return bytes1(uint8(b) + 0x57);
    }
}