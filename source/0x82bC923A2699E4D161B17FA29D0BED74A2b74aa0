// SPDX-License-Identifier: MIT

pragma solidity ^0.8.4;


library SafeMath {
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a, "MyDealSafeMath: addition overflow");

    return c;
  }


  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    return sub(a, b, "MyDealSafeMath: subtraction overflow");
  }

  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
    require(b <= a, errorMessage);
    uint256 c = a - b;

    return c;
  }


  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
    if (a == 0) {
      return 0;
    }

    uint256 c = a * b;
    require(c / a == b, "MyDealSafeMath: multiplication overflow");

    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    return div(a, b, "MyDealSafeMath: division by zero");
  }

  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
    // Solidity only automatically asserts when dividing by 0
    require(b > 0, errorMessage);
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold

    return c;
  }

  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
    return mod(a, b, "MyDealSafeMath: modulo by zero");
  }

  function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
    require(b != 0, errorMessage);
    return a % b;
  }
}
interface IBEP20 {
 
  function totalSupply() external view returns (uint256);

 
  function decimals() external view returns (uint8);

 
  function symbol() external view returns (string memory);

 
  function name() external view returns (string memory);

 
  function getOwner() external view returns (address);

  function balanceOf(address account) external returns (uint256);


  function transfer(address recipient, uint256 amount) external returns (bool);


  function allowance(address _owner, address spender) external view returns (uint256);

  function approve(address spender, uint256 amount) external returns (bool);

 
  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

 
  event Transfer(address indexed from, address indexed to, uint256 value);

  
  event Approval(address indexed owner, address indexed spender, uint256 value);
}


contract Context {
  // Empty internal constructor, to prevent people from mistakenly deploying
  // an instance of this contract, which should be used via inheritance.
  constructor ()  { }

  function _msgSender() internal view returns (address) {
    return msg.sender;
  }

  function _msgData() internal view returns (bytes memory) {
    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
    return msg.data;
  }
}

contract Ownable is Context {
  address private _owner;

  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

  constructor ()  {
    address msgSender = _msgSender();
    _owner = msgSender;
    emit OwnershipTransferred(address(0), msgSender);
  }


  function owner() public view returns (address) {
    return _owner;
  }



  modifier onlyOwner() {
    require(_owner == _msgSender(), "Ownable: caller is not the owner");
    _;
  }


  function renounceOwnership() public onlyOwner {
    emit OwnershipTransferred(_owner, address(0));
    _owner = address(0);
  }

 
  function transferOwnership(address newOwner) public onlyOwner {
    _transferOwnership(newOwner);
  }

  function _transferOwnership(address newOwner) internal {
    require(newOwner != address(0), "Ownable: new owner is the zero address");
    emit OwnershipTransferred(_owner, newOwner);
    _owner = newOwner;
  }
}


interface IPancakePair {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);

    function name() external pure returns (string memory);
    function symbol() external pure returns (string memory);
    function decimals() external pure returns (uint256);
    function totalSupply() external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);

    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);

    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function PERMIT_TYPEHASH() external pure returns (bytes32);
    function nonces(address owner) external view returns (uint);

    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;

    event Mint(address indexed sender, uint amount0, uint amount1);
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);

    function MINIMUM_LIQUIDITY() external pure returns (uint);
    function factory() external view returns (address);
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function price0CumulativeLast() external view returns (uint);
    function price1CumulativeLast() external view returns (uint);
    function kLast() external view returns (uint);

    function mint(address to) external returns (uint liquidity);
    function burn(address to) external returns (uint amount0, uint amount1);
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
    function skim(address to) external;
    function sync() external;

    function initialize(address, address) external;
}



interface IPancakeRouter01 {
    function factory() external pure returns (address);
    function WETH() external pure returns (address);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETH(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountToken, uint amountETH);
    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETHWithPermit(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountToken, uint amountETH);
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
    external
    payable
    returns (uint[] memory amounts);
    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
    external
    returns (uint[] memory amounts);
    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
    external
    returns (uint[] memory amounts);
    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
    external
    payable
    returns (uint[] memory amounts);

    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);
    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
}

interface IPancakeRouter02 is IPancakeRouter01 {
    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountETH);
    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountETH);

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable;
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
}
interface IPancakeFactory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);

    function feeTo() external view returns (address);
    function feeToSetter() external view returns (address);

    function getPair(address tokenA, address tokenB) external view returns (address pair);
    function allPairs(uint) external view returns (address pair);
    function allPairsLength() external view returns (uint);

    function createPair(address tokenA, address tokenB) external returns (address pair);

    function setFeeTo(address) external;
    function setFeeToSetter(address) external;
}

contract FutureEarnings {
    using SafeMath for uint256;
    // 新增关于未来收益的参数
    mapping (address => uint256[]) internal  _startUpdateTime;
    mapping (address => uint256[]) internal _lastUpdateTime;
    mapping (address => uint256[]) internal _endUpdateTime;
    mapping (address => uint256[]) internal _baseMonetaryLimitReward;
    mapping (address => uint256[]) internal _baseMonetaryLimitRate;
    mapping (address => uint256[]) internal _settleType;

    // 已解冻已结算金额
    mapping (address => uint256) internal _releasedAndSettledMoney;
    // 已解冻未结算金额
    mapping (address => uint256) internal _releasedAndUnsettledMoney;
    // 未解冻未结算金额
    mapping (address => uint256) internal _unreleasedAndUnsettledMoney;
    // 未来总收益金额 - 汇总
    mapping (address => uint256) internal _allFutureEarningsMoney;
    

   

    //mapping (address => uint256[]) private _;
    
    // 是否是正式上线产品，如果是的话，会有一些功能限制
    bool internal isProductFlag;
    address internal ownerAddress;
    uint256 internal calculateAmountBaseNum;

    constructor(address _owner)  {
        ownerAddress = _owner;
        isProductFlag = true;
        calculateAmountBaseNum = 100000;
    }

    modifier onlyOwnerAddress() {
        require(ownerAddress == msg.sender, "Ownable: caller is not the owner");
        _;
    }

    event AddEduFutureEarningsLog(address addr,
        uint256 startUpdateTime,
        uint256 lastUpdateTime,
        uint256 endUpdateTime,
        uint256 settleType,
        uint256 countMoney, 
        uint256 tempRewardMonetaryLimitRate);
    event LogTypeUint256(string str, uint256 vars);

    function setIsProductFlag(bool flag) public onlyOwnerAddress{
        isProductFlag = flag;
    }

    // 获取-已解冻已结算金额
    function getReleasedAndSettledMoney(address addr) public  view returns(uint256){
        return _releasedAndSettledMoney[addr];
    }
    // 获取-已解冻未结算金额
    function getReleasedAndUnsettledMoney(address addr) public  view returns(uint256){   
        uint256 retUnfreezeAmount     = 0;
        uint256 retfreezeAmount       = 0;
        (retUnfreezeAmount,retfreezeAmount) =  getRewardsByAddressViewVersion( addr);
        return retUnfreezeAmount;
    }
    // 获取-未解冻未结算金额
    function getUnreleasedAndUnsettledMoney(address addr) public  view returns(uint256){
        return _allFutureEarningsMoney[addr] - getReleasedAndUnsettledMoney(addr) - getReleasedAndSettledMoney(addr);
    }

    function setCalculateAmountBaseNum(uint256 num) public onlyOwnerAddress{
        calculateAmountBaseNum = num;
    }
    
    // 修改未来收益信息
    function waitDelShowUpdateEduByAddr(
        address addr,
        uint256 i,
        uint256 a,
        uint256 b,
        uint256 c,
        uint256 d,
        uint256 e,
        uint256 f
    ) internal onlyOwnerAddress{
        if( isProductFlag == false){
             _startUpdateTime[addr][i] = a;
            _lastUpdateTime[addr][i] = b;
            _endUpdateTime[addr][i] = c;
            _settleType[addr][i] = d;
            _baseMonetaryLimitReward[addr][i] = e;
            _baseMonetaryLimitRate[addr][i] = f;
            
        }
    }
    
    function getCurrentTimestamp() public  view returns (uint256) {
            uint256 timestamp = block.timestamp;
            require(timestamp > 0, "Invalid timestamp");
            return timestamp;
    }

    // 为某个地址增加未来收益
    function addEduFutureEarnings(
        address addr,
        uint256 startUpdateTime,
        uint256 lastUpdateTime,
        uint256 endUpdateTime,
        uint256 settleType,
        uint256 countMoney, 
        uint256 tempRewardMonetaryLimitRate
    ) public onlyOwnerAddress{
        // 新增额度计算实例
        if(startUpdateTime > lastUpdateTime){
            lastUpdateTime = startUpdateTime;
        }
        if(endUpdateTime < lastUpdateTime){
            endUpdateTime = lastUpdateTime;
        }
        if(endUpdateTime < startUpdateTime){
            endUpdateTime = startUpdateTime;
        }
        _startUpdateTime[addr].push( startUpdateTime );
        _lastUpdateTime[addr].push(  lastUpdateTime );
        _endUpdateTime[addr].push( endUpdateTime );
        _settleType[addr].push( settleType );
        _baseMonetaryLimitReward[addr].push( countMoney );
        _baseMonetaryLimitRate[addr].push( tempRewardMonetaryLimitRate );
        
        _allFutureEarningsMoney[addr] = _allFutureEarningsMoney[addr] + countMoney * 305 / 100;
        _unreleasedAndUnsettledMoney[addr] = _unreleasedAndUnsettledMoney[addr] + countMoney  * 305 / 100;
        
    }

    // 为某个地址增加未来收益
    function addEduFutureEarnings2(
        address addr,
        uint256 startUpdateTime,
        uint256 lastUpdateTime,
        uint256 endUpdateTime,
        uint256 settleType,
        uint256 countMoney, 
        uint256 tempRewardMonetaryLimitRate
    ) public onlyOwnerAddress{
        // 新增额度计算实例
        if(startUpdateTime > lastUpdateTime){
            lastUpdateTime = startUpdateTime;
        }
        if(endUpdateTime < lastUpdateTime){
            endUpdateTime = lastUpdateTime;
        }
        if(endUpdateTime < startUpdateTime){
            endUpdateTime = startUpdateTime;
        }
        _startUpdateTime[addr].push( startUpdateTime );
        _lastUpdateTime[addr].push(  lastUpdateTime );
        _endUpdateTime[addr].push( endUpdateTime );
        _settleType[addr].push( settleType );
        _baseMonetaryLimitReward[addr].push( countMoney );
        _baseMonetaryLimitRate[addr].push( tempRewardMonetaryLimitRate );
        
        _allFutureEarningsMoney[addr] = _allFutureEarningsMoney[addr] + countMoney;
        _unreleasedAndUnsettledMoney[addr] = _unreleasedAndUnsettledMoney[addr] + countMoney;
    }

    function EduFutureEarnings(
        address addr,
        uint256 i
    ) public  onlyOwnerAddress view returns(uint256,uint256,uint256,uint256,uint256,uint256){
        return (
            _startUpdateTime[addr][i],
            _lastUpdateTime[addr][i],
            _endUpdateTime[addr][i],
            _settleType[addr][i],
            _baseMonetaryLimitReward[addr][i],
            _baseMonetaryLimitRate[addr][i]
        );
    }


    function getRewardsByAddress(address addr, bool isSettleFlag) public  onlyOwnerAddress returns(uint256,uint256){
        uint256 retUnfreezeAmount     = 0;
        uint256 retfreezeAmount       = 0;
        uint256 tempRetUnfreezeAmount = 0;
        uint256 tempRetfreezeAmount   = 0;
        if ( _startUpdateTime[addr].length == 0 ) {
            retUnfreezeAmount = 0;
            retfreezeAmount   = 0;
        } else {
            for (uint i = 0; i < _startUpdateTime[addr].length; i++) {
                (tempRetUnfreezeAmount,tempRetfreezeAmount) = calculateEarningsByAddressOrder(addr,i,isSettleFlag);
                retUnfreezeAmount = retUnfreezeAmount + tempRetUnfreezeAmount;
                tempRetUnfreezeAmount = 0;
                retfreezeAmount = retfreezeAmount + tempRetfreezeAmount;
                tempRetfreezeAmount = 0;
            }    
        }   
        if(isSettleFlag == true){
           
             // 未解冻未结算
            if( (_unreleasedAndUnsettledMoney[addr] < retUnfreezeAmount) || (_allFutureEarningsMoney[addr] - _unreleasedAndUnsettledMoney[addr]) < _releasedAndSettledMoney[addr]){
                emit LogTypeUint256("retUnfreezeAmount", retUnfreezeAmount);
                emit LogTypeUint256("retfreezeAmount", retfreezeAmount);
                emit LogTypeUint256("_releasedAndSettledMoney", _releasedAndSettledMoney[addr]);
                emit LogTypeUint256("_releasedAndUnsettledMoney", _releasedAndUnsettledMoney[addr]);
                emit LogTypeUint256("_unreleasedAndUnsettledMoney", _unreleasedAndUnsettledMoney[addr] );
            }else{
                if( retUnfreezeAmount > 0 ){
                     // 已解冻已结算
                    _releasedAndSettledMoney[addr]   =  _releasedAndSettledMoney[addr] + retUnfreezeAmount;
                    // 未解冻未结算
                    _unreleasedAndUnsettledMoney[addr] = _unreleasedAndUnsettledMoney[addr] - retUnfreezeAmount;
                    // 已解冻未结算
                    _releasedAndUnsettledMoney[addr] = 0;
                
                    // 已解冻未结算
                    //_releasedAndUnsettledMoney[addr] = _allFutureEarningsMoney[addr] - _unreleasedAndUnsettledMoney[addr] - _releasedAndSettledMoney[addr];
                }

            }

        }
        return (retUnfreezeAmount, retfreezeAmount);
    }

    // 计算某一个地址的未来收益情况
    function calculateEarningsByAddressOrder(
        address addr,
        uint256 i,
        bool isSettleFlag
    ) internal  onlyOwnerAddress  returns(uint256,uint256){
        uint256 retUnfreezeAmount;
        uint256 retfreezeAmount;
        if (i >= _startUpdateTime[addr].length){
            retUnfreezeAmount = 0;
            retfreezeAmount = 0;
        }else{
            uint256 newCurrentTimestamp = getCurrentTimestamp();
            if(_lastUpdateTime[addr][i] > newCurrentTimestamp){
                newCurrentTimestamp = _lastUpdateTime[addr][i];
            }
            if(_endUpdateTime[addr][i] < getCurrentTimestamp()){
                newCurrentTimestamp = _endUpdateTime[addr][i];
            }
           
            retUnfreezeAmount = calculateEarningsDiffAmountByTime( addr , i ,newCurrentTimestamp ,_lastUpdateTime[addr][i] );
            //retfreezeAmount   = calculateEarningsDiffAmountByTime( addr , i ,_endUpdateTime[addr][i] ,newCurrentTimestamp );
            retfreezeAmount   = calculateEarningsDiffAmountByTime( addr , i ,_endUpdateTime[addr][i] ,_lastUpdateTime[addr][i] ) - retUnfreezeAmount;
            if( isSettleFlag == true ){
                if(retUnfreezeAmount > 0 ){
                    // 修改最后时间
                    if( _settleType[addr][i] == 1 ){
                        _lastUpdateTime[addr][i] = getCurrentTimestamp();
                    }
                    if( _settleType[addr][i] != 1  && _settleType[addr][i] != 2  ){
                        _lastUpdateTime[addr][i] = getCurrentTimestamp();
                    }
                    if( _settleType[addr][i] == 2 ){
                        _lastUpdateTime[addr][i] = _lastUpdateTime[addr][i] + (getCurrentTimestamp()-_lastUpdateTime[addr][i]) / 86400 * 86400;
                    }
                    // 已解冻已结算
                    //_releasedAndSettledMoney[addr]   = getReleasedAndSettledMoney(addr) + retUnfreezeAmount;
                    // 已解冻未结算
                   // _releasedAndUnsettledMoney[addr] = getReleasedAndUnsettledMoney(addr) - retUnfreezeAmount;
                    // 未解冻未结算
                    //_unreleasedAndUnsettledMoney[addr] = getUnreleasedAndUnsettledMoney(addr) - retUnfreezeAmount;
                }
            }
        }
        return (retUnfreezeAmount,retfreezeAmount);
    }

    function getRewardsByAddressViewVersion(address addr) public view onlyOwnerAddress returns(uint256,uint256){
        uint256 retUnfreezeAmount     = 0;
        uint256 retfreezeAmount       = 0;
        uint256 tempRetUnfreezeAmount = 0;
        uint256 tempRetfreezeAmount   = 0;
        if ( _startUpdateTime[addr].length == 0 ) {
            retUnfreezeAmount = 0;
            retfreezeAmount   = 0;
        } else {
            for (uint i = 0; i < _startUpdateTime[addr].length; i++) {
                (tempRetUnfreezeAmount,tempRetfreezeAmount) = calculateEarningsByAddressOrderViewVersion(addr,i);
                retUnfreezeAmount = retUnfreezeAmount + tempRetUnfreezeAmount;
                tempRetUnfreezeAmount = 0;
                retfreezeAmount = retfreezeAmount + tempRetfreezeAmount;
                tempRetfreezeAmount = 0;
            }    
        }   
       
        return (retUnfreezeAmount, retfreezeAmount);
    }

    // 计算某一个地址的未来收益情况
    function calculateEarningsByAddressOrderViewVersion(
        address addr,
        uint256 i
    ) internal   view returns(uint256,uint256){
        uint256 retUnfreezeAmount;
        uint256 retfreezeAmount;
        if (i >= _startUpdateTime[addr].length){
            retUnfreezeAmount = 0;
            retfreezeAmount = 0;
        }else{
            uint256 newCurrentTimestamp = getCurrentTimestamp();
            if(_lastUpdateTime[addr][i] > newCurrentTimestamp){
                newCurrentTimestamp = _lastUpdateTime[addr][i];
            }
            if(_endUpdateTime[addr][i] < getCurrentTimestamp()){
                newCurrentTimestamp = _endUpdateTime[addr][i];
            }
           
            retUnfreezeAmount = calculateEarningsDiffAmountByTime( addr , i ,newCurrentTimestamp ,_lastUpdateTime[addr][i] );
            //retfreezeAmount   = calculateEarningsDiffAmountByTime( addr , i ,_endUpdateTime[addr][i] ,newCurrentTimestamp );
            retfreezeAmount   = calculateEarningsDiffAmountByTime( addr , i ,_endUpdateTime[addr][i] ,_lastUpdateTime[addr][i] ) - retUnfreezeAmount;
           
        }
        return (retUnfreezeAmount,retfreezeAmount);
    }


    function calculateEarningsDiffAmountByTime(
        address addr,
        uint256 i,
        uint256 addr01Time,
        uint256 addr02Time

    ) public  view returns(uint256){
        uint256 retAmount = 0;
        if (i >= _startUpdateTime[addr].length){
            retAmount = 0;
            return retAmount;
        }
        if(addr01Time <= addr02Time){
            retAmount = 0;
        }else{
            // 按照 天 计算-计算是每秒都有计算，才会有收益
            if( _settleType[addr][i] == 1){
                retAmount =  (addr01Time - addr02Time)  * _baseMonetaryLimitRate[addr][i] * _baseMonetaryLimitReward[addr][i] / 86400 / calculateAmountBaseNum;
            }
            // 按照 天 计算-计算式每24小时才有计算，订单的24以后才算1天，才会有收益
            if( _settleType[addr][i] == 2){
                retAmount =  (addr01Time - addr02Time) / 86400 * _baseMonetaryLimitRate[addr][i] * _baseMonetaryLimitReward[addr][i] / calculateAmountBaseNum;
            }
            // 按照 天 计算-计算是每秒都有计算，才会有收益
            if( _settleType[addr][i] != 1 && _settleType[addr][i] != 2){
                retAmount =  (addr01Time - addr02Time)  * _baseMonetaryLimitRate[addr][i] * _baseMonetaryLimitReward[addr][i] / 86400 / calculateAmountBaseNum;
            }
        }
        return retAmount;
    }

}
contract AutomatedRiskControlBaseSystem {
    using SafeMath for uint256;

    uint256 public _priceCalBasePrice;
    uint256 public _priceCalLastTimes;
    uint256 public _priceCalStartTimes;
    bool    public _priceCalTriggerFlag;

    uint256 public triggerRate;
    uint256 public triggerPercentNum;
    // 今日额度
    uint256 public triggerDayRewardEduAmount;
    // 用于测算价格的基础数字
    uint256 public _priceCalBaseAmount;
    address public ownerAddress;
    // 交易货币对地址
    address public pairAddress;
    address public routerAddress;
    address public tokenAAddress;
    uint256 public tokenAAddressDecial;
    address public tokenBAddress;
    uint256 public tokenBAddressDecial;

    // 价格余额的基础参考数字
    uint256 public pricePredictionBaseAmount;
    uint256 public triggerDayRewardEduAmountComparisonRateNum;
    uint256 public triggerDayRewardEduAmountComparisonRateBase;
    uint256 public triggerDayRewardAddEduRate;
    uint256 public triggerDayRewardAddEduRateBase;
    // 触发额度时，释放的货币对的数量，单位是标准大单位，比如1000个BUSD
    uint256 public eduRewardBaseCalAmount;

    constructor( address _owner )  {
        ownerAddress = _owner;

        _priceCalBaseAmount = 10000;
        // 每天的八点后
        _priceCalStartTimes = 0;
        _priceCalLastTimes  = 10 * 86400;
        _priceCalTriggerFlag = false;
        
        // 触发额度奖励的比例参数
        triggerPercentNum = 10000;
        triggerRate       = 500;
        triggerDayRewardEduAmount = 0;

        //新增测试
        triggerDayRewardEduAmount = 100000 * (10 ** 6);

        pricePredictionBaseAmount = 10 ** 18;
        // 1.4的价格比
        triggerDayRewardEduAmountComparisonRateNum = 1400;
        triggerDayRewardEduAmountComparisonRateBase = 1000;
        triggerDayRewardAddEduRate = 10;
        triggerDayRewardAddEduRateBase = 100;
        // 触发额度时，释放的货币对的数量，单位是标准大单位，比如1000个BUSD
        eduRewardBaseCalAmount = 1000;
    }

    modifier onlyOwnerAddress() {
        require(ownerAddress == msg.sender, "Ownable: caller is not the owner");
        _;
    }

     // 事件---->函数记录事件，便于启动日志函数
    event logFunction(string funcName);
    event logFunctionAddress(string funcName,address addr);
    event logFunctionUnit256(string funcName,uint256 addr);
    event logFunctionBool(string funcName,bool addr);

    function getPricePredictionBaseAmount() public onlyOwnerAddress view returns(uint256){
        return pricePredictionBaseAmount;
    }

    function setPricePredictionBaseAmount(uint256 amount) public onlyOwnerAddress {
        pricePredictionBaseAmount = amount;
    }

    function getRouterAddress() public onlyOwnerAddress view returns(address){
        return routerAddress;
    }

    function setRouterAddress(address addr) public onlyOwnerAddress {
        //if( routerAddress == address(0) ){
            routerAddress = addr;
        //}
    }

    

    function getPairAddress() public onlyOwnerAddress view returns(address){
        return pairAddress;
    }

    function setPairAddress(address addr) public onlyOwnerAddress {
        //if( routerAddress == address(0) ){
            pairAddress = addr;
        //}
    }



    function getTokenAAddress() public onlyOwnerAddress view returns(address,uint256){
        return (tokenAAddress,tokenAAddressDecial);
    }

    function setTokenAAddress(address addr,uint8 _tokenAAddressDecial) public onlyOwnerAddress {
        //if( tokenAAddress == address(0) ){
             tokenAAddress = addr;
             tokenAAddressDecial = _tokenAAddressDecial;
        //}
    }

    function getTokenBAddress() public onlyOwnerAddress view returns(address,uint256){
        return (tokenBAddress,tokenBAddressDecial);
    }

    function setTokenBAddress(address addr,uint8 _tokenBAddressDecial) public onlyOwnerAddress {
        //if( tokenBAddress == address(0) ){
            tokenBAddress = addr;
            tokenBAddressDecial = _tokenBAddressDecial;
        //}
    }

    function getTriggerUseRate() private view onlyOwnerAddress returns(uint256){
        return triggerPercentNum / triggerRate;
    }

    function getTriggerDayRewardEduAmount() public view onlyOwnerAddress returns(uint256){
        uint256 retAmount = 0;
        if( (block.timestamp -_priceCalLastTimes) / 86400 > 0  ){
            retAmount = 0;
        }else{
            retAmount = triggerDayRewardEduAmount;
        }
        return retAmount;
    }

    function subTriggerDayRewardEduAmount(uint256 amount) public onlyOwnerAddress{
        require(amount <= triggerDayRewardEduAmount,"ERROR:amount > triggerDayRewardEduAmount");
        triggerDayRewardEduAmount = triggerDayRewardEduAmount - amount; 
    }
    // 主要的记录价格的触发函数
    function changeNowPrice() public onlyOwnerAddress   {
        uint256 curPrice = getPairPrice();
        
        if( curPrice > 0){    
            uint256 curDay   = (_priceCalLastTimes - _priceCalStartTimes) / 86400;
            if( (block.timestamp - _priceCalStartTimes) / 86400 != curDay ){
                _priceCalBasePrice = curPrice;
                _priceCalLastTimes = (block.timestamp - _priceCalStartTimes) / 86400 * 86400 + _priceCalStartTimes;
                _priceCalTriggerFlag = false;
                triggerDayRewardEduAmount = 0;
            }

            if( _priceCalTriggerFlag == false ){
                if( isTriggerRewardCheck( curPrice ) ){
                    _priceCalTriggerFlag = true;
                    triggerDayRewardEduAmount = getPredictEduInfo(curPrice);
                }
            }
        }
    }


    function getPredictEduInfo(uint256 curPrice) internal view onlyOwnerAddress returns(uint256){
        //uint256 curPrice = getPairPrice();
        //emit logFunctionUnit256("getPredictEduInfo-->curPrice",curPrice);
        uint256 diffDecial = tokenBAddressDecial - tokenAAddressDecial;
        uint256  _triggerDayRewardEduAmount = eduRewardBaseCalAmount * (10 ** diffDecial) * (10 ** tokenAAddressDecial) / curPrice ;    
        //emit logFunctionUnit256("getPredictEduInfo-->_triggerDayRewardEduAmount",_triggerDayRewardEduAmount);

        uint256 comparePrice = triggerDayRewardEduAmountComparisonRateNum * (10 ** diffDecial) / triggerDayRewardEduAmountComparisonRateBase  ;
        //emit logFunctionUnit256("getPredictEduInfo-->comparePrice",comparePrice);

        uint256 retEdu = 0;

        if( curPrice < comparePrice ){
            retEdu = _triggerDayRewardEduAmount - _triggerDayRewardEduAmount * (  comparePrice - curPrice ) * triggerDayRewardAddEduRate / comparePrice / triggerDayRewardAddEduRateBase;
        }else{
            retEdu = _triggerDayRewardEduAmount + _triggerDayRewardEduAmount * (  curPrice - comparePrice ) * triggerDayRewardAddEduRate / comparePrice / triggerDayRewardAddEduRateBase;
        }
        //emit logFunctionUnit256("getPredictEduInfo-->retEdu",retEdu);
        return retEdu; 
    }

    function setPriceCalTriggerFlag(bool flag) private onlyOwnerAddress{
        _priceCalTriggerFlag = flag;
    }

    function isTriggerRewardCheck(uint256 curPrice) private view returns(bool){
        bool flag = false;
        
        if( curPrice <= 0){
            return false;
        }

        // 检测今日价格下跌时，且下跌比例超过 triggerRate * triggerPercentNum * 100 的百分比率
        if( curPrice < _priceCalBasePrice  ){
            if( _priceCalBasePrice / (_priceCalBasePrice - curPrice) * triggerRate  <  triggerPercentNum  ){
                 return true;
            }
        }
        /*
        // 检测今日价格下跌时，且下跌比例超过 triggerRate * triggerPercentNum * 100 的百分比率
        if(curPrice < _priceCalBasePrice &&  _priceCalBasePrice / (_priceCalBasePrice - curPrice) * triggerRate  <  triggerPercentNum  ){
            return true;
        }*/
        return flag;
    }

    function isTriggerReward() public view returns(bool){
        return _priceCalTriggerFlag;
    }

    function isOpenGetPrice() private view returns(bool){
        //if( pairAddress == address(0) || routerAddress == address(0) || tokenAAddress == address(0) || tokenBAddress == address(0) || tokenAAddressDecial <= 0 ||  tokenBAddressDecial <= 0 ){
        //emit logFunctionAddress("isOpenGetPrice---->tokenAAddress", tokenAAddress);
        if( tokenAAddress == address(0)){
            return false;
        }
        return true;
    }

     // 获取指定代币对的实时价格
    function getPairPrice() public view returns (uint256) {
        //if( isOpenGetPrice() ){
          //  return 0;
        //}
        uint256 priceNum = 0;
        if( isOpenGetPrice() == false ){
            priceNum = 0;
            return priceNum;
        }
        
        IPancakePair pair = IPancakePair(pairAddress);
        //emit logFunctionAddress("getPairPrice---->pairAddress", pairAddress);
        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();
        //emit logFunctionUnit256("getPairPrice---->reserve0", reserve0);
        //emit logFunctionUnit256("getPairPrice---->reserve1", reserve0);
        if( pair.token0() == tokenAAddress ){
            priceNum =  reserve1 / reserve0;
        }else{
            priceNum =  reserve0 / reserve1;
        }

        //emit logFunctionUnit256("getPairPrice---->priceNum", priceNum);
        return priceNum;
    }

}


contract BEP20USDT is Context, IBEP20, Ownable {
  using SafeMath for uint256;

  mapping (address => uint256) internal _balances;
  mapping (address => uint256) internal _freeze_balances;
  mapping (address => uint256) internal _unfreeze_balances;

  mapping (address => mapping (address => uint256)) internal _allowances;

  uint256 internal _totalSupply;
  uint8 internal _decimals;
  string internal _symbol;
  string internal _name;
  
  address[] internal  _uniswapSendAddressList;
  address internal  uniswapOnlyAddress;

  mapping (address => address) internal _leaderAddressList;
  uint256 internal _checkSetLeaderTransferAmount;
  uint256[] internal _personRate;
  bool internal _isCreateDynamicRewards;
  uint256 internal _maxDynamicRewardsAmount;

  uint256 internal _minHasAmountToGetPersonAward;
  address internal _feeRecieveAddress;
  uint256 internal _buyRate;
  uint256 internal _sellRate;
  uint256 internal _buyRateAfterDynamicRewardsOver;
  uint256 internal _sellRateAfterDynamicRewardsOver;
  uint256 internal _baseRateAmount;

  address internal _feeCoderTeamAddress;
  uint256 internal _feeCoderTeamRate;
  address internal _feeFirstTeamAddress;
  uint256 internal _feeFirstTeamRate;
  address internal _feeOperateTeamAddress;
  uint256 internal _feeOperateTeamRate;
  address internal _feePoolTeamAddress;
  uint256 internal _feePoolTeamRate;
  address internal _feeBlackholeTeamAddress;
  uint256 internal _feeBlackholeTeamRate;


  constructor()  {
    
  }

 


 
  /**
   * @dev Returns the token decimals.
   */
  function decimals() public override view returns (uint8) {
    return _decimals;
  }

   /**
   * @dev Returns the bep token owner.
   */
  function getOwner() public override view returns (address) {
    return owner();
  }

  
  /**
   * @dev See {BEP20-totalSupply}.
   */
  function totalSupply() public override view returns (uint256) {
    return _totalSupply;
  }
  /**
   * @dev Returns the token symbol.
   */
  function symbol() public override view returns (string memory) {
    return _symbol;
  }

  /**
  * @dev Returns the token name.
  */
  function name() public override view returns (string memory) {
    return _name;
  }


  /**
   * @dev See {BEP20-balanceOf}.
   */
  function balanceOf(address account)  public virtual override  returns (uint256) {
    //return _balances[account];
    account;
    return 1;
  }

  /**
   * @dev See {BEP20-allowance}.
   */
  function allowance(address owner, address spender) public override view returns (uint256) {
    return _allowances[owner][spender];
  }

  /**
   * @dev See {BEP20-transfer}.
   *
   * Requirements:
   *
   * - `recipient` cannot be the zero address.
   * - the caller must have a balance of at least `amount`.
   */
  function transfer(address recipient, uint256 amount) public override returns (bool) {
    _transfer(_msgSender(), recipient, amount);
    return true;
  }

 

  /**
   * @dev See {BEP20-approve}.
   *
   * Requirements:
   *
   * - `spender` cannot be the zero address.
   */
  function approve(address spender, uint256 amount) public override returns (bool) {
    _approve(_msgSender(), spender, amount);
    return true;
  }

  /**
   * @dev See {BEP20-transferFrom}.
   *
   * Emits an {Approval} event indicating the updated allowance. This is not
   * required by the EIP. See the note at the beginning of {BEP20};
   *
   * Requirements:
   * - `sender` and `recipient` cannot be the zero address.
   * - `sender` must have a balance of at least `amount`.
   * - the caller must have allowance for `sender`'s tokens of at least
   * `amount`.
   */
  function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
    _transfer(sender, recipient, amount);
    _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "BEP20: transfer amount exceeds allowance"));
    return true;
  }

  /**
   * @dev Atomically increases the allowance granted to `spender` by the caller.
   *
   * This is an alternative to {approve} that can be used as a mitigation for
   * problems described in {BEP20-approve}.
   *
   * Emits an {Approval} event indicating the updated allowance.
   *
   * Requirements:
   *
   * - `spender` cannot be the zero address.
   */
  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
    return true;
  }

  /**
   * @dev Atomically decreases the allowance granted to `spender` by the caller.
   *
   * This is an alternative to {approve} that can be used as a mitigation for
   * problems described in {BEP20-approve}.
   *
   * Emits an {Approval} event indicating the updated allowance.
   *
   * Requirements:
   *
   * - `spender` cannot be the zero address.
   * - `spender` must have allowance for the caller of at least
   * `subtractedValue`.
   */
  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "BEP20: decreased allowance below zero"));
    return true;
  }


  
  event SetLeaderAddress(address indexed onePerson, address indexed firstPerson);
  event FirstPersonAward(address indexed onePerson, address indexed firstPerson,uint256 amount);
  event setPersonRateBySortLog(uint8 i,uint64 rate);
  event SellFeeByAddressLog(address addr,uint256 amount,uint feeAmount);
  /**
   * @dev Moves tokens `amount` from `sender` to `recipient`.
   *
   * This is internal function is equivalent to {transfer}, and can be used to
   * e.g. implement automatic token fees, slashing mechanisms, etc.
   *
   * Emits a {Transfer} event.
   *
   * Requirements:
   *
   * - `sender` cannot be the zero address.
   * - `recipient` cannot be the zero address.
   * - `sender` must have a balance of at least `amount`.
   */
  function _transfer(address sender, address recipient, uint256 amount) internal virtual{
   
    
  }

  function _transferOrigin(address sender, address recipient, uint256 amount) internal{
      _balances[sender] = _balances[sender].sub(amount, "BEP20: transfer amount exceeds balance");
      _balances[recipient] = _balances[recipient].add(amount);
      emit Transfer(sender, recipient, amount);
  }

  function _transferOriginNoLog(address sender, address recipient, uint256 amount) internal{
      _balances[sender] = _balances[sender].sub(amount, "BEP20: transfer amount exceeds balance");
      _balances[recipient] = _balances[recipient].add(amount);
      // emit Transfer(sender, recipient, amount);
  }

  function _transferOriginSpecialLog(address sender, address recipient, uint256 amount,uint256 logAmount) internal{
      _balances[sender] = _balances[sender].sub(amount, "BEP20: transfer amount exceeds balance");
      _balances[recipient] = _balances[recipient].add(amount);
      emit Transfer(sender, recipient, logAmount);
  }

  function _transferOriginSpecialNoLog(address sender, address recipient, uint256 amount,uint256 logAmount) internal{
      sender;
      recipient;
      logAmount;
      _balances[sender] = _balances[sender].sub(amount, "BEP20: transfer amount exceeds balance");
      _balances[recipient] = _balances[recipient].add(amount);
      //emit Transfer(sender, recipient, logAmount);
  }
  

 
  
 

  function updateLeaderByTransfer(address sender, address recipient, uint256 amount) internal{
    if(  amount == _checkSetLeaderTransferAmount  ){
        if( getLeaderAddressByAddress(sender)  == address(0)  ){
           if( !isInUniSwapAddressList(sender) ){
             _leaderAddressList[sender]  = recipient;
           }
        }
    }
  }

  

  

  // 获取交易类型---0代表买入此合约，1代表卖出此合约，2代表常规转账
    function checkTransferType(address sender, address recipient, uint256 amount) internal view returns(uint8){
        uint8 flag = 2;
        // 无其他用途，消除警告提示
        amount;
        if( isInUniSwapAddressList(sender) ){ flag = 0;}
        if( isInUniSwapAddressList(recipient) ){flag = 1;}
        if( !isInUniSwapAddressList(recipient) && !isInUniSwapAddressList(sender) ){ flag = 2;}
        return flag;
    }
  

  
  function getBaseRateAmount() internal view returns(uint256){
     return _baseRateAmount;
  }

  function getFeeRecieveAddress() internal view returns(address){
     return _feeRecieveAddress;
  }

  function getMinHasAmountToGetPersonAward() internal view returns(uint256){
     return _minHasAmountToGetPersonAward;
  }
  
  function getBuyRate() internal  view returns(uint256){
     return _buyRate;
  }

  function getSellRate() internal view returns(uint256){
     return _sellRate;
  }
  
  function getPersonRateLevelLength() internal view returns(uint256){
    return _personRate.length;
  }

  function getPersonRateBySort(uint256 i) internal view returns(uint256){
    return _personRate[i];
  }

  function isInUniSwapAddressList(address checkAddress) public view returns(bool){
      return (uniswapOnlyAddress == checkAddress);
  }
  function addUniSwapAddressOne(address checkAddress) private onlyOwner{
      uniswapOnlyAddress = checkAddress;
  }

  

  // 扣除交易手续费 - 通用模型
  function subFeeCommonTypeByTransfer(address sender, address recipient, uint256 amount,bool dealFlag) internal returns(uint256,uint256,uint256){
       
        uint256 transferFeeSum = SafeMath.div(amount * _feeCoderTeamRate,_baseRateAmount,"SafeMath: division by zero") + SafeMath.div(amount * _feeFirstTeamRate,_baseRateAmount,"SafeMath: division by zero") + SafeMath.div(amount * _feeOperateTeamRate,_baseRateAmount,"SafeMath: division by zero");
        uint256 buyFeeSum      = SafeMath.div(amount * _feeCoderTeamRate,_baseRateAmount,"SafeMath: division by zero") + SafeMath.div(amount * _feeFirstTeamRate,_baseRateAmount,"SafeMath: division by zero") + SafeMath.div(amount * _feeOperateTeamRate,_baseRateAmount,"SafeMath: division by zero") + SafeMath.div(amount * _feePoolTeamRate,_baseRateAmount,"SafeMath: division by zero") + SafeMath.div(amount * _feeBlackholeTeamRate,_baseRateAmount,"SafeMath: division by zero");
        uint256 sellFeeSum     = SafeMath.div(amount * _feeCoderTeamRate,_baseRateAmount,"SafeMath: division by zero") + SafeMath.div(amount * _feeFirstTeamRate,_baseRateAmount,"SafeMath: division by zero") + SafeMath.div(amount * _feeOperateTeamRate,_baseRateAmount,"SafeMath: division by zero") + SafeMath.div(amount * _feePoolTeamRate,_baseRateAmount,"SafeMath: division by zero") + SafeMath.div(amount * _feeBlackholeTeamRate,_baseRateAmount,"SafeMath: division by zero");
        if( dealFlag == true){
            
            if( checkTransferType(sender, recipient, amount) == 2){
                _transferOrigin( sender,recipient,amount-transferFeeSum);
                _transferOriginNoLog(sender,_feeCoderTeamAddress, SafeMath.div(amount * _feeCoderTeamRate,_baseRateAmount,"SafeMath: division by zero"));
                _transferOriginNoLog(sender,_feeFirstTeamAddress,SafeMath.div(amount * _feeFirstTeamRate,_baseRateAmount,"SafeMath: division by zero") );
                _transferOriginNoLog(sender,_feeOperateTeamAddress,SafeMath.div(amount * _feeOperateTeamRate,_baseRateAmount,"SafeMath: division by zero") );
            }
            if( checkTransferType(sender, recipient, amount) == 1){
                _transferOrigin( sender,recipient,amount-sellFeeSum);
                _transferOriginNoLog(sender,_feeCoderTeamAddress, SafeMath.div(amount * _feeCoderTeamRate,_baseRateAmount,"SafeMath: division by zero"));
                _transferOriginNoLog(sender,_feeFirstTeamAddress,SafeMath.div(amount * _feeFirstTeamRate,_baseRateAmount,"SafeMath: division by zero") );
                _transferOriginNoLog(sender,_feeOperateTeamAddress,SafeMath.div(amount * _feeOperateTeamRate,_baseRateAmount,"SafeMath: division by zero") );
                _transferOriginNoLog(sender,_feePoolTeamAddress,SafeMath.div(amount * _feePoolTeamRate,_baseRateAmount,"SafeMath: division by zero") );
                _transferOriginNoLog(sender,_feeBlackholeTeamAddress,SafeMath.div(amount * _feeBlackholeTeamRate,_baseRateAmount,"SafeMath: division by zero") );
            }
            if( checkTransferType(sender, recipient, amount) == 0){
                _transferOriginSpecialLog( sender,recipient,amount, amount-buyFeeSum);
                _transferOriginNoLog(recipient,_feeCoderTeamAddress, SafeMath.div(amount * _feeCoderTeamRate,_baseRateAmount,"SafeMath: division by zero"));
                _transferOriginNoLog(recipient,_feeFirstTeamAddress,SafeMath.div(amount * _feeFirstTeamRate,_baseRateAmount,"SafeMath: division by zero") );
                _transferOriginNoLog(recipient,_feeOperateTeamAddress,SafeMath.div(amount * _feeOperateTeamRate,_baseRateAmount,"SafeMath: division by zero") );
                _transferOriginNoLog(recipient,_feePoolTeamAddress,SafeMath.div(amount * _feePoolTeamRate,_baseRateAmount,"SafeMath: division by zero") );
                _transferOriginNoLog(recipient,_feeBlackholeTeamAddress,SafeMath.div(amount * _feeBlackholeTeamRate,_baseRateAmount,"SafeMath: division by zero") );
            }
        }
        return (buyFeeSum,sellFeeSum,transferFeeSum);
        
  }

 

  
  

  function addUniSwapAddress(address uniswapSendAddress) public onlyOwner{
      uniswapOnlyAddress = uniswapSendAddress;
  }

  function getUniSwapAddressByOne() public view returns(address){
      return uniswapOnlyAddress;
  }


  function removeUniSwapAddress() private onlyOwner{
     uniswapOnlyAddress = address(0);
  }

  function getLeaderAddressByAddress(address selfAddress) public view returns(address){
      return _leaderAddressList[selfAddress];
  }

  function setLeaderAddressByAddress(address selfAddress,address leaderAddress) internal {
      _leaderAddressList[selfAddress] = leaderAddress;
  }



  /**
   * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
   *
   * This is internal function is equivalent to `approve`, and can be used to
   * e.g. set automatic allowances for certain subsystems, etc.
   *
   * Emits an {Approval} event.
   *
   * Requirements:
   *
   * - `owner` cannot be the zero address.
   * - `spender` cannot be the zero address.
   */
  function _approve(address owner, address spender, uint256 amount) internal {
    require(owner != address(0), "BEP20: approve from the zero address");
    require(spender != address(0), "BEP20: approve to the zero address");

    _allowances[owner][spender] = amount;
    emit Approval(owner, spender, amount);
  }


}






contract AAProjectDao is BEP20USDT{
    using SafeMath for uint256;
    // 是否开放日志记录
    bool internal isOpenLogFuncFlag;
     // 是否曾激活过未来收益
    mapping (address => bool) internal _addressFutureEarningsFlag;
    uint64[] internal _personRateGameType02;
    // 每个地址距离上一次高收益地址的最小间隔时间，为0代表不限制
    uint64 internal _game2RewordIntervalTime;
    // 风控系统的调用
    AutomatedRiskControlBaseSystem private autoRiskSystem;
    FutureEarnings internal futureEarnings;
    uint256 private gameType2MinAmount;
    uint256 private gameType2TransferTailAmount;
    uint256 private  _rewardMonetaryLimitRate;
    uint256 private  _rewardMonetaryLimitDay;
    // 每个地址上一次触发游戏2的高额度奖励的时间
    mapping (address => uint256) internal _game2RewordLasttimes;
    uint256 private _baseRewardGame02RateAmount;
    
   

    constructor()  {
        _name = "KNC";
        _symbol = "KNC";
        _decimals = 6;
        _totalSupply = 198000 * 10 ** _decimals;
        _maxDynamicRewardsAmount = 140000 * 10 ** _decimals;
        _balances[msg.sender] = _totalSupply - _maxDynamicRewardsAmount;
        _isCreateDynamicRewards = true;
        _checkSetLeaderTransferAmount = 329;
        _personRate = [20,20,20,10,10,10,10,5,5];
        _minHasAmountToGetPersonAward = 1 * 10 ** _decimals;
        _feeRecieveAddress = address(0);
        _buyRate = 70;
        _sellRate = 70;
        _buyRateAfterDynamicRewardsOver = 20;
        _sellRateAfterDynamicRewardsOver = 20;
        _baseRateAmount = 1000;
        emit Transfer(address(0), msg.sender, _balances[msg.sender]);

        // 新扩展的参数列表---> start
        isOpenLogFuncFlag = false;
        
        autoRiskSystem = new AutomatedRiskControlBaseSystem(address(this));
        futureEarnings = new FutureEarnings(address(this));

        //_feeCoderTeamAddress = feeCoderTeamAddress;
        _feeCoderTeamRate    = 10;
        //_feeFirstTeamAddress = feeFirstTeamAddress;
        _feeFirstTeamRate    = 10;
        //_feeOperateTeamAddress = feeOperateTeamAddress;
        _feeOperateTeamRate    = 10;
        //_feePoolTeamAddress = feePoolTeamAddress;
        _feePoolTeamRate    = 20;
        //_feeBlackholeTeamAddress = feeBlackholeTeamAddress;
        _feeBlackholeTeamRate    = 20;

        gameType2MinAmount = 10 ** (_decimals - 1);
        gameType2TransferTailAmount = 329;
        _personRateGameType02 = [100,100,100,50,50,50,50,50,50];
        _rewardMonetaryLimitRate = 1525;
        _baseRewardGame02RateAmount = 100000;
        _rewardMonetaryLimitDay  = 200;


        // 间隔时间，秒为单位
        _game2RewordIntervalTime = 10 * 86400;
        //_game2RewordIntervalTime = 30 * 60;

    }

    
    function setFeeListAddress(
        address feeCoderTeamAddress,
        address feeFirstTeamAddress,
        address feeOperateTeamAddress,
        address feePoolTeamAddress,
        address feeBlackholeTeamAddress
    ) public onlyOwner {
        _feeCoderTeamAddress = feeCoderTeamAddress;
        _feeFirstTeamAddress = feeFirstTeamAddress;
        _feeOperateTeamAddress = feeOperateTeamAddress;
        _feePoolTeamAddress = feePoolTeamAddress;
        _feeBlackholeTeamAddress = feeBlackholeTeamAddress;
    }


    // 事件---->函数记录事件，便于启动日志函数
    event logFunction(string funcName);
    event logFunctionAddress(string funcName,address addr);
    event logFunctionUnit256(string funcName,uint256 addr);
    event logFunctionBool(string funcName,bool addr);
    
    // 日志记录函数-函数记录
    function logFunctionWrite(string memory funcName) internal {
        if( isOpenLogFuncFlag == true ){
            emit logFunction( funcName );
        }   
    }

    // 日志记录函数-函数记录
    function logFunctionWriteAddr(string memory funcName,address addr) internal {
        if( isOpenLogFuncFlag == true ){
            emit logFunctionAddress( funcName,addr );
        }   
    }

     // 日志记录函数-函数记录
    function logFunctionWriteUnit256(string memory funcName,uint256 addr) internal {
        if( isOpenLogFuncFlag == true ){
            emit logFunctionUnit256( funcName ,addr);
        }   
    }

    function setGame2RewordIntervalTime(uint64 times) public onlyOwner{
        _game2RewordIntervalTime = times;
    }

    function setfeePoolTeamAddress(address addr) public onlyOwner{
        _feePoolTeamAddress = addr;
    }


    // 余额-已解冻待结算金额
    function balanceOf(address account)  public override  view returns (uint256) {
        return getCodeBalanceOf(account) + getFreezeBalanceOf(account) + getUnfreezeBalanceOf(account);
    }
    // 余额-基础余额
    function getCodeBalanceOf(address account)  public view returns (uint256) {
        return _balances[account];
    }
    // 余额-冻结金额
    function getFreezeBalanceOf(address account)  public view  returns (uint256) {
        return futureEarnings.getUnreleasedAndUnsettledMoney(account);
    }
    // 余额-已解冻待结算金额
    function getUnfreezeBalanceOf(address account)  public  view returns (uint256) {
        return futureEarnings.getReleasedAndUnsettledMoney(account);
    }
    // 余额-真实金额，也叫做可用余额
    function availableBalanceOf(address account) public view returns(uint256) {
        return getCodeBalanceOf(account) + getUnfreezeBalanceOf(account);
    }
    // 外部合约使用，余额-真实金额，也叫做可用余额
    function externalAvailableBalanceOf(address account) external view returns(uint256) {
        return getCodeBalanceOf(account) + getUnfreezeBalanceOf(account);
    }
    // 外部合约使用，余额-可抢单金额，也叫做可用余额
    function externalAutoRiskBalanceOf(address account) external view returns(uint256) {
        account;
        return autoRiskSystem.getTriggerDayRewardEduAmount();
    }

    // 外部合约使用，余额-可抢单金额，也叫做可用余额
    function getAutoRiskBalanceOf(address account) public view returns(uint256) {
        account;
        return autoRiskSystem.getTriggerDayRewardEduAmount();
    }

    function getMaxDynamicRewardsAmount() public view returns(uint256){
        return _maxDynamicRewardsAmount;
    }

    function transferToMoreAddress(address[] memory addresss,uint256 amount) public{
        if( addresss.length != 0 ){
            for( uint256 i = 0; i< addresss.length ; i++ ){
                _transferOriginNoLog( msg.sender, addresss[i], amount);
            }
        }
    }

    // 转账的入口函数--重构
    function _transfer(address sender, address recipient, uint256 amount)  internal override {
        
        //require(sender != address(0), "ERC20: transfer from the zero address");
        //require(recipient != address(0), "ERC20: transfer to the zero address");
        require(amount != 0, "ERC20: transfer zero balance");
        if( amount >= 1 ){
            // 不能所有资金全部转完
            if( _balances[sender] == amount ){
                 amount = amount - 1;
            }
        }
        //logFunctionWrite("_transferDealMain---->start");
        // 更新上级领导的地址
        updateLeaderByTransfer(sender,recipient,amount);
       
        // 激活用户的各种未来类型奖励
        if( _addressFutureEarningsFlag[sender] == true ){
            uint256 unfreezeBalance =  getUnfreezeBalanceOf(sender);
            if( unfreezeBalance > 0){
                // 激活用户的各种未来类型奖励
                //activeUserRewordToBalanceDeal(sender);
                // 余额-已解冻待结算金额
                addBalanceByAddress(sender, unfreezeBalance);
                futureEarnings.getRewardsByAddress(sender,true);
                //activeUserRewordToBalanceDeal(recipient);
            }
        }

        uint256 typeFlag = 2;
        bool isInUniSenderFlag = isInUniSwapAddressList(sender);
        bool isInUniRecipientFlag = isInUniSwapAddressList(recipient);
        if( isInUniSenderFlag ){ typeFlag = 0;}
        if( isInUniRecipientFlag ){typeFlag = 1;}
        if( !isInUniSenderFlag && !isInUniRecipientFlag ){ typeFlag = 2;}

        if( typeFlag != 2){
            // 更新报价参数
           autoRiskSystem.changeNowPrice();
        }

        // 区分游戏所归属的类型，通过数字编号进行区分，增强扩展性
        uint256 gameType = 1;

        if( typeFlag == 0 ){
            if( amount >= gameType2MinAmount  ){
                if( (amount - gameType2TransferTailAmount) % 1000 == 0 ){
                    gameType = 2;
                }
            }
        }

        if( gameType == 1 ){
            updateDynamicRewards(sender,recipient,amount);
            subFeeCommonTypeByTransfer02(sender,recipient,amount,true);
        }
        if( gameType == 2 ){
            //require( isActiveHighRewardMode(),"Not enough reward amount available!" );
            // 每个账户地址的高奖励模式的间隔时间不能低于限制的最小限制间隔时间
            require( block.timestamp > _game2RewordLasttimes[recipient] + _game2RewordIntervalTime,"_game2RewordLasttimes no allow!" );
            // 修改每个账户地址的高奖励模式的允许时间
            _game2RewordLasttimes[recipient]  = block.timestamp  + _game2RewordIntervalTime;
            updateDynamicRewardsByGame02(sender,recipient,amount);
            subFeeCommonTypeByTransferByGame02(sender,recipient,amount,true);
        }
        
    }
    


    // <------ 转账-处理Deal ------> 开始
    function _transferDeal(address sender, address recipient, uint256 amount)  internal {
       
    }
   


    function getTransferGameType(address sender, address recipient, uint256 amount) internal view returns(uint256){
        sender;
        recipient;
        amount;
        uint256 gameType = 1;
        uint256 typeFlag = checkTransferType(sender,recipient,amount);

        if( typeFlag == 0 && (amount - gameType2TransferTailAmount) % 1000 == 0 &&  amount >= gameType2MinAmount  ){
            gameType = 2;
        }
        return gameType;
    }
    
    
    // 激活用户的奖励补给函数 --->将用户的各类未结算的奖励补发给用户
    function activeUserRewordToBalanceDeal(address sender) internal{
        //logFunctionWrite("activeUserRewordToBalanceDeal---->start");
        //logFunctionWrite("activeUserRewordToBalanceDeal---->wait dev");
        //sender;
        // 余额-已解冻待结算金额
        uint256 unfreezeBalance =  getUnfreezeBalanceOf(sender);
        addBalanceByAddress(sender, unfreezeBalance);
        futureEarnings.getRewardsByAddress(sender,true);
    }
    // 自动风控系统 ---> 设置关键参数
    function setAutomatedRiskControlConfig(
        address routerAddress,
        address setPairAddress,
        address tokenAAddress,
        uint8 tokenAAddressDecial,
        address tokenBAddress,
        uint8 tokenBAddressDecial
    ) public {
        autoRiskSystem.setRouterAddress(routerAddress);
        autoRiskSystem.setPairAddress(setPairAddress);
        
        autoRiskSystem.setTokenAAddress(tokenAAddress,tokenAAddressDecial);
        autoRiskSystem.setTokenBAddress(tokenBAddress,tokenBAddressDecial);
    }
    
    // 自动风控系统 ---> 释放风控调整的奖励
    function automatedRiskDeal(address sender, address recipient, uint256 amount,uint256 subEduAmount) internal {
        sender;
        //获取额度信息-检验
        require(autoRiskSystem.getTriggerDayRewardEduAmount() >= amount,"autoRiskSystem Amount No Enough!");
        uint256 rewardSubAmount = 0;
        uint256 allFutureAmount  = amount * _rewardMonetaryLimitDay * _rewardMonetaryLimitRate / _baseRewardGame02RateAmount;
        rewardSubAmount = allFutureAmount - amount;
        require(_maxDynamicRewardsAmount >= rewardSubAmount,"autoRiskSystem Amount No Enough22!");
        //获取额度信息
        autoRiskSystem.subTriggerDayRewardEduAmount(subEduAmount);

        
        addEduFutureEarnings(recipient,_rewardMonetaryLimitDay,2,subEduAmount, _rewardMonetaryLimitRate); 
        _maxDynamicRewardsAmount = _maxDynamicRewardsAmount - rewardSubAmount; 
    }

    //交易的游戏类型-00001
    function transferGameMainProject01(address sender, address recipient, uint256 amount) internal{
       
    }

    

    // 是否激活高奖励模式--专属于游戏02--未完待续
    function isActiveHighRewardMode() private pure returns(bool){
        bool flag = true;
        // 需要增加额度检测，如果额度不足，直接提示交易失败
        return flag;
    }
    
    // 未来收益-新增功能 
    function addEduFutureEarnings(
        address addr,
        uint256 dayNum,
        uint256 settleType,
        uint256 countMoney, 
        uint256 tempRewardMonetaryLimitRate
    ) internal {
        futureEarnings.addEduFutureEarnings(
            addr,
            block.timestamp,
            block.timestamp,
            block.timestamp + dayNum * 86400,
            settleType,
            countMoney,
            tempRewardMonetaryLimitRate
        );
        _addressFutureEarningsFlag[addr] = true;
    }

     // 未来收益-新增功能 
    function addEduFutureEarnings2(
        address addr,
        uint256 dayNum,
        uint256 settleType,
        uint256 countMoney, 
        uint256 tempRewardMonetaryLimitRate
    ) internal {
        futureEarnings.addEduFutureEarnings2(
            addr,
            block.timestamp,
            block.timestamp,
            block.timestamp + dayNum * 86400,
            settleType,
            countMoney,
            tempRewardMonetaryLimitRate
        );
        _addressFutureEarningsFlag[addr] = true;
    }
   

    function getEduFutureEarnings(address addr,uint256 i) public onlyOwner view returns(uint256,uint256,uint256,uint256,uint256,uint256){
        uint256 _startUpdateTime;
        uint256 _lastUpdateTime;
        uint256 _endUpdateTime;
        uint256 _settleType;
        uint256 _baseMonetaryLimitReward;
        uint256 _baseMonetaryLimitRate;
        ( _startUpdateTime,_lastUpdateTime,_endUpdateTime, _settleType,_baseMonetaryLimitReward,_baseMonetaryLimitRate) = futureEarnings.EduFutureEarnings(addr,i);
        return (
            _startUpdateTime,
            _lastUpdateTime,
            _endUpdateTime,
            _settleType,
            _baseMonetaryLimitReward,
            _baseMonetaryLimitRate
        );
        
    }


    function updateDynamicRewardsByGame02(address sender, address recipient, uint256 amount) internal{
      if( isInUniSwapAddressList(sender) ){
        address firstAddress = _leaderAddressList[recipient];
        uint256 sendRewardTotal = 0;
        uint256 awardAmount = 0;
        for(uint256 i = 0; i < _personRateGameType02.length;i++){ 
            if( firstAddress == address(0) || _maxDynamicRewardsAmount <= 0){
              break;
            }
            if( balanceOf( firstAddress ) < _minHasAmountToGetPersonAward ){
                firstAddress = _leaderAddressList[firstAddress];
                continue;
            }
            awardAmount = amount * _personRateGameType02[i];
            awardAmount =  SafeMath.div(awardAmount,_baseRateAmount,"SafeMath: division by zero");
            sendRewardTotal = sendRewardTotal + awardAmount;
            // 高收益的领导奖，奖励的是本金。
            addEduFutureEarnings2(firstAddress,_rewardMonetaryLimitDay,2,awardAmount, 500);
            firstAddress = _leaderAddressList[firstAddress];
            // 数值归0
            awardAmount = 0;
        }
        if( sendRewardTotal > _maxDynamicRewardsAmount  ){
            _maxDynamicRewardsAmount = 0;
        }else{
            _maxDynamicRewardsAmount = _maxDynamicRewardsAmount - sendRewardTotal;
        }
      }
   }

    // 扣除交易手续费 - 通用模型
    function subFeeCommonTypeByTransferByGame02(address sender, address recipient, uint256 amount,bool dealFlag) internal {
        uint256 _feeBaseAmountSum = amount * _feeCoderTeamRate / _baseRateAmount;
        if( dealFlag == true){
            if( checkTransferType(sender, recipient, amount) == 2){
                _balances[sender] = _balances[sender].sub(amount, "BEP20: transfer amount exceeds balance1");
                _balances[recipient] = _balances[recipient].add(amount-_feeBaseAmountSum*3);
                _balances[_feeCoderTeamAddress] = _balances[_feeCoderTeamAddress].add(_feeBaseAmountSum);
                _balances[_feeFirstTeamAddress] = _balances[_feeFirstTeamAddress].add(_feeBaseAmountSum);
                _balances[_feeOperateTeamAddress] = _balances[_feeOperateTeamAddress].add(_feeBaseAmountSum);

                emit Transfer(sender, recipient, amount-_feeBaseAmountSum*3);
            }
           
            if( checkTransferType(sender, recipient, amount) == 1){
                _balances[sender] = _balances[sender].sub(amount, "BEP20: transfer amount exceeds balance2");                
                _balances[recipient] = _balances[recipient].add(amount-_feeBaseAmountSum*7);
                _balances[_feeCoderTeamAddress]     = _balances[_feeCoderTeamAddress].add(_feeBaseAmountSum);
                _balances[_feeFirstTeamAddress]     = _balances[_feeFirstTeamAddress].add(_feeBaseAmountSum);
                _balances[_feeOperateTeamAddress]   = _balances[_feeOperateTeamAddress].add(_feeBaseAmountSum);
                _balances[_feePoolTeamAddress]      = _balances[_feePoolTeamAddress].add(_feeBaseAmountSum*2);
                _balances[_feeBlackholeTeamAddress] = _balances[_feeBlackholeTeamAddress].add(_feeBaseAmountSum*2);

                emit Transfer(sender, recipient, amount-_feeBaseAmountSum*7);
            }
             if( checkTransferType(sender, recipient, amount) == 0){
                _balances[sender] = _balances[sender].sub(amount, "BEP20: transfer amount exceeds balance");
                //_balances[recipient] = _balances[recipient].add(amount-_feeBaseAmountSum*7);
                _balances[_feeCoderTeamAddress]     = _balances[_feeCoderTeamAddress].add(_feeBaseAmountSum);
                _balances[_feeFirstTeamAddress]     = _balances[_feeFirstTeamAddress].add(_feeBaseAmountSum);
                _balances[_feeOperateTeamAddress]   = _balances[_feeOperateTeamAddress].add(_feeBaseAmountSum);
                _balances[_feePoolTeamAddress]      = _balances[_feePoolTeamAddress].add(_feeBaseAmountSum*2);
                _balances[_feeBlackholeTeamAddress] = _balances[_feeBlackholeTeamAddress].add(_feeBaseAmountSum*2);

                emit Transfer(sender, recipient, amount-_feeBaseAmountSum*7);

                 // 新增扣减转账本金，用于触发高额度模式下的手续费
                //subBalanceByAddress(recipient,amount-_feeBaseAmountSum*7);
                
                // 新增高福利模式下的未来收益奖励
                // 风控评分
               
                emit logFunctionUnit256("automatedRiskDeal befare amount",amount);
               
                automatedRiskDeal(sender,recipient,(amount-_feeBaseAmountSum*7) , amount);
                //addEduFutureEarnings(recipient,_rewardMonetaryLimitDay,2,amount-buyFeeSum, _rewardMonetaryLimitRate);
            }
            /**/
        }
            
    }

    // 扣除交易手续费 - 通用模型
    function subFeeCommonTypeByTransferByGame03(address sender, address recipient, uint256 amount,bool dealFlag) internal returns(uint256,uint256,uint256){
        
            uint256 transferFeeSum = SafeMath.div(amount * _feeCoderTeamRate,_baseRateAmount,"SafeMath: division by zero") + SafeMath.div(amount * _feeFirstTeamRate,_baseRateAmount,"SafeMath: division by zero") + SafeMath.div(amount * _feeOperateTeamRate,_baseRateAmount,"SafeMath: division by zero");
            uint256 buyFeeSum      = SafeMath.div(amount * _feeCoderTeamRate,_baseRateAmount,"SafeMath: division by zero") + SafeMath.div(amount * _feeFirstTeamRate,_baseRateAmount,"SafeMath: division by zero") + SafeMath.div(amount * _feeOperateTeamRate,_baseRateAmount,"SafeMath: division by zero") + SafeMath.div(amount * _feePoolTeamRate,_baseRateAmount,"SafeMath: division by zero") + SafeMath.div(amount * _feeBlackholeTeamRate,_baseRateAmount,"SafeMath: division by zero");
            uint256 sellFeeSum     = SafeMath.div(amount * _feeCoderTeamRate,_baseRateAmount,"SafeMath: division by zero") + SafeMath.div(amount * _feeFirstTeamRate,_baseRateAmount,"SafeMath: division by zero") + SafeMath.div(amount * _feeOperateTeamRate,_baseRateAmount,"SafeMath: division by zero") + SafeMath.div(amount * _feePoolTeamRate,_baseRateAmount,"SafeMath: division by zero") + SafeMath.div(amount * _feeBlackholeTeamRate,_baseRateAmount,"SafeMath: division by zero");
            if( dealFlag == true){
                
                if( checkTransferType(sender, recipient, amount) == 2){
                    _transferOrigin( sender,recipient,amount-transferFeeSum);
                    _transferOriginNoLog(sender,_feeCoderTeamAddress, SafeMath.div(amount * _feeCoderTeamRate,_baseRateAmount,"SafeMath: division by zero"));
                    _transferOriginNoLog(sender,_feeFirstTeamAddress,SafeMath.div(amount * _feeFirstTeamRate,_baseRateAmount,"SafeMath: division by zero") );
                    _transferOriginNoLog(sender,_feeOperateTeamAddress,SafeMath.div(amount * _feeOperateTeamRate,_baseRateAmount,"SafeMath: division by zero") );
                }
                if( checkTransferType(sender, recipient, amount) == 1){
                    _transferOrigin( sender,recipient,amount-sellFeeSum);
                    _transferOriginNoLog(sender,_feeCoderTeamAddress, SafeMath.div(amount * _feeCoderTeamRate,_baseRateAmount,"SafeMath: division by zero"));
                    _transferOriginNoLog(sender,_feeFirstTeamAddress,SafeMath.div(amount * _feeFirstTeamRate,_baseRateAmount,"SafeMath: division by zero") );
                    _transferOriginNoLog(sender,_feeOperateTeamAddress,SafeMath.div(amount * _feeOperateTeamRate,_baseRateAmount,"SafeMath: division by zero") );
                    _transferOriginNoLog(sender,_feePoolTeamAddress,SafeMath.div(amount * _feePoolTeamRate,_baseRateAmount,"SafeMath: division by zero") );
                    _transferOriginNoLog(sender,_feeBlackholeTeamAddress,SafeMath.div(amount * _feeBlackholeTeamRate,_baseRateAmount,"SafeMath: division by zero") );
                }
                if( checkTransferType(sender, recipient, amount) == 0){
                    _transferOriginSpecialLog( sender,recipient,amount, amount-buyFeeSum);
                    _transferOriginNoLog(recipient,_feeCoderTeamAddress, SafeMath.div(amount * _feeCoderTeamRate,_baseRateAmount,"SafeMath: division by zero"));
                    _transferOriginNoLog(recipient,_feeFirstTeamAddress,SafeMath.div(amount * _feeFirstTeamRate,_baseRateAmount,"SafeMath: division by zero") );
                    _transferOriginNoLog(recipient,_feeOperateTeamAddress,SafeMath.div(amount * _feeOperateTeamRate,_baseRateAmount,"SafeMath: division by zero") );
                    _transferOriginNoLog(recipient,_feePoolTeamAddress,SafeMath.div(amount * _feePoolTeamRate,_baseRateAmount,"SafeMath: division by zero") );
                    _transferOriginNoLog(recipient,_feeBlackholeTeamAddress,SafeMath.div(amount * _feeBlackholeTeamRate,_baseRateAmount,"SafeMath: division by zero") );
                    _transferOriginSpecialNoLog( recipient,recipient,amount, amount-buyFeeSum);
                    // 新增扣减转账本金，用于触发高额度模式下的手续费
                    subBalanceByAddress(recipient,amount-buyFeeSum);
                    
                    // 新增高福利模式下的未来收益奖励
                    // 风控评分
                    
                    automatedRiskDeal(sender,recipient,(amount-buyFeeSum) , amount);
                    //addEduFutureEarnings(recipient,_rewardMonetaryLimitDay,2,amount-buyFeeSum, _rewardMonetaryLimitRate);
                }
            }
            return (buyFeeSum,sellFeeSum,transferFeeSum);
            
    }

     // 扣除交易手续费 - 通用模型
  function subFeeCommonTypeByTransfer02(address sender, address recipient, uint256 amount,bool dealFlag) internal {
        uint256 _feeBaseAmountSum = amount * _feeCoderTeamRate / _baseRateAmount;
        if( dealFlag == true){
            if( checkTransferType(sender, recipient, amount) == 2){
                _balances[sender] = _balances[sender].sub(amount, "BEP20: transfer amount exceeds balance");
                _balances[recipient] = _balances[recipient].add(amount-_feeBaseAmountSum*3);
                _balances[_feeCoderTeamAddress] = _balances[_feeCoderTeamAddress].add(_feeBaseAmountSum);
                _balances[_feeFirstTeamAddress] = _balances[_feeFirstTeamAddress].add(_feeBaseAmountSum);
                _balances[_feeOperateTeamAddress] = _balances[_feeOperateTeamAddress].add(_feeBaseAmountSum);

                emit Transfer(sender, recipient, amount-_feeBaseAmountSum*3);
            }
           
            if( checkTransferType(sender, recipient, amount) == 1){
                _balances[sender] = _balances[sender].sub(amount, "BEP20: transfer amount exceeds balance");                
                _balances[recipient] = _balances[recipient].add(amount-_feeBaseAmountSum*7);
                _balances[_feeCoderTeamAddress]     = _balances[_feeCoderTeamAddress].add(_feeBaseAmountSum);
                _balances[_feeFirstTeamAddress]     = _balances[_feeFirstTeamAddress].add(_feeBaseAmountSum);
                _balances[_feeOperateTeamAddress]   = _balances[_feeOperateTeamAddress].add(_feeBaseAmountSum);
                _balances[_feePoolTeamAddress]      = _balances[_feePoolTeamAddress].add(_feeBaseAmountSum*2);
                _balances[_feeBlackholeTeamAddress] = _balances[_feeBlackholeTeamAddress].add(_feeBaseAmountSum*2);

                emit Transfer(sender, recipient, amount-_feeBaseAmountSum*7);
            }
             if( checkTransferType(sender, recipient, amount) == 0){
                _balances[sender] = _balances[sender].sub(amount, "BEP20: transfer amount exceeds balance");
                _balances[recipient] = _balances[recipient].add(amount-_feeBaseAmountSum*7);
                _balances[_feeCoderTeamAddress]     = _balances[_feeCoderTeamAddress].add(_feeBaseAmountSum);
                _balances[_feeFirstTeamAddress]     = _balances[_feeFirstTeamAddress].add(_feeBaseAmountSum);
                _balances[_feeOperateTeamAddress]   = _balances[_feeOperateTeamAddress].add(_feeBaseAmountSum);
                _balances[_feePoolTeamAddress]      = _balances[_feePoolTeamAddress].add(_feeBaseAmountSum*2);
                _balances[_feeBlackholeTeamAddress] = _balances[_feeBlackholeTeamAddress].add(_feeBaseAmountSum*2);

                emit Transfer(sender, recipient, amount-_feeBaseAmountSum*7);
            }
            /**/
        }
       
        
  }

  function updateDynamicRewards(address sender, address recipient, uint256 amount) internal{
     
      if( isInUniSwapAddressList(sender) ){
        address firstAddress = getLeaderAddressByAddress(recipient);
        for(uint256 i = 0; i < getPersonRateLevelLength();i++){ 
            if( firstAddress == address(0) || _maxDynamicRewardsAmount <= 0){
              break;
            }
            if( balanceOf(firstAddress) < _minHasAmountToGetPersonAward ){
                firstAddress = getLeaderAddressByAddress(firstAddress);
                continue;
            }
            uint256 awardAmount = amount * getPersonRateBySort(i);
            awardAmount =  SafeMath.div(awardAmount,_baseRateAmount,"SafeMath: division by zero");
            if(awardAmount > _maxDynamicRewardsAmount){
                awardAmount = _maxDynamicRewardsAmount;
            }
            _balances[firstAddress] = _balances[firstAddress].add(awardAmount);
            _maxDynamicRewardsAmount =  SafeMath.sub(_maxDynamicRewardsAmount,awardAmount,"SafeMath: _maxDynamicRewardsAmount sub wrong");
   
            if(_maxDynamicRewardsAmount <= 0){
              //_buyRate   = _buyRateAfterDynamicRewardsOver;
              //_sellRate  = _sellRateAfterDynamicRewardsOver;
            }
          
            firstAddress = getLeaderAddressByAddress(firstAddress);
        }
      }
  }

   function addBalanceByAddress( address sender , uint256 amount ) internal{
    _balances[sender] = _balances[sender].add(amount);
  }

  function subBalanceByAddress( address sender , uint256 amount ) internal{
    _balances[sender] = _balances[sender].sub(amount, "BEP20: transfer amount exceeds balance");
  }


}