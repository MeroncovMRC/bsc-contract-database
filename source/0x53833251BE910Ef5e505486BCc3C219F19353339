{"IERC20.sol":{"content":"// SPDX-License-Identifier: Unlicensed\r\npragma solidity ^0.7.4;\r\n\r\n\r\n/**\r\n * ERC20 standard interface.\r\n */\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function getOwner() external view returns (address);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"},"IWAGMI20.sol":{"content":"// SPDX-License-Identifier: Unlicensed\r\npragma solidity ^0.7.4;\r\n\r\n\r\n/**\r\n * @dev Interface of the WAGMI20 standard\r\n */\r\ninterface IWAGMI20 {\r\n    function quickRundown(address account) external view returns (uint256);\r\n    function heBought(address account, uint256 amount) external;\r\n    function heSold(address account, uint256 amount) external;\r\n    function fundsAreSafu() external pure returns (bool);\r\n}"},"QuantumMint.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.4;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport \"./IWAGMI20.sol\";\r\n\r\n\r\n/*\r\n\r\n\r\nTelegram - https://t.me/QuantumMint\r\n\r\n\r\nTOGETHER WE WILL SAVE LUNC\r\n\r\n/**\r\n * Implement the basic ERC20 functions\r\n */\r\nabstract contract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address =\u003e uint256) internal _balances;\r\n    mapping (address =\u003e mapping (address =\u003e uint256)) internal _allowances;\r\n\r\n    uint256 internal _totalSupply = 0;\r\n    \r\n    string internal _name;\r\n    string internal _symbol;\r\n    uint8 internal _decimals = 18;\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n    \r\n    function name() public view override returns (string memory) {\r\n        return _name;\r\n    }\r\n    \r\n    function symbol() public view override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n    \r\n    function decimals() public view override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n}\r\n\r\n/**\r\n * Store contract creation block \u0026 timestamp. \r\n * Useful for APY calculations\r\n */\r\nabstract contract RecordsCreation {\r\n    uint256 public creationBlock;\r\n    uint256 public creationTimestamp;\r\n    \r\n    constructor(){\r\n        creationBlock = block.number;\r\n        creationTimestamp = block.timestamp;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Provides ownable context \r\n */\r\nabstract contract Ownable {\r\n    constructor() { _owner = msg.sender; }\r\n    address payable _owner;\r\n    modifier onlyOwner() {\r\n        require(isOwner(msg.sender), \"!OWNER\"); _;\r\n    }    \r\n    /**\r\n     * Check if address is owner\r\n     */\r\n    function isOwner(address account) public view returns (bool) {\r\n        return account == _owner;\r\n    }\r\n    \r\n    /**\r\n     * Function modifier to require caller to be contract owner\r\n     */\r\n    modifier owned() {\r\n        require(isOwner(msg.sender)); _;\r\n    }\r\n    \r\n    /**\r\n     * Transfer ownership to the zero address. Caller must be owner.\r\n     */\r\n    function renounceOwnership() public owned() {\r\n        transferOwnership(address(0));\r\n    }\r\n    \r\n    /**\r\n     * Transfer ownership to new address. Caller must be owner.\r\n     */\r\n    function transferOwnership(address payable adr) public owned() {\r\n        _owner = adr;\r\n    }\r\n}\r\n\r\n/**\r\n * QuantumMintBot interface for accepting transfer hooks\r\n */\r\ninterface IQuantumMintBot {\r\n    function txHook(address caller, address sender, address receiver, uint256 amount) external;\r\n}\r\n\r\n/**\r\n * Allow external contracts (QuantumMintBots) to hook into QuantumMint transactions\r\n */\r\nabstract contract QuantumMintBotController is Ownable {\r\n    struct QuantumMintBotInfo {\r\n        bool bot;\r\n        uint256 adrIndex;\r\n    }\r\n    \r\n    mapping (address =\u003e QuantumMintBotInfo) _botsInfo;\r\n    address[] _QuantumMintBots;\r\n    uint256 _QuantumMintBotsCount;\r\n    \r\n    /**\r\n     * Returns array of QuantumMintBots\r\n     */\r\n    function getBots() public view returns (address[] memory) {\r\n        return _QuantumMintBots;\r\n    }\r\n    \r\n    /**\r\n     * Returns QuantumMintBot count\r\n     */\r\n    function getBotCount() public view returns (uint256) {\r\n        return _QuantumMintBotsCount;\r\n    }\r\n    \r\n    /**\r\n     * Check if address is registered as QuantumMintBot\r\n     */\r\n    function isBot(address account) public view returns (bool) {\r\n        return _botsInfo[account].bot;\r\n    }\r\n    \r\n    /**\r\n     * Add contract to list\r\n     */\r\n    function addQuantumMintBot(address bot) external owned {\r\n        require(isContract(bot));\r\n        _botsInfo[bot].bot = true;\r\n        _botsInfo[bot].adrIndex = _QuantumMintBots.length;\r\n        _QuantumMintBots.push(bot);\r\n        _QuantumMintBotsCount++;\r\n    }\r\n    \r\n    /**\r\n     * Remove bot from list\r\n     */\r\n    function removeQuantumMintBot(address bot) external owned {\r\n        require(isBot(bot));\r\n        _botsInfo[bot].bot = false;\r\n        _QuantumMintBotsCount--; \r\n        \r\n        uint256 i = _botsInfo[bot].adrIndex; // gas savings\r\n        \r\n        // swap in removed bot with last holder and then pop from end\r\n        _QuantumMintBots[i] = _QuantumMintBots[_QuantumMintBots.length-1];\r\n        _botsInfo[_QuantumMintBots[i]].adrIndex = i;\r\n        _QuantumMintBots.pop();\r\n    }\r\n    \r\n    /**\r\n     * Call all QuantumMintBot hooks\r\n     */\r\n    function QuantumMintBotTxHook(address sender, address receiver, uint256 amount) internal {\r\n        if(getBotCount() == 0){ return; }\r\n        for(uint256 i=0; i\u003c_QuantumMintBots.length; i++){ \r\n            /* \r\n             * Using try-catch ensures that any errors / fails in one of the QuantumMintBot contracts will not cancel the overall transaction\r\n             */\r\n            try IQuantumMintBot(_QuantumMintBots[i]).txHook(msg.sender, sender, receiver, amount) {} catch {}\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Check if address is contract.\r\n     * Credit to OpenZeppelin\r\n     */\r\n    function isContract(address addr) internal view returns (bool) {\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n    \r\n        bytes32 codehash;\r\n        assembly {\r\n            codehash := extcodehash(addr)\r\n        }\r\n        return (codehash != 0x0 \u0026\u0026 codehash != accountHash);\r\n    }\r\n}\r\n\r\n/**\r\n * Keeps a record of all holders.\r\n * Allows all holder data to be used on-chain by other contracts. ;)\r\n */\r\nabstract contract TracksHolders is Ownable {\r\n    \r\n    /**\r\n     * Struct for storing holdings data\r\n     */\r\n    struct Holding {\r\n        bool holding; // whether address is currently holding\r\n        uint256 adrIndex; // index of address in holders array\r\n    }\r\n    \r\n    mapping (address =\u003e Holding) _holdings;\r\n    address[] _holders;\r\n    uint256 _holdersCount;\r\n    \r\n    /**\r\n     * Returns array of holders\r\n     */\r\n    function getHolders() public view returns (address[] memory) {\r\n        return _holders;\r\n    }\r\n    \r\n    /**\r\n     * Returns holders count\r\n     */\r\n    function getHoldersCount() public view returns (uint256) {\r\n        return _holdersCount;\r\n    }\r\n    \r\n    /**\r\n     * Returns whether address is currently holder\r\n     */\r\n    function isHolder(address holder) public view returns (bool) {\r\n        return _holdings[holder].holding;\r\n    }\r\n    \r\n    /**\r\n     * Add address to holders list\r\n     */\r\n    function addHolder(address account) internal {\r\n        _holdings[account].holding = true;\r\n        _holdings[account].adrIndex = _holders.length;\r\n        _holders.push(account);\r\n        _holdersCount++;\r\n    }\r\n    \r\n    /**\r\n     * Remove address from holders list\r\n     */\r\n    function removeHolder(address account) internal {\r\n        _holdings[account].holding = false;\r\n        \r\n        // saves gas\r\n        uint256 i = _holdings[account].adrIndex;\r\n        \r\n        // remove holder from array by swapping in end holder\r\n        _holders[i] = _holders[_holders.length-1];\r\n        _holders.pop();\r\n        \r\n        // update end holder index\r\n        _holdings[_holders[i]].adrIndex = i;\r\n        \r\n        _holdersCount--;\r\n    }\r\n}\r\n\r\ninterface IQuantumMintDistributive {\r\n    function getTotalStaked() external view returns (uint256);\r\n    function getTotalFees() external view returns (uint256);\r\n    \r\n    function getStake(address staker) external view returns (uint256);\r\n    function getEarnings(address staker) external view returns (uint256);\r\n    \r\n    function stake(uint256 amount) external;\r\n    function unstake(uint256 amount) external;\r\n    \r\n    function getPairAddress() external view returns (address);\r\n    function forceUnstakeAll() external;\r\n    \r\n    event Staked(address account, uint256 amount);\r\n    event Unstaked(address account, uint256 amount);\r\n    \r\n    event FeesDistributed(address account, uint256 amount);\r\n}\r\n\r\n/* \u003e We can soon purchase Sri Lanka with our market cap */\r\n\r\n/**\r\n * This is where the fun begins\r\n */\r\nabstract contract QuantumMintDistributive is IQuantumMintDistributive, ERC20, Ownable, TracksHolders {\r\n    using SafeMath for uint256;\r\n    \r\n    IERC20 _pair;\r\n    bool _pairInitialized;\r\n    \r\n    /**\r\n     * Struct for holding record of account stakes.\r\n     */\r\n    struct Stake {\r\n        uint256 LP; // Amount of LP tokens staked\r\n        uint256 excludedAmt; // Amount of staking rewards to exclude from returns (if claimed or staked after)\r\n        uint256 realised; // realised rewards\r\n    }\r\n    \r\n    mapping (address =\u003e Stake) _stakes;\r\n    \r\n    uint256 _totalLP;\r\n    uint256 _totalFees;\r\n    uint256 _totalRealised;\r\n    \r\n    /**\r\n     * Total LP tokens staked\r\n     */\r\n    function getTotalStaked() external override view returns (uint256) {\r\n        return _totalLP;\r\n    }\r\n    \r\n    /**\r\n     * Total amount of transaction fees reflected to stakers\r\n     */\r\n    function getTotalFees() external override view returns (uint256) {\r\n        return _totalFees;\r\n    }\r\n    \r\n    /**\r\n     * Returns amount of LP that address has staked\r\n     */\r\n    function getStake(address account) public override view returns (uint256) {\r\n        return _stakes[account].LP;\r\n    }\r\n    \r\n    /**\r\n     * Returns total earnings (realised + unrealised)\r\n     */\r\n    function getEarnings(address staker) external override view returns (uint256) {\r\n        return _stakes[staker].realised.add(earnt(staker)); // realised gains plus outstanding earnings\r\n    }\r\n    \r\n    /**\r\n     * Returns unrealised earnings\r\n     */\r\n    function getUnrealisedEarnings(address staker) external view returns (uint256) {\r\n        return earnt(staker);\r\n    }\r\n    \r\n    /**\r\n     * Stake LP tokens to earn a share of the 4% tx fee\r\n     */\r\n    function stake(uint256 amount) external override pairInitialized {\r\n        _stake(msg.sender, amount);\r\n    }\r\n    \r\n    /**\r\n     * Unstake LP tokens\r\n     */\r\n    function unstake(uint256 amount) external override pairInitialized {\r\n        _unstake(msg.sender, amount);\r\n    }\r\n    \r\n    /**\r\n     * Return Cake-LP pair address\r\n     */\r\n    function getPairAddress() external view override returns (address) {\r\n        return address(_pair);\r\n    }\r\n    \r\n    /**\r\n     * Return stakes to all holders\r\n     */\r\n    function forceUnstakeAll() external override owned {\r\n        for(uint256 i=0; i\u003c_holders.length; i++){\r\n            uint256 amt = getStake(_holders[i]); // saves gas\r\n            if(amt \u003e 0){ _unstake(_holders[i], amt); }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Add outstanding staking rewards to balance\r\n     */\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account].add(earnt(account));\r\n    }\r\n    \r\n    /**\r\n     * Convert unrealised staking gains into actual balance\r\n     */\r\n    function realise() public {\r\n        _realise(msg.sender);\r\n    }\r\n    \r\n    /**\r\n     * Realises outstanding staking rewards into balance\r\n     */\r\n    function _realise(address account) internal {\r\n        if(getStake(account) != 0){\r\n            uint256 amount = earnt(account);\r\n            _balances[account] = _balances[account].add(amount);\r\n            _stakes[account].realised = _stakes[account].realised.add(amount);\r\n            _totalRealised = _totalRealised.add(amount);\r\n        }\r\n        _stakes[account].excludedAmt = _totalFees;\r\n    }\r\n    \r\n    /**\r\n     * Calculate current outstanding staking gains\r\n     */\r\n    function earnt(address account) internal view returns (uint256) {\r\n        if(_stakes[account].excludedAmt == _totalFees || _stakes[account].LP == 0){ return 0; }\r\n        uint256 availableFees = _totalFees.sub(_stakes[account].excludedAmt);\r\n        uint256 share = availableFees.mul(_stakes[account].LP).div(_totalLP); // won\u0027t overflow as even totalsupply^2 is less than uint256 max\r\n        return share;\r\n    }\r\n    \r\n    /**\r\n     * Stake amount LP from account\r\n     */\r\n    function _stake(address account, uint256 amount) internal {\r\n        _pair.transferFrom(account, address(this), amount); // transfer LP tokens from account\r\n        \r\n        // realise staking gains now (also works to set excluded amt to current total rewards)\r\n        _realise(account); \r\n        \r\n        // add to current address\u0027 stake\r\n        _stakes[account].LP = _stakes[account].LP.add(amount);\r\n        _totalLP = _totalLP.add(amount);\r\n        \r\n        // ensure staker is recorded as holder\r\n        updateHoldersStaked(account);\r\n        \r\n        emit Staked(account, amount);\r\n    }\r\n    \r\n    /**\r\n     * Unstake amount for account\r\n     */\r\n    function _unstake(address account, uint256 amount) internal {\r\n        require(_stakes[account].LP \u003e= amount); // ensure sender has staked more than or equal to requested amount\r\n        \r\n        _realise(account); // realise staking gains\r\n        \r\n        // remove stake\r\n        _stakes[account].LP = _stakes[account].LP.sub(amount);\r\n        _totalLP = _totalLP.sub(amount);\r\n        \r\n        // send LP tokens back\r\n        _pair.transfer(account, amount);\r\n        \r\n        // check if sender is no longer a holder\r\n        updateHoldersUnstaked(account);\r\n        \r\n        emit Unstaked(account, amount);\r\n    }\r\n    \r\n    /**\r\n     * Distribute amount to stakers.\r\n     */\r\n    function distribute(uint256 amount) external {\r\n        _realise(msg.sender);\r\n        require(_balances[msg.sender] \u003e= amount);\r\n        \r\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\r\n        _distribute(msg.sender, amount);\r\n    }\r\n    \r\n    /**\r\n     * Distribute amount from account as transaction fee\r\n     */\r\n    function _distribute(address account, uint256 amount) internal {\r\n        _totalFees = _totalFees.add(amount);\r\n        emit FeesDistributed(account, amount);\r\n    }\r\n    \r\n    /**\r\n     * Check if account is holding in context of transaction sender\r\n     */\r\n    function updateHoldersTransferSender(address account) internal {\r\n        if(!isStillHolding(account)){ removeHolder(account); }\r\n    }\r\n    \r\n    /**\r\n     * Check if account is still holding in context of transaction recipient\r\n     */\r\n    function updateHoldersTransferRecipient(address account) internal {\r\n        if(!isHolder(account)){ addHolder(account); }\r\n    }\r\n    \r\n    /**\r\n     * Check if account is holding in context of staking tokens\r\n     */\r\n    function updateHoldersStaked(address account) internal {\r\n        if(!isHolder(account)){ addHolder(account); }\r\n    }\r\n    \r\n    /**\r\n     * Check if account is still holding in context of unstaking tokens\r\n     */\r\n    function updateHoldersUnstaked(address account) internal {\r\n        if(!isStillHolding(account)){ removeHolder(account); }\r\n    }\r\n    \r\n    /**\r\n     * Check if account has a balance or a stake\r\n     */\r\n    function isStillHolding(address account) internal view returns (bool) {\r\n        return balanceOf(account) \u003e 0 || getStake(account) \u003e 0;\r\n    }\r\n    \r\n    /**\r\n     * Require pair address to be set\r\n     */\r\n    modifier pairInitialized() { require(_pairInitialized); _; }\r\n    \r\n    /**\r\n     * Set the pair address.\r\n     * Don\u0027t allow changing whilst LP is staked (as this would prevent stakers getting their LP back)\r\n     */\r\n    function setPairAddress(address pair) external owned {\r\n        require(_totalLP == 0, \"Cannot change pair whilst there is LP staked\");\r\n        _pair = IERC20(pair);\r\n        _pairInitialized = true;\r\n    }\r\n}\r\n\r\n/* \u003e QuantumMint governs exchanges \u0026 pools globally */\r\n\r\n/**\r\n * This contract burns tokens on transactions\r\n */\r\nabstract contract Burnable is QuantumMintDistributive {\r\n    using SafeMath for uint256;\r\n    \r\n    uint256 _burnRate = 12; // 1.0% of tx\u0027s to  be split between burn/distribute\r\n    uint256 _distributeRatio = 1; // 1:1 ratio of burn:distribute\r\n    uint256 _totalBurnt;\r\n    \r\n    /**\r\n     * Total amount of tokens burnt\r\n     */\r\n    function getTotalBurnt() external view returns (uint256) {\r\n        return _totalBurnt;\r\n    }\r\n    \r\n    /**\r\n     * Current burn rate\r\n     */\r\n    function getBurnRate() public view returns (uint256) {\r\n        return _burnRate;\r\n    }\r\n    \r\n    /**\r\n     * Current distribution ratio\r\n     */\r\n     function getDistributionRatio() public view returns (uint256) {\r\n         return _distributeRatio;\r\n     }\r\n    \r\n    /**\r\n     * Change to a new burn rate\r\n     */\r\n    function setBurnRate(uint256 newRate) external owned {\r\n        require(newRate \u003c 100);\r\n        _burnRate = newRate;\r\n    }\r\n    \r\n    /**\r\n     * Change the burn:stakers distribution ratio\r\n     */\r\n    function setDistributionRatio(uint256 newRatio) external owned {\r\n        require(newRatio \u003e= 1);\r\n        _distributeRatio = newRatio;\r\n    }  \r\n\r\n    /**\r\n     * Burns transaction amount as per burn rate \u0026 returns remaining transfer amount. \r\n     */\r\n    function _txBurn(address account, uint256 txAmount) internal returns (uint256) {\r\n        uint256 toBurn = txAmount.mul(_burnRate).div(1000); // calculate amount to burn\r\n        \r\n        _distribute(account, toBurn.mul(_distributeRatio-1).div(_distributeRatio));\r\n        _burn(account, toBurn.div(_distributeRatio));\r\n        \r\n        return txAmount.sub(toBurn); // return amount left after burn\r\n    }\r\n    \r\n    /**\r\n     * Burn amount tokens from sender\r\n     */\r\n    function burn(uint256 amount) public {\r\n        require(_balances[msg.sender] \u003e= amount);\r\n        _burn(msg.sender, amount);\r\n    }\r\n    \r\n    /**\r\n     * Burns amount of tokens from account\r\n     */\r\n    function _burn(address account, uint256 amount) internal {\r\n        if(amount == 0){ return; }\r\n        \r\n        _totalSupply = _totalSupply.sub(amount);\r\n        _totalBurnt = _totalBurnt.add(amount);\r\n        _balances[account] = _balances[account].sub(amount);\r\n        \r\n        emit Burn(account, amount);\r\n    }\r\n    \r\n    event Burn(address account, uint256 amount);\r\n}\r\n\r\n/**\r\n * Implements high level functions\r\n */\r\nabstract contract WAGMI20 is IWAGMI20, Burnable, QuantumMintBotController {\r\n    using SafeMath for uint256;\r\n    \r\n    uint32 _maxTxPercent = 30; // max size as % of supply as percentage to 1d.p, eg 30 = 3.0%\r\n    bool _firstTx = true; // flag for first tx (as this will be to provide liquidity so don\u0027t want limit)\r\n    \r\n    /**\r\n     * Mint tx sender with initial supply\r\n     */\r\n    constructor(uint256 supply) {\r\n        uint256 amount = supply * (10 ** _decimals);\r\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\r\n        _totalSupply = _totalSupply.add(amount);\r\n        updateHoldersTransferRecipient(msg.sender); // ensure receiver is set as sender\r\n        emit Transfer(address(0), msg.sender, amount);\r\n    }\r\n    \r\n    /**\r\n     * \u003eCan I get a quick rundown?\r\n     */\r\n    function quickRundown(address account) external view override returns (uint256) {\r\n        return balanceOf(account);    \r\n    }\r\n    \r\n    /**\r\n     * funds are safu?\r\n     */\r\n    function fundsAreSafu() external pure override returns (bool) {\r\n        return true; // always ;)\r\n    }\r\n\r\n    /**\r\n    * burns QuantumMint to the dead address \r\n    */\r\n\r\n    function _burnToDeadAddress(address account, uint256 amount) internal virtual {\r\n        _balances[account] = _balances[account].sub(amount);\r\n        _totalSupply -= amount;\r\n        emit Transfer(account, address(0), amount);\r\n    }   \r\n   \r\n    /**\r\n     * Return owner address as per ERC20 standard\r\n     */\r\n    function getOwner() external view override returns (address) {\r\n        return _owner;\r\n    }\r\n    \r\n    /**\r\n     * Ensure tx size is within allowed % of supply\r\n     */\r\n    function checkTxAmount(uint256 amount) internal {\r\n        if(_firstTx){ _firstTx = amount == 0 ? true : false; return; } // skip first tx as this will be providing 100% as liquidity\r\n        require(amount \u003c= _totalSupply.mul(_maxTxPercent).div(1000), \"Tx size exceeds limit\");\r\n    }\r\n\r\n    /**\r\n    * calls burn function\r\n    */\r\n\r\n    function burnToDeadAddress(uint256 amount) public onlyOwner {\r\n        _burnToDeadAddress(msg.sender, amount);\r\n    }    \r\n\r\n    /**\r\n     * Change the max tx size percent. Required to be from 1% to 100%\r\n     */\r\n    function setMaxTxPercent(uint32 amount) external owned {\r\n        require(amount \u003e 10 \u0026\u0026 amount \u003c 1000, \"Invalid max tx size\"); // ensure \u003e 1% \u0026 \u003c 100%\r\n        _maxTxPercent = amount;\r\n    }\r\n       \r\n    /**\r\n     * The transfer function. \r\n     * Normal transfer is also called through this and a sender==msg.sender check is used to determine whether to use allowance\r\n     */\r\n    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        require(sender != address(0), \"Can\u0027t transfer from zero\");\r\n        require(recipient != address(0), \"Can\u0027t transfer to zero\");\r\n        \r\n        // ensure tx size is below limit\r\n        checkTxAmount(amount); \r\n        \r\n        // realise staked gains \u0026 then check if enough balance to cover\r\n        _realise(sender);\r\n        require(_balances[sender] \u003e= amount, \"Not enough balance\");\r\n        \r\n        // require allowance if sender is not transaction creator\r\n        if(sender != msg.sender){\r\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount, \"Not enough allowance\");\r\n        }\r\n        \r\n        // burn \u0026 distribute\r\n        uint256 sendAmt = _txBurn(sender, amount); \r\n        \r\n        // transfer\r\n        _balances[sender] = _balances[sender].sub(sendAmt);\r\n        _balances[recipient] = _balances[recipient].add(sendAmt);\r\n        \r\n        // update holders\r\n        updateHoldersTransferSender(sender);\r\n        updateHoldersTransferRecipient(recipient);\r\n        \r\n        // call any hooks\r\n        QuantumMintBotTxHook(sender, recipient, amount);\r\n        \r\n        emit Transfer(sender, recipient, sendAmt);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * Approve spender to spend amount from msg.sender\r\n     */\r\n    function _approve(address spender, uint256 amount) internal returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        return true;\r\n    }\r\n    \r\n    function heBought(address account, uint256 amount) external override { /* just for the IWAGMI20 meme */}\r\n    function heSold(address account, uint256 amount) external override { /* just for the IWAGMI20 meme */ }\r\n    \r\n    \r\n    /**\r\n     * Approve spender to spend amount from msg.sender\r\n     */\r\n    function approve(address spender, uint256 amount) external override returns (bool) {\r\n        return _approve(spender, amount);\r\n    }\r\n    \r\n    /**\r\n     * Transfer from msg.sender to recipient for amount\r\n     */\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n         return _transferFrom(msg.sender, recipient, amount);\r\n     }\r\n\r\n    /**\r\n     * Transfer amount from sender to recipient so long as msg.sender has at least amount allowance\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        return _transferFrom(sender, recipient, amount);\r\n    }\r\n    \r\n    /**\r\n     * Bulk execute transfers\r\n     */\r\n    function multiTransfer(address[] memory accounts, uint256[] memory amounts) external {\r\n        require(accounts.length == amounts.length, \"Accounts \u0026 amounts must be same length\");\r\n        for(uint256 i=0; i\u003caccounts.length; i++){\r\n            _transferFrom(msg.sender, accounts[i], amounts[i]);\r\n        }\r\n    }\r\n}\r\n\r\ncontract QuantumMint is WAGMI20, RecordsCreation {\r\n    using SafeMath for uint256;\r\n    \r\n    constructor() WAGMI20(1000000) {\r\n        _name = \"Quantum Mint Coin\";\r\n        _symbol = \"QMC\";\r\n    }\r\n}"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\r\n\r\npragma solidity ^0.7.4;\r\n/**\r\n * @dev Wrappers over Solidity\u0027s arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\r\n * now has built in overflow checking.\r\n */\r\n\r\nlibrary SafeMath {\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { if (b == 1) return ~uint120(0);\r\n        require(b \u003c= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) {\r\n        return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b \u003e 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n}"}}