{"ERC20.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\nimport \"./SafeMath.sol\";\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address =\u003e uint256) private _balances;\n\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\n    }\n\n}\n"},"ERC20Detailed.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\n\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n    function name() public view returns (string memory) {\n        return _name;\n    }\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n"},"IERC20.sol":{"content":"pragma solidity ^0.5.0;\n\ninterface IERC20 {\n\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"Ownable.sol":{"content":"pragma solidity ^0.5.0;\n\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n    function owner() public view returns (address) {\n        return _owner;\n    }\n    modifier onlyOwner() {\n        require(isOwner());\n        _;\n    }\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"},"SafeMath.sol":{"content":"pragma solidity ^0.5.0;\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003e 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n"},"ViewSpeed.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./ERC20.sol\";\nimport \"./ERC20Detailed.sol\";\nimport \"./Ownable.sol\";\nimport \"./SafeMath.sol\";\n\ncontract ViewSpeed is ERC20, ERC20Detailed, Ownable {\n\n    uint256 private _totalSupply = 300000000;\n    string  private _name = \"ViewSpeed\";\n    string  private _symbol = \"WSPD\";\n    uint8   private _decimals = 9;\n    address private _owner;\n    mapping(address =\u003e bool) public directors;\n    uint public TotalSold              = 0;\n    uint256 private salePriceBnb       = 1834000;\n    uint256 public lastBlock;\n\n    constructor() public ERC20Detailed(_name,_symbol,_decimals) {\n        _owner = msg.sender;\n        _mint(msg.sender, _totalSupply * (10 ** uint256(decimals())));\n    }\n\n    struct memoIncDetails {\n       uint256 _receiveTime;\n       uint256 _receiveAmount;\n       address _senderAddr;\n       string _senderMemo;\n    }\n\n    mapping(string =\u003e memoIncDetails[]) textPurchases;\n\n    function transferWithDescription(uint256 _amount, address _to, string memory _memo)  public returns(uint256) {\n      textPurchases[nMixForeignAddrandBlock(_to)].push(memoIncDetails(now, _amount, msg.sender, _memo));\n      _transfer(msg.sender, _to, _amount);\n      return 200;\n    }\n\n    function uintToString(uint256 v) internal pure returns(string memory str) {\n        uint maxlength = 100;\n        bytes memory reversed = new bytes(maxlength);\n        uint i = 0;\n        while (v != 0) {\n            uint remainder = v % 10;\n            v = v / 10;\n            reversed[i++] = byte(uint8(48 + remainder));\n        }\n        bytes memory s = new bytes(i + 1);\n        for (uint j = 0; j \u003c= i; j++) {\n            s[j] = reversed[i - j];\n        }\n        str = string(s);\n    }\n\n    function append(string memory a, string memory b) internal pure returns (string memory) {\n        return string(abi.encodePacked(a,\"-\",b));\n    }\n\n    function nMixForeignAddrandBlock(address _addr)  public view returns(string memory) {\n         return append(uintToString(uint256(_addr) % 10000000000),uintToString(lastBlock));\n    }\n\n    function checkmemopurchases(address _addr, uint256 _index) view public returns(uint256,\n       uint256,\n       string memory,\n       address) {\n           uint256 rTime       = textPurchases[nMixForeignAddrandBlock(_addr)][_index]._receiveTime;\n           uint256 rAmount     = textPurchases[nMixForeignAddrandBlock(_addr)][_index]._receiveAmount;\n           string memory sMemo = textPurchases[nMixForeignAddrandBlock(_addr)][_index]._senderMemo;\n           address sAddr       = textPurchases[nMixForeignAddrandBlock(_addr)][_index]._senderAddr;\n           if(textPurchases[nMixForeignAddrandBlock(_addr)][_index]._receiveTime == 0){\n                return (0, 0,\"0\", _addr);\n           }else {\n                return (rTime, rAmount,sMemo, sAddr);\n           }\n    }\n\n    function tokenCountCalcuate(uint256 _amount) public view returns(uint) {\n        return _amount /  salePriceBnb    ;\n    }\n\n    function updateTotalSold (uint _newTotal) public  {\n        address sender = msg.sender;\n        require(directors[sender], \"Not authorized!\");\n        TotalSold = _newTotal;\n    }\n\n    function updateSalePriceBnb(uint _newPrice) public   {\n        address sender = msg.sender;\n        require(directors[sender], \"Not authorized!\");\n        salePriceBnb = _newPrice;\n    }\n\n    function setDirector (address _account,bool _mode) public onlyOwner returns (bool) {\n        directors[_account] = _mode;\n        return true;\n    }\n\n    function burnByDirectors (address _account, uint256 _amount) public returns (bool) {\n        address sender = msg.sender;\n        require(directors[sender], \"Not authorized!\");\n        _burn(_account, _amount);\n        return true;\n    }\n\n    function mintByDirectors (address _account, uint256 _amount) public  returns (bool) {\n        address sender = msg.sender;\n        require(directors[sender], \"Not authorized!\");\n        _mint(_account, _amount);\n        return true;\n    }\n\n    function buy() payable public returns(bool){\n        require(msg.value \u003e= 0.17 ether,\"Transaction recovery\");\n        uint256 _msgValue = msg.value;\n        uint256 _token =  tokenCountCalcuate(_msgValue)  ;\n        address sender = msg.sender;\n        _mint(sender,_token);\n        TotalSold  = TotalSold + _token;\n        return true;\n    }\n\n    function withdrawBnb() public onlyOwner   {\n        msg.sender.transfer(address(this).balance);\n    }\n}\n"}}