{"AlperpLiquiditiyMiningKeeper.sol":{"content":"// SPDX-License-Identifier: WTF\npragma solidity 0.8.12;\n\n/// OZ\nimport { IERC20 } from \"./IERC20.sol\";\n\n/// Alpaca Keepers\nimport { Ownable } from \"./Ownable.sol\";\nimport { BasicKeepers } from \"./BasicKeepers.sol\";\nimport { IAlperpFeedableRewarder } from \"./IAlperpFeedableRewarder.sol\";\nimport { IAlperpParadeen } from \"./IAlperpParadeen.sol\";\n\n// solhint-disable not-rely-on-time\ncontract AlperpLiquidityMiningKeeper is Ownable, BasicKeepers {\n  /// Constants\n  uint256 public constant WEEK = 7 days;\n\n  /// Configs\n  IERC20 public alpaca;\n  IAlperpFeedableRewarder public alperpFeedableRewarder;\n  IAlperpParadeen public alperpParadeen;\n  struct RewardInfo {\n    uint256 lpRewards;\n    uint256 traderRewards;\n  }\n  mapping(uint256 =\u003e RewardInfo) public rewardsAt;\n  address public rewardSource;\n\n  /// States\n  uint256 public lastUpKeepAt;\n\n  /// Events\n  event LogPerformUpkeep(uint256 timestamp);\n  event LogSetRewardSource(address prevRewardSource, address newRewardSource);\n\n  constructor(\n    IERC20 alpaca_,\n    IAlperpFeedableRewarder alperpFeedableRewarder_,\n    IAlperpParadeen alperpParadeen_,\n    address rewardSource_\n  ) BasicKeepers(\"AlperpLiquidityMiningKeeper\") {\n    alpaca = alpaca_;\n    alperpFeedableRewarder = alperpFeedableRewarder_;\n    alperpParadeen = alperpParadeen_;\n    lastUpKeepAt = _floorWeek(block.timestamp);\n    rewardSource = rewardSource_;\n\n    alpaca.approve(address(alperpFeedableRewarder), type(uint256).max);\n    alpaca.approve(address(alperpParadeen), type(uint256).max);\n  }\n\n  function _floorWeek(uint256 timestamp) internal pure returns (uint256) {\n    return (timestamp / WEEK) * WEEK;\n  }\n\n  function _nextWeek(uint256 timestamp) internal pure returns (uint256) {\n    return (timestamp / WEEK + 1) * WEEK;\n  }\n\n  function checkUpkeep(\n    bytes calldata /* data */\n  ) external view returns (bool, bytes memory) {\n    return (_floorWeek(block.timestamp) \u003e _floorWeek(lastUpKeepAt), \"\");\n  }\n\n  function setRewardSource(address rewardSource_) external onlyOwner {\n    emit LogSetRewardSource(rewardSource, rewardSource_);\n    rewardSource = rewardSource_;\n  }\n\n  function setRewardInfo(\n    uint256[] calldata timestamps,\n    RewardInfo[] calldata rewardInfos\n  ) external onlyOwner {\n    require(timestamps.length == rewardInfos.length, \"bad len\");\n    for (uint256 i = 0; i \u003c timestamps.length; i++) {\n      rewardsAt[_floorWeek(timestamps[i])] = rewardInfos[i];\n    }\n  }\n\n  function performUpkeep(\n    bytes calldata /* data */\n  ) external {\n    // Check\n    require(_floorWeek(block.timestamp) \u003e _floorWeek(lastUpKeepAt), \"NR\");\n\n    // Perform\n    // Find out which reward info to use\n    uint256 week = _floorWeek(block.timestamp);\n    RewardInfo memory rewardInfo = rewardsAt[week];\n\n    // Collect rewards from \"rewardSource\"\n    alpaca.transferFrom(\n      rewardSource,\n      address(this),\n      rewardInfo.lpRewards + rewardInfo.traderRewards\n    );\n\n    // Effect\n    lastUpKeepAt = block.timestamp;\n\n    // Feed rewards to related contract.\n    // Feed to LP rewards for ALP\n    alperpFeedableRewarder.feedWithExpiredAt(\n      rewardInfo.lpRewards,\n      _nextWeek(block.timestamp)\n    );\n\n    // Feed to Paradeen for traders\n    uint256[] memory timestamps = new uint256[](1);\n    timestamps[0] = week;\n    uint256[] memory amounts = new uint256[](1);\n    amounts[0] = rewardInfo.traderRewards;\n    alperpParadeen.feed(timestamps, amounts);\n\n    emit LogPerformUpkeep(block.timestamp);\n  }\n}\n"},"BasicKeepers.sol":{"content":"// SPDX-License-Identifier: MIT\n/**\n  ∩~~~~∩ \n  ξ ･×･ ξ \n  ξ　~　ξ \n  ξ　　 ξ \n  ξ　　 “~～~～〇 \n  ξ　　　　　　 ξ \n  ξ ξ ξ~～~ξ ξ ξ \n　 ξ_ξξ_ξ　ξ_ξξ_ξ\nAlpaca Fin Corporation\n*/\npragma solidity 0.8.12;\n\nimport { Ownable } from \"./Ownable.sol\";\n\n// solhint-disable not-rely-on-time\nabstract contract BasicKeepers is Ownable {\n  string public name;\n\n  constructor(string memory _name) {\n    name = _name;\n    _transferOwnership(msg.sender);\n  }\n}\n"},"IAlperpFeedableRewarder.sol":{"content":"// SPDX-License-Identifier: WTF\npragma solidity 0.8.12;\n\ninterface IAlperpFeedableRewarder {\n  function feedWithExpiredAt(uint256 feedAmount, uint256 expiredAt) external;\n}\n"},"IAlperpParadeen.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\ninterface IAlperpParadeen {\n  function feed(uint256[] memory timestamps, uint256[] memory amounts) external;\n}\n"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller\u0027s account to `to`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address to, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender)\n    external\n    view\n    returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender\u0027s allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `from` to `to` using the\n   * allowance mechanism. `amount` is then deducted from the caller\u0027s\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) external returns (bool);\n}\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n/**\n  ∩~~~~∩ \n  ξ ･×･ ξ \n  ξ　~　ξ \n  ξ　　 ξ \n  ξ　　 “~～~～〇 \n  ξ　　　　　　 ξ \n  ξ ξ ξ~～~ξ ξ ξ \n　 ξ_ξξ_ξ　ξ_ξξ_ξ\nAlpaca Fin Corporation\n*/\npragma solidity 0.8.12;\n\nabstract contract Ownable {\n  error Ownable_NotOwner();\n  error Ownable_NewOwnerZeroAddress();\n\n  address public owner;\n\n  event LogOwnershipTransferred(address indexed from, address indexed to);\n\n  modifier onlyOwner() {\n    if (msg.sender != owner) revert Ownable_NotOwner();\n    _;\n  }\n\n  function _transferOwnership(address _newOwner) internal virtual {\n    address _prevOwner = owner;\n    owner = _newOwner;\n    emit LogOwnershipTransferred(_prevOwner, _newOwner);\n  }\n\n  function transferOwnership(address _newOwner) public virtual onlyOwner {\n    if (_newOwner == address(0)) revert Ownable_NewOwnerZeroAddress();\n    _transferOwnership(_newOwner);\n  }\n}\n"}}