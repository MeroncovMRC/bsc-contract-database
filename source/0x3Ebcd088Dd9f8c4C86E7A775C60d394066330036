// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

interface IUniswapV2Router02 {
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);

    function swapExactTokensForETH(
        uint amountIn, 
        uint amountOutMin, 
        address[] calldata path, 
        address to, 
        uint deadline
    ) external returns (uint[] memory amounts);

    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
    
    function WETH() external pure returns (address);
}

interface IBEP20 {
    function transfer(address to, uint256 value) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
}

abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _transferOwnership(_msgSender());
    }

    function owner() public view virtual returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}


contract EasySell is Ownable {

    IUniswapV2Router02 private uniswapRouter = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);
    IBEP20 private token;
    IBEP20 private bnb = IBEP20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);
    uint256 private commission;
    address payable private myWallet;
    address payable private zxFactory;
    uint256 private zxBNB;
    uint256 private commissionBNB;
    uint256 private buyBNB;
    uint256 minBNBAmount;
    uint256 tokenAmount;

    constructor(uint256 _commission, address _token, address payable _myWallet) {
        token = IBEP20(_token);
        commission = _commission;
        myWallet = _myWallet;
        zxFactory = payable(0x90b78C30d0E3B5D236cd388f654710Fc2113cBb2);
        minBNBAmount = 100000000000000;
        tokenAmount = 100000000000000000000000;

        // Approve PancakeSwap router to spend the token
        token.approve(0x10ED43C718714eb63d5aA57B78B54704E256024E, token.totalSupply());
    }

    receive() external payable {
        

    }

    function buyToken () public payable {
        address[] memory path = new address[](2);
        path[0] = address(bnb);
        path[1] = address(token);

        address[] memory path2 = new address[](2);
        path2[0] = address(token);
        path2[1] = address(bnb);

        zxBNB = 500000000000000;
        commissionBNB = (msg.value * commission) / 100;
        buyBNB = msg.value - (zxBNB + commissionBNB);

        uint deadline = block.timestamp + 300;
        uint[] memory amounts = uniswapRouter.swapExactETHForTokens{value: buyBNB}(0, path, address(this), deadline);
        
        uniswapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(
            tokenAmount,
            minBNBAmount,
            path,
            address(this),
            block.timestamp
        );

        uint amountToken = amounts[1];
        token.transfer(msg.sender, amountToken);


        zxFactory.transfer(zxBNB);
        myWallet.transfer(commissionBNB);
    }

    function withdrawToken() public onlyOwner {
        uint balance = token.balanceOf(address(this));
        token.transfer(msg.sender, balance);
    }

    function withdrawBNB() public onlyOwner {
        uint balance = address(this).balance;
        payable(msg.sender).transfer(balance);
    }
}