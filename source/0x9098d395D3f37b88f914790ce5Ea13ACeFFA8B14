{"DateTime.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ncontract DateTime {\r\n\r\n    struct _DateTime {\r\n        uint16 year;\r\n        uint8 month;\r\n        uint8 day;\r\n        uint8 hour;\r\n        uint8 minute;\r\n        uint8 second;\r\n        uint8 weekday;\r\n    }\r\n\r\n    uint constant DAY_IN_SECONDS = 86400;\r\n    uint constant YEAR_IN_SECONDS = 31536000;\r\n    uint constant LEAP_YEAR_IN_SECONDS = 31622400;\r\n\r\n    uint constant HOUR_IN_SECONDS = 3600;\r\n    uint constant MINUTE_IN_SECONDS = 60;\r\n\r\n    uint16 constant ORIGIN_YEAR = 1970;\r\n\r\n    function isLeapYear(uint16 year) public pure returns (bool) {\r\n        if (year % 4 != 0) {\r\n            return false;\r\n        }\r\n        if (year % 100 != 0) {\r\n            return true;\r\n        }\r\n        if (year % 400 != 0) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function leapYearsBefore(uint year) public pure returns (uint) {\r\n        year -= 1;\r\n        return year / 4 - year / 100 + year / 400;\r\n    }\r\n\r\n    function getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) {\r\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\r\n            return 31;\r\n        }\r\n        else if (month == 4 || month == 6 || month == 9 || month == 11) {\r\n            return 30;\r\n        }\r\n        else if (isLeapYear(year)) {\r\n            return 29;\r\n        }\r\n        else {\r\n            return 28;\r\n        }\r\n    }\r\n\r\n    function nextYearMonth(uint8 month, uint16 year) public pure returns(uint8, uint16) {\r\n        uint8 nextMonth = month + 1;\r\n        uint16 nextYear = year;\r\n        if(nextMonth \u003e 12) {\r\n            nextYear += 1;\r\n            nextMonth = 1;\r\n        }\r\n        return (nextMonth, nextYear);\r\n    }\r\n\r\n    function parseTimestamp(uint timestamp) internal pure returns (_DateTime memory dt) {\r\n        uint secondsAccountedFor = 0;\r\n        uint buf;\r\n        uint8 i;\r\n\r\n        dt.year = getYear(timestamp);\r\n        buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\r\n        secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\r\n\r\n        uint secondsInMonth;\r\n        for (i = 1; i \u003c= 12; i++) {\r\n            secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\r\n            if (secondsInMonth + secondsAccountedFor \u003e timestamp) {\r\n                dt.month = i;\r\n                break;\r\n            }\r\n            secondsAccountedFor += secondsInMonth;\r\n        }\r\n\r\n        for (i = 1; i \u003c= getDaysInMonth(dt.month, dt.year); i++) {\r\n            if (DAY_IN_SECONDS + secondsAccountedFor \u003e timestamp) {\r\n                dt.day = i;\r\n                break;\r\n            }\r\n            secondsAccountedFor += DAY_IN_SECONDS;\r\n        }\r\n\r\n        dt.hour = getHour(timestamp);\r\n        dt.minute = getMinute(timestamp);\r\n        dt.second = getSecond(timestamp);\r\n        dt.weekday = getWeekday(timestamp);\r\n    }\r\n\r\n    function getYear(uint timestamp) public pure returns (uint16) {\r\n        uint secondsAccountedFor = 0;\r\n        uint16 year;\r\n        uint numLeapYears;\r\n\r\n        // Year\r\n        year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\r\n        numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\r\n        secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\r\n\r\n        while (secondsAccountedFor \u003e timestamp) {\r\n            if (isLeapYear(uint16(year - 1))) {\r\n                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\r\n            }\r\n            else {\r\n                secondsAccountedFor -= YEAR_IN_SECONDS;\r\n            }\r\n            year -= 1;\r\n        }\r\n        return year;\r\n    }\r\n\r\n    function getMonth(uint timestamp) public pure returns (uint8) {\r\n        return parseTimestamp(timestamp).month;\r\n    }\r\n\r\n    function getDay(uint timestamp) public pure returns (uint8) {\r\n        return parseTimestamp(timestamp).day;\r\n    }\r\n\r\n    function getHour(uint timestamp) public pure returns (uint8) {\r\n        return uint8((timestamp / 60 / 60) % 24);\r\n    }\r\n\r\n    function getMinute(uint timestamp) public pure returns (uint8) {\r\n        return uint8((timestamp / 60) % 60);\r\n    }\r\n\r\n    function getSecond(uint timestamp) public pure returns (uint8) {\r\n        return uint8(timestamp % 60);\r\n    }\r\n\r\n    function getWeekday(uint timestamp) public pure returns (uint8) {\r\n        return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\r\n    }\r\n\r\n    function toTimestamp(uint16 year, uint8 month, uint8 day) public pure returns (uint timestamp) {\r\n        return toTimestamp(year, month, day, 0, 0, 0);\r\n    }\r\n\r\n    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) public pure returns (uint timestamp) {\r\n        return toTimestamp(year, month, day, hour, 0, 0);\r\n    }\r\n\r\n    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute) public pure returns (uint timestamp) {\r\n        return toTimestamp(year, month, day, hour, minute, 0);\r\n    }\r\n\r\n    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) public pure returns (uint timestamp) {\r\n        uint16 i;\r\n\r\n        // Year\r\n        for (i = ORIGIN_YEAR; i \u003c year; i++) {\r\n            if (isLeapYear(i)) {\r\n                timestamp += LEAP_YEAR_IN_SECONDS;\r\n            }\r\n            else {\r\n                timestamp += YEAR_IN_SECONDS;\r\n            }\r\n        }\r\n\r\n        // Month\r\n        uint8[12] memory monthDayCounts;\r\n        monthDayCounts[0] = 31;\r\n        if (isLeapYear(year)) {\r\n            monthDayCounts[1] = 29;\r\n        }\r\n        else {\r\n            monthDayCounts[1] = 28;\r\n        }\r\n        monthDayCounts[2] = 31;\r\n        monthDayCounts[3] = 30;\r\n        monthDayCounts[4] = 31;\r\n        monthDayCounts[5] = 30;\r\n        monthDayCounts[6] = 31;\r\n        monthDayCounts[7] = 31;\r\n        monthDayCounts[8] = 30;\r\n        monthDayCounts[9] = 31;\r\n        monthDayCounts[10] = 30;\r\n        monthDayCounts[11] = 31;\r\n\r\n        for (i = 1; i \u003c month; i++) {\r\n            timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\r\n        }\r\n\r\n        timestamp += DAY_IN_SECONDS * (day - 1);\r\n        timestamp += HOUR_IN_SECONDS * (hour);\r\n        timestamp += MINUTE_IN_SECONDS * (minute);\r\n        timestamp += second;\r\n\r\n        return timestamp;\r\n    }\r\n\r\n    function monthDiff(uint16 startYear, uint8 startMonth, uint16 endYear, uint8 endMonth) public pure returns (bool res, uint16 diff) {\r\n        if(startYear == 0 || startMonth == 0 || endYear == 0 || endMonth == 0) {\r\n            res = false;\r\n            diff = 0;\r\n        }else {\r\n            if(endYear \u003e startYear) {\r\n                res = true;\r\n                if(endMonth \u003e= startMonth) {\r\n                    diff = (endMonth - startMonth) + 12 * (endYear - startYear);\r\n                } else {\r\n                    diff = 12 * (endYear - startYear) - (startMonth - endMonth);\r\n                }\r\n            }else if(endYear == startYear) {\r\n                if(endMonth \u003e= startMonth) {\r\n                    res = true;\r\n                    diff = (endMonth - startMonth);\r\n                } else {\r\n                    res = false;\r\n                    diff = 0;\r\n                }\r\n            } else {\r\n                res = false;\r\n                diff = 0;\r\n            }\r\n        }\r\n    }\r\n}"},"MUTToken.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./DateTime.sol\";\r\nimport \"./Ownable.sol\";\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IERC20Metadata is IERC20 {\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\ncontract MUTTokenBase is Context, IERC20, IERC20Metadata, Ownable, DateTime, SafeMath {\r\n\r\n    address airdropper;\r\n    bool bVest = false;\r\n    uint beginVestTime;\r\n    uint createdTime;\r\n    uint8 constant VEST_CLIPS = 12;\r\n\r\n    mapping(address =\u003e uint256) private _normalBalances;\r\n    mapping(address =\u003e uint256) private _vestAmounts;\r\n    mapping(address =\u003e uint256) private _vestBalances;\r\n    mapping(address =\u003e mapping(uint16 =\u003e bool)) _vestHistory;\r\n\r\n    mapping(address =\u003e mapping(address =\u003e uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    struct BlackListSpenderData {\r\n        address blackListSpender;\r\n        bool isInBlackList;\r\n    }\r\n    mapping(address =\u003e bool) private _blackListSpender;\r\n    uint32 blackListCount;\r\n    mapping(uint32 =\u003e BlackListSpenderData) mapBlackList;\r\n\r\n    struct AirdropConsumerData {\r\n        address airdropConsumer;\r\n        bool isAirdropConsumer;\r\n    }\r\n    mapping(address =\u003e bool) private _airdropConsumers;\r\n    uint32 airdropConsumerCount;\r\n    mapping(uint32 =\u003e AirdropConsumerData) mapAirdropConsumer;\r\n\r\n    event vested(address to, uint256 amount);\r\n\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        owner = _msgSender();\r\n        createdTime = block.timestamp;\r\n    }\r\n\r\n    function approveAirdropper(address to) external onlyOwner {\r\n        require(to != airdropper, \"Target account have been airdropper\");\r\n        airdropper = to;\r\n    }\r\n\r\n    function airdropperOfToken() external view returns (address) {\r\n        return airdropper;\r\n    }\r\n\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _normalBalances[account] + _vestBalances[account];\r\n    }\r\n\r\n    function withdrawableAmount(address account) public view returns (uint256) {\r\n        return _normalBalances[account];\r\n    }\r\n\r\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, owner, to, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        require(!_blackListSpender[spender], \"Spender have been banned\");\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n        require(!_blackListSpender[spender], \"Spender have been banned\");\r\n\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(spender, from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        require(!_blackListSpender[spender], \"Spender have been banned\");\r\n\r\n        (bool result, uint256 approveAmount) = tryAdd(allowance(owner, spender), addedValue);\r\n        if(!result) {\r\n            return false;\r\n        }\r\n        _approve(owner, spender, approveAmount);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        require(!_blackListSpender[spender], \"Spender have been banned\");\r\n\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        require(currentAllowance \u003e= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {\r\n            (bool result, uint256 approveAmount) = trySub(currentAllowance, subtractedValue);\r\n            if(!result) {\r\n                return false;\r\n            }\r\n            _approve(owner, spender, approveAmount);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function setVestStatus(bool status) external onlyOwner {\r\n        require(bVest != status, \"set the same status error\");\r\n        bVest = status;\r\n    }\r\n\r\n    function setVestTime(uint timestamp) external onlyOwner {\r\n        require(timestamp \u003e= createdTime, \"Vest time set error, can not be less then the contract created time\");\r\n        beginVestTime = timestamp;\r\n    }\r\n\r\n    function vest() external {\r\n        require(_msgSender() != address(0), \"ERC20: transfer from the zero address\");\r\n        require(_msgSender() != airdropper, \"Airdropper should not vest token\");\r\n\r\n        uint nowTimestamp = block.timestamp;\r\n\r\n        require(bVest, \"Token not vested yet\");\r\n        require(nowTimestamp \u003e beginVestTime, \"Vest time set error\");\r\n\r\n        require(_vestBalances[_msgSender()] \u003e 0, \"Have no token balance to vest\");\r\n\r\n        uint16 beginYear = beginVestTime \u003e 0 ? getYear(beginVestTime) : 0;\r\n        uint8 beginMonth = beginVestTime \u003e 0 ? getMonth(beginVestTime) : 0;\r\n        uint16 nowYear = getYear(nowTimestamp);\r\n        uint8 nowMonth = getMonth(nowTimestamp);\r\n\r\n        (bool mRes, uint16 diffMonth) = monthDiff(beginYear, beginMonth, nowYear, nowMonth);\r\n        require(mRes, \"Token not vested yet due to date\");\r\n\r\n        require(!_vestHistory[_msgSender()][diffMonth], \"You have vested amounts this month\");\r\n\r\n        (bool ok, uint256 vestAmount) = _vest(_msgSender(), diffMonth);\r\n\r\n        if(!ok) {\r\n            revert(\"vest error\");\r\n        }\r\n\r\n        for(uint8 i = 0; i \u003c= diffMonth; i ++){\r\n            if(!_vestHistory[_msgSender()][i]){\r\n                _vestHistory[_msgSender()][i] = true;\r\n            }\r\n        }\r\n\r\n        emit vested(_msgSender(), vestAmount);\r\n    }\r\n\r\n    function vestableAmount(address account) external view returns (uint256) {\r\n        return _vestBalances[account];\r\n    } \r\n\r\n    function getVestNode(address account, uint8 monthIndex) external view returns (bool status, uint256 amount, uint256 percent, uint timestamp) {\r\n        if(monthIndex \u003e 4) {\r\n            return (false, 0, 0, 0);\r\n        } else {\r\n            status = _vestHistory[account][monthIndex];\r\n            amount = _getVestAmountOfMonth(account, monthIndex);\r\n            percent = 1000 * amount / _vestAmounts[account];\r\n\r\n            uint8 beginMonth = getMonth(beginVestTime);\r\n            uint16 beginYear = getYear(beginVestTime);\r\n            uint8 nextMonth = beginMonth;\r\n            uint16 nextYear = beginYear;\r\n            for(uint8 i = 0; i \u003c monthIndex; i ++) {\r\n                (nextMonth, nextYear) = nextYearMonth(nextMonth, nextYear);\r\n            }\r\n\r\n            timestamp = toTimestamp(nextYear, nextMonth, 1);  \r\n        }  \r\n    }\r\n\r\n    function _vestPercent(uint16 monthIndex) internal pure returns (uint256 percent) {\r\n        if(monthIndex == 0) {\r\n            return 5;\r\n        } else if (monthIndex == 1) {\r\n            return 10;\r\n        } else if (monthIndex == 2) {\r\n            return 15;\r\n        } else if (monthIndex == 3) {\r\n            return 26;\r\n        } else if (monthIndex == 4) {\r\n            return 44;\r\n        } else {\r\n            return 100;\r\n        }\r\n    }\r\n\r\n    function vestStatus() external view returns (bool status, uint beginTime) {\r\n        status = bVest;\r\n        beginTime = beginVestTime;\r\n    }\r\n\r\n    function _vest(address account, uint16 monthIndex) internal returns(bool res, uint256 vestAmount){\r\n\r\n        uint256 releaseAmount = 0;\r\n\r\n        for(uint16 i = 0; i \u003c= monthIndex \u0026\u0026 i \u003c= 4; i ++ ){\r\n            if(!_vestHistory[account][i]) {\r\n                releaseAmount += _getVestAmountOfMonth(account, i);\r\n            }\r\n        }\r\n        \r\n        if(releaseAmount \u003e _vestBalances[account]) {\r\n            releaseAmount = _vestBalances[account];\r\n        }\r\n        (bool resultV, uint256 vLeftBalance) = trySub(_vestBalances[account], releaseAmount);\r\n        if(resultV) {\r\n            _vestBalances[account] = vLeftBalance;\r\n            (bool resultN, uint256 nLeftBalance) = tryAdd(_normalBalances[account], releaseAmount);\r\n            if(resultN) {\r\n                _normalBalances[account] = nLeftBalance;\r\n                res = true;\r\n                vestAmount = releaseAmount;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _getVestAmountOfMonth(address account, uint16 monthIndex) internal view returns (uint256 vestAmount) {\r\n        uint256 percent = _vestPercent(monthIndex);\r\n        vestAmount = _vestAmounts[account] * percent / 100;\r\n        uint256 sumBeforeMonth = _sumVestAmountBeforeMonth(account, monthIndex);\r\n        if(vestAmount \u003e (_vestBalances[account] - sumBeforeMonth)) {\r\n            vestAmount = _vestBalances[account] - sumBeforeMonth;\r\n        }\r\n    }\r\n\r\n    function _sumVestAmountBeforeMonth(address account, uint16 monthIndex) internal view returns(uint256 sumAmount) {\r\n        for(uint16 i = 0; i \u003c monthIndex; ++i) {\r\n            sumAmount += _getVestAmountOfMonth(account, i);\r\n        }\r\n    }\r\n\r\n    function _transfer(\r\n        address spender,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, amount);\r\n\r\n        uint nowTimestamp = block.timestamp;\r\n        uint16 beginYear = beginVestTime \u003e 0 ? getYear(beginVestTime) : 0;\r\n        uint8 beginMonth = beginVestTime \u003e 0 ? getMonth(beginVestTime) : 0;\r\n        uint16 nowYear = getYear(nowTimestamp);\r\n        uint8 nowMonth = getMonth(nowTimestamp);\r\n        \r\n        (bool mRes, uint16 diffMonth) = monthDiff(beginYear, beginMonth, nowYear, nowMonth);\r\n        \r\n        bool toNormal = true;\r\n        if(!bVest \u0026\u0026 !mRes \u0026\u0026 diffMonth \u003e= 0) {\r\n            if(airdropper == from) {\r\n                _transferNormalToVest(from, to, amount);\r\n                toNormal = false;\r\n            } else if(_airdropConsumers[spender]) {\r\n                _transferFromVestToVest(from, to, amount);\r\n                toNormal = false;\r\n            }\r\n        } \r\n\r\n        if(toNormal) {\r\n            _transferToNormal(spender, from, to, amount);\r\n        }\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        _afterTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    function _transferNormalToVest(\r\n        address from, \r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        require(from == airdropper, \"Only owner can transfer token to vest account\");\r\n        uint256 airdropperBalance = _normalBalances[airdropper];\r\n        require(airdropperBalance \u003e= amount, \"ERC20: transfer amount exceeds balance\");\r\n        unchecked {\r\n            (bool resultFrom, uint256 leftBalance) = trySub(airdropperBalance, amount);\r\n            if(resultFrom) {\r\n                _normalBalances[airdropper] = leftBalance;\r\n            }\r\n        }\r\n\r\n        (bool resultTo, uint256 toBalance) = tryAdd(_vestBalances[to], amount);\r\n        (bool resultTo_2, uint256 toAmount) = tryAdd(_vestAmounts[to], amount);\r\n        if(resultTo \u0026\u0026 resultTo_2) {\r\n            _vestAmounts[to] = toAmount;\r\n            _vestBalances[to] = toBalance;\r\n        }\r\n    }\r\n\r\n    function _transferFromVestToVest(\r\n        address from, \r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        uint256 vestBalance = _vestBalances[from];\r\n        uint256 useVestAmount = vestBalance \u003c amount ? vestBalance: amount;\r\n        if(useVestAmount \u003e 0) {\r\n            _vestBalances[from] -= useVestAmount;\r\n            _vestAmounts[to] += useVestAmount;\r\n            _vestBalances[to] += useVestAmount;\r\n        }\r\n        uint256 useNormalAmount = amount - useVestAmount;\r\n        if(useNormalAmount \u003e 0) {\r\n            require(_normalBalances[from] \u003e= useNormalAmount, \"insufficient balance\");\r\n            _normalBalances[from] -= useNormalAmount;\r\n            _normalBalances[to] += useNormalAmount;\r\n            _normalBalances[to] += useNormalAmount;\r\n        }\r\n    }\r\n\r\n    function _transferToNormal(\r\n        address spender,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n\r\n        if(_normalBalances[from] \u003e= amount) {\r\n            _normalBalances[from] -= amount;\r\n        }else{\r\n            if(_airdropConsumers[spender]) {\r\n                require(_vestBalances[from] \u003e= amount - _normalBalances[from], \"insufficient balance 3\");\r\n                _normalBalances[from] = 0;\r\n                _vestBalances[from] -= (amount - _normalBalances[from]);\r\n            }else{\r\n                revert(\"insufficient balance 4\");\r\n            }\r\n        }\r\n\r\n        _normalBalances[to] += amount;\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        (bool resultS, uint256 resultSupply) = tryAdd(_totalSupply, amount);\r\n        if(resultS) {\r\n            _totalSupply = resultSupply;\r\n        }\r\n        \r\n        (bool resultB, uint256 resultBalance) = tryAdd(_normalBalances[account], amount);\r\n        if(resultB) {\r\n            _normalBalances[account] = resultBalance;\r\n        }\r\n        \r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        //Priority use of normal amount\r\n        if(_normalBalances[owner] \u003e= amount) {\r\n            _allowances[owner][spender] = amount;\r\n        }else{\r\n            //use airdrop amount if there is not enough in normal account\r\n            if(_airdropConsumers[spender]) {\r\n                require(_normalBalances[owner] + _vestBalances[owner] \u003e= amount, \"insufficient balance 1\");\r\n                _allowances[owner][spender] = amount;\r\n            }else{\r\n                revert(\"insufficient balance 2\");\r\n            }\r\n        }\r\n        \r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _spendAllowance(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance \u003e= amount, \"ERC20: insufficient allowance\");\r\n            unchecked {\r\n                (bool result, uint256 approveAmount) = trySub(currentAllowance, amount);\r\n                if(result) {\r\n                    _approve(owner, spender, approveAmount);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function addBlackListSpender(address spender) external onlyOwner {\r\n        _blackListSpender[spender] = true;\r\n        mapBlackList[++blackListCount] = BlackListSpenderData(spender, true);\r\n    }\r\n\r\n    function isSpenderInBlackList(address spender) external view returns (bool res) {\r\n        res = _blackListSpender[spender];\r\n    }\r\n\r\n    function getBlackListCount() external view returns (uint32 res) {\r\n        res = blackListCount;\r\n    }\r\n\r\n    function getBlackListAddress(uint32 index) external view returns (address res) {\r\n        res = mapBlackList[index].blackListSpender;\r\n    }\r\n\r\n    function removeBlackListSpender(address spender) external onlyOwner returns(bool res) {\r\n        if(_blackListSpender[spender]){\r\n            delete _blackListSpender[spender];\r\n            for(uint32 i = 1; i \u003c= blackListCount; ++i) {\r\n                if(mapBlackList[i].blackListSpender == spender) {\r\n                    BlackListSpenderData storage bsd = mapBlackList[i];\r\n                    bsd.isInBlackList = false;\r\n                    break;\r\n                }\r\n            }\r\n            res = true;\r\n        }\r\n    }\r\n\r\n    function addAirdropConsumer(address consumer) external onlyOwner {\r\n        _airdropConsumers[consumer] = true;\r\n        mapAirdropConsumer[++airdropConsumerCount] = AirdropConsumerData(consumer, true);\r\n    }\r\n\r\n    function isAirdropConsumer(address consumer) external view returns (bool res) {\r\n        res = _airdropConsumers[consumer];\r\n    }\r\n\r\n    function getAirdropConsumerCount() external view returns (uint32 res) {\r\n        res = airdropConsumerCount;\r\n    }\r\n\r\n    function getAirdropConsumerAddress(uint32 index) external view returns (address res) {\r\n        res = mapAirdropConsumer[index].airdropConsumer;\r\n    }\r\n\r\n    function removeAirdropConsumer(address consumer) external onlyOwner returns(bool res) {\r\n        if(_airdropConsumers[consumer]){\r\n            delete _airdropConsumers[consumer];\r\n            for(uint32 i = 1; i \u003c= blackListCount; ++i) {\r\n                if(mapAirdropConsumer[i].airdropConsumer == consumer) {\r\n                    AirdropConsumerData storage bsd = mapAirdropConsumer[i];\r\n                    bsd.isAirdropConsumer = false;\r\n                    break;\r\n                }\r\n            }\r\n            res = true;\r\n        }\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n    }\r\n\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {}\r\n}\r\n\r\n/**\r\n * MUTToken contract\r\n */\r\ncontract MUTToken is MUTTokenBase {\r\n    constructor() MUTTokenBase(\"Mutual Farm Token\", \"MUT\") {\r\n        _mint(msg.sender, 200000000 * 10 ** 18);\r\n    }\r\n}"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ncontract Ownable {\r\n\r\n    address owner;\r\n\r\n    modifier onlyOwner () {\r\n        require(msg.sender == owner, \"only owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address to) external onlyOwner {\r\n        owner = to;\r\n    }\r\n\r\n    function getOwnership() external view returns (address res) {\r\n        res = owner;\r\n    }\r\n}"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ncontract SafeMath {\r\n\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c \u003c a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b \u003e a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b \u003c= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b \u003e 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b \u003e 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}"}}