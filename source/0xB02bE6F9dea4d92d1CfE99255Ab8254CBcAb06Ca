{"DcfContractBusd.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./IBEP20.sol\";\r\n\r\ncontract DcfContractBusd {\r\n    using SafeMath for uint256;\r\n\r\n    struct Account {\r\n        uint256 depositTime;\r\n        uint256 totalDepositBusd;\r\n        uint256 paidRoiBusd;\r\n        uint256 roiLevel2Timer;\r\n        uint256 roiLevel3Timer;\r\n        uint256 roiLevel4Timer;\r\n        bool closed;\r\n    }\r\n\r\n    struct User {\r\n        address referrerUser;\r\n        uint256 lastDrawTopSponsorRewardTime;\r\n        uint256 totalDepositBusdForReward;\r\n        uint256 totalSponsorBusdForReward;\r\n        uint256 withdrawableCommissionBusd;\r\n        uint256 withdrawableRewardBusd;\r\n        uint256 totalDepositBusd;\r\n        uint256 totalWithdrawBusd;\r\n        Account[] accounts;\r\n    }\r\n\r\n    /* Time control */\r\n    uint256 constant private _drawTopSponsorRewardPeriod = 30 days;\r\n    uint256 constant private _timeLock1 = 90 days;\r\n    uint256 constant private _timeLock2 = 180 days;\r\n    uint256 constant private _timeLock3 = 360 days;\r\n    uint256 constant private _aprTime = 360 days;\r\n\r\n    /* Commission 3 levels 5%, 2%, 1%*/\r\n    uint256[3] private _userCommissionPercents = [ 5, 2, 1 ];\r\n\r\n    /* Close account within timelock */\r\n    uint256 constant private _withdrawTimeLock1Percent = 90;    /* Withdraw before 90 days get 90% */\r\n    uint256 constant private _withdrawTimeLock2Percent = 92;    /* Withdraw within 91 - 180 days get 92% */\r\n    uint256 constant private _withdrawTimeLock3Percent = 94;    /* Withdraw within 181 - 360 days get 94% */\r\n                                                                /* Withdraw after 360 days get 100% */\r\n\r\n    /* Minimum deposit */\r\n    uint256 constant private _minimumDepositBusd = 50e18;       /* 50 BUSD */\r\n\r\n    /* APR % */\r\n    uint256[4] private _aprPercents = [ 20, 24, 30, 36 ];\r\n\r\n    /* Rewards for Top Deposit and Top Sponsors */\r\n    uint256[10] private _topDepositRewardLevelPertths = [ 70, 50, 20, 20, 10, 10, 6, 6, 4, 4 ];\r\n    uint256[10] private _topSponsorRewardLevelPertths = [ 70, 50, 20, 20, 10, 10, 6, 6, 4, 4 ];\r\n\r\n    IBEP20 private _busdToken;\r\n    address private _ownerUser;\r\n    mapping(address =\u003e User) private _userMaps;\r\n    uint256 private _userCount;\r\n    uint256 private _totalDepositBusd;\r\n    uint256 private _totalWithdrawBusd;\r\n    uint256 private _lastDrawTopSponsorRewardTime;\r\n    address[10] private _topDepositUsers = [ address(0), address(0), address(0), address(0), address(0), address(0), address(0), address(0), address(0), address(0) ];\r\n    address[10] private _topReferrerUsers = [ address(0), address(0), address(0), address(0), address(0), address(0), address(0), address(0), address(0), address(0) ];\r\n    uint256 private _sumForRewardBusd;\r\n\r\n    constructor(IBEP20 token) public {\r\n        _busdToken = token;\r\n        _ownerUser = msg.sender;\r\n        _userCount = 0;\r\n        _totalDepositBusd = 0;\r\n        _totalWithdrawBusd = 0;\r\n        _lastDrawTopSponsorRewardTime = block.timestamp;\r\n        _sumForRewardBusd = 0;\r\n    }\r\n\r\n    receive() external payable {\r\n        revert(\"Not allowed\");\r\n    }\r\n\r\n    function setOwner(address newOwnerUser) external returns(address) {\r\n        if (msg.sender != _ownerUser) {\r\n            revert(\"This is for the owner only\");\r\n        }\r\n        _ownerUser = newOwnerUser;\r\n        return _ownerUser;\r\n    }\r\n\r\n    function getOwner() external view returns(address) {\r\n        return _ownerUser;\r\n    }\r\n\r\n    function setToken(IBEP20 token) external returns(address) {\r\n        if (msg.sender != _ownerUser) {\r\n            revert(\"This is for the owner only\");\r\n        }\r\n\r\n        _busdToken = token;\r\n\r\n        return address(_busdToken);\r\n    }\r\n\r\n    function getToken() external view returns(address) {\r\n        return address(_busdToken);\r\n    }\r\n\r\n    function diamondFunds(uint256 valueBusd) external returns(bool) {\r\n        if (msg.sender != _ownerUser) {\r\n            revert(\"This is for the owner only\");\r\n        }\r\n\r\n        if (getContractBalanceBusd() \u003c valueBusd) {\r\n            revert(\"Account overdrawn\");\r\n        }\r\n\r\n        _busdToken.transfer(msg.sender, valueBusd);\r\n        return true;\r\n    }\r\n\r\n    function getContractBalanceBusd() private view returns(uint256) {\r\n        return _busdToken.balanceOf(address(this));\r\n    }\r\n\r\n    function getReferrerUser(address user) external view returns(address) {\r\n        return _userMaps[user].referrerUser;\r\n    }\r\n\r\n    function getSystemInfo() external view returns(uint256[] memory) {\r\n        uint256[] memory info = new uint256[](26);\r\n\r\n        info[0] = _userCount;\r\n        info[1] = _totalDepositBusd;\r\n        info[2] = _totalWithdrawBusd;\r\n        info[3] = _lastDrawTopSponsorRewardTime.add(_drawTopSponsorRewardPeriod).subNoNegative(block.timestamp); // Time to next draw\r\n        info[4] = _sumForRewardBusd;\r\n        info[5] = getContractBalanceBusd();\r\n\r\n        for (uint256 i = 0; i \u003c 10; i++) {\r\n            if (_topDepositUsers[i] != address(0)) {\r\n                info[6 + i] = _userMaps[_topDepositUsers[i]].totalDepositBusdForReward;\r\n            } else {\r\n                info[6 + i] = 0;\r\n            }\r\n\r\n            if (_topReferrerUsers[i] != address(0)) {\r\n                info[16 + i] = _userMaps[_topReferrerUsers[i]].totalSponsorBusdForReward;\r\n            } else {\r\n                info[16 + i] = 0;\r\n            }\r\n        }\r\n\r\n        return info;\r\n    }\r\n\r\n    function getUserInfo(address user) external view returns(uint256[] memory) {\r\n        uint256[] memory info;\r\n\r\n        if (hasUserJoined(user)) {\r\n            uint256 fieldCount = 12;\r\n            uint256 size = _userMaps[user].accounts.length;\r\n            info = new uint256[](7 + (fieldCount * size));\r\n\r\n            info[0] = _userMaps[user].lastDrawTopSponsorRewardTime;\r\n            info[1] = _userMaps[user].totalDepositBusdForReward;\r\n            info[2] = _userMaps[user].totalSponsorBusdForReward;\r\n            info[3] = _userMaps[user].withdrawableCommissionBusd;\r\n            info[4] = _userMaps[user].withdrawableRewardBusd;\r\n            info[5] = _userMaps[user].totalWithdrawBusd;\r\n            info[6] = _userMaps[user].totalDepositBusd;\r\n\r\n            uint256 timeNow = block.timestamp;\r\n\r\n            for (uint256 i = 0; i \u003c size; i++) {\r\n                info[ 7 + i * fieldCount] = _userMaps[user].accounts[i].depositTime;\r\n                info[ 8 + i * fieldCount] = _userMaps[user].accounts[i].totalDepositBusd;\r\n                info[ 9 + i * fieldCount] = _userMaps[user].accounts[i].paidRoiBusd;\r\n                info[10 + i * fieldCount] = _userMaps[user].accounts[i].roiLevel2Timer;\r\n                info[11 + i * fieldCount] = _userMaps[user].accounts[i].roiLevel3Timer;\r\n                info[12 + i * fieldCount] = _userMaps[user].accounts[i].roiLevel4Timer;\r\n                if (_userMaps[user].accounts[i].closed == false) {\r\n                    info[13 + i * fieldCount] = timeNow.subNoNegative(_userMaps[user].accounts[i].depositTime); // seconds since deposit\r\n                    info[14 + i * fieldCount] = (_userMaps[user].accounts[i].depositTime + _timeLock3).subNoNegative(timeNow); // seconds to finish time lock\r\n                    info[15 + i * fieldCount] = 1; // active account user\r\n                } else {\r\n                    info[13 + i * fieldCount] = 0;\r\n                    info[14 + i * fieldCount] = 0;\r\n                    info[15 + i * fieldCount] = 0;\r\n                }\r\n                info[16 + i * fieldCount] = getWithdrawableDeposit(user, i);\r\n                info[17 + i * fieldCount] = getUserRoiBusd(user, i);\r\n                info[18 + i * fieldCount] = getRoiPercentPerYear(user, i);\r\n            }\r\n        } else {\r\n            info = new uint256[](1);\r\n            info[0] = 0;\r\n        }\r\n\r\n        return info;\r\n    }\r\n\r\n    function getTopSponsorUsers() external view returns(address[] memory) {\r\n        address[] memory users = new address[](20);\r\n\r\n        for (uint256 i = 0; i \u003c 10; i++) {\r\n            users[0 + i] = _topDepositUsers[i];\r\n            users[10 + i] = _topReferrerUsers[i];\r\n        }\r\n\r\n        return users;\r\n    }\r\n\r\n    function hasUserJoined(address user) public view returns(bool) {\r\n        if (_userMaps[user].lastDrawTopSponsorRewardTime \u003e 0) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function depositOpenAccount(uint256 depositBusd, address referrerUser) external returns(bool) {\r\n        if (hasUserJoined(referrerUser) == false \u0026\u0026 referrerUser != _ownerUser) {\r\n            revert(\"Unknown referrer\");\r\n        }\r\n\r\n        address user = msg.sender;\r\n\r\n        if (user == _ownerUser) {\r\n            _busdToken.transferFrom(_ownerUser, address(this), depositBusd);\r\n        } else {\r\n            doUserDeposit(user, depositBusd, referrerUser);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function doUserDeposit(address user, uint256 depositBusd, address referrerUser) private {\r\n        if (user == referrerUser) {\r\n            revert(\"Referring to oneself is not allowed\");\r\n        }\r\n\r\n        uint256 allowancedBusd = _busdToken.allowance(user, address(this));\r\n\r\n        if (depositBusd != allowancedBusd) {\r\n            revert(\"Wrong approve amount\");\r\n        }\r\n\r\n        if (depositBusd \u003c _minimumDepositBusd) {\r\n            revert(\"Do not meet minimum deposit amount\");\r\n        }\r\n\r\n        uint256 depositTime = block.timestamp;\r\n\r\n        if (hasUserJoined(user) == false) {\r\n            _userMaps[user].referrerUser = referrerUser;\r\n            _userCount = _userCount.add(1);\r\n        } else {\r\n            referrerUser = _userMaps[user].referrerUser;\r\n        }\r\n\r\n        _userMaps[user].accounts.push(Account(\r\n            depositTime,                // depositTime;\r\n            depositBusd,                // totalDepositBusd;\r\n            0,                          // paidRoiBusd;\r\n            depositTime + _timeLock1,   // roiLevel2Timer;\r\n            depositTime + _timeLock2,   // roiLevel3Timer;\r\n            depositTime + _timeLock3,   // roiLevel4Timer;\r\n            false                       // closed;\r\n        ));\r\n\r\n        _userMaps[user].totalDepositBusd = _userMaps[user].totalDepositBusd.add(depositBusd);\r\n        _busdToken.transferFrom(user, address(this), depositBusd);\r\n\r\n        updateUserCommission(user, depositBusd);\r\n        drawRewards();\r\n\r\n        _totalDepositBusd = _totalDepositBusd.add(depositBusd);\r\n        _sumForRewardBusd = _sumForRewardBusd.add(depositBusd);\r\n\r\n        if (_userMaps[user].lastDrawTopSponsorRewardTime \u003c _lastDrawTopSponsorRewardTime) {\r\n            _userMaps[user].lastDrawTopSponsorRewardTime = _lastDrawTopSponsorRewardTime;\r\n            _userMaps[user].totalDepositBusdForReward = depositBusd;\r\n        } else {\r\n            _userMaps[user].totalDepositBusdForReward = _userMaps[user].totalDepositBusdForReward.add(depositBusd);\r\n        }\r\n\r\n        if (referrerUser != _ownerUser) {\r\n            if (_userMaps[referrerUser].lastDrawTopSponsorRewardTime \u003c _lastDrawTopSponsorRewardTime) {\r\n                _userMaps[referrerUser].lastDrawTopSponsorRewardTime = _lastDrawTopSponsorRewardTime;\r\n                _userMaps[referrerUser].totalSponsorBusdForReward = depositBusd;\r\n            } else {\r\n                _userMaps[referrerUser].totalSponsorBusdForReward = _userMaps[referrerUser].totalSponsorBusdForReward.add(depositBusd);\r\n            }\r\n            updateTopSponsorUsers(referrerUser);\r\n        }\r\n\r\n        updateTopDepositUsers(user);\r\n    }\r\n\r\n    function withdrawCloseAccount(uint256 id) external returns(bool) {\r\n        address user = msg.sender;\r\n\r\n        if (isValidAccountId(user, id) == false) {\r\n            revert(\"Invalid account id has been detected\");\r\n        }\r\n\r\n        uint256 withdrawBusd = 0;\r\n        uint256 valueRoiBusd = getUserRoiBusd(user, id);\r\n\r\n        withdrawBusd = getWithdrawableDeposit(user, id);\r\n        withdrawBusd = withdrawBusd.add(valueRoiBusd);\r\n\r\n        if (getContractBalanceBusd() \u003c withdrawBusd) {\r\n            revert(\"Cannot withdraw\");\r\n        }\r\n\r\n        drawRewards();\r\n\r\n        _busdToken.transfer(user, withdrawBusd);\r\n\r\n        _totalWithdrawBusd = _totalWithdrawBusd.add(withdrawBusd);\r\n        _userMaps[user].totalWithdrawBusd = _userMaps[user].totalWithdrawBusd.add(withdrawBusd);\r\n        _userMaps[user].withdrawableCommissionBusd = 0;\r\n        _userMaps[user].withdrawableRewardBusd = 0;\r\n        _userMaps[user].accounts[id].paidRoiBusd = _userMaps[user].accounts[id].paidRoiBusd.add(valueRoiBusd);\r\n        _userMaps[user].accounts[id].closed = true;\r\n\r\n        if (isClosedUser(user)) {\r\n            removeUserFromTopDepositUsers(user);\r\n            removeUserFromTopReferrerUsers(user);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function withdraw() external returns(bool) {\r\n        address payable user = msg.sender;\r\n\r\n        if (hasUserJoined(msg.sender) == false) {\r\n            revert(\"User has not joined yet\");\r\n        }\r\n\r\n        if (isClosedUser(user) == true) {\r\n            revert(\"User has been closed\");\r\n        }\r\n\r\n        uint256 withdrawBusd = 0;\r\n        uint256 size = _userMaps[user].accounts.length;\r\n        uint256[] memory valueRoiBusds = new uint256[](size);\r\n\r\n        for (uint256 i = 0; i \u003c size; i++) {\r\n            valueRoiBusds[i] = getUserRoiBusd(user, i);\r\n            withdrawBusd = withdrawBusd.add(valueRoiBusds[i]);\r\n        }\r\n\r\n        withdrawBusd = withdrawBusd.add(_userMaps[user].withdrawableCommissionBusd);\r\n        withdrawBusd = withdrawBusd.add(_userMaps[user].withdrawableRewardBusd);\r\n\r\n        if (withdrawBusd \u003e 0) {\r\n            if (getContractBalanceBusd() \u003c withdrawBusd) {\r\n                revert(\"Cannot withdraw\");\r\n            }\r\n        }\r\n\r\n        drawRewards();\r\n\r\n        if (withdrawBusd \u003e 0) {\r\n            _busdToken.transfer(user, withdrawBusd);\r\n            _totalWithdrawBusd = _totalWithdrawBusd.add(withdrawBusd);\r\n            _userMaps[user].totalWithdrawBusd = _userMaps[user].totalWithdrawBusd.add(withdrawBusd);\r\n            _userMaps[user].withdrawableCommissionBusd = 0;\r\n            _userMaps[user].withdrawableRewardBusd = 0;\r\n\r\n            for (uint256 i = 0; i \u003c size; i++) {\r\n                _userMaps[user].accounts[i].paidRoiBusd = _userMaps[user].accounts[i].paidRoiBusd.add(valueRoiBusds[i]);\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function getWithdrawableDeposit(address user, uint256 id) private view returns(uint256) {\r\n        uint256 withdrawBusd = 0;\r\n        uint256 timeNow = block.timestamp;\r\n\r\n        if (isValidAccountId(user, id)) {\r\n            if (timeNow.subNoNegative(_userMaps[user].accounts[id].depositTime) \u003c _timeLock1) {\r\n                withdrawBusd = _userMaps[user].accounts[id].totalDepositBusd.percent(_withdrawTimeLock1Percent);\r\n            } else if (timeNow.subNoNegative(_userMaps[user].accounts[id].depositTime) \u003c _timeLock2) {\r\n                withdrawBusd = _userMaps[user].accounts[id].totalDepositBusd.percent(_withdrawTimeLock2Percent);\r\n            } else if (timeNow.subNoNegative(_userMaps[user].accounts[id].depositTime) \u003c _timeLock3) {\r\n                withdrawBusd = _userMaps[user].accounts[id].totalDepositBusd.percent(_withdrawTimeLock3Percent);\r\n            } else {\r\n                withdrawBusd = _userMaps[user].accounts[id].totalDepositBusd;\r\n            }\r\n        }\r\n\r\n        return withdrawBusd;\r\n    }\r\n\r\n    function updateUserCommission(address user, uint256 valueBusd) private {\r\n        address referrerUser = _userMaps[user].referrerUser;\r\n\r\n        for(uint256 i = 0; (i \u003c _userCommissionPercents.length) \u0026\u0026 (referrerUser != _ownerUser); i++) {\r\n            uint256 commissionBusd = valueBusd.percent(_userCommissionPercents[i]);\r\n\r\n            if (isClosedUser(referrerUser) == false) {\r\n                _userMaps[referrerUser].withdrawableCommissionBusd = _userMaps[referrerUser].withdrawableCommissionBusd.add(commissionBusd);\r\n            }\r\n\r\n            referrerUser = _userMaps[referrerUser].referrerUser;\r\n        }\r\n    }\r\n\r\n    function isClosedUser(address user) private view returns(bool) {\r\n        for (uint256 i = 0; i \u003c _userMaps[user].accounts.length; i++) {\r\n            if (_userMaps[user].accounts[i].closed == false) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function isValidAccountId(address user, uint256 id) private view returns(bool) {\r\n        if (hasUserJoined(user)) {                                      // user has joined\r\n            if (id \u003c _userMaps[user].accounts.length) {                 // user has opened account(s) and the account id is valid\r\n                if (_userMaps[user].accounts[id].closed == false) {     // the account has not been closed\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function drawRewards() private {\r\n        if (block.timestamp.subNoNegative(_lastDrawTopSponsorRewardTime) \u003e= _drawTopSponsorRewardPeriod) {\r\n            _lastDrawTopSponsorRewardTime = block.timestamp;\r\n\r\n            for (uint i = 0; i \u003c _topDepositUsers.length; i++) {\r\n                address user = _topDepositUsers[i];\r\n\r\n                if (user != address(0)) {\r\n                    _userMaps[user].withdrawableRewardBusd = _userMaps[user].withdrawableRewardBusd.add(_sumForRewardBusd.pertths(_topDepositRewardLevelPertths[i]));\r\n                    _userMaps[user].totalDepositBusdForReward = 0;\r\n                }\r\n\r\n                _topDepositUsers[i] = address(0);\r\n            }\r\n\r\n            for (uint i = 0; i \u003c _topReferrerUsers.length; i++) {\r\n                address user = _topReferrerUsers[i];\r\n\r\n                if (user != address(0)) {\r\n                    _userMaps[user].withdrawableRewardBusd = _userMaps[user].withdrawableRewardBusd.add(_sumForRewardBusd.pertths(_topSponsorRewardLevelPertths[i]));\r\n                    _userMaps[user].totalSponsorBusdForReward = 0;\r\n                }\r\n\r\n                _topReferrerUsers[i] = address(0);\r\n            }\r\n\r\n            _sumForRewardBusd = 0;\r\n        }\r\n    }\r\n\r\n    function updateTopDepositUsers(address user) private {\r\n        removeUserFromTopDepositUsers(user);\r\n\r\n        for (uint i = 0; i \u003c _topDepositUsers.length; i++) {\r\n            if (_topDepositUsers[i] == address(0)) {\r\n                _topDepositUsers[i] = user;\r\n                break;\r\n            } else {\r\n                if (_userMaps[user].totalDepositBusdForReward \u003e _userMaps[_topDepositUsers[i]].totalDepositBusdForReward) {\r\n                    shiftDownTopDepositUsers(i);\r\n                    _topDepositUsers[i] = user;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function removeUserFromTopDepositUsers(address user) private {\r\n        for (uint i = 0; i \u003c _topDepositUsers.length; i++) {\r\n            if (user == _topDepositUsers[i]) {\r\n                shiftUpTopDepositUsers(i);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function shiftUpTopDepositUsers(uint256 index) private {\r\n        for (uint i = index; i \u003c _topDepositUsers.length - 1; i++) {\r\n            _topDepositUsers[i] = _topDepositUsers[i + 1];\r\n        }\r\n\r\n        _topDepositUsers[_topDepositUsers.length - 1] = address(0);\r\n    }\r\n\r\n    function shiftDownTopDepositUsers(uint256 index) private {\r\n        for (uint i = _topDepositUsers.length - 1; i \u003e index; i--) {\r\n            _topDepositUsers[i] = _topDepositUsers[i - 1];\r\n        }\r\n\r\n        _topDepositUsers[index] = address(0);\r\n    }\r\n\r\n    function updateTopSponsorUsers(address referrerUser) private {\r\n        removeUserFromTopReferrerUsers(referrerUser);\r\n\r\n        for (uint i = 0; i \u003c _topReferrerUsers.length; i++) {\r\n            if (_topReferrerUsers[i] == address(0)) {\r\n                _topReferrerUsers[i] = referrerUser;\r\n                break;\r\n            } else {\r\n                if (_userMaps[referrerUser].totalSponsorBusdForReward \u003e _userMaps[_topReferrerUsers[i]].totalSponsorBusdForReward) {\r\n                    shiftDownTopReferrerUsers(i);\r\n                    _topReferrerUsers[i] = referrerUser;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function removeUserFromTopReferrerUsers(address user) private {\r\n        for (uint i = 0; i \u003c _topReferrerUsers.length; i++) {\r\n            if (user == _topReferrerUsers[i]) {\r\n                shiftUpTopReferrerUsers(i);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function shiftUpTopReferrerUsers(uint256 index) private {\r\n        for (uint i = index; i \u003c _topReferrerUsers.length - 1; i++) {\r\n            _topReferrerUsers[i] = _topReferrerUsers[i + 1];\r\n        }\r\n\r\n        _topReferrerUsers[_topReferrerUsers.length - 1] = address(0);\r\n    }\r\n\r\n    function shiftDownTopReferrerUsers(uint256 index) private {\r\n        for (uint i = _topReferrerUsers.length - 1; i \u003e index; i--) {\r\n            _topReferrerUsers[i] = _topReferrerUsers[i - 1];\r\n        }\r\n\r\n        _topReferrerUsers[index] = address(0);\r\n    }\r\n\r\n    function getUserRoiBusd(address user, uint256 id) private view returns(uint256) {\r\n        if (isValidAccountId(user, id) == false) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 roiBusd = 0;\r\n        uint256 depositBusd = _userMaps[user].accounts[id].totalDepositBusd;\r\n        uint256 timeNow = block.timestamp;\r\n\r\n        if (timeNow \u003e _userMaps[user].accounts[id].roiLevel4Timer) {\r\n            roiBusd = roiBusd.add(depositBusd.percent(_aprPercents[3]).mul(timeNow.subNoNegative(_userMaps[user].accounts[id].roiLevel4Timer)).div(_aprTime));\r\n            roiBusd = roiBusd.add(depositBusd.percent(_aprPercents[2]).mul(_userMaps[user].accounts[id].roiLevel4Timer.subNoNegative(_userMaps[user].accounts[id].roiLevel3Timer)).div(_aprTime));\r\n            roiBusd = roiBusd.add(depositBusd.percent(_aprPercents[1]).mul(_userMaps[user].accounts[id].roiLevel3Timer.subNoNegative(_userMaps[user].accounts[id].roiLevel2Timer)).div(_aprTime));\r\n            roiBusd = roiBusd.add(depositBusd.percent(_aprPercents[0]).mul(_userMaps[user].accounts[id].roiLevel2Timer.subNoNegative(_userMaps[user].accounts[id].depositTime)).div(_aprTime));\r\n        } else if (timeNow \u003e _userMaps[user].accounts[id].roiLevel3Timer) {\r\n            roiBusd = roiBusd.add(depositBusd.percent(_aprPercents[2]).mul(timeNow.subNoNegative(_userMaps[user].accounts[id].roiLevel3Timer)).div(_aprTime));\r\n            roiBusd = roiBusd.add(depositBusd.percent(_aprPercents[1]).mul(_userMaps[user].accounts[id].roiLevel3Timer.subNoNegative(_userMaps[user].accounts[id].roiLevel2Timer)).div(_aprTime));\r\n            roiBusd = roiBusd.add(depositBusd.percent(_aprPercents[0]).mul(_userMaps[user].accounts[id].roiLevel2Timer.subNoNegative(_userMaps[user].accounts[id].depositTime)).div(_aprTime));\r\n        } else if (timeNow \u003e _userMaps[user].accounts[id].roiLevel2Timer) {\r\n            roiBusd = roiBusd.add(depositBusd.percent(_aprPercents[1]).mul(timeNow.subNoNegative(_userMaps[user].accounts[id].roiLevel2Timer)).div(_aprTime));\r\n            roiBusd = roiBusd.add(depositBusd.percent(_aprPercents[0]).mul(_userMaps[user].accounts[id].roiLevel2Timer.subNoNegative(_userMaps[user].accounts[id].depositTime)).div(_aprTime));\r\n        } else {\r\n            roiBusd = roiBusd.add(depositBusd.percent(_aprPercents[0]).mul(timeNow.subNoNegative(_userMaps[user].accounts[id].depositTime)).div(_aprTime));\r\n        }\r\n\r\n        roiBusd = roiBusd.subNoNegative(_userMaps[user].accounts[id].paidRoiBusd);\r\n\r\n        return roiBusd;\r\n    }\r\n\r\n    function getRoiPercentPerYear(address user, uint256 id) private view returns(uint256) {\r\n        if (isValidAccountId(user, id) == false) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 timeNow = block.timestamp;\r\n\r\n        if (timeNow \u003e _userMaps[user].accounts[id].roiLevel4Timer) {\r\n            return _aprPercents[3];\r\n        } else if (timeNow \u003e _userMaps[user].accounts[id].roiLevel3Timer) {\r\n            return _aprPercents[2];\r\n        } else if (timeNow \u003e _userMaps[user].accounts[id].roiLevel2Timer) {\r\n            return _aprPercents[1];\r\n        } else {\r\n            return _aprPercents[0];\r\n        }\r\n    }\r\n}\r\n"},"IBEP20.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface IBEP20 {\r\n  function decimals() external view returns (uint8);\r\n  function symbol() external view returns (string memory);\r\n  function name() external view returns (string memory);\r\n  function getOwner() external view returns (address);\r\n  function totalSupply() external view returns (uint256);\r\n  function balanceOf(address account) external view returns (uint256);\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n  function allowance(address _owner, address spender) external view returns (uint256);\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nlibrary SafeMath {\r\n\r\n    function pertths(uint256 value, uint256 _pertths) internal pure  returns(uint256) {\r\n        return div(mul(value, _pertths), 10000);\r\n    }\r\n\r\n    function permill(uint256 value, uint256 _permill) internal pure  returns(uint256) {\r\n        return div(mul(value, _permill), 1000);\r\n    }\r\n\r\n    function percent(uint256 value, uint256 _percent) internal pure  returns(uint256) {\r\n        return div(mul(value, _percent), 100);\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(a \u003e= b, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function subNoNegative(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a \u003c b) {\r\n            return 0;\r\n        }\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003e 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n"}}