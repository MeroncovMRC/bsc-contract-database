{"AggregatorV2V3Interface.sol":{"content":"pragma solidity \u003e=0.5.0;\n\n/**\n * @title The V2 \u0026 V3 Aggregator Interface\n * @notice Solidity V0.5 does not allow interfaces to inherit from other\n * interfaces so this contract is a combination of v0.5 AggregatorInterface.sol\n * and v0.5 AggregatorV3Interface.sol.\n */\ninterface AggregatorV2V3Interface {\n  //\n  // V2 Interface:\n  //\n  function latestAnswer() external view returns (int256);\n  function latestTimestamp() external view returns (uint256);\n  function latestRound() external view returns (uint256);\n  function getAnswer(uint256 roundId) external view returns (int256);\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp);\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n\n  //\n  // V3 Interface:\n  //\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}"},"CompStorageTT.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.5.16;\n\nimport \"./ITrendToken.sol\";\nimport \"./IChainlinkOracle.sol\";\n\n\n\ncontract UnitrollerAdminStorage {\n    /**\n    * @notice Administrator for this contract\n    */\n    address public admin;\n\n    /**\n    * @notice Pending administrator for this contract\n    */\n    address public pendingAdmin;\n\n    /**\n    * @notice Active brains of Unitroller\n    */\n    address public comptrollerImplementation;\n\n    /**\n    * @notice Pending brains of Unitroller\n    */\n    address public pendingComptrollerImplementation;\n}\n\n\n\ncontract ComptrollerStorage is UnitrollerAdminStorage {\n\n    /**\n     * @notice Oracle which gives the price of any given asset\n     */\n    IOracle public oracle;\n\n\n    /**\n     * @notice Per-account mapping of \"assets you are in\", capped by maxAssets\n     */\n    mapping(address =\u003e ITrendToken[]) public accountAssets;\n\n\n    struct TrendToken {\n\n        // @notice Whether or not this Trend Token is listed \n        bool isListed;\n\n        // @notice Whether or not this Trend Token is active\n        // @dev Admin may set Trend Token to inactive to prevent any activity\n        bool isActive;\n\n        // @notice Whether or not this Trend Token is tradeable\n        // @dev Admin may set Trend Token to isTrade to prevent any trade activity\n        bool isTrade;\n\n        // @notice Whether or not this Trend Token can interact with Dual Pools\n        bool allowedDualPools;\n\n        // @notice The maximum trade fee this Trend Token can have\n        uint maxTradeFee;\n\n        // @notice The maximum performance fee this Trend Token can have\n        uint maxPerformanceFee;\n\n        // @notice Maximum value (contract and collateral) to disable token from portfolio\n        uint maxDisableValue;\n\n    }\n\n\n    /**\n     * @notice Official mapping of vTokens -\u003e Market metadata\n     * @dev Used e.g. to determine if a market is supported\n     */\n    mapping(address =\u003e TrendToken) public trendTokens;\n\n\n    /**\n     * @notice The Pause Guardian can pause certain actions as a safety mechanism.\n     *  Actions which allow users to remove their own assets cannot be paused.\n     *  Liquidation / seizing / transfer can only be paused globally, not by market.\n     */\n    address public pauseGuardian;\n\n\n    /**\n     * @notice Pause/Unpause whole protocol actions\n     */\n    bool public protocolPaused;\n\n\n    /**\n     * @notice Sets a specific Trend Token to paused\n     * @dev Does not allow for deposit or redeems\n     */\n    mapping(address =\u003e bool) public mintGuardianPaused;\n\n\n    /**\n     * @notice A list of all Trend Tokens\n     */\n    ITrendToken[] public allTrendTokens;\n\n    /**\n     * @notice a list of all supported underlying tokens\n     * @dev May be added to Trend Token portfolios\n     */\n    address[] public supportedTokens;\n\n    /**\n     * @notice Mapping of underlying:dTokens\n     */\n    mapping(address =\u003e address) public tokenToDToken;\n\n\n    /**\n     * @notice Wallet that is able to change the state of locked\n     */\n    address lockedWallet;\n\n    /**\n     * @notice Restrictions actions of admin if locked\n     * @dev Adds an extra layer of security\n     */\n    bool locked = true;\n\n\n}\n\n"},"IChainlinkOracle.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.5.16;\n\nimport \"./AggregatorV2V3Interface.sol\";\n\ninterface IOracle {\n    function getUnderlyingPrice(address vtoken) external view returns(uint256);\n\n    function getFeed(string calldata symbol) external view returns (AggregatorV2V3Interface);\n    function getChainlinkPrice(AggregatorV2V3Interface feed) external view returns (uint);\n\n}\n\n"},"IERC20.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * \u003e Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"IIncentiveModelSimple.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.5.16;\n//pragma experimental ABIEncoderV2;\n\n\nimport \"./IERC20.sol\";\n\n\ninterface IIncentiveModelSimple {\n\n    /**\n     * @notice For Lens\n     */\n    function protocolFeeTrade() external view returns(uint);\n\n    function protocolFeeDeposit() external view returns(uint);\n\n    function protocolFeeRedeem() external view returns(uint);\n\n    function isIncentiveModel() external view returns(bool);\n    function totalDepositFee(IERC20 _depositBEP20, uint _valueDeposit, int priorDelta, int postDelta, uint price, uint balanceXTT)  external view returns(int totalFee, uint protocolFeePerc, uint reward, uint fee);\n    function totalRedeemFee(IERC20 _redeemBep20, uint _valueRedeem, int priorDelta, int postDelta, uint price, uint balanceXTT) external view returns(int totalFee, uint protocolFeePerc, uint reward, uint fee);\n    function valueOutAfterSell(IERC20 _tokenIn, uint _valueIn, int priorDeltaIn, int postDeltaIn, uint balanceXTT) external view returns(uint redeemValue);\n    function valueOutAfterBuy(IERC20 _tokenOut, uint _valueAfterSell, int priorDeltaOut, int postDeltaOut) external view returns(uint buyValue);\n\n}"},"ITrendToken.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.5.16; \n\nimport \"./IVBep20.sol\";\nimport \"./ITrendTokenTkn.sol\";\nimport \"./IIncentiveModelSimple.sol\";\n\ninterface ITrendToken {\n\n    /**\n     * @notice For lens\n     */\n    function incentiveModel() external view returns(IIncentiveModelSimple);\n    function storedEquity() external view returns(address[] memory,uint[] memory,uint[] memory,uint[] memory,uint[] memory,uint);\n    function trendToken() external view returns(ITrendTokenTkn);\n    function performanceFee() external view returns(uint);\n\n    function desiredAllocations() external view returns(uint[] memory);\n\n\n\n    function lastRebalance() external view returns(uint);\n    function isTrendToken() external view returns(bool);\n\n    function compDP() external view returns (address);\n    function dBNB() external view returns(IVBep20);\n    function priceExt(IVBep20 _dToken) external view returns(uint);\n    function trendTokenToUSDext() external view returns(uint, uint);\n    function trendTokenOutExternal(IERC20 _depositBep20, IVBep20 _dToken, uint _sellAmtBEP20) external view returns(uint, uint, uint, uint, uint, int); \n    function trendTokenInExternal(IERC20 _redeemBep20, IVBep20 _dToken, uint _redeemAmt) external view returns(uint, uint, uint, uint, uint, int);\n    function tradeInfoExt(IERC20[] calldata tokenInOut, IVBep20[] calldata dTokensInOut, uint valueIn) external view returns(uint);\n\n}\n\n"},"ITrendTokenTkn.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.5.16;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\ninterface ITrendTokenTkn {\n  \n    function mint(address _recipient, uint256 _amount) external;\n\n    function name() external view returns(string memory);\n\n    function burn(uint256 _amount) external;\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * \u003e Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    //function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function transfersFrom(address sender, address recipient, uint256 amount) external returns(bool); // requires allowance (instead of subtraction overflow message)\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"IVBep20.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.5.16;\n\ninterface IVBep20 {\n\n    function balanceOf(address _user) external view returns(uint256);\n    function balanceOfUnderlying(address account) external returns (uint);\n\n    function mint(uint mintAmount) external returns (uint); // Different for IVBNB\n    function repayBorrow(uint256 _amount) external returns(uint256); // Different for IVBNB\n\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\n    function exchangeRateStored() external view returns(uint256);\n    function borrowBalanceCurrent(address _owner) external returns(uint256);\n    function borrow(uint256 _amount) external returns(uint256);\n\n    function getCash() external view returns (uint);\n\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\n    function borrowBalanceStored(address account) external view returns (uint);\n    function totalBorrowsCurrent() external returns (uint);\n\n    function accrueInterest() external returns (uint);\n\n    /*** Trading Functionality ***/\n    \n    function amountsOut(address _dTokenIn, address _dTokenOut, uint _amountIn, address _trader, address _referrer) external view returns(uint amountOut, uint reserveFeeUnderly, uint totalFeeAndSlip);\n    function swapExactTokensForTokens(uint256 _amountTokenIn, uint256 _minOut, address[] calldata dTokenOut_referrer, address payable _sendTo, uint256 _deadline) external;\n\n\n    function underlying() external view returns(address);\n\n}"},"UniTT.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.5.16;\n\nimport \"./CompStorageTT.sol\";\n\n\n/**\n * @title ComptrollerCore\n * @dev Storage for the comptroller is at this address, while execution is delegated to the `comptrollerImplementation`.\n * VTokens should reference this contract as their comptroller.\n */\ncontract Unitroller is UnitrollerAdminStorage {\n\n    /**\n      * @notice Emitted when pendingComptrollerImplementation is changed\n      */\n    event NewPendingImplementation(address oldPendingImplementation, address newPendingImplementation);\n\n    /**\n      * @notice Emitted when pendingComptrollerImplementation is accepted, which means comptroller implementation is updated\n      */\n    event NewImplementation(address oldImplementation, address newImplementation);\n\n    /**\n      * @notice Emitted when pendingAdmin is changed\n      */\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    /**\n      * @notice Emitted when pendingAdmin is accepted, which means admin is updated\n      */\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    constructor() public {\n        // Set admin to caller\n        admin = msg.sender;\n    }\n\n    /*** Admin Functions ***/\n    function _setPendingImplementation(address newPendingImplementation) public  {\n\n        require(msg.sender == admin, \"must be admin\");\n\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n        pendingComptrollerImplementation = newPendingImplementation;\n\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n    }\n\n    /**\n    * @notice Accepts new implementation of comptroller. msg.sender must be pendingImplementation\n    * @dev Admin function for new implementation to accept it\u0027s role as implementation\n    * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n    */\n    function _acceptImplementation() public returns (uint) {\n        // Check caller is pendingImplementation and pendingImplementation ≠ address(0)\n        require(msg.sender == pendingComptrollerImplementation \u0026\u0026 pendingComptrollerImplementation != address(0),\n                \"!_acceptImplementation\");\n\n        // Save current values for inclusion in log\n        address oldImplementation = comptrollerImplementation;\n        address oldPendingImplementation = pendingComptrollerImplementation;\n\n        comptrollerImplementation = pendingComptrollerImplementation;\n\n        pendingComptrollerImplementation = address(0);\n\n        emit NewImplementation(oldImplementation, comptrollerImplementation);\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n\n    }\n\n\n    /**\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n      * @param newPendingAdmin New pending admin.\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function _setPendingAdmin(address newPendingAdmin) public  {\n        // Check caller = admin\n        require(msg.sender == admin,\"!setPendingAdmin\");\n\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n    }\n\n    /**\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n      * @dev Admin function for pending admin to accept role and update admin\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function _acceptAdmin() public {\n        // Check caller is pendingAdmin\n        require(msg.sender == pendingAdmin,\"!acceptAdmin\");\n\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n\n        // Clear the pending value\n        pendingAdmin = address(0);\n\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n    }\n\n    /**\n     * @dev Delegates execution to an implementation contract.\n     * It returns to the external caller whatever the implementation returns\n     * or forwards reverts.\n     */\n    function () external payable {\n        // delegate all other functions to current implementation\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n        assembly {\n              let free_mem_ptr := mload(0x40)\n              returndatacopy(free_mem_ptr, 0, returndatasize)\n\n              switch success\n              case 0 { revert(free_mem_ptr, returndatasize) }\n              default { return(free_mem_ptr, returndatasize) }\n        }\n    }\n}"}}