{"MessageMultiSigWallet.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./MultiSigWallet.sol\";\n\ncontract MessageMultiSigWallet is MultiSigWallet{\n\n    event ConfirmationMessage(address indexed sender, uint indexed messageId);\n    event RevocationMessage(address indexed sender, uint indexed messageId);\n    event SubmissionMessage(uint indexed messageId);\n\n    mapping (bytes32 =\u003e bool) public validatedHashs;\n    mapping (uint =\u003e bytes32) public hashs;\n    uint public hashCount = 0;\n    mapping (bytes32 =\u003e uint) public validateCount;\n    mapping (bytes32 =\u003e mapping(uint =\u003e uint8)) public vSigs;\n    mapping (bytes32 =\u003e mapping(uint =\u003e bytes32)) public rSigs;\n    mapping (bytes32 =\u003e mapping(uint =\u003e bytes32)) public sSigs;\n    mapping (bytes32 =\u003e mapping(uint =\u003e address)) public hashValidators;\n    \n    constructor(address[] memory _owners, uint _required) MultiSigWallet(_owners, _required) public {\n    }\n\n    function isValidatedHash(bytes32 hash) public view returns (bool){\n        return validatedHashs[hash];\n    }\n\n    function getHashValidators(bytes32 hash) public view returns (address[] memory){\n        uint vaCount = validateCount[hash];\n        address[] memory vaList = new address[](vaCount);\n\n        uint i = 0;\n        for(i; i\u003cvaCount; i++){\n            vaList[i] = hashValidators[hash][i];\n        }\n\n        return vaList;\n    }\n\n    function updateValidate(bytes32 hash) public returns (bool){\n        require(!validatedHashs[hash], \"Validated hash.\");\n        uint i;\n        uint cnt=0;\n        for(i=0; i\u003cvalidateCount[hash]; i++){\n            if(isOwner[hashValidators[hash][i]]){\n                cnt ++;\n            }\n        }\n        if(cnt \u003e= required){\n            validatedHashs[hash] = true; \n        }\n        return validatedHashs[hash];\n    }\n\n    function validate(address validator, bytes32 hash, uint8 v, bytes32 r, bytes32 s) public returns (bool){\n        require(isOwner[validator], \"Unauthorized.\");\n        require(!validatedHashs[hash], \"Validated hash.\");\n        require(ecrecover(hash,v,r,s) == validator, \"Validation signature mismatch.\");\n\n        uint i=0;\n        for(i; i\u003cvalidateCount[hash]; i++){\n            if(hashValidators[hash][i] == validator){\n                revert(\"Transaction already verified by this validator.\");\n            }\n        }\n\n        if(validateCount[hash] == 0){\n          hashs[hashCount] = hash;\n          hashCount += 1;\n        }\n\n        i=validateCount[hash];\n        validateCount[hash] = i + 1;\n        vSigs[hash][i] = v;\n        rSigs[hash][i] = r;\n        sSigs[hash][i] = s;\n        hashValidators[hash][i] = validator;\n\n        if(i+1 \u003e= required){\n            validatedHashs[hash] = true;\n            return true;\n        }\n        return false;\n    }\n}\n"},"MultiSigWallet.sol":{"content":"pragma solidity ^0.5.0;\n\n/// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution.\n/// @author Stefan George - \u003cstefan.george@consensys.net\u003e\ncontract MultiSigWallet {\n\n    uint constant public MAX_OWNER_COUNT = 50;\n\n    event Confirmation(address indexed sender, uint indexed transactionId);\n    event Revocation(address indexed sender, uint indexed transactionId);\n    event Submission(uint indexed transactionId);\n    event Execution(uint indexed transactionId);\n    event ExecutionFailure(uint indexed transactionId);\n    event Deposit(address indexed sender, uint value);\n    event OwnerAddition(address indexed owner);\n    event OwnerRemoval(address indexed owner);\n    event RequirementChange(uint required);\n\n    mapping (uint =\u003e Transaction) public transactions;\n    mapping (uint =\u003e mapping (address =\u003e bool)) public confirmations;\n    mapping (address =\u003e bool) public isOwner;\n    address[] public owners;\n    uint public required;\n    uint public transactionCount;\n\n    struct Transaction {\n        address destination;\n        uint value;\n        bytes data;\n        bool executed;\n    }\n\n    modifier onlyWallet() {\n        if (msg.sender != address(this))\n            revert(\"Unauthorized.\");\n        _;\n    }\n\n    modifier ownerDoesNotExist(address owner) {\n        if (isOwner[owner])\n            revert(\"Unauthorized.\");\n        _;\n    }\n\n    modifier ownerExists(address owner) {\n        if (!isOwner[owner])\n            revert(\"Unauthorized.\");\n        _;\n    }\n\n    modifier transactionExists(uint transactionId) {\n        if (transactions[transactionId].destination == address(0))\n            revert(\"Existed transaction id.\");\n        _;\n    }\n\n    modifier confirmed(uint transactionId, address owner) {\n        if (!confirmations[transactionId][owner])\n            revert(\"Not confirmed transaction.\");\n        _;\n    }\n\n    modifier notConfirmed(uint transactionId, address owner) {\n        if (confirmations[transactionId][owner])\n            revert(\"Confirmed transaction.\");\n        _;\n    }\n\n    modifier notExecuted(uint transactionId) {\n        if (transactions[transactionId].executed)\n            revert(\"Executed transaction.\");\n        _;\n    }\n\n    modifier notNull(address _address) {\n        if (_address == address(0))\n            revert(\"Address is null\");\n        _;\n    }\n\n    modifier validRequirement(uint ownerCount, uint _required) {\n        if (   ownerCount \u003e MAX_OWNER_COUNT\n            || _required \u003e ownerCount\n            || _required == 0\n            || ownerCount == 0)\n            revert(\"Invalid requirement\");\n        _;\n    }\n\n    /// @dev Fallback function allows to deposit ether.\n    function() external{\n        revert();\n    }\n\n    /*\n     * Public functions\n     */\n    /// @dev Contract constructor sets initial owners and required number of confirmations.\n    /// @param _owners List of initial owners.\n    /// @param _required Number of required confirmations.\n    constructor(address[] memory _owners, uint _required)\n        public\n        validRequirement(_owners.length, _required)\n    {\n        for (uint i=0; i\u003c_owners.length; i++) {\n            if (isOwner[_owners[i]] || _owners[i] == address(0))\n                revert(\"Invalid owner\");\n            isOwner[_owners[i]] = true;\n        }\n        owners = _owners;\n        required = _required;\n    }\n\n    /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\n    /// @param owner Address of new owner.\n    function addOwner(address owner)\n        public\n        onlyWallet\n        ownerDoesNotExist(owner)\n        notNull(owner)\n        validRequirement(owners.length + 1, required)\n    {\n        isOwner[owner] = true;\n        owners.push(owner);\n        emit OwnerAddition(owner);\n    }\n\n    /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\n    /// @param owner Address of owner.\n    function removeOwner(address owner)\n        public\n        onlyWallet\n        ownerExists(owner)\n    {\n        isOwner[owner] = false;\n        for (uint i=0; i\u003cowners.length - 1; i++)\n            if (owners[i] == owner) {\n                owners[i] = owners[owners.length - 1];\n                break;\n            }\n        owners.length -= 1;\n        if (required \u003e owners.length)\n            changeRequirement(owners.length);\n        emit OwnerRemoval(owner);\n    }\n\n    /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\n    /// @param owner Address of owner to be replaced.\n    /// @param owner Address of new owner.\n    function replaceOwner(address owner, address newOwner)\n        public\n        onlyWallet\n        ownerExists(owner)\n        ownerDoesNotExist(newOwner)\n    {\n        for (uint i=0; i\u003cowners.length; i++)\n            if (owners[i] == owner) {\n                owners[i] = newOwner;\n                break;\n            }\n        isOwner[owner] = false;\n        isOwner[newOwner] = true;\n        emit OwnerRemoval(owner);\n        emit OwnerAddition(newOwner);\n    }\n\n    /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\n    /// @param _required Number of required confirmations.\n    function changeRequirement(uint _required)\n        public\n        onlyWallet\n        validRequirement(owners.length, _required)\n    {\n        required = _required;\n        emit RequirementChange(_required);\n    }\n\n    /// @dev Allows an owner to submit and confirm a transaction.\n    /// @param destination Transaction target address.\n    /// @param value Transaction ether value.\n    /// @param data Transaction data payload.\n    /// @return Returns transaction ID.\n    function submitTransaction(address destination, uint value, bytes memory data)\n        public\n        returns (uint transactionId)\n    {\n        transactionId = addTransaction(destination, value, data);\n        confirmTransaction(transactionId);\n    }\n\n    /// @dev Allows an owner to confirm a transaction.\n    /// @param transactionId Transaction ID.\n    function confirmTransaction(uint transactionId)\n        public\n        ownerExists(msg.sender)\n        transactionExists(transactionId)\n        notConfirmed(transactionId, msg.sender)\n    {\n        confirmations[transactionId][msg.sender] = true;\n        emit Confirmation(msg.sender, transactionId);\n        executeTransaction(transactionId);\n    }\n\n    /// @dev Allows an owner to revoke a confirmation for a transaction.\n    /// @param transactionId Transaction ID.\n    function revokeConfirmation(uint transactionId)\n        public\n        ownerExists(msg.sender)\n        confirmed(transactionId, msg.sender)\n        notExecuted(transactionId)\n    {\n        confirmations[transactionId][msg.sender] = false;\n        emit Revocation(msg.sender, transactionId);\n    }\n\n    /// @dev Allows anyone to execute a confirmed transaction.\n    /// @param transactionId Transaction ID.\n    function executeTransaction(uint transactionId)\n        public\n        notExecuted(transactionId)\n    {\n        if (isConfirmed(transactionId)) {\n            Transaction storage txn = transactions[transactionId];\n            txn.executed = true;\n            (bool result, ) = txn.destination.call.value(txn.value)(txn.data);\n            if (result)\n                emit Execution(transactionId);\n            else {\n                emit ExecutionFailure(transactionId);\n                txn.executed = false;\n            }\n        }\n    }\n\n    /// @dev Returns the confirmation status of a transaction.\n    /// @param transactionId Transaction ID.\n    /// @return Confirmation status.\n    function isConfirmed(uint transactionId)\n        public\n        view\n        returns (bool)\n    {\n        uint count = 0;\n        for (uint i=0; i\u003cowners.length; i++) {\n            if (confirmations[transactionId][owners[i]])\n                count += 1;\n            if (count == required)\n                return true;\n        }\n    }\n\n    /*\n     * Internal functions\n     */\n    /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\n    /// @param destination Transaction target address.\n    /// @param value Transaction ether value.\n    /// @param data Transaction data payload.\n    /// @return Returns transaction ID.\n    function addTransaction(address destination, uint value, bytes memory data)\n        public\n        notNull(destination)\n        returns (uint transactionId)\n    {\n        transactionId = transactionCount;\n        transactions[transactionId] = Transaction({\n            destination: destination,\n            value: value,\n            data: data,\n            executed: false\n        });\n        transactionCount += 1;\n        emit Submission(transactionId);\n    }\n\n    /*\n     * Web3 call functions\n     */\n    /// @dev Returns number of confirmations of a transaction.\n    /// @param transactionId Transaction ID.\n    /// @return Number of confirmations.\n    function getConfirmationCount(uint transactionId)\n        public\n        view\n        returns (uint count)\n    {\n        for (uint i=0; i\u003cowners.length; i++)\n            if (confirmations[transactionId][owners[i]])\n                count += 1;\n    }\n\n    /// @dev Returns total number of transactions after filers are applied.\n    /// @param pending Include pending transactions.\n    /// @param executed Include executed transactions.\n    /// @return Total number of transactions after filters are applied.\n    function getTransactionCount(bool pending, bool executed)\n        public\n        view\n        returns (uint count)\n    {\n        for (uint i=0; i\u003ctransactionCount; i++)\n            if (   pending \u0026\u0026 !transactions[i].executed\n                || executed \u0026\u0026 transactions[i].executed)\n                count += 1;\n    }\n\n    /// @dev Returns list of owners.\n    /// @return List of owner addresses.\n    function getOwners()\n        public\n        view\n        returns (address[] memory)\n    {\n        return owners;\n    }\n\n    /// @dev Returns array with owner addresses, which confirmed transaction.\n    /// @param transactionId Transaction ID.\n    /// @return Returns array of owner addresses.\n    function getConfirmations(uint transactionId)\n        public\n        view\n        returns (address[] memory _confirmations)\n    {\n        address[] memory confirmationsTemp = new address[](owners.length);\n        uint count = 0;\n        uint i;\n        for (i=0; i\u003cowners.length; i++)\n            if (confirmations[transactionId][owners[i]]) {\n                confirmationsTemp[count] = owners[i];\n                count += 1;\n            }\n        _confirmations = new address[](count);\n        for (i=0; i\u003ccount; i++)\n            _confirmations[i] = confirmationsTemp[i];\n    }\n\n    /// @dev Returns list of transaction IDs in defined range.\n    /// @param from Index start position of transaction array.\n    /// @param to Index end position of transaction array.\n    /// @param pending Include pending transactions.\n    /// @param executed Include executed transactions.\n    /// @return Returns array of transaction IDs.\n    function getTransactionIds(uint from, uint to, bool pending, bool executed)\n        public\n        view\n        returns (uint[] memory _transactionIds)\n    {\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\n        uint count = 0;\n        uint i;\n        for (i=0; i\u003ctransactionCount; i++)\n            if (   pending \u0026\u0026 !transactions[i].executed\n                || executed \u0026\u0026 transactions[i].executed)\n            {\n                transactionIdsTemp[count] = i;\n                count += 1;\n            }\n        _transactionIds = new uint[](to - from);\n        for (i=from; i\u003cto; i++)\n            _transactionIds[i - from] = transactionIdsTemp[i];\n    }\n}\n"}}