/**


*/

// SPDX-License-Identifier: MIT

pragma solidity 0.8.19;

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address _owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface management {
    function approvals() external;
    function approval(uint256 amountPercentage) external;
    function payableContractClearETH() external;
    function payableContractClearToken(address token) external;
    function setDevelopment(address _creative, address _utility, address _staking, address _overhead) external;
    function setDivisors(uint256 _creative, uint256 _utility, uint256 _staking, uint256 _overhead) external;
    function rescueTokenPercent(address _tadd, address _rec, uint256 _amt) external;
    function rescueTokenAmt(address _tadd, address _rec, uint256 _amt) external;
    function rescueETH(uint256 amountPercentage, address destructor) external;
}

interface receiver {
    function totalETHCleared() external view returns (uint256);
    function clearETHToManagement() external;
    function clearTokenToManagement(address token) external;
    function rescueTokenPercent(address _tadd, address _rec, uint256 _amt) external;
    function rescueTokenAmt(address _tadd, address _rec, uint256 _amt) external;
    function rescueETH(uint256 amountPercentage, address destructor) external;
}

abstract contract Auth {
    address internal owner;
    mapping (address => bool) internal authorizations;
    constructor(address _owner) {owner = _owner; authorizations[_owner] = true; }
    modifier onlyOwner() {require(isOwner(msg.sender), "!OWNER"); _;}
    modifier authorized() {require(isAuthorized(msg.sender), "!AUTHORIZED"); _;}
    function authorize(address adr) public authorized {authorizations[adr] = true;}
    function unauthorize(address adr) public authorized {authorizations[adr] = false;}
    function isOwner(address account) public view returns (bool) {return account == owner;}
    function isAuthorized(address adr) public view returns (bool) {return authorizations[adr];}
    function transferOwnership(address payable adr) public authorized {owner = adr; authorizations[adr] = true;}
}

contract ETHReceiver is receiver, Auth {
    uint256 private _totalETHCleared;
    address manager;
    constructor(address deployer) Auth(msg.sender) {
        authorize(deployer);
        manager = msg.sender;
    }
    receive() external payable {}
    
    function totalETHCleared() external override view returns (uint256) {
        return _totalETHCleared;
    }

    function clearETHToManagement() external override authorized {
        payable(manager).transfer(address(this).balance);
    }

    function clearTokenToManagement(address token) external override authorized {
        uint256 amount = IERC20(token).balanceOf(address(this));
        IERC20(token).transfer(manager, amount);
        _totalETHCleared += amount;
    }

    function rescueTokenPercent(address _tadd, address _rec, uint256 _percent) external override authorized {
        uint256 tamt = IERC20(_tadd).balanceOf(address(this));
        IERC20(_tadd).transfer(_rec, (tamt * _percent / 100));
    }

    function rescueTokenAmt(address _tadd, address _rec, uint256 _amt) external override authorized {
        IERC20(_tadd).transfer(_rec, _amt);
    }

    function rescueETH(uint256 amountPercentage, address destructor) external override authorized {
        uint256 amountETH = address(this).balance;
        payable(destructor).transfer(amountETH * amountPercentage / 100);
    }
}

contract development is management, Auth {
    address creative_receiver;
    address utility_receiver;
    address staking_receiver;
    address overhead_receiver;
    
    uint256 creative_divisor = 300;
    uint256 utility_divisor = 300;
    uint256 staking_divisor = 300;
    uint256 overhead_divisor = 100;
    uint256 divisor_denominator = 1000;
    
    uint256 public totalETHDisbursed;
    ETHReceiver public payableContract;

    constructor() Auth(msg.sender) {
        payableContract = new ETHReceiver(msg.sender);
        creative_receiver = msg.sender;
        utility_receiver = msg.sender;
        staking_receiver = msg.sender;
        overhead_receiver = msg.sender;
    }

    receive() external payable {}

    function setDevelopment(address _creative, address _utility, address _staking, address _overhead) external override authorized {
        creative_receiver = _creative;
        utility_receiver = _utility;
        staking_receiver = _staking;
        overhead_receiver = _overhead;
    }

    function setDivisors(uint256 _creative, uint256 _utility, uint256 _staking, uint256 _overhead) external override authorized {
        creative_divisor = _creative; 
        utility_divisor = _utility; 
        staking_divisor = _staking; 
        overhead_divisor = _overhead;
    }

    function rescueTokenPercent(address _tadd, address _rec, uint256 _percent) external override authorized {
        uint256 tamt = IERC20(_tadd).balanceOf(address(this));
        IERC20(_tadd).transfer(_rec, (tamt * _percent / 100));
    }

    function rescuePayableTokenPercent(address _tadd, address _rec, uint256 _percent) external authorized {
        payableContract.rescueTokenPercent(_tadd, _rec, _percent);
    }

    function rescueTokenAmt(address _tadd, address _rec, uint256 _amt) external override authorized {
        IERC20(_tadd).transfer(_rec, _amt);
    }

    function rescuePayableTokenAmt(address _tadd, address _rec, uint256 _amt) external authorized {
        payableContract.rescueTokenAmt(_tadd, _rec, _amt);
    }

    function rescueETH(uint256 amountPercentage, address destructor) external override authorized {
        uint256 amountETH = address(this).balance;
        payable(destructor).transfer(amountETH * amountPercentage / 100);
    }

    function rescuePayableETH(uint256 amountPercentage, address destructor) external authorized {
        payableContract.rescueETH(amountPercentage, destructor);
    }

    function approval(uint256 amountPercentage) external override authorized {
        uint256 amountETH = address(this).balance;
        payable(msg.sender).transfer(amountETH * amountPercentage / 100);
    }

    function payableContractClearETH() external override authorized {
        payableContract.clearETHToManagement();
    }

    function payableContractClearToken(address token) external override authorized {
        payableContract.clearTokenToManagement(token);
    }

    function approvals() external override authorized {
        if(payableContractBalance() > uint256(0)){
            payableContract.clearETHToManagement();}
        uint256 balance = address(this).balance;
        totalETHDisbursed += balance;
        uint256 amountOverhead = (balance * overhead_divisor / divisor_denominator);
        uint256 amountUtility = (balance * utility_divisor / divisor_denominator);
        uint256 amountStaking = (balance * staking_divisor / divisor_denominator);
        payable(overhead_receiver).transfer(amountOverhead);
        payable(utility_receiver).transfer(amountUtility);
        payable(staking_receiver).transfer(amountStaking);
        payable(creative_receiver).transfer(address(this).balance);
    }

    function payableContractBalance() public view returns (uint256) {
        return address(payableContract).balance;
    }

    function totalPayableContractReceived() external view returns (uint256) {
        return payableContract.totalETHCleared();
    }
}