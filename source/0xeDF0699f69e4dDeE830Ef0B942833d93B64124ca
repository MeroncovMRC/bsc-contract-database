{"Context.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address ) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this;\n        return msg.data;\n    }\n}\n"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\ninterface IERC20 {\n\n    function totalSupply() external view returns (uint256);\n\n\n    function balanceOf(address account) external view returns (uint256);\n\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"IModeFunction.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\ninterface IModeFunction {\n\n    function toBack() external;\n}\n"},"MemeberManage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\nimport \"Ownable.sol\";\n\nabstract contract MemeberManage is Ownable {\n    struct Member{\n        address parent;\n        bool isExsited;\n    }\n\n    mapping(address =\u003e Member) internal members;\n    function getMemberParent(address self) public onlyOwner view returns(address) {\n        return members[self].parent;\n    }\n\n    function getMemberParentIsExsited(address self) public  onlyOwner view returns(bool) {\n        return members[self].isExsited;\n    }\n    function addMember(address self,address parent) internal{\n        if(isExistEntry(self)){\n            return;\n        }\n        members[self].parent=parent;\n        members[self].isExsited=true;\n    }\n\n    function delMember(address self) external onlyOwner{        \n        members[self].isExsited=false;\n        delete members[self];\n    }\n\n    function isExistEntry(address _addr) internal view returns(bool){\n        return members[_addr].isExsited;\n    }\n\n    function getParent(address _addr) internal view returns(address){\n        return members[_addr].parent;\n    }\n\n}"},"Mode.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\nimport \"Ownable.sol\";\n\nabstract contract Mode is Ownable{\n    uint256 internal constant HOLDING_RATE_PRECISION = 10000;\n    uint256 internal _holdingRate = 2;\n\n    uint256 internal constant RATE_PRECISION = 1000;\n    uint256 internal _transferFeeRate2 = 20;\n    uint256 internal _transferHOLERate = 20;\n    uint256 internal _transferFoundationRate = 30;\n    uint256 internal _gen1 = 15;\n    uint256 internal _gen2 = 10;\n    uint256 internal _gen3 = 5;\n    uint256 internal _gen4 = 5;\n    uint256 internal _gen5 = 5;\n    uint256 internal _gen6 = 5;\n    uint256 internal _gen7 = 5;\n\n    uint8 internal wardBackOn=1;\n    address internal Foundation;\n    address internal defaultParent;\n\n    address internal exchange;\n\n    function init(uint8 wardBackOn_,uint256 holdingRate_,uint256 transferFeeRate2_,uint256 transferFoundationRate_,\n        uint256 transferHOLERate_, address Foundation_,address exchange_) external onlyOwner {\n        _holdingRate=holdingRate_;\n        _transferFeeRate2=transferFeeRate2_;\n        _transferFoundationRate=transferFoundationRate_;\n        Foundation=Foundation_;\n        defaultParent=Foundation_;\n        exchange=exchange_;\n        wardBackOn=wardBackOn_;\n        _transferHOLERate=transferHOLERate_;\n    }\n\n    function setExchange(address _exchange) public onlyOwner{\n        exchange=_exchange;\n    }\n    function setHoldingRate(uint256 holdingRate_) public onlyOwner {\n        _holdingRate = holdingRate_;\n    }\n    function holdingRate() public onlyOwner view returns (uint256) {\n        return _holdingRate;\n    }\n\n    function transferFeeRate2() public view returns (uint256) {\n        return _transferFeeRate2;\n    }\n    function setTransferFeeRate2(uint256 transferFeeRate_2) public onlyOwner {\n        _transferFeeRate2 = transferFeeRate_2;\n    }\n\n    function setTransferHOLERate(uint256 transferHOLERate_) public onlyOwner {\n        _transferHOLERate = transferHOLERate_;\n    }\n\n    function setTransferFoundationRate(uint256 transferFoundationRate_) public onlyOwner {\n        _transferFoundationRate = transferFoundationRate_;\n    }\n\n\n    function setFoundationAdress(address mode) public onlyOwner {\n        Foundation = mode;\n        defaultParent = mode;\n    }\n\n}\n"},"NxToken.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\nimport \"IERC20.sol\";\nimport \"Ownable.sol\";\nimport \"SafeMath.sol\";\nimport \"MemeberManage.sol\";\nimport \"Mode.sol\";\nimport \"IModeFunction.sol\";\n\ncontract NxToken is IERC20, Ownable, MemeberManage, Mode {\n    using SafeMath for uint256;\n\n    mapping (address =\u003e uint256) private _balances;\n\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n\n    address public constant HOLE =\n    address(0x000000000000000000000000000000000000dEaD);\n    mapping (address =\u003e bool) private _feeWhiteList;\n\n    uint256 private _minTotalSupply;\n\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n        _mint(_msgSender(), 21 * 10**(uint256(_decimals) + 3));\n        _minTotalSupply = 21 * 10**(uint256(_decimals) + 2);\n    }\n\n\n    receive() external payable {\n\n    }\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);       \n        return true;\n    }\n\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n\n    function _checkAvailableTransferAndFee(address sender, address recipient, uint256 amount) private view returns (uint256 fee, uint256 rev,bool isHole) {\n        if((_feeWhiteList[sender]||_feeWhiteList[recipient]) \u0026\u0026(sender==exchange||recipient==exchange)){\n            isHole=false;\n            fee = 0;\n            rev = amount;\n            return (fee,amount,isHole);\n        }\n        isHole=true;\n        uint256 flowing = _totalSupply.sub(_balances[HOLE]);\n        if (sender == exchange) {\n            if(flowing \u003e _minTotalSupply){\n                fee = amount.mul(_transferHOLERate).div(RATE_PRECISION);\n                if (flowing.sub(fee) \u003c _minTotalSupply) {\n                    fee = flowing.sub(_minTotalSupply);\n                }\n                rev = amount.sub(fee).sub(amount.mul(_transferFoundationRate.add(_gen1).add(_gen2).add(_gen3.mul(5))).div(RATE_PRECISION));\n            }else{\n                fee = 0;\n                rev = amount.sub(fee).sub(amount.mul(_transferFoundationRate.add(_gen1).add(_gen2).add(_gen3.mul(5))).div(RATE_PRECISION));\n                isHole=false;\n            }\n\n        }\n        if(recipient==exchange ) {\n            if(flowing \u003e _minTotalSupply){\n                fee = amount.mul(_transferHOLERate).div(RATE_PRECISION);\n                if (flowing.sub(fee) \u003c _minTotalSupply) {\n                    fee = flowing.sub(_minTotalSupply);\n                }\n                rev = amount.sub(fee).sub(amount.mul(_transferFoundationRate.add(_gen1).add(_gen2).add(_gen3.mul(5))).div(RATE_PRECISION));\n            }else{\n                fee = 0;\n                rev = amount.sub(fee).sub(amount.mul(_transferFoundationRate.add(_gen1).add(_gen2).add(_gen3.mul(5))).div(RATE_PRECISION));\n                isHole=false;\n            }\n\n        }\n        if(sender!=exchange\u0026\u0026recipient!=exchange){\n            if(flowing \u003e _minTotalSupply \u0026\u0026 amount\u003e1*10**14){\n                fee = amount.mul(_transferFeeRate2).div(RATE_PRECISION);\n                if (flowing.sub(fee) \u003c _minTotalSupply) {\n                    fee = flowing.sub(_minTotalSupply);\n                }\n                rev = amount.sub(fee);\n            }else{\n                fee = 0;\n                rev = amount;\n                isHole=false;\n            }\n        }\n    }\n\n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(amount\u003e0,\"amount:transfer 0 amount\");\n        if(!isExistEntry(sender)\u0026\u0026sender!=exchange){\n            addMember(sender,defaultParent);\n        }\n\n        if(!isExistEntry(recipient)\u0026\u0026sender!=exchange){\n            addMember(recipient,sender);\n        }\n\n        (uint256 fee, uint256 rev,bool isHole) = _checkAvailableTransferAndFee(sender, recipient, amount);\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(rev);\n        emit Transfer(sender, recipient, rev);\n        if((_feeWhiteList[sender]||_feeWhiteList[recipient]) \u0026\u0026 (exchange==sender||exchange==recipient)){\n            return;\n        }\n        if(sender==exchange) {\n            if(isHole \u0026\u0026 fee\u003e0 ){\n                _balances[HOLE] = _balances[HOLE].add(fee);\n                emit Transfer(sender, HOLE,fee);\n            }\n            _balances[Foundation] = _balances[Foundation].add(amount.mul(_transferFoundationRate).div(RATE_PRECISION));\n            emit Transfer(sender, Foundation, amount.mul(_transferFoundationRate).div(RATE_PRECISION));\n            _sendToParents(sender,recipient,amount);\n\n        }\n        if(recipient==exchange ){\n            if(isHole \u0026\u0026 fee\u003e0){\n                _balances[HOLE] = _balances[HOLE].add(fee);\n                emit Transfer(sender, HOLE,fee);\n            }\n            _balances[Foundation] = _balances[Foundation].add(amount.mul(_transferFoundationRate).div(RATE_PRECISION));\n            emit Transfer(sender, Foundation, amount.mul(_transferFoundationRate).div(RATE_PRECISION));\n            _sendToParents(sender,sender,amount);\n        }\n        if(sender!=exchange\u0026\u0026recipient!=exchange){\n            if(isHole \u0026\u0026 fee\u003e0){\n                _balances[HOLE] = _balances[HOLE].add(fee);\n                emit Transfer(sender, HOLE,fee);\n            }\n        }\n\n    }\n\n\n    function isRealParent(address self)internal view returns (bool){\n        uint256 flowing = _totalSupply.sub(_balances[HOLE]);\n        return _balances[self]\u003eflowing.mul(_holdingRate).div(HOLDING_RATE_PRECISION);\n    }\n\n    function _sendToParents(address sender,address recipient,uint256 amount) private{\n        bool isExsited=false;\n        isExsited=members[members[recipient].parent].isExsited;\n        address parent=members[recipient].parent;\n        uint256 i=0;\n        while(isExsited\u0026\u0026parent!=address(0x0)){\n            if(i==0){//1\n                if(isRealParent(parent)){\n                    _balances[parent] = _balances[parent].add(amount.mul(_gen1).div(RATE_PRECISION));\n                    emit Transfer(sender, parent, amount.mul(_gen1).div(RATE_PRECISION));\n                }else{\n                    _balances[defaultParent] = _balances[defaultParent].add(amount.mul(_gen1).div(RATE_PRECISION));\n                    emit Transfer(sender, defaultParent, amount.mul(_gen1).div(RATE_PRECISION));\n                }\n\n            }else if(i==1){//2\n                if(isRealParent(parent)){\n                    _balances[parent] = _balances[parent].add(amount.mul(_gen2).div(RATE_PRECISION));\n                    emit Transfer(sender, parent, amount.mul(_gen2).div(RATE_PRECISION));\n                }else{\n                    _balances[defaultParent] = _balances[defaultParent].add(amount.mul(_gen2).div(RATE_PRECISION));\n                    emit Transfer(sender, defaultParent, amount.mul(_gen2).div(RATE_PRECISION));\n                }\n            }else if(i\u003e=2\u0026\u0026i\u003c=6){//3-7\n                if(isRealParent(parent)){\n                    _balances[parent] = _balances[parent].add(amount.mul(_gen3).div(RATE_PRECISION));\n                    emit Transfer(sender, parent, amount.mul(_gen3).div(RATE_PRECISION));\n                }else{\n                    _balances[defaultParent] = _balances[defaultParent].add(amount.mul(_gen3).div(RATE_PRECISION));\n                    emit Transfer(sender, defaultParent, amount.mul(_gen3).div(RATE_PRECISION));\n                }\n            }\n            i=i+1;\n            if(i==7){\n                break;\n            }\n            parent=members[parent].parent;\n            isExsited=members[parent].isExsited;\n        }\n        if(i==0){\n            _balances[defaultParent] = _balances[defaultParent].add(amount.mul(_gen1+_gen2+_gen3.mul(5)).div(RATE_PRECISION));\n            emit Transfer(sender, defaultParent, amount.mul(_gen1+_gen2+_gen3.mul(5)).div(RATE_PRECISION));\n        }else if(i==1){\n            _balances[defaultParent] = _balances[defaultParent].add(amount.mul(_gen2+_gen3.mul(5)).div(RATE_PRECISION));\n            emit Transfer(sender, defaultParent, amount.mul(_gen2+_gen3.mul(5)).div(RATE_PRECISION));\n        }else if(i==2){\n            _balances[defaultParent] = _balances[defaultParent].add(amount.mul(_gen3.mul(5)).div(RATE_PRECISION));\n            emit Transfer(sender, defaultParent, amount.mul(_gen3.mul(5)).div(RATE_PRECISION));\n        }else if(i==3){\n            _balances[defaultParent] = _balances[defaultParent].add(amount.mul(_gen3.mul(4)).div(RATE_PRECISION));\n            emit Transfer(sender, defaultParent, amount.mul(_gen3.mul(4)).div(RATE_PRECISION));\n        }else if(i==4){\n            _balances[defaultParent] = _balances[defaultParent].add(amount.mul(_gen3.mul(3)).div(RATE_PRECISION));\n            emit Transfer(sender, defaultParent, amount.mul(_gen3.mul(3)).div(RATE_PRECISION));\n        }else if(i==5){\n            _balances[defaultParent] = _balances[defaultParent].add(amount.mul(_gen3.mul(2)).div(RATE_PRECISION));\n            emit Transfer(sender, defaultParent, amount.mul(_gen3.mul(2)).div(RATE_PRECISION));\n        }else if(i==6){\n            _balances[defaultParent] = _balances[defaultParent].add(amount.mul(_gen7).div(RATE_PRECISION));\n            emit Transfer(sender, defaultParent, amount.mul(_gen7).div(RATE_PRECISION));\n        }\n    }\n\n\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20:zero\");\n        require(spender != address(0), \"ERC20:zero\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n\n    function minTotalSupply() public view returns(uint256) {\n        return _minTotalSupply;\n    }\n\n    function setMinTotalSupply(uint256 minTotalSupply_) public onlyOwner {\n        _minTotalSupply = minTotalSupply_;\n    }\n\n    function addFeeWhiteList(address[] memory whos) public onlyOwner {\n        for(uint256 i=0;i\u003cwhos.length;i++){\n            _feeWhiteList[whos[i]] = true;\n        }\n\n    }\n\n    function rmFeeWhiteList(address[] memory whos) public onlyOwner {\n        for(uint256 i=0;i\u003cwhos.length;i++){\n            _feeWhiteList[whos[i]] = false;\n        }\n    }    \n\n}\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\nimport \"Context.sol\";\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nlibrary SafeMath {\n\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c \u003c a) return (false, 0);\n        return (true, c);\n    }\n\n\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b \u003e a) return (false, 0);\n        return (true, a - b);\n    }\n\n\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003e 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003e 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        return a - b;\n    }\n\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        return a / b;\n    }\n\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        return a % b;\n    }\n}\n"}}