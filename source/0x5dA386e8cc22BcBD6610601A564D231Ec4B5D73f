{"BUSDKingdom.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// WEB | https://busdkingdom.online\r\n// TG | https://t.me/busdkingdom\r\n// TW | https://twitter.com/busdkingdom\r\n\r\npragma solidity ^0.8.7;\r\npragma experimental ABIEncoderV2;\r\nimport \"./IERC20.sol\";\r\n\r\ncontract BUSDKingdom {\r\n    struct Tower {\r\n        uint256 crystals;\r\n        uint256 money;\r\n        uint256 money2;\r\n        uint256 yield;\r\n        uint256 timestamp;\r\n        uint256 hrs;\r\n        address ref;\r\n        uint256 refs;\r\n        uint256 refDeps;\r\n        uint8   treasury;\r\n        uint8[5] chefs;\r\n    }\r\n\r\n    mapping(address =\u003e Tower) public towers;\r\n\r\n    uint256 public totalChefs;\r\n    uint256 public totalTowers;\r\n    uint256 public totalInvested;\r\n    address public manager;\r\n\r\n    IERC20 constant BUSD_TOKEN = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\r\n\r\n    uint256 immutable public denominator = 10;\r\n    bool public init;\r\n\r\n    modifier initialized {\r\n      require(init, \u0027Not initialized\u0027);\r\n      _;\r\n    }\r\n\r\n    constructor(address manager_) {\r\n       manager = manager_;\r\n    }\r\n\r\n\r\n    function initialize() external {\r\n      require(manager == msg.sender);\r\n      require(!init);\r\n      init = true;\r\n    }\r\n\r\n    function addCrystals(address ref, uint256 value) initialized external {\r\n        uint256 crystals = value / 2e17;\r\n        require(crystals \u003e 0, \"Zero crystals\");\r\n        address user = msg.sender;\r\n        totalInvested += value;\r\n        if (towers[user].timestamp == 0) {\r\n            totalTowers++;\r\n            ref = towers[ref].timestamp == 0 ? manager : ref;\r\n            towers[ref].refs++;\r\n            towers[user].ref = ref;\r\n            towers[user].timestamp = block.timestamp;\r\n            towers[user].treasury = 0;\r\n        }\r\n        ref = towers[user].ref;\r\n        towers[ref].crystals += (crystals * 8) / 100;\r\n        towers[ref].money += (crystals * 100 * 4) / 100;\r\n        towers[ref].refDeps += crystals;\r\n        towers[user].crystals += crystals;\r\n        towers[manager].crystals += (crystals * 8) / 100;\r\n\r\n        uint256 valueToManager = (value * 5) / 100;\r\n        BUSD_TOKEN.transferFrom(msg.sender, manager, valueToManager);\r\n        BUSD_TOKEN.transferFrom(msg.sender, address(this), value - valueToManager);\r\n    }\r\n\r\n    function withdrawMoney(uint256 gold) initialized external {\r\n        address user = msg.sender;\r\n        require(gold \u003c= towers[user].money \u0026\u0026 gold \u003e 0);\r\n        towers[user].money -= gold;\r\n        uint256 amount = gold * 2e15;\r\n        BUSD_TOKEN.transfer(user, BUSD_TOKEN.balanceOf(address(this)) \u003c amount ? BUSD_TOKEN.balanceOf(address(this)) : amount);\r\n    }\r\n\r\n    function collectMoney() public {\r\n        address user = msg.sender;\r\n        syncTower(user);\r\n        towers[user].hrs = 0;\r\n        towers[user].money += towers[user].money2;\r\n        towers[user].money2 = 0;\r\n    }\r\n\r\n    function upgradeTower(uint256 towerId) initialized external {\r\n        require(towerId \u003c 5, \"Max 5 towers\");\r\n        address user = msg.sender;\r\n        syncTower(user);\r\n        towers[user].chefs[towerId]++;\r\n        totalChefs++;\r\n        uint256 chefs = towers[user].chefs[towerId];\r\n        towers[user].crystals -= getUpgradePrice(towerId, chefs) / denominator;\r\n        towers[user].yield += getYield(towerId, chefs);\r\n    }\r\n\r\n    function upgradeTreasury() external {\r\n      address user = msg.sender;\r\n      uint8 treasuryId = towers[user].treasury + 1;\r\n      syncTower(user);\r\n      require(treasuryId \u003c 5, \"Max 5 treasury\");\r\n      (uint256 price,) = getTreasure(treasuryId);\r\n      towers[user].crystals -= price / denominator; \r\n      towers[user].treasury = treasuryId;\r\n    }\r\n\r\n     function sellTower() external {\r\n        collectMoney();\r\n        address user = msg.sender;\r\n        uint8[5] memory chefs = towers[user].chefs;\r\n        totalChefs -= chefs[0] + chefs[1] + chefs[2] + chefs[3] + chefs[4];\r\n        towers[user].money += towers[user].yield * 24 * 5;\r\n        towers[user].chefs = [0, 0, 0, 0, 0];\r\n        towers[user].yield = 0;\r\n        towers[user].treasury = 0;\r\n    }\r\n\r\n    function getChefs(address addr) external view returns (uint8[5] memory) {\r\n        return towers[addr].chefs;\r\n    }\r\n\r\n    function syncTower(address user) internal {\r\n        require(towers[user].timestamp \u003e 0, \"User is not registered\");\r\n        if (towers[user].yield \u003e 0) {\r\n            (, uint256 treasury) = getTreasure(towers[user].treasury);\r\n            uint256 hrs = block.timestamp / 3600 - towers[user].timestamp / 3600;\r\n            if (hrs + towers[user].hrs \u003e treasury) {\r\n                hrs = treasury - towers[user].hrs;\r\n            }\r\n            towers[user].money2 += hrs * towers[user].yield;\r\n            towers[user].hrs += hrs;\r\n        }\r\n        towers[user].timestamp = block.timestamp;\r\n    }\r\n\r\n    function getUpgradePrice(uint256 towerId, uint256 chefId) internal pure returns (uint256) {\r\n        if (chefId == 1) return [400, 4000, 12000, 24000, 40000][towerId];\r\n        if (chefId == 2) return [600, 6000, 18000, 36000, 60000][towerId];\r\n        if (chefId == 3) return [900, 9000, 27000, 54000, 90000][towerId];\r\n        if (chefId == 4) return [1360, 13500, 40500, 81000, 135000][towerId];\r\n        if (chefId == 5) return [2040, 20260, 60760, 121500, 202500][towerId];\r\n        if (chefId == 6) return [3060, 30400, 91140, 182260, 303760][towerId];\r\n        revert(\"Incorrect chefId\");\r\n    }\r\n\r\n    function getYield(uint256 towerId, uint256 chefId) internal pure returns (uint256) {\r\n        if (chefId == 1) return [5, 56, 179, 382, 678][towerId];\r\n        if (chefId == 2) return [8, 85, 272, 581, 1030][towerId];\r\n        if (chefId == 3) return [12, 128, 413, 882, 1564][towerId];\r\n        if (chefId == 4) return [18, 195, 628, 1340, 2379][towerId];\r\n        if (chefId == 5) return [28, 297, 954, 2035, 3620][towerId];\r\n        if (chefId == 6) return [42, 450, 1439, 3076, 5506][towerId];\r\n        revert(\"Incorrect chefId\");\r\n    }\r\n\r\n    function getTreasure(uint256 treasureId) internal pure returns (uint256, uint256) {\r\n      if(treasureId == 0) return (0, 24); // price | value\r\n      if(treasureId == 1) return (2000, 30);\r\n      if(treasureId == 2) return (2500, 36);\r\n      if(treasureId == 3) return (3000, 42);\r\n      if(treasureId == 4) return (4000, 48);\r\n      revert(\"Incorrect treasureId\");\r\n    }\r\n}"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller\u0027s account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}"}}