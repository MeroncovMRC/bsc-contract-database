// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;


interface IERC20 {
    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Approval(address indexed owner, address indexed spender, uint256 value);

    
    function totalSupply() external view returns (uint256);

    
    function balanceOf(address account) external view returns (uint256);

    
    function transfer(address to, uint256 amount) external returns (bool);

    
    function allowance(address owner, address spender) external view returns (uint256);

    
    function approve(address spender, uint256 amount) external returns (bool);

    
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
}

contract TokenLockAILI {
    
    IERC20 public token;
    
    uint256 private constant DECIMAL_MULTIPLIER = 1e8;
    
    uint256 private constant INITIAL_DAILY_UNLOCK = 21600 * DECIMAL_MULTIPLIER;
    
    uint256 private constant PERIOD_DAYS = 90;
    
    uint256 private constant TOTAL_DAYS = 360;
    
    uint256 private constant MIN_DAILY_UNLOCK = 1000 * DECIMAL_MULTIPLIER;

    
    uint256 public startTimestamp;
    
    uint256 public unlockedToken;
    
    uint256 public lastUnlockTimestamp;
    
    address public owner;

    
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner can call this function.");
        _;
    }

    
    event UnlockEvent(uint256 indexed amount, uint256 indexed timestamp);
    
    event TransferEvent(address indexed to, uint256 indexed amount);

    
    
    constructor(address _token) {
        
        require(_token != address(0), "Token address cannot be zero address.");
        
        token = IERC20(_token);

        
        
        startTimestamp = block.timestamp - 1 days;

        lastUnlockTimestamp = startTimestamp;
        
        owner = msg.sender;
    }

    
    
    function unlock() external onlyOwner {
        
        require(block.timestamp - lastUnlockTimestamp >= 1 days, "The time since the last unlock is less than one day.");
        
        require(token.balanceOf(address(this)) >= MIN_DAILY_UNLOCK, "Insufficient balance");
        
        uint256 daysSinceStart = (block.timestamp - startTimestamp) / 1 days;
        
        uint256 periodsSinceStart = daysSinceStart / PERIOD_DAYS;
        
        uint256 dailyUnlock;

        
        if (daysSinceStart >= TOTAL_DAYS) {
            dailyUnlock = MIN_DAILY_UNLOCK;
        } else {
            
            dailyUnlock = INITIAL_DAILY_UNLOCK / 2 ** periodsSinceStart;
        }

        
        uint256 daysSinceLastUnlock = daysSinceStart - (lastUnlockTimestamp - startTimestamp) / 1 days;
        
        uint256 newUnlockedToken = daysSinceLastUnlock * dailyUnlock;

        
        unlockedToken += newUnlockedToken;
        
        lastUnlockTimestamp = block.timestamp;

        
        emit UnlockEvent(newUnlockedToken, block.timestamp);
    }

    
    function transfer(address to, uint256 amount) external onlyOwner {
        
        require(to != address(0), "Recipient address cannot be zero address.");
        require(to != address(this), "Recipient address cannot be contract address.");
        
        require(unlockedToken >= amount, "Not enough unlocked tokens.");

        
        unlockedToken -= amount;
        
        token.transfer(to, amount);

        
        emit TransferEvent(to, amount);
    }
}