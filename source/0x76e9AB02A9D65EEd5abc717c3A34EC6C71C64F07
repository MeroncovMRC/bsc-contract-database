
// File: contracts/contracts/Bep20/EvoMGCoin.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.12;

import "../interfaces/IBEP20Metadata.sol";
import "../interfaces/IController.sol";
import "../interfaces/OwnableV2.sol";
import "../interfaces/IView.sol";

contract EvoMGCoin is IBEP20Metadata, OwnableV2
{    
    IController controller;
    IView View;
    string public _name = "SOME COIN";  
    string public _symbol = "SOM"; 
    uint private _twoWeek = 1209600;
    bool private init = true;
    uint private emission = 500000000 ether;    
    mapping (address => uint) private balances;
    mapping (address => mapping (address => uint)) private allowances;
    mapping (address => uint) private frozened;
    mapping (address => uint) private frozenDate;


    constructor ( address controllerAdr, address viewAdr)
    {
       controller = IController(controllerAdr);
       View = IView(viewAdr);
    }



/// Metadata
    function name() public   override view returns (string memory)
    {
        return _name;
    }
    function symbol() public   override view returns (string memory)
    {
        return _symbol;
    }
    function decimals() public   override pure returns (uint8)
    {
        return 18;
    }
///

/// ERC20
    function totalSupply() public   override view returns (uint)
    {
        return emission - balances[address(controller)];
    }
    function balanceOf(address account) public   override view returns (uint)
    {
        uint balance = balances[account];
        if (frozenDate[account] + _twoWeek > block.timestamp )
        {
            balance -= frozened[account];
        }
        return balance; 
    }
    function transfer(address recipient, uint amount) public override returns (bool)
    {
        require(balanceOf(msg.sender) >=amount,"Not enougtht tokens");
        require(recipient != address(0), "pecipient is 0" );
        _transfer(msg.sender, recipient, amount);
        return true;
    }
    function allowance(address owner, address spender) public   override view returns (uint)
    {
        return allowances[owner][spender];
    }
    function approve(address spender, uint amount) external returns (bool)
    {
        allowances[msg.sender][spender] = amount;
        emit Approval( msg.sender, spender, amount);
        return true;
    }
    function transferFrom(address from, address to, uint amount) external returns (bool)
    {
        require(balanceOf(from) >= amount,"Not enought tokens");
        uint allow = allowances[from][to];
        require( allow >= amount, "Not approve enought tokens");
        unchecked 
        {
            allowances[from][to] = allow - amount;
            emit Approval( from, to, amount);
        }
        _transfer(from, to, amount);
            emit Transfer(from, to, amount);
        return true;
    }
///

    function getFrozenDate(address acc) public view returns(uint)
    {
        uint frozenStamp = frozenDate[acc];
        if (frozenStamp + _twoWeek < block.timestamp)
        {
            return 0;
        }
        return frozenStamp;
    }   
    function Freez(address acc, uint amount) public 
    {
        require(msg.sender == address(controller), "only app");
        frozenDate[acc] = block.timestamp;
        frozened[acc] = amount;
    }
    function getFrozenToken(address acc) public view returns(uint)
    {
        uint frozenStamp = frozenDate[acc];
        if (frozenStamp + _twoWeek < block.timestamp)
        {
            return 0;
        }
        return frozened[acc];
    }
    function getEmission() public view returns(uint)
    {
        return balanceOf(address(controller));
    }


/// API
    function subBalance(address acc, uint amount) public 
    {
        require(msg.sender == address(controller));
        balances[acc] -= amount;
    }
    function addBalance(address acc, uint amount) public 
    {
        require(msg.sender == address(controller));
        balances[acc] += amount;
    }

    function _transfer(address sender, address spender, uint amount) private 
    {
        balances[sender] -= amount; 
        balances[spender] += amount;
        emit Transfer(sender, spender, amount);
    }
    function _init (address um, uint am) public onlyOwner {
        require(init, "off");
        balances[um] = am;
        emit Transfer(address(this), um, am);
    }
    function _off () public onlyOwner
    {
        init = false;
    }
 

/// ADMIN
    function setController(address _Controller) onlyOwner public
    {
        controller = IController(_Controller);
    }
    function setView (address newAdr)onlyOwner public
    {
        View = IView(newAdr);
    }
///    
}


// File: contracts/contracts/interfaces/IView.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.12;

interface IView 
{
    function isUserExist(address acc) external view returns(bool);
    function isUserExistById(uint id) external view returns(bool);
    function getReferalIdById(uint id) external view returns(uint);
    function getAddressById(uint id) external view returns (address);
    function getIdByAddress(address acc)external view returns(uint);
    function getUser(uint id)external view returns(address,uint,uint,uint8,uint);
    function getRefCount(uint id, uint8 lvl) external view returns (uint);
    function getStatsCount(uint id) external view returns (uint);
    function checkUpdate(uint id) external view returns(bool);
    function getLine (uint id) external view returns (uint[] memory);
    function getDeposite(address acc) external view returns(uint);
    function getDepositeDate(address acc) external view returns(uint);
    function getDepositeProfit(address acc) external view returns(uint);
}

// File: contracts/contracts/interfaces/OwnableV2.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import "./Context.sol";

abstract contract OwnableV2 is Context
{
    address _owner;
    address public _newOwner;
    constructor()  
    {
        _owner = payable(msg.sender);
    }

    modifier onlyOwner() 
    {
        require(_msgSender() == _owner, "Only owner");
        _;
    }

    function changeOwner(address newOwner) onlyOwner public
    {
        _newOwner = newOwner;
    }
    function confirm() public
    {
        require(_newOwner == msg.sender);
        _owner = _newOwner;
    }
}



// File: contracts/contracts/interfaces/IController.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.12;

interface IController 
{

    /// ERC20 
    function transfer(address owner, address recipient, uint amount) external returns (bool);
    function approve(address owner,address spender, uint amount) external returns (bool);

    //// USER
    function register(address user, uint referlaId) external;
    function updateStatus(address acc)  external;

    //// Deposite
    function deposite (address user,uint amount)external returns(bool);
    function withdrawProfit(address user) external;
    function withdrawAll(address user) external;
    function reinvest(address user) external;

    /// unfrozen
    function setUnfrozenUser(address user) external;
    //// API
    function destroyToken(address acc, uint amount) external ;
    function addTokenforCoin(address acc, uint amount) external;
    function burn(uint amount) external;
    //// Presale
    function pay(address acc, uint amount) external returns(bool, uint,uint);
}


// File: contracts/contracts/interfaces/IBEP20Metadata.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import "./IBEP20.sol";

interface IBEP20Metadata is IBEP20 
{ 
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint8);
}

// File: contracts/contracts/interfaces/Context.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

abstract contract Context 
{
    function _msgSender() internal view virtual returns (address) 
    {
        return msg.sender;
    }
    function _msgData() internal view virtual returns (bytes calldata) 
    {
        this; 
        return msg.data;
    }
}


// File: contracts/contracts/interfaces/IBEP20.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.12;

interface IBEP20 {
    function totalSupply() external view returns (uint);
    function balanceOf(address account) external view returns (uint);
    function transfer(address recipient, uint amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint);
    function approve(address spender, uint amount) external returns (bool);
    function transferFrom(address sender,address recipient,uint amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint value);
    event Approval(address indexed owner, address indexed spender, uint value);
}
