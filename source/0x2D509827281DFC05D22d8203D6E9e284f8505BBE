// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// File: @openzeppelin/contracts/utils/introspection/IERC165.sol


// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)


/**
 * @dev Interface of the ERC165 standard, as defined in the
 * https://eips.ethereum.org/EIPS/eip-165[EIP].
 *
 * Implementers can declare support of contract interfaces, which can then be
 * queried by others ({ERC165Checker}).
 *
 * For an implementation, see {ERC165}.
 */
interface IERC165 {
    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

// File: @openzeppelin/contracts/utils/introspection/ERC165.sol


// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)

pragma solidity ^0.8.0;


/**
 * @dev Implementation of the {IERC165} interface.
 *
 * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
 * for the additional interface id that will be supported. For example:
 *
 * ```solidity
 * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 * }
 * ```
 *
 * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
 */
abstract contract ERC165 is IERC165 {
    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IERC165).interfaceId;
    }
}

// File: @openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol


// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)

pragma solidity ^0.8.0;


/**
 * @dev _Available since v3.1._
 */
interface IERC1155Receiver is IERC165 {
    /**
     * @dev Handles the receipt of a single ERC1155 token type. This function is
     * called at the end of a `safeTransferFrom` after the balance has been updated.
     *
     * NOTE: To accept the transfer, this must return
     * `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`
     * (i.e. 0xf23a6e61, or its own function selector).
     *
     * @param operator The address which initiated the transfer (i.e. msg.sender)
     * @param from The address which previously owned the token
     * @param id The ID of the token being transferred
     * @param value The amount of tokens being transferred
     * @param data Additional data with no specified format
     * @return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` if transfer is allowed
     */
    function onERC1155Received(
        address operator,
        address from,
        uint256 id,
        uint256 value,
        bytes calldata data
    ) external returns (bytes4);

    /**
     * @dev Handles the receipt of a multiple ERC1155 token types. This function
     * is called at the end of a `safeBatchTransferFrom` after the balances have
     * been updated.
     *
     * NOTE: To accept the transfer(s), this must return
     * `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`
     * (i.e. 0xbc197c81, or its own function selector).
     *
     * @param operator The address which initiated the batch transfer (i.e. msg.sender)
     * @param from The address which previously owned the token
     * @param ids An array containing ids of each token being transferred (order and length must match values array)
     * @param values An array containing amounts of each token being transferred (order and length must match ids array)
     * @param data Additional data with no specified format
     * @return `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))` if transfer is allowed
     */
    function onERC1155BatchReceived(
        address operator,
        address from,
        uint256[] calldata ids,
        uint256[] calldata values,
        bytes calldata data
    ) external returns (bytes4);
}

// File: @openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol


// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)

pragma solidity ^0.8.0;



/**
 * @dev _Available since v3.1._
 */
abstract contract ERC1155Receiver is ERC165, IERC1155Receiver {
    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);
    }
}

// File: @openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol


// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)

pragma solidity ^0.8.0;


/**
 * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.
 *
 * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be
 * stuck.
 *
 * @dev _Available since v3.1._
 */
contract ERC1155Holder is ERC1155Receiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes memory
    ) public virtual override returns (bytes4) {
        return this.onERC1155Received.selector;
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] memory,
        uint256[] memory,
        bytes memory
    ) public virtual override returns (bytes4) {
        return this.onERC1155BatchReceived.selector;
    }
}

// File: contracts/BeanQuest/BeanQuestGuilds.sol


pragma solidity ^0.8.0;


contract BeanQuestGuilds is ERC1155Holder {

    //MAINNET

    BeanQuestNFTs nft = BeanQuestNFTs(0xcF807B56F5c59B11A6e5448E6D40CBA2c84874EA);
    BeanQuest miner = BeanQuest(0x9f5FcfeaaF8aA60cB4239d53507429b8cC86b015);
    BeanQuestGacha gacha = BeanQuestGacha(0x6759dda0e5f4e4205DDF8909FDEF33EBdcB251Ca);

    //TESTNET
    
    // BeanQuestNFTs nft = BeanQuestNFTs(0xB97D65122bc263DB4EAbCdBFA970785Bc776Ea76);
    // BeanQuest miner = BeanQuest(0xf70743A8e05261FB9E54211098D8ede0BDBA00eC);
    // BeanQuestGacha gacha = BeanQuestGacha(0xeaa1b72106b7fAbB7721Ad30b4037533F3273B87);
    
    BeanQuestGuildBosses raidBoss = BeanQuestGuildBosses(address(0));

    function setContracts(address _nft, address _miner, address _raidBoss, address _gacha, address _dev) public {
        require(msg.sender == dev, "Unauthorized");
        nft = BeanQuestNFTs(_nft);
        miner = BeanQuest(_miner);
        gacha = BeanQuestGacha(_gacha);
        raidBoss = BeanQuestGuildBosses(_raidBoss);
        dev = _dev;
    }  

    struct Relic {
        string relicName;
        uint256 multiplier;
        uint8 bonusType;
        bool consumable;
    }
    
    struct Guild{
        string name;
        string tag;
        uint hall;
        address[] members;
        address[] guildMasters;
        bool bossActive;
        uint bossId;
        uint bossHealth;
        uint pooledForBoss;
        uint timeBossActivated;
        uint guildDamageDealt;
        uint bossesKilled;
    }

    Guild[] public guilds;

    mapping(string => bool) public isInUseName;
    mapping(string => bool) public isInUseTag;


    mapping(uint => mapping(uint => uint)) public itemsInGuildBank;

    mapping(uint => mapping(address => uint)) public depositedByUser;
    mapping(address => uint) public playerToGuild;
    mapping(address => uint) public damageDealt;
    mapping(address => uint) public globalDamageDealt;
    mapping(uint => mapping(uint => uint)) public bossTypesKilled;
    uint public guildCreationCost = 0 ether;

    function setGuildCreationCost(uint newCost) public {
        require(msg.sender == dev, "Unauthorized");
        guildCreationCost = newCost;
    }

    
    event GuildCreated(string userName, string guildName);
    event GuildPromotion(string guildName, string namePromoter, string namePromoted);

    address dev;


    constructor() {
        guilds.push(Guild("", "", 0, new address[](0), new address[](0), false, 0, 0, 0, 0, 0, 0));
        dev = msg.sender;
    }

    /////////////////////////////
    // GUILD Item Bank Functions
    /////////////////////////////

    function depositItem(uint item, uint amount) public {
        uint guild = playerToGuild[msg.sender];
        require(guild != 0, "You are not in a guild");
        require(nft.balanceOf(msg.sender, item) >= amount, "You do not have the items you are trying to deposit");
        nft.safeTransferFrom(msg.sender, address(this), item, amount, "");
        itemsInGuildBank[guild][item] += amount;
    }

    function withdrawItem(uint item, uint amount) public {
        uint guild = playerToGuild[msg.sender];
        require(guild != 0, "You are not in a guild");
        require(nft.balanceOf(address(this), item) >= amount, "The Bank contract does not have this item in it's wallet");
        require(itemsInGuildBank[guild][item] >= amount, "This item is not in your guilds bank");
        itemsInGuildBank[guild][item] -= amount;
        nft.safeTransferFrom(address(this), msg.sender, item, amount, "");
    }

    function poolForBoss() public payable {
        uint guild = playerToGuild[msg.sender];
        require(guild != 0, "You are not in a guild");
        require(guilds[guild].bossId != 0, "No boss selected");
        require(!guilds[guild].bossActive, "Your guild is already fighting a boss");
        require(guilds[guild].pooledForBoss + msg.value <= raidBoss.price(guilds[guild].bossId), "You cannot pool more BNB than the price of the boss you are trying to fight");
        depositedByUser[guild][msg.sender] += msg.value;
        guilds[guild].pooledForBoss += msg.value;
    }

    function withdrawFromPool() public {
        uint guild = playerToGuild[msg.sender];
        require(guild != 0, "You do not have a guild");
        require(depositedByUser[guild][msg.sender] > 0, "You did not deposit into the pool");
        uint deposit = depositedByUser[guild][msg.sender];
        depositedByUser[guild][msg.sender] = 0;
        guilds[guild].pooledForBoss -= deposit;
        sendBeans(msg.sender, deposit);
    }

    function sendDepositBackToAll() public {
        uint guild = playerToGuild[msg.sender];
        (bool isMaster,) = checkIfGuildMaster(msg.sender, guild);
        require(isMaster, "Only a Guild Master can do this");
        require(!guilds[guild].bossActive, "Cannot do this while a Boss Fight is active");
        require(guilds[guild].pooledForBoss > 0, "There is no amount pooled for the boss");
        for(uint i; i < guilds[guild].members.length; i++) {
            if(depositedByUser[guild][guilds[guild].members[i]] > 0) {
                sendBeans(guilds[guild].members[i], depositedByUser[guild][guilds[guild].members[i]]);
                depositedByUser[guild][guilds[guild].members[i]] = 0;
            }
        }
        guilds[guild].pooledForBoss = 0;
    }

    function sendBeans(address to, uint amount) internal {
        (bool success,) = to.call{value : amount}("");
        require(success);
    }


    /////////////////////////////
    // GUILD Management Functions
    /////////////////////////////

    function createGuild(string memory name, string memory tag, uint hall) public payable {
        require(_checkName(name, false), "This Guild Name is either already in use or is longer than the limit of 15 characters");
        require(_checkName(tag, true), "This Guild Tag is either already in use or is longer than the limit of 5 characters");
        isInUseName[name] = true;
        isInUseTag[tag] = true;
        address[] memory a = new address[](1);
        a[0] = msg.sender;
        playerToGuild[msg.sender] = guilds.length;
        guilds.push(Guild(name, tag, hall, a, a, false, 0, 0, 0, 0, 0, 0));
        emit GuildCreated(miner.getNicknameToAddress(msg.sender), name);
    }

    function leaveGuild() public {
        uint guild = playerToGuild[msg.sender];
        require(playerToGuild[msg.sender] != 0, "This player is already part of a guild");
        require(msg.sender != guilds[guild].members[0], "The Guild Leader cannot leave the Guild");
        (bool isMaster, uint masterId) = checkIfGuildMaster(msg.sender, guild);
        if(isMaster) {
            deleteFromArray(guild, masterId, true);
        }
        uint id = checkMemberNumber(msg.sender, guild);
        deleteFromArray(guild, id, false);
        if(depositedByUser[guild][msg.sender] > 0) {
            sendBeans(msg.sender, depositedByUser[guild][msg.sender]);
            guilds[guild].pooledForBoss -= depositedByUser[guild][msg.sender];
            depositedByUser[guild][msg.sender] = 0;
        }
        playerToGuild[msg.sender] = 0;
        damageDealt[msg.sender] = 0;
    }

    function transferLeadership(address user) public {
        uint guild = playerToGuild[msg.sender];
        require(msg.sender == guilds[guild].members[0], "Only the Guild Leader can transfer leadership of the Guild");
        require(playerToGuild[user] == guild, "The person you are transferring to, must be part of your guild");
        (bool isMaster, uint masterId) = checkIfGuildMaster(user, guild);
        if(isMaster) {
            deleteFromArray(guild, masterId, true);
        }
        uint id = checkMemberNumber(user, guild);
        deleteFromArray(guild, id, false);
        guilds[guild].members[0] = user;
        guilds[guild].guildMasters[0] = user;
        guilds[guild].members.push(msg.sender);
        guilds[guild].guildMasters.push(msg.sender);
    }

    function endGuild() public {
        uint guild = playerToGuild[msg.sender];
        require(msg.sender == guilds[guild].members[0], "Only the Guild Leader can transfer leadership of the Guild");
        require(guilds[guild].members.length == 1, "You cannot have anyone else in the guild if you wish to end it");
        require(guilds[guild].bossActive, "You cannot do this while a boss is active");
        playerToGuild[msg.sender] = 0;
        isInUseName[guilds[guild].name] = false;
        isInUseTag[guilds[guild].tag] = false;
        guilds[guild].name = "";
        guilds[guild].tag = "";
    }

    function addToGuild(address user) public {
        uint guild = playerToGuild[msg.sender];
        (bool isMaster,) = checkIfGuildMaster(msg.sender, guild);
        require(isMaster, "You are not a Guild Master in this Guild");
        require(playerToGuild[user] == 0, "This player is already part of a guild");
        playerToGuild[user] = guild;
        guilds[guild].members.push(user);
    }

    function promoteToGuildMaster(address user) public {
        uint guild = playerToGuild[msg.sender];
        require(playerToGuild[user] == guild, "User is not in the same Guild");
        require(msg.sender == guilds[guild].members[0], "Only the Guild Leader can promote someone to Guild Master");
        (bool isMaster,) = checkIfGuildMaster(user, guild);
        require(!isMaster, "The user you are trying to promote is already a Guild Master");
        guilds[guild].guildMasters.push(user);
        emit GuildPromotion(guilds[guild].name, miner.getNicknameToAddress(msg.sender), miner.getNicknameToAddress(user));
    }

    function demoteFromGuildMaster(address user) public {
        uint guild = playerToGuild[msg.sender];
        require(playerToGuild[user] == guild, "User is not in the same Guild");
        require(msg.sender == guilds[guild].members[0], "Only the Guild Leader can demote a Guild Master");
        require(user != msg.sender, "You cannot demote yourself as Guild Leader");
        (bool isMaster, uint id) = checkIfGuildMaster(user, guild);
        require(isMaster, "The user you are trying to demote is not a Guild Master");
        deleteFromArray(guild, id, true);
    }

    function kickFromGuild(address user) public {
        uint guild = playerToGuild[msg.sender];
        require(playerToGuild[user] == guild, "User is not in the same Guild");
        (bool isMaster, uint senderId) = checkIfGuildMaster(msg.sender, guild);
        require(user != msg.sender, "You cannot kick yourself from the Guild");
        require(isMaster, "You are not a Guild Master in this Guild");
        (bool isAlsoMaster, uint masterId) = checkIfGuildMaster(user, guild);
        if(isAlsoMaster) {
            require(senderId == 0, "Only the Guild Leader can kick a Master");
            deleteFromArray(guild, masterId, true);
        }
        if(depositedByUser[guild][user] > 0) {
            sendBeans(user, depositedByUser[guild][user]);
            guilds[guild].pooledForBoss -= depositedByUser[guild][user];
            depositedByUser[guild][user] = 0;
        }
        uint id = checkMemberNumber(user, guild);
        deleteFromArray(guild, id, false);
        playerToGuild[user] = 0;
        damageDealt[user] = 0;
    }

    function changeGuildNameAndHall(string memory name, string memory tag, uint hall) public {
        uint guild = playerToGuild[msg.sender];
        require(msg.sender == guilds[guild].members[0], "Only the Guild Leader can change the Guild name");
        require(_checkName(name, false), "This Guild Name is either already in use or is longer than the limit of 15 characters");
        require(_checkName(tag, true), "This Guild Tag is either already in use or is longer than the limit of 5 characters");
        isInUseName[name] = true;
        isInUseTag[tag] = true;
        isInUseName[guilds[guild].name] = false;
        isInUseTag[guilds[guild].tag] = false;
        guilds[guild].name = name;
        guilds[guild].tag = tag;
        guilds[guild].hall = hall;
    }

    function checkIfGuildMaster(address user, uint guild) public view returns(bool, uint) {
        for(uint i; i < guilds[guild].guildMasters.length; i++) {
            if(user == guilds[guild].guildMasters[i]) {
                return(true, i);
            }
        }
        return (false, 0);
    }

    function checkMemberNumber(address user, uint guild) public view returns(uint) {
        for(uint i; i < guilds[guild].members.length; i++) {
            if(user == guilds[guild].members[i]) {
                return i;
            }
        }
        return 0;
    }

    function deleteFromArray(uint guild, uint id, bool master) internal {
        if(!master) {
            for(uint i = id; i < guilds[guild].members.length - 1; i++) {
                guilds[guild].members[i] = guilds[guild].members[i+1];
            }
            guilds[guild].members.pop();
        }
        else {
            for(uint i = id; i < guilds[guild].guildMasters.length - 1; i++) {
                guilds[guild].guildMasters[i] = guilds[guild].guildMasters[i+1];
            }
            guilds[guild].guildMasters.pop();
        }
    }

    // EXTERNAL FUNCTIONS //
    
    function changeDamageDealt(address user, uint dmg) external {
        require(msg.sender == address(raidBoss), "Unauthorized call");
        damageDealt[user] += dmg;
        globalDamageDealt[user] += dmg;
        guilds[playerToGuild[user]].guildDamageDealt += dmg;
    }

    function resetDamageDealt(uint guild) external {
        require(msg.sender == address(raidBoss), "Unauthorized call");
        for(uint i; i < guilds[guild].members.length; i++) {
            damageDealt[guilds[guild].members[i]] = 0;
        }
    }

    function getDamageDealt(address user) external view returns(uint) {
        return damageDealt[user];
    }

    function changeBossHealth(uint guild, uint atk) external {
        require(msg.sender == address(raidBoss), "Unauthorized call");
        if(guilds[guild].bossHealth < atk) {
            guilds[guild].bossHealth = 0;
        }
        else {
            guilds[guild].bossHealth -= atk;
        }
    }

    function activateBoss(uint guild, bool activate, bool bossKilled, uint health, uint price, uint time) external {
        require(msg.sender == address(raidBoss), "Unauthorized call");
        if(activate) {
            require(guilds[guild].pooledForBoss >= price, "You have not pooled enough BNB for this boss fight");
            require(!guilds[guild].bossActive, "The Guild is already in a boss fight");
            guilds[guild].bossHealth = health;
            guilds[guild].timeBossActivated = time;
            guilds[guild].pooledForBoss = 0;
        }
        if(!activate) {
            if(bossKilled) {
                guilds[guild].bossesKilled++;
                bossTypesKilled[guild][guilds[guild].bossId]++;
            }
            guilds[guild].bossId = 0;
        }
        guilds[guild].bossActive = activate;

        
    }

    function defineBoss(uint guild, uint id) external {
        require(msg.sender == address(raidBoss), "Unauthorized call");
        require(!guilds[guild].bossActive, "The Guild is already in a boss fight");
        require(guilds[guild].pooledForBoss == 0, "You cannot do this while you already have BNB pooled for a certain boss");
        guilds[guild].bossId = id;
    }

    function getBossHealth(uint guild) external view returns(uint) {
        return guilds[guild].bossHealth;
    }

    function getBossId(uint guild) external view returns(uint) {
        return guilds[guild].bossId;
    }

    function getBossActive(uint guild) external view returns(bool) {
        return guilds[guild].bossActive;
    }

    function getTimeBossActivated(uint guild) external view returns(uint) {
        return guilds[guild].timeBossActivated;
    }

    function getGuildName(uint guild) external view returns(string memory) {
        return guilds[guild].name;
    }

    function addItemToBank(uint guild, uint itemId, uint amount) external {
        require(msg.sender == address(raidBoss), "Unauthorized call");
        itemsInGuildBank[guild][itemId] += amount;
    }

    function distributeBeans(uint guild, uint beans) external {
        require(msg.sender == address(raidBoss), "Unauthorized call");
        uint threshold;
        uint[4] memory stats = nft.userStats(msg.sender);
        for(uint a; a < guilds[guild].members.length; a++) {
            threshold = stats[3] * 3;
            if(damageDealt[guilds[guild].members[a]] > 0 && damageDealt[guilds[guild].members[a]] < threshold) {
                gacha.sendGachaTokens(beans, guilds[guild].members[a]);
            }
            else if(damageDealt[guilds[guild].members[a]] >= threshold) {
                gacha.sendGachaTokens(beans * 2, guilds[guild].members[a]);
            }
        }
    }

    function resetDepositedByUser(uint guild) external {
        require(msg.sender == address(raidBoss), "Unauthorized call");
        for(uint i; i < guilds[guild].members.length; i++) {
            depositedByUser[guild][guilds[guild].members[i]] = 0;
        }
    }

    // RETURN FUNCTIONS //

    function getGuildInfo(uint guild) public view returns(Guild memory _guild, string[] memory members, uint[] memory deposits, uint[] memory damage, uint[] memory bank) {
        members = new string[](guilds[guild].members.length);
        deposits = new uint[](guilds[guild].members.length);
        damage = new uint[](guilds[guild].members.length);
        Relic[] memory relics = nft.getRelics();
        bank = new uint[](relics.length);
        for(uint i; i < members.length; i++) {
            members[i] = miner.getNicknameToAddress(guilds[guild].members[i]);
            deposits[i] = depositedByUser[guild][guilds[guild].members[i]];
            damage[i] = damageDealt[guilds[guild].members[i]];
        }
        for(uint a; a < relics.length; a++) {
            bank[a] = itemsInGuildBank[guild][a];
        }
        return (guilds[guild], members, deposits, damage, bank);
    }

    function getPlayerToGuild(address player) public view returns(uint) {
        return playerToGuild[player];
    }

    function getGuildTag(uint guild) public view returns(string memory tag) {
        return guilds[guild].tag;
    }

    function getDepositedByUser(uint guild, address user) public view returns(uint) {
        return depositedByUser[guild][user];
    }

    function getBossTypesKilled(uint guild, uint id) public view returns(uint) {
        return bossTypesKilled[guild][id];
    }

    //INTERNAL

    function _checkName(string memory name, bool tag) private view returns (bool){
        if(tag ? bytes(name).length > 5 : bytes(name).length > 15 ){
            return false; 
        }
        if(bytes(name).length < 1) {
            return false;
        }
        if(tag ? isInUseTag[name] : isInUseName[name]) {
            return false;
        }
        return true;
    }

    


}

contract BeanQuest {
    function getNicknameToAddress(address _addr) public view returns (string memory nick){}
}

contract BeanQuestGacha {
    function sendGachaTokens(uint _amount, address receiver) public {}
}

contract BeanQuestNFTs {
    function setApprovalForAll(address operator, bool approved) external {}
    function balanceOf(address account, uint256 id) external view returns (uint256) {}
    function userStats(address _addr) view external returns(uint[4] memory) {}
    function getEffectStatus(uint8 _bonus, address _add) public view returns(bool) {}
    function getRelicActiveForBonus(address _add, uint8 _bonus) public view returns(uint) {}
    function getBonusMultiplier(uint _id) public view returns (uint) {}
    function getRelic(uint _id) public view returns(BeanQuestGuilds.Relic memory) {}
    function getRelics() public view returns(BeanQuestGuilds.Relic[] memory) {}
    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes calldata data
    ) external {}
}

contract BeanQuestGuildBosses {
    function price(uint id) public view returns(uint) {}
}