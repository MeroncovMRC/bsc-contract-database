{"Context.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.7;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n}\n"},"ISecurityManager.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\n/**\n * @title ISecurityManager \n * \n * Interface for a contract\u0027s associated { SecurityManager } contract, from the point of view of the security-managed \n * contract (only a small subset of the SecurityManager\u0027s methods are needed). \n * \n * See also { SecurityManager }\n * \n * @author John R. Kosinski \n */\ninterface ISecurityManager  {\n    \n    /**\n     * Returns `true` if `account` has been granted `role`.\n     * \n     * @param role The role to query. \n     * @param account Does this account have the specified role?\n     */\n    function hasRole(bytes32 role, address account) external returns (bool); \n}"},"IWhitelist.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\n/**\n * @title IWhitelist \n * \n * Interface for a { Whitelist } contract, from the perspective of another contract which holds a reference to \n * the Whitelist (only a small subset of its methods/properties will be needed). \n * \n * See also { Whitelist }\n * \n * @author John R. Kosinski \n */\ninterface IWhitelist  {\n    \n    /**\n     * Indicates whether or not the given address is in the contained. \n     * \n     * @param addr The address to query. \n     * @return True if the given address is on the whitelist, otherwise false.\n     */\n    function isWhitelisted(address addr) external returns (bool); \n}"},"ManagedSecurity.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"./Context.sol\"; \nimport \"./ISecurityManager.sol\"; \n\n/**\n * @title ManagedSecurity \n * \n * This is an abstract base class for contracts whose security is managed by { SecurityManager }. It exposes \n * the modifier which calls back to the associated { SecurityManager } contract. \n * \n * See also { SecurityManager }\n * \n * @author John R. Kosinski \n */\nabstract contract ManagedSecurity is Context { \n    //TODO: (MED) the use of Context here instead of ContextUpgradeable is questionable; consider making a separate ManagedSecurityUpgradeable\n    ISecurityManager public securityManager; \n    \n    //security roles \n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n    bytes32 public constant BURNER_ROLE = keccak256(\"BURNER_ROLE\");\n    bytes32 public constant UPGRADER_ROLE = keccak256(\"UPGRADER_ROLE\");\n    bytes32 public constant GENERAL_MANAGER_ROLE = keccak256(\"GENERAL_MANAGER_ROLE\");\n    bytes32 public constant LIFECYCLE_MANAGER_ROLE = keccak256(\"LIFECYCLE_MANAGER_ROLE\");\n    bytes32 public constant WHITELIST_MANAGER_ROLE = keccak256(\"WHITELIST_MANAGER_ROLE\");\n    bytes32 public constant DEPOSIT_MANAGER_ROLE = keccak256(\"DEPOSIT_MANAGER_ROLE\");\n    \n    //thrown when the onlyRole modifier reverts \n    error UnauthorizedAccess(bytes32 roleId, address addr); \n    \n    //thrown if zero-address argument passed for securityManager\n    error ZeroAddressArgument(); \n    \n    //Restricts function calls to callers that have a specified security role only \n    modifier onlyRole(bytes32 role) {\n        if (!securityManager.hasRole(role, _msgSender())) {\n            revert UnauthorizedAccess(role, _msgSender());\n        }\n        _;\n    }\n    \n    /**\n     * Allows an authorized caller to set the securityManager address. \n     * \n     * Reverts: \n     * - {UnauthorizedAccess}: if caller is not authorized \n     * - {ZeroAddressArgument}: if the address passed is 0x0\n     * - \u0027Address: low-level delegate call failed\u0027 (if `_securityManager` is not legit)\n     * \n     * @param _securityManager Address of an ISecurityManager. \n     */\n    function setSecurityManager(ISecurityManager _securityManager) external onlyRole(ADMIN_ROLE) {\n        _setSecurityManager(_securityManager); \n    }\n    \n    /**\n     * This call helps to check that a given address is a legitimate SecurityManager contract, by \n     * attempting to call one of its read-only methods. If it fails, this function will revert. \n     * \n     * @param _securityManager The address to check \u0026 verify \n     */\n    function _setSecurityManager(ISecurityManager _securityManager) internal {\n        \n        //address can\u0027t be zero\n        if (address(_securityManager) == address(0)) \n            revert ZeroAddressArgument(); \n            \n        //this line will fail if security manager is invalid address\n        _securityManager.hasRole(ADMIN_ROLE, address(this)); \n        \n        //set the security manager\n        securityManager = _securityManager;\n    }\n    \n    //future-proof, as this is inherited by upgradeable contracts\n    uint256[50] private __gap;\n}"},"Whitelist.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"./IWhitelist.sol\";\nimport \"./ManagedSecurity.sol\";\n\n/**\n * @title Whitelist \n * \n * Contract that keeps whitelist data. On the admin side it allows adding \u0026 removing of addresses on \n * the whitelist. To other contracts, it acts as an oracle to determine whether or not any arbitrary \n * address is whitelisted. \n * \n * @author John R. Kosinski\n */\ncontract Whitelist is IWhitelist, ManagedSecurity {\n    mapping(address =\u003e bool) private whitelisted;   //stores the whitelist \n    bool public whitelistOn = true;                 //enables/disables whitelist \n    \n    //events \n    event WhitelistOnOffChanged(address indexed caller, bool value); \n    event WhitelistAddedRemoved(address indexed caller, address indexed addr, bool value); \n    \n    /**\n     * Creates an instance of the Whitelist contract. \n     * \n     * @param _securityManager Contract which will manage secure access for this contract. \n     */\n    constructor(ISecurityManager _securityManager) {\n        _setSecurityManager(_securityManager); \n    }\n    \n    /**\n     * Indicates whether or not the given address is in the whitelist. \n     * \n     * @param addr The address to query. \n     * @return bool True if the given address is in the whitelist.\n     */\n    function isWhitelisted(address addr) external view returns (bool) {\n        if (whitelistOn) {\n            return whitelisted[addr]; \n        }\n        return true;\n    }\n    \n    /**\n     * Adds or removes an address to/from the whitelist. \n     * \n     * Emits: \n     * - {WhitelistAddedRemoved} event if any change has been made to the whitelist. \n     * \n     * Reverts: \n     * - {UnauthorizedAccess} if caller does not have the appropriate security role\n     * - {ZeroAddressArgument} if address passed is 0x0\n     * \n     * @param addr The address to add or remove. \n     * @param addRemove If true, adds; otherwise removes the address.\n     */\n    function addRemoveWhitelist(address addr, bool addRemove) external onlyRole(WHITELIST_MANAGER_ROLE) {  \n        if (addr == address(0)) \n            revert ZeroAddressArgument(); \n        \n        _addRemoveWhitelist(addr, addRemove); \n    }\n    \n    /**\n     * Adds or removes multiple addresses to/from the whitelist. \n     * @dev Addresses that are equal to 0x0 will not be added, but the function will not revert if one \n     * is included in the array. 0x0 addresses in this function will just be ignored. \n     * \n     * Emits: \n     * - {WhitelistAddedRemoved} event if any change has been made to the whitelist, for each address. \n     * \n     * Reverts: \n     * - {UnauthorizedAccess} if caller does not have the appropriate security role\n     * \n     * @param addresses Array of addresses to add or remove. \n     * @param addRemove If true, adds; otherwise removes the address.\n     */\n    function addRemoveWhitelistBulk(address[] calldata addresses, bool addRemove) external onlyRole(WHITELIST_MANAGER_ROLE)  {\n        for (uint n = 0; n \u003c addresses.length; n++) {\n            if (addresses[n] != address(0)) {\n                _addRemoveWhitelist(addresses[n], addRemove); \n            }\n        }\n    }\n    \n    /**\n     * Enables or disables whitelisting. \n     * \n     * Emits: \n     * - {WhitelistOnOffChanged} event if any change has been made to {whitelistOn} flag. \n     * \n     * Reverts: \n     * - {UnauthorizedAccess} if caller does not have the appropriate security role\n     * \n     * @param onOff If true, enables; otherwise disables whitelisting.\n     */\n    function setWhitelistOnOff(bool onOff) external onlyRole(WHITELIST_MANAGER_ROLE) { \n        if (whitelistOn != onOff) {\n            whitelistOn = onOff;\n            emit WhitelistOnOffChanged(_msgSender(), onOff);\n        }\n    }\n    \n    /**\n     * Adds or removes the given address to/from the whitelist. \n     * \n     * Emits: \n     * - {WhitelistAddedRemoved} if any change has been made to the whitelist (e.g. address\n     *      actually added or removed)\n     * \n     * @param addr The address to add or remove. \n     * @param addRemove If true, adds; otherwise removes the address.\n     */\n    function _addRemoveWhitelist(address addr, bool addRemove) internal {\n        if (whitelisted[addr] != addRemove) {\n            whitelisted[addr] = addRemove;\n            emit WhitelistAddedRemoved(_msgSender(), addr, addRemove); \n        }\n    }\n}"}}