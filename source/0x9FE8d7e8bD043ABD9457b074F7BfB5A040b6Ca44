{"EmyemToken.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.6;\r\n\r\nimport \"./Libraries.sol\";\r\n\r\ncontract Emyem {\r\n    string public name = \"Emyem\";\r\n    string public symbol = \"MYM\";\r\n    uint256 public totalSupply = 300000000000000000000000000; // 300 millones de tokens\r\n    uint8 public decimals = 18;\r\n    address public teamWallet; // Dueño del contrato.\r\n    address public marketingWallet; // Dirección de la billetera de marketing.\r\n    address private firstPresaleContract; // Dirección del contrato de la primera preventa.\r\n    address private secondPresaleContract; // Dirección del contrato de la segunda preventa.\r\n    address private teamVestingContract; // Dirección del contrato de vesting para el equipo.\r\n    IUniswapV2Router02 router; // Router.\r\n    address private pancakePairAddress; // Dirección del par.\r\n    uint public liquidityLockTime = 365 days; // Tiempo que va a estar bloqueada la liquidez.\r\n    uint public liquidityLockCooldown;\r\n\r\n    mapping(address =\u003e uint256) public balanceOf;\r\n    mapping(address =\u003e mapping(address =\u003e uint256)) private _allowances;\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    constructor(address _teamWallet, address _marketingWallet, address _firstPresaleContract, address _secondPresaleContract, address _teamVestingContract) {\r\n        teamWallet = _teamWallet;\r\n        marketingWallet = _marketingWallet;\r\n        firstPresaleContract = _firstPresaleContract;\r\n        secondPresaleContract = _secondPresaleContract;\r\n        teamVestingContract = _teamVestingContract;\r\n        router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n        pancakePairAddress = IPancakeFactory(router.factory()).createPair(address(this), router.WETH());\r\n\r\n        uint _firstPresaleTokens = 10000000000000000000000000;\r\n        uint _secondPresaleTokens = 20000000000000000000000000;\r\n        uint _teamVestingTokens = 45000000000000000000000000;\r\n        uint _marketingTokens = 15000000000000000000000000;\r\n        uint _contractTokens = totalSupply - (_teamVestingTokens + _marketingTokens + _firstPresaleTokens + _secondPresaleTokens);\r\n\r\n        balanceOf[firstPresaleContract] = _firstPresaleTokens;\r\n        balanceOf[secondPresaleContract] = _secondPresaleTokens;\r\n        balanceOf[teamVestingContract] = _teamVestingTokens;\r\n        balanceOf[marketingWallet] = _marketingTokens;\r\n        balanceOf[address(this)] = _contractTokens;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == teamWallet, \u0027You must be the owner.\u0027);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Función que permite hacer una transferencia.\r\n     * @param _to Dirección del destinatario.\r\n     * @param _value Cantidad de tokens a transferir.\r\n     */\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        require(balanceOf[msg.sender] \u003e= _value);\r\n\r\n        balanceOf[msg.sender] -= _value;\r\n        balanceOf[_to] += _value;\r\n\r\n        emit Transfer(msg.sender, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Función que permite ver cuanta cantidad de tokens tiene permiso para gastar una dirección.\r\n     * @param _owner Dirección de la persona que da permiso a gastar sus tokens.\r\n     * @param _spender Dirección a la que se le da permiso para gastar los tokens.\r\n     */\r\n    function allowance(address _owner, address _spender) public view virtual returns (uint256) {\r\n        return _allowances[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n     * @notice Función que incrementa el allowance.\r\n     * @param _spender Dirección a la que se le da permiso para gastar tokens.\r\n     * @param _addedValue Cantidad de tokens que das permiso para que gasten.\r\n     */\r\n    function increaseAllowance(address _spender, uint256 _addedValue) public virtual returns (bool) {\r\n        _approve(msg.sender, _spender, _allowances[msg.sender][_spender] + _addedValue);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Función que disminuye el allowance.\r\n     * @param _spender Dirección a la que se le quita permiso para gastar tokens.\r\n     * @param _subtractedValue Cantidad de tokens que se van a disminuir de la cantidad permitida para gastar.\r\n     */\r\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[msg.sender][_spender];\r\n        require(currentAllowance \u003e= _subtractedValue, \"ERC20: decreased allowance below zero\");\r\n\r\n        unchecked {\r\n            _approve(msg.sender, _spender, currentAllowance - _subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Función que llama a la función interna _approve.\r\n     * @param _spender Dirección de la cuenta a la que le das permiso para gastar tus tokens.\r\n     * @param _value Cantidad de tokens que das permiso para que gasten.\r\n     */\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        _approve(msg.sender, _spender, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Función interna que permite aprobar a otra cuenta a gastar tus tokens.\r\n     * @param _owner Dirección de la cuenta que da permiso para gastar sus tokens.\r\n     * @param _spender Dirección de la cuenta a la que le das permiso para gastar tus tokens.\r\n     * @param _amount Cantidad de tokens que das permiso para que gasten.\r\n     */\r\n    function _approve(address _owner, address _spender, uint256 _amount) internal virtual {\r\n        require(_owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(_spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[_owner][_spender] = _amount;\r\n\r\n        emit Approval(_owner, _spender, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Función que permite hacer una transferencia desde una dirección.\r\n     * @param _from Dirección del emisor.\r\n     * @param _to Dirección del destinatario.\r\n     * @param _value Cantidad de tokens a transferir.\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        require(_value \u003c= balanceOf[_from]);\r\n        require(_value \u003c= _allowances[_from][msg.sender]);\r\n\r\n        balanceOf[_from] -= _value;\r\n        balanceOf[_to] += _value;\r\n        _allowances[_from][msg.sender] -= _value;\r\n\r\n        emit Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Función pública que permite quemar tokens.\r\n     * @param _amount Cantidad de tokens que se van a quemar.\r\n     */\r\n    function burn(uint256 _amount) public virtual {\r\n        _burn(msg.sender, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Función interna que permite quemar tokens.\r\n     * @param _account Dirección desde la que se van a quemar los tokens.\r\n     * @param _amount Cantidad de tokens que se van a quemar.\r\n     */\r\n    function _burn(address _account, uint256 _amount) internal virtual {\r\n        require(_account != address(0), \u0027No puede ser la direccion cero.\u0027);\r\n        require(balanceOf[_account] \u003e= _amount, \u0027La cuenta debe tener los tokens suficientes.\u0027);\r\n\r\n        balanceOf[_account] -= _amount;\r\n        totalSupply -= _amount;\r\n\r\n        emit Transfer(_account, address(0), _amount);\r\n    }\r\n    \r\n    /**\r\n     * @notice Función que permite añadir liquidez.\r\n     * @param _tokenAmount Cantidad de tokens que se van a destinar para la liquidez.\r\n     */\r\n    function addLiquidity(uint _tokenAmount) public payable onlyOwner {\r\n        require(_tokenAmount \u003e 0 || msg.value \u003e 0, \"Insufficient tokens or BNBs.\");\r\n        require(IERC20(pancakePairAddress).totalSupply() == 0);\r\n\r\n        _approve(address(this), address(router), _tokenAmount);\r\n\r\n        liquidityLockCooldown = block.timestamp + liquidityLockTime;\r\n\r\n        router.addLiquidityETH{value: msg.value}(\r\n            address(this),\r\n            _tokenAmount,\r\n            0,\r\n            0,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Función que permite retirar la liquidez.\r\n     */\r\n    function removeLiquidity() public onlyOwner {\r\n        require(block.timestamp \u003e= liquidityLockCooldown, \"Locked\");\r\n\r\n        IERC20 liquidityTokens = IERC20(pancakePairAddress);\r\n        uint _amount = liquidityTokens.balanceOf(address(this));\r\n        liquidityTokens.approve(address(router), _amount);\r\n\r\n        router.removeLiquidityETH(\r\n            address(this),\r\n            _amount,\r\n            0,\r\n            0,\r\n            teamWallet,\r\n            block.timestamp\r\n        );\r\n    }\r\n}\r\n"},"Libraries.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.6;\r\n\r\ninterface IPancakeFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IUniswapV2Router02 {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        returns (\r\n            uint256 amountA,\r\n            uint256 amountB,\r\n            uint256 liquidity\r\n        );\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (\r\n            uint256 amountToken,\r\n            uint256 amountETH,\r\n            uint256 liquidity\r\n        );\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountA, uint256 amountB);\r\n\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountToken, uint256 amountETH);\r\n\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint256 amountA, uint256 amountB);\r\n\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint256 amountToken, uint256 amountETH);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapTokensForExactTokens(\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapExactETHForTokens(\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable returns (uint256[] memory amounts);\r\n\r\n    function swapTokensForExactETH(\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapExactTokensForETH(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapETHForExactTokens(\r\n        uint256 amountOut,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable returns (uint256[] memory amounts);\r\n\r\n    function quote(\r\n        uint256 amountA,\r\n        uint256 reserveA,\r\n        uint256 reserveB\r\n    ) external pure returns (uint256 amountB);\r\n\r\n    function getAmountOut(\r\n        uint256 amountIn,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) external pure returns (uint256 amountOut);\r\n\r\n    function getAmountIn(\r\n        uint256 amountOut,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) external pure returns (uint256 amountIn);\r\n\r\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\r\n        external\r\n        view\r\n        returns (uint256[] memory amounts);\r\n\r\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\r\n        external\r\n        view\r\n        returns (uint256[] memory amounts);\r\n\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountETH);\r\n\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint256 amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n}\r\n\r\ninterface IERC20 {\r\n    function decimals() external view returns (uint256);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot\u0027s contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler\u0027s defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction\u0027s gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}"}}