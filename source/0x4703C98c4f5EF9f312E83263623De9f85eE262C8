{"Address.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\u0027s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) private pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"},"IERC1155.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\npragma solidity \u003e=0.7.4 \u003c=0.8.9;\n\n\ninterface IERC1155 {\n\n  /****************************************|\n  |                 Events                 |\n  |_______________________________________*/\n\n  /**\n   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\n   *   Operator MUST be msg.sender\n   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\n   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\n   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the \"circulating supply\" for a given token ID\n   *   To broadcast the existence of a token ID with no initial balance, the contract SHOULD emit the TransferSingle event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\n   */\n  event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _amount);\n\n  /**\n   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\n   *   Operator MUST be msg.sender\n   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\n   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\n   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the \"circulating supply\" for a given token ID\n   *   To broadcast the existence of multiple token IDs with no initial balance, this SHOULD emit the TransferBatch event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\n   */\n  event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _amounts);\n\n  /**\n   * @dev MUST emit when an approval is updated\n   */\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n\n  /****************************************|\n  |                Functions               |\n  |_______________________________________*/\n\n  /**\n    * @notice Transfers amount of an _id from the _from address to the _to address specified\n    * @dev MUST emit TransferSingle event on success\n    * Caller must be approved to manage the _from account\u0027s tokens (see isApprovedForAll)\n    * MUST throw if `_to` is the zero address\n    * MUST throw if balance of sender for token `_id` is lower than the `_amount` sent\n    * MUST throw on any other error\n    * When transfer is complete, this function MUST check if `_to` is a smart contract (code size \u003e 0). If so, it MUST call `onERC1155Received` on `_to` and revert if the return amount is not `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n    * @param _from    Source address\n    * @param _to      Target address\n    * @param _id      ID of the token type\n    * @param _amount  Transfered amount\n    * @param _data    Additional data with no specified format, sent in call to `_to`\n    */\n  function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes calldata _data) external;\n\n  /**\n    * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\n    * @dev MUST emit TransferBatch event on success\n    * Caller must be approved to manage the _from account\u0027s tokens (see isApprovedForAll)\n    * MUST throw if `_to` is the zero address\n    * MUST throw if length of `_ids` is not the same as length of `_amounts`\n    * MUST throw if any of the balance of sender for token `_ids` is lower than the respective `_amounts` sent\n    * MUST throw on any other error\n    * When transfer is complete, this function MUST check if `_to` is a smart contract (code size \u003e 0). If so, it MUST call `onERC1155BatchReceived` on `_to` and revert if the return amount is not `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n    * Transfers and events MUST occur in the array order they were submitted (_ids[0] before _ids[1], etc)\n    * @param _from     Source addresses\n    * @param _to       Target addresses\n    * @param _ids      IDs of each token type\n    * @param _amounts  Transfer amounts per token type\n    * @param _data     Additional data with no specified format, sent in call to `_to`\n  */\n  function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external;\n\n  /**\n   * @notice Get the balance of an account\u0027s Tokens\n   * @param _owner  The address of the token holder\n   * @param _id     ID of the Token\n   * @return        The _owner\u0027s balance of the Token type requested\n   */\n  function balanceOf(address _owner, uint256 _id) external view returns (uint256);\n\n  /**\n   * @notice Get the balance of multiple account/token pairs\n   * @param _owners The addresses of the token holders\n   * @param _ids    ID of the Tokens\n   * @return        The _owner\u0027s balance of the Token types requested (i.e. balance for each (owner, id) pair)\n   */\n  function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);\n\n  /**\n   * @notice Enable or disable approval for a third party (\"operator\") to manage all of caller\u0027s tokens\n   * @dev MUST emit the ApprovalForAll event on success\n   * @param _operator  Address to add to the set of authorized operators\n   * @param _approved  True if the operator is approved, false to revoke approval\n   */\n  function setApprovalForAll(address _operator, bool _approved) external;\n\n  /**\n   * @notice Queries the approval status of an operator for a given owner\n   * @param _owner     The owner of the Tokens\n   * @param _operator  Address of authorized operator\n   * @return isOperator True if the operator is approved, false if not\n   */\n  function isApprovedForAll(address _owner, address _operator) external view returns (bool isOperator);\n\n}\n"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"IERC20Metadata.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"},"INEFTiLicense.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.9;\n\n/*\n**    █▄░█ █▀▀ █▀▀ ▀█▀ █ █▀█ █▀▀ █▀▄ █ ▄▀█\n**    █░▀█ ██▄ █▀░ ░█░ █ █▀▀ ██▄ █▄▀ █ █▀█\n**    ____________________________________\n**    https://neftipedia.com\n**    contact@neftipedia.com\n**/\n\n/** d6147a8a */\ninterface INEFTiLicense {\n    /** 921fe338 */\n    function legalInfo() external view\n        returns (string memory _title, string memory _license, string memory _version, string memory _url);\n}\n"},"INEFTiMPFeeCalcExt.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.9;\n\ninterface INEFTiMPFeeCalcExt {\n    function defaultPayment()\n        external view\n        returns (address tokenContract, uint8 decimals, uint256 priceUSD);\n\n    function setDefaultPayment(address _tokenContract)\n        external;\n\n    function enablePayment(address _tokenContract)\n        external;\n\n    function disablePayment(address _tokenContract)\n        external;\n\n    function payments()\n        external view\n        returns (address[] memory cryptos);\n\n    function paymentIsEnabled(address _tokenContract)\n        external view\n        returns (bool);\n    \n    function usdFeeAsToken(uint256 _usdAmount, address _tokenContract)\n        external view\n        returns (uint256);\n    \n    function paymentInfo(address _tokenContract)\n        external view\n        returns (uint256 index, bool isEnabled, string memory name, string memory symbol, uint8 decimals, uint256 priceUSD);\n\n    function staticPercent() external view returns (uint256);\n    \n    function feeOf(uint8 feeType) external view returns (uint16);\n\n    function calcFeeOf(uint8 _feeType, uint256 _price, uint256 _amount)\n        external view\n        returns (uint256);\n}"},"INEFTiMultiTokens.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity \u003e=0.7.4 \u003c=0.8.9;\n\nimport \"./IERC1155.sol\";\n\ninterface INEFTiMultiTokens is IERC1155 {\n\n    /*════════════oooooOooooo═════════════╗\n    ║█~~~~~~~~~~~~ FUNCTIONS ~~~~~~~~~~~~█║\n    ╚════════════════════════════════════*/\n\n    /**\n    ** @notice Transfers amount of an _id from the _from address to the _to address specified\n    ** @dev MUST emit TransferSingle event on success\n    ** Caller must be approved to manage the _from account\u0027s tokens (see isApprovedForAll)\n    ** MUST throw if `_to` is the zero address\n    ** MUST throw if balance of sender for token `_id` is lower than the `_amount` sent\n    ** MUST throw on any other error\n    ** When transfer is complete, this function MUST check if `_to` is a smart contract (code size \u003e 0). If so, it MUST call `onERC1155Received` on `_to` and revert if the return amount is not `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n    ** @param _from    Source address\n    ** @param _to      Target address\n    ** @param _id      ID of the token type\n    ** @param _amount  Transfered amount\n    ** @param _data    Additional data with no specified format, sent in call to `_to`\n    **/\n    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes calldata _data) external override (IERC1155);\n\n    /**\n    ** @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\n    ** @dev MUST emit TransferBatch event on success\n    ** Caller must be approved to manage the _from account\u0027s tokens (see isApprovedForAll)\n    ** MUST throw if `_to` is the zero address\n    ** MUST throw if length of `_ids` is not the same as length of `_amounts`\n    ** MUST throw if any of the balance of sender for token `_ids` is lower than the respective `_amounts` sent\n    ** MUST throw on any other error\n    ** When transfer is complete, this function MUST check if `_to` is a smart contract (code size \u003e 0). If so, it MUST call `onERC1155BatchReceived` on `_to` and revert if the return amount is not `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n    ** Transfers and events MUST occur in the array order they were submitted (_ids[0] before _ids[1], etc)\n    ** @param _from     Source addresses\n    ** @param _to       Target addresses\n    ** @param _ids      IDs of each token type\n    ** @param _amounts  Transfer amounts per token type\n    ** @param _data     Additional data with no specified format, sent in call to `_to`\n    **/\n    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external override(IERC1155);\n\n    /**\n    ** @notice Get the balance of an account\u0027s Tokens\n    ** @param _owner  The address of the token holder\n    ** @param _id     ID of the Token\n    ** @return        The _owner\u0027s balance of the Token type requested\n    **/\n    function balanceOf(address _owner, uint256 _id) external view  override(IERC1155) returns (uint256);\n\n    /**\n    ** @notice Get the balance of multiple account/token pairs\n    ** @param _owners The addresses of the token holders\n    ** @param _ids    ID of the Tokens\n    ** @return        The _owner\u0027s balance of the Token types requested (i.e. balance for each (owner, id) pair)\n    **/\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view override(IERC1155) returns (uint256[] memory);\n\n    /**\n    ** @notice Enable or disable approval for a third party (\"operator\") to manage all of caller\u0027s tokens\n    ** @dev MUST emit the ApprovalForAll event on success\n    ** @param _operator  Address to add to the set of authorized operators\n    ** @param _approved  True if the operator is approved, false to revoke approval\n    **/\n    function setApprovalForAll(address _operator, bool _approved) external override(IERC1155);\n\n    /**\n    ** @notice Queries the approval status of an operator for a given owner\n    ** @param _owner     The owner of the Tokens\n    ** @param _operator  Address of authorized operator\n    ** @return isOperator True if the operator is approved, false if not\n    **/\n    function isApprovedForAll(address _owner, address _operator) external view override(IERC1155) returns (bool isOperator);\n\n\n    /*════════════oooooOooooo═════════════╗\n    ║█~~~~~~~~~ TOKEN PROPERTIES ~~~~~~~~█║\n    ╚════════════════════════════════════*/\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n\n\n    /*════════════oooooOooooo═════════════╗\n    ║█~~~~~~~~~~~ MINT \u0026 BURN ~~~~~~~~~~~█║\n    ╚════════════════════════════════════*/\n\n    function mint(address _to, uint256 _id, uint256 _value, bytes memory _data) external payable;\n\n    function batchMint(address _to, uint256[] memory _ids, uint256[] memory _values, bytes memory _data) external payable;\n\n    function burn(address _from, uint256 _id, uint256 _value) external;\n\n    function batchBurn(address _from, uint256[] memory _ids, uint256[] memory _values) external;\n\n\n    /*════════════oooooOooooo═════════════╗\n    ║█~~~~~~~~~~~~ UTILITIES ~~~~~~~~~~~~█║\n    ╚════════════════════════════════════*/\n\n    function requestId() external;\n\n    function totalSupply(uint256 _id) external view returns(uint256);\n\n    function minterOf(uint256 _id) external view returns (address);\n\n    function itemsOf(address _holder) external view returns (uint256[] memory);\n\n    function getMintFee(uint256 amount) external view returns(uint256[3] memory mintFee, uint256 multitokenOnEach, string memory feeAs);\n\n    function getBatchMintFee(uint[] memory _amounts) external view returns(uint256[3] memory mintFee, uint256 multitokenOnEach, string memory feeAs);\n\n}\n\n/**\n**    █▄░█ █▀▀ █▀▀ ▀█▀ █ █▀█ █▀▀ █▀▄ █ ▄▀█\n**    █░▀█ ██▄ █▀░ ░█░ █ █▀▀ ██▄ █▄▀ █ █▀█\n**    ____________________________________\n**    https://neftipedia.com\n**    contact@neftipedia.com\n**/\n"},"NEFTiMarketplace.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity \u003e=0.7.4 \u003c=0.8.9;\n\nimport \"./INEFTiLicense.sol\";\nimport \"./SafeMath.sol\";\nimport \"./ReentrancyGuard.sol\";\nimport \"./Ownable.sol\";\nimport \"./IERC20.sol\";\nimport \"./IERC20Metadata.sol\";\nimport \"./INEFTiMultiTokens.sol\";\nimport \"./INEFTiMPFeeCalcExt.sol\";\nimport \"./SafeERC20.sol\";\nimport \"./NEFTiMPStorages.sol\";\n\n/** a2461f9f */\ncontract NEFTiMarketplace is NEFTiMPStorages, ReentrancyGuard , Ownable {\n    using SafeMath  for uint256;\n    using SafeERC20 for IERC20;\n\n    bytes32 public version = keccak256(\"1.10.55\");\n\n    address internal NEFTi20;\n    address internal NEFTiMPFeeCalcExt;\n    address internal NEFTiMT;\n    address private  NEFTiReceivable;\n    address private  NEFTiLegalInfo;\n\n    event UpdateExternalRelationship(uint8 extType, address extTarget);\n    event UpdateReceivableTo(address NEFTiAccount);\n\n    event Sale(\n        uint256 indexed saleId,\n        uint256 indexed tokenId,\n        uint256 price,\n        uint256 amount,\n        uint8 saleMethod,\n        address indexed seller,\n        bool[4] states,\n        //+--\u003e  bool isPostPaid;\n        //+--\u003e  bool isNegotiable;\n        //+--\u003e  bool isAuction;\n        //+--\u003e  bool isContract;\n        uint256[2] saleDate,\n        uint8 status\n    );\n\n    event Negotiate(\n        uint256 indexed saleId,\n        uint256 indexed tokenId,\n        uint256 amount,\n        uint256 price,\n        address indexed negotiator,\n        uint256 negoDate,\n        uint8 status\n    );\n    event NegotiationCanceled(uint256 _sid, address _negotiator);\n    event Bid(\n        uint256 indexed saleId,\n        uint256 indexed tokenId,\n        uint256 amount,\n        uint256 price,\n        address indexed bidder,\n        uint256 bidDate,\n        uint8 status\n    );   \n    event BidCanceled(uint256 _sid, address _negotiator);\n    event CancelSale(\n        uint256 indexed saleId,\n        uint256 indexed tokenId,\n        address indexed seller,\n        uint8 status\n    );\n    event Purchase(\n        uint256 indexed purchaseId,\n        uint256 indexed saleId,\n        uint256 indexed tokenId,\n        uint256 price,\n        uint256 amount,\n        uint8   saleMethod,\n        address seller,\n        bool[4] states,\n        //+--\u003e  bool isPostPaid;\n        //+--\u003e  bool isNegotiable;\n        //+--\u003e  bool isAuction;\n        //+--\u003e  bool isContract;\n        uint8   status\n    );\n    event Suspended(uint256 _sid, uint256 _tokenId, address _seller, bool _suspend);\n    event Delisted(uint256 _sid, uint256 _tokenId, address _seller);\n\n\n    /*════════════oooooOooooo═════════════╗\n    ║█~~~~~~~~~~~~~ LISTING ~~~~~~~~~~~~~█║\n    ╚════════════════════════════════════*/\n\n    /**\n    ** 31262f27\n    ** @dev Proceed Listing item into Marketplace\n    ** @param _from         Owner of the item\n    ** @param _id           Token ID of the NEFTiMultiToken\n    ** @param _amount       Amount of the item\n    ** @param _price        Price of the item\n    ** @param _saleMethod   Selling method\n    **/\n    function _sellToken(uint256 _id, uint256 _amount, uint256 _price, SaleMethods _saleMethod)\n        internal\n    {\n        uint256 listingFee = (\n            SaleMethods(_saleMethod) == SaleMethods.DIRECT\n                ?   INEFTiMPFeeCalcExt(NEFTiMPFeeCalcExt).calcFeeOf( uint8(FeeTypes.DirectListingFee), _price, _amount )\n                :   INEFTiMPFeeCalcExt(NEFTiMPFeeCalcExt).calcFeeOf( uint8(FeeTypes.AuctionListingFee), _price, _amount )\n        );        \n        if (listingFee \u003e 0) {\n            require(IERC20(NEFTi20).balanceOf(msg.sender) \u003e= listingFee, \"ENEFTiMP.01.INSUFFICIENT_NEFTi\"); // Not enough NFT balance for listing\n            IERC20(NEFTi20).safeTransferFrom( msg.sender, address(this), listingFee );\n        }\n        INEFTiMultiTokens(NEFTiMT).safeTransferFrom(msg.sender, address(this), _id, _amount, \"\");\n    }\n    /**\n    ** 6f980d6a\n    ** @dev Listing NEFTiMultiTokens (MT) into the Marketplace (MP)\n    ** @param _sid          Input Sale ID (client-side)\n    ** @param _tokenId      Token ID of the NEFTiMultiToken\n    ** @param _price        Price of the item\n    ** @param _amount       Amount of the item\n    ** @param _saleMethod   Selling method\n    ** @param _states       States in array\n    ** @param _saleDate     Listing date for sale\n    **/\n    function txSaleItems(\n        uint256    _sid,\n        uint256    _tokenId,\n        uint256    _price,\n        uint256    _amount,\n        uint8      _saleMethod,\n        bool[4]    memory _states,\n        //+-----\u003e  bool _isPostPaid,\n        //+-----\u003e  bool _isNegotiable,\n        //+-----\u003e  bool _isAuction,\n        //+-----\u003e  bool _isContract,\n        uint256[2] memory _saleDate\n    )\n        public nonReentrant\n    {\n        require(_saleMethod \u003c 0x02, \"ENEFTiMP.02.INVALID_SALE_METHOD\"); // Unknown Sale Method!\n        require(_saleDate[0] \u003e= block.timestamp, \"ENEFTiMP.03.TIME_BEHIND_CURRENT\"); // Time for sale is behind current time!\n        require(INEFTiMultiTokens(NEFTiMT).balanceOf(msg.sender, _tokenId) \u003e 0, \"ENEFTiMP.04.INSUFFICIENT_TOKEN_ID\"); // Not enough current token id balance for listing!\n        require(_amount \u003e 0, \"ENEFTiMP.05.ZERO_AMOUNT\"); // Zero amount is not applicable for listing!\n\n        _poolSales[msg.sender][_tokenId] += _amount;\n        // if ((_selling[_sid].amount == 0) \u0026\u0026 (_selling[_sid].amount == 0)) {\n        if (_selling[_sid].amount == 0) {\n            // _saleItems.push(_sid);\n            _itemsOnSaleItems[msg.sender].push(_sid);\n        }\n\n        uint256[3] memory values = [uint(0),uint(0),uint(0)];\n        _selling[_sid] = SaleItems(\n            _tokenId,\n            _price,\n            _amount,\n            msg.sender,\n            _states,\n            //+--\u003e _states[0] :  _isPostPaid\n            //+--\u003e _states[1] :  _isNegotiable\n            //+--\u003e _states[2] :  _isAuction\n            //+--\u003e _states[3] :  _isContract\n            _saleDate,\n            values,\n            //+--\u003e values[0]  :  _valContract   0\n            //+--\u003e values[1]  :  _highBid       0\n            //+--\u003e values[2]  :  _bidMultiplier 0\n            address(0),\n            SaleStatus.OPEN\n        );\n        _sellToken( _tokenId, _amount, _price, SaleMethods(_saleMethod) );\n\n        emit Sale(\n            _sid,\n            _tokenId,\n            _price,\n            _amount,\n            _saleMethod,\n            msg.sender,\n            [ _states[0], _states[1], _states[2], false ],\n            _saleDate,\n            uint8(SaleStatus.OPEN)\n        );\n    }\n\n    /**\n    ** 96fd6550\n    ** @dev Add more amount to Sale item\n    ** @param _sid      Input Sale ID (client-side)\n    ** @param _tokenId  Token ID of the NEFTiMultiToken\n    ** @param _amount   Amount of the item\n    **/\n    function txAddItemForSale(uint256 _sid, uint256 _tokenId, uint256 _amount)\n        public nonReentrant\n    {\n        require((_sid \u003e 0) \u0026\u0026 (_tokenId \u003e 0) \u0026\u0026 (_amount \u003e 0), \"ENEFTiMP.06.INVALID_PARAMS\");\n        require(_selling[_sid].seller == msg.sender, \"ENEFTiMP.07.FORBIDDEN_EXECUTOR\"); // Executor have no rights to the item!\n        require(!_selling[_sid].states[2], \"ENEFTiMP.08.INVALID_STATE_OF_AUCTION\"); // unsupported adding item to Auction\n\n        _selling[_sid].amount += _amount;\n        _poolSales[msg.sender][_tokenId] += _amount;\n\n        _sellToken(\n            _tokenId,\n            _amount,\n            _selling[_sid].price,\n            SaleMethods(0x00)\n        );\n        \n        emit Sale(\n            _sid,\n            _tokenId,\n            _selling[_sid].price,\n            _selling[_sid].amount,\n            uint8(0),\n            msg.sender,\n            _selling[_sid].states,\n            _selling[_sid].saleDate,\n            uint8(SaleStatus.OPEN)\n        );\n    }\n\n\n    /*════════════oooooOooooo═════════════╗\n    ║█~~~~~~~~~~~~ UTILITIES ~~~~~~~~~~~~█║\n    ╚════════════════════════════════════*/\n\n    /**\n    ** ec980dea\n    ** @dev Get item information by Sale ID\n    ** @param _sid  Sale ID\n    ** @return      Item information (SaleItems)\n    **/\n    function getSaleItemsInfo(uint256 _sid)\n        public view\n        returns (\n            uint256[3] memory info,\n            //+-----\u003e  uint256 tokenId,\n            //+-----\u003e  uint256 price,\n            //+-----\u003e  uint256 amount,\n            address    seller,\n            bool[4]    memory states,\n            //+-----\u003e  bool isPostPaid,\n            //+-----\u003e  bool isNegotiable,\n            //+-----\u003e  bool isAuction,\n            //+-----\u003e  bool isContract,\n            uint256[2] memory saleDate,\n            uint256[3] memory values,\n            //+-----\u003e  uint256 valContract,\n            //+-----\u003e  uint256 highBid,\n            //+-----\u003e  uint256 bidMultiplier,\n            address    buyer,\n            uint8      status\n        )\n    {\n        return (\n            [\n                _selling[_sid].tokenId,\n                _selling[_sid].price,\n                _selling[_sid].amount\n            ],\n            _selling[_sid].seller,\n            _selling[_sid].states,\n            //+-----\u003e  .isPostPaid,\n            //+-----\u003e  .isNegotiable,\n            //+-----\u003e  .isAuction,\n            //+-----\u003e  .isContract,\n            _selling[_sid].saleDate,\n            _selling[_sid].values,\n            //+-----\u003e  .valContract,\n            //+-----\u003e  .highBid,\n            //+-----\u003e  .bidMultiplier,\n            _selling[_sid].buyer,\n            uint8(_selling[_sid].status)\n        );\n    }\n    \n    /**\n    ** 1626da32\n    ** @dev Get sale item amount by seller address and token ID\n    ** @param _sid      Sale ID\n    ** @param _tokenId  Token ID of the NEFTiMultiToken\n    ** @return Balance on Sale amount of current token id\n    **/\n    function balanceOf(address _seller, uint256 _tokenId)\n        public view\n        returns (uint256)\n    { return (_poolSales[_seller][_tokenId]); }\n\n    /**\n    ** 90267f9c\n    ** @dev Get sale items by seller address\n    ** @param _seller   Address of the seller\n    ** @return Array of Sale item IDs (bytes32)\n    **/\n    function itemsOf(address _seller)\n        public view\n        returns (uint256[] memory items)\n    { return _itemsOnSaleItems[_seller]; }\n\n    /**\n    ** e894a07a\n    ** @dev Cancel Negotiation\n    ** @param _sid          Sale ID\n    ** @param _negotiator   Negotiator address\n    **/\n    function cancelNegotiation(uint256 _sid, address _negotiator)\n        public nonReentrant\n    {\n        require((_sid \u003e 0) \u0026\u0026 (_negotiator != address(0)), \"ENEFTiMP.09.INVALID_PARAMS\");\n        require((msg.sender).balance \u003e 0, \"ENEFTiMP.10.ISSUE_TO_PAY_GAS\");\n        \n        bool isNegotiator = false;\n        bool isSeller = (msg.sender == _selling[_sid].seller);\n        address negotiator = address(0);\n        NegotiateStatus cancelStatus;\n        uint256 cancellationFee = 0;\n\n        if (isSeller || msg.sender == owner()) {\n            cancelStatus = NegotiateStatus.REJECTED;\n            negotiator = _negotiator;\n        } else {\n            for (uint256 i=0; _negotiators[_sid].length \u003e i; i++) {\n                if (_negotiators[_sid][i] == msg.sender) {\n                    isNegotiator = true;\n                    negotiator = msg.sender;\n                    break;\n                }\n            }\n            require(isNegotiator, \"ENEFTiMP.11.INVALID_EXECUTOR\"); // Only seller or negotiator can cancel the negotiation!\n            cancelStatus = NegotiateStatus.CANCELED;\n        }\n\n        for (uint256 i=0; _negotiators[_sid].length \u003e i; i++) {\n            if ((negotiator != address(0)) \u0026\u0026 (_negotiators[_sid][i] == negotiator)) {\n                if (isNegotiator \u0026\u0026 (cancelStatus == NegotiateStatus.CANCELED)) {\n                    cancellationFee = INEFTiMPFeeCalcExt(NEFTiMPFeeCalcExt).calcFeeOf(\n                        uint8(FeeTypes.DirectNegotiateCancellationFee),\n                        _poolNegotiating[_sid][msg.sender].value,\n                        1\n                    );\n\n                    require(IERC20(NEFTi20).balanceOf(msg.sender) \u003e= cancellationFee, \"ENEFTiMP.12.INSUFFICIENT_NEFTi\"); // Not enough current token balance for cancellation!\n                    IERC20(NEFTi20).safeTransferFrom(\n                        address(this),\n                        NEFTiReceivable,\n                        cancellationFee\n                    );\n                }\n                IERC20(NEFTi20).safeTransferFrom(\n                    address(this),\n                    _negotiators[_sid][i],\n                    _poolNegotiating[_sid][negotiator].value.sub(cancellationFee)\n                );\n                \n                _poolNegotiating[_sid][negotiator].status = cancelStatus;\n                _negotiators[_sid][i] = _negotiators[_sid][_negotiators[_sid].length-1];\n                // remove last index\n                _negotiators[_sid].pop();\n                break;\n            }\n        }\n\n        emit NegotiationCanceled(_sid, negotiator);\n    }\n\n    /**\n    ** 27106aa4\n    ** @dev Cancel Bid\u0027s Auction\n    ** @param _sid      Sale ID\n    ** @param _bidder   Bidder address\n    **/\n    function cancelAuctionBid(uint256 _sid, address _bidder)\n        public nonReentrant\n    {\n        bool isBidder = false;\n        bool isAdmin = (msg.sender == owner());\n        address bidder = address(0);\n\n        if (isAdmin) {\n            bidder = _bidder;\n        } else {\n            for (uint256 i=0; _bidders[_sid].length \u003e i; i++) {\n                if (_bidders[_sid][i] == msg.sender) {\n                    isBidder = true;\n                    bidder = msg.sender;\n                    break;\n                }\n            }\n            require(isBidder, \"ENEFTiMP.13.INVALID_EXECUTOR\"); // Only seller or bidder can cancel the negotiation!\n        }\n\n        for (uint256 i=0; _negotiators[_sid].length \u003e i; i++) {\n            if (_bidders[_sid][i] == bidder) {\n                IERC20(NEFTi20).safeTransferFrom(\n                    address(this),\n                    _bidders[_sid][i],   // bidder\n                    _poolBidding[_sid][bidder]\n                );\n                _poolBidding[_sid][bidder] = 0;\n\n                _bidders[_sid][i] = _bidders[_sid][_bidders[_sid].length-1];\n                // remove last index\n                _bidders[_sid].pop();\n            }\n        }\n\n        emit BidCanceled(_sid, bidder);\n    }\n\n    /**\n    ** 5447d080\n    ** @dev Get listing cancellation fee\n    ** @param _sid  Sale ID\n    ** @return Value as fee\n    **/\n    function getListingCancellationFee(uint256 _sid)\n        public view\n        returns (uint256)\n    {\n        require(_selling[_sid].status == SaleStatus.OPEN, \"ENEFTiMP.14.ITEM_NOT_ONSALE\"); // Only open sale can be canceled!\n\n        uint8 cancelFor = (\n            (!_selling[_sid].states[2] \u0026\u0026 !_selling[_sid].states[3])\n                ?   0x02            // FeeTypes.DirectListingCancellationFee\n                :   (\n                    (_selling[_sid].states[2] \u0026\u0026 !_selling[_sid].states[3])\n                        ?   0x07    // FeeTypes.AuctionListingCancellationFee\n                        :   0x0c    // FeeTypes.ContractListingCancellationFee\n                )\n        );\n        uint256 cancelFee = INEFTiMPFeeCalcExt(NEFTiMPFeeCalcExt).calcFeeOf(\n            cancelFor,\n            _selling[_sid].price,\n            _selling[_sid].amount\n        );\n        return cancelFee;\n    }\n\n    /**\n    ** e40417c9\n    ** @dev Cancel item on sale\n    ** @param _sid  Sale ID\n    **/\n    function cancelSaleItem(uint256 _sid)\n        public nonReentrant\n    {\n        require(_sid \u003e 0, \"ENEFTiMP.15.INVALID_SALEID\"); // Unknown Sale ID\n        address seller = _selling[_sid].seller;\n        require(msg.sender == seller || msg.sender == owner(), \"ENEFTiMP.16.INVALID_EXECUTOR\"); // Only seller can cancel the sale!\n        require(_selling[_sid].status == SaleStatus.OPEN, \"ENEFTiMP.17.NOT_FOR_SALE\"); // Only open sale can be canceled!\n        // require(msg.sender.balance \u003e 0, \"Cancellation cost gas fee\");\n\n        address item_seller = _selling[_sid].seller;\n        uint256 item_tokenId = _selling[_sid].tokenId;\n        uint256 item_amount = _selling[_sid].amount;\n\n        // when it\u0027s an Auction\n        if ( _selling[_sid].states[2] ) {\n            if (_bidders[_sid].length \u003e 0) {\n                require(msg.sender == owner(), \"ENEFTiMP.18.FORBIDDEN_ONLY_ADMIN\"); // Only Admin able to cancel auction when bids are placed\n                for (uint256 i=0; i \u003c _bidders[_sid].length; i++) {\n                    // cancellation index should stay on [0]!\n                    if (_bidders[_sid][0] != address(0)) {\n                        cancelAuctionBid(_sid, _bidders[_sid][0]);\n                    }\n                }\n            }\n        }\n        // when it\u0027s a Direct Sale\n        else if ( !_selling[_sid].states[2] ) {\n            if (_negotiators[_sid].length \u003e 0) {\n                for (uint256 i=0; i \u003c _negotiators[_sid].length; i++) {\n                    // cancellation index should stay on [0]!\n                    if (_negotiators[_sid][0] != address(0)) {\n                        cancelNegotiation(_sid, _negotiators[_sid][0]);   \n                    }\n                }\n            }\n        }\n\n        if (_itemsOnSaleItems[seller].length \u003e 0) {\n            for (uint256 i=0; i \u003c _itemsOnSaleItems[seller].length; i++) {\n                if (_itemsOnSaleItems[seller][0] != _sid) {\n                    _itemsOnSaleItems[seller][i] = _itemsOnSaleItems[seller][_itemsOnSaleItems[seller].length-1];\n                    // remove last index\n                    // delete _itemsOnSaleItems[seller][_itemsOnSaleItems[seller].length-1];\n                    _itemsOnSaleItems[seller].pop();\n                }\n            }\n        }\n\n        _poolSales[seller][_selling[_sid].tokenId] -= _selling[_sid].amount;\n        _selling[_sid].buyer = address(0);\n        _selling[_sid].status = SaleStatus.CANCELED;\n\n        INEFTiMultiTokens(NEFTiMT).safeTransferFrom(\n            address(this),\n            item_seller,\n            item_tokenId,\n            item_amount,\n            \"\"\n        );\n\n        emit CancelSale(\n            _sid,\n            item_tokenId,\n            item_seller,\n            uint8(SaleStatus.CANCELED)\n        );\n    }\n\n    /**\n    ** b78c56dd\n    ** @dev Get list of negotiators\n    ** @param _sid  Sale ID\n    ** @return List of negotiator addresses\n    **/\n    function getNegotiators(uint256 _sid) \n        public view\n        returns (address[] memory)\n    { return _negotiators[_sid]; }\n\n    /**\n    ** b0ec6c52\n    ** @dev Get negotiation info\n    ** @param _sid          Sale ID\n    ** @param _negotiator   Negotiator address\n    ** @return (\n    **    saleId    - Sale ID\n    **    value     - Negotiation value\n    **    amount    - Negotiation amount\n    **    negoDate  - Negotiation date\n    **    status    - Negotiation status\n    ** )\n    **/\n    function getNegotiationInfo(uint256 _sid, address _negotiator) \n        public view\n        returns (\n            uint256 saleId,\n            uint256 value,\n            uint256 amount,\n            uint256 negoDate,\n            uint8   status\n        )\n    {\n        require(_negotiator != address(0), \"ENEFTiMP.19.INVALID_NEGOTIATOR\"); // Unknown Negotiator\n        return (\n            _poolNegotiating[_sid][_negotiator].saleHash,\n            _poolNegotiating[_sid][_negotiator].value,\n            _poolNegotiating[_sid][_negotiator].amount,\n            _poolNegotiating[_sid][_negotiator].negoDate,\n            uint8(_poolNegotiating[_sid][_negotiator].status)\n        );\n    }\n\n    /**\n    ** 5a02723f\n    ** @dev Get list of bidders\n    ** @param _sid  Sale ID\n    ** @return List of bidder addresses\n    **/\n    function getAuctionBidders(uint256 _sid) \n        public view\n        returns (address[] memory)\n    { return _bidders[_sid]; }\n\n    /**\n    ** 12f2a515\n    ** @dev Get auction bid value\n    ** @param _sid      Sale ID\n    ** @param _bidder   Bidder address\n    ** @return Bid value\n    **/\n    function getBidValue(uint256 _sid, address _bidder) \n        public view\n        returns (uint256)\n    {\n        require(_bidder != address(0), \"ENEFTiMP.20.INVALID_BIDDER\"); // Unknown Bidder\n        return _poolBidding[_sid][_bidder];\n    }\n\n    /**\n    ** db794cbe\n    ** @dev Get highest bid amount\n    ** @param _sid  Sale ID\n    ** @return (\n    **    bidder  - Bidder address\n    **    bid     - Bid value\n    ** )\n    **/\n    function getHighestBidValue(uint256 _sid)\n        public view\n        returns (address bidder, uint256 bid)\n    { return ( _selling[_sid].buyer, _selling[_sid].values[1] ); }\n    \n\n    /*════════════oooooOooooo═════════════╗\n    ║█~~~~~~~ PURCHASING - DIRECT ~~~~~~~█║\n    ╚════════════════════════════════════*/\n\n    /**\n    ** 7de47861\n    ** @dev Buying item directly\n    ** @param _sid      Sale ID\n    ** @param _pid      Input PurchaseItems ID (client-side)\n    ** @param _amount   Amount to buy\n    **/\n    function txDirectBuy(\n        uint256 _sid,\n        uint256 _pid,\n        uint256 _amount\n    )\n        public nonReentrant\n    {\n        require (_selling[_sid].status == SaleStatus.OPEN, \"ENEFTiMP.21.NOT_FOR_SALE\"); // Item is not for sale!\n        require (_selling[_sid].saleDate[0] \u003c= block.timestamp, \"ENEFTiMP.22.ITEM_WAIT_FOR_CONFIRMATION\"); // Item is not yet for sale!\n        require (_selling[_sid].amount \u003e= _amount, \"ENEFTiMP.23.PURCHASE_AMOUNT_OVERFLOW\"); // Not enough tokens for sale!\n        require (address(msg.sender).balance \u003e 0, \"ENEFTiMP.24.ISSUE_TO_PAY_GAS\"); // Not enough BNB to spend for Gas fee!\n        \n        uint256 subTotal = _selling[_sid].price * _amount;\n        uint256 txFee = INEFTiMPFeeCalcExt(NEFTiMPFeeCalcExt).calcFeeOf( uint8(FeeTypes.DirectTransactionFee), subTotal, 0x01 );\n        require (IERC20(NEFTi20).balanceOf(msg.sender) \u003e= subTotal, \"ENEFTiMP.25.INSUFFICIENT_NEFTi\"); // Not enough NFT balance for purchase!\n\n        // transfer NFT20 purchase value to seller\n        IERC20(NEFTi20).safeTransferFrom( msg.sender, _selling[_sid].seller, subTotal.sub(txFee) );\n        // transfer NFT20 fee to owner\n        IERC20(NEFTi20).safeTransferFrom( msg.sender, NEFTiReceivable, txFee );\n        // then transfer NFT1155 token in return\n        INEFTiMultiTokens(NEFTiMT).safeTransferFrom( address(this), msg.sender, _selling[_sid].tokenId, _amount, \"\" );\n\n        _poolSales[ _selling[_sid].seller ][ _selling[_sid].tokenId ] = _selling[_sid].amount.sub(_amount);\n        _selling[_sid].amount = _selling[_sid].amount.sub(_amount);\n        if (_selling[_sid].amount == 0) { _selling[_sid].status = SaleStatus.FULFILLED; }\n        \n        emit Purchase(\n            _pid,\n            _sid,\n            _selling[_sid].tokenId,\n            _selling[_sid].price,\n            _amount,\n            1,\n            _selling[_sid].seller,\n            [ false, false, false, false ],\n            uint8(PurchaseStatus.FULFILLED)\n        );\n    }\n\n    /**\n    ** 38e8818e\n    ** @dev Buyer negotiate an offer\n    ** @param _sid      Sale ID\n    ** @param _amount   Amount to buy\n    ** @param _price    Price per token\n    **/\n    function txDirectOffering(\n        uint256 _sid,\n        uint256 _amount,\n        uint256 _price\n    )\n        public nonReentrant\n    {\n        require (_selling[_sid].status == SaleStatus.OPEN, \"ENEFTiMP.26.NOT_FOR_SALE\"); // Item is not for sale!\n        require (_selling[_sid].saleDate[0] \u003c= block.timestamp, \"ENEFTiMP.27.ITEM_WAIT_FOR_CONFIRMATION\"); // Item is not yet for sale!\n        require (_selling[_sid].amount \u003e= _amount, \"ENEFTiMP.28.OFFERING_AMOUNT_OVERFLOW\"); // Not enough tokens for sale!\n        require (address(msg.sender).balance \u003e 0, \"ENEFTiMP.29.ISSUE_TO_PAY_GAS\"); // Not enough BNB to spend for Gas fee!\n        require (_selling[_sid].states[1], \"ENEFTiMP.30.NEGOTIATION_DISABLED\"); // This item is not for negotiation!\n\n        uint256 subTotal = ( _price * _amount );\n        uint256 txFee = INEFTiMPFeeCalcExt(NEFTiMPFeeCalcExt).calcFeeOf( uint8(FeeTypes.DirectNegotiateFee), _price, _amount );\n        require((subTotal + txFee) \u003c= IERC20(NEFTi20).balanceOf(msg.sender), \"ENEFTiMP.31.INSUFFICIENT_NEFTi\"); // Not enough NFT token to place the offer!\n        \n        // transfer NFT20 negotiation price to pool\n        IERC20(NEFTi20).safeTransferFrom( msg.sender, address(this), subTotal );\n        // transfer NFT20 fee to owner\n        IERC20(NEFTi20).safeTransferFrom( msg.sender, NEFTiReceivable, txFee );\n\n        if (_poolNegotiating[_sid][msg.sender].value == 0) { _negotiators[_sid].push(msg.sender); }\n\n        uint256 prevPrice = (\n            _poolNegotiating[_sid][msg.sender].amount == 0\n                ? 0\n                : _poolNegotiating[_sid][msg.sender].value.div( _poolNegotiating[_sid][msg.sender].amount )\n        );\n        uint256 totalAmount = _poolNegotiating[_sid][msg.sender].amount.add( _amount );\n        \n        _poolNegotiating[_sid][msg.sender] = Negotiating(\n            _sid,\n            msg.sender,\n            ( prevPrice.add(_price) * totalAmount ),\n            totalAmount,\n            block.timestamp,\n            NegotiateStatus.OPEN\n        );\n\n        emit Negotiate(\n            _sid,\n            _selling[_sid].tokenId,\n            _amount,\n            _price,\n            msg.sender,\n            block.timestamp,\n            uint8(NegotiateStatus.OPEN)\n        );\n    }\n\n    /**\n    ** 9bf7b83a\n    ** @dev Seller accept an offer\n    ** @param _sid          Sale ID\n    ** @param _pid          Input PurchaseItems ID (client-side)\n    ** @param _negotiator   Selected negotiator address\n    **/\n    function txAcceptDirectOffering(\n        uint256 _sid,\n        uint256 _pid,\n        address _negotiator\n    )\n        public nonReentrant\n    {\n        require (_selling[_sid].status == SaleStatus.OPEN, \"ENEFTiMP.32.SALE_HAS_PASSED\"); // Item is not for sale anymore!\n        require (\n            (_selling[_sid].amount \u003e 0) \u0026\u0026\n            (_poolSales[msg.sender][_selling[_sid].tokenId] \u003e 0) \u0026\u0026\n            (_selling[_sid].amount \u003e= _poolNegotiating[_sid][_negotiator].amount),\n            \"ENEFTiMP.33.SALE_AMOUNT_UNDERFLOW\"\n        ); // Not enough tokens at pool for sale!\n        require (_poolNegotiating[_sid][_negotiator].status == NegotiateStatus.OPEN, \"ENEFTiMP.34.OFFER_HAS_PASSED\"); // This negotiation is not available anymore!\n        require (_poolNegotiating[_sid][_negotiator].amount \u003e 0, \"ENEFTiMP.35.UNDEFINED_OFFERING_AMOUNT\"); // Current negotiation amount was not set!\n        \n        uint256 subTotal = _poolNegotiating[_sid][_negotiator].value;\n        uint256 txFee = INEFTiMPFeeCalcExt(NEFTiMPFeeCalcExt).calcFeeOf(\n            uint8(FeeTypes.DirectTransactionFee),\n            subTotal,\n            1\n        );\n        \n        // transfer NFT20 purchased value to seller - fee\n        IERC20(NEFTi20).safeTransfer( _selling[_sid].seller, subTotal.sub(txFee) );\n        // transfer NFT20 fee to owner\n        IERC20(NEFTi20).safeTransfer( NEFTiReceivable, txFee );\n        // transfer NFT1155 asset to buyer\n        INEFTiMultiTokens(NEFTiMT).safeTransferFrom( address(this), _negotiator, _selling[_sid].tokenId, _poolNegotiating[_sid][_negotiator].amount, \"\" );\n        \n        uint256 updateAmount = _selling[_sid].amount.sub(1);\n        _poolSales[msg.sender][_selling[_sid].tokenId] = updateAmount;\n        _selling[_sid].amount = updateAmount;\n\n        if (_selling[_sid].amount == 0) { _selling[_sid].status = SaleStatus.FULFILLED; }\n        \n        _poolNegotiating[_sid][_negotiator].status = NegotiateStatus.FULFILLED;\n        \n        emit Purchase(\n            _pid,\n            _sid,\n            _selling[_sid].tokenId,\n            _poolNegotiating[_sid][_negotiator].value.div( _poolNegotiating[_sid][_negotiator].amount ), /** price  */ \n            _poolNegotiating[_sid][_negotiator].amount, /** amount */ \n            1,\n            _selling[_sid].seller,\n            [ false, false, false, false ],\n            uint8(PurchaseStatus.FULFILLED)\n        );\n    }\n\n\n    /*════════════oooooOooooo═════════════╗\n    ║█~~~~~~ PURCHASING - AUCTION ~~~~~~~█║\n    ╚════════════════════════════════════*/\n\n    /**\n    ** 5f212d35\n    ** @dev Buyer bid an offer\n    ** @param _sid      Sale ID\n    ** @param _price    Price to bid\n    **/\n    function txBid(\n        uint256 _sid,\n        uint256 _price\n    )\n        public nonReentrant\n    {\n        require (_selling[_sid].status == SaleStatus.OPEN, \"ENEFTiMP.36.NOT_FOR_AUCTION\"); // Item is not for auction!\n        require (_selling[_sid].saleDate[0] \u003c= block.timestamp, \"ENEFTiMP.37.ITEM_WAIT_FOR_CONFIRMATION\"); // Item is not yet for sale!\n\n        uint256 txFee = INEFTiMPFeeCalcExt(NEFTiMPFeeCalcExt).calcFeeOf(uint8(FeeTypes.AuctionBiddingFee), _price, 1);\n        require ((_price + txFee) \u003c= IERC20(NEFTi20).balanceOf(msg.sender), \"ENEFTiMP.38.INSUFFICIENT_NEFTi\"); // Not enough NFT token to bid in auction!\n        require (address(msg.sender).balance \u003e 0, \"ENEFTiMP.39.ISSUE_TO_PAY_GAS\"); // Not enough BNB to spend for Gas fee!\n\n        // when Auction\n        if (_selling[_sid].states[2]) {\n            require (_price \u003e= _selling[_sid].values[2], \"ENEFTiMP.40.BID_UNDERFLOW_THE_MULTIPLIER\"); // Bid value less than required multiplier!\n\n            uint256 _totalBids = _poolBidding[_sid][msg.sender].add(_price);\n            require ((_selling[_sid].values[1] + _selling[_sid].values[1]) \u003c _totalBids, \"ENEFTiMP.41.BID_UNDERFLOW_THE_HIGHEST\"); // Price is too lower than highest bid!\n\n            // send NFT20 to auction pool\n            IERC20(NEFTi20).safeTransferFrom( msg.sender, address(this), _price );\n            // send fee NFT20 to owner\n            IERC20(NEFTi20).safeTransferFrom( msg.sender, NEFTiReceivable, txFee );\n\n            if (_poolBidding[_sid][msg.sender] == 0) { _bidders[_sid].push(msg.sender); }\n\n            // if exist and higher than the highest bid, update to auction bidding pool\n            _poolBidding[_sid][msg.sender] = _totalBids;\n\n            // update highest bidder price and address\n            _selling[_sid].values[1] = _totalBids;\n            _selling[_sid].buyer = msg.sender;\n            \n            _poolBidding[_sid][msg.sender] = _totalBids;\n\n            emit Bid(\n                _sid,\n                _selling[_sid].tokenId,\n                _selling[_sid].amount,\n                _totalBids,\n                msg.sender,\n                block.timestamp,\n                uint8(NegotiateStatus.OPEN)\n            );\n        }\n        // This item is not for auction!\n        else { revert(\"ENEFTiMP.42.ITEM_NOT_FOR_AUCTION\"); }\n    }\n\n    /**\n    ** da064fc0\n    ** @dev Buyer accept an offer of highest bid\n    ** @param _sid  Sale ID\n    ** @param _pid  Input PurchaseItems ID (client-side)\n    **/\n    function txAcceptAuctionBid(\n        uint256 _sid,\n        uint256 _pid\n    )\n        public nonReentrant\n    {\n        require (_selling[_sid].status == SaleStatus.OPEN, \"ENEFTiMP.43.AUCTION_HAS_PASSED\"); // Item is not for auction anymore!\n        require (\n            (_selling[_sid].amount \u003e 0) \u0026\u0026\n            (_poolSales[msg.sender][_selling[_sid].tokenId] \u003e 0),\n            \"ENEFTiMP.44.BID_AMOUNT_OVERFLOW\"\n        ); // Not enough tokens at pool for sale!\n        \n        require (_selling[_sid].buyer != address(0), \"ENEFTiMP.45.INVALID_BIDDER\"); // Current bidder address was not set!\n        require (_poolBidding[_sid][_selling[_sid].buyer] \u003e 0, \"ENEFTiMP.46.INVALID_BID_VALUE\"); // Current bid value was not available!\n        require (_selling[_sid].values[1] \u003e 0, \"ENEFTiMP.47.UNDEFINED_HIGHEST_BID\"); // Highest bid value was not set!\n        \n        uint256 txFee = INEFTiMPFeeCalcExt(NEFTiMPFeeCalcExt).calcFeeOf( uint8(FeeTypes.AuctionTransactionFee), _selling[_sid].values[1], 0x01 );\n        \n        uint256 subTotal = _selling[_sid].values[1];\n        \n        // transfer NFT20 purchased value to seller - fee\n        IERC20(NEFTi20).safeTransferFrom( address(this), _selling[_sid].seller, subTotal.sub(txFee) );\n        // transfer NFT20 fee to owner\n        IERC20(NEFTi20).safeTransferFrom( address(this), NEFTiReceivable, txFee );\n        // transfer NFT1155 asset to buyer\n        INEFTiMultiTokens(NEFTiMT).safeTransferFrom( address(this), _selling[_sid].buyer, _selling[_sid].tokenId, _selling[_sid].amount, \"\" );\n        \n        uint256 updateAmount = _selling[_sid].amount.sub(1);\n        _poolSales[msg.sender][_selling[_sid].tokenId] = updateAmount;\n        _selling[_sid].amount = updateAmount;\n        if (_selling[_sid].amount == 0) { _selling[_sid].status = SaleStatus.FULFILLED; }\n        _poolBidding[_sid][_selling[_sid].buyer] = 0;\n        \n        emit Purchase(\n            _pid,\n            _sid,\n            _selling[_sid].tokenId,\n            /* price  */ _poolBidding[_sid][ _selling[_sid].buyer ].div( _selling[_sid].amount ),\n            /* amount */ _selling[_sid].amount,\n            1,\n            _selling[_sid].seller,\n            [ false, false, true, false ],\n            uint8(PurchaseStatus.FULFILLED)\n        );\n    }\n\n\n    /*════════════oooooOooooo═════════════╗\n    ║█~~~~~~~~~~ MISCELLANEOUS ~~~~~~~~~~█║\n    ╚════════════════════════════════════*/\n\n    /**\n    ** f3c2e296\n    ** @dev Caller is refers to a smart contract\n    ** @return The acceptance magic value\n    **/\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata)\n        external pure\n        returns(bytes4)\n    { return bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\")); }\n\n    /**\n    ** 1cb8a750\n    ** @dev Default Payment info\n    ** @return (\n    **    tokenContract - ERC20 contract address\n    **    decimals      - ERC20 decimals\n    **    priceUSD      - Equivalent value in USD\n    ** )\n    **/\n    function defaultPayment()\n        public view\n        returns (address tokenContract, uint8 decimals, uint256 priceUSD)\n    { (tokenContract, decimals, priceUSD) = INEFTiMPFeeCalcExt(NEFTiMPFeeCalcExt).defaultPayment(); }\n\n    /**\n    ** c1f7235a\n    ** @dev Get Calculated Fees\n    ** @param _price    Item price\n    ** @param _amount   Amount of item\n    ** @return List of calculated fees\n    ** +---\u003e   uint256 DirectListingFee,\n    ** +---\u003e   uint256 DirectListingCancellationFee,\n    ** +---\u003e   uint256 DirectNegotiateFee,\n    ** +---\u003e   uint256 DirectNegotiateCancellationFee,\n    ** +---\u003e   uint256 DirectTransactionFee,\n    ** +---\u003e   uint256 AuctionListingFee,\n    ** +---\u003e   uint256 AuctionListingCancellationFee,\n    ** +---\u003e   uint256 AuctionBiddingFee,\n    ** +---\u003e   uint256 AuctionBiddingCancellationFee,\n    ** +---\u003e   uint256 AuctionTransactionFee\n    **/\n    function feesOf(uint256 _price, uint256 _amount)\n        public view\n        returns (uint256[11] memory fees)\n    {   \n        // uint256[11] memory fees;\n        fees[0] = 0;\n        for (uint8 i=1; i\u003c11; i++) { fees[i] = INEFTiMPFeeCalcExt(NEFTiMPFeeCalcExt).calcFeeOf(i, _price, _amount); }\n        // return fees;\n    }\n\n    /**\n    ** 2612ddc0\n    ** @dev Update External Relationship\n    ** @param _extType   External type\n    ** @param _extTarget External address\n    **/\n    function updateExtRelationship(uint8 _extType, address _extTarget)\n        public onlyOwner\n    {\n        if (ExternalRelationship(_extType) == ExternalRelationship.NEFTi20) { NEFTi20 = _extTarget; }\n        else if (ExternalRelationship(_extType) == ExternalRelationship.NEFTiMultiTokens) { NEFTiMT = _extTarget; }\n        else if (ExternalRelationship(_extType) == ExternalRelationship.NEFTiMPFeeCalcExt) { NEFTiMPFeeCalcExt = _extTarget; }\n        else { revert(\"ENEFTiMP.48.INVALID_EXTERNAL_RELATIONSHIP\"); } // Invalid external relationship type\n        emit UpdateExternalRelationship(_extType, _extTarget);\n    }\n\n    /**\n    ** 4b28fc21\n    ** @dev Update Receivable account\n    ** @param _NEFTiAccount Account address\n    **/\n    function updateReceivable(address _NEFTiAccount)\n        public onlyOwner\n    {\n        require(_NEFTiAccount != address(0), \"ENEFTiMP.49.INVALID_NEFTi_ACCOUNT\");\n        NEFTiReceivable = _NEFTiAccount;\n        emit UpdateReceivableTo(_NEFTiAccount);\n    }\n\n    /**\n    ** 220a8b22\n    ** @dev Send Asset\n    ** @param _to       Receiver address\n    ** @param _tokenId  Asset ID\n    ** @param _amount   Asset amount\n    **/\n    function sendAssets(address _to, uint256 _tokenId, uint256 _amount)\n        public nonReentrant onlyOwner\n    {\n        require(_amount \u003e 0, \"ENEFTiMP.50.INVALID_AMOUNT\"); // Amount must be greater than 0\n        require(_tokenId \u003e 0, \"ENEFTiMP.51.INVALID_TOKEN_ID\"); // Token ID must be greater than 0\n        INEFTiMultiTokens cNEFTiMT = INEFTiMultiTokens(NEFTiMT);\n        require(cNEFTiMT.balanceOf(address(this), _tokenId) \u003e= _amount, \"ENEFTiMP.52.INSUFFICIENT_FOR_TOKEN_ID\"); // Insufficient tokens\n        cNEFTiMT.safeTransferFrom(address(this), _to, _tokenId, _amount, \"\");\n    }\n\n    /**\n    ** 88436dbd\n    ** @dev Send Currency\n    ** @param _tokenContract    Receiver address\n    ** @param _to               Asset ID\n    ** @param _amount           Asset amount\n    **/\n    function sendCurrencies(address _tokenContract, address _to, uint256 _amount)\n        public nonReentrant onlyOwner\n    {\n        require(_amount \u003e 0, \"ENEFTiMP.53.INVALID_AMOUNT\"); // Amount must be greater than 0\n        if (_tokenContract != address(0)) {\n            IERC20 _ERC20 = IERC20(_tokenContract);\n            require(_ERC20.balanceOf(address(this)) \u003e= _amount, \"ENEFTiMP.54.INSUFFICIENT_ERC20\"); // Insufficient tokens\n            _ERC20.safeTransfer(_to, _amount);\n        } else {\n            (bool sent, ) = address(this).call{ value: _amount }(\"\");\n            require(sent, \"ENEFTiMP.55.INSUFFICIENT_BALANCE\"); // Insufficient Balance\n        }\n    }\n\n    /**\n    ** b6485833\n    ** @dev Suspending Sale item\n    ** @param _sid          Sale ID\n    ** @param _isSuspended  True/False\n    **/\n    function suspend(uint256 _sid, bool _isSuspended)\n        public onlyOwner\n    {\n        require(_sid \u003e 0, \"ENEFTiMP.56.INVALID_SALE_ITEM_ID\"); // Sale item ID must be greater than 0\n        _selling[_sid].status = (_isSuspended  ? SaleStatus.SUSPENDED : SaleStatus.OPEN);\n        emit Suspended(_sid, _selling[_sid].tokenId, _selling[_sid].seller, _isSuspended);\n    }\n\n    /**\n    ** f7cced22\n    ** @dev Delisting Sale item\n    ** @param _sid          Sale ID\n    **/\n    function delist(uint256 _sid)\n        public onlyOwner\n    {\n        require(_sid \u003e 0, \"ENEFTiMP.57.INVALID_SALE_ITEM_ID\"); // Sale item ID must be greater than 0\n        INEFTiMultiTokens(NEFTiMT).safeTransferFrom( address(this), _selling[_sid].seller, _selling[_sid].tokenId, _selling[_sid].amount, \"\" );\n        _selling[_sid].status = SaleStatus.DELISTED;\n        emit Delisted(_sid, _selling[_sid].tokenId, _selling[_sid].seller);\n    }\n\n    /**\n    ** 1955f1b8\n    ** @dev Show legal info\n    ** @return (\n    **    string title,\n    **    string license,\n    **    string version,\n    **    string url\n    ** )\n    **/\n    function legalInfo()\n        public view\n        returns (string memory _title, string memory _license, string memory _version, string memory _url)\n    { (_title, _license, _version, _url) = INEFTiLicense(NEFTiLegalInfo).legalInfo(); }\n\n    /**\n    ** 31084f3e\n    ** @dev Update legal info\n    ** @param _newLegalInfo Updated info\n    **/\n    function updateLicense(address _newLegalInfo)\n        public onlyOwner\n    { NEFTiLegalInfo = _newLegalInfo; }\n\n    /**\n    ** @dev NEFTi Marketplace contract constructor\n    ** @params _NEFTi20 - address of ERC20 contract for NFT20\n    ** @params _NEFTiMT - address of ERC1155 contract for NFT1155\n    ** @params _NEFTiMPFeeCalcExt - address of NEFTi MP Fee Calc Extension contract\n    ** @params _NEFTiReceivable - address of NEFTi Receivable contract\n    **/\n    constructor(address _NEFTi20, address _NEFTiMT, address _NEFTiMPFeeCalcExt, address _NEFTiAccount, address _NEFTiLegalInfo)\n    {\n        NEFTi20 = _NEFTi20;\n        NEFTiMT = _NEFTiMT;\n        NEFTiMPFeeCalcExt = _NEFTiMPFeeCalcExt;\n        NEFTiReceivable = _NEFTiAccount;\n        NEFTiLegalInfo = _NEFTiLegalInfo;\n    }\n\n    /*════════════════════════════oooooOooooo════════════════════════════╗\n    ║█  (!) WARNING  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~█║\n    ╚════════════════════════════════════════════════════════════════════╝\n    ║  There are no handler in fallback function,                        ║\n    ║  If there are any incoming value directly to Smart Contract, will  ║\n    ║  considered as generous donation. And Thank you!                   ║\n    ╚═══════════════════════════════════════════════════════════════════*/\n    receive () external payable /* nonReentrant */ {}\n    fallback () external payable /* nonReentrant */ {}\n}\n\n/**\n**    █▄░█ █▀▀ █▀▀ ▀█▀ █ █▀█ █▀▀ █▀▄ █ ▄▀█\n**    █░▀█ ██▄ █▀░ ░█░ █ █▀▀ ██▄ █▄▀ █ █▀█\n**    ____________________________________\n**    https://neftipedia.com\n**    contact@neftipedia.com\n**/\n"},"NEFTiMPStorages.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity \u003e=0.7.4 \u003c=0.8.9;\n\ncontract NEFTiMPStorages {\n    // enum ResourceClasses {\n    //     IMAGE,          // 0x00,\n    //     AUDIO,          // 0x01,\n    //     VIDEO,          // 0x02,\n    //     OBJECT3D,       // 0x03,\n    //     DOCUMENT,       // 0x04,\n    //     FONT,           // 0x05,\n    //     REDEEMABLE,     // 0x06,\n    //     GAMEASSETS      // 0x07,\n    // }\n\n    enum SaleMethods {\n        DIRECT,         // 0x00,                                    (1) seller pays gas to get listing,\n                        //                                          (2) buyer pays gas to purchase,\n                        //                                          (3) seller receive payment from buyer - transaction fee\n\n        AUCTION         // 0x01,                                    (1) seller pays gas and auction listing fee,\n                        //                                          (2) bidder pays gas for each bids to purchase,\n                        //                                          (3) auction which have no bidder are able cancel by seller, costs gas\n                        //                                          (4) bidder pays gas for cancellation, also costs transaction fee\n                        //                                          (5) bidder unable to cancel bids last 1 hour before auction time expired\n                        //                                          (6) seller may claim the highest bid when auction was completed\n                        //                                              within 1 hour after the expiration time, cost gas and transaction fee\n                        //                                          (7) or the company pays gas to set auto-expired for auction after 1 hour\n    }\n\n    enum FeeTypes {\n        none,\n        \n        DirectListingFee,                                           // FREE\n        DirectListingCancellationFee,                               // FREE\n        DirectNegotiateFee,                                         // FREE\n        DirectNegotiateCancellationFee,                             // 0.5% x Negotiate Price\n        DirectTransactionFee,                                       // 0.8% x Item Price\n\n        AuctionListingFee,                                          // 0.3% x Item Price\n        AuctionListingCancellationFee,                              // 0.5% x Item Price\n        AuctionBiddingFee,                                          // 0.1% x Bid Price\n        AuctionBiddingCancellationFee,                              // 0.5% x Bid Price\n        AuctionTransactionFee                                       // 0.8% x Item Price\n    }\n\n    enum SaleStatus {\n        OPEN,           // 0x00,    sale is open                    (gas pays by the seller)\n        FULFILLED,      // 0x01,    sale is filfilled               (gas pays by the buyer)\n        RENTING,        // 0x02,    an item goes on rent                \n        PAUSED,         // 0x03,    an item paused                  (gas pays by the seller)                \n        CANCELED,       // 0x04,    sale is cancelled               (gas may pays by the seller or the buyer)\n        EXPIRED,        // 0x05,    sale is expired                 (gas may pays by the seller or the company)\n        SUSPENDED,      // 0x06,    sale is suspended               (gas pays by the company)\n        DELISTED        // 0x07,    sale is delisted                (gas pays by the company)\n    }\n\n    enum PurchaseStatus {\n        ACCEPTED,       // 0x00,    sale is open                    (gas pays by the seller)\n        SENDING,        // 0x01,    sale is closed                  (gas pays by the buyer)\n        INPROGRESS,     // 0x02,    an item goes on rent            \n        REJECTED,       // 0x03,    an item on escrow               \n        FULFILLED       // 0x04,    sale is cancelled               (gas may pays by the seller or the buyer)\n    }\n\n    enum NegotiateStatus {\n        OPEN,           // 0x00,    negotiation is open             (gas pays by the buyer as negotiator)\n        SENDING,        // 0x01,    negotiation OK, sending         (gas pays by the seler to accept, and sending items)\n        INPROGRESS,     // 0x02,    negotiation OK, in progress     (gas pays by the seler to accept, and in progress)\n        FULFILLED,      // 0x03,    negotiation is fulfilled        (gas pays by the buyer to fulfill the rent)\n        REJECTED,       // 0x04,    negotiation is rejected         (gas pays by the seller to reject)\n        CANCELED        // 0x05,    IF BUYER cancel negotiation     (gas pays by the buyer, also charge cancellation fee as income to the company)\n                        //          IF SELLER cancel negotiation    (gas pays by the seller, also charge cancellation fee as income to the company)\n    }\n\n    enum ExternalRelationship {\n        _NONE_,\n        NEFTi20,\n        NEFTiMultiTokens,\n        NEFTiMPFeeCalcExt\n    }\n\n    struct SaleItems {\n        uint256    tokenId;\n        uint256    price;\n        uint256    amount;\n        address    seller;\n        bool[4]    states;\n        //+-----\u003e  bool isPostPaid;\n        //+-----\u003e  bool isNegotiable;\n        //+-----\u003e  bool isAuction;\n        //+-----\u003e  bool isContract;\n        uint256[2] saleDate;\n        uint256[3] values;\n        //+-----\u003e  uint256 valContract;\n        //+-----\u003e  uint256 highBid;\n        //+-----\u003e  uint256 bidMultiplier;\n        address    buyer;\n        SaleStatus status;\n    }\n\n    struct Negotiating {\n        uint256         saleHash;\n        address         negosiator;\n        uint256         value;\n        uint256         amount;\n        uint256         negoDate;\n        NegotiateStatus status;\n    }\n\n    // @dev Sale Pool\n    // @params address Seller address\n    // @params uint256 TokenId\n    // @return uint256 Balance amount of token\n    mapping (address =\u003e mapping (uint256 =\u003e uint256)) internal _poolSales;\n\n    // @dev Sale Pool Info\n    // @params uint256 Sale ID\n    // @return SaleItems struct of SaleItems\n    mapping (uint256 =\u003e SaleItems) internal _selling;\n\n    // @dev Listed items by Seller address\n    // @params address Seller address\n    // @return uint256[] Sale Ids\n    mapping (address =\u003e uint256[]) internal _itemsOnSaleItems;\n\n    // @dev All listed items Sale Ids\n    // uint256[] internal _saleItems;\n    \n    // @dev Bidding pool for Auction\n    // @params uint256 Sale/Auction ID\n    // @params address Buyers (_bidders)\n    // @return uint256 Bid value\n    mapping (uint256 =\u003e mapping (address =\u003e uint256)) internal _poolBidding;\n\n    // @dev Negotiation pool\n    // @params uint256 Sale ID\n    // @params address Negotiator\n    // @return uint256 Negotiating Info\n    mapping (uint256 =\u003e mapping (address =\u003e Negotiating)) internal _poolNegotiating;\n\n    // @dev Bidders in Auction\n    // @params uint256 Sale ID\n    // @return address[] Bidders\n    mapping (uint256 =\u003e address[]) _bidders;\n\n    // @dev Negotiators in Sale\n    // @params uint256 Sale ID\n    // @return address[] Negotiators\n    mapping (uint256 =\u003e address[]) _negotiators;\n\n    // mapping (address =\u003e uint256) internal txNonce;\n}\n\n/**\n**    █▄░█ █▀▀ █▀▀ ▀█▀ █ █▀█ █▀▀ █▀▄ █ ▄▀█\n**    █░▀█ ██▄ █▀░ ░█░ █ █▀▀ ██▄ █▄▀ █ █▀█\n**    ____________________________________\n**    https://neftipedia.com\n**    contact@neftipedia.com\n**/\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT OR Apache-2.0\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\n\npragma solidity \u003e=0.7.4 \u003c=0.8.9;\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address private _owner_;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor () {\n    _owner_ = msg.sender;\n    emit OwnershipTransferred(address(0), _owner_);\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == _owner_, \"ENEFTiOA__onlyOwner__SENDER_IS_NOT_OWNER\");\n    _;\n  }\n\n  /**\n   * @notice Transfers the ownership of the contract to new address\n   * @param _newOwner Address of the new owner\n   */\n  function transferOwnership(address _newOwner)\n    public onlyOwner\n  {\n    require(_newOwner != address(0), \"ENEFTiOA__transferOwnership__INVALID_ADDRESS\");\n    emit OwnershipTransferred(_owner_, _newOwner);\n    _owner_ = _newOwner;\n  }\n\n  /**\n   * @notice Returns the address of the owner.\n   */\n  function owner()\n    public view\n    returns (address)\n  { return _owner_; }\n}"},"ReentrancyGuard.sol":{"content":"// SPDX-License-Identifier: MIT\n\n// pragma solidity ^0.8.0;\npragma solidity \u003e=0.7.4 \u003c=0.8.9;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\u0027s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\u0027s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\u0027s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"},"SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IERC20.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \u0027safeIncreaseAllowance\u0027 and \u0027safeDecreaseAllowance\u0027\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\u0027s return data size checking mechanism, since\n        // we\u0027re implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler\u0027s built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations.\n *\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c \u003c a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b \u003e a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n            // benefit is lost if \u0027b\u0027 is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003c= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003e 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003e 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"}}