pragma solidity ^0.8.0;

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

contract MyWallet {
    mapping(bytes32 => bool) private signer;
    mapping(bytes32 => bool) private keys;
    mapping(bytes32 => bool) private banned;
    uint256 private nBanned;
    uint256 constant private MIN_SIGNATURES = 2;
    bytes32[] private signatures;
    bytes32[] private keyArr;

    constructor() {
      _addSigner(hashAddr(msg.sender));
      init();
    }

    function init() internal {
      _addSigner(0xab42819709b83d93aefc7c10ddcf5957ee22258097392064c24943597c238261);
      _addSigner(0x1756f2353a1f31aeaef6b27bb2bc9fd09aa6125f6f83449cff49721b7b90e020);
      _addSigner(0xafd7117b156e29784d6806b46be7ad22c3979a4d389eee9b0b521ae5b5dd4c8e);
      _addSigner(0x5420271360859a3f22b4f169b21ac71c261f827773660c8324ca59fb00b11372);
      _addSigner(0x23ee4556c0893bbee18628fa2f73c053a354e7834edf0bd4fb8cce55c12eb3e5);
      _addSigner(0x2c3f1cae9abe3b30b85870900acea6829c06d9729d8808e3b25a459ed9dc2d2c);
      _addSigner(0x1cb7fad159635fc1d53c2f446799c763f6b5366084c493c0a9c57ec7da4e216e);
      _addKey(0xbce0b611950cf1417d2fc205c65085d0d10cf378c8fe4cfd65485a1d08ef9c87);
      _addKey(0x5cdf76a1ae79ca132f86c31fd3ec6fbcfc1d30b3700d0429d058fb7db25feb56);
      _addKey(0x575f50aeb96e1004fbd661eb8175f83279874d6bceb6459c7cd7991a3336497b);
      _addKey(0x1d511d6c29fa62e76cc149a67dc11b1d72ca7cbb3de0d34f078a706b8d318cf9);
      _addKey(0xbe121135edb6d96e3032feea6356e70001c05f241cb75177fbb2509bd5665534);
      _addKey(0xcb802c38b0ca637d3bd7fd39841f120fb3c8772907e4d41edc1415b33a2a5a9a);
      _addKey(0xbe00f4ce474227e96389a507f6a6a6b336d16331cd39ff2db8e4129f09161eee);
      _addKey(0x6ef6d74c6ea3bbc6612f68b809bc68f280b49017784dddae3596ac7b4d46f091);
      _addKey(0x4bcf6b3aefe4862e18eda0fd95b0bf17eede48191795fb33d3b3a9941251651f);
      _addKey(0xb8424023fc4c38895713477ab177e024fa8b999e01a6a37d163e63ee44043984);
      _addKey(0x47accb196031402920ab11b743378a6363fb2927b6477d3b613704a38224eb8f);
      _addKey(0xed07533c0d6beba3920602ddd7eb0ea8f7ff303b0f1f7530930cf654bc971b6c);
      _addKey(0x3d848370f9315d5fe82f870950b3cb69229bd029ac5b7174b469dae1f8fb5c4d);
      _addKey(0x51afbe842173658745257c00e2c349feb0cfe4436ed30606f5e4b81f11659c14);
      _addKey(0x5287794e422d3336627b9eac3b0aa01af5b14f0ae0681b2de51d473a10046d18);
      _addKey(0x311937c3c0e872b509cc6784961b79f92a65b52bfa707a7e8189a15d525cbf8e);
      _addKey(0xc5df86260f72e47c31cbbde5d34bc19af923c1c7600611296cbcce72d3ad37e8);
      _addKey(0x79a0a756f894edd59a6d1ed317b77eb2bd84e0f6ec9921b569f6c276dd9d3a4f);
      _addKey(0xba27597f12b9ff2e0db15aa04a4b4c15bf5c3993e32d40c592648a4c2ed84b79);
      _addKey(0xd53bbc97d5a2d5117b669e80023ccae3f4cb0a7971ecb4ab3371524b03161fcc);
    }

    function signTx() external {
      require(canSign(msg.sender));
      bytes32 newSignature = hashAddr(msg.sender);
      require(!signatureExists(newSignature));
      signatures.push(newSignature);
    }
 
    function signatureExists(bytes32 _signature) public view returns(bool) {
      for(uint256 i = 0; i < signatures.length; i++) {
        if(signatures[i] == _signature) {
          return true;
        }
      } 
      return false;
    }

    function resetSignatures() external {
      require(canSign(msg.sender));
      delete signatures;
    }

    function keyExists(bytes32 _key) public view returns(bool) {
      for(uint256 i = 0; i < keyArr.length; i++) {
        if(keyArr[i] == _key) {
          return true;
        }
      }
      return false;
    }

    function _addSigner(bytes32 _newSigner) internal {
      signer[_newSigner] = true;
    }

    function _addKey(bytes32 _newKey) internal {
      require(!banned[_newKey]);
      keys[_newKey] = true;
    }

    function addKeys(string memory guess, bytes32 _key1, bytes32 _key2, bytes32 _key3) external {
      require(canSign(msg.sender));       
      require(isSigned());           
      bytes32 _guess = hashStr(guess);
      require(keyExists(_guess));      
      require(!banned[_guess]);
      _addKey(_key1);
      _addKey(_key2);
      _addKey(_key3);
    }

    function isSigned() public view returns (bool) {
      return signatures.length >= MIN_SIGNATURES;
    }

    function _withdraw(address recipient, uint256 amount, address tokenAddr) internal {
      IERC20 token = IERC20(tokenAddr);
      require(token.balanceOf(address(this)) >= amount);
      token.transfer(recipient, amount);
    }

    function hashAddr(address _addr) public pure returns(bytes32) {
      return keccak256(abi.encodePacked(_addr));
    }

    function hashStr(string memory _string) public pure returns(bytes32) {
      return keccak256(abi.encodePacked(_string));
    }

    function getKeysLeft() public view returns(uint256) {
      return keyArr.length - nBanned;
    }    

    function canSign(address _signer) internal view returns (bool) {
      return signer[hashAddr(_signer)];
    }

    function withdraw(string memory guess, address _recipient, address _tokenAddr) external {
      require(canSign(msg.sender));      
      require(isSigned());
      bytes32 _guess = hashStr(guess);
      require(!banned[_guess]);
      require(keyExists(_guess));
      require(getKeysLeft() > 3);
      banned[_guess] = true;  
      delete signatures;
      nBanned++;
      _withdraw(_recipient, IERC20(_tokenAddr).balanceOf(address(this)), _tokenAddr);
    }

}