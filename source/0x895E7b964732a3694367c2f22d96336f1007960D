{"MerkleProof.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/cryptography/MerkleProof.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev These functions deal with verification of Merkle Tree proofs.\r\n *\r\n * The proofs can be generated using the JavaScript library\r\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\r\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\r\n *\r\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\r\n *\r\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\r\n * hashing, or use a hash function other than keccak256 for hashing leaves.\r\n * This is because the concatenation of a sorted pair of internal nodes in\r\n * the merkle tree could be reinterpreted as a leaf value.\r\n */\r\nlibrary MerkleProof {\r\n    /**\r\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\r\n     * defined by `root`. For this, a `proof` must be provided, containing\r\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\r\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\r\n     */\r\n    function verify(\r\n        bytes32[] memory proof,\r\n        bytes32 root,\r\n        bytes32 leaf\r\n    ) internal pure returns (bool) {\r\n        return processProof(proof, leaf) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Calldata version of {verify}\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function verifyCalldata(\r\n        bytes32[] calldata proof,\r\n        bytes32 root,\r\n        bytes32 leaf\r\n    ) internal pure returns (bool) {\r\n        return processProofCalldata(proof, leaf) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\r\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\r\n     * hash matches the root of the tree. When processing the proof, the pairs\r\n     * of leafs \u0026 pre-images are assumed to be sorted.\r\n     *\r\n     * _Available since v4.4._\r\n     */\r\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\r\n        bytes32 computedHash = leaf;\r\n        for (uint256 i = 0; i \u003c proof.length; i++) {\r\n            computedHash = _hashPair(computedHash, proof[i]);\r\n        }\r\n        return computedHash;\r\n    }\r\n\r\n    /**\r\n     * @dev Calldata version of {processProof}\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\r\n        bytes32 computedHash = leaf;\r\n        for (uint256 i = 0; i \u003c proof.length; i++) {\r\n            computedHash = _hashPair(computedHash, proof[i]);\r\n        }\r\n        return computedHash;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the `leaves` can be proved to be a part of a Merkle tree defined by\r\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function multiProofVerify(\r\n        bytes32[] memory proof,\r\n        bool[] memory proofFlags,\r\n        bytes32 root,\r\n        bytes32[] memory leaves\r\n    ) internal pure returns (bool) {\r\n        return processMultiProof(proof, proofFlags, leaves) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Calldata version of {multiProofVerify}\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function multiProofVerifyCalldata(\r\n        bytes32[] calldata proof,\r\n        bool[] calldata proofFlags,\r\n        bytes32 root,\r\n        bytes32[] memory leaves\r\n    ) internal pure returns (bool) {\r\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the root of a tree reconstructed from `leaves` and the sibling nodes in `proof`,\r\n     * consuming from one or the other at each step according to the instructions given by\r\n     * `proofFlags`.\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function processMultiProof(\r\n        bytes32[] memory proof,\r\n        bool[] memory proofFlags,\r\n        bytes32[] memory leaves\r\n    ) internal pure returns (bytes32 merkleRoot) {\r\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\r\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\r\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\r\n        // the merkle tree.\r\n        uint256 leavesLen = leaves.length;\r\n        uint256 totalHashes = proofFlags.length;\r\n\r\n        // Check proof validity.\r\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\r\n\r\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\r\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\u0027s \"pop\".\r\n        bytes32[] memory hashes = new bytes32[](totalHashes);\r\n        uint256 leafPos = 0;\r\n        uint256 hashPos = 0;\r\n        uint256 proofPos = 0;\r\n        // At each step, we compute the next hash using two values:\r\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\r\n        //   get the next hash.\r\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\r\n        //   `proof` array.\r\n        for (uint256 i = 0; i \u003c totalHashes; i++) {\r\n            bytes32 a = leafPos \u003c leavesLen ? leaves[leafPos++] : hashes[hashPos++];\r\n            bytes32 b = proofFlags[i] ? leafPos \u003c leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\r\n            hashes[i] = _hashPair(a, b);\r\n        }\r\n\r\n        if (totalHashes \u003e 0) {\r\n            return hashes[totalHashes - 1];\r\n        } else if (leavesLen \u003e 0) {\r\n            return leaves[0];\r\n        } else {\r\n            return proof[0];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Calldata version of {processMultiProof}\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function processMultiProofCalldata(\r\n        bytes32[] calldata proof,\r\n        bool[] calldata proofFlags,\r\n        bytes32[] memory leaves\r\n    ) internal pure returns (bytes32 merkleRoot) {\r\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\r\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\r\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\r\n        // the merkle tree.\r\n        uint256 leavesLen = leaves.length;\r\n        uint256 totalHashes = proofFlags.length;\r\n\r\n        // Check proof validity.\r\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\r\n\r\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\r\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\u0027s \"pop\".\r\n        bytes32[] memory hashes = new bytes32[](totalHashes);\r\n        uint256 leafPos = 0;\r\n        uint256 hashPos = 0;\r\n        uint256 proofPos = 0;\r\n        // At each step, we compute the next hash using two values:\r\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\r\n        //   get the next hash.\r\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\r\n        //   `proof` array.\r\n        for (uint256 i = 0; i \u003c totalHashes; i++) {\r\n            bytes32 a = leafPos \u003c leavesLen ? leaves[leafPos++] : hashes[hashPos++];\r\n            bytes32 b = proofFlags[i] ? leafPos \u003c leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\r\n            hashes[i] = _hashPair(a, b);\r\n        }\r\n\r\n        if (totalHashes \u003e 0) {\r\n            return hashes[totalHashes - 1];\r\n        } else if (leavesLen \u003e 0) {\r\n            return leaves[0];\r\n        } else {\r\n            return proof[0];\r\n        }\r\n    }\r\n\r\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\r\n        return a \u003c b ? _efficientHash(a, b) : _efficientHash(b, a);\r\n    }\r\n\r\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x00, a)\r\n            mstore(0x20, b)\r\n            value := keccak256(0x00, 0x40)\r\n        }\r\n    }\r\n}\r\n"},"presalebsc.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\nimport \"./MerkleProof.sol\";\r\n\r\n\r\ncontract Context {\r\n\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return payable(msg.sender);\r\n    }\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\ninterface IBEP20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) \r\n    \r\n    {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003c= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b \u003e 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor ()  {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\ncontract ARC_Presale is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    IBEP20 public USDC;\r\n    IBEP20 public BUSD;\r\n\r\n\r\n    \r\n    uint256 public ARCpricePerUSDC = 23330000000000000000000; // 23330 ARC per USDC\r\n    uint256 public ARCpricePerBUSD = 23330000000000000000000; // 23330 ARC per BUSD\r\n    uint256 public ARC_Sold;\r\n    uint256 public maxTokeninPresale= 2333000000*(1E18);\r\n\r\n\r\n\r\n    bool public presaleStatus;\r\n    bool public WL_Acces;\r\n    bytes32 public root;\r\n    mapping(address =\u003e uint256) public deposits;\r\n    event Deposited(address indexed user, uint256 amount);\r\n    event Recovered(address token, uint256 amount);\r\n   \r\n\r\n    constructor(IBEP20 _USDC,IBEP20 _BUSD,bytes32 merkleroot)  {\r\n        USDC = _USDC;\r\n        BUSD=_BUSD;\r\n        root = merkleroot;\r\n    }\r\n\r\n     receive() external payable {\r\n            // React to receiving ETH\r\n        }\r\n\r\n\r\n\r\n\r\n    function BuyARCWithUSDC(uint256 _USDCAmount,bytes32[] calldata proof) external \r\n    {\r\n         require(ARC_Sold.add(getARCvalueperUSDC(_USDCAmount))\u003c=maxTokeninPresale,\"Hardcap Reached!\");\r\n        if(WL_Acces==true){\r\n        require(isValid(proof, keccak256(abi.encodePacked(msg.sender))), \"Not a part of Allowlist\");\r\n        require(presaleStatus == false, \"Presale : Presale is started\");  \r\n        }\r\n        else{\r\n        require(presaleStatus == true, \"Presale : Presale is finished\"); \r\n        }\r\n        require(_USDCAmount \u003e 0, \"Presale : Unsuitable Amount\");\r\n        require(USDC.balanceOf(msg.sender)\u003e_USDCAmount,\"not enough USDC in your wallet\");\r\n        USDC.transferFrom(msg.sender, address(this), _USDCAmount); \r\n        ARC_Sold =ARC_Sold.add(getARCvalueperUSDC(_USDCAmount));  \r\n    }\r\n\r\n    function getARCvalueperUSDC(uint256 value) public view returns(uint256)\r\n    {\r\n        return (ARCpricePerUSDC.mul(value)).div(1e18);\r\n    }\r\n\r\n\r\n\r\n\r\n       function BuyARCWithBUSD(uint256 _BUSDAmount,bytes32[] calldata proof) external  \r\n    {\r\n         require(ARC_Sold.add(getARCvalueperBUSD(_BUSDAmount))\u003c=maxTokeninPresale,\"Hardcap Reached!\");\r\n        if(WL_Acces==true){\r\n        require(isValid(proof, keccak256(abi.encodePacked(msg.sender))), \"Not a part of Allowlist\");\r\n        require(presaleStatus == false, \"Presale : Presale is started\");  \r\n        }\r\n        else{\r\n        require(presaleStatus == true, \"Presale : Presale is finished\"); \r\n        }\r\n        require(_BUSDAmount \u003e 0, \"Presale : Unsuitable Amount\");\r\n        require(BUSD.balanceOf(msg.sender)\u003e_BUSDAmount,\"not enough USDC in your wallet\");\r\n        BUSD.transferFrom(msg.sender, address(this), _BUSDAmount); \r\n        ARC_Sold =ARC_Sold.add(getARCvalueperBUSD(_BUSDAmount));   \r\n    }\r\n\r\n    function getARCvalueperBUSD(uint256 value) public view returns(uint256)\r\n    {\r\n        return (ARCpricePerBUSD.mul(value)).div(1e18);\r\n    }\r\n\r\n\r\n\r\n    \r\n    function setRewardARCPriceperUSDC(uint256 _count) external onlyOwner {\r\n        ARCpricePerUSDC = _count;\r\n    }\r\n\r\n    function setRewardARCPriceperBUSD(uint256 _count) external onlyOwner {\r\n        ARCpricePerBUSD = _count;\r\n    }\r\n\r\n    function changeUSDC(IBEP20 _USDC,IBEP20 _BUSD) external onlyOwner{\r\n        USDC=_USDC;\r\n        BUSD=_BUSD;\r\n    }\r\n\r\n    function stopPresale() external onlyOwner {\r\n        presaleStatus = false;\r\n    }\r\n\r\n    function resumePresale() external onlyOwner {\r\n        presaleStatus = true;\r\n    }\r\n\r\n      function setmaxTokeninPresale(uint256 _value) external onlyOwner{\r\n        maxTokeninPresale=_value;\r\n    }\r\n\r\n    function modify_WL_Acces(bool _state) external onlyOwner{\r\n        WL_Acces=_state;\r\n    }\r\n\r\n    function contractbalance() public view returns(uint256)\r\n    {\r\n      return address(this).balance;\r\n    }\r\n\r\n    function recoverBEP20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\r\n        IBEP20(tokenAddress).transfer(this.owner(), tokenAmount);\r\n        emit Recovered(tokenAddress, tokenAmount);\r\n    }\r\n       function releaseFunds() external onlyOwner \r\n    {\r\n        payable(msg.sender).transfer(address(this).balance);\r\n    }\r\n\r\n\r\n       ///////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n         function isValid(bytes32[] memory proof, bytes32 leaf) public view returns (bool) {\r\n        return MerkleProof.verify(proof, root, leaf);\r\n    }\r\n\r\n\r\n      // owner can update the merkle root at any time\r\n\r\n                function updateMerkleroot(bytes32 _root) external onlyOwner{\r\n                    root=_root;\r\n                }\r\n\r\n\r\n    // USDC 0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d\r\n    // BUSD 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56\r\n    // merkle root 0x562067e9d3944fd681eb0134523702526f518bd88d60371d7f43cb9ba8bdc9d8\r\n\r\n    \r\n  \r\n}"}}