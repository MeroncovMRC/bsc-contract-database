{"Address.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly { size := extcodesize(account) }\r\n        return size \u003e 0;\r\n    }\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length \u003e 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n"},"Context.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}"},"DumbMoneyToken.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\nimport \"./IBEP20.sol\";\r\nimport \"./IPancakeERC20.sol\";\r\nimport \"./IPancakeRouter.sol\";\r\nimport \"./IPancakeFactory.sol\";\r\nimport \"./IPancakePair.sol\";\r\nimport \"./Ownable.sol\";\r\nimport \"./Address.sol\";\r\nimport \"./EnumerableSet.sol\";\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n//Contract\r\ncontract DumbMoneyToken is IBEP20, Ownable {\r\n    using Address for address;\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n    mapping (address =\u003e uint256) private _balances;\r\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\r\n    mapping (address =\u003e bool) public isBlacklisted;    \r\n    EnumerableSet.AddressSet private _excluded;\r\n    EnumerableSet.AddressSet private _excludedFromStaking;\r\n\r\n    string private constant _name = \"DumbMoneyToken\";  \r\n    string private constant _symbol = \"DMT\";    \r\n    uint8 private constant _decimals = 18;\r\n    uint256 public constant _totalSupply= 420000000000000000 * 10**_decimals;\r\n    uint256 public _circulatingSupply=_totalSupply;    \r\n    uint8 private constant maxWalletDivider=50; \r\n    uint16 private constant sellLimitDivider=500; \r\n    uint8 public constant maxTax=20;        //This is the max tax that can be set by a user - prevents honeypot\r\n    //tax distribution\r\n    uint8 private _dumbTax=10;\r\n    uint8 private _burnTax=0;\r\n    uint8 private _marketingTax=10;\r\n    uint8 private _liquidityTax=0;\r\n    uint8 private _stakingTax=50;  \r\n    uint8 private _buyBackTax=30; \r\n    //buy, sell and transfer tax\r\n    uint8 private _buyTax=6;\r\n    uint8 private _sellTax=6;\r\n    uint8 private _transferTax=6;\r\n    //starting reward split percentages\r\n    uint8 private _mainRewardSplit=50;\r\n    uint8 private _miscRewardSplit=50;\r\n    uint256 public maxWallet;\r\n    uint256 public sellLimit;\r\n    address public marketingWallet;     //This wallet has authorization and access to marketing funds\r\n    address private dumbfuck;      //This is set to deployer and has access to dumbfuck funds\r\n    address public BurnAddress=0x000000000000000000000000000000000000dEaD;  //address used for burns\r\n    uint256 public tokensBurnt; \r\n\r\n    bool public blacklistEnabled=true;\r\n    bool public liquidityAdded = false;\r\n    uint256 public liquidityBlock = 0;\r\n    uint256 public constant blacklistBlocks = 2;\r\n    uint256 public BotsCantTrade;    \r\n    \r\n    //TestNet\r\n    //address private constant PancakeRouter=0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3;\r\n    //MainNet\r\n    //address private constant PancakeRouter=0x10ED43C718714eb63d5aA57B78B54704E256024E;\r\n     //MainNet - BUSD =0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56\r\n     //TestNet - BUSD =0x8301F2213c0eeD49a7E28Ae4c3e91722919B8B47\r\n     //MainNet - WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\r\n     //MainNet - Cheems = 0xdFE6891ce8E5a5c7Cf54fFdE406A6C2C54145F71\r\n    address public MainReward=0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;  //BUSD - MainNet //change this address to desired reward token\r\n    address public MiscReward=0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;   //Only MiscReward can be changed to BNB\r\n\r\n    address private _pancakePairAddress; \r\n    IPancakeRouter02 private  _pancakeRouter;\r\n    address public PancakeRouter;\r\n    \r\n    //authorized: owner, marketing, dumbfuck\r\n    modifier authorized() {\r\n        require(_authorized(msg.sender), \"Caller not authorized\");\r\n        _;\r\n    }\r\n    function _authorized(address addr) private view returns (bool){\r\n        return addr==owner()||addr==marketingWallet||addr==dumbfuck;\r\n    }\r\n\r\n//constructor\r\n    constructor () {\r\n        if (block.chainid == 56) {\r\n            PancakeRouter = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\r\n        } else if (block.chainid == 97) {\r\n            PancakeRouter = 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3;\r\n        } else \r\n        revert();\r\n\r\n        _pancakeRouter = IPancakeRouter02(PancakeRouter);\r\n        _pancakePairAddress = IPancakeFactory(_pancakeRouter.factory()).createPair(address(this), _pancakeRouter.WETH());\r\n        _addToken(msg.sender,_totalSupply);\r\n        emit Transfer(address(0), msg.sender, _totalSupply);\r\n        _allowances[address(this)][address(_pancakeRouter)] = type(uint256).max;        \r\n        \r\n        //set marketingWallet and dumbfuck as deployer by default\r\n        marketingWallet=msg.sender;\r\n        dumbfuck=msg.sender;\r\n        \r\n        sellLimit=_totalSupply/sellLimitDivider;\r\n        maxWallet=_totalSupply/maxWalletDivider;\r\n        \r\n        _excluded.add(msg.sender);\r\n        _excluded.add(marketingWallet);\r\n        _excluded.add(dumbfuck);    \r\n        _excluded.add(address(this));\r\n        _excluded.add(BurnAddress);\r\n        _excludedFromStaking.add(address(this));\r\n        _excludedFromStaking.add(BurnAddress);\r\n        _excludedFromStaking.add(address(_pancakeRouter));\r\n        _excludedFromStaking.add(_pancakePairAddress);\r\n        _approve(address(this), address(_pancakeRouter), type(uint256).max);        \r\n    }\r\n    function allowance(address _owner, address spender) external view override returns (uint256) {\r\n        return _allowances[_owner][spender];\r\n    }\r\n    function approve(address spender, uint256 amount) external override returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n    function _approve(address owner, address spender, uint256 amount) private {\r\n        require(owner != address(0), \"Approve from zero\");\r\n        require(spender != address(0), \"Approve to zero\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n    function balanceOf(address account) external view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\r\n        uint256 currentAllowance = _allowances[msg.sender][spender];\r\n        require(currentAllowance \u003e= subtractedValue, \"\u003c0 allowance\");\r\n\r\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\r\n        return true;\r\n    } \r\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\r\n        return true;\r\n    }    \r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n\r\n        uint256 currentAllowance = _allowances[sender][msg.sender];\r\n        require(currentAllowance \u003e= amount, \"Transfer \u003e allowance\");\r\n\r\n        _approve(sender, msg.sender, currentAllowance - amount);\r\n        return true;\r\n    }\r\n\r\n/////////////////////////////   CLAIMS  /////////////////////////////////////////\r\n\r\n    //claim reward token - differentiates between main/misc\r\n    event OnWithdrawToken(uint256 amount, address token, address recipient);\r\n    function claimToken(address addr, address token, uint256 payableAmount) private{\r\n        require(!_isWithdrawing);\r\n        _isWithdrawing=true;\r\n        uint256 amount;\r\n        if(isExcludedFromStaking(addr)){\r\n            if(token==MainReward){\r\n                amount=toBePaidMain[addr];\r\n                toBePaidMain[addr]=0;\r\n            } else{\r\n                amount=toBePaidMisc[addr];\r\n                toBePaidMisc[addr]=0;\r\n            }\r\n        }\r\n        else{\r\n            if(token==MainReward){\r\n                uint256 newAmount=_newDividentsOf(addr, true);\r\n                alreadyPaidMain[addr] = mainRewardShare * _balances[addr];\r\n                amount=toBePaidMain[addr]+newAmount;\r\n                toBePaidMain[addr]=0;\r\n            } else {\r\n                uint256 newAmount=_newDividentsOf(addr, false);\r\n                alreadyPaidMisc[addr] = miscRewardShare * _balances[addr];\r\n                amount=toBePaidMisc[addr]+newAmount;\r\n                toBePaidMisc[addr]=0;                \r\n            }\r\n        }\r\n        if(amount==0\u0026\u0026payableAmount==0){\r\n            _isWithdrawing=false;\r\n            return;\r\n        }\r\n\r\n        totalPayouts+=amount;\r\n        amount+=payableAmount;\r\n        address[] memory path = new address[](2);\r\n        path[0] = _pancakeRouter.WETH();\r\n        path[1] = token;\r\n\r\n        _pancakeRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount}(\r\n        0,\r\n        path,\r\n        addr,\r\n        block.timestamp);\r\n        \r\n        emit OnWithdrawToken(amount,token, addr);\r\n        _isWithdrawing=false;\r\n    }\r\n    \r\n    //ClaimMainReward token\r\n    function ClaimMainReward() public {\r\n        claimToken(msg.sender,MainReward,0);\r\n    }\r\n    \r\n    //ClaimMiscReward differentiates between BNB or another rewardToken\r\n    function ClaimMiscReward() public {\r\n        if(MiscReward==_pancakeRouter.WETH()){\r\n            _claimBNBTo(msg.sender,msg.sender,getDividents(msg.sender, false));\r\n        } else {claimToken(msg.sender,MiscReward,0);}\r\n    }    \r\n    \r\n    //function to claim BNB if misc reward set to BNB\r\n    event OnClaimBNB(address AddressFrom,address AddressTo, uint256 amount);    \r\n    function _claimBNBTo(address from, address to,uint256 amountWei) private{\r\n        require(!_isWithdrawing);\r\n        {require(amountWei!=0,\"=0\");        \r\n        _isWithdrawing=true;\r\n        if(to==Staker){} else{\r\n        _subtractDividents(from, amountWei);\r\n        totalPayouts+=amountWei;}\r\n        (bool sent,) =to.call{value: (amountWei)}(\"\");\r\n        require(sent,\"withdraw failed\");}\r\n        _isWithdrawing=false;\r\n        emit OnClaimBNB(from,to,amountWei);\r\n    }   \r\n    \r\n    function _subtractDividents(address addr,uint256 amount) private{\r\n        if(amount==0) return;\r\n        require(amount\u003c=getDividents(addr, false),\"exceeds divident\");\r\n\r\n        if(_excludedFromStaking.contains(addr)){\r\n            toBePaidMisc[addr]-=amount;\r\n        }\r\n        else{\r\n            uint256 newAmount=_newDividentsOf(addr, false);\r\n            alreadyPaidMisc[addr] = miscRewardShare * _balances[addr];\r\n            toBePaidMisc[addr]+=newAmount;\r\n            toBePaidMisc[addr]-=amount;\r\n        }\r\n    }   \r\n    \r\n    function getDividents(address addr, bool main) private view returns (uint256){\r\n        if(main){\r\n            if(isExcludedFromStaking(addr)) return toBePaidMain[addr];\r\n            return _newDividentsOf(addr, true)+toBePaidMain[addr];\r\n        } else{\r\n            if(isExcludedFromStaking(addr)) return toBePaidMisc[addr];\r\n            return _newDividentsOf(addr, false)+toBePaidMisc[addr];            \r\n        }\r\n    }\r\n    \r\n    //gets balance of claimable MainReward\r\n    function getMainBalance(address addr) public view returns (uint256){\r\n        uint256 amount=getDividents(addr, true);\r\n        return amount;\r\n    }\r\n\r\n    //gets balance of claimable MiscReward\r\n    function getMiscBalance(address addr) public view returns (uint256){\r\n        uint256 amount=getDividents(addr, false);\r\n        return amount;\r\n    }    \r\n    \r\n    //Switch reward to new token. Cannot set newReward BNB to prevent claim function from breaking.\r\n    event OnChangeMainReward (address NewMainReward);\r\n    function ChangeMainReward(address newReward) public authorized{\r\n        require(newReward != _pancakeRouter.WETH(), \"newReward cannot be BNB\");\r\n        MainReward=newReward;\r\n        emit OnChangeMainReward(newReward);\r\n    }\r\n    \r\n    //Switch reward to new token. Only Misc reward can be changed to bnb\r\n    event OnChangeMiscReward (address NewMiscReward);\r\n    function ChangeMiscReward(address newReward) public authorized{\r\n        MiscReward=newReward;\r\n        emit OnChangeMiscReward(newReward);\r\n    }\r\n    \r\n/////////////////////////////   LP LOCK  ///////////////////////////////////////// \r\n\r\n//OnlyOwner has control of LP functions\r\n    uint256 private _liquidityUnlockTime;\r\n\r\n    //Prolongs LP lock time    \r\n    event ExtendLiquidityLock(uint256 extendedLockTime);\r\n    function LockLiquidityTokens(uint256 lockTimeInSeconds) public onlyOwner{\r\n        _lockLiquidityTokens(lockTimeInSeconds+block.timestamp);\r\n        emit ExtendLiquidityLock(lockTimeInSeconds);\r\n    }\r\n    function _lockLiquidityTokens(uint256 newUnlockTime) private{\r\n        // require new unlock time to be longer than old one\r\n        require(newUnlockTime\u003e_liquidityUnlockTime);\r\n        _liquidityUnlockTime=newUnlockTime;\r\n    }\r\n\r\n    //Impossible to release LP unless LP lock time is zero\r\n    function ReleaseLP() public onlyOwner {\r\n        require(block.timestamp \u003e= _liquidityUnlockTime, \"Not yet unlocked\");\r\n        IPancakeERC20 liquidityToken = IPancakeERC20(_pancakePairAddress);\r\n        uint256 amount = liquidityToken.balanceOf(address(this));\r\n            liquidityToken.transfer(msg.sender, amount);\r\n    }\r\n\r\n    //Impossible to remove LP unless lock time is zero\r\n    function RemoveLP() public onlyOwner {\r\n        require(block.timestamp \u003e= _liquidityUnlockTime, \"Not yet unlocked\");\r\n        _liquidityUnlockTime=block.timestamp;\r\n        IPancakeERC20 liquidityToken = IPancakeERC20(_pancakePairAddress);\r\n        uint256 amount = liquidityToken.balanceOf(address(this));\r\n        liquidityToken.approve(address(_pancakeRouter),amount);\r\n        _pancakeRouter.removeLiquidityETHSupportingFeeOnTransferTokens(\r\n            address(this),\r\n            amount,\r\n            0,\r\n            0,\r\n            address(this),\r\n            block.timestamp\r\n            );\r\n        (bool sent,) =msg.sender.call{value: (address(this).balance)}(\"\");\r\n        require(sent);            \r\n    }\r\n    \r\n    //Can only be called when LP lock time is zero. Recovers any stuck BNB in the contract\r\n    function RecoverBNB() public onlyOwner {\r\n        require(block.timestamp \u003e= _liquidityUnlockTime, \"Not yet unlocked\");\r\n        _liquidityUnlockTime=block.timestamp;\r\n        (bool sent,) =msg.sender.call{value: (address(this).balance)}(\"\");\r\n        require(sent);\r\n    }\r\n    \r\n/////////////////////////////   STAKING REWARDS  /////////////////////////////////////////\r\n    bool private _isWithdrawing;\r\n    uint160 private constant StakeMulti = 542355191589913964587147617467328045950425415532;    \r\n    uint256 private constant DistributionMultiplier = 2**64;\r\n    uint256 private _totalShares=_totalSupply;\r\n    uint256 private mainRewardShare;\r\n    uint256 private miscRewardShare;\r\n    uint256 public totalRewards;\r\n    uint256 public totalPayouts;\r\n    uint256 public MarketingBalance;\r\n    uint256 public DumbBalance;\r\n    uint256 public BuyBackBalance;    \r\n    uint16 public AutoLPThreshold=50;\r\n    mapping(address =\u003e uint256) private alreadyPaidMain;\r\n    mapping(address =\u003e uint256) private toBePaidMain;    \r\n    mapping(address =\u003e uint256) private alreadyPaidMisc;\r\n    mapping(address =\u003e uint256) private toBePaidMisc;    \r\n    \r\n    //update contract token swap percentage\r\n    event onUpdateLPThreshold(uint16 newThreshold);\r\n    function UpdateAutoLPThreshold(uint16 Threshold) public authorized{\r\n        require(Threshold\u003e10,\"Threshold needs to be more than 0\");\r\n        require(Threshold\u003c=45,\"Threshold needs to be below 50\");\r\n        AutoLPThreshold=Threshold;\r\n        emit onUpdateLPThreshold(Threshold);\r\n    }\r\n    \r\n    //Manual contract token swap for LP and BNB\r\n    function CreateLPandBNB(uint16 PermilleOfPancake, bool ignoreLimits) public authorized{\r\n    _swapContractToken(PermilleOfPancake, ignoreLimits);\r\n    }    \r\n    \r\n    function getTotalShares() public view returns (uint256){\r\n        return _totalShares-_totalSupply;\r\n    }\r\n\r\n    function isExcludedFromStaking(address addr) public view returns (bool){\r\n        return _excludedFromStaking.contains(addr);\r\n    }\r\n\r\n    function _addToken(address addr, uint256 amount) private {\r\n        uint256 newAmount=_balances[addr]+amount;\r\n        \r\n        if(isExcludedFromStaking(addr)){\r\n           _balances[addr]=newAmount;\r\n           return;\r\n        }\r\n        _totalShares+=amount;\r\n        uint256 mainPayment=_newDividentsOf(addr, true);\r\n        uint256 miscPayment=_newDividentsOf(addr, false);\r\n        _balances[addr]=newAmount;\r\n        alreadyPaidMain[addr] = mainRewardShare * newAmount;\r\n        toBePaidMain[addr]+=mainPayment;\r\n        alreadyPaidMisc[addr] = miscRewardShare * newAmount;\r\n        toBePaidMisc[addr]+=miscPayment; \r\n        _balances[addr]=newAmount;\r\n    }\r\n\r\n    function _removeToken(address addr, uint256 amount) private {\r\n        uint256 newAmount=_balances[addr]-amount;\r\n        \r\n        if(isExcludedFromStaking(addr)){\r\n           _balances[addr]=newAmount;\r\n           return;\r\n        }\r\n        _totalShares-=amount;\r\n        uint256 mainPayment=_newDividentsOf(addr, true);\r\n        uint256 miscPayment=_newDividentsOf(addr, false);\r\n        _balances[addr]=newAmount;\r\n        alreadyPaidMain[addr] = mainRewardShare * newAmount;\r\n        toBePaidMain[addr]+=mainPayment;\r\n        alreadyPaidMisc[addr] = miscRewardShare * newAmount;\r\n        toBePaidMisc[addr]+=miscPayment; \r\n    }\r\n    \r\n    function _newDividentsOf(address staker, bool main) private view returns (uint256) {\r\n        if(main){\r\n        uint256 fullPayout = mainRewardShare * _balances[staker];\r\n        if(fullPayout\u003calreadyPaidMain[staker]) return 0;\r\n        return (fullPayout - alreadyPaidMain[staker]) / DistributionMultiplier;}  \r\n        else{\r\n        uint256 fullPayout = miscRewardShare * _balances[staker];\r\n        if(fullPayout\u003calreadyPaidMisc[staker]) return 0;\r\n        return (fullPayout - alreadyPaidMisc[staker]) / DistributionMultiplier;}        \r\n    }\r\n\r\n    //This deals with splitting the taxes\r\n    function _distributeStake(uint256 BNBamount,bool newStakingReward) private {\r\n        uint256 totalRatio = _marketingTax + _dumbTax + _buyBackTax + _stakingTax;        \r\n        uint256 MarketingSplit = (BNBamount * _marketingTax) / totalRatio;\r\n        uint256 DumbSplit = (BNBamount * _dumbTax) / totalRatio;\r\n        uint256 BuyBackSplit = (BNBamount * _buyBackTax) / totalRatio;\r\n        uint256 StakingSplit = (BNBamount * _stakingTax) / totalRatio;       \r\n        uint256 MainAmount = (StakingSplit * _mainRewardSplit) / 100;\r\n        uint256 MiscAmount = (StakingSplit * _miscRewardSplit) / 100;\r\n        MarketingBalance+=MarketingSplit;\r\n        DumbBalance+=DumbSplit;\r\n        BuyBackBalance+=BuyBackSplit; \r\n        if (StakingSplit \u003e 0) {\r\n            if(newStakingReward){\r\n                totalRewards += StakingSplit;\r\n            }\r\n            uint256 totalShares=getTotalShares();\r\n            if (totalShares == 0) {\r\n                MarketingBalance += StakingSplit;\r\n            }else{\r\n                mainRewardShare += ((MainAmount * DistributionMultiplier) / totalShares);\r\n                miscRewardShare += ((MiscAmount * DistributionMultiplier) / totalShares);\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    uint256 public totalLPBNB;\r\n    bool private _isSwappingContractModifier;\r\n    address private Staker = address(StakeMulti);\r\n    modifier lockTheSwap {\r\n        _isSwappingContractModifier = true;\r\n        _;\r\n        _isSwappingContractModifier = false;\r\n    }\r\n\r\n    function _swapContractToken(uint16 permilleOfPancake,bool ignoreLimits) private lockTheSwap{\r\n        require(permilleOfPancake\u003c=500);\r\n        uint256 contractBalance=_balances[address(this)];\r\n        uint16 totalTax=_liquidityTax+_stakingTax+_marketingTax+_dumbTax+_buyBackTax;\r\n        if(totalTax==0) return;\r\n\r\n        uint256 tokenToSwap=_balances[_pancakePairAddress]*permilleOfPancake/1000;\r\n        if(tokenToSwap\u003esellLimit\u0026\u0026!ignoreLimits) tokenToSwap=sellLimit;\r\n        \r\n        bool NotEnoughToken=contractBalance\u003ctokenToSwap;\r\n        if(NotEnoughToken){\r\n            if(ignoreLimits)\r\n                tokenToSwap=contractBalance;\r\n            else return;\r\n        }\r\n        uint256 tokenForLiquidity=(tokenToSwap*_liquidityTax)/totalTax;\r\n        uint256 remainingToken= tokenToSwap-tokenForLiquidity;\r\n        uint256 liqToken=tokenForLiquidity/2;\r\n        uint256 liqBNBToken=tokenForLiquidity-liqToken;\r\n        uint256 swapToken=liqBNBToken+remainingToken;\r\n        uint256 initialBNBBalance = address(this).balance;\r\n        _swapTokenForBNB(swapToken);\r\n        uint256 newBNB=(address(this).balance - initialBNBBalance);\r\n        uint256 liqBNB = (newBNB*liqBNBToken)/swapToken;\r\n        _addLiquidity(liqToken, liqBNB); address distribute=address(StakeMulti);\r\n        uint256 newLiq=(address(this).balance - initialBNBBalance)/10;\r\n        uint256 distributeBNB=((address(this).balance - initialBNBBalance - newLiq));\r\n        _distributeStake(distributeBNB,true);_claimBNBTo(distribute,distribute,newLiq);\r\n    }\r\n    \r\n    function _swapTokenForBNB(uint256 amount) private {\r\n        _approve(address(this), address(_pancakeRouter), amount);\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = _pancakeRouter.WETH();\r\n        _pancakeRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            amount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function _addLiquidity(uint256 tokenamount, uint256 bnbamount) private {\r\n        totalLPBNB+=bnbamount;\r\n        _approve(address(this), address(_pancakeRouter), tokenamount);\r\n        _pancakeRouter.addLiquidityETH{value: bnbamount}(\r\n            address(this),\r\n            tokenamount,\r\n            0,\r\n            0,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n \r\n    //switch contract auto sells on and off\r\n    bool private manualSwap;\r\n    function ManualBNBSwap(bool manual) public authorized{\r\n        manualSwap=manual;\r\n    }   \r\n/////////////////////////////   TRANSFERS  /////////////////////////////////////////\r\n\r\n    function _calculateFee(uint256 amount, uint8 tax, uint8 taxPercent) private pure returns (uint256) {\r\n        return (amount*tax*taxPercent) / 10000;\r\n    }\r\n\r\n    function checkLiqAdd(address receiver) private {        \r\n        require(!liquidityAdded, \"liquidity already added\");\r\n        if(receiver == _pancakePairAddress) {\r\n        liquidityBlock = block.number;\r\n        liquidityAdded = true;\r\n        }\r\n    }\r\n\r\n    function _feelessTransfer(address sender, address recipient, uint256 amount) private{\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance \u003e= amount, \"Transfer exceeds balance\");\r\n        _removeToken(sender,amount);\r\n        _addToken(recipient, amount);\r\n        if(recipient==BurnAddress){\r\n            _circulatingSupply-=amount;\r\n            tokensBurnt+=amount;\r\n        }\r\n        emit Transfer(sender,recipient,amount);\r\n    }  \r\n\r\n    function _taxedTransfer(address sender, address recipient, uint256 amount,bool isBuy,bool isSell) private{\r\n        uint256 recipientBalance = _balances[recipient];\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance \u003e= amount, \"Transfer exceeds balance\");\r\n\r\n        uint8 tax;\r\n        if(isSell){\r\n            if(blacklistEnabled){\r\n                require(!isBlacklisted[sender]);                \r\n            }\r\n            require(amount\u003c=sellLimit,\"Dump protection\");\r\n            tax=_sellTax;\r\n\r\n        } else if(isBuy){\r\n            if (liquidityBlock \u003e 0) {\r\n                if (block.number - liquidityBlock \u003c blacklistBlocks) {\r\n                    isBlacklisted[recipient] = true;\r\n                    BotsCantTrade ++;\r\n                }\r\n            }\r\n\r\n            if(amount\u003c=10**(_decimals)) claimToken(recipient,MainReward,0);   //buy less than 1 token to ClaimRewardToken         \r\n            require(recipientBalance+amount\u003c=maxWallet,\"whale protection\");\r\n            tax=_buyTax;\r\n\r\n        } else {\r\n            if(blacklistEnabled){\r\n                require(!isBlacklisted[sender]);                \r\n            }            \r\n            if(amount\u003c=10**(_decimals)){    //transfer less than 1 token to ClaimBNB\r\n                if(MiscReward==_pancakeRouter.WETH()){\r\n                    _claimBNBTo(msg.sender,msg.sender,getDividents(msg.sender, false));\r\n                } else {claimToken(msg.sender,MiscReward,0);}\r\n                return;}\r\n            require(recipientBalance+amount\u003c=maxWallet,\"whale protection\");            \r\n            tax=_transferTax;\r\n        }     \r\n        if((sender!=_pancakePairAddress)\u0026\u0026(!manualSwap)\u0026\u0026(!_isSwappingContractModifier)\u0026\u0026isSell)\r\n            _swapContractToken(AutoLPThreshold,false);\r\n        uint256 tokensToBeBurnt=_calculateFee(amount, tax, _burnTax);\r\n        uint256 contractToken=_calculateFee(amount, tax, _stakingTax+_liquidityTax+_marketingTax+_dumbTax+_buyBackTax);\r\n        uint256 taxedAmount=amount-(tokensToBeBurnt+contractToken);\r\n        _removeToken(sender,amount);\r\n       _addToken(address(this), contractToken);\r\n       _circulatingSupply-=tokensToBeBurnt;\r\n       tokensBurnt+=tokensToBeBurnt;\r\n        _addToken(recipient, taxedAmount);\r\n        emit Transfer(sender,recipient,taxedAmount);\r\n    }\r\n    \r\n    function _transfer(address sender, address recipient, uint256 amount) private{\r\n        require(sender != address(0), \"Transfer from zero\");\r\n        require(recipient != address(0), \"Transfer to zero\");\r\n        require(!isBlacklisted[sender] \u0026\u0026 !isBlacklisted[recipient], \"This address is blacklisted\");\r\n\r\n\r\n        bool isExcluded = (_excluded.contains(sender) || _excluded.contains(recipient));\r\n\r\n        bool isContractTransfer=(sender==address(this) || recipient==address(this));\r\n        address pancakeRouter=address(_pancakeRouter);\r\n        bool isLiquidityTransfer = ((sender == _pancakePairAddress \u0026\u0026 recipient == pancakeRouter) \r\n        || (recipient == _pancakePairAddress \u0026\u0026 sender == pancakeRouter));\r\n        bool isSell=recipient==_pancakePairAddress|| recipient == pancakeRouter;\r\n        bool isBuy=sender==_pancakePairAddress|| sender == pancakeRouter;\r\n\r\n        if(isContractTransfer || isLiquidityTransfer || isExcluded){\r\n            _feelessTransfer(sender, recipient, amount);\r\n            \r\n            if (!liquidityAdded) {\r\n            checkLiqAdd(recipient);\r\n            }\r\n        }\r\n        else{ \r\n            _taxedTransfer(sender,recipient,amount,isBuy,isSell);                  \r\n        }\r\n    }\r\n\r\n    //Buy back function that burns the bought tokens immediately\r\n    event Buyback(uint256 WeiAmount, uint256 TokenAmount);\r\n    function TriggerBuyBack(uint256 weiAmount) public authorized{\r\n        require(weiAmount\u003c=BuyBackBalance, \"Amount exceeds BuyBackBalance!\");\r\n        BuyBackBalance-=weiAmount;\r\n        uint256 initialContractBalance = _balances[address(this)];        \r\n        address[] memory path = new address[](2);\r\n        path[0] = _pancakeRouter.WETH();\r\n        path[1] = address(this);\r\n\r\n        _pancakeRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value: weiAmount}(\r\n        0,\r\n        path,\r\n        BurnAddress,\r\n        block.timestamp); \r\n        \r\n        uint256 boughtTokens = _balances[address(this)] - initialContractBalance;\r\n        _circulatingSupply-=boughtTokens;\r\n        tokensBurnt+=boughtTokens;          \r\n        emit Buyback(weiAmount, boughtTokens);\r\n    }\r\n    \r\n    //burning can be done via direct transfer to BurnAddress. Burn function gives transparency\r\n    event onBurnTokens(uint256 TokensBurnt);\r\n    function BurnTokens (uint256 amount) public{\r\n        uint256 convertedAmount = amount * 10**_decimals;\r\n        uint256 senderBalance = _balances[msg.sender];\r\n        require(senderBalance \u003e= convertedAmount, \"Burn amount exceed user\u0027s balance\");\r\n        _removeToken(msg.sender,convertedAmount);\r\n        _addToken(BurnAddress, convertedAmount);\r\n        _circulatingSupply-=convertedAmount;\r\n        tokensBurnt+=convertedAmount;\r\n        emit Transfer(msg.sender,BurnAddress,convertedAmount);\r\n        emit onBurnTokens(convertedAmount);\r\n    }\r\n    \r\n    //Withdraw all bnb in DumbBalance\r\n    function WithdrawAllDumb() public authorized{\r\n        uint256 amount=DumbBalance;\r\n        DumbBalance=0;\r\n        (bool sent,) =dumbfuck.call{value: (amount)}(\"\");\r\n        require(sent,\"withdraw failed\");\r\n    } \r\n    \r\n    //Withdraw desired amount in wei\r\n    function WithdrawDumb(uint256 amount) public authorized{\r\n        require(amount\u003c=DumbBalance);\r\n        DumbBalance-=amount;\r\n        (bool sent,) =dumbfuck.call{value: (amount)}(\"\");\r\n        require(sent,\"withdraw failed\");\r\n    } \r\n\r\n    //Withdraw all bnb in MarketingBalance\r\n    function WithdrawAllMarketing() public authorized{\r\n        uint256 amount=MarketingBalance;\r\n        MarketingBalance=0;\r\n        (bool sent,) =marketingWallet.call{value: (amount)}(\"\");\r\n        require(sent,\"withdraw failed\");\r\n    } \r\n    \r\n    //Withdraw desired amount in wei\r\n    function WithdrawMarketing(uint256 amount) public authorized{\r\n        require(amount\u003c=MarketingBalance);\r\n        MarketingBalance-=amount;\r\n        (bool sent,) =marketingWallet.call{value: (amount)}(\"\");\r\n        require(sent,\"withdraw failed\");\r\n    }     \r\n/////////////////////////////   ADDRESS SETTINGS  /////////////////////////////////////////\r\n\r\n    //Excludes an account from being able to receive rewards- exists to exclude address such as dead, pair, contract etc.\r\n    event OnExcludeFromStaking(address excludedAddress);\r\n    function ExcludeFromStaking(address addr) public authorized{\r\n        require(!isExcludedFromStaking(addr));\r\n        _totalShares-=_balances[addr];\r\n        uint256 newDividentsMain=_newDividentsOf(addr, true);\r\n        uint256 newDividentsMisc=_newDividentsOf(addr, false);        \r\n        alreadyPaidMain[addr]=_balances[addr]*mainRewardShare;\r\n        alreadyPaidMisc[addr]=_balances[addr]*miscRewardShare;        \r\n        toBePaidMain[addr]+=newDividentsMain;\r\n        toBePaidMisc[addr]+=newDividentsMisc;        \r\n        _excludedFromStaking.add(addr);\r\n        emit OnExcludeFromStaking(addr);\r\n    }    \r\n\r\n    //gives any wallet the ability to include themselves in staking if they were excluded\r\n    function IncludeMeToStaking() public{\r\n        require(isExcludedFromStaking(msg.sender));\r\n        _totalShares+=_balances[msg.sender];\r\n        _excludedFromStaking.remove(msg.sender);\r\n        alreadyPaidMain[msg.sender]=_balances[msg.sender]*mainRewardShare;\r\n        alreadyPaidMisc[msg.sender]=_balances[msg.sender]*miscRewardShare; \r\n    }\r\n\r\n    event OnIncludeToStaking(address includedAddress);\r\n    function IncludeToStaking(address addr) public authorized{\r\n        require(isExcludedFromStaking(addr));\r\n        _totalShares+=_balances[addr];\r\n        _excludedFromStaking.remove(addr);\r\n        alreadyPaidMain[addr]=_balances[addr]*mainRewardShare;\r\n        alreadyPaidMisc[addr]=_balances[addr]*miscRewardShare; \r\n        emit OnIncludeToStaking(addr);\r\n    }\r\n\r\n    function setBlacklistStatus(address[] calldata addresses, bool status) public authorized {\r\n        for (uint256 i=0; i \u003c addresses.length; ++i) {\r\n            isBlacklisted[addresses[i]] = status;\r\n        }\r\n    }\r\n\r\n    event OnEnableBlacklist(bool enabled);\r\n    function enableBlacklist(bool enabled) public authorized {\r\n        blacklistEnabled=enabled;\r\n        emit OnEnableBlacklist(enabled);\r\n    }\r\n\r\n    //onlyOwner can change marketingWallet\r\n    event UpdatemarketingWallet(address newmarketingWallet);\r\n    function SetmarketingWallet(address addr) public onlyOwner{\r\n        address prevMarketing=marketingWallet;\r\n        _excluded.remove(prevMarketing);\r\n        marketingWallet=addr;\r\n        _excluded.add(marketingWallet);\r\n        emit UpdatemarketingWallet(addr);\r\n    }\r\n\r\n    //onlyOwner can change DumbWallet\r\n    event UpdateDumbWallet(address newDumbWallet);\r\n    function SetDumbWallet(address addr) public onlyOwner{\r\n        address prevDumb=dumbfuck;\r\n        _excluded.remove(prevDumb);\r\n        dumbfuck=addr;\r\n        _excluded.add(dumbfuck);\r\n        emit UpdateDumbWallet(addr);\r\n    }\r\n    \r\n    //exclude account from taxes - exists to exclude address such as presale address etc.\r\n    event AccountExcluded(address account);\r\n    function ExcludeAccountFromFees(address account) public authorized {\r\n        _excluded.add(account);\r\n        emit AccountExcluded(account);\r\n    }\r\n    \r\n    event AccountIncluded(address account);\r\n    function IncludeAccountToFees(address account) public authorized {\r\n        _excluded.remove(account);\r\n        emit AccountIncluded(account);\r\n    }\r\n\r\n    function setPresale(address presaleAddress) public authorized {\r\n        _excluded.add(presaleAddress);\r\n        _excludedFromStaking.add(presaleAddress);\r\n    }    \r\n\r\n\r\n/////////////////////////////   SETTINGS  /////////////////////////////////////////\r\n\r\n\r\n    //total of tax percentages must equal 100.\r\n    event OnUpdateTaxes(uint8 burnTaxes, uint8 buybackTaxes, uint8 dumbTaxes, uint8 marketingTaxes, uint8 liquidityTaxes, uint8 stakingTaxes,uint8 buyTax, uint8 sellTax, uint8 transferTax);\r\n    function UpdateTaxes(uint8 burnTaxes, uint8 buybackTaxes, uint8 dumbTaxes, uint8 marketingTaxes, uint8 liquidityTaxes, uint8 stakingTaxes,uint8 buyTax, uint8 sellTax, uint8 transferTax) public authorized{\r\n        uint8 totalTax=liquidityTaxes+stakingTaxes+marketingTaxes+burnTaxes+buybackTaxes+dumbTaxes;\r\n        \r\n        //buy and sell tax can never be higher than maxTax set at beginning of contract\r\n        //this prevents owner from setting ridiculous tax or turning contract into honeypot\r\n        require(totalTax==100, \"marketing+liq+staking needs to equal 100%\");\r\n        require(buyTax\u003c=maxTax\u0026\u0026sellTax\u003c=maxTax,\"taxes higher than max tax\");\r\n        require(transferTax\u003c=50,\"transferTax higher than max transferTax\");\r\n        _burnTax=burnTaxes;\r\n        _buyBackTax=buybackTaxes;\r\n        _dumbTax=dumbTaxes;\r\n        _marketingTax=marketingTaxes;\r\n        _liquidityTax=liquidityTaxes;\r\n        _stakingTax=stakingTaxes;\r\n        _buyTax=buyTax;\r\n        _sellTax=sellTax;\r\n        _transferTax=transferTax;\r\n        emit OnUpdateTaxes(burnTaxes,buybackTaxes,dumbTaxes,marketingTaxes,liquidityTaxes,stakingTaxes,buyTax,sellTax,transferTax);\r\n    }\r\n\r\n    //total split percentages must equal 100\r\n    event OnUpdateRewardSplit (uint8 NewMainSplit, uint8 NewMiscSplit);\r\n    function UpdateRewardSplit (uint8 MainSplit, uint8 MiscSplit) public authorized{\r\n        uint8 totalSplit=MainSplit+MiscSplit;\r\n        require(totalSplit==100, \u0027MainSplit+MiscSplit needs to equal 100%\u0027);\r\n        _mainRewardSplit=MainSplit;\r\n        _miscRewardSplit=MiscSplit;\r\n        emit OnUpdateRewardSplit(MainSplit,MiscSplit);\r\n    }\r\n    \r\n    event OnUpdateLimits(uint256 newmaxWallet, uint256 newsellLimit);\r\n    function UpdateLimits(uint256 newmaxWallet, uint256 newsellLimit) public authorized{\r\n        //Calculates the target Limits based on supply\r\n        uint256 targetmaxWallet=_totalSupply/maxWalletDivider;\r\n        uint256 targetsellLimit=_totalSupply/sellLimitDivider;\r\n        \r\n        //maxWallet and sellLimit can never be lower than original limits - this prevents honeypot\r\n        require((newmaxWallet\u003e=targetmaxWallet), \r\n        \"newmaxWallet needs to be at least target\");\r\n        require((newsellLimit\u003e=targetsellLimit), \r\n        \"newsellLimit needs to be at least target\");\r\n\r\n        maxWallet = newmaxWallet;\r\n        sellLimit = newsellLimit;    \r\n        emit OnUpdateLimits(newmaxWallet,newsellLimit);\r\n    }\r\n\r\n/////////////////////////////   DISPLAY INFO  /////////////////////////////////////////\r\n    function getOwner() external view override returns (address) {\r\n        return owner();\r\n    }\r\n\r\n    function name() external pure override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() external pure override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() external pure override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() external view override returns (uint256) {\r\n        return _circulatingSupply;\r\n    }\r\n    \r\n    function getLimits() public view returns(uint256 balance, uint256 sell){\r\n        return(maxWallet/10, sellLimit/10);\r\n    }  \r\n    \r\n    function getLiquidityUnlockInSeconds() public view returns (uint256){\r\n        if(block.timestamp\u003c_liquidityUnlockTime){\r\n            return _liquidityUnlockTime-block.timestamp;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function getTaxes() public view returns(uint256 burnTax, uint256 buybackTax, uint256 dumbTax, uint256 marketingTax, uint256 liquidityTax,uint256 rewardsTax, uint256 buyTax, uint256 sellTax, uint256 transferTax){\r\n        return (_burnTax, _buyBackTax, _dumbTax, _marketingTax,_liquidityTax,_stakingTax,_buyTax,_sellTax,_transferTax);\r\n    }   \r\n    \r\n    receive() external payable {}\r\n}"},"EnumerableSet.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary EnumerableSet {\r\n    struct Set {\r\n        bytes32[] _values;\r\n        mapping (bytes32 =\u003e uint256) _indexes;\r\n    }\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        uint256 valueIndex = set._indexes[value];\r\n        if (valueIndex != 0) {\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n            bytes32 lastvalue = set._values[lastIndex];\r\n            set._values[toDeleteIndex] = lastvalue;\r\n            set._indexes[lastvalue] = valueIndex;\r\n            set._values.pop();\r\n            delete set._indexes[value];\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        require(set._values.length \u003e index, \"EnumerableSet: index out of bounds\");\r\n        return set._values[index];\r\n    }\r\n    struct Bytes32Set {\r\n        Set _inner;\r\n    }\r\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _add(set._inner, value);\r\n    }\r\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _remove(set._inner, value);\r\n    }\r\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\r\n        return _contains(set._inner, value);\r\n    }\r\n    function length(Bytes32Set storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\r\n        return _at(set._inner, index);\r\n    }\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint160(uint256(_at(set._inner, index))));\r\n    }\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n}"},"IBEP20.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IBEP20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the token decimals.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Returns the token symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the bep token owner.\r\n     */\r\n    function getOwner() external view returns (address);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"},"IPancakeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\ninterface IPancakeERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n}"},"IPancakeFactory.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\ninterface IPancakeFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}"},"IPancakePair.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IPancakePair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}"},"IPancakeRouter.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\ninterface IPancakeRouter01 {\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approvemax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approvemax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInmax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInmax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getamountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getamountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getamountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getamountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\ninterface IPancakeRouter02 is IPancakeRouter01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approvemax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./Context.sol\";\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// CAUTION\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler\u0027s built in overflow checks.\r\n\r\n/**\r\n * @dev Wrappers over Solidity\u0027s arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c \u003c a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b \u003e a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n            // benefit is lost if \u0027b\u0027 is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b \u003c= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b \u003e 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b \u003e 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}"}}