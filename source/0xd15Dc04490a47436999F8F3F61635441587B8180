// SPDX-License-Identifier: MIT

pragma solidity ^0.8.19;

interface IERC20 {
    function decimals() external view returns (uint8);

    function symbol() external view returns (string memory);

    function name() external view returns (string memory);

    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function transfer(address recipient, uint256 amount) external returns (bool);

    function allowance(address owner, address spender) external view returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

abstract contract Ownable {
    address internal _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor () {
        address msgSender = msg.sender;
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(_owner == msg.sender, "!o");
        _;
    }

    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "n0");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

contract Migrate is Ownable {
    address public _cashAddress;
    address private _oldTokenAddress;
    address private _newTokenAddress;
    uint256 private _totalToken;
    bool private _start = true;

    function migrate(uint256 amount) external {
        require(_start, "!start");
        address account = msg.sender;
        require(tx.origin == account, "origin");
        _takeToken(_oldTokenAddress, account, _cashAddress, amount);
        _giveToken(_newTokenAddress, account, amount);
        _totalToken += amount;
    }

    function _giveToken(address tokenAddress, address account, uint256 tokenNum) private {
        if (tokenNum > 0) {
            IERC20 token = IERC20(tokenAddress);
            token.transfer(account, tokenNum);
        }
    }

    function _takeToken(address tokenAddress, address account, address receiver, uint256 tokenNum) private {
        IERC20 token = IERC20(tokenAddress);
        require(token.balanceOf(account) >= tokenNum, "balance not enough");
        token.transferFrom(account, receiver, tokenNum);
    }

    function baseInfo() external view returns (
        address oldTokenAddress, uint256 oldTokenDecimals, string memory oldTokenSymbol,
        address newTokenAddress, uint256 newTokenDecimals, string memory newTokenSymbol,
        uint256 totalToken, bool start
    ){
        oldTokenAddress = _oldTokenAddress;
        oldTokenDecimals = IERC20(oldTokenAddress).decimals();
        oldTokenSymbol = IERC20(oldTokenAddress).symbol();
        newTokenAddress = _newTokenAddress;
        newTokenDecimals = IERC20(newTokenAddress).decimals();
        newTokenSymbol = IERC20(newTokenAddress).symbol();
        totalToken = _totalToken;
        start = _start;
    }

    function getUserInfo(address account) external view returns (
        uint256 oldTokenBalance, uint256 oldTokenAllowance
    ){
        oldTokenBalance = IERC20(_oldTokenAddress).balanceOf(account);
        oldTokenAllowance = IERC20(_oldTokenAddress).allowance(account, address(this));
    }

    receive() external payable {}

    function setOldTokenAddress(address adr) external onlyOwner {
        _oldTokenAddress = adr;
    }

    function setNewTokenAddress(address adr) external onlyOwner {
        _newTokenAddress = adr;
    }

    function setCashAddress(address adr) external onlyOwner {
        _cashAddress = adr;
    }

    function setStart(bool enable) external onlyOwner {
        _start = enable;
    }

    function claimBalance(address to, uint256 amount) external onlyOwner {
        address payable addr = payable(to);
        addr.transfer(amount);
    }

    function claimToken(address erc20Address, address to, uint256 amount) external onlyOwner {
        IERC20 erc20 = IERC20(erc20Address);
        erc20.transfer(to, amount);
    }

    function claimNewToken() external onlyOwner {
        IERC20 erc20 = IERC20(_newTokenAddress);
        erc20.transfer(_cashAddress, erc20.balanceOf(address (this)));
    }

    constructor(){
        _oldTokenAddress = address(0x4ec59bbE3D46473C4fcCecaF7ddBe8d80d1767A8);
        _newTokenAddress = address(0x44ac762dB7E7170A48e895fDC81Bc2e81c188888);
        _cashAddress = address(0x9F81a15C9f36dDb1a0DCFA209ED157808319F8c5);
    }
}