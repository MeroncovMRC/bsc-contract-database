
// File: contracts/Marketing.sol
//SPDX-License-Identifier: MIT
pragma solidity 0.8.11;

interface IERC20 {
    function transfer(address to, uint amount) external;
    function decimals() external view returns(uint);
    function balanceOf(address account) external view returns (uint256);
}

contract Donate {

    uint256 constant public minDonate = 90000000;
    uint256 public totalAllocated = 0;
    address public owner;
    bool public isClaimStarted;

    mapping (address => uint256) public allocations;

    IERC20 token;
    
    // Reentrancy storage
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;
    uint256 private _status;

    modifier nonReentrant() {
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
        _status = _ENTERED;
        _;
        _status = _NOT_ENTERED;
    }

    constructor(address _token) {
        token = IERC20(_token);
        owner = msg.sender;
    }

    function donate() public payable nonReentrant {
        require(msg.value >= minDonate);
        uint256 allocation = msg.value / minDonate;
        allocations[msg.sender] = allocations[msg.sender] + allocation * 10 ** token.decimals();
        totalAllocated += allocation * 10 ** token.decimals();
    }

    function claim() public nonReentrant {
        address sender = msg.sender;
        require(isClaimStarted);
        require(allocations[sender] >= 0);

        uint256 allocation = allocations[sender];
        allocations[sender] = 0;
        token.transfer(sender, allocation);
    }

    function enable() public {
        require(msg.sender == owner);
        isClaimStarted = true;
    }

    function withdrawDonate() public {
        require(msg.sender == owner);
        payable(msg.sender).transfer(address(this).balance); 
    }

    function withdrawERC20() public {
        address sender = msg.sender;
        require(sender == owner);
        token.transfer(sender, token.balanceOf(address(this)));
    }
}

