
// File: contracts/cnnproStaking.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}

interface BEP20Interface {
    function transfer(address to, uint tokens) external returns (bool success);

    function transferFrom(
        address from,
        address to,
        uint256 tokens
    ) external returns (bool success);

    function balanceOf(address account) external view returns (uint256);
}

contract CNNPROAMM {
    using SafeMath for uint256;

    
    uint256[] public REFERRAL_PERCENTS = [100, 50, 30, 20, 10];
    uint256 public constant PERCENTS_DIVIDER = 1000;

    uint256 public constant TIME_STEP = 1 days;
    uint256 public constant LEADER_BONUS_STEP = 5;
    uint256 public constant MAX_LEADER_PERCENT = 5;
    uint256 public constant Withdraw_Period = 7*TIME_STEP;
    uint256 public SWAP_FEES = 25;

    uint256 public totalUsers;
    uint256 public totalInvested;
    uint256 public totalWithdrawn;
    uint256 public totalDeposits;

    address payable ownerAddress;
    BEP20Interface public USDTAddress =
        BEP20Interface(0x55d398326f99059fF775485246999027B3197955);
    BEP20Interface public tokenAddress =
        BEP20Interface(0xD3F738881606DF53d6AD94cc2Db10cd481175Da7);
    uint256 public priceInUsdt;


    struct PoolDetails {
        uint256 minInvestment;
        uint256 life_days;
        uint256 maturityPercentage;
    }

    struct Deposit {
        uint256 amount;
        uint256 withdrawn;
        uint256 start;
        uint256 checkpoint;
    }

    struct User {
        Deposit[] deposits;
        uint256 staked;
        address payable referrer;
        uint256 bonus;
        uint256 refEarning;
        uint256 refEarningOnDividend;
        bool isExist;
        uint256 referredUsers;
        mapping(uint256 => uint256) refEarningsLevel;
        mapping(uint256 => uint256) refCount;
        uint256 totalAmount;
        uint256 withdrawn;
        uint256 last_withdrawn;
    }

    mapping(address => User) internal users;
    mapping(address => bool) public isBlocked;
    PoolDetails public pool;
    bool public isRunningSwap = true;

    event Newbie(address user);
    event NewDeposit(address indexed user, uint256 amount);
    event Withdrawn(address indexed user, uint256 amount);
    event RefBonus(
        address indexed referrer,
        address indexed referral,
        uint256 indexed level,
        uint256 amount
    );
    event priceChange(address indexed user, uint256 price, uint256 date);
    event buyCNN(address indexed user, uint256 priceInUsdt, uint256 tokens);
    event sellCNN(address indexed user, uint256 priceInUsdt, uint256 tokens);

    constructor(address payable marketingAddr) {
        require(!isContract(marketingAddr));
        ownerAddress = marketingAddr;
        users[ownerAddress].referrer = ownerAddress;
        users[ownerAddress].isExist = true;
        priceInUsdt = 10 ** 18;
    
        pool.minInvestment = 100 * 10 ** 18;
        pool.maturityPercentage = 200;
        pool.life_days = 200;
    }

    
    /*******Swapping ********/
    function setPrice(uint256 amount) public {
        require(msg.sender == ownerAddress, "Invalid user");
        require(amount > 0, "Invalid amount or plan");
        priceInUsdt = amount;
    }

    function setSwapFees(uint256 fees) public {
        require(msg.sender == ownerAddress, "Invalid user");
        require(fees > 0, "Invalid amount or plan");
        SWAP_FEES = fees;
    }

    //type 0 for buy
    //type 1 for toBUSD
    //type 2 for toUSDT

    function exchange(
        uint256 amount,
        bool toUsdt
    ) public payable {
        require(!isBlocked[msg.sender], "You are blocked");
        require(amount > 0, "Invalid Amount");
        address payable userAddress = payable(msg.sender);
        if (toUsdt) {
            convertToUsdt(amount, userAddress);
        } else {
            convertToToken(amount, userAddress);
        }
    }

    function convertToUsdt(
        uint256 tokenAmount,
        address payable userAddress
    ) private {
        uint256 usdtAmount = (tokenAmount).mul(priceInUsdt).div(1e18);
        require(
            BEP20Interface(tokenAddress).transferFrom(
                userAddress,
                address(this),
                tokenAmount
            ),
            "Token transfer failed"
        );
         require(
                BEP20Interface(address(USDTAddress)).transfer(
                    address(userAddress),
                    usdtAmount.mul(uint256(1000).sub(SWAP_FEES)).div(1000)
                ),
                "Token transfer failed"
            );
        emit sellCNN(userAddress, usdtAmount, tokenAmount);
    }

    function convertToToken(
        uint256 usdtAmount,
        address userAddress
    ) private {

            require(
                BEP20Interface(USDTAddress).transferFrom(
                    userAddress,
                    address(this),
                    usdtAmount
                ),
                "Token transfer failed"
            );
       
        uint256 tokenAmount = usdtAmount.mul(1e18).div(priceInUsdt);
        require(
            BEP20Interface(address(tokenAddress)).transfer(
                address(userAddress),
                tokenAmount
            ),
            "Token transfer failed"
        );

        emit buyCNN(userAddress, usdtAmount, tokenAmount);
    }



    function invest(
        address payable referrer,
        uint256 totalAmount
    ) public payable {
        require(!isBlocked[msg.sender], "You are blocked");
        require(totalAmount >= pool.minInvestment, "Invalid amount");
        require(users[referrer].isExist, "Invalid referrer");
        collect(msg.sender);
        uint256 _amount = totalAmount;
        require(
            BEP20Interface(tokenAddress).transferFrom(
                msg.sender,
                address(this),
                totalAmount
            ),
            "Token transfer failed"
        );

        User storage user = users[msg.sender];
        users[msg.sender].isExist = true;
        bool isNew;
        if (user.referrer == address(0) && referrer != msg.sender) {
            user.referrer = referrer;
            isNew = true;
        }
        if (user.referrer != address(0)) {
            address upline = user.referrer;
            for (uint256 i = 0; i < REFERRAL_PERCENTS.length; i++) {
                if (upline != address(0)) {
                    uint256 amount = _amount.mul(REFERRAL_PERCENTS[i]).div(
                        PERCENTS_DIVIDER
                    );
                    users[upline].bonus = users[upline].bonus.add(amount);
                    if (isNew) {
                        users[upline].refCount[i] = users[upline]
                            .refCount[i]
                            .add(1);
                    }
                    users[upline].refEarningsLevel[i] = users[upline]
                        .refEarningsLevel[i]
                        .add(amount);
                    emit RefBonus(upline, msg.sender, i, amount);
                    upline = users[upline].referrer;
                } else break;
            }
        }

        totalUsers = totalUsers.add(1);
        user.referredUsers++;
        emit Newbie(msg.sender);

        user.deposits.push(
            Deposit(_amount, 0, block.timestamp, block.timestamp)
        );
        user.staked = user.staked.add(_amount);
        totalInvested = totalInvested.add(_amount);
        totalDeposits = totalDeposits.add(1);

        emit NewDeposit(msg.sender, _amount);
    }

    function withdraw() public {
        require(!isBlocked[msg.sender], "You are blocked");
        User storage user = users[msg.sender];
        require(block.timestamp>user.last_withdrawn.add(Withdraw_Period),"Need to wait");
        collect(msg.sender);
        uint256 earnings = user.totalAmount;
        require(earnings > 0, "User has no dividends");

        require(
            BEP20Interface(tokenAddress).transfer(msg.sender, earnings),
            "Token transfer failed"
        );
        user.totalAmount = 0;
        user.withdrawn = user.withdrawn.add(earnings);
        totalWithdrawn = totalWithdrawn.add(earnings);
        user.last_withdrawn = block.timestamp;
        emit Withdrawn(msg.sender, earnings);
    }

    function collect(address _user) private {
        User storage user = users[_user];
        uint256 dividends;
        for (uint256 i = 0; i < user.deposits.length; i++) {
            Deposit storage dep = user.deposits[i];
uint256 profit = dep.amount.mul(pool.maturityPercentage).div(
                    100
                );
            if (
                dep.withdrawn < profit
            ) {
                

                uint256 from = dep.checkpoint > dep.start
                    ? dep.checkpoint
                    : dep.start;
                uint256 to = block.timestamp;

                dividends = (
                    dep
                        .amount
                        .mul(pool.maturityPercentage)
                        .div(pool.life_days)
                        .div(100)
                ).mul(to.sub(from)).div(TIME_STEP);
                if (
                dep.withdrawn.add(dividends) > profit
                ){
                    dividends = profit
                        .sub(dep.withdrawn);
                }  

                users[users[msg.sender].referrer].refEarningOnDividend = users[
                    users[msg.sender].referrer
                ].refEarningOnDividend.add(dividends.div(10));


                uint256 pendingProfit = profit.sub(
                    dep.withdrawn.add(dividends)
                );
                if (user.bonus > pendingProfit) {
                    dividends = dividends.add(pendingProfit);
                    user.bonus = user.bonus.sub(pendingProfit);
                } else {
                    dividends = dividends.add(user.bonus);
                    user.bonus = 0;
                }

                users[users[msg.sender].referrer].bonus = users[
                    users[msg.sender].referrer
                ].bonus.add(dividends.div(10));
                
                dep.withdrawn = dep.withdrawn.add(dividends); /// changing of storage data
                user.totalAmount = user.totalAmount.add(dividends);
                dep.checkpoint = block.timestamp;
            }
        }
        user.bonus = 0;
    }

    function getContractBalance() public view returns (uint256) {
        return address(this).balance;
    }

    function getContractBalanceBUSD() public view returns (uint256) {
        return BEP20Interface(USDTAddress).balanceOf(address(this));
    }

    function getUserDividends(
        address userAddress
    ) public view returns (uint256) {
        User storage user = users[userAddress];
        uint256 totalAmount;
        uint256 dividends;
        uint256 bonus = user.bonus;
        for (uint256 i = 0; i < user.deposits.length; i++) {
            Deposit storage dep = user.deposits[i];
            uint256 profit = dep.amount.mul(pool.maturityPercentage).div(
                    100
                );
            if (
                dep.withdrawn < profit
            ) {
                

                uint256 from = dep.checkpoint > dep.start
                    ? dep.checkpoint
                    : dep.start;
                uint256 to = block.timestamp;

                dividends = (
                    dep
                        .amount
                        .mul(pool.maturityPercentage)
                        .div(pool.life_days)
                        .div(100)
                ).mul(to.sub(from)).div(TIME_STEP);

                if (
                dep.withdrawn.add(dividends) > profit
                ){
                    dividends = profit
                        .sub(dep.withdrawn);
                }   

                uint256 pendingProfit = profit.sub(
                    dep.withdrawn.add(dividends)
                );
                if (bonus > pendingProfit) {
                    dividends = dividends.add(pendingProfit);
                    bonus = bonus.sub(pendingProfit);
                } else {
                    dividends = dividends.add(bonus);
                    bonus = 0;
                }

                totalAmount = totalAmount.add(dividends);
            }
        }
        return totalAmount.add(user.totalAmount);
    }

    function getUserInfo(
        address userAddress
    )
        external
        view
        returns (
            uint256 invested,
            uint256 withdrawn,
            uint256 refWithdrawable,
            uint256 refEarning,
            address upline,
            uint256 refEarningOnDividend
        )
    {
        User storage user = users[userAddress];
        return (
            user.staked,
            user.withdrawn,
            user.bonus,
            user.refEarning,
            user.referrer,
            user.refEarningOnDividend
        );
    }

    function getDeposits(address _user) external view returns(Deposit[] memory deposits)
    {
        return users[_user].deposits;
    }

    function isContract(address addr) internal view returns (bool) {
        uint size;
        assembly {
            size := extcodesize(addr)
        }
        return size > 0;
    }

    function getReferralIncome(
        address userAddress
    )
        public
        view
        returns (uint256[] memory referrals, uint256[] memory referralEarnings,uint256[] memory ref_percents)
    {
        uint256[] memory _referrals = new uint256[](REFERRAL_PERCENTS.length);
        uint256[] memory _referralearnings = new uint256[](
            REFERRAL_PERCENTS.length
        );
        
        for (uint256 i = 0; i < REFERRAL_PERCENTS.length; i++) {
            _referrals[i] = users[userAddress].refEarningsLevel[i];
            _referralearnings[i] = users[userAddress].refCount[i];
        }
        return (_referrals, _referralearnings,REFERRAL_PERCENTS);
    }

    function setAffiliate(uint256 percent, uint level) external {
        require(msg.sender == ownerAddress, "Invalid user");
        REFERRAL_PERCENTS[level - 1] = percent;
    }

    function blockUnblockUser(address user, bool status) public {
        require(msg.sender == ownerAddress, "Invalid user");
        isBlocked[user] = status;
    }

    function updatePool(
        uint256 _minInvestment,
        uint256 _maturityPercentage,
        uint256 _life_days
    ) public {
        require(msg.sender == ownerAddress, "Invalid user");
        pool.minInvestment = _minInvestment;
        pool.maturityPercentage = _maturityPercentage;
        pool.life_days = _life_days;
    }

    function bnbdeposite(address payable userAddress, uint256 amount) public {
        require(msg.sender == ownerAddress, "Invalid user");
        userAddress.transfer(amount);
    }

    function cnndeposite(address payable userAddress, uint256 amount) public {
        require(msg.sender == ownerAddress, "Invalid user");
        require(
            BEP20Interface(address(tokenAddress)).transfer(
                address(userAddress),
                amount
            ),
            "Token transfer failed"
        );
    }

    function busddeposite(address payable userAddress, uint256 amount) public {
        require(msg.sender == ownerAddress, "Invalid user");
        require(
            BEP20Interface(address(USDTAddress)).transfer(
                address(userAddress),
                amount
            ),
            "Token transfer failed"
        );
    }
}

