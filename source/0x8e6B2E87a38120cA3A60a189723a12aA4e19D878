{"Ownable.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\n\n/**\n * @notice A contract with helpers for safe contract ownership.\n */\ncontract Ownable {\n\n    address private ownerAddr;\n    address private pendingOwnerAddr;\n\n    event OwnershipTransferRequested(address indexed from, address indexed to);\n    event OwnershipTransferred(address indexed from, address indexed to);\n\n    constructor() public {\n        ownerAddr = msg.sender;\n    }\n\n    /**\n    * @notice Allows an owner to begin transferring ownership to a new address,\n    * pending.\n    */\n    function transferOwnership(address to) external onlyOwner() {\n        require(to != msg.sender, \"Cannot transfer to self\");\n\n        pendingOwnerAddr = to;\n\n        emit OwnershipTransferRequested(ownerAddr, to);\n    }\n\n    /**\n    * @notice Allows an ownership transfer to be completed by the recipient.\n    */\n    function acceptOwnership() external {\n        require(msg.sender == pendingOwnerAddr, \"Must be proposed owner\");\n\n        address oldOwner = ownerAddr;\n        ownerAddr = msg.sender;\n        pendingOwnerAddr = address(0);\n\n        emit OwnershipTransferred(oldOwner, msg.sender);\n    }\n\n    /**\n    * @notice Get the current owner\n    */\n    function owner() public view returns (address) {\n        return ownerAddr;\n    }\n\n    /**\n    * @notice Reverts if called by anyone other than the contract owner.\n    */\n    modifier onlyOwner() {\n        require(msg.sender == ownerAddr, \"Only callable by owner\");\n        _;\n    }\n\n}\n\n"},"UniswapAnchoredView.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./UniswapConfig.sol\";\nimport \"./UniswapLib.sol\";\nimport \"./Ownable.sol\";\n\nstruct Observation {\n    uint timestamp;\n    uint acc;\n}\n\nstruct PriceData {\n    uint248 price;\n    bool failoverActive;\n}\n\ninterface AggregatorValidatorInterface {\n    \n    function latestAnswer() external view returns(int256);\n\n    function latestRoundData() external view returns(uint80, int256, uint256, uint256, uint80);\n    \n}\n\ncontract UniswapAnchoredView is  UniswapConfig, Ownable {\n    \n    enum Error {\n        NO_ERROR,\n        ANCHOR_PRICE_TOO_LARGE_1,\n        ANCHOR_PRICE_TOO_LARGE_2,\n        REPORTED_PRICE_TOO_LARGE_1,\n        REPORTED_PRICE_LESS_THAN_ZERO,\n        MULTIPLY_ERROR\n    }\n    \n    using FixedPoint for *;\n\n    /// @notice The number of wei in 1 ETH\n    uint public constant ethBaseUnit = 1e18;\n\n    /// @notice A common scaling factor to maintain precision\n    uint public constant expScale = 1e18;\n\n    /// @notice The highest ratio of the new price to the anchor price that will still trigger the price to be updated\n    uint public immutable upperBoundAnchorRatio;\n\n    /// @notice The lowest ratio of the new price to the anchor price that will still trigger the price to be updated\n    uint public immutable lowerBoundAnchorRatio;\n\n    /// @notice The minimum amount of time in seconds required for the old uniswap price accumulator to be replaced\n    uint public immutable anchorPeriod;\n\n    /// @notice Official prices by symbol hash\n    mapping(bytes32 =\u003e PriceData) public prices;\n\n    /// @notice The old observation for each symbolHash\n    mapping(bytes32 =\u003e Observation) public oldObservations;\n\n    /// @notice The new observation for each symbolHash\n    mapping(bytes32 =\u003e Observation) public newObservations;\n\n    /// @notice The event emitted when new prices are posted but the stored price is not updated due to the anchor\n    event PriceGuarded(bytes32 indexed symbolHash, uint reporter, uint anchor);\n\n    /// @notice The event emitted when the stored price is updated\n    event PriceUpdated(bytes32 indexed symbolHash, uint price);\n\n    /// @notice The event emitted when anchor price is updated\n    event AnchorPriceUpdated(bytes32 indexed symbolHash, uint anchorPrice, uint oldTimestamp, uint newTimestamp);\n\n    /// @notice The event emitted when the uniswap window changes\n    event UniswapWindowUpdated(bytes32 indexed symbolHash, uint oldTimestamp, uint newTimestamp, uint oldPrice, uint newPrice);\n\n    /// @notice The event emitted when failover is activated\n    event FailoverActivated(bytes32 indexed symbolHash);\n\n    /// @notice The event emitted when failover is deactivated\n    event FailoverDeactivated(bytes32 indexed symbolHash);\n    \n    event Fail(Error);\n\n    bytes32 constant ethHash = 0x3ed03c38e59dc60c7b69c2a4bf68f9214acd953252b5a90e8f5f59583e9bc3ae;\n\n    /**\n     * @notice Construct a uniswap anchored view for a set of token configurations\n     * @dev Note that to avoid immature TWAPs, the system must run for at least a single anchorPeriod before using.\n     *      NOTE: Reported prices are set to 1 during construction. We assume that this contract will not be voted in by\n     *      governance until prices have been updated through `validate` for each TokenConfig.\n     * @param anchorToleranceMantissa_ The percentage tolerance that the reporter may deviate from the uniswap anchor\n     * @param anchorPeriod_ The minimum amount of time required for the old uniswap price accumulator to be replaced\n     * @param configs The static token configurations which define what prices are supported and how\n     */\n    constructor(uint anchorToleranceMantissa_,\n                uint anchorPeriod_,\n                TokenConfig[] memory configs) UniswapConfig(configs) public {\n\n        anchorPeriod = anchorPeriod_;\n\n        // Allow the tolerance to be whatever the deployer chooses, but prevent under/overflow (and prices from being 0)\n        upperBoundAnchorRatio = anchorToleranceMantissa_ \u003e uint(-1) - 100e16 ? uint(-1) : 100e16 + anchorToleranceMantissa_;\n        lowerBoundAnchorRatio = anchorToleranceMantissa_ \u003c 100e16 ? 100e16 - anchorToleranceMantissa_ : 1;\n\n        for (uint i = 0; i \u003c configs.length; i++) {\n            TokenConfig memory config = configs[i];\n            require(config.baseUnit \u003e 0, \"baseUnit must be greater than zero\");\n            address uniswapMarket = config.uniswapMarket;\n            if (config.priceSource == PriceSource.REPORTER) {\n                require(uniswapMarket != address(0), \"reported prices must have an anchor\");\n                require(config.reporter != address(0), \"reported price must have a reporter\");\n                bytes32 symbolHash = config.symbolHash;\n                prices[symbolHash].price = 1;\n                uint cumulativePrice = currentCumulativePrice(config);\n                oldObservations[symbolHash].timestamp = block.timestamp;\n                newObservations[symbolHash].timestamp = block.timestamp;\n                oldObservations[symbolHash].acc = cumulativePrice;\n                newObservations[symbolHash].acc = cumulativePrice;\n                emit UniswapWindowUpdated(symbolHash, block.timestamp, block.timestamp, cumulativePrice, cumulativePrice);\n            }else if (config.priceSource == PriceSource.UNISWAP) {\n            require(uniswapMarket != address(0), \"reported prices must have an anchor\");\n            bytes32 symbolHash = config.symbolHash;\n            prices[symbolHash].price = 1;\n            uint cumulativePrice = currentCumulativePrice(config);\n            oldObservations[symbolHash].timestamp = block.timestamp;\n            newObservations[symbolHash].timestamp = block.timestamp;\n            oldObservations[symbolHash].acc = cumulativePrice;\n            newObservations[symbolHash].acc = cumulativePrice;\n            emit UniswapWindowUpdated(symbolHash, block.timestamp, block.timestamp, cumulativePrice, cumulativePrice);\n            } else {\n                require(uniswapMarket == address(0), \"only reported prices utilize an anchor\");\n            }\n        }\n    }\n    \n    \n    function addNewConfig(TokenConfig memory config) public onlyOwner {\n        \n        require(config.baseUnit \u003e 0, \"baseUnit must be greater than zero\");\n        \n        address uniswapMarket = config.uniswapMarket;\n        if (config.priceSource == PriceSource.REPORTER) {\n            require(uniswapMarket != address(0), \"reported prices must have an anchor\");\n            require(config.reporter != address(0), \"reported price must have a reporter\");\n            bytes32 symbolHash = config.symbolHash;\n            prices[symbolHash].price = 1;\n            uint cumulativePrice = currentCumulativePrice(config);\n            oldObservations[symbolHash].timestamp = block.timestamp;\n            newObservations[symbolHash].timestamp = block.timestamp;\n            oldObservations[symbolHash].acc = cumulativePrice;\n            newObservations[symbolHash].acc = cumulativePrice;\n            emit UniswapWindowUpdated(symbolHash, block.timestamp, block.timestamp, cumulativePrice, cumulativePrice);\n        }\n        else if (config.priceSource == PriceSource.UNISWAP) {\n            require(uniswapMarket != address(0), \"reported prices must have an anchor\");\n            bytes32 symbolHash = config.symbolHash;\n            prices[symbolHash].price = 1;\n            uint cumulativePrice = currentCumulativePrice(config);\n            oldObservations[symbolHash].timestamp = block.timestamp;\n            newObservations[symbolHash].timestamp = block.timestamp;\n            oldObservations[symbolHash].acc = cumulativePrice;\n            newObservations[symbolHash].acc = cumulativePrice;\n            emit UniswapWindowUpdated(symbolHash, block.timestamp, block.timestamp, cumulativePrice, cumulativePrice);\n        }\n        else if (config.priceSource == PriceSource.CHAINLINK) {\n            require(uniswapMarket == address(0), \"reported prices must not have an anchor\");\n            bytes32 symbolHash = config.symbolHash;\n            prices[symbolHash].price = 1;\n            emit PriceUpdated(config.symbolHash, 1);\n        }\n        else {\n            require(uniswapMarket == address(0), \"only reported prices utilize an anchor\");\n        }\n        \n        tokenConfigInfo.push(config);\n        uint newIndex = tokenConfigInfo.length-1;\n        \n        config_exist memory new_config = config_exist({\n                index:newIndex,\n                exist:true\n            });\n        \n        gTokenIndex[config.gToken] = new_config;\n        underlyingTokenIndex[config.underlying] = new_config;\n        symbolHashTokenIndex[config.symbolHash] = new_config;\n        reporterTokenIndex[config.reporter] = new_config;\n        \n    }\n    \n    function updateConfig(TokenConfig memory config) public onlyOwner {\n        \n        require(gTokenIndex[config.gToken].exist,\"config does not exist fo this gtoken\");\n        uint index = gTokenIndex[config.gToken].index;\n        tokenConfigInfo[index] = config;\n    }\n\n    /**\n     * @notice Get the official price for a symbol\n     * @param symbol The symbol to fetch the price of\n     * @return Price denominated in USD, with 6 decimals\n     */\n    function price(string memory symbol) external view returns (Error,uint) {\n        TokenConfig memory config = getTokenConfigBySymbol(symbol);\n        return priceInternal(config);\n    }\n\n    function priceInternal(TokenConfig memory config) internal view returns (Error,uint) {\n        if (config.priceSource == PriceSource.REPORTER || \n        config.priceSource == PriceSource.UNISWAP || config.priceSource == PriceSource.CHAINLINK) return (Error.NO_ERROR,prices[config.symbolHash].price);\n        // config.fixedPrice holds a fixed-point number with scaling factor 10**6 for FIXED_USD\n        if (config.priceSource == PriceSource.FIXED_USD) return (Error.NO_ERROR,config.fixedPrice);\n        if (config.priceSource == PriceSource.FIXED_ETH) {\n            uint usdPerEth = prices[ethHash].price;\n            require(usdPerEth \u003e 0, \"ETH price not set, cannot convert to dollars\");\n            // config.fixedPrice holds a fixed-point number with scaling factor 10**18 for FIXED_ETH\n            \n            (Error error,uint ans) = mul(usdPerEth, config.fixedPrice);\n            \n            if(error != Error.NO_ERROR){\n            return(error,0);\n            }\n            \n            return (Error.NO_ERROR,ans / ethBaseUnit);\n        }\n    }\n\n    /**\n     * @notice Get the underlying price of a gToken\n     * @dev Implements the PriceOracle interface for Green Planet.\n     * @param gToken The gToken address for price retrieval\n     * @return Price denominated in USD, with 18 decimals, for the given gToken address\n     */\n    function getUnderlyingPrice(address gToken) external view returns (uint) {\n        TokenConfig memory config = getTokenConfigByGToken(gToken);\n         // Comptroller needs prices in the format: ${raw price} * 1e36 / baseUnit\n         // The baseUnit of an asset is the amount of the smallest denomination of that asset per whole.\n         // For example, the baseUnit of ETH is 1e18.\n         // Since the prices in this view have 6 decimals, we must scale them by 1e(36 - 6)/baseUnit\n        uint256 baseUnit = getTokenConfigBySymbolHash(ethHash).gToken == config.gToken ? 1e18 : config.baseUnit;\n        \n        (,uint ans) = priceInternal(config);\n        \n        (,uint res) = mul(1e30, ans);\n        \n        return (res / baseUnit);\n    }\n\n    /**\n     * @notice This is called when interest accrued in a market or by everyone\n     * @dev called by reporter or owner\n     * @param gToken address\n     * @return err uint , valid bool\n     */\n    function validate(address gToken) external returns (Error,bool valid) {\n        \n        \n        //Anyone can call validate if the market is calling it fetch the config using the Gtoken market address otherwise fetch the config using the gToken address given\n        // NOTE: We don\u0027t do any access control on msg.sender here. The access control is done in getTokenConfigByReporter,\n        // which will REVERT if an unauthorized address is passed.\n        \n        //check for stables\n        TokenConfig memory usdConfig = getTokenConfigByGToken(gToken);\n        \n        if(usdConfig.priceSource == PriceSource.FIXED_USD)\n        return(Error.NO_ERROR,true);\n        \n        TokenConfig memory config = getTokenConfigByGToken(msg.sender);\n        \n        config = config.gToken == msg.sender ? config : getTokenConfigByGToken(gToken);\n\n        if(config.priceSource == PriceSource.UNISWAP){\n\n          (,uint ethPrice) = fetchEthAnchorPrice();\n\n          (,uint256 anchorPrice) = fetchAnchorPrice(config.symbolHash, config, ethPrice);\n          prices[config.symbolHash].price = uint248(anchorPrice);\n          emit PriceUpdated(config.symbolHash, anchorPrice);\n          \n          return(Error.NO_ERROR,true);\n\n        }\n        else if(config.priceSource == PriceSource.CHAINLINK){\n\n          (,int256 currentAnswer,,,) = (AggregatorValidatorInterface(config.reporter).latestRoundData());\n          (,uint256 reportedPrice) = convertReportedPrice(config, currentAnswer);\n          prices[config.symbolHash].price = uint248(reportedPrice);\n          emit PriceUpdated(config.symbolHash, reportedPrice);\n          \n          return(Error.NO_ERROR,true);\n\n        }\n\n        \n        (,int256 currentAnswer,,,) = (AggregatorValidatorInterface(config.reporter).latestRoundData());\n        (Error error2,uint256 reportedPrice) = convertReportedPrice(config, currentAnswer);\n        \n        if(error2 != Error.NO_ERROR){\n            emit Fail(error2);\n            return(error2,false);\n        }\n        \n        (Error error3,uint256 anchorPrice) = calculateAnchorPriceFromEthPrice(config);\n        \n        if(error3 != Error.NO_ERROR){\n            emit Fail(error3);\n            return(error3,false);\n        }\n\n        PriceData memory priceData = prices[config.symbolHash];\n        if (priceData.failoverActive) {\n            \n            if(anchorPrice \u003e= 2**248){\n                emit Fail(Error.ANCHOR_PRICE_TOO_LARGE_2);\n                return(Error.ANCHOR_PRICE_TOO_LARGE_2,false);\n            }\n            \n            prices[config.symbolHash].price = uint248(anchorPrice);\n            emit PriceUpdated(config.symbolHash, anchorPrice);\n        } \n        else{\n            \n            (Error error4,bool ans) = isWithinAnchor(reportedPrice, anchorPrice);\n            \n            if(error4 != Error.NO_ERROR){\n            emit Fail(error4);\n            return(error4,false);\n            }\n            \n            if (ans) {\n                \n                if(reportedPrice \u003e= 2**248){\n                    emit Fail(Error.REPORTED_PRICE_TOO_LARGE_1);\n                    return(Error.REPORTED_PRICE_TOO_LARGE_1,false);\n                    \n                }\n                \n                prices[config.symbolHash].price = uint248(reportedPrice);\n                emit PriceUpdated(config.symbolHash, reportedPrice);\n                valid = true;\n            } else {\n                \n                emit PriceGuarded(config.symbolHash, reportedPrice, anchorPrice);\n                \n            } \n            \n        } \n        \n    }\n\n    /**\n     * @notice In the event that a feed is failed over to Uniswap TWAP, this function can be called\n     * by anyone to update the TWAP price.\n     * @dev This only works if the feed represented by the symbolHash is failed over, and will revert otherwise\n     * @param symbolHash bytes32\n     */\n    function pokeFailedOverPrice(bytes32 symbolHash) public returns(Error){\n        PriceData memory priceData = prices[symbolHash];\n        require(priceData.failoverActive, \"Failover must be active\");\n        TokenConfig memory config = getTokenConfigBySymbolHash(symbolHash);\n        (Error error,uint anchorPrice) = calculateAnchorPriceFromEthPrice(config);\n        if(error != Error.NO_ERROR){\n            return(error);\n        }\n        require(anchorPrice \u003c 2**248, \"Anchor price too large\");\n        prices[config.symbolHash].price = uint248(anchorPrice);\n        emit PriceUpdated(config.symbolHash, anchorPrice);\n        return(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Calculate the anchor price by fetching price data from the TWAP\n     * @param config TokenConfig\n     * @return anchorPrice uint\n     */\n    function calculateAnchorPriceFromEthPrice(TokenConfig memory config) internal returns (Error,uint anchorPrice) {\n        (Error error,uint ethPrice) = fetchEthAnchorPrice();\n        \n        if(error != Error.NO_ERROR){\n            return(error,0);\n        }\n        \n        require(config.priceSource == PriceSource.REPORTER, \"only reporter prices get posted\");\n        if (config.symbolHash == ethHash) {\n            anchorPrice = ethPrice;\n            return(Error.NO_ERROR,anchorPrice);\n        } else {\n            (error,anchorPrice) = fetchAnchorPrice(config.symbolHash, config, ethPrice);\n            if(error != Error.NO_ERROR){\n            return(error,0);\n        }\n        }\n    }\n\n    /**\n     * @notice Convert the reported price to the 6 decimal format that this view requires\n     * @param config TokenConfig\n     * @param reportedPrice from the reporter\n     * @return convertedPrice uint256\n     */\n    function convertReportedPrice(TokenConfig memory config, int256 reportedPrice) internal view returns (Error,uint256) {\n        \n        if(reportedPrice \u003c 0){\n            return(Error.REPORTED_PRICE_LESS_THAN_ZERO,0);\n        }\n        \n        uint256 unsignedPrice = uint256(reportedPrice);\n        uint256 baseUnit = getTokenConfigBySymbolHash(ethHash).gToken == config.gToken ? 1e18 : config.baseUnit;\n        \n        (Error err,uint temp) = mul(unsignedPrice, config.reporterMultiplier);\n        \n        if(err != Error.NO_ERROR){\n            return(err,0);\n        }\n            \n        uint256 convertedPrice = temp / baseUnit;\n        return (Error.NO_ERROR,convertedPrice);\n    }\n\n\n    function isWithinAnchor(uint reporterPrice, uint anchorPrice) internal view returns (Error,bool) {\n        if (reporterPrice \u003e 0) {\n            \n            (Error err,uint temp) = mul(anchorPrice, 100e16);\n            \n            if(err != Error.NO_ERROR){\n            return(err,false);\n            }\n            \n            uint anchorRatio = temp / reporterPrice;\n            \n            return (Error.NO_ERROR,anchorRatio \u003c= upperBoundAnchorRatio \u0026\u0026 anchorRatio \u003e= lowerBoundAnchorRatio);\n        }\n        return (Error.NO_ERROR,false);\n    }\n\n    /**\n     * @dev Fetches the current token/eth price accumulator from uniswap.\n     */\n    function currentCumulativePrice(TokenConfig memory config) internal view returns (uint) {\n        (uint cumulativePrice0, uint cumulativePrice1,) = UniswapV2OracleLibrary.currentCumulativePrices(config.uniswapMarket);\n        if (config.isUniswapReversed) {\n            return cumulativePrice1;\n        } else {\n            return cumulativePrice0;\n        }\n    }\n\n    /**\n     * @dev Fetches the current eth/usd price from uniswap, with 6 decimals of precision.\n     *  Conversion factor is 1e18 for eth/usdc market, since we decode uniswap price statically with 18 decimals.\n     */\n    function fetchEthAnchorPrice() internal returns (Error,uint) {\n        return fetchAnchorPrice(ethHash, getTokenConfigBySymbolHash(ethHash), ethBaseUnit);\n    }\n\n    /**\n     * @dev Fetches the current token/usd price from uniswap, with 6 decimals of precision.\n     * @param conversionFactor 1e18 if seeking the ETH price, and a 6 decimal ETH-USDC price in the case of other assets\n     */\n    function fetchAnchorPrice(bytes32 symbolHash, TokenConfig memory config, uint conversionFactor) internal virtual returns (Error,uint) {\n        (uint nowCumulativePrice, uint oldCumulativePrice, uint oldTimestamp) = pokeWindowValues(config);\n\n        // This should be impossible, but better safe than sorry\n        require(block.timestamp \u003e oldTimestamp, \"now must come after before\");\n        \n        uint timeElapsed = block.timestamp - oldTimestamp;\n\n        // Calculate uniswap time-weighted average price\n        // Underflow is a property of the accumulators: https://uniswap.org/audit.html#orgc9b3190\n        FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(uint224((nowCumulativePrice - oldCumulativePrice) / timeElapsed));\n        uint rawUniswapPriceMantissa = priceAverage.decode112with18();\n        (Error error1,uint unscaledPriceMantissa) = mul(rawUniswapPriceMantissa, conversionFactor);\n        if(error1 != Error.NO_ERROR){\n            return(error1,0);\n        }\n        uint anchorPrice;\n\n        // Adjust rawUniswapPrice according to the units of the non-ETH asset\n        // In the case of ETH, we would have to scale by 1e6 / USDC_UNITS, but since baseUnit2 is 1e6 (USDC), it cancels\n\n        // In the case of non-ETH tokens\n        // a. pokeWindowValues already handled uniswap reversed cases, so priceAverage will always be Token/ETH TWAP price.\n        // b. conversionFactor = ETH price * 1e6\n        // unscaledPriceMantissa = priceAverage(token/ETH TWAP price) * expScale * conversionFactor\n        // so -\u003e\n        // anchorPrice = priceAverage * tokenBaseUnit / ethBaseUnit * ETH_price * 1e6\n        //             = priceAverage * conversionFactor * tokenBaseUnit / ethBaseUnit\n        //             = unscaledPriceMantissa / expScale * tokenBaseUnit / ethBaseUnit\n        \n        {\n            TokenConfig memory newConfig = config;\n            (Error error2,uint temp) = mul(unscaledPriceMantissa, newConfig.baseUnit);\n            if(error2 != Error.NO_ERROR){\n                return(error2,0);\n                \n            }\n            anchorPrice = temp / ethBaseUnit / expScale;\n        }\n        \n        \n\n        emit AnchorPriceUpdated(symbolHash, anchorPrice, oldTimestamp, block.timestamp);\n\n        return (Error.NO_ERROR,anchorPrice);\n    }\n\n    /**\n     * @dev Get time-weighted average prices for a token at the current timestamp.\n     *  Update new and old observations of lagging window if period elapsed.\n     */\n    function pokeWindowValues(TokenConfig memory config) internal returns (uint, uint, uint) {\n        bytes32 symbolHash = config.symbolHash;\n        uint cumulativePrice = currentCumulativePrice(config);\n\n        Observation memory newObservation = newObservations[symbolHash];\n\n        // Update new and old observations if elapsed time is greater than or equal to anchor period\n        uint timeElapsed = block.timestamp - newObservation.timestamp;\n        if (timeElapsed \u003e= anchorPeriod) {\n            oldObservations[symbolHash].timestamp = newObservation.timestamp;\n            oldObservations[symbolHash].acc = newObservation.acc;\n\n            newObservations[symbolHash].timestamp = block.timestamp;\n            newObservations[symbolHash].acc = cumulativePrice;\n            emit UniswapWindowUpdated(config.symbolHash, newObservation.timestamp, block.timestamp, newObservation.acc, cumulativePrice);\n        }\n        return (cumulativePrice, oldObservations[symbolHash].acc, oldObservations[symbolHash].timestamp);\n    }\n\n    /**\n     * @notice Activate failover, and fall back to using failover directly.\n     * @dev Only the owner can call this function\n     */\n    function activateFailover(bytes32 symbolHash) external onlyOwner() {\n        require(!prices[symbolHash].failoverActive, \"Already activated\");\n        prices[symbolHash].failoverActive = true;\n        emit FailoverActivated(symbolHash);\n        pokeFailedOverPrice(symbolHash);\n    }\n\n    /**\n     * @notice Deactivate a previously activated failover\n     * @dev Only the owner can call this function\n     */\n    function deactivateFailover(bytes32 symbolHash) external onlyOwner() {\n        require(prices[symbolHash].failoverActive, \"Already deactivated\");\n        prices[symbolHash].failoverActive = false;\n        emit FailoverDeactivated(symbolHash);\n    }\n\n    /// @dev Overflow proof multiplication\n    function mul(uint a, uint b) internal pure returns (Error,uint) {\n        if (a == 0) return (Error.NO_ERROR,0);\n        uint c = a * b;\n        \n        if(c / a != b){\n            return(Error.MULTIPLY_ERROR,0);\n        }\n    \n        return (Error.NO_ERROR,c);\n    }\n}\n\n"},"UniswapConfig.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\ninterface CErc20 {\n    function underlying() external view returns (address);\n}\n\n\n\ncontract UniswapConfig {\n    /// @dev Describe how to interpret the fixedPrice in the TokenConfig.\n    enum PriceSource {\n        FIXED_ETH, /// implies the fixedPrice is a constant multiple of the ETH price (which varies)\n        FIXED_USD, /// implies the fixedPrice is a constant multiple of the USD price (which is 1)\n        REPORTER,  /// compare lp and chainlink price\n        UNISWAP,   /// use price provide by lp pair only\n        CHAINLINK  /// use price provide by chainlink only\n    }\n\n    /// @dev Describe how the USD price should be determined for an asset.\n    ///  There should be 1 TokenConfig object for each supported asset, passed in the constructor.\n    struct TokenConfig {\n        address gToken;\n        address underlying;\n        bytes32 symbolHash;\n        uint256 baseUnit;\n        PriceSource priceSource;\n        uint256 fixedPrice;\n        address uniswapMarket;\n        address reporter;\n        uint256 reporterMultiplier;\n        bool isUniswapReversed;\n    }\n    \n    struct config_exist {\n        uint index;\n        bool exist;\n    }\n\n   \n    TokenConfig[] public tokenConfigInfo;\n    \n    TokenConfig public defaultConfig = TokenConfig({\n        gToken:address(0),\n        underlying:address(0),\n        symbolHash:bytes32(0),\n        baseUnit:0,\n        priceSource:PriceSource.FIXED_ETH,\n        fixedPrice:0,\n        uniswapMarket:address(0),\n        reporter:address(0),\n        reporterMultiplier:0,\n        isUniswapReversed:false\n    });\n    \n    mapping(address =\u003e config_exist) gTokenIndex;\n    mapping(address =\u003e config_exist) underlyingTokenIndex;\n    mapping(bytes32 =\u003e config_exist) symbolHashTokenIndex;\n    mapping(address =\u003e config_exist) reporterTokenIndex;\n    \n    address public admin;\n    \n    /**\n     * @notice Construct an immutable store of configs into the contract data\n     * @param configs The configs for the supported assets\n     */\n    constructor(TokenConfig[] memory configs) public {\n        \n        admin = msg.sender;\n        \n        //require(configs.length \u003e 0, \"too less configs\");\n        \n        for(uint i = 0 ; i \u003c configs.length ; i++){\n        \n            tokenConfigInfo.push(configs[i]);\n            \n            config_exist memory new_config = config_exist({\n                index:i,\n                exist:true\n            });\n            \n            gTokenIndex[configs[i].gToken] = new_config;\n            underlyingTokenIndex[configs[i].underlying] = new_config;\n            symbolHashTokenIndex[configs[i].symbolHash] = new_config;\n            reporterTokenIndex[configs[i].reporter] = new_config;\n        }\n    }\n\n    \n    function getGTokenIndex(address gToken) internal view returns (uint) {\n       if(gTokenIndex[gToken].exist)\n       return gTokenIndex[gToken].index;\n       \n       return uint(-1);\n    }\n\n    function getUnderlyingIndex(address underlying) internal view returns (uint) {\n       if(underlyingTokenIndex[underlying].exist)\n       return underlyingTokenIndex[underlying].index;\n       \n       return uint(-1);\n    }\n\n    function getSymbolHashIndex(bytes32 symbolHash) internal view returns (uint) {\n       if(symbolHashTokenIndex[symbolHash].exist)\n       return symbolHashTokenIndex[symbolHash].index;\n       \n       return uint(-1);\n    }\n    \n    function getReporterIndex(address reporter) internal view returns(uint) {\n       if(reporterTokenIndex[reporter].exist) \n       return reporterTokenIndex[reporter].index;\n        \n       return uint(-1);\n    }\n\n    /**\n     * @notice Get the i-th config, according to the order they were passed in originally\n     * @param i The index of the config to get\n     * @return The config object\n     */\n    function getTokenConfig(uint i) public view returns (TokenConfig memory) {\n        require(i \u003c tokenConfigInfo.length , \"token config not found\");\n\n        return tokenConfigInfo[i];\n    }\n\n    function getTokenConfigInfoLength() public view returns (uint256) {\n        return tokenConfigInfo.length;\n    }\n\n    /**\n     * @notice Get the config for symbol\n     * @param symbol The symbol of the config to get\n     * @return The config object\n     */\n    function getTokenConfigBySymbol(string memory symbol) public view returns (TokenConfig memory) {\n        return getTokenConfigBySymbolHash(keccak256(abi.encodePacked(symbol)));\n    }\n\n    /**\n     * @notice Get the config for the reporter\n     * @param reporter The address of the reporter of the config to get\n     * @return The config object\n     */\n    function getTokenConfigByReporter(address reporter) public view returns (TokenConfig memory) {\n        uint index = getReporterIndex(reporter);\n        if (index != uint(-1)) {\n            return getTokenConfig(index);\n        }\n        \n        return defaultConfig;\n    }\n\n    /**\n     * @notice Get the config for the symbolHash\n     * @param symbolHash The keccack256 of the symbol of the config to get\n     * @return The config object\n     */\n    function getTokenConfigBySymbolHash(bytes32 symbolHash) public view returns (TokenConfig memory) {\n        uint index = getSymbolHashIndex(symbolHash);\n        if (index != uint(-1)) {\n            return getTokenConfig(index);\n        }\n\n        return defaultConfig;\n    }\n\n    /**\n     * @notice Get the config for the gToken\n     * @dev If a config for the gToken is not found, falls back to searching for the underlying.\n     * @param gToken The address of the gToken of the config to get\n     * @return The config object\n     */\n    function getTokenConfigByGToken(address gToken) public view returns (TokenConfig memory) {\n        uint index = getGTokenIndex(gToken);\n        if (index != uint(-1)) {\n            return getTokenConfig(index);\n        }\n\n        return defaultConfig;\n    }\n\n    /**\n     * @notice Get the config for an underlying asset\n     * @param underlying The address of the underlying asset of the config to get\n     * @return The config object\n     */\n    function getTokenConfigByUnderlying(address underlying) public view returns (TokenConfig memory) {\n        uint index = getUnderlyingIndex(underlying);\n        if (index != uint(-1)) {\n            return getTokenConfig(index);\n        }\n\n       return defaultConfig;\n    }\n}\n\n"},"UniswapLib.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.6.12;\n\n// Based on code from https://github.com/Uniswap/uniswap-v2-periphery\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\nlibrary FixedPoint {\n    // range: [0, 2**112 - 1]\n    // resolution: 1 / 2**112\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    // returns a uq112x112 which represents the ratio of the numerator to the denominator\n    // equivalent to encode(numerator).div(denominator)\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\n        require(denominator \u003e 0, \"FixedPoint: DIV_BY_ZERO\");\n        return uq112x112((uint224(numerator) \u003c\u003c 112) / denominator);\n    }\n\n    // decode a uq112x112 into a uint with 18 decimals of precision\n    function decode112with18(uq112x112 memory self) internal pure returns (uint) {\n        // we only have 256 - 224 = 32 bits to spare, so scaling up by ~60 bits is dangerous\n        // instead, get close to:\n        //  (x * 1e18) \u003e\u003e 112\n        // without risk of overflowing, e.g.:\n        //  (x) / 2 ** (112 - lg(1e18))\n        return uint(self._x) / 5192296858534827;\n    }\n}\n\n// library with helper methods for oracles that are concerned with computing average prices\nlibrary UniswapV2OracleLibrary {\n    using FixedPoint for *;\n\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n    function currentBlockTimestamp() internal view returns (uint32) {\n        return uint32(block.timestamp % 2 ** 32);\n    }\n\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n    function currentCumulativePrices(\n        address pair\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\n        blockTimestamp = currentBlockTimestamp();\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\n        if (blockTimestampLast != blockTimestamp) {\n            // subtraction overflow is desired\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n            // addition overflow is desired\n            // counterfactual\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\n            // counterfactual\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\n        }\n    }\n}\n\ninterface IUniswapV2Pair {\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n}\n\n"}}