// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;



interface IBEP20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 tokens);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    }

contract ThespUp is IBEP20 {
    string public constant name = "ThespUp";
    string public constant symbol = "TspUP";
    uint8 public constant decimals = 18;
    uint256 private _initialSupply = 1000000 * 10**18;

    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;

    address public _marketingWallet = 0x31a2C52Aa2A137f686Afe34046f619f7Eb9eE7Ed;
    uint256 public _taxFee = 8;
    uint256 public _luckyFee = 6;
    uint256 public _marketingFee = 2;
    uint256 public _luckyThreshold = 10;
    address private _taxAddress = 0xB2A6a547dB215D90d9e68330715009004E47Fa4C;

    address[] private _recentBuyers;
    uint256 private _recentBuyerCount = 10;
    mapping(address => bool) private _isDisqualified;

    constructor() {
        _balances[msg.sender] = _initialSupply;
        emit Transfer(address(0), msg.sender, _initialSupply);
    }

    function totalSupply() public view override returns (uint256) {
        return _initialSupply;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _checkDisqualification(msg.sender);
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        _checkDisqualification(sender);
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] - subtractedValue);
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) private {
        require(sender != address(0), "TspUP: transfer from the zero address");
        require
(recipient != address(0), "TspUP: transfer to the zero address");
        require(_balances[sender] >= amount, "TspUP: insufficient balance for transfer");

        uint256 fee = amount * _taxFee / 100;
        uint256 luckyAmount = 0;

        if (_luckyFee > 0 && _luckyThreshold > 0) {
            uint256 randomRoll = _getRandomNumber() % _luckyThreshold;

            if (randomRoll == 0) {
                address luckyAddress = _getRandomLuckyAddress();

            luckyAmount = fee * _luckyFee / 100;              
            _balances[luckyAddress] += luckyAmount;
            emit Transfer(address(this), luckyAddress, luckyAmount);
            }
        }

        uint256 finalAmount = amount - fee - luckyAmount;
        _balances[sender] -= amount;
        _balances[recipient] += finalAmount;

        if (_taxFee > 0) {
    uint256 marketingFee = fee * _marketingFee / _taxFee;
    _balances[_marketingWallet] += marketingFee;
    emit Transfer(sender, _marketingWallet, marketingFee);
}


        emit Transfer(sender, recipient, finalAmount);
    }

    function _approve(address owner, address spender, uint256 amount) private {
        require(owner != address(0), "ThesUp: approve from the zero address");
        require(spender != address(0), "ThesUp: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _getRandomNumber() private view returns (uint256) {
        uint256 randomNumber = uint256(
            keccak256(abi.encodePacked(block.timestamp, block.number, blockhash(block.number - 1)))
        );
        return randomNumber;
    }

    function _getRandomLuckyAddress() private returns (address) {
        uint256 count = _recentBuyers.length;
        uint256 randomIndex = _getRandomNumber() % count;
        address luckyAddress = _recentBuyers[randomIndex];
        _recentBuyers[randomIndex] = _recentBuyers[count - 1];
        _recentBuyers.pop();
        return luckyAddress;
    }

    function _checkDisqualification(address account) private {
        if (_recentBuyers.length >= _recentBuyerCount) {
            address disqualifiedAddress = _recentBuyers[0];
            if (!_isDisqualified[disqualifiedAddress]) {
                _isDisqualified[disqualifiedAddress] = true;
            }
            _recentBuyers[0] = account;
        } else {
            _recentBuyers.push(account);
        }
    }
}