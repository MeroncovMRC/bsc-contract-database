// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _transferOwnership(_msgSender());
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(
            newOwner != address(0),
            "Ownable: new owner is the zero address"
        );
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Internal function without access restriction.
     */
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(
        address recipient,
        uint256 amount
    ) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(
        address owner,
        address spender
    ) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
}

// OpenZeppelin Contracts v4.4.0 (token/ERC20/extensions/IERC20Metadata.sol)

/**
 * @dev Interface for the optional metadata functions from the ERC20 standard.
 *
 * _Available since v4.1._
 */
interface IERC20Metadata is IERC20 {
    /**
     * @dev Returns the name of the token.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the symbol of the token.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the decimals places of the token.
     */
    function decimals() external view returns (uint8);
}

// OpenZeppelin Contracts v4.4.0 (token/ERC20/ERC20.sol)

/**
 * @dev Implementation of the {IERC20} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 * For a generic mechanism see {ERC20PresetMinterPauser}.
 *
 * TIP: For a detailed writeup see our guide
 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How
 * to implement supply mechanisms].
 *
 * We have followed general OpenZeppelin Contracts guidelines: functions revert
 * instead returning `false` on failure. This behavior is nonetheless
 * conventional and does not conflict with the expectations of ERC20
 * applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn't required by the specification.
 *
 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
 * functions have been added to mitigate the well-known issues around setting
 * allowances. See {IERC20-approve}.
 */
contract ERC20 is Context, IERC20, IERC20Metadata {
    mapping(address => uint256) private _balances;

    mapping(address => mapping(address => uint256)) private _allowances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;

    /**
     * @dev Sets the values for {name} and {symbol}.
     *
     * The default value of {decimals} is 18. To select a different value for
     * {decimals} you should overload it.
     *
     * All two of these values are immutable: they can only be set once during
     * construction.
     */
    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    /**
     * @dev Returns the name of the token.
     */
    function name() public view virtual override returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5.05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei. This is the value {ERC20} uses, unless this function is
     * overridden;
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view virtual override returns (uint8) {
        return 18;
    }

    /**
     * @dev See {IERC20-totalSupply}.
     */
    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(
        address account
    ) public view virtual override returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(
        address recipient,
        uint256 amount
    ) public virtual override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(
        address owner,
        address spender
    ) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(
        address spender,
        uint256 amount
    ) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20}.
     *
     * Requirements:
     *
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for ``sender``'s tokens of at least
     * `amount`.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);

        uint256 currentAllowance = _allowances[sender][_msgSender()];
        require(
            currentAllowance >= amount,
            "ERC20: transfer amount exceeds allowance"
        );
        unchecked {
            _approve(sender, _msgSender(), currentAllowance - amount);
        }

        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(
        address spender,
        uint256 addedValue
    ) public virtual returns (bool) {
        _approve(
            _msgSender(),
            spender,
            _allowances[_msgSender()][spender] + addedValue
        );
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(
        address spender,
        uint256 subtractedValue
    ) public virtual returns (bool) {
        uint256 currentAllowance = _allowances[_msgSender()][spender];
        require(
            currentAllowance >= subtractedValue,
            "ERC20: decreased allowance below zero"
        );
        unchecked {
            _approve(_msgSender(), spender, currentAllowance - subtractedValue);
        }

        return true;
    }

    /**
     * @dev Moves `amount` of tokens from `sender` to `recipient`.
     *
     * This internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(
        address sender,
        address recipient,
        uint256 amount
    ) internal virtual {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _beforeTokenTransfer(sender, recipient, amount);

        uint256 senderBalance = _balances[sender];
        require(
            senderBalance >= amount,
            "ERC20: transfer amount exceeds balance"
        );
        unchecked {
            _balances[sender] = senderBalance - amount;
        }
        _balances[recipient] += amount;

        emit Transfer(sender, recipient, amount);

        _afterTokenTransfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: mint to the zero address");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);

        _afterTokenTransfer(address(0), account, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: burn from the zero address");

        _beforeTokenTransfer(account, address(0), amount);

        uint256 accountBalance = _balances[account];
        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
        unchecked {
            _balances[account] = accountBalance - amount;
        }
        _totalSupply -= amount;

        emit Transfer(account, address(0), amount);

        _afterTokenTransfer(account, address(0), amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
     *
     * This internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(
        address owner,
        address spender,
        uint256 amount
    ) internal virtual {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Hook that is called before any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * will be transferred to `to`.
     * - when `from` is zero, `amount` tokens will be minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {}

    /**
     * @dev Hook that is called after any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * has been transferred to `to`.
     * - when `from` is zero, `amount` tokens have been minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {}
}

interface IWBNB {
    function deposit() external payable;

    function transfer(address to, uint value) external returns (bool);

    function withdraw(uint) external;
}

interface IUniswapV2Pair {
    function balanceOf(address owner) external view returns (uint);

    function transfer(address to, uint value) external returns (bool);

    function token0() external view returns (address);

    function totalSupply() external view returns (uint);

    function getReserves()
        external
        view
        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);

    function mint(address to) external returns (uint liquidity);

    function burn(address to) external returns (uint amount0, uint amount1);

    function swap(
        uint amount0Out,
        uint amount1Out,
        address to,
        bytes calldata data
    ) external;

    function skim(address to) external;

    function sync() external;
}

interface IUniswapV2Factory {
    function createPair(
        address tokenA,
        address tokenB
    ) external returns (address pair);
}

/**
 * @dev a proxy contract because we can not swap directly to v token address
 * just receives swapped tokens and then withdrawn back to the v token address
 * withdrawAll can only be called from the v token conract to retrieve the child's balances if any.
 */
contract ChildProxy {
    address private constant wbnbAddress =
        0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
    address private veeTokenAddress;

    IERC20 private constant _wbnb = IERC20(wbnbAddress);
    IERC20 private _vee;

    constructor(address _veeAddress) {
        veeTokenAddress = _veeAddress;
        _vee = IERC20(_veeAddress);
    }

    function withdrawAll() external {
        require(msg.sender == veeTokenAddress, "unauthorized access");

        uint256 wbnbAmount = _wbnb.balanceOf(address(this));
        if (wbnbAmount > 0) {
            _wbnb.transfer(veeTokenAddress, wbnbAmount);
        } else {
            // unlikely to occur
            uint256 veeAmount = _vee.balanceOf(address(this));
            _vee.transfer(veeTokenAddress, veeAmount);
        }
    }
}

/**
 * @dev Main token contract
 *
 *
 * Overall design relays the economic fundamentals for a token to gain and maintain intrinsic value
 * in a decentralized manner through adoption, by ensuring deeper liquidity & more decentralized token allocation
 * through natural market force and without excessive interference from the contract.
 *
 *
 * Controlled launch mechanism ensures more decantralized token allocation for the very first transactions
 *
 *
 * Token contract has 3 built-in virtual liquidity pools with different liquidity levels
 * which are responsible for determining the token mint amount
 * through an AMM constant product formula same as uniswapV2 formula but without fees
 *
 *
 * Built in routing mechanism that routes the received amount through one of the virtual pools or through
 * pancakeswap liquidity pool
 * this mechanism ensures no more tokens could be minted when the token is over sold or over supplied in the free market
 *
 *
 * an equivalent amount of tokens minted to sender are also minted to the
 * the liquidity pool along with bnb amount received deepening liquidty
 * and minimizing slippage
 *
 *
 * This behaviour ensures adequate liquidity for all minted tokens at any point,
 * since it acts as a backup reserve of value for all tokens minted, this value also appreciates by
 * trading volume from fees colleced by pancakeswapV2 pool.
 *
 *
 * The token contract will often be owning a majority of the value provided as liquidity to the pancakeswapV2 pool,
 * accordingly also expected to often own a major amount of tokens minted, also this amount becomes more relatively
 * significant as more tokens are minted
 *
 *
 * The liquidity pool tokens are simply locked forever within the contract.
 * since the contract is the liquidity deployer, thus the only owner of the liquidity pool tokens
 *
 *
 * Overall contract design along with the built-in router ensures that any trial to trick the contract into minting more tokens
 * than necessary will be at the loss of the attacker
 *
 *
 */
contract V_Token is ERC20, Ownable {
    address public constant wbnbAddress =
        0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
    address public uniswapV2PairAddress;
    bool public isVeeToken0;
    IWBNB public wbnb = IWBNB(wbnbAddress);
    IUniswapV2Pair public uniswapV2Pair;

    mapping(address => bool) public blacklist;
    mapping(address => bool) public launchList; // a mapping of all wallets that participated in the controlled mint

    uint256 public controlledLaunchDeadline;
    uint256 public constant controlledLaunchHardcap =
        21_000_000_000_000_000_000; // 21 BNB
    uint256 public controlledLaunchReceivedBnb = 0;

    uint256 public constant maxTotalSupply =
        100_000_000_000_000_000_000_000_000_000; // 100 Billion
    uint256 public totalMinted = 0; // number of tokens ever minted

    uint256 public virtualK1;
    uint256 public virtualK2;
    uint256 public virtualK3;

    uint256 public bnbVirtualReserves1;
    uint256 public bnbVirtualReserves2;
    uint256 public bnbVirtualReserves3;

    uint256 public tokenVirtualReserves1;
    uint256 public tokenVirtualReserves2;
    uint256 public tokenVirtualReserves3;

    address private childProxyAddress;

    ChildProxy childProxy;

    constructor(
        address _uniswapFactory,
        uint256 initialMintAmount
    ) ERC20("v", "V") {
        controlledLaunchDeadline = block.timestamp + (115000);
        _mint(msg.sender, initialMintAmount);
        totalMinted += initialMintAmount;
        createLiquidityPool(_uniswapFactory);
        initiateVirtualPools();
        createChildProxy();
    }

    function _blacklist(
        address _address,
        bool _isBlacklisting
    ) external onlyOwner {
        blacklist[_address] = _isBlacklisting;
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        require(!blacklist[from] && !blacklist[to], "blacklisted");

        // can only participate once during controlled sale
        // can not send tokens until the controlled launch ends
        if (launchList[to]) {
            require(
                controlledLaunchReceivedBnb >= controlledLaunchHardcap ||
                    block.timestamp > controlledLaunchDeadline,
                "controlled Launch has not ended yet"
            );
        }
    }

    /**
     * @dev receive function that receives BNB and mint tokens accordingly
     */
    receive() external payable {
        require(totalMinted < maxTotalSupply, "max tokens minted"); // if it is > or equal then minting had ended

        uint256 bnbAmountIn = msg.value; // received BNB amount
        require(bnbAmountIn > 0, "amount can not be zero");

        if (
            block.timestamp < controlledLaunchDeadline &&
            controlledLaunchReceivedBnb < controlledLaunchHardcap
        ) {
            require(
                bnbAmountIn <= 70_000_000_000_000_000,
                "max buy at controlled sale is 0.07 BNB"
            );
        }

        wrapBnb(bnbAmountIn);

        uint256 wbnbBalance = IERC20(wbnbAddress).balanceOf(address(this));

        uint256 tokenReserves;
        uint256 wbnbReserves;

        uint256 lpTokensTotalSupply = uniswapV2Pair.totalSupply(); // gas savings

        if (lpTokensTotalSupply == 0) {
            // we just mimic pancakeswap liquidity pool behaviour during controlled launch without providing liquidity directly to the pool
            tokenReserves = balanceOf(address(this));
            wbnbReserves = wbnbBalance;
        } else {
            (uint112 reserves0, uint112 reserves1, ) = uniswapV2Pair
                .getReserves();
            tokenReserves = isVeeToken0 ? reserves0 : reserves1;
            wbnbReserves = isVeeToken0 ? reserves1 : reserves0;
        }

        // route to the best liquidity that offers maximum token for the given BNB amount in
        uint256 liquidityPoolTokenAmountOut = getTokenAmountOutFromliquidityPool(
                bnbAmountIn,
                tokenReserves,
                wbnbReserves
            );
        uint256 virtualPool1TokenAmountOut = getTokenAmountOutFromVirtualPool(
            bnbAmountIn,
            tokenVirtualReserves1,
            bnbVirtualReserves1
        );
        uint256 virtualPool2TokenAmountOut = getTokenAmountOutFromVirtualPool(
            bnbAmountIn,
            tokenVirtualReserves2,
            bnbVirtualReserves2
        );
        uint256 virtualPool3TokenAmountOut = getTokenAmountOutFromVirtualPool(
            bnbAmountIn,
            tokenVirtualReserves3,
            bnbVirtualReserves3
        );

        (uint8 poolId, uint256 tokenAmountOut) = getPoolIdAndTokenAmount(
            liquidityPoolTokenAmountOut,
            virtualPool1TokenAmountOut,
            virtualPool2TokenAmountOut,
            virtualPool3TokenAmountOut
        );

        if (poolId == 0) {
            if (lpTokensTotalSupply == 0) {
                _transfer(address(this), msg.sender, tokenAmountOut); // transfer required tokens from our balance to msg.sender
                recordParticipation(bnbAmountIn); // record controlled mint participant
            } else {
                // swap through pancakeswap
                swapTokensForSender(bnbAmountIn, tokenAmountOut);
            }
        } else {
            // mint tokens through the choosen virtual pool and update virtual reserves, then send half to msg.sender
            mintTokensToParties(poolId, tokenAmountOut);

            updateVirtualReserves(poolId, tokenAmountOut, bnbAmountIn);

            if (
                controlledLaunchReceivedBnb < controlledLaunchHardcap &&
                block.timestamp < controlledLaunchDeadline
            ) {
                recordParticipation(bnbAmountIn);
                return;
            }

            uint256 tokenBalance = balanceOf(address(this));

            if (lpTokensTotalSupply > 0) {
                rebalanceTokensBeforeProvidingLiquidity(
                    wbnbBalance,
                    tokenBalance,
                    tokenReserves,
                    wbnbReserves
                );
            }

            depositLiquidity(
                IERC20(wbnbAddress).balanceOf(address(this)),
                balanceOf(address(this))
            );
        }
    }

    function recordParticipation(uint256 bnbAmountIn) internal {
        launchList[msg.sender] = true; // record participant so that it can buy no more than once during the controlled sale
        controlledLaunchReceivedBnb += bnbAmountIn;
    }

    /**
     * @dev rebalances tokens amounts before providing liquidity
     * in order to obtain max number of liquidity pool tokens possible
     */
    function rebalanceTokensBeforeProvidingLiquidity(
        uint256 bnbAmount,
        uint256 tokenAmount,
        uint256 tokenReserves,
        uint256 wbnbReserves
    ) internal {
        if (totalMinted == maxTotalSupply) {
            bnbAmount = IERC20(wbnbAddress).balanceOf(address(this));
        }

        uint256 _tokenReservesAfter = tokenReserves + tokenAmount;
        uint256 _bnbReservesAfter = wbnbReserves + bnbAmount;

        uint256 bnbSimulatedReserves = (tokenReserves * _bnbReservesAfter) /
            _tokenReservesAfter;
        uint256 tokenSimulatedReserves = (wbnbReserves * _tokenReservesAfter) /
            _bnbReservesAfter;

        if (tokenSimulatedReserves > tokenReserves) {
            uint256 bnbAmountIn = wbnbReserves - bnbSimulatedReserves;
            uint256 tokenAmountOut = getAmountOut(
                bnbAmountIn,
                wbnbReserves,
                tokenReserves
            );

            wbnb.transfer(uniswapV2PairAddress, bnbAmountIn);
            uniswapV2Pair.swap(
                isVeeToken0 ? tokenAmountOut : 0,
                isVeeToken0 ? 0 : tokenAmountOut,
                childProxyAddress,
                ""
            );
        } else if (bnbSimulatedReserves > wbnbReserves) {
            uint256 tokenAmountIn = tokenReserves - tokenSimulatedReserves;
            uint256 bnbAmountOut = getAmountOut(
                tokenAmountIn,
                tokenReserves,
                wbnbReserves
            );

            _transfer(address(this), uniswapV2PairAddress, tokenAmountIn);
            uniswapV2Pair.swap(
                isVeeToken0 ? 0 : bnbAmountOut,
                isVeeToken0 ? bnbAmountOut : 0,
                childProxyAddress,
                ""
            );
        }

        childProxy.withdrawAll();
    }

    function wrapBnb(uint256 bnbAmount) internal {
        wbnb.deposit{value: bnbAmount}(); // wrap BNB
    }

    /**
     * @dev determines which pool the received BNB amount should go through,
     * the pool that gets the sender maximum number of tokens out is choosen
     */
    function getPoolIdAndTokenAmount(
        uint256 liquidityPoolTokenAmountOut,
        uint256 virtualPool1TokenAmountOut,
        uint256 virtualPool2TokenAmountOut,
        uint256 virtualPool3TokenAmountOut
    ) public pure returns (uint8 poolId, uint256 maxTokenAmountOut) {
        maxTokenAmountOut = liquidityPoolTokenAmountOut;
        poolId = 0;
        if (virtualPool1TokenAmountOut > maxTokenAmountOut) {
            maxTokenAmountOut = virtualPool1TokenAmountOut;
            poolId = 1;
        }
        if (virtualPool2TokenAmountOut > maxTokenAmountOut) {
            maxTokenAmountOut = virtualPool2TokenAmountOut;
            poolId = 2;
        }
        if (virtualPool3TokenAmountOut > maxTokenAmountOut) {
            maxTokenAmountOut = virtualPool3TokenAmountOut;
            poolId = 3;
        }
    }

    /**
     * @dev swaps WBNB for tokens on behalf of sender through pancakeswap liquidity pool
     */
    function swapTokensForSender(
        uint256 bnbAmountIn,
        uint256 tokenAmountOut
    ) internal {
        wbnb.transfer(uniswapV2PairAddress, bnbAmountIn);
        uniswapV2Pair.swap(
            isVeeToken0 ? tokenAmountOut : 0,
            isVeeToken0 ? 0 : tokenAmountOut,
            msg.sender,
            ""
        );
    }

    /**
     * @dev only called in the last tmint transaction to refund excess bnb sent.
     * refund in wrapped BNB
     *
     */
    function refundWbnbToSender(uint256 bnbRefundAmount) internal {
        wbnb.transfer(msg.sender, bnbRefundAmount);
    }

    /**
     * @dev mint tokens through the choosen virtual pool and update virtual pool's reserves
     * sends half minted tokens to msg.sender and leave the rest in the contract for providing liquidity
     */
    function mintTokensToParties(
        uint8 poolId,
        uint256 senderTokenAmount
    ) internal {
        uint256 totalMintRemainder = maxTotalSupply - totalMinted;
        uint256 mintAmount = senderTokenAmount * 2;
        if (mintAmount > totalMintRemainder) {
            // this condition will occur once, only for the last mint
            mintAmount = totalMintRemainder;
            senderTokenAmount = mintAmount / 2;
            uint256 bnbAmountNeeded = getBnbAmountIn(poolId, senderTokenAmount);
            uint256 bnbRefundAmount = IERC20(wbnbAddress).balanceOf(
                address(this)
            ) - bnbAmountNeeded;
            refundWbnbToSender(bnbRefundAmount);
        }
        _mint(address(this), mintAmount); // we only mint tokens to the contract then transfer // mint tokens accrued for msg.sender and an equivalent amount to the lqiuidity pool
        totalMinted += mintAmount; // add minted amount to all tokens minted
        _transfer(address(this), msg.sender, senderTokenAmount); // transfer half minted tokens to msg.sender
        require(totalMinted <= maxTotalSupply, "Can not exceed max supply");
    }

    function updateVirtualReserves(
        uint8 poolId,
        uint256 tokenAmountOut,
        uint256 bnbAmountIn
    ) internal {
        if (poolId == 1) {
            tokenVirtualReserves1 -= tokenAmountOut;
            bnbVirtualReserves1 += bnbAmountIn;
            require(
                bnbVirtualReserves1 * tokenVirtualReserves1 >= virtualK1,
                "VIRTUAL AMM ERROR : K1 "
            );
        } else if (poolId == 2) {
            tokenVirtualReserves2 -= tokenAmountOut;
            bnbVirtualReserves2 += bnbAmountIn;
            require(
                bnbVirtualReserves2 * tokenVirtualReserves2 >= virtualK2,
                "VIRTUAL AMM ERROR : K2 "
            );
        } else if (poolId == 3) {
            tokenVirtualReserves3 -= tokenAmountOut;
            bnbVirtualReserves3 += bnbAmountIn;
            require(
                bnbVirtualReserves3 * tokenVirtualReserves3 >= virtualK3,
                "VIRTUAL AMM ERROR : K3 "
            );
        }
    }

    function depositLiquidity(uint256 bnbAmount, uint256 tokenAmount) internal {
        wbnb.transfer(uniswapV2PairAddress, bnbAmount);
        _transfer(address(this), uniswapV2PairAddress, tokenAmount);
        uniswapV2Pair.mint(address(this));
    }

    function burn(uint256 amount) external {
        _burn(msg.sender, amount);
    }

    // creates v2 liquidity pool
    function createLiquidityPool(address factoryAddress) internal {
        uniswapV2PairAddress = IUniswapV2Factory(factoryAddress).createPair(
            address(this),
            wbnbAddress
        );
        uniswapV2Pair = IUniswapV2Pair(uniswapV2PairAddress);
        address token0 = uniswapV2Pair.token0();
        isVeeToken0 = (token0 == address(this)) ? true : false;
    }

    // initiates the contract virtual pools
    function initiateVirtualPools() internal {
        bnbVirtualReserves1 = 1_000_000_000_000_000_000; // 1
        bnbVirtualReserves2 = 10_000_000_000_000_000_000_000; // 10,000
        bnbVirtualReserves3 = 100_000_000_000_000_000_000_000; // 100,000

        tokenVirtualReserves1 = 10_000_000_000_000_000_000_000_000_000; // 10 B
        tokenVirtualReserves2 = 20_000_000_000_000_000_000_000_000_000; // 20 B
        tokenVirtualReserves3 = 30_000_000_000_000_000_000_000_000_000; // 30 B

        virtualK1 = bnbVirtualReserves1 * tokenVirtualReserves1;
        virtualK2 = bnbVirtualReserves2 * tokenVirtualReserves2;
        virtualK3 = bnbVirtualReserves3 * tokenVirtualReserves3;
    }

    /**
     * @dev we create a child proxy contract to be used as an intermediate when swapping tokens
     * through pancakeswap liquidity pool since the token contract can not receive
     * its own tokens directly out from the swap
     */
    function createChildProxy() internal {
        childProxyAddress = address(new ChildProxy(address(this)));
        childProxy = ChildProxy(childProxyAddress);
    }

    function getTokenAmountOutFromVirtualPool(
        uint256 bnbAmountIn,
        uint256 tokenVirtualReserves,
        uint256 bnbVirtualReserves
    ) internal pure returns (uint256 tokensAmountOut) {
        uint256 numerator = bnbAmountIn * tokenVirtualReserves;
        uint256 denominator = bnbVirtualReserves + bnbAmountIn;
        tokensAmountOut = numerator / denominator; // Integer division is safe in Solidity
    }

    function getTokenAmountOutFromliquidityPool(
        uint256 bnbAmountIn,
        uint256 tokenReserves,
        uint256 bnbReserves
    ) internal pure returns (uint256 tokensAmountOut) {
        tokensAmountOut = getAmountOut(bnbAmountIn, bnbReserves, tokenReserves);
    }

    function getAmountOut(
        uint256 amountIn,
        uint256 reserveIn,
        uint256 reserveOut
    ) internal pure returns (uint256 amountOut) {
        uint256 amountInWithFee = amountIn * 9975;
        uint256 numerator = amountInWithFee * reserveOut;
        uint256 denominator = (reserveIn * 10000) + amountInWithFee;
        amountOut = numerator / denominator;
    }

    // only called once during last mint
    function getBnbAmountIn(
        uint8 poolId,
        uint256 tokenAmountOut
    ) internal view returns (uint256 amountIn) {
        uint256 tokenReserves;
        uint256 bnbReserves;
        if (poolId == 1) {
            bnbReserves = bnbVirtualReserves1;
            tokenReserves = tokenVirtualReserves1;
        } else if (poolId == 2) {
            bnbReserves = bnbVirtualReserves2;
            tokenReserves = tokenVirtualReserves2;
        } else if (poolId == 3) {
            bnbReserves = bnbVirtualReserves3;
            tokenReserves = tokenVirtualReserves3;
        }
        uint256 numerator = bnbReserves * tokenAmountOut;
        uint256 denominator = (tokenReserves - tokenAmountOut);
        amountIn = numerator / denominator;

        require(amountIn > 0, "ee");
    }
}