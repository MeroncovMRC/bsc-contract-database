{"EmissionRecipient.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\nimport \"./IERC20.sol\";\n\ninterface IToken {\n    function getOwner() external view returns (address);\n    function burn(uint256 amount) external returns (bool);\n}\n\ncontract EmissionRecipient {\n\n    address public constant accumulator = 0x9cb949e8c256C3EA5395bbe883E6Ee6a20Db6045;\n\n    address public pool = 0xc4e864940C34cDF5086202c34Dff07365f5042Ab;\n\n    uint256 public rate = 700000000000;  // 2% per day\n\n    uint256 public lastReward;\n\n    uint256 public devAmountPerBlock = 138888888900000000; // 0.1388888 * 28,800 blocks per day = 4,000 per day\n\n    address[] public devAddrs;\n    mapping ( address =\u003e bool ) public skipAddr;\n\n    modifier onlyOwner() {\n        require(\n            msg.sender == IToken(accumulator).getOwner(),\n            \u0027Only Owner\u0027\n        );\n        _;\n    }\n\n    constructor() {\n        lastReward = block.number;\n\n        devAddrs = new address[](7);\n        devAddrs[0] = 0x2aB15F8e211eA475bC9275A4C2BFbC9A8130EE89;\n        devAddrs[1] = 0xB695b344dfd4B25782Fc87B09439D98358771891;\n        devAddrs[2] = 0xB1F73ebCC9866708618D74a6314f1c0b80308deE;\n        devAddrs[3] = 0x851e5A29Ffa7651Ca7f94e166D52376f3315a092;\n        devAddrs[4] = 0x88f348b5546FCEf9c44cEEcA6DB33F6136E2B74F;\n        devAddrs[5] = 0xB6B46eD2a978D480dDf9F0700fec1899000554e3;\n        devAddrs[6] = msg.sender;\n    }\n\n    function resetEmissions() external onlyOwner {\n        lastReward = block.number;\n    }\n\n    function setLastRewardStartTime(uint startBlock) external onlyOwner {\n        lastReward = startBlock;\n    }\n\n    function setAddr(uint index, address newAddr) external onlyOwner {\n        if (index \u003e= devAddrs.length) {\n            devAddrs.push(newAddr);\n        } else {\n            devAddrs[index] = newAddr;\n        }\n    }\n\n    function setSkipAddr(address addr, bool skip) external onlyOwner {\n        skipAddr[addr] = skip;\n    }\n\n    function setDevAmountPerBlock(uint newAmountPerBlock) external onlyOwner {\n        devAmountPerBlock = newAmountPerBlock;\n    }\n\n    function setPools(\n        address pool_\n    ) external onlyOwner {\n        pool = pool_;\n    }\n\n    function setRates(\n        uint rate_\n    ) external onlyOwner {\n        rate = rate_;\n    }\n\n    function withdraw(address token) external onlyOwner {\n        IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this)));\n    }\n\n    function withdrawAmount(address token, uint amount) external onlyOwner {\n        IERC20(token).transfer(msg.sender, amount);\n    }\n\n    function trigger() external {\n\n        // amount to reward\n        (\n        uint amount, uint devAmount\n        ) = amountToDistribute();\n        \n        // reset timer\n        lastReward = block.number;\n\n        // send reward to the vault\n        _send(pool, amount);\n        \n        // send reward to devs\n        _handleDevTokens(devAmount);\n    }\n\n    function amountInPool(address pool_) public view returns (uint256) {\n        if (pool_ == address(0)) {\n            return 0;\n        }\n        return IERC20(accumulator).balanceOf(pool_);\n    }\n\n    function timeSince() public view returns (uint256) {\n        return lastReward \u003c block.number ? block.number - lastReward : 0;\n    }\n\n    function qtyPerBlock(address pool_, uint256 dailyReturn) public view returns (uint256) {\n        return ( amountInPool(pool_) * dailyReturn ) / 10**18;\n    }\n\n    function amountToDistribute() public view returns (uint256, uint256) {\n        uint nTime = timeSince();\n        return(\n            qtyPerBlock(pool, rate) * nTime,\n            devAmountPerBlock * nTime\n        );\n    }\n\n    function _send(address to, uint amount) internal {\n        uint bal = IERC20(accumulator).balanceOf(address(this));\n        if (amount \u003e bal) {\n            amount = bal;\n        }\n        if (amount == 0) {\n            return;\n        }\n        IERC20(accumulator).transfer(to, amount); \n    }\n\n    function _handleDevTokens(uint256 amountPer) internal {\n\n        uint len = devAddrs.length;\n        for (uint i = 0; i \u003c len;) {\n            if (!skipAddr[devAddrs[i]]) {\n                _send(devAddrs[i], amountPer);\n            }\n            unchecked { ++i; }\n        }\n\n    }\n}"},"IERC20.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\ninterface IERC20 {\n\n    function totalSupply() external view returns (uint256);\n    \n    function symbol() external view returns(string memory);\n    \n    function name() external view returns(string memory);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n    \n    /**\n     * @dev Returns the number of decimal places\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"}}