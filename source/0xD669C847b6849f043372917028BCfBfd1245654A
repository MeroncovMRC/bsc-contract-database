// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

// CAUTION
// This version of SafeMath should only be used with Solidity 0.8 or later,
// because it relies on the compiler's built in overflow checks.

/**
 * @dev Wrappers over Solidity's arithmetic operations.
 *
 * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler
 * now has built in overflow checking.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function tryAdd(
        uint256 a,
        uint256 b
    ) internal pure returns (bool, uint256) {
        unchecked {
            uint256 c = a + b;
            if (c < a) return (false, 0);
            return (true, c);
        }
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function trySub(
        uint256 a,
        uint256 b
    ) internal pure returns (bool, uint256) {
        unchecked {
            if (b > a) return (false, 0);
            return (true, a - b);
        }
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function tryMul(
        uint256 a,
        uint256 b
    ) internal pure returns (bool, uint256) {
        unchecked {
            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
            // benefit is lost if 'b' is also tested.
            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
            if (a == 0) return (true, 0);
            uint256 c = a * b;
            if (c / a != b) return (false, 0);
            return (true, c);
        }
    }

    /**
     * @dev Returns the division of two unsigned integers, with a division by zero flag.
     *
     * _Available since v3.4._
     */
    function tryDiv(
        uint256 a,
        uint256 b
    ) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a / b);
        }
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.
     *
     * _Available since v3.4._
     */
    function tryMod(
        uint256 a,
        uint256 b
    ) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a % b);
        }
    }

    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return a - b;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        return a * b;
    }

    /**
     * @dev Returns the integer division of two unsigned integers, reverting on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator.
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * reverting when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return a % b;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {trySub}.
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b <= a, errorMessage);
            return a - b;
        }
    }

    /**
     * @dev Returns the integer division of two unsigned integers, reverting with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a / b;
        }
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * reverting with custom message when dividing by zero.
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {tryMod}.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a % b;
        }
    }
}

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function transfer(
        address recipient,
        uint256 amount
    ) external returns (bool);

    function allowance(
        address owner,
        address spender
    ) external view returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
}

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }
}

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _transferOwnership(_msgSender());
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if the sender is not the owner.
     */
    function _checkOwner() internal view virtual {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) external virtual onlyOwner {
        require(
            newOwner != address(0),
            "Ownable: new owner is the zero address"
        );
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Internal function without access restriction.
     */
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

interface IPancakeSwap {
    function getAmountsOut(
        uint256 amountIn,
        address[] memory path
    ) external view returns (uint256[] memory amounts);
}

contract Ample is Ownable {
    using SafeMath for uint256;

    struct User {
        uint256 checkpoint;
        uint256 totalInvested;
        uint256 totalTokenPurchase;
        uint256 totalUsdPurchase;
        address referrer;
        uint256[22] levels;
        uint256[22] totalBusiness;
        uint256 bonus;
        uint256 totalBonus;
        Stake[] stakes;
        Withdraw[] withdraws;
        uint256 leg;
        uint256 deposit_payouts;
    }

    struct Stake {
        uint256 amount;
        uint256 checkpoint;
        uint256 recieved;
    }
    struct Withdraw {
        uint256 amount;
        uint256 checkpoint;
        uint256 recieved;
    }

    mapping(address => User) public users;

    address payable public creatorWallet = payable(0xA0077694315aF2F982995c1217f3047c344Da982);
    uint256 public creatorFee = 100; // 10%
    uint256 public creatorFeeCollected;
    uint256 public constant PERCENTS_DIVIDER = 1000;
    uint256 public constant TIME_STEP = 1440 minutes; // 1 Day
    uint256 public MIN_AMOUNT = 10 ether; // 10 Dollar
    uint256 public totalInvested;
    uint256 public totalUsers;
    uint256 public totalStakeCount;
    uint256 public totalWithdrawCount;
    bool public pancakePrice = false;
    uint256 public staticPrice = 3 ether;

    uint256[] public REFERRAL_PERCENTS = [
        70,
        200,
        100,
        50,
        50,
        50,
        50,
        50,
        50,
        50,
        50,
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        10
    ]; // 100 = 10%, 90 = 9%
    uint256[] public MINIMUM_BUSINESS = [
        10 ether,
        499 ether,
        500 ether,
        2999 ether,
        3000 ether,
        4999 ether,
        5000 ether
    ]; // Dollar Rates
    uint256[] public DAILY_BONUS = [4, 5, 6, 7]; // 0.4 = 4

    event RefBonus(
        address indexed referrer,
        address indexed referral,
        uint256 indexed level,
        uint256 amount
    );
    event Newbie(address user);
    event NewDeposit(address indexed user, uint256 amount);

    // Mainnet - 0x10ED43C718714eb63d5aA57B78B54704E256024E
    // Testnet - 0xD99D1c33F9fC3444f8101754aBC46c52416550D1
    address public pancakeSwapAddress =
        0x10ED43C718714eb63d5aA57B78B54704E256024E; // Address of the PancakeSwap contract
    // Mainnet - 0xA2Df6b077d5036d4526A38Fb791b9aeE62435511
    // Testnet -
    address public ampletoken = 0xA2Df6b077d5036d4526A38Fb791b9aeE62435511;

    function stake(uint256 _amount, address _referrer, uint256 _leg) external {
        // Calculate USD price using PancakeSwap contract interface
        uint256 usdPrice = getTokenToUsd(_amount);

        require(
            usdPrice >= MIN_AMOUNT,
            "Ample Coin: Deposit value is too small"
        );
        require(
            IERC20(ampletoken).transferFrom(msg.sender, address(this), _amount),
            "Token transfer failed"
        );

        User storage user = users[msg.sender];
        if (user.referrer == address(0) && _msgSender() != creatorWallet) {
            if (
                users[_referrer].totalTokenPurchase > 0 &&
                _referrer != msg.sender
            ) {
                user.referrer = _referrer;
            } else if (_referrer == creatorWallet) {
                user.referrer = creatorWallet;
            } else {
                user.referrer = creatorWallet;
            }
            address upline = user.referrer;
            for (uint256 i = 0; i < 22; i++) {
                if (upline != address(0)) {
                    users[upline].levels[i] = users[upline].levels[i].add(1);
                    upline = users[upline].referrer;
                } else break;
            }
        }

        if (user.referrer != address(0)) {
            address upline = user.referrer;
            uint256 totalDirect = users[upline].levels[0];

            for (uint256 i = 0; i < 1; i++) {
                if (upline != address(0)) {
                    users[upline].totalBusiness[i] = users[upline]
                        .totalBusiness[i]
                        .add(_amount);

                    uint256 amount = _amount.mul(REFERRAL_PERCENTS[i]).div(
                        PERCENTS_DIVIDER
                    );
                    users[upline].bonus = users[upline].bonus.add(amount);

                    emit RefBonus(upline, msg.sender, i, amount);

                    upline = users[upline].referrer;
                    totalDirect = users[upline].levels[0];
                }
            }
        }

        if (user.totalInvested == 0) {
            totalUsers = totalUsers.add(1);
            user.checkpoint = block.timestamp;
            emit Newbie(msg.sender);
        }

        user.leg = _leg;
        user.totalInvested = user.totalInvested.add(_amount);
        totalInvested = totalInvested.add(_amount);
        totalStakeCount = totalStakeCount.add(1);

        user.totalTokenPurchase = user.totalTokenPurchase.add(_amount);
        user.totalUsdPurchase = user.totalUsdPurchase.add(usdPrice);
        user.stakes.push(Stake(_amount, block.timestamp, usdPrice));

        emit NewDeposit(msg.sender, _amount);
    }

    function getTokenToUsd(uint256 _tokenAmount) public view returns (uint256) {
        if (pancakePrice) {
            address[] memory path = new address[](2);
            path[0] = address(ampletoken); // Replace with the token address used for deposit
            path[1] = address(0x55d398326f99059fF775485246999027B3197955); // Assuming this is the address of a stablecoin like USDT

            uint256[] memory amounts = IPancakeSwap(pancakeSwapAddress)
                .getAmountsOut(_tokenAmount, path);
            return amounts[1]; // USD price of the token
        } else {
            return ((staticPrice/1e18)*_tokenAmount);
        }
    }

    function getUsdToToken(uint256 _usdAmount) public view returns (uint256) {
        if (pancakePrice) {
            address[] memory path = new address[](2);
            path[0] = address(0x55d398326f99059fF775485246999027B3197955); // Assuming this is the address of a stablecoin like USDT
            path[1] = address(ampletoken); // Replace with the token address used for deposit

            uint256[] memory amounts = IPancakeSwap(pancakeSwapAddress)
                .getAmountsOut(_usdAmount, path);
            return amounts[1]; // Token Output
        } else {
            return (_usdAmount/(staticPrice/1e18));
        }
    }



    function maxPayoutOf(uint256 _amount) external pure returns (uint256) {
        return (_amount * 30) / 10; // 3X ROI
    }

    function maxPayoutOfIncome(
        uint256 _amount
    ) external pure returns (uint256) {
        return (_amount * 20) / 10; // 2X Reward
    }

    function payoutOf(
        address _addr
    ) external view returns (uint256 payout, uint256 max_payout) {
        max_payout = this.maxPayoutOf(users[_addr].totalTokenPurchase);
        uint256 dailyPercent = DAILY_BONUS[0];

        if (
            users[_addr].totalUsdPurchase >= MINIMUM_BUSINESS[0] &&
            users[_addr].totalUsdPurchase <= MINIMUM_BUSINESS[1]
        ) {
            dailyPercent = DAILY_BONUS[0];
        } else if (
            users[_addr].totalUsdPurchase >= MINIMUM_BUSINESS[2] &&
            users[_addr].totalUsdPurchase <= MINIMUM_BUSINESS[3]
        ) {
            dailyPercent = DAILY_BONUS[1];
        } else if (
            users[_addr].totalUsdPurchase >= MINIMUM_BUSINESS[4] &&
            users[_addr].totalUsdPurchase <= MINIMUM_BUSINESS[5]
        ) {
            dailyPercent = DAILY_BONUS[2];
        } else {
            dailyPercent = DAILY_BONUS[3];
        }

        if (users[_addr].deposit_payouts < max_payout) {
            payout =
                ((users[_addr].totalTokenPurchase *
                    dailyPercent *
                    ((block.timestamp - users[_addr].checkpoint) / 1 days)) /
                    PERCENTS_DIVIDER) -
                users[_addr].deposit_payouts;

            if (users[_addr].deposit_payouts + payout > max_payout) {
                payout = max_payout - users[_addr].deposit_payouts;
            }
        }
    }

    function payoutOfIncome(
        address _addr
    ) external view returns (uint256 payout, uint256 max_payout) {
        max_payout = this.maxPayoutOfIncome(users[_addr].totalTokenPurchase);

        if (users[_addr].totalBonus < max_payout) {
            payout = users[_addr].bonus;

            if (users[_addr].totalBonus + payout > max_payout) {
                payout = max_payout - users[_addr].totalBonus;
            }
        }
    }

    function withdrawIncome() external {
        User storage user = users[msg.sender];
        uint256 withdrawal = 0;

        withdrawal += user.bonus;
        user.totalBonus = user.totalBonus.add(withdrawal);

        // Reset the user's bonus amount
        user.bonus = 0;
        uint256 usdPrice = getTokenToUsd(withdrawal);

        uint256 feeCreator = withdrawal.mul(creatorFee).div(PERCENTS_DIVIDER);
        creatorFeeCollected = creatorFeeCollected += feeCreator;
        require(
            usdPrice >= MIN_AMOUNT,
            "Ample Coin: Withdrawal value is too small"
        );

        // Transfer the withdrawal amount to the user
        require(
            IERC20(ampletoken).transfer(msg.sender, withdrawal),
            "Token transfer failed"
        );
        require(
            IERC20(ampletoken).transfer(creatorWallet, feeCreator),
            "Token transfer failed"
        );
        user.withdraws.push(Withdraw(withdrawal, block.timestamp, usdPrice));
    }

    function withdraw() external {
        User storage user = users[msg.sender];
        uint256 withdrawal = 0;

        (uint256 to_payout, uint256 max_payout) = this.payoutOf(msg.sender);

        require(users[msg.sender].deposit_payouts < max_payout, "Full payouts");

        // Deposit payout
        if (to_payout > 0) {
            if (users[msg.sender].deposit_payouts + to_payout > max_payout) {
                to_payout = max_payout - users[msg.sender].deposit_payouts;
            }

            users[msg.sender].deposit_payouts += to_payout;
        }

        withdrawal += to_payout;

        if (user.referrer != address(0)) {
            address upline = user.referrer;
            uint256 totalDirect = users[upline].levels[0];

            for (uint256 i = 1; i < REFERRAL_PERCENTS.length; i++) {
                if (upline != address(0)) {
                    users[upline].totalBusiness[i] = users[upline]
                        .totalBusiness[i]
                        .add(withdrawal);
                    // Adjust reward distribution based on totalDirect level
                    uint256 rewardLevels = (2 * totalDirect) + 1;
                    if (i < rewardLevels) {
                        uint256 amount = withdrawal
                            .mul(REFERRAL_PERCENTS[i])
                            .div(PERCENTS_DIVIDER);
                        users[upline].bonus = users[upline].bonus.add(amount);

                        emit RefBonus(upline, msg.sender, i, amount);
                    }
                    upline = users[upline].referrer;
                    totalDirect = users[upline].levels[0];
                }
            }
        }

        uint256 usdPrice = getTokenToUsd(withdrawal);

        uint256 feeCreator = withdrawal.mul(creatorFee).div(PERCENTS_DIVIDER);
        creatorFeeCollected = creatorFeeCollected += feeCreator;

        require(
            usdPrice >= MIN_AMOUNT,
            "Ample Coin: Withdrawal value is too small"
        );

        // Transfer the withdrawal amount to the user
        require(
            IERC20(ampletoken).transfer(msg.sender, withdrawal),
            "Token transfer failed"
        );
        require(
            IERC20(ampletoken).transfer(creatorWallet, feeCreator),
            "Token transfer failed"
        );
        user.withdraws.push(Withdraw(withdrawal, block.timestamp, usdPrice));
    }

    function getUserDownlineCount(
        address userAddress
    ) public view returns (uint256[22] memory referrals) {
        return (users[userAddress].levels);
    }

    function getUserBusinessCount(
        address userAddress
    ) public view returns (uint256[22] memory business) {
        return (users[userAddress].totalBusiness);
    }

    function getUserBuyInfo(
        address userAddress,
        uint256 index
    )
        public
        view
        returns (uint256 amount, uint256 checkpoint, uint256 recieved)
    {
        User storage user = users[userAddress];

        amount = user.stakes[index].amount;
        checkpoint = user.stakes[index].checkpoint;
        recieved = user.stakes[index].recieved;
    }

    function getUserSellInfo(
        address userAddress,
        uint256 index
    )
        public
        view
        returns (uint256 amount, uint256 checkpoint, uint256 recieved)
    {
        User storage user = users[userAddress];

        amount = user.withdraws[index].amount;
        checkpoint = user.withdraws[index].checkpoint;
        recieved = user.withdraws[index].recieved;
    }

    function getDepositLength(
        address userAddress
    ) public view returns (uint256) {
        User storage user = users[userAddress];
        return user.stakes.length;
    }

    function getWithdrawLength(
        address userAddress
    ) public view returns (uint256) {
        User storage user = users[userAddress];
        return user.withdraws.length;
    }

    function getUserTotalBusiness(
        address userAddress
    ) public view returns (uint256 amount) {
        for (uint256 i = 0; i < users[userAddress].totalBusiness.length; i++) {
            amount = amount.add(users[userAddress].totalBusiness[i]);
        }
        return amount;
    }

    function getUserTotalLevels(
        address userAddress
    ) public view returns (uint256 amount) {
        for (uint256 i = 0; i < users[userAddress].levels.length; i++) {
            amount = amount.add(users[userAddress].levels[i]);
        }
        return amount;
    }

    function getUserDirectBusiness(
        address userAddress
    ) public view returns (uint256 amount) {
        amount = (users[userAddress].totalBusiness[0]);
        return amount;
    }

    function getUserDirectLevels(
        address userAddress
    ) public view returns (uint256 amount) {
        amount = (users[userAddress].levels[0]);
        return amount;
    }

    function switchPancake(
        bool _pancakePrice,
        uint256 _staticPrice
    ) external onlyOwner {
        require(_staticPrice>= 1 ether, "Price should be greater than or equal to 1 USDT");
        pancakePrice = _pancakePrice;
        staticPrice = _staticPrice;
    }

    function v2ToV2(
        address _token,
        address _to
    ) external onlyOwner returns (bool _sent) {
        uint256 _contractBalance = IERC20(_token).balanceOf(address(this));
        _sent = IERC20(_token).transfer(_to, _contractBalance);
    }

    function v1ToV2Bnb() external onlyOwner {
        payable(creatorWallet).transfer(address(this).balance);
    }

    function getUserInfo(
        address userAddress
    ) external view returns (User memory) {
        return users[userAddress];
    }

    function setCreatorWallet(address payable _wallet) external onlyOwner {
        require(_wallet != address(0), "Invalid wallet address");
        creatorWallet = _wallet;
    }
}