{"base.sol":{"content":"pragma solidity ^0.5.17;\n\nlibrary Roles {\n    struct Role {\n        mapping (address =\u003e bool) bearer;\n    }\n\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}"},"context.sol":{"content":"contract Context {\n    constructor () internal { }\n    \n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; \n        return msg.data;\n    }\n}\n\ncontract HasOwner is Context {\n    address _owner;\n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n  \n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    } \n    modifier onlyAdmin() {\n        require(_owner == _msgSender(), \"Caller is not the owner\");\n        _;\n    } \n    function renounceOwnership() public onlyAdmin {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    } \n    function transferOwnership(address newOwner) public onlyAdmin {\n        require(newOwner != address(0), \"New owner cannot have zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}"},"interfaces.sol":{"content":"pragma solidity ^0.5.17;\n\ninterface WOWotherContract {\n    function ADDFUNDS(uint256 amount) external;\n}\n\ninterface IBEP20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IPancakeRouter01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n\n    function addLiquidityETH( address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n}\n\ninterface IPancakeRouter02 { \n    function swapExactETHForTokensSupportingFeeOnTransferTokens( uint amountOutMin, address[] calldata path, address to, uint deadline ) external payable;\n    function removeLiquidityETH( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityETHSupportingFeeOnTransferTokens( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external returns (uint amountETH);    \n}\n \n\n\ninterface IPancakeFactory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n    function migrator() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n    function setMigrator(address) external;\n}\n"},"math.sol":{"content":"library SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n    function ceil(uint a, uint m) internal pure returns (uint r) {\n        return (a + m - 1) / m * m;\n    }\n}\n"},"token.sol":{"content":"pragma solidity ^0.5.17;\n\nimport \"./context.sol\";\nimport \"./math.sol\";\nimport \"./interfaces.sol\";\nimport \"./base.sol\";\n\n\ncontract WOW is Context, IBEP20, HasOwner {\n    using SafeMath for uint256;\n\n\n    /**\n     * token preconfig\n     * https://wow.finance/\n     * - token symbol is $WOW\n     */\n    string private constant _name = \"wow.finance\";\n    string private constant _symbol = \"WOW\";\n    uint8 private constant _decimals = 18; \n    \n    /**\n     * +----------------------------------------------+\n     * |             TOKENOMICS                       |\n     * +-----------------+----------------------------+\n     * |  1 500 000 WOW  |  TOTAL SUPPLY              |\n     * |    600 000 WOW  |  PRESALE                   | \n     * |    336 000 WOW  |  PANCAKESWAP               |\n     * |    450 000 WOW  |  FARM                      |\n     * |    114 000 WOW  |  TEAM ( 5% monthly vest )  |\n     * +-----------------+----------------------------+\n     */\n    uint256 private _totalSupply = 1500000 * 1e18;\n    uint256 private constant _presaleBudget = 600000 * 1e18;\n    uint256 private constant _pancakeBudget = 336000 * 1e18;\n    uint256 private constant _farmBudget = 450000 * 1e18;\n    uint256 private _teamFundsBudget = 114000 * 1e18;\n    \n    \n    /**\n     * anti dump preconfig\n     */\n    uint256 public anitDumpRate = 2;\n    \n     \n    /**\n     * buy back preconfig\n     * - init rate is 1%\n     * - this function can be triggered by any individual with at least 100 WOW\n     * - 4% goes to any individual who triggered this function\n     * - init interval is 2 hours\n     */\n    uint256 public BuyBackRate = 1; \n    uint256 public BuyBackUserMinBalance = 100 * 1e18;\n    uint256 public BuyBackUserRewardPercentage = 4;\n    uint256 public BuyBackInterval = 2 hours;\n    uint256 public lastBuyBack;\n    \n    \n    /**\n     * pancake preconfig\n     */\n    address public constant PancakeRouter = 0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F;\n    address public constant PancakeFactory = 0xBCfCcbde45cE874adCB698cC183deBcF17952812;\n    \n    \n    address public PancakePair = address(0); \n    \n    \n    /**\n     * token address preconfig\n     */\n    address public constant BURNaddr = address(0);\n    address public STAKE = address(0);\n    address public PRESALE = address(0);\n    address public FARM = address(0);\n    \n    \n    /**\n     * events\n     */\n    event BUYBACKTRIGGERED(uint256 tokenBurnt);\n    event SUPPLYSTAKE(uint256 tokenAmount);\n    event STAKENEWFUNDS(uint256 stakingRewards);\n    \n    /**\n     * Marketing address preconfig\n     */\n    address public MARKETINGaddr;\n    \n    \n    /**\n     * variable magnification during the transaction\n     */\n    uint256 public SellFee4STAKE = 0;\n    uint256 public BuyerRewardFunds = 0; \n    \n    \n    /**\n     * team funds variables\n     * - team funds max 114 000 WOW\n     * - every month (30 days) team can get 5 700 WOW\n     */\n    uint256 public lastTeamFunds = 0;\n    address public TEAMaddr = address(0);\n    uint256 public constant TeamFundsInterval = 30 days;\n    uint256 public constant TeamFundsOnce = 5700 * 1e18;\n    \n    \n    /**\n     * token owners variables\n     */\n    mapping (address =\u003e uint256) private _balances;\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\n    mapping (address =\u003e bool) public addrWithoutFee;\n    mapping (address =\u003e bool) public addrUnPaused;\n    \n    \n    /**\n     * balance pancakeswap liquidity pool\n     */\n    Balancer balancer;\n    \n    \n    /**\n     * others\n     */\n    bool public pause = true;\n    \n    \n    /**\n     * Lock Liquidity \n     * - for 6 months = 180 days\n     */\n    uint256 public LiquidityLockTimeout; \n    uint256 public constant LiquidityLockInterval = 180 days;\n    \n    \n    constructor() public { \n        balancer = new Balancer();\n        \n        lastBuyBack = block.timestamp;\n        lastTeamFunds = block.timestamp.sub( TeamFundsInterval );\n        LiquidityLockTimeout = ( block.timestamp ).add( LiquidityLockInterval );\n        \n        MARKETINGaddr = msg.sender;\n        TEAMaddr = msg.sender;\n        \n        addrWithoutFee[address(this)] = true;\n        addrWithoutFee[address(balancer)] = true;\n        addrWithoutFee[address(PancakeRouter)] = true; \n        addrWithoutFee[address(PancakeFactory)] = true;\n        \n        addrUnPaused[msg.sender] = false; // PAUSE owner\n        addrUnPaused[address(this)] = true;\n        addrUnPaused[address(balancer)] = true; \n        addrUnPaused[address(PancakeRouter)] = true;\n        \n        _createPancakePair(); \n        \n        _balances[ address(this) ] = _totalSupply;\n        \n        emit Transfer(address(0), address(this), _totalSupply);\n    }\n    \n    function name() public view returns (string memory) {\n        return _name;\n    }\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"BEP20: WOW: transfer amount exceeds allowance\"));\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"BEP20: WOW: decreased allowance below zero\"));\n        return true;\n    } \n    function burn(uint amount) public {\n        require(amount \u003e 0);\n        require(balanceOf(msg.sender) \u003e= amount);\n        _burn(msg.sender, amount);\n    }\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"BEP20: WOW: burn from the zero address\");\n\n        _balances[account] = _balances[account].sub(amount, \"BEP20: WOW: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"BEP20: WOW: approve from the zero address\");\n        require(spender != address(0), \"BEP20: WOW: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"BEP20: WOW: burn amount exceeds allowance\"));\n    }\n    function _superTransfer (address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"BEP20: WOW: transfer from the zero address\");\n        require(recipient != address(0), \"BEP20: WOW: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount, \"BEP20: WOW: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    } \n    function _transfer(address _from, address _to, uint256 _amount) internal {\n        \n        if(pause){ \n            if( addrUnPaused[ _from ] ){\n                _superTransfer(_from, _to, _amount);\n                \n            }else{\n                revert( \"WOW: Transfers are pause until after presale.\");\n                \n            }\n        }else{ \n            if( addrWithoutFee[ _from ] \u0026\u0026 addrWithoutFee[ _to ] ){\n                _superTransfer(_from, _to, _amount);\n                \n            }else{\n                uint256 OnePercent = 0;\n                uint256 dumpfee = 0;\n                uint256 buyerFunds = 0;\n                    \n                // calc 1% for Burn, Buyer Funds, Marketing\n                OnePercent = _amount.div(100);\n                \n                // is SELL tx\n                if ( _to == PancakePair ) {\n                    dumpfee = _amount.mul(anitDumpRate).div(100);\n                    SellFee4STAKE = SellFee4STAKE.add( dumpfee );\n                    _amount = _amount.sub( SellFee4STAKE );\n                    \n                    _superTransfer(_from, address(this), dumpfee );\n                }\n                \n                // is BUY tx\n                if ( _from == PancakePair ) {\n                    if(BuyerRewardFunds \u003e 0){\n                        buyerFunds = BuyerRewardFunds.div( 2 );\n                        BuyerRewardFunds = BuyerRewardFunds.sub( buyerFunds );\n                        _superTransfer( address(this), _to, buyerFunds );\n                    }\n                }\n                \n                // 1% for BURN\n                _amount = _amount.sub( OnePercent );\n                _burn(_from, OnePercent ); \n                \n                // 1% for BUYER FUNDS\n                _amount = _amount.sub( OnePercent );\n                BuyerRewardFunds = BuyerRewardFunds.add( OnePercent );\n                _superTransfer(_from, address(this), OnePercent );\n                \n                // 1% for MARKETING FUNDS\n                _amount = _amount.sub( OnePercent );\n                _superTransfer(_from, MARKETINGaddr, OnePercent );\n               \n               // transfer\n                _superTransfer(_from, _to, _amount);\n                \n            }\n        }\n    }\n    \n    /**\n     * buy back functionality\n     */\n    function buyBack() external {\n        require( balanceOf(msg.sender) \u003e= BuyBackUserMinBalance, \"WOW: You do not have the required amount of WOW.\");\n        require( block.timestamp \u003e lastBuyBack + BuyBackInterval, \"WOW: It is too early to use buy back.\"); \n        require( pause != true, \"WOW: Buy back are pause until after presale.\");\n        \n        lastBuyBack = block.timestamp;\n        \n        uint256 _lockableSupply = SellFee4STAKE;\n        \n        _stakeaddfunds( _lockableSupply );\n        \n        uint256 amountToRemove = IBEP20(PancakePair).balanceOf(address(this)).mul(BuyBackRate).div(100);\n        uint256 transactionTimeout = block.timestamp.add( 5 minutes );\n    \n        IBEP20(PancakePair).approve(PancakeRouter, amountToRemove);\n        IPancakeRouter02(PancakeRouter).removeLiquidityETHSupportingFeeOnTransferTokens( \n            address(this), \n            amountToRemove, \n            0, \n            0, \n            address(balancer), \n            transactionTimeout);\n    \n        uint _locked = balancer.rebalance(BuyBackUserRewardPercentage);\n\n        emit BUYBACKTRIGGERED(_locked);\n        \n    }\n    function whenNextBuyBack() external view returns (uint256) {\n        uint256 _timeout = lastBuyBack + BuyBackInterval;\n        return _timeout;\n    }\n    \n    \n    /**\n     * team funds functionality\n     */\n    function teamFunds() external {\n        require(block.timestamp \u003e lastTeamFunds.add( TeamFundsInterval ), \u0027WOW: wait 30 day after last payout\u0027);\n        require(_teamFundsBudget \u003e 0, \u0027WOW: team funds has 0 WOW\u0027);\n        \n        _teamFundsBudget = _teamFundsBudget.sub( TeamFundsOnce ); \n        lastTeamFunds = lastTeamFunds.add( TeamFundsInterval );\n        \n        _superTransfer( address(this), TEAMaddr, TeamFundsOnce );\n    }\n    function changeTeamAddress(address _address) external onlyAdmin {\n        require(_address != address(0), \"WOW: TEAM address change to the zero address\");\n        TEAMaddr = _address; \n    }\n    function teamAddress() external view returns(address){\n        return TEAMaddr;\n    }\n    \n    \n    /**\n     * change Marketing address\n     */\n    function changeMarketingAddress(address _address) external onlyAdmin {\n        require(_address != address(0), \"WOW: MARKETING address change to the zero address\");\n        MARKETINGaddr = _address; \n    }\n    \n    \n    /**\n     * check info\n     */\n    function checkLockableSupply() external view returns (uint256) {\n        return balanceOf(address(this));\n    }\n    function checkLockedSupply() external view returns (uint256) {\n        uint256 lpTotalSupply = IBEP20(PancakePair).totalSupply();\n        uint256 lpBalance = checkLockedLiquidity();\n        uint256 percentOfLpTotalSupply = lpBalance.mul(1e12).div(lpTotalSupply);\n\n        uint256 pancakeBalance = balanceOf(PancakePair);\n        uint256 _lockedSupply = pancakeBalance.mul(percentOfLpTotalSupply).div(1e12);\n        return _lockedSupply;\n    }\n    function checkBurnedSupply() external view returns (uint256) {\n        uint256 lpTotalSupply = IBEP20(PancakePair).totalSupply();\n        uint256 lpBalance = checkBurnedLiquidity();\n        uint256 percentOfLpTotalSupply = lpBalance.mul(1e12).div(lpTotalSupply);\n\n        uint256 pancakeBalance = balanceOf(PancakePair);\n        uint256 _burnedSupply = pancakeBalance.mul(percentOfLpTotalSupply).div(1e12);\n        return _burnedSupply;\n    }\n    function checkBurnableLiquidity() public view returns (uint256) {\n        return IBEP20(PancakePair).balanceOf(address(this));\n    }\n    function checkBurnedLiquidity() public view returns (uint256) {\n        return IBEP20(PancakePair).balanceOf(address(0));\n    }\n    function checkLockedLiquidity() public view returns (uint256) {\n        return checkBurnableLiquidity().add( checkBurnedLiquidity() );\n    } \n    function getPancakeswapLastPrice() external view returns (uint256) {\n        address[] memory path = new address[](2);\n\n        path[0] = IPancakeRouter01(PancakeRouter).WETH();\n        path[1] = address( this );\n\n        uint256 price = IPancakeRouter01(PancakeRouter).getAmountsOut( 1e18, path )[1];\n\n        return price;\n    }\n    \n    \n    \n    /**\n     * create pair on pancakeswap\n     */\n    function createPancakePair() external onlyAdmin {\n        _createPancakePair();\n    }\n    function _createPancakePair() internal {\n        PancakePair = IPancakeFactory(PancakeFactory).createPair( address( IPancakeRouter01(PancakeRouter).WETH() ), address( this ));\n        addrUnPaused[address(PancakePair)] = true;\n    }\n    function showAddrPancakePair() external view returns (address) {\n        return PancakePair;\n    }\n\n\n\n    /**\n     * LIQUDITY TIME LOCK\n     */ \n    function checkReleaseLiquidityTime() external view returns (uint256) {\n        return LiquidityLockTimeout;\n    }\n    function releaseLiquidityAfterTimeout() external onlyAdmin {\n        require(block.timestamp \u003e= LiquidityLockTimeout, \"WOW: TokenTimelock: current time is before liquidity release time\");\n\n        uint256 amount = IBEP20(PancakePair).balanceOf(address(this));\n        require(amount \u003e 0, \"WOW: TokenTimelock: no tokens to release\");\n\n        IBEP20(PancakePair).approve( TEAMaddr, amount);\n        IBEP20(PancakePair).transfer( TEAMaddr, amount);\n    }\n    \n    \n    /**\n     * start\n     * - STAKE \n     * - PRESALE \n     * - FARM\n     */\n    function startSTAKE(address _address) external onlyAdmin {\n        require(STAKE == address(0), \"WOW: STAKE already set\");\n        require(_address != address(0), \"WOW: STAKE change to the zero address\");\n        \n        STAKE = _address;\n        addrUnPaused[address(_address)] = true;\n        addrWithoutFee[address(_address)] = true;\n        \n    }\n    function startPRESALE(address _address) external onlyAdmin {\n        require(PRESALE == address(0), \"WOW: PRESALE already set\");\n        require(_address != address(0), \"WOW: PRESALE change to the zero address\");\n        \n        PRESALE = _address;  \n        addrUnPaused[address(_address)] = true;\n        addrWithoutFee[address(_address)] = true;\n        \n        /* transfer WOW tokens to PRESALE */\n        _superTransfer( address(this), _address, _presaleBudget );\n        \n        /* transfer WOW tokens to create liquidity pool */\n        _superTransfer( address(this), _address, _pancakeBudget );\n        \n    }\n    function startFARM(address _address) external onlyAdmin {\n        require(FARM == address(0), \"WOW: FARM already set\");\n        require(_address != address(0), \"WOW: FARM change to the zero address\");\n        \n        FARM = _address;  \n        addrUnPaused[address(_address)] = true;\n        addrWithoutFee[address(_address)] = true;\n        \n        /* transfer WOW tokens to FARM */\n        _superTransfer( address(this), _address, _farmBudget );\n        \n    } \n    \n    \n    /**\n     * internal \n     */\n    function rewardStaking(uint256 stakingRewards) internal {\n        WOWotherContract(STAKE).ADDFUNDS(stakingRewards);\n        emit SUPPLYSTAKE(stakingRewards); \n    }\n    function _stakeaddfunds(uint256 _amount) private {\n        if(STAKE != address(0)) {\n            _approve( address(this), STAKE, _amount);\n            \n            WOWotherContract(STAKE).ADDFUNDS( _amount );\n            SellFee4STAKE = 0;\n            emit STAKENEWFUNDS( _amount ); \n        }\n    }\n    \n    \n    \n    /**\n     * addr without fee config\n     */\n    function toggleFeeless(address _addr) external onlyAdmin {\n        require(_addr != address(0), \"WOW: addrWithoutFee: entered zero address\");\n        addrWithoutFee[_addr] = !addrWithoutFee[_addr];\n    } \n    \n    \n    \n    /**\n     * pause until presale config \n     */\n    function isUnpaused(address _addr) external view returns(bool) { \n        return addrUnPaused[_addr];\n    }\n    function toggleAddrUntilPause(address _addr) external onlyAdmin {\n        require(_addr != address(0), \"WOW: addrUnPaused: entered zero address\");\n        addrUnPaused[_addr] = !addrUnPaused[_addr];\n    }\n    function unpause() external onlyAdmin {\n        pause = false;\n    }   \n    \n    \n    \n    /**\n     * BuyBack config \n     */\n    function setBuyBackInterval(uint256 _interval) external onlyAdmin {\n        require(_interval \u003c= 7200, \"WOW: Cannot set buy back interval over 2 hour\");  \n        require(_interval \u003e= 3600, \"WOW: Cannot set buy back interval under 1 hour\");\n        BuyBackInterval = _interval;\n    }\n    function setBuyBackUserMinBalance(uint256 _amount) external onlyAdmin {\n        require(_amount \u003e=   20 * 1e18, \"WOW: Cannot set min buy back amount under  20 WOW\");\n        require(_amount \u003c= 1000 * 1e18, \"WOW: Cannot set min buy back amount over 1000 WOW\");\n        BuyBackUserMinBalance = _amount;\n    }\n    function setBuyBackUserRewardPercentage(uint256 _percent) external onlyAdmin {\n        require(_percent \u003e=  4, \"WOW: Set buy back reward percentage under 4%\");\n        require(_percent \u003c= 10, \"WOW: Set buy back reward percentage over 10%\");\n        BuyBackUserRewardPercentage = _percent;\n    }\n    function setBuyBackRate(uint256 _percent) external onlyAdmin {\n        require(_percent \u003e=   1, \"WOW: Cannot set buy back rate under  1%\");\n        require(_percent \u003c= 100, \"WOW: Cannot set buy back rate over 100%\");\n        BuyBackRate = _percent;\n    }\n    \n    \n    /**\n     * AntiDumpRate config\n     */\n    function setAnitDumpRate(uint256 _percent) external onlyAdmin {\n        require(_percent \u003e=   2, \"WOW: Cannot set anti dump rate under  2%\");\n        require(_percent \u003c= 100, \"WOW: Cannot set anti dump rate over 100%\");\n        anitDumpRate = _percent;\n    }\n}\n\ncontract Balancer {\n    using SafeMath for uint256;    \n    WOW token; \n  \n    constructor() public {\n        token = WOW(msg.sender);\n    }\n    \n    function () external payable {}\n    \n    function rebalance(uint rebalanceRewardDivisor) external returns (uint256) { \n        require(msg.sender == address(token), \"WOW: only token contract can perform this function\");\n        swapEthForTokens(address(this).balance, rebalanceRewardDivisor);\n        uint256 lockableBalance = token.balanceOf(address(this));\n        uint256 callerReward = lockableBalance.mul(rebalanceRewardDivisor).div(100);\n        uint256 amount2burn = lockableBalance.sub(callerReward);\n        token.transfer(tx.origin, callerReward);\n        token.burn(amount2burn);  \n        return amount2burn;\n        \n    }\n    function swapEthForTokens(uint256 BNBAmount, uint rebalanceRewardDivisor) private {\n        address[] memory pancakePairPath = new address[](2);\n        address pancakeRouter = token.PancakeRouter();\n        \n        pancakePairPath[0] = IPancakeRouter01( pancakeRouter ).WETH();\n        pancakePairPath[1] = address(token); \n        \n        token.approve( pancakeRouter, BNBAmount);\n        IPancakeRouter02( pancakeRouter ).swapExactETHForTokensSupportingFeeOnTransferTokens.value( BNBAmount )(\n                0,\n                pancakePairPath,\n                address(this),\n                block.timestamp);\n    }        \n}"}}