{"ErrorReporter.sol":{"content":"pragma solidity ^0.7.4;\n\ncontract ControllerErrorReporter {\n    enum Error {\n        NO_ERROR,\n        UNAUTHORIZED,\n        CONTROLLER_MISMATCH,\n        INSUFFICIENT_SHORTFALL,\n        INSUFFICIENT_LIQUIDITY,\n        INVALID_CLOSE_FACTOR,\n        INVALID_COLLATERAL_FACTOR,\n        INVALID_LIQUIDATION_INCENTIVE,\n        MARKET_NOT_ENTERED, // no longer possible\n        MARKET_NOT_LISTED,\n        MARKET_ALREADY_LISTED,\n        MATH_ERROR,\n        NONZERO_BORROW_BALANCE,\n        PRICE_ERROR,\n        PRICE_UPDATE_ERROR,\n        REJECTION,\n        SNAPSHOT_ERROR,\n        TOO_MANY_ASSETS,\n        TOO_MUCH_REPAY\n    }\n\n    enum FailureInfo {\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n        ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\n        EXIT_MARKET_BALANCE_OWED,\n        EXIT_MARKET_REJECTION,\n        SET_CLOSE_FACTOR_OWNER_CHECK,\n        SET_CLOSE_FACTOR_VALIDATION,\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\n        SET_COLLATERAL_FACTOR_NO_EXISTS,\n        SET_COLLATERAL_FACTOR_VALIDATION,\n        SET_COLLATERAL_FACTOR_WITHOUT_PRICE,\n        SET_IMPLEMENTATION_OWNER_CHECK,\n        SET_LIQUIDATION_INCENTIVE_OWNER_CHECK,\n        SET_LIQUIDATION_INCENTIVE_VALIDATION,\n        SET_MAX_ASSETS_OWNER_CHECK,\n        SET_PAUSE_GUARDIAN_OWNER_CHECK,\n        SET_PENDING_ADMIN_OWNER_CHECK,\n        SET_PENDING_IMPLEMENTATION_OWNER_CHECK,\n        SET_PRICE_ORACLE_OWNER_CHECK,\n        SUPPORT_MARKET_EXISTS,\n        SUPPORT_MARKET_OWNER_CHECK\n    }\n\n    /**\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n      **/\n    event Failure(uint error, uint info, uint detail);\n\n    /**\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n      */\n    function fail(Error err, FailureInfo info) internal returns (uint) {\n        emit Failure(uint(err), uint(info), 0);\n\n        return uint(err);\n    }\n\n    /**\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n      */\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\n        emit Failure(uint(err), uint(info), opaqueError);\n\n        return uint(err);\n    }\n}\n\ncontract TokenErrorReporter {\n    enum Error {\n        NO_ERROR,\n        UNAUTHORIZED,\n        BAD_INPUT,\n        CONTROLLER_REJECTION,\n        CONTROLLER_CALCULATION_ERROR,\n        INTEREST_RATE_MODEL_ERROR,\n        INVALID_ACCOUNT_PAIR,\n        INVALID_CLOSE_AMOUNT_REQUESTED,\n        INVALID_COLLATERAL_FACTOR,\n        MATH_ERROR,\n        MARKET_NOT_FRESH,\n        MARKET_NOT_LISTED,\n        TOKEN_INSUFFICIENT_ALLOWANCE,\n        TOKEN_INSUFFICIENT_BALANCE,\n        TOKEN_INSUFFICIENT_CASH,\n        TOKEN_TRANSFER_IN_FAILED,\n        TOKEN_TRANSFER_OUT_FAILED\n    }\n\n    /*\n     * Note: FailureInfo (but not Error) is kept in alphabetical order\n     *       This is because FailureInfo grows significantly faster, and\n     *       the order of Error has some meaning, while the order of FailureInfo\n     *       is entirely arbitrary.\n     */\n    enum FailureInfo {\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n        ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\n        ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\n        ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\n        BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n        BORROW_ACCRUE_INTEREST_FAILED,\n        BORROW_CASH_NOT_AVAILABLE,\n        BORROW_FRESHNESS_CHECK,\n        BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n        BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n        BORROW_MARKET_NOT_LISTED,\n        BORROW_CONTROLLER_REJECTION,\n        LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED,\n        LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED,\n        LIQUIDATE_COLLATERAL_FRESHNESS_CHECK,\n        LIQUIDATE_CONTROLLER_REJECTION,\n        LIQUIDATE_CONTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED,\n        LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX,\n        LIQUIDATE_CLOSE_AMOUNT_IS_ZERO,\n        LIQUIDATE_FRESHNESS_CHECK,\n        LIQUIDATE_LIQUIDATOR_IS_BORROWER,\n        LIQUIDATE_REPAY_BORROW_FRESH_FAILED,\n        LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,\n        LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,\n        LIQUIDATE_SEIZE_CONTROLLER_REJECTION,\n        LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER,\n        LIQUIDATE_SEIZE_TOO_MUCH,\n        MINT_ACCRUE_INTEREST_FAILED,\n        MINT_CONTROLLER_REJECTION,\n        MINT_EXCHANGE_CALCULATION_FAILED,\n        MINT_EXCHANGE_RATE_READ_FAILED,\n        MINT_FRESHNESS_CHECK,\n        MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n        MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n        MINT_TRANSFER_IN_FAILED,\n        MINT_TRANSFER_IN_NOT_POSSIBLE,\n        REDEEM_ACCRUE_INTEREST_FAILED,\n        REDEEM_CONTROLLER_REJECTION,\n        REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\n        REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\n        REDEEM_EXCHANGE_RATE_READ_FAILED,\n        REDEEM_FRESHNESS_CHECK,\n        REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n        REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n        REDEEM_TRANSFER_OUT_NOT_POSSIBLE,\n        REDUCE_RESERVES_ACCRUE_INTEREST_FAILED,\n        REDUCE_RESERVES_ADMIN_CHECK,\n        REDUCE_RESERVES_CASH_NOT_AVAILABLE,\n        REDUCE_RESERVES_FRESH_CHECK,\n        REDUCE_RESERVES_VALIDATION,\n        REPAY_BEHALF_ACCRUE_INTEREST_FAILED,\n        REPAY_BORROW_ACCRUE_INTEREST_FAILED,\n        REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n        REPAY_BORROW_CONTROLLER_REJECTION,\n        REPAY_BORROW_FRESHNESS_CHECK,\n        REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n        REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n        REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\n        SET_COLLATERAL_FACTOR_VALIDATION,\n        SET_CONTROLLER_OWNER_CHECK,\n        SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED,\n        SET_INTEREST_RATE_MODEL_FRESH_CHECK,\n        SET_INTEREST_RATE_MODEL_OWNER_CHECK,\n        SET_MAX_ASSETS_OWNER_CHECK,\n        SET_ORACLE_MARKET_NOT_LISTED,\n        SET_PENDING_ADMIN_OWNER_CHECK,\n        SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED,\n        SET_RESERVE_FACTOR_ADMIN_CHECK,\n        SET_RESERVE_FACTOR_FRESH_CHECK,\n        SET_RESERVE_FACTOR_BOUNDS_CHECK,\n        TRANSFER_CONTROLLER_REJECTION,\n        TRANSFER_NOT_ALLOWED,\n        TRANSFER_NOT_ENOUGH,\n        TRANSFER_TOO_MUCH,\n        ADD_RESERVES_ACCRUE_INTEREST_FAILED,\n        ADD_RESERVES_FRESH_CHECK,\n        ADD_RESERVES_TRANSFER_IN_NOT_POSSIBLE,\n        SET_NEW_IMPLEMENTATION\n    }\n\n    /**\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n      **/\n    event Failure(uint error, uint info, uint detail);\n\n    /**\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n      */\n    function fail(Error err, FailureInfo info) internal returns (uint) {\n        emit Failure(uint(err), uint(info), 0);\n\n        return uint(err);\n    }\n\n    /**\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n      */\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\n        emit Failure(uint(err), uint(info), opaqueError);\n\n        return uint(err);\n    }\n}\n\ncontract OracleErrorReporter {\n    enum Error {\n        NO_ERROR,\n        UNAUTHORIZED,\n        UPDATE_PRICE\n    }\n\n    enum FailureInfo {\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n        NO_RESERVES,\n        PERIOD_NOT_ELAPSED,\n        SET_NEW_ADDRESSES,\n        SET_NEW_IMPLEMENTATION,\n        SET_PENDING_ADMIN_OWNER_CHECK\n    }\n\n    /**\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n      **/\n    event Failure(uint error, uint info, uint detail);\n\n    /**\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n      */\n    function fail(Error err, FailureInfo info) internal returns (uint) {\n        emit Failure(uint(err), uint(info), 0);\n\n        return uint(err);\n    }\n}\n\ncontract FactoryErrorReporter {\n    enum Error {\n        NO_ERROR,\n        INVALID_POOL,\n        MARKET_NOT_LISTED,\n        UNAUTHORIZED\n    }\n\n    //TODO: Add more cases\n    enum FailureInfo {\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n        CREATE_PETH_POOL,\n        CREATE_PPIE_POOL,\n        DEFICIENCY_ETH_LIQUIDITY_IN_POOL,\n        PAIR_IS_NOT_EXIST,\n        SET_MIN_LIQUIDITY_OWNER_CHECK,\n        SET_NEW_CONTROLLER,\n        SET_NEW_EXCHANGE_RATE,\n        SET_NEW_IMPLEMENTATION,\n        SET_NEW_INTEREST_RATE_MODEL,\n        SET_NEW_ORACLE,\n        SET_NEW_RESERVE_FACTOR,\n        SET_PENDING_ADMIN_OWNER_CHECK,\n        SUPPORT_MARKET_BAD_RESULT\n    }\n\n    /**\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n      **/\n    event Failure(uint error, uint info, uint detail);\n\n    /**\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n      */\n    function fail(Error err, FailureInfo info) internal returns (uint) {\n        emit Failure(uint(err), uint(info), 0);\n\n        return uint(err);\n    }\n}\n\ncontract RegistryErrorReporter {\n    enum Error {\n        NO_ERROR,\n        UNAUTHORIZED\n    }\n\n    //TODO: Add more cases\n    enum FailureInfo {\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n        SET_NEW_IMPLEMENTATION,\n        SET_PENDING_ADMIN_OWNER_CHECK,\n        SET_NEW_FACTORY\n    }\n\n    /**\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n      **/\n    event Failure(uint error, uint info, uint detail);\n\n    /**\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n      */\n    function fail(Error err, FailureInfo info) internal returns (uint) {\n        emit Failure(uint(err), uint(info), 0);\n\n        return uint(err);\n    }\n}\n"},"PPIEDelegator.sol":{"content":"pragma solidity ^0.7.4;\n\nimport \"./ProxyWithRegistry.sol\";\nimport \"./RegistryInterface.sol\";\nimport \"./ErrorReporter.sol\";\n\n/**\n * @title DeFiPie\u0027s PPIEDelegator Contract\n * @notice PPIE which wrap an EIP-20 underlying and delegate to an implementation\n * @author DeFiPie\n */\ncontract PPIEDelegator is ImplementationStorage, ProxyWithRegistry, TokenErrorReporter {\n\n    /**\n      * @notice Emitted when implementation is changed\n      */\n    event NewImplementation(address oldImplementation, address newImplementation);\n\n    /**\n     * @notice Construct a new money market\n     * @param underlying_ The address of the underlying asset\n     * @param pPIEImplementation_ The address of the PPIEImplementation\n     * @param controller_ The address of the Controller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param initialReserveFactorMantissa_ The initial reserve factor, scaled by 1e18\n     * @param name_ ERC-20 name of this token\n     * @param symbol_ ERC-20 symbol of this token\n     * @param decimals_ ERC-20 decimal precision of this token\n     * @param registry_ The address of the registry contract\n     */\n    constructor(\n        address underlying_,\n        address pPIEImplementation_,\n        address controller_,\n        address interestRateModel_,\n        uint initialExchangeRateMantissa_,\n        uint initialReserveFactorMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        address registry_\n    ) {\n        // Set registry\n        _setRegistry(registry_);\n        _setImplementation(pPIEImplementation_);\n\n        // First delegate gets to initialize the delegator (i.e. storage contract)\n        delegateTo(implementation, abi.encodeWithSignature(\"initialize(address,address,address,address,uint256,uint256,string,string,uint8)\",\n                                                        underlying_,\n                                                        registry_,\n                                                        controller_,\n                                                        interestRateModel_,\n                                                        initialExchangeRateMantissa_,\n                                                        initialReserveFactorMantissa_,\n                                                        name_,\n                                                        symbol_,\n                                                        decimals_));\n    }\n\n    /**\n     * @notice Internal method to delegate execution to another contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     * @param callee The contract to delegatecall\n     * @param data The raw data to delegatecall\n     * @return The returned bytes from the delegatecall\n     */\n    function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\n        assembly {\n            if eq(success, 0) {\n                revert(add(returnData, 0x20), returndatasize())\n            }\n        }\n        return returnData;\n    }\n\n    function delegateAndReturn() internal returns (bytes memory) {\n        (bool success, ) = implementation.delegatecall(msg.data);\n\n        assembly {\n            let free_mem_ptr := mload(0x40)\n            returndatacopy(free_mem_ptr, 0, returndatasize())\n\n            switch success\n            case 0 { revert(free_mem_ptr, returndatasize()) }\n            default { return(free_mem_ptr, returndatasize()) }\n        }\n    }\n\n    /**\n     * @notice Delegates execution to an implementation contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     */\n    fallback() external {\n        // delegate all other functions to current implementation\n        delegateAndReturn();\n    }\n\n    function setImplementation(address newImplementation) external returns(uint) {\n        if (msg.sender != RegistryInterface(registry).admin()) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_NEW_IMPLEMENTATION);\n        }\n\n        address oldImplementation = implementation;\n        _setImplementation(newImplementation);\n\n        emit NewImplementation(oldImplementation, implementation);\n\n        return(uint(Error.NO_ERROR));\n    }\n}\n\n"},"ProxyWithRegistry.sol":{"content":"pragma solidity ^0.7.4;\n\nimport \"./RegistryInterface.sol\";\n\ncontract ProxyWithRegistryStorage {\n\n    /**\n     * @notice Address of the registry contract\n     */\n    address public registry;\n}\n\nabstract contract ProxyWithRegistryInterface is ProxyWithRegistryStorage {\n    function _setRegistry(address _registry) internal virtual;\n    function _pTokenImplementation() internal view virtual returns (address);\n}\n\ncontract ProxyWithRegistry is ProxyWithRegistryInterface {\n    /**\n     *  Returns actual address of the implementation contract from current registry\n     *  @return registry Address of the registry\n     */\n    function _pTokenImplementation() internal view override returns (address) {\n        return RegistryInterface(registry).pTokenImplementation();\n    }\n\n    function _setRegistry(address _registry) internal override {\n        registry = _registry;\n    }\n}\n\ncontract ImplementationStorage {\n\n    address public implementation;\n\n    function _setImplementation(address implementation_) internal {\n        implementation = implementation_;\n    }\n}\n"},"RegistryInterface.sol":{"content":"pragma solidity ^0.7.4;\n\ninterface RegistryInterface {\n\n    /**\n     *  Returns admin address for cToken contracts\n     *  @return admin address\n     */\n    function admin() external view returns (address payable);\n\n    /**\n     *  Returns address of actual PToken implementation contract\n     *  @return Address of contract\n     */\n    function pTokenImplementation() external view returns (address);\n\n    function addPToken(address underlying, address pToken) external returns(uint);\n    function addPETH(address pETH_) external returns(uint);\n    function addPPIE(address pPIE_) external returns(uint);\n}\n"}}