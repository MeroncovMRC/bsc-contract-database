
// File: @openzeppelin/contracts/security/ReentrancyGuard.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)

pragma solidity ^0.8.0;

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and making it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}


// File: @openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
 * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
 *
 * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
 * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't
 * need to send a transaction, and thus is not required to hold Ether at all.
 */
interface IERC20Permit {
    /**
     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,
     * given ``owner``'s signed approval.
     *
     * IMPORTANT: The same issues {IERC20-approve} has related to transaction
     * ordering also apply here.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `deadline` must be a timestamp in the future.
     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
     * over the EIP712-formatted function arguments.
     * - the signature must use ``owner``'s current nonce (see {nonces}).
     *
     * For more information on the signature format, see the
     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
     * section].
     */
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    /**
     * @dev Returns the current nonce for `owner`. This value must be
     * included whenever a signature is generated for {permit}.
     *
     * Every successful call to {permit} increases ``owner``'s nonce by one. This
     * prevents a signature from being used multiple times.
     */
    function nonces(address owner) external view returns (uint256);

    /**
     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.
     */
    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32);
}


// File: @openzeppelin/contracts/token/ERC20/IERC20.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `from` to `to` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
}


// File: @openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)

pragma solidity ^0.8.0;

import "../IERC20.sol";
import "../extensions/draft-IERC20Permit.sol";
import "../../../utils/Address.sol";

/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
    using Address for address;

    function safeTransfer(
        IERC20 token,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(
        IERC20 token,
        address from,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    /**
     * @dev Deprecated. This function has issues similar to the ones found in
     * {IERC20-approve}, and its usage is discouraged.
     *
     * Whenever possible, use {safeIncreaseAllowance} and
     * {safeDecreaseAllowance} instead.
     */
    function safeApprove(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        require(
            (value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance = token.allowance(address(this), spender) + value;
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        unchecked {
            uint256 oldAllowance = token.allowance(address(this), spender);
            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");
            uint256 newAllowance = oldAllowance - value;
            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
        }
    }

    function safePermit(
        IERC20Permit token,
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal {
        uint256 nonceBefore = token.nonces(owner);
        token.permit(owner, spender, value, deadline, v, r, s);
        uint256 nonceAfter = token.nonces(owner);
        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
        if (returndata.length > 0) {
            // Return data is optional
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}


// File: @openzeppelin/contracts/utils/Address.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)

pragma solidity ^0.8.1;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     *
     * [IMPORTANT]
     * ====
     * You shouldn't rely on `isContract` to protect against flash loan attacks!
     *
     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
     * constructor.
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize/address.code.length, which returns 0
        // for contracts in construction, since the code is only stored at the end
        // of the constructor execution.

        return account.code.length > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain `call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCall(target, data, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");

        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");

        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(isContract(target), "Address: delegate call to non-contract");

        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the
     * revert reason using the provided one.
     *
     * _Available since v4.3._
     */
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length > 0) {
                // The easiest way to bubble the revert reason is using memory via assembly
                /// @solidity memory-safe-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}


// File: contracts/facets/base/DiamondCutFacet.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.16;

import { IDiamondCut } from "../../interfaces/IDiamondCut.sol";
import { LibDiamond } from "../../libraries/LibDiamond.sol";

contract DiamondCutFacet is IDiamondCut {
    /// @notice Add/replace/remove any number of functions and optionally execute
    ///         a function with delegatecall
    /// @param _diamondCut Contains the facet addresses and function selectors
    /// @param _init The address of the contract or facet to execute _calldata
    /// @param _calldata A function call, including function selector and arguments
    ///                  _calldata is executed with delegatecall on _init
    function diamondCut(
        FacetCut[] calldata _diamondCut,
        address _init,
        bytes calldata _calldata
    ) external override {
        LibDiamond.enforceIsContractOwner();
        LibDiamond.diamondCut(_diamondCut, _init, _calldata);
    }
}


// File: contracts/facets/base/DiamondLoupeFacet.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.16;

import {LibDiamond} from "../../libraries/LibDiamond.sol";
import {IDiamondLoupe} from "../../interfaces/IDiamondLoupe.sol";
import {IERC165} from "../../interfaces/IERC165.sol";

contract DiamondLoupeFacet is IDiamondLoupe, IERC165 {
    // Diamond Loupe Functions
    ////////////////////////////////////////////////////////////////////
    /// These functions are expected to be called frequently by tools.
    //
    // struct Facet {
    //     address facetAddress;
    //     bytes4[] functionSelectors;
    // }

    /// @notice Gets all facets and their selectors.
    /// @return facets_ Facet
    function facets() external view override returns (Facet[] memory facets_) {
        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();
        uint256 numFacets = ds.facetAddresses.length;
        facets_ = new Facet[](numFacets);
        for (uint256 i = 0; i < numFacets;) {
            address facetAddress_ = ds.facetAddresses[i];
            facets_[i].facetAddress = facetAddress_;
            facets_[i].functionSelectors = ds.facetFunctionSelectors[facetAddress_].functionSelectors;
            unchecked {
                ++i;
            }
        }
    }

    /// @notice Gets all selectors
    /// @return selectors the function selectors.
    function selectors() external view returns (bytes4[]memory) {
        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();
        uint256 numFacets = ds.facetAddresses.length;
        uint256 numSelectors;

        uint256 i;
        for (i = 0; i < numFacets;) {
            address facetAddress_ = ds.facetAddresses[i];
            numSelectors += ds.facetFunctionSelectors[facetAddress_].functionSelectors.length;
            unchecked {
                ++i;
            }
        }

        bytes4[] memory selectors_ = new bytes4[](numSelectors);
        uint256 j;
        uint256 k;
        for (i = 0; i < numFacets;) {
            address facetAddress_ = ds.facetAddresses[i];
            for (j = 0; j < ds.facetFunctionSelectors[facetAddress_].functionSelectors.length;) {
                selectors_[k] = ds.facetFunctionSelectors[facetAddress_].functionSelectors[j];
                unchecked {
                    ++j;
                    ++k;
                }
            }
            unchecked {
                ++i;
            }
        }
        return selectors_;
    }

    /// @notice Gets all the function selectors provided by a facet.
    /// @param _facet The facet address.
    /// @return facetFunctionSelectors_
    function facetFunctionSelectors(address _facet)
        external
        view
        override
        returns (bytes4[] memory facetFunctionSelectors_)
    {
        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();
        facetFunctionSelectors_ = ds.facetFunctionSelectors[_facet].functionSelectors;
    }

    /// @notice Get all the facet addresses used by a diamond.
    /// @return facetAddresses_
    function facetAddresses() external view override returns (address[] memory facetAddresses_) {
        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();
        facetAddresses_ = ds.facetAddresses;
    }

    /// @notice Gets the facet that supports the given selector.
    /// @dev If facet is not found return address(0).
    /// @param _functionSelector The function selector.
    /// @return facetAddress_ The facet address.
    function facetAddress(bytes4 _functionSelector) external view override returns (address facetAddress_) {
        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();
        facetAddress_ = ds.selectorToFacetAndPosition[_functionSelector].facetAddress;
    }

    // This implements ERC-165.
    function supportsInterface(bytes4 _interfaceId) external view override returns (bool) {
        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();
        return ds.supportedInterfaces[_interfaceId];
    }
}


// File: contracts/facets/base/OwnershipFacet.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.16;

import { LibDiamond } from "../../libraries/LibDiamond.sol";
import { IERC173 } from "../../interfaces/IERC173.sol";

contract OwnershipFacet is IERC173 {
    /// Storage ///

    /// @dev keccak256("exchange.rango.facets.ownership");
    bytes32 internal constant NAMESPACE = hex"62434cca177aa6071a5ef14ac38a94bc33078d7cb2c1f72b485320da7dfd349b";
    struct Storage {
        address newOwner;
    }

    /// Errors ///

    error NoNullOwner();
    error NewOwnerMustNotBeSelf();
    error NoPendingOwnershipTransfer();
    error NotPendingOwner();

    /// Events ///

    event OwnershipTransferRequested(address indexed _from, address indexed _to);

    /// External Methods ///

    /// @notice Initiates transfer of ownership to a new address
    /// @param _newOwner the address to transfer ownership to
    function transferOwnership(address _newOwner) external override {
        LibDiamond.enforceIsContractOwner();
        Storage storage s = getStorage();

        if (_newOwner == address(0)) revert NoNullOwner();

        if (_newOwner == LibDiamond.contractOwner()) revert NewOwnerMustNotBeSelf();

        s.newOwner = _newOwner;
        emit OwnershipTransferRequested(msg.sender, s.newOwner);
    }

    /// @notice Cancel transfer of ownership
    function cancelOwnershipTransfer() external {
        LibDiamond.enforceIsContractOwner();
        Storage storage s = getStorage();

        if (s.newOwner == address(0)) revert NoPendingOwnershipTransfer();
        s.newOwner = address(0);
    }

    /// @notice Confirms transfer of ownership to the calling address (msg.sender)
    function confirmOwnershipTransfer() external {
        Storage storage s = getStorage();
        address _pendingOwner = s.newOwner;
        if (msg.sender != _pendingOwner) revert NotPendingOwner();
        emit OwnershipTransferred(LibDiamond.contractOwner(), _pendingOwner);
        LibDiamond.setContractOwner(_pendingOwner);
        s.newOwner = address(0);
    }

    /// @notice Return the current owner address
    /// @return owner_ The current owner address
    function owner() external view override returns (address owner_) {
        owner_ = LibDiamond.contractOwner();
    }

    /// @dev fetch local storage
    function getStorage() private pure returns (Storage storage s) {
        bytes32 namespace = NAMESPACE;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            s.slot := namespace
        }
    }
}


// File: contracts/facets/base/RangoAccessManagerFacet.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "../../libraries/LibDiamond.sol";
import "../../libraries/LibSwapper.sol";

contract RangoAccessManagerFacet {

    struct whitelistRequest {
        address contractAddress;
        bytes4[] methodIds;
    }

    /// @notice Notifies that a new contract is whitelisted
    /// @param _address The address of the contract
    event ContractWhitelisted(address _address);

    /// @notice Notifies that a new contract is whitelisted
    /// @param contractAddress The address of the contract
    /// @param methods The method signatures that are whitelisted for a contractAddress
    event ContractAndMethodsWhitelisted(address contractAddress, bytes4[] methods);

    /// @notice Notifies that a new contract is blacklisted
    /// @param _address The address of the contract
    event ContractBlacklisted(address _address);

    /// @notice Adds a contract & its' methods to the whitelisted addresses that can be called. The contract is usually a dex.
    /// @param req The array containing address of the contract & its' methods
    function addWhitelistContract(whitelistRequest[] calldata req) public {
        LibDiamond.enforceIsContractOwner();

        for (uint i = 0; i < req.length; i++) {
            LibSwapper.addMethodWhitelists(req[i].contractAddress, req[i].methodIds);
            emit ContractAndMethodsWhitelisted(req[i].contractAddress, req[i].methodIds);
            emit ContractWhitelisted(req[i].contractAddress);
        }
    }

    /// @notice Adds a contract to the whitelisted addresses that can be called
    /// @param _address The address of the contract to be whitelisted
    function addWhitelistContract(address _address) public {
        LibDiamond.enforceIsContractOwner();
        LibSwapper.addWhitelist(_address);
        emit ContractWhitelisted(_address);
    }

    /// @notice Adds a list of contracts to the whitelisted conracts that can be called
    /// @param _addresses The addresses of the contracts to be whitelisted
    function addWhitelists(address[] calldata _addresses) external {
        LibDiamond.enforceIsContractOwner();
        for (uint i = 0; i < _addresses.length; i++)
            addWhitelistContract(_addresses[i]);
    }

    /// @notice Removes a contract from the whitelisted addresses
    /// @param _address The address of the contract to be removed from whitelist
    function removeWhitelistContract(address _address) external {
        LibDiamond.enforceIsContractOwner();
        LibSwapper.removeWhitelist(_address);
        emit ContractBlacklisted(_address);
    }
}

// File: contracts/facets/base/RangoBaseInterchainMiddleware.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "../../libraries/LibDiamond.sol";
import "../../libraries/LibInterchain.sol";

// @title The base contract to be used as a parent of middleware classes
// @author George
// @dev Note that this is not a facet and should be extended and deployed separately.
contract RangoBaseInterchainMiddleware {
    /// @dev keccak256("exchange.rango.middleware.base")
    bytes32 internal constant BASE_MIDDLEWARE_CONTRACT_NAMESPACE = hex"ad914d4300c64e1902ca499875cd8a76ae717047bcfaa9e806ff7ea4f6911268";

    struct BaseInterchainMiddlewareStorage {
        address rangoDiamond;
        address owner;
    }

    struct whitelistRequest {
        address contractAddress;
        bytes4[] methodIds;
    }

    constructor(
        address _owner,
        address _rangoDiamond,
        address _weth
    ){
        require(_owner != address(0));
        updateOwnerInternal(_owner);
        updateRangoDiamondInternal(_rangoDiamond);
        LibSwapper.setWeth(_weth);
    }


    /// Events
    /// @notice Emits when the rango diamond address is updated
    /// @param oldAddress The previous address
    /// @param newAddress The new address
    event RangoDiamondAddressUpdated(address oldAddress, address newAddress);
    /// @notice Emits when the weth address is updated
    /// @param oldAddress The previous address
    /// @param newAddress The new address
    event WethAddressUpdated(address oldAddress, address newAddress);
    /// @notice Emits when the owner is updated
    /// @param previousOwner The previous owner
    /// @param newOwner The new owner
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    /// @notice Notifies that admin manually refunded some money
    /// @param _token The address of refunded token, 0x000..00 address for native token
    /// @param _amount The amount that is refunded
    event Refunded(address _token, uint _amount);
    /// @notice Notifies that a new contract is whitelisted
    /// @param _address The address of the contract
    event ContractWhitelisted(address _address);
    /// @notice Notifies that a new contract is blacklisted
    /// @param _address The address of the contract
    event ContractBlacklisted(address _address);
    /// @notice Notifies that a new contract is whitelisted
    /// @param _dapp The address of the contract
    event MessagingDAppWhitelisted(address _dapp);
    /// @notice Notifies that a new contract is blacklisted
    /// @param _dapp The address of the contract
    event MessagingDAppBlacklisted(address _dapp);

    /// @notice used to limit access only to owner
    modifier onlyOwner() {
        require(msg.sender == getBaseInterchainMiddlewareStorage().owner, "should be called only from diamond");
        _;
    }

    /// @notice used to limit access only to rango diamond
    modifier onlyDiamond() {
        require(msg.sender == getBaseInterchainMiddlewareStorage().rangoDiamond, "should be called only from diamond");
        _;
    }

    /// @notice Enables the contract to receive native ETH token from other contracts including WETH contract
    receive() external payable {}

    /// Administration & Control

    /// @notice Updates the address of rango diamond contract
    /// @param newAddress The new address of diamond contract
    function updateRangoDiamondAddress(address newAddress) external onlyOwner {
        updateRangoDiamondInternal(newAddress);
    }
    /// @notice Updates the address of weth contract
    /// @param newAddress The new address of weth contract
    function updateWethAddress(address newAddress) external onlyOwner {
        LibSwapper.setWeth(newAddress);
    }
    /// @notice Updates the address of owner
    /// @param newAddress The new address of owner
    function updateOwner(address newAddress) external onlyOwner {
        updateOwnerInternal(newAddress);
    }

    /// @notice Transfers an ERC20 token from this contract to msg.sender
    /// @dev This endpoint is to return money to a user if we didn't handle failure correctly and the money is still in the contract
    /// @dev Currently the money goes to admin and they should manually transfer it to a wallet later
    /// @param _tokenAddress The address of ERC20 token to be transferred
    /// @param _amount The amount of money that should be transfered
    function refund(address _tokenAddress, uint256 _amount) external onlyOwner {
        IERC20 ercToken = IERC20(_tokenAddress);
        uint balance = ercToken.balanceOf(address(this));
        require(balance >= _amount, 'Insufficient balance');

        SafeERC20.safeTransfer(IERC20(_tokenAddress), msg.sender, _amount);
        emit Refunded(_tokenAddress, _amount);
    }

    /// @notice Transfers the native token from this contract to msg.sender
    /// @dev This endpoint is to return money to a user if we didn't handle failure correctly and the money is still in the contract
    /// @dev Currently the money goes to admin and they should manually transfer it to a wallet later
    /// @param _amount The amount of native token that should be transferred
    function refundNative(uint256 _amount) external onlyOwner {
        uint balance = address(this).balance;
        require(balance >= _amount, 'Insufficient balance');

        (bool sent,) = msg.sender.call{value : _amount}("");
        require(sent, "failed to send native");

        emit Refunded(LibSwapper.ETH, _amount);
    }

    /// @notice Adds a list of contracts to the whitelisted DEXes that can be called
    /// @param req The requests for whitelisting contracts and methods
    function addWhitelistContractMiddleWare(whitelistRequest[] calldata req) external onlyOwner {
        for (uint i = 0; i < req.length; i++) {
            LibSwapper.addMethodWhitelists(req[i].contractAddress, req[i].methodIds);
            emit ContractWhitelisted(req[i].contractAddress);
        }
    }

    /// @notice Removes a contract from the whitelisted DEXes
    /// @param contractAddress The address of the DEX or dApp
    function removeWhitelistMiddleWare(address contractAddress) external onlyOwner {
        LibSwapper.removeWhitelist(contractAddress);
        emit ContractBlacklisted(contractAddress);
    }

    /// @notice Removes a method of contract from the whitelisted DEXes
    /// @param contractAddress The address of the DEX or dApp
    /// @param methodId The method of the DEX
    function removeMethodWhitelistMiddleWare(address contractAddress, bytes4 methodId) external onlyOwner {
        LibSwapper.removeMethodWhitelist(contractAddress, methodId);
    }

    /// @notice Adds a list of contracts to the whitelisted messaging dApps that can be called
    /// @param _dapps The addresses of dApps
    function addMessagingDAppsMiddleWare(address[] calldata _dapps) external onlyOwner {
        address dapp;
        for (uint i = 0; i < _dapps.length; i++) {
            dapp = _dapps[i];
            LibInterchain.addMessagingDApp(dapp);
            emit MessagingDAppWhitelisted(dapp);
        }
    }

    /// @notice Removes a contract from dApps that can be called
    /// @param _dapp The address of dApp
    function removeMessagingDAppContractMiddleWare(address _dapp) external onlyOwner {
        LibInterchain.removeMessagingDApp(_dapp);
        emit MessagingDAppBlacklisted(_dapp);
    }


    /// Internal and Private functions
    function updateRangoDiamondInternal(address newAddress) private {
        BaseInterchainMiddlewareStorage storage s = getBaseInterchainMiddlewareStorage();
        address oldAddress = s.rangoDiamond;
        s.rangoDiamond = newAddress;
        emit RangoDiamondAddressUpdated(oldAddress, newAddress);
    }

    function updateOwnerInternal(address newAddress) private {
        BaseInterchainMiddlewareStorage storage s = getBaseInterchainMiddlewareStorage();
        address oldAddress = s.owner;
        s.owner = newAddress;
        emit OwnershipTransferred(oldAddress, newAddress);
    }

    /// @dev fetch local storage
    function getBaseInterchainMiddlewareStorage() private pure returns (BaseInterchainMiddlewareStorage storage s) {
        bytes32 namespace = BASE_MIDDLEWARE_CONTRACT_NAMESPACE;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            s.slot := namespace
        }
    }
}

// File: contracts/facets/base/RangoInterchainFacet.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "../../libraries/LibDiamond.sol";
import "../../libraries/LibInterchain.sol";

contract RangoInterchainFacet {
    /// Events ///

    /// @notice Notifies that a new contract is whitelisted
    /// @param _dapp The address of the contract
    event MessagingDAppWhitelisted(address _dapp);

    /// @notice Notifies that a new contract is blacklisted
    /// @param _dapp The address of the contract
    event MessagingDAppBlacklisted(address _dapp);

    /// @notice Adds a contract to the whitelisted messaging dApps that can be called
    /// @param _dapp The address of dApp
    function addMessagingDAppContract(address _dapp) public {
        LibDiamond.enforceIsContractOwner();
        LibInterchain.addMessagingDApp(_dapp);
        emit MessagingDAppWhitelisted(_dapp);
    }

    /// @notice Adds a list of contracts to the whitelisted messaging dApps that can be called
    /// @param _dapps The addresses of dApps
    function addMessagingDApps(address[] calldata _dapps) external {
        LibDiamond.enforceIsContractOwner();
        for (uint i = 0; i < _dapps.length; i++)
            addMessagingDAppContract(_dapps[i]);
    }

    /// @notice Removes a contract from dApps that can be called
    /// @param _dapp The address of dApp
    function removeMessagingDAppContract(address _dapp) external {
        LibDiamond.enforceIsContractOwner();
        LibInterchain.removeMessagingDApp(_dapp);
        emit MessagingDAppBlacklisted(_dapp);
    }
}

// File: contracts/facets/base/RangoSwapperFacet.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "../../libraries/LibDiamond.sol";
import "../../libraries/LibSwapper.sol";
import "../../utils/ReentrancyGuard.sol";

contract RangoSwapperFacet is ReentrancyGuard{
    /// Events ///

    /// @notice initializes the base swapper and sets the init params
    /// @param _weth Address of wrapped token (WETH, WBNB, etc.) on the current chain
    function initBaseSwapper(address _weth, address payable _feeReceiver) public {
        LibDiamond.enforceIsContractOwner();
        LibSwapper.setWeth(_weth);    
        LibSwapper.updateFeeContractAddress(_feeReceiver);           
    }

    /// @notice Sets the wallet that receives Rango's fees from now on
    /// @param _address The receiver wallet address
    function updateFeeReceiver(address payable _address) external {
        LibDiamond.enforceIsContractOwner();
        LibSwapper.updateFeeContractAddress(_address);
    }

    /// @notice Transfers an ERC20 token from this contract to msg.sender
    /// @dev This endpoint is to return money to a user if we didn't handle failure correctly and the money is still in the contract
    /// @dev Currently the money goes to admin and they should manually transfer it to a wallet later
    /// @param _tokenAddress The address of ERC20 token to be transferred
    /// @param _amount The amount of money that should be transfered
    function refund(address _tokenAddress, uint256 _amount) external {
        LibDiamond.enforceIsContractOwner();
        IERC20 ercToken = IERC20(_tokenAddress);
        uint balance = ercToken.balanceOf(address(this));
        require(balance >= _amount, "Insufficient balance");

        SafeERC20.safeTransfer(ercToken, msg.sender, _amount);

        emit LibSwapper.Refunded(_tokenAddress, _amount);
    }

    /// @notice Transfers the native token from this contract to msg.sender
    /// @dev This endpoint is to return money to a user if we didn't handle failure correctly and the money is still in the contract
    /// @dev Currently the money goes to admin and they should manually transfer it to a wallet later
    /// @param _amount The amount of native token that should be transfered
    function refundNative(uint256 _amount) external {
        LibDiamond.enforceIsContractOwner();
        uint balance = address(this).balance;
        require(balance >= _amount, "Insufficient balance");

        LibSwapper._sendToken(LibSwapper.ETH, _amount, msg.sender, true, false);

        emit LibSwapper.Refunded(LibSwapper.ETH, _amount);
    }

    /// @notice Does a simple on-chain swap
    /// @param request The general swap request containing from/to token and fee/affiliate rewards
    /// @param calls The list of DEX calls
    /// @param nativeOut indicates that the output of swaps must be a native token
    /// @param receiver The address that should receive the output of swaps.
    /// @return The byte array result of all DEX calls
    function onChainSwaps(
        LibSwapper.SwapRequest memory request,
        LibSwapper.Call[] calldata calls,
        bool nativeOut,
        address receiver
    ) external payable nonReentrant returns (bytes[] memory) {
        require(receiver != LibSwapper.ETH, "receiver cannot be address(0)");
        (bytes[] memory result, uint outputAmount) = LibSwapper.onChainSwapsInternal(request, calls, 0);
        LibSwapper.emitSwapEvent(request, outputAmount, receiver);
        LibSwapper._sendToken(request.toToken, outputAmount, receiver, nativeOut, false);
        return result;
    }

    function isContractWhitelisted(address _contractAddress) external view returns (bool) {
        LibDiamond.enforceIsContractOwner();
        LibSwapper.BaseSwapperStorage storage baseSwapperStorage = LibSwapper.getBaseSwapperStorage();

        return baseSwapperStorage.whitelistContracts[_contractAddress];
    } 
}

// File: contracts/facets/bridges/cbridge/im/interfaces/IBridge.sol
// SPDX-License-Identifier: GPL-3.0-only

pragma solidity 0.8.16;

interface IBridge {
    function send(
        address _receiver,
        address _token,
        uint256 _amount,
        uint64 _dstChainId,
        uint64 _nonce,
        uint32 _maxSlippage
    ) external;

    function sendNative(
        address _receiver,
        uint256 _amount,
        uint64 _dstChainId,
        uint64 _nonce,
        uint32 _maxSlippage
    ) external payable;

    function relay(
        bytes calldata _relayRequest,
        bytes[] calldata _sigs,
        address[] calldata _signers,
        uint256[] calldata _powers
    ) external;

    function transfers(bytes32 transferId) external view returns (bool);

    function withdraws(bytes32 withdrawId) external view returns (bool);

    function withdraw(
        bytes calldata _wdmsg,
        bytes[] calldata _sigs,
        address[] calldata _signers,
        uint256[] calldata _powers
    ) external;

    /**
     * @notice Verifies that a message is signed by a quorum among the signers.
     * @param _msg signed message
     * @param _sigs list of signatures sorted by signer addresses in ascending order
     * @param _signers sorted list of current signers
     * @param _powers powers of current signers
     */
    function verifySigs(
        bytes memory _msg,
        bytes[] calldata _sigs,
        address[] calldata _signers,
        uint256[] calldata _powers
    ) external view;
}


// File: contracts/facets/bridges/cbridge/im/interfaces/IMessageBusSender.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

interface IMessageBusSender {
    function calcFee(bytes calldata _message) external view returns (uint256);
}

// File: contracts/facets/bridges/cbridge/im/message/framework/MessageBusAddress.sol
// SPDX-License-Identifier: GPL-3.0-only
pragma solidity 0.8.16;

abstract contract MessageBusAddress {
    /// @dev keccak256("exchange.rango.facets.cbridge.msg.messagebusaddress")
    bytes32 internal constant MSG_BUS_ADDRESS_NAMESPACE = hex"d82f4f572578dde7d9e798c168d6d6abab176a082ca20bc9a27a6c48782c92ef";

    struct MsgBusAddrStorage {
        address messageBus;
    }

    event MessageBusUpdated(address messageBus);

    function setMessageBusInternal(address _messageBus) internal {
        MsgBusAddrStorage storage s = getMsgBusAddrStorage();
        s.messageBus = _messageBus;
        emit MessageBusUpdated(s.messageBus);
    }

    function getMsgBusAddress() internal view returns (address) {
        MsgBusAddrStorage storage s = getMsgBusAddrStorage();
        return s.messageBus;
    }

    /// @dev fetch local storage
    function getMsgBusAddrStorage() private pure returns (MsgBusAddrStorage storage s) {
        bytes32 namespace = MSG_BUS_ADDRESS_NAMESPACE;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            s.slot := namespace
        }
    }

}


// File: contracts/facets/bridges/cbridge/im/message/framework/MessageReceiverApp.sol
// SPDX-License-Identifier: GPL-3.0-only

pragma solidity 0.8.16;

import "../interfaces/IMessageReceiverApp.sol";
import "./MessageBusAddress.sol";

abstract contract MessageReceiverApp is IMessageReceiverApp, MessageBusAddress {
    modifier onlyMessageBus() {
        require(msg.sender == getMsgBusAddress(), "caller is not message bus");
        _;
    }

    /**
     * @notice Called by MessageBus (MessageBusReceiver) if the process is originated from MessageBus (MessageBusSender)'s
     *         sendMessageWithTransfer it is only called when the tokens are checked to be arrived at this contract's address.
     * @param _sender The address of the source app contract
     * @param _token The address of the token that comes out of the bridge
     * @param _amount The amount of tokens received at this contract through the cross-chain bridge.
     *        the contract that implements this contract can safely assume that the tokens will arrive before this
     *        function is called.
     * @param _srcChainId The source chain ID where the transfer is originated from
     * @param _message Arbitrary message bytes originated from and encoded by the source app contract
     * @param _executor Address who called the MessageBus execution function
     */
    function executeMessageWithTransfer(
        address _sender,
        address _token,
        uint256 _amount,
        uint64 _srcChainId,
        bytes calldata _message,
        address _executor
    ) external payable virtual override onlyMessageBus returns (ExecutionStatus) {}

    /**
     * @notice Only called by MessageBus (MessageBusReceiver) if
     *         1. executeMessageWithTransfer reverts, or
     *         2. executeMessageWithTransfer returns ExecutionStatus.Fail
     * @param _sender The address of the source app contract
     * @param _token The address of the token that comes out of the bridge
     * @param _amount The amount of tokens received at this contract through the cross-chain bridge.
     *        the contract that implements this contract can safely assume that the tokens will arrive before this
     *        function is called.
     * @param _srcChainId The source chain ID where the transfer is originated from
     * @param _message Arbitrary message bytes originated from and encoded by the source app contract
     * @param _executor Address who called the MessageBus execution function
     */
    function executeMessageWithTransferFallback(
        address _sender,
        address _token,
        uint256 _amount,
        uint64 _srcChainId,
        bytes calldata _message,
        address _executor
    ) external payable virtual override onlyMessageBus returns (ExecutionStatus) {}

    /**
     * @notice Called by MessageBus (MessageBusReceiver) to process refund of the original transfer from this contract
     * @param _token The token address of the original transfer
     * @param _amount The amount of the original transfer
     * @param _message The same message associated with the original transfer
     * @param _executor Address who called the MessageBus execution function
     */
    function executeMessageWithTransferRefund(
        address _token,
        uint256 _amount,
        bytes calldata _message,
        address _executor
    ) external payable virtual override onlyMessageBus returns (ExecutionStatus) {}

    /**
     * @notice Called by MessageBus (MessageBusReceiver)
     * @param _sender The address of the source app contract
     * @param _srcChainId The source chain ID where the transfer is originated from
     * @param _message Arbitrary message bytes originated from and encoded by the source app contract
     * @param _executor Address who called the MessageBus execution function
     */
    function executeMessage(
        address _sender,
        uint64 _srcChainId,
        bytes calldata _message,
        address _executor
    ) external payable virtual override onlyMessageBus returns (ExecutionStatus) {}
}


// File: contracts/facets/bridges/cbridge/im/message/framework/MessageSenderApp.sol
// SPDX-License-Identifier: GPL-3.0-only

pragma solidity 0.8.16;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import "../libraries/MsgDataTypes.sol";
import "../libraries/MessageSenderLib.sol";
import "./MessageBusAddress.sol";

abstract contract MessageSenderApp is MessageBusAddress {
    using SafeERC20 for IERC20;

    // ============== Utility functions called by apps ==============

    /**
     * @notice Sends a message to a contract on another chain.
     * Sender needs to make sure the uniqueness of the message Id, which is computed as
     * hash(type.MessageOnly, sender, receiver, srcChainId, srcTxHash, dstChainId, message).
     * If messages with the same Id are sent, only one of them will succeed at dst chain.
     * @param _receiver The address of the destination app contract.
     * @param _dstChainId The destination chain ID.
     * @param _message Arbitrary message bytes to be decoded by the destination app contract.
     * @param _fee The fee amount to pay to MessageBus.
     */
    function sendMessage(
        address _receiver,
        uint64 _dstChainId,
        bytes memory _message,
        uint256 _fee
    ) internal {
        MessageSenderLib.sendMessage(_receiver, _dstChainId, _message, getMsgBusAddress(), _fee);
    }

    /**
     * @notice Sends a message associated with a transfer to a contract on another chain.
     * @param _receiver The address of the destination app contract.
     * @param _token The address of the token to be sent.
     * @param _amount The amount of tokens to be sent.
     * @param _dstChainId The destination chain ID.
     * @param _nonce A number input to guarantee uniqueness of transferId. Can be timestamp in practice.
     * @param _maxSlippage The max slippage accepted, given as percentage in point (pip). Eg. 5000 means 0.5%.
     *        Must be greater than minimalMaxSlippage. Receiver is guaranteed to receive at least
     *        (100% - max slippage percentage) * amount or the transfer can be refunded.
     *        Only applicable to the {MsgDataTypes.BridgeSendType.Liquidity}.
     * @param _message Arbitrary message bytes to be decoded by the destination app contract.
     *        If message is empty, only the token transfer will be sent
     * @param _bridgeSendType One of the {BridgeSendType} enum.
     * @param _fee The fee amount to pay to MessageBus.
     * @return The transfer ID.
     */
    function sendMessageWithTransfer(
        address _receiver,
        address _token,
        uint256 _amount,
        uint64 _dstChainId,
        uint64 _nonce,
        uint32 _maxSlippage,
        bytes memory _message,
        MsgDataTypes.BridgeSendType _bridgeSendType,
        uint256 _fee
    ) internal returns (bytes32) {
        return
        MessageSenderLib.sendMessageWithTransfer(
            _receiver,
            _token,
            _amount,
            _dstChainId,
            _nonce,
            _maxSlippage,
            _message,
            _bridgeSendType,
            getMsgBusAddress(),
            _fee
        );
    }

    /**
     * @notice Sends a token transfer via a bridge.
     * @dev sendMessageWithTransfer with empty message
     * @param _receiver The address of the destination app contract.
     * @param _token The address of the token to be sent.
     * @param _amount The amount of tokens to be sent.
     * @param _dstChainId The destination chain ID.
     * @param _nonce A number input to guarantee uniqueness of transferId. Can be timestamp in practice.
     * @param _maxSlippage The max slippage accepted, given as percentage in point (pip). Eg. 5000 means 0.5%.
     *        Must be greater than minimalMaxSlippage. Receiver is guaranteed to receive at least
     *        (100% - max slippage percentage) * amount or the transfer can be refunded.
     *        Only applicable to the {MsgDataTypes.BridgeSendType.Liquidity}.
     * @param _bridgeSendType One of the {BridgeSendType} enum.
     */
    function sendTokenTransfer(
        address _receiver,
        address _token,
        uint256 _amount,
        uint64 _dstChainId,
        uint64 _nonce,
        uint32 _maxSlippage,
        MsgDataTypes.BridgeSendType _bridgeSendType
    ) internal returns (bytes32) {
        return
        MessageSenderLib.sendMessageWithTransfer(
            _receiver,
            _token,
            _amount,
            _dstChainId,
            _nonce,
            _maxSlippage,
            "", // empty message, which will not trigger sendMessage
            _bridgeSendType,
            getMsgBusAddress(),
            0
        );
    }
}


// File: contracts/facets/bridges/cbridge/im/message/interfaces/IMessageBus.sol
// SPDX-License-Identifier: GPL-3.0-only

pragma solidity 0.8.16;

import "../libraries/MsgDataTypes.sol";

interface IMessageBus {
    function liquidityBridge() external view returns (address);

    function pegBridge() external view returns (address);

    function pegBridgeV2() external view returns (address);

    function pegVault() external view returns (address);

    function pegVaultV2() external view returns (address);

    /**
     * @notice Calculates the required fee for the message.
     * @param _message Arbitrary message bytes to be decoded by the destination app contract.
     @ @return The required fee.
     */
    function calcFee(bytes calldata _message) external view returns (uint256);

    /**
     * @notice Sends a message to a contract on another chain.
     * Sender needs to make sure the uniqueness of the message Id, which is computed as
     * hash(type.MessageOnly, sender, receiver, srcChainId, srcTxHash, dstChainId, message).
     * If messages with the same Id are sent, only one of them will succeed at dst chain..
     * A fee is charged in the native gas token.
     * @param _receiver The address of the destination app contract.
     * @param _dstChainId The destination chain ID.
     * @param _message Arbitrary message bytes to be decoded by the destination app contract.
     */
    function sendMessage(
        address _receiver,
        uint256 _dstChainId,
        bytes calldata _message
    ) external payable;

    /**
     * @notice Sends a message associated with a transfer to a contract on another chain.
     * If messages with the same srcTransferId are sent, only one of them will succeed at dst chain..
     * A fee is charged in the native token.
     * @param _receiver The address of the destination app contract.
     * @param _dstChainId The destination chain ID.
     * @param _srcBridge The bridge contract to send the transfer with.
     * @param _srcTransferId The transfer ID.
     * @param _dstChainId The destination chain ID.
     * @param _message Arbitrary message bytes to be decoded by the destination app contract.
     */
    function sendMessageWithTransfer(
        address _receiver,
        uint256 _dstChainId,
        address _srcBridge,
        bytes32 _srcTransferId,
        bytes calldata _message
    ) external payable;

    /**
     * @notice Withdraws message fee in the form of native gas token.
     * @param _account The address receiving the fee.
     * @param _cumulativeFee The cumulative fee credited to the account. Tracked by SGN.
     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A withdrawal must be
     * signed-off by +2/3 of the sigsVerifier's current signing power to be delivered.
     * @param _signers The sorted list of signers.
     * @param _powers The signing powers of the signers.
     */
    function withdrawFee(
        address _account,
        uint256 _cumulativeFee,
        bytes[] calldata _sigs,
        address[] calldata _signers,
        uint256[] calldata _powers
    ) external;

    /**
     * @notice Execute a message with a successful transfer.
     * @param _message Arbitrary message bytes originated from and encoded by the source app contract
     * @param _transfer The transfer info.
     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by
     * +2/3 of the sigsVerifier's current signing power to be delivered.
     * @param _signers The sorted list of signers.
     * @param _powers The signing powers of the signers.
     */
    function executeMessageWithTransfer(
        bytes calldata _message,
        MsgDataTypes.TransferInfo calldata _transfer,
        bytes[] calldata _sigs,
        address[] calldata _signers,
        uint256[] calldata _powers
    ) external payable;

    /**
     * @notice Execute a message with a refunded transfer.
     * @param _message Arbitrary message bytes originated from and encoded by the source app contract
     * @param _transfer The transfer info.
     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by
     * +2/3 of the sigsVerifier's current signing power to be delivered.
     * @param _signers The sorted list of signers.
     * @param _powers The signing powers of the signers.
     */
    function executeMessageWithTransferRefund(
        bytes calldata _message, // the same message associated with the original transfer
        MsgDataTypes.TransferInfo calldata _transfer,
        bytes[] calldata _sigs,
        address[] calldata _signers,
        uint256[] calldata _powers
    ) external payable;

    /**
     * @notice Execute a message not associated with a transfer.
     * @param _message Arbitrary message bytes originated from and encoded by the source app contract
     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by
     * +2/3 of the sigsVerifier's current signing power to be delivered.
     * @param _signers The sorted list of signers.
     * @param _powers The signing powers of the signers.
     */
    function executeMessage(
        bytes calldata _message,
        MsgDataTypes.RouteInfo calldata _route,
        bytes[] calldata _sigs,
        address[] calldata _signers,
        uint256[] calldata _powers
    ) external payable;
}


// File: contracts/facets/bridges/cbridge/im/message/interfaces/IMessageReceiverApp.sol
// SPDX-License-Identifier: GPL-3.0-only

pragma solidity 0.8.16;

interface IMessageReceiverApp {
    enum ExecutionStatus {
        Fail, // execution failed, finalized
        Success, // execution succeeded, finalized
        Retry // execution rejected, can retry later
    }

    /**
     * @notice Called by MessageBus (MessageBusReceiver) if the process is originated from MessageBus (MessageBusSender)'s
     *         sendMessageWithTransfer it is only called when the tokens are checked to be arrived at this contract's address.
     * @param _sender The address of the source app contract
     * @param _token The address of the token that comes out of the bridge
     * @param _amount The amount of tokens received at this contract through the cross-chain bridge.
     *        the contract that implements this contract can safely assume that the tokens will arrive before this
     *        function is called.
     * @param _srcChainId The source chain ID where the transfer is originated from
     * @param _message Arbitrary message bytes originated from and encoded by the source app contract
     * @param _executor Address who called the MessageBus execution function
     */
    function executeMessageWithTransfer(
        address _sender,
        address _token,
        uint256 _amount,
        uint64 _srcChainId,
        bytes calldata _message,
        address _executor
    ) external payable returns (ExecutionStatus);

    /**
     * @notice Only called by MessageBus (MessageBusReceiver) if
     *         1. executeMessageWithTransfer reverts, or
     *         2. executeMessageWithTransfer returns ExecutionStatus.Fail
     * @param _sender The address of the source app contract
     * @param _token The address of the token that comes out of the bridge
     * @param _amount The amount of tokens received at this contract through the cross-chain bridge.
     *        the contract that implements this contract can safely assume that the tokens will arrive before this
     *        function is called.
     * @param _srcChainId The source chain ID where the transfer is originated from
     * @param _message Arbitrary message bytes originated from and encoded by the source app contract
     * @param _executor Address who called the MessageBus execution function
     */
    function executeMessageWithTransferFallback(
        address _sender,
        address _token,
        uint256 _amount,
        uint64 _srcChainId,
        bytes calldata _message,
        address _executor
    ) external payable returns (ExecutionStatus);

    /**
     * @notice Called by MessageBus (MessageBusReceiver) to process refund of the original transfer from this contract
     * @param _token The token address of the original transfer
     * @param _amount The amount of the original transfer
     * @param _message The same message associated with the original transfer
     * @param _executor Address who called the MessageBus execution function
     */
    function executeMessageWithTransferRefund(
        address _token,
        uint256 _amount,
        bytes calldata _message,
        address _executor
    ) external payable returns (ExecutionStatus);

    /**
     * @notice Called by MessageBus (MessageBusReceiver)
     * @param _sender The address of the source app contract
     * @param _srcChainId The source chain ID where the transfer is originated from
     * @param _message Arbitrary message bytes originated from and encoded by the source app contract
     * @param _executor Address who called the MessageBus execution function
     */
    function executeMessage(
        address _sender,
        uint64 _srcChainId,
        bytes calldata _message,
        address _executor
    ) external payable returns (ExecutionStatus);
}


// File: contracts/facets/bridges/cbridge/im/message/libraries/MessageSenderLib.sol
// SPDX-License-Identifier: GPL-3.0-only

pragma solidity 0.8.16;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "../../interfaces/IBridge.sol";
import "../interfaces/IMessageBus.sol";
import "./MsgDataTypes.sol";

library MessageSenderLib {
    using SafeERC20 for IERC20;

    // ============== Internal library functions called by apps ==============

    /**
     * @notice Sends a message to a contract on another chain.
     * Sender needs to make sure the uniqueness of the message Id, which is computed as
     * hash(type.MessageOnly, sender, receiver, srcChainId, srcTxHash, dstChainId, message).
     * If messages with the same Id are sent, only one of them will succeed at dst chain.
     * @param _receiver The address of the destination app contract.
     * @param _dstChainId The destination chain ID.
     * @param _message Arbitrary message bytes to be decoded by the destination app contract.
     * @param _messageBus The address of the MessageBus on this chain.
     * @param _fee The fee amount to pay to MessageBus.
     */
    function sendMessage(
        address _receiver,
        uint64 _dstChainId,
        bytes memory _message,
        address _messageBus,
        uint256 _fee
    ) internal {
        IMessageBus(_messageBus).sendMessage{value : _fee}(_receiver, _dstChainId, _message);
    }

    /**
     * @notice Sends a message associated with a transfer to a contract on another chain.
     * @param _receiver The address of the destination app contract.
     * @param _token The address of the token to be sent.
     * @param _amount The amount of tokens to be sent.
     * @param _dstChainId The destination chain ID.
     * @param _nonce A number input to guarantee uniqueness of transferId. Can be timestamp in practice.
     * @param _maxSlippage The max slippage accepted, given as percentage in point (pip). Eg. 5000 means 0.5%.
     *        Must be greater than minimalMaxSlippage. Receiver is guaranteed to receive at least
     *        (100% - max slippage percentage) * amount or the transfer can be refunded.
     *        Only applicable to the {MsgDataTypes.BridgeSendType.Liquidity}.
     * @param _message Arbitrary message bytes to be decoded by the destination app contract.
     *        If message is empty, only the token transfer will be sent
     * @param _bridgeSendType One of the {MsgDataTypes.BridgeSendType} enum.
     * @param _messageBus The address of the MessageBus on this chain.
     * @param _fee The fee amount to pay to MessageBus.
     * @return The transfer ID.
     */
    function sendMessageWithTransfer(
        address _receiver,
        address _token,
        uint256 _amount,
        uint64 _dstChainId,
        uint64 _nonce,
        uint32 _maxSlippage,
        bytes memory _message,
        MsgDataTypes.BridgeSendType _bridgeSendType,
        address _messageBus,
        uint256 _fee
    ) internal returns (bytes32) {
        if (_bridgeSendType == MsgDataTypes.BridgeSendType.Liquidity) {
            return
            sendMessageWithLiquidityBridgeTransfer(
                _receiver,
                _token,
                _amount,
                _dstChainId,
                _nonce,
                _maxSlippage,
                _message,
                _messageBus,
                _fee
            );
        } else {
            revert("bridge type not supported");
        }
    }

    /**
     * @notice Sends a message to an app on another chain via MessageBus with an associated liquidity bridge transfer.
     * @param _receiver The address of the destination app contract.
     * @param _token The address of the token to be sent.
     * @param _amount The amount of tokens to be sent.
     * @param _dstChainId The destination chain ID.
     * @param _nonce A number input to guarantee uniqueness of transferId. Can be timestamp in practice.
     * @param _maxSlippage The max slippage accepted, given as percentage in point (pip). Eg. 5000 means 0.5%.
     *        Must be greater than minimalMaxSlippage. Receiver is guaranteed to receive at least
     *        (100% - max slippage percentage) * amount or the transfer can be refunded.
     * @param _message Arbitrary message bytes to be decoded by the destination app contract.
     *        If message is empty, only the token transfer will be sent
     * @param _messageBus The address of the MessageBus on this chain.
     * @param _fee The fee amount to pay to MessageBus.
     * @return The transfer ID.
     */
    function sendMessageWithLiquidityBridgeTransfer(
        address _receiver,
        address _token,
        uint256 _amount,
        uint64 _dstChainId,
        uint64 _nonce,
        uint32 _maxSlippage,
        bytes memory _message,
        address _messageBus,
        uint256 _fee
    ) internal returns (bytes32) {
        address bridge = IMessageBus(_messageBus).liquidityBridge();
        // IERC20(_token).safeIncreaseAllowance(bridge, _amount); // using safeIncreaseAllowance fails for eth.usdt
        SafeERC20.safeApprove(IERC20(_token), bridge, 0);
        SafeERC20.safeIncreaseAllowance(IERC20(_token), bridge, _amount);
        IBridge(bridge).send(_receiver, _token, _amount, _dstChainId, _nonce, _maxSlippage);
        bytes32 transferId = keccak256(
            abi.encodePacked(address(this), _receiver, _token, _amount, _dstChainId, _nonce, uint64(block.chainid))
        );
        if (_message.length > 0) {
            IMessageBus(_messageBus).sendMessageWithTransfer{value : _fee}(
                _receiver,
                _dstChainId,
                bridge,
                transferId,
                _message
            );
        }
        return transferId;
    }
}


// File: contracts/facets/bridges/cbridge/im/message/libraries/MsgDataTypes.sol
// SPDX-License-Identifier: GPL-3.0-only

pragma solidity 0.8.16;

library MsgDataTypes {
    // bridge operation type at the sender side (src chain)
    enum BridgeSendType {
        Null,
        Liquidity,
        PegDeposit,
        PegBurn,
        PegV2Deposit,
        PegV2Burn,
        PegV2BurnFrom
    }

    // bridge operation type at the receiver side (dst chain)
    enum TransferType {
        Null,
        LqRelay, // relay through liquidity bridge
        LqWithdraw, // withdraw from liquidity bridge
        PegMint, // mint through pegged token bridge
        PegWithdraw, // withdraw from original token vault
        PegV2Mint, // mint through pegged token bridge v2
        PegV2Withdraw // withdraw from original token vault v2
    }

    enum MsgType {
        MessageWithTransfer,
        MessageOnly
    }

    enum TxStatus {
        Null,
        Success,
        Fail,
        Fallback,
        Pending // transient state within a transaction
    }

    struct TransferInfo {
        TransferType t;
        address sender;
        address receiver;
        address token;
        uint256 amount;
        uint64 wdseq; // only needed for LqWithdraw (refund)
        uint64 srcChainId;
        bytes32 refId;
        bytes32 srcTxHash; // src chain msg tx hash
    }

    struct RouteInfo {
        address sender;
        address receiver;
        uint64 srcChainId;
        bytes32 srcTxHash; // src chain msg tx hash
    }

    struct MsgWithTransferExecutionParams {
        bytes message;
        TransferInfo transfer;
        bytes[] sigs;
        address[] signers;
        uint256[] powers;
    }

    struct BridgeTransferParams {
        bytes request;
        bytes[] sigs;
        address[] signers;
        uint256[] powers;
    }
}


// File: contracts/facets/bridges/cbridge/RangoCBridgeFacet.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "./im/message/framework/MessageSenderApp.sol";
import "./im/message/framework/MessageReceiverApp.sol";
import "../../../interfaces/IUniswapV2.sol";
import "../../../interfaces/IWETH.sol";
import "./im/interfaces/IMessageBusSender.sol";
import "../../../interfaces/IRangoCBridge.sol";
import "../../../libraries/LibInterchain.sol";
import "../../../interfaces/IRangoMessageReceiver.sol";
import "../../../interfaces/Interchain.sol";
import "../../../utils/ReentrancyGuard.sol";
import "../../../libraries/LibDiamond.sol";
import {RangoCBridgeMiddleware} from "./RangoCBridgeMiddleware.sol";

/// @title The root contract that handles Rango's interaction with cBridge through a middleware
/// @author George
/// @dev Logic for direct interaction with CBridge is mostly implemented in RangoCBridgeMiddleware contract.
contract RangoCBridgeFacet is IRango, IRangoCBridge, ReentrancyGuard {
    /// @dev keccak256("exchange.rango.facets.cbridge")
    bytes32 internal constant CBRIDGE_NAMESPACE = hex"c41612f6cce3d3f6bab8332956a2c64db0d9b22d96d4f739ed2233d021aebb9b";

    struct cBridgeStorage {
        address payable rangoCBridgeMiddlewareAddress;
    }

    /// Constructor

    /// @notice Initialize the contract.
    /// @param rangoCBridgeMiddlewareAddress The address of rango cBridge middleware
    function initCBridge(address payable rangoCBridgeMiddlewareAddress) external {
        LibDiamond.enforceIsContractOwner();
        updateRangoCBridgeMiddlewareAddressInternal(rangoCBridgeMiddlewareAddress);
    }

    /// @notice Enables the contract to receive native ETH token from other contracts including WETH contract
    receive() external payable {}


    /// @notice Emits when the cBridge address is updated
    /// @param oldAddress The previous address
    /// @param newAddress The new address
    event RangoCBridgeMiddlewareAddressUpdated(address oldAddress, address newAddress);

    /// @notice Executes a DEX (arbitrary) call + a cBridge send function
    /// @param request The general swap request containing from/to token and fee/affiliate rewards
    /// @param calls The list of DEX calls, if this list is empty, it means that there is no DEX call and we are only bridging
    /// @dev The cbridge part is handled in the RangoCBridgeMiddleware contract
    /// @dev If this function is success, user will automatically receive the fund in the destination in his/her wallet (receiver)
    /// @dev If bridge is out of liquidity somehow after submiting this transaction and success, user must sign a refund transaction which is not currently present here, will be supported soon
    function cBridgeSwapAndBridge(
        LibSwapper.SwapRequest memory request,
        LibSwapper.Call[] calldata calls,
        CBridgeBridgeRequest calldata bridgeRequest
    ) external payable nonReentrant {
        address payable middleware = getCBridgeStorage().rangoCBridgeMiddlewareAddress;
        require(middleware != LibSwapper.ETH, "Middleware not set");
        // transfer tokens to middleware if necessary
        uint sgnFee = bridgeRequest.sgnFee;
        uint value = sgnFee;
        uint bridgeAmount;
        if (request.toToken == LibSwapper.ETH && msg.value == 0) {
            uint out = LibSwapper.onChainSwapsPreBridge(request, calls, 0);
            bridgeAmount = out - sgnFee;
            // value should not decrease sgnFee, we should send full value to the middleware
            value = out;
        }
        else {
            bridgeAmount = LibSwapper.onChainSwapsPreBridge(request, calls, sgnFee);
        }
        // transfer tokens to middleware if necessary
        if (request.toToken != LibSwapper.ETH) {
            SafeERC20.safeTransfer(IERC20(request.toToken), middleware, bridgeAmount);
        }

        if (bridgeRequest.bridgeType == CBridgeBridgeType.TRANSFER) {
            RangoCBridgeMiddleware(middleware).doSend{value : value}(
                bridgeRequest.receiver,
                request.toToken,
                bridgeAmount,
                bridgeRequest.dstChainId,
                bridgeRequest.nonce,
                bridgeRequest.maxSlippage);

            // event emission
            emit RangoBridgeInitiated(
                request.requestId,
                request.toToken,
                bridgeAmount,
                bridgeRequest.receiver,
                "",
                bridgeRequest.dstChainId,
                false,
                false,
                uint8(BridgeType.CBridge),
                request.dAppTag
            );
        } else {
            Interchain.RangoInterChainMessage memory imMessage = abi.decode((bridgeRequest.imMessage), (Interchain.RangoInterChainMessage));
            RangoCBridgeMiddleware(middleware).doCBridgeIM{value : value}(
                request.toToken,
                bridgeAmount,
                bridgeRequest.receiver,
                bridgeRequest.dstChainId,
                bridgeRequest.nonce,
                bridgeRequest.maxSlippage,
                sgnFee,
                imMessage
            );

            // event emission
            emit RangoBridgeInitiated(
                request.requestId,
                request.toToken,
                bridgeAmount,
                bridgeRequest.receiver,
                keccak256(bridgeRequest.imMessage),
                bridgeRequest.dstChainId,
                true,
                imMessage.actionType != Interchain.ActionType.NO_ACTION,
                uint8(BridgeType.CBridge),
                request.dAppTag
            );
        }
    }

    /// @notice Executes a DEX (arbitrary) call + a cBridge send function

    /// @dev The cbridge part is handled in the RangoCBridgeMiddleware contract
    /// @dev If this function is success, user will automatically receive the fund in the destination in his/her wallet (receiver)
    /// @dev If bridge is out of liquidity somehow after submiting this transaction and success, user must sign a refund transaction which is not currently present here, will be supported later
    function cBridgeBridge(
        RangoBridgeRequest memory request,
        CBridgeBridgeRequest calldata bridgeRequest
    ) external payable nonReentrant {
        address payable middleware = getCBridgeStorage().rangoCBridgeMiddlewareAddress;
        require(middleware != LibSwapper.ETH, "Middleware not set");
        // transfer tokens to middleware if necessary
        uint amount = request.amount;
        uint sumFees = LibSwapper.sumFees(request);
        uint value = bridgeRequest.sgnFee;
        if (request.token == LibSwapper.ETH) {
            require(msg.value >= amount + bridgeRequest.sgnFee + sumFees, "Insufficient ETH");
            value = amount + bridgeRequest.sgnFee;
        } else {
            // To save gas we dont transfer to this contract, instead we directly transfer from user to middleware.
            // Note we only send the amount to middleware (doesn't include fees)
            SafeERC20.safeTransferFrom(IERC20(request.token), msg.sender, middleware, amount);
            require(msg.value >= value, "Insufficient ETH");
        }

        // collect fees directly from sender
        LibSwapper.collectFeesFromSender(request);

        if (bridgeRequest.bridgeType == CBridgeBridgeType.TRANSFER) {
            RangoCBridgeMiddleware(middleware).doSend{value : value}(
                bridgeRequest.receiver,
                request.token,
                amount,
                bridgeRequest.dstChainId,
                bridgeRequest.nonce,
                bridgeRequest.maxSlippage);

            // event emission
            emit RangoBridgeInitiated(
                request.requestId,
                request.token,
                amount,
                bridgeRequest.receiver,
                "",
                bridgeRequest.dstChainId,
                false,
                false,
                uint8(BridgeType.CBridge),
                request.dAppTag
            );
        } else {
            Interchain.RangoInterChainMessage memory imMessage = abi.decode((bridgeRequest.imMessage), (Interchain.RangoInterChainMessage));
            RangoCBridgeMiddleware(middleware).doCBridgeIM{value : value}(
                request.token,
                amount,
                bridgeRequest.receiver,
                bridgeRequest.dstChainId,
                bridgeRequest.nonce,
                bridgeRequest.maxSlippage,
                bridgeRequest.sgnFee,
                imMessage
            );

            // event emission
            emit RangoBridgeInitiated(
                request.requestId,
                request.token,
                amount,
                bridgeRequest.receiver,
                keccak256(bridgeRequest.imMessage),
                bridgeRequest.dstChainId,
                true,
                imMessage.actionType != Interchain.ActionType.NO_ACTION,
                uint8(BridgeType.CBridge),
                request.dAppTag
            );
        }
    }

    function updateRangoCBridgeMiddlewareAddressInternal(address payable newAddress) private {
        cBridgeStorage storage s = getCBridgeStorage();

        address oldAddress = getRangoCBridgeMiddlewareAddress();
        s.rangoCBridgeMiddlewareAddress = newAddress;

        emit RangoCBridgeMiddlewareAddressUpdated(oldAddress, newAddress);
    }

    function getRangoCBridgeMiddlewareAddress() internal view returns (address) {
        cBridgeStorage storage s = getCBridgeStorage();
        return s.rangoCBridgeMiddlewareAddress;
    }

    /// @dev fetch local storage
    function getCBridgeStorage() private pure returns (cBridgeStorage storage s) {
        bytes32 namespace = CBRIDGE_NAMESPACE;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            s.slot := namespace
        }
    }
}

// File: contracts/facets/bridges/cbridge/RangoCBridgeMiddleware.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "./im/message/framework/MessageReceiverApp.sol";
import "./im/message/framework/MessageSenderApp.sol";
import "../../../libraries/LibInterchain.sol";
import "../../../utils/ReentrancyGuard.sol";
import "../../base/RangoAccessManagerFacet.sol";
import "../../base/RangoInterchainFacet.sol";
import "../../base/RangoBaseInterchainMiddleware.sol";

/// @title The middleware contract that handles Rango's interaction with cBridge.
/// @author George
/// @dev this contract works directly with cBridge and messagebus.
///      Note that this is not a facet and should be deployed separately.
contract RangoCBridgeMiddleware is RangoBaseInterchainMiddleware, IRango, MessageSenderApp, MessageReceiverApp, ReentrancyGuard {

    /// @dev keccak256("exchange.rango.middleware.cbridge")
    bytes32 internal constant CBIRDGE_MIDDLEWARE_NAMESPACE = hex"2ba094f4e7908864b6d0bf1b955a13285820ecdae1501be90101739a37f73d34";

    struct RangoCBridgeMiddlewareStorage {
        address cBridgeAddress;
        address rangoDiamond;
    }

    constructor(
        address _owner,
        address _cBridgeAddress,
        address _cBridgeMessageBusAddress,
        address _rangoDiamond,
        address _weth
    ) RangoBaseInterchainMiddleware(_owner, _rangoDiamond, _weth){
        updateCBridgeAddressInternal(_cBridgeAddress);
        setMessageBusInternal(_cBridgeMessageBusAddress);
    }

    /// Events

    /// @notice Emits when the cBridge address is updated
    /// @param oldAddress The previous address
    /// @param newAddress The new address
    event CBridgeAddressUpdated(address oldAddress, address newAddress);
    /// @notice A series of events with different status value to help us track the progress of cross-chain swap
    /// @param id The transferId generated by cBridge
    /// @param token The token address in the current network that is being bridged
    /// @param outputAmount The latest observed amount in the path, aka: input amount for source and output amount on dest
    /// @param destination The destination address that received the money, ZERO address if not sent to the end-user yet
    event CBridgeIMStatusUpdated(bytes32 id, address token, uint256 outputAmount, IRango.CrossChainOperationStatus status, address destination);
    /// @notice A simple cBridge.send scenario
    /// @param receiver The wallet address of receiver on the destination
    /// @param token The address of token on the source chain
    /// @param amount The input amount sent to the bridge
    /// @param dstChainId The network id of destination chain
    /// @param nonce A nonce mechanism used by cBridge that is generated off-chain, it normally is the time.now()
    /// @param maxSlippage The maximum tolerable slippage by user on cBridge side (The bridge is not 1-1 and may have slippage in big swaps)
    event CBridgeSend(address receiver, address token, uint256 amount, uint64 dstChainId, uint64 nonce, uint32 maxSlippage);

    /// Administration & Control

    /// @notice Updates the address of cBridge contract
    /// @param newAddress The new address of cBridge contract
    function updateCBridgeAddress(address newAddress) external onlyOwner {
        updateCBridgeAddressInternal(newAddress);
    }
    /// @notice Updates the address of messageBus
    /// @param _messageBus The new address of messageBus
    function setMessageBus(address _messageBus) external onlyOwner {
        setMessageBusInternal(_messageBus);
    }

    /// @inheritdoc IMessageReceiverApp
    /// @dev We also send a message to dApp if dAppMessage is valid
    /// @dev We refund the money back to the message.originalSender which is the source wallet address or any wallet that dapp likes to be receiver of the refund
    function executeMessageWithTransferRefund(
        address token,
        uint256 amount,
        bytes calldata message,
        address // executor
    ) external payable override onlyMessageBus nonReentrant returns (ExecutionStatus) {
        Interchain.RangoInterChainMessage memory m = abi.decode((message), (Interchain.RangoInterChainMessage));

        LibSwapper.BaseSwapperStorage storage baseStorage = LibSwapper.getBaseSwapperStorage();
        address fromToken = token;
        if (token == baseStorage.WETH) {
            if (IERC20(token).balanceOf(address(this)) < amount) {
                if (address(this).balance >= amount) {
                    fromToken = LibSwapper.ETH;
                } else {
                    revert("Neither WETH nor ETH were found on contract");
                }
            }
        }

        LibInterchain._sendTokenWithDApp(
            fromToken,
            amount,
            m.originalSender,
            m.dAppMessage,
            m.dAppSourceContract,
            IRangoMessageReceiver.ProcessStatus.REFUND_IN_SOURCE
        );

        bytes32 id = computeSwapRequestId(m.originalSender, uint64(block.chainid), m.dstChainId, message);
        emit CBridgeIMStatusUpdated(id, fromToken, amount, IRango.CrossChainOperationStatus.RefundInSource, m.originalSender);
        emit RangoBridgeCompleted(
            m.requestId,
            fromToken,
            m.originalSender,
            m.recipient,
            amount,
            IRango.CrossChainOperationStatus.RefundInSource,
            m.dAppTag
        );
        return ExecutionStatus.Success;
    }

    /// @inheritdoc IMessageReceiverApp
    /**
     * @dev If our message contains a uniswap-like DEX call on the destination we also perform it here
     * There are also some flags such as:
     * 1. message.bridgeNativeOut which indicates that bridge sent native token to us, so we unwrap it if required
     * 2. message.nativeOut which indicates that we should send native token to end-user/dapp so we unwrap it if needed
     */
    function executeMessageWithTransfer(
        address, // sender
        address token,
        uint256 amount,
        uint64 srcChainId,
        bytes memory message,
        address // executor
    ) external payable override onlyMessageBus nonReentrant returns (ExecutionStatus) {
        Interchain.RangoInterChainMessage memory m = abi.decode((message), (Interchain.RangoInterChainMessage));
        bytes32 id = computeSwapRequestId(m.originalSender, srcChainId, uint64(block.chainid), message);

        (address receivedToken, uint dstAmount, IRango.CrossChainOperationStatus status) = LibInterchain.handleDestinationMessage(token, amount, m);

        emit CBridgeIMStatusUpdated(id, receivedToken, dstAmount, status, m.recipient);
        emit RangoBridgeCompleted(
            m.requestId,
            receivedToken,
            m.originalSender,
            m.recipient,
            dstAmount,
            status,
            m.dAppTag
        );
        // always return success since swap failure is already handled in-place
        return ExecutionStatus.Success;
    }

    /// @inheritdoc IMessageReceiverApp
    /// @dev In case of failure in the destination, we only send money to the end-user in the destination
    function executeMessageWithTransferFallback(
        address, // sender
        address token, // token
        uint256 amount, // amount
        uint64 srcChainId,
        bytes memory message,
        address // executor
    ) external payable override onlyMessageBus nonReentrant returns (ExecutionStatus) {
        Interchain.RangoInterChainMessage memory m = abi.decode((message), (Interchain.RangoInterChainMessage));
        LibSwapper.BaseSwapperStorage storage baseStorage = LibSwapper.getBaseSwapperStorage();

        bytes32 id = computeSwapRequestId(m.originalSender, srcChainId, uint64(block.chainid), message);
        address sourceToken = m.bridgeRealOutput == LibSwapper.ETH && token == baseStorage.WETH ? LibSwapper.ETH : token;

        LibInterchain._sendTokenWithDApp(
            sourceToken,
            amount,
            m.originalSender,
            m.dAppMessage,
            m.dAppSourceContract,
            IRangoMessageReceiver.ProcessStatus.REFUND_IN_DESTINATION
        );

        emit CBridgeIMStatusUpdated(id, token, amount, IRango.CrossChainOperationStatus.RefundInDestination, m.originalSender);
        emit RangoBridgeCompleted(
            m.requestId,
            token,
            m.originalSender,
            m.recipient,
            amount,
            IRango.CrossChainOperationStatus.RefundInDestination,
            m.dAppTag
        );
        return ExecutionStatus.Fail;
    }

    /// @notice Computes the sgnFee for a given message based on messageBus formula
    /// @param imMessage The message that fee is computed for
    function computeCBridgeSgnFee(Interchain.RangoInterChainMessage memory imMessage) external view returns (uint) {
        bytes memory msgBytes = abi.encode(imMessage);
        return IMessageBus(getMsgBusAddress()).calcFee(msgBytes);
    }

    /// @notice Executes a bridging via cBridge
    /// @param receiver The receiver address in the destination chain
    /// @param token The token address to be bridged
    /// @param amount The amount of the token to be bridged
    /// @param dstChainId The network id of destination chain, ex: 10 for optimism
    /// @param nonce A nonce mechanism used by cBridge that is generated off-chain, it normally is the time.now()
    /// @param maxSlippage The maximum tolerable slippage by user on cBridge side (The bridge is not 1-1 and may have slippage in big swaps)
    function doSend(
        address receiver,
        address token,
        uint256 amount,
        uint64 dstChainId,
        uint64 nonce,
        uint32 maxSlippage
    ) external payable nonReentrant onlyDiamond {
        address cBridgeAddress = getRangoCBridgeMiddlewareStorage().cBridgeAddress;
        require(cBridgeAddress != LibSwapper.ETH, 'cBridge address not set');
        if (token != LibSwapper.ETH) {
            LibSwapper.approve(token, cBridgeAddress, amount);
            IBridge(cBridgeAddress).send(receiver, token, amount, dstChainId, nonce, maxSlippage);
        } else {
            IBridge(cBridgeAddress).sendNative{value : amount}(receiver, amount, dstChainId, nonce, maxSlippage);
        }
        emit CBridgeSend(receiver, token, amount, dstChainId, nonce, maxSlippage);
    }

    /// @notice Executes a cBridgeIM call
    /// @param fromToken The address of source token to bridge
    /// @param inputAmount The amount of input to be bridged
    /// @param receiverContract Our RangoCBridge.sol contract in the destination chain that will handle the destination logic
    /// @param dstChainId The network id of destination chain, ex: 10 for optimism
    /// @param nonce A nonce mechanism used by cBridge that is generated off-chain, it normally is the time.now()
    /// @param maxSlippage The maximum tolerable slippage by user on cBridge side (The bridge is not 1-1 and may have slippage in big swaps)
    /// @param sgnFee The fee amount (in native token) that cBridge IM charges for delivering the message
    /// @param imMessage Our custom interchain message that contains all the required info for the RangoCBridge.sol on the destination
    function doCBridgeIM(
        address fromToken,
        uint inputAmount,
        address receiverContract, // The receiver app contract address, not recipient
        uint64 dstChainId,
        uint64 nonce,
        uint32 maxSlippage,
        uint sgnFee,

        Interchain.RangoInterChainMessage memory imMessage
    ) external payable nonReentrant onlyDiamond {
        require(msg.value >= sgnFee, 'sgnFee is bigger than the input');
        address cBridgeAddress = getRangoCBridgeMiddlewareStorage().cBridgeAddress;
        address messageBus = getMsgBusAddress();

        require(messageBus != LibSwapper.ETH, 'cBridge message-bus address not set');
        require(cBridgeAddress != LibSwapper.ETH, 'cBridge address not set');
        require(imMessage.dstChainId == dstChainId, 'dstChainId and imMessage.dstChainId do not match');

        if (fromToken != LibSwapper.ETH)
            LibSwapper.approve(fromToken, cBridgeAddress, inputAmount);

        bytes memory message = abi.encode(imMessage);

        sendMessageWithTransfer(
            receiverContract,
            fromToken,
            inputAmount,
            dstChainId,
            nonce,
            maxSlippage,
            message,
            MsgDataTypes.BridgeSendType.Liquidity,
            sgnFee
        );
    }

    function updateCBridgeAddressInternal(address newAddress) private {
        RangoCBridgeMiddlewareStorage storage s = getRangoCBridgeMiddlewareStorage();
        address oldAddress = s.cBridgeAddress;
        s.cBridgeAddress = newAddress;
        emit CBridgeAddressUpdated(oldAddress, newAddress);
    }

    /// @notice Computes the transferId generated by cBridge
    /// @param sender The sender wallet or contract address
    /// @param srcChainId The network id of source
    /// @param dstChainId The network id of destination
    /// @param message The byte array message that Rango likes to transfer
    /// @return The bytes32 hash of all these information combined
    function computeSwapRequestId(
        address sender,
        uint64 srcChainId,
        uint64 dstChainId,
        bytes memory message
    ) private pure returns (bytes32) {
        return keccak256(abi.encodePacked(sender, srcChainId, dstChainId, message));
    }

    /// @dev fetch local storage
    function getRangoCBridgeMiddlewareStorage() private pure returns (RangoCBridgeMiddlewareStorage storage s) {
        bytes32 namespace = CBIRDGE_MIDDLEWARE_NAMESPACE;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            s.slot := namespace
        }
    }
}

// File: contracts/facets/bridges/RangoAcrossFacet.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "../../interfaces/IAcrossSpokePool.sol";
import "../../interfaces/IRangoAcross.sol";
import "../../interfaces/IRango.sol";
import "../../utils/ReentrancyGuard.sol";
import "../../libraries/LibSwapper.sol";
import "../../libraries/LibDiamond.sol";

/// @title The root contract that handles Rango's interaction with Across bridge
/// @author Thinking Particle & AMA
/// @dev This is deployed as a facet for RangoDiamond
contract RangoAcrossFacet is IRango, ReentrancyGuard, IRangoAcross {

    /// Storage ///

    /// @dev keccak256("exchange.rango.facets.across")
    bytes32 internal constant ACROSS_NAMESPACE = hex"4e63b982873f293633572d65fbc8b8e979949d7d2e57c548af3c9d5fc8844dbb";

    struct AcrossStorage {
        /// @notice List of whitelisted Across spoke pools in the current chain
        mapping(address => bool) acrossSpokePools;
        bytes acrossRewardBytes;
    }

    /// Events ///

    /// @notice Notifies that some new spoke pool addresses are whitelisted
    /// @param _addresses The newly whitelisted addresses
    event AcrossSpokePoolsAdded(address[] _addresses);
    /// @notice Notifies that reward bytes are updated
    /// @param rewardBytes The newly set rewardBytes
    event AcrossRewardBytesUpdated(bytes rewardBytes);
    /// @notice Notifies that some spoke pool addresses are blacklisted
    /// @param _addresses The addresses that are removed
    event AcrossSpokePoolsRemoved(address[] _addresses);

    /// Initialization ///

    /// @notice Initialize the contract.
    /// @param _addresses The contract address of the spoke pool on the source chain.
    /// @param acrossRewardBytes The rewardBytes passed to across pool
    function initAcross(address[] calldata _addresses, bytes calldata acrossRewardBytes) external {
        LibDiamond.enforceIsContractOwner();
        addAcrossSpokePoolsInternal(_addresses);
        setAcrossRewardBytesInternal(acrossRewardBytes);
    }

    /// @notice Enables the contract to receive native ETH token from other contracts including WETH contract
    receive() external payable {}

    /// @notice Adds a list of new addresses to the whitelisted Across spokePools
    /// @param _addresses The list of new routers
    function addAcrossSpokePools(address[] calldata _addresses) public {
        LibDiamond.enforceIsContractOwner();

        addAcrossSpokePoolsInternal(_addresses);
    }
    /// @notice Adds a list of new addresses to the whitelisted Across spokePools
    /// @param acrossRewardBytes The rewardBytes passed to across contract
    function setAcrossRewardBytes(bytes calldata acrossRewardBytes) public {
        LibDiamond.enforceIsContractOwner();
        setAcrossRewardBytesInternal(acrossRewardBytes);
    }

    /// @notice Removes a list of routers from the whitelisted addresses
    /// @param _addresses The list of addresses that should be deprecated
    function removeAcrossSpokePools(address[] calldata _addresses) external {
        LibDiamond.enforceIsContractOwner();
        AcrossStorage storage s = getAcrossStorage();
        for (uint i = 0; i < _addresses.length; i++) {
            delete s.acrossSpokePools[_addresses[i]];
        }

        emit AcrossSpokePoolsRemoved(_addresses);
    }

    /// @notice Executes a DEX (arbitrary) call + a Across bridge call
    /// @dev request.toToken can be address(0) for native deposits and will be replaced in doAcrossBridge
    /// @param request The general swap request containing from/to token and fee/affiliate rewards
    /// @param calls The list of DEX calls, if this list is empty, it means that there is no DEX call and we are only bridging
    /// @param bridgeRequest required data for the bridging step, including the destination chain and recipient wallet address
    function acrossSwapAndBridge(
        LibSwapper.SwapRequest memory request,
        LibSwapper.Call[] calldata calls,
        AcrossBridgeRequest memory bridgeRequest
    ) external payable nonReentrant {
        uint out = LibSwapper.onChainSwapsPreBridge(request, calls, 0);
        if (request.toToken != LibSwapper.ETH)
            LibSwapper.approve(request.toToken, bridgeRequest.spokePoolAddress, out);
        doAcrossBridge(bridgeRequest, request.toToken, out);
        // event emission
        emit RangoBridgeInitiated(request.requestId,
            request.toToken,
            out,
            bridgeRequest.recipient,
            "",
            bridgeRequest.destinationChainId,
            false,
            false,
            uint8(BridgeType.Across),
            request.dAppTag);
    }

    /// @notice starts bridging through Across bridge
    /// @dev request.toToken can be address(0) for native deposits and will be replaced in doAcrossBridge
    function acrossBridge(
        AcrossBridgeRequest memory request,
        IRango.RangoBridgeRequest memory bridgeRequest
    ) external payable nonReentrant {
        uint amount = bridgeRequest.amount;
        address token = bridgeRequest.token;
        uint amountWithFee = amount + LibSwapper.sumFees(bridgeRequest);
        // transfer tokens if necessary
        if (token == LibSwapper.ETH) {
            require(
                msg.value >= amountWithFee, "Insufficient ETH sent for bridging and fees");
        } else {
            SafeERC20.safeTransferFrom(IERC20(token), msg.sender, address(this), amountWithFee);
            LibSwapper.approve(token, request.spokePoolAddress, amount);
        }
        LibSwapper.collectFees(bridgeRequest);
        doAcrossBridge(request, token, amount);

        // event emission
        emit RangoBridgeInitiated(
            bridgeRequest.requestId,
            token,
            amount,
            request.recipient,
            "",
            request.destinationChainId,
            false,
            false,
            uint8(BridgeType.Across),
            bridgeRequest.dAppTag
        );
    }

    /// @notice Executes an Across bridge call
    /// @dev bridgeRequest.originToken can be address(0) for native deposits
    /// @param request The other required fields for across bridge contract
    /// @param amount Amount of tokens to deposit. Will be amount of tokens to receive less fees.
    function doAcrossBridge(
        AcrossBridgeRequest memory request,
        address token,
        uint amount
    ) internal {
        AcrossStorage storage s = getAcrossStorage();
        require(s.acrossSpokePools[request.spokePoolAddress], "Requested spokePool address not whitelisted");
        address bridgeToken = token;
        if (token == LibSwapper.ETH) bridgeToken = LibSwapper.getBaseSwapperStorage().WETH;

        bytes memory acrossCallData = encodeWithSignature(
            request.recipient,
            bridgeToken,
            amount,
            request.destinationChainId,
            request.relayerFeePct,
            request.quoteTimestamp
        );

        bytes memory callData = concat(acrossCallData, s.acrossRewardBytes);

        (bool success, bytes memory ret) = request.spokePoolAddress.call{value : token == LibSwapper.ETH ? amount : 0}(callData);
        if (!success)
            revert(LibSwapper._getRevertMsg(ret));

    }

    function concat(bytes memory a, bytes memory b) internal pure returns (bytes memory) {
        return abi.encodePacked(a, b);
    }

    function encodeWithSignature(
        address recipient,
        address originToken,
        uint256 amount,
        uint256 destinationChainId,
        uint64 relayerFeePct,
        uint32 quoteTimestamp
    ) public pure returns (bytes memory) {
        return abi.encodeWithSignature("deposit(address,address,uint256,uint256,uint64,uint32)",
            recipient, originToken, amount, destinationChainId, relayerFeePct, quoteTimestamp
        );
    }

    function addAcrossSpokePoolsInternal(address[] calldata _addresses) private {
        AcrossStorage storage s = getAcrossStorage();

        for (uint i = 0; i < _addresses.length; i++) {
            s.acrossSpokePools[_addresses[i]] = true;
        }

        emit AcrossSpokePoolsAdded(_addresses);
    }

    function setAcrossRewardBytesInternal(bytes calldata acrossRewardBytes) private {
        AcrossStorage storage s = getAcrossStorage();
        s.acrossRewardBytes = acrossRewardBytes;
        emit AcrossRewardBytesUpdated(acrossRewardBytes);
    }

    /// @dev fetch local storage
    function getAcrossStorage() private pure returns (AcrossStorage storage s) {
        bytes32 namespace = ACROSS_NAMESPACE;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            s.slot := namespace
        }
    }

}

// File: contracts/facets/bridges/RangoAllBridgeFacet.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "../../interfaces/IRango.sol";
import "../../utils/LibTransform.sol";
import "../../utils/ReentrancyGuard.sol";
import "../../libraries/LibDiamond.sol";
import "../../libraries/LibSwapper.sol";
import "../../interfaces/IAllBridgeRouter.sol";
import "../../interfaces/IRangoAllBridge.sol";

/// @title The root contract that handles Rango's interaction with allbridge
/// @author George
/// @dev This facet should be added to diamond.
contract RangoAllBridgeFacet is IRango, ReentrancyGuard, IRangoAllBridge {
    /// Storage ///
    /// @dev keccak256("exchange.rango.facets.allbridge")
    bytes32 internal constant ALLBRIDGE_NAMESPACE = hex"ca7499307d2f8158acd5d48318ce24f77c0ef835d9c609fad6ea61d3bb4728d7";

    struct AllBridgeStorage {
        /// @notice The address of AllBridge contract on this chain
        address bridgeAddress;
    }

    /// @notice Emitted when the ALlBridge bridge address is updated
    /// @param _oldAddress The previous bridge contract
    /// @param _newAddress The new bridge contract
    event AllBridgeBridgeAddressUpdated(address _oldAddress, address _newAddress);

    /// @notice Updates the address of ALlBridge bridge contract
    /// @param _address The new address of ALlBridge bridge contract
    function updateAllBridgeBridgeAddress(address _address) public {
        LibDiamond.enforceIsContractOwner();
        updateAllBridgeBridgeAddressInternal(_address);
    }

    /// @notice Executes a DEX (arbitrary) call + a AllBridge bridge call
    /// @param request The general swap request containing from/to token and fee/affiliate rewards
    /// @param calls The list of DEX calls, if this list is empty, it means that there is no DEX call and we are only bridging
    /// @param bridgeRequest required data for the bridging step, including the destination chain and recipient wallet address
    function allbridgeSwapAndBridge(
        LibSwapper.SwapRequest memory request,
        LibSwapper.Call[] calldata calls,
        AllBridgeRequest memory bridgeRequest
    ) external payable nonReentrant {
        uint out = LibSwapper.onChainSwapsPreBridge(request, calls, bridgeRequest.transferFee);

        doAllBridgeBridge(bridgeRequest, request.toToken, out);
        // event emission
        emit RangoBridgeInitiated(
            request.requestId,
            request.toToken,
            out,
            LibTransform.bytes32LeftPaddedToAddress(bridgeRequest.recipient),
            "",
            bridgeRequest.destinationChainId,
            false,
            false,
            uint8(BridgeType.AllBridge),
            request.dAppTag
        );
    }

    /// @notice Executes a bridging via allbridge
    /// @param request The extra fields required by the allbridge
    function allbridgeBridge(
        AllBridgeRequest memory request,
        RangoBridgeRequest memory bridgeRequest
    ) external payable nonReentrant {
        uint amount = bridgeRequest.amount;
        address token = bridgeRequest.token;
        uint amountWithFee = amount + LibSwapper.sumFees(bridgeRequest);
        // transfer tokens if necessary
        if (token != LibSwapper.ETH) {
            SafeERC20.safeTransferFrom(IERC20(token), msg.sender, address(this), amountWithFee);
            require(msg.value >= request.transferFee);
        } else {
            require(msg.value >= amountWithFee);
        }
        LibSwapper.collectFees(bridgeRequest);
        doAllBridgeBridge(request, token, amount);
        // event emission
        emit RangoBridgeInitiated(
            bridgeRequest.requestId,
            token,
            amount,
            LibTransform.bytes32LeftPaddedToAddress(request.recipient),
            "",
            request.destinationChainId,
            false,
            false,
            uint8(BridgeType.AllBridge),
            bridgeRequest.dAppTag
        );
    }

    /// @notice Executes a bridging via allBridge
    /// @param request The extra fields required by the allbridge
    /// @param token The requested token to bridge
    /// @param amount The requested amount to bridge
    function doAllBridgeBridge(
        AllBridgeRequest memory request,
        address token,
        uint256 amount
    ) internal {
        AllBridgeStorage storage s = getAllBridgeStorage();
        require(s.bridgeAddress != LibSwapper.ETH, 'AllBridge bridge address not set');
        require(token != LibSwapper.ETH, 'native token bridging not implemented');

        IAllBridgeRouter bridge = IAllBridgeRouter(s.bridgeAddress);
        // get the pool address and approve for it
        bytes32 tokenAddressLeftPadded = LibTransform.addressToBytes32LeftPadded(token);

        address poolAddress = bridge.pools(tokenAddressLeftPadded);
        require(poolAddress != LibSwapper.ETH, 'PoolAddress does not exist');
        LibSwapper.approve(token, poolAddress, amount);

        bridge.swapAndBridge{value : request.transferFee}(
            tokenAddressLeftPadded,
            amount,
            request.recipient,
            request.destinationChainId,
            request.receiveTokenAddress,
            request.nonce,
            request.messenger
        );

    }

    function updateAllBridgeBridgeAddressInternal(address _address) private {
        AllBridgeStorage storage s = getAllBridgeStorage();
        address oldAddress = s.bridgeAddress;
        s.bridgeAddress = _address;
        emit AllBridgeBridgeAddressUpdated(oldAddress, _address);
    }

    /// @dev fetch local storage
    function getAllBridgeStorage() private pure returns (AllBridgeStorage storage s) {
        bytes32 namespace = ALLBRIDGE_NAMESPACE;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            s.slot := namespace
        }
    }
}

// File: contracts/facets/bridges/RangoArbitrumBridgeFacet.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "../../interfaces/IRango.sol";
import "../../interfaces/IRangoArbitrum.sol";
import "../../interfaces/IArbitrumBridgeInbox.sol";
import "../../interfaces/IArbitrumBridgeRouter.sol";
import "../../utils/ReentrancyGuard.sol";
import "../../libraries/LibSwapper.sol";
import "../../libraries/LibDiamond.sol";

/// @title The root contract that handles Rango's interaction with Arbitrum bridge
/// @author AMA
contract RangoArbitrumBridgeFacet is IRango, ReentrancyGuard, IRangoArbitrum {

    /// @dev keccak256("exchange.rango.facets.arbitrum")
    bytes32 internal constant ARBITRUM_NAMESPACE = hex"7d1b09bbce5c043a71c87365772180eb27aa885a0961d4a3dbf28dad7b428352";

    struct ArbitrumBridgeStorage {
        address inbox;
        address router;
    }

    /// @notice Notifies that some change(s) happened to arbitrum addresses
    /// @param oldInboxAddress The old inbox address
    /// @param oldRouterAddress The old router ddress
    /// @param newInboxAddress The newly inbox address
    /// @param newRouterAddress The newly router ddress
    event ArbitrumBridgeAddressChanged(address oldInboxAddress, address oldRouterAddress, address newInboxAddress, address newRouterAddress);

    /// @notice Notifies that arbitrum bridge started
    /// @param router The router addess
    /// @param recipient The receiver of funds
    /// @param token The input token of the bridge
    /// @param amount The amount that should be bridged
    event ArbitrumBridgeRouterCalled(address router, address recipient, address token, uint256 amount);

    /// @notice Initialize the contract.
    /// @param inboxAddress The new address of inbox
    /// @param routerAddress The new address of router
    function initArbitrum(address inboxAddress, address routerAddress) external {
        LibDiamond.enforceIsContractOwner();
        changeArbitrumAddressInternal(inboxAddress, routerAddress);
    }

    /// @notice Changes the configured Arbitrum bridge address
    /// @param inboxAddress The new address of inbox
    /// @param routerAddress The new address of router
    function changeArbitrumAddresses(address inboxAddress, address routerAddress) public {
        LibDiamond.enforceIsContractOwner();
        changeArbitrumAddressInternal(inboxAddress, routerAddress);
    }

    /// @notice Executes a DEX (arbitrary) call + a arbitrum bridge call
    /// @param request The general swap request containing from/to token and fee/affiliate rewards
    /// @param calls The list of DEX calls, if this list is empty, it means that there is no DEX call and we are only bridging
    /// @param bridgeRequest required data for the bridging step, including the destination chain and recipient wallet address
    function arbitrumSwapAndBridge(
        LibSwapper.SwapRequest memory request,
        LibSwapper.Call[] calldata calls,
        IRangoArbitrum.ArbitrumBridgeRequest memory bridgeRequest
    ) external payable nonReentrant {
        uint out;
        uint bridgeAmount;
        // if toToken is native coin and the user has not paid fee in msg.value,
        // then the user can pay bridge fee using output of swap.
        if (request.toToken == LibSwapper.ETH && msg.value == 0) {
            out = LibSwapper.onChainSwapsPreBridge(request, calls, 0);
            bridgeAmount = out - bridgeRequest.cost;
        }
        else {
            out = LibSwapper.onChainSwapsPreBridge(request, calls, bridgeRequest.cost);
            bridgeAmount = out;
        }
        doArbitrumBridge(bridgeRequest, request.toToken, bridgeAmount);

        // event emission
        emit RangoBridgeInitiated(
            request.requestId,
            request.toToken,
            out,
            bridgeRequest.receiver,
            "",
            42161,
            false,
            false,
            uint8(BridgeType.Hop),
            request.dAppTag
        );
    }

    /// @notice Executes a DEX (arbitrary) call + a arbitrum bridge call
    /// @param bridgeRequest required data for the bridging
    function arbitrumBridge(
        IRangoArbitrum.ArbitrumBridgeRequest memory request,
        RangoBridgeRequest memory bridgeRequest
    ) external payable nonReentrant {
        uint256 amount = bridgeRequest.amount + LibSwapper.sumFees(bridgeRequest);
        // transfer tokens & check inputs if necessary
        if (bridgeRequest.token == LibSwapper.ETH) {
            require(msg.value >= amount + request.cost, "Insufficient ETH sent for bridging");
        } else {
            require(msg.value >= request.cost, "Insufficient ETH sent for fee payment");
            SafeERC20.safeTransferFrom(IERC20(bridgeRequest.token), msg.sender, address(this), bridgeRequest.amount);
        }

        LibSwapper.collectFees(bridgeRequest);
        doArbitrumBridge(request, bridgeRequest.token, bridgeRequest.amount);

        // event emission
        emit RangoBridgeInitiated(
            bridgeRequest.requestId,
            bridgeRequest.token,
            bridgeRequest.amount,
            request.receiver,
            "",
            42161,
            false,
            false,
            uint8(BridgeType.ArbitrumBridge),
            bridgeRequest.dAppTag
        );
    }


    /// @notice Executes a Arbitrum bridge call
    /// @param request The request object containing required field by arbitrum bridge
    /// @param fromToken The token to be bridged
    /// @param amount The amount to be bridged
    function doArbitrumBridge(
        IRangoArbitrum.ArbitrumBridgeRequest memory request,
        address fromToken,
        uint amount
    ) internal {
        ArbitrumBridgeStorage storage s = getArbitrumBridgeStorage();
        if (fromToken == LibSwapper.ETH) {
            IArbitrumBridgeInbox(s.inbox).unsafeCreateRetryableTicket{value : amount + request.cost}(
                request.receiver,
                amount,
                request.maxSubmissionCost,
                request.receiver,
                request.receiver,
                request.maxGas,
                request.maxGasPrice,
                ""
            );
            emit ArbitrumBridgeRouterCalled(s.inbox, request.receiver, fromToken, amount);
        } else {
            address gatewayAddr = IArbitrumBridgeRouter(s.router).getGateway(fromToken);
            LibSwapper.approve(fromToken, gatewayAddr, amount);
            IArbitrumBridgeRouter(s.router).outboundTransfer{value : request.cost}(
                fromToken,
                request.receiver,
                amount,
                request.maxGas,
                request.maxGasPrice,
                abi.encode(request.maxSubmissionCost, "")
            );
            emit ArbitrumBridgeRouterCalled(s.router, request.receiver, fromToken, amount);
        }
    }

    function changeArbitrumAddressInternal(address inboxAddress, address routerAddress) private {
        ArbitrumBridgeStorage storage s = getArbitrumBridgeStorage();
        address oldInboxAddress = s.inbox;
        address oldRouterAddress = s.router;
        s.inbox = inboxAddress;
        s.router = routerAddress;

        emit ArbitrumBridgeAddressChanged(oldInboxAddress, oldRouterAddress, inboxAddress, routerAddress);
    }

    /// @dev fetch local storage
    function getArbitrumBridgeStorage() private pure returns (ArbitrumBridgeStorage storage s) {
        bytes32 namespace = ARBITRUM_NAMESPACE;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            s.slot := namespace
        }
    }
}

// File: contracts/facets/bridges/RangoHopFacet.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "../../interfaces/IHop.sol";
import "../../interfaces/IRangoHop.sol";
import "../../interfaces/IRango.sol";
import "../../utils/ReentrancyGuard.sol";
import "../../libraries/LibSwapper.sol";
import "../../libraries/LibDiamond.sol";

/// @title The root contract that handles Rango's interaction with Hop bridge
/// @author Uchiha Sasuke
contract RangoHopFacet is IRango, ReentrancyGuard, IRangoHop {

    /// Storage ///
    /// @dev keccak256("exchange.rango.facets.hop")
    bytes32 internal constant HOP_NAMESPACE = hex"e55d91fd33507c47be7760850d08c4215f74dbd7bc3c006505d8961de648af93";

    struct HopStorage {
        /// @notice List of whitelisted Hop bridge addresses in the current chain
        mapping(address => bool) hopBridges;
    }

    /// @notice Notifies that some new hop bridge addresses are whitelisted
    /// @param _addresses The newly whitelisted addresses
    event HopBridgesAdded(address[] _addresses);

    /// @notice Notifies that some hop bridge addresses are blacklisted
    /// @param _addresses The addresses that are removed
    event HopBridgesRemoved(address[] _addresses);

    /// @notice An event showing that a Hop bridge call happened
    event HopBridgeSent(
        address bridgeAddress,
        HopActionType actionType,
        uint256 chainId,
        address recipient,
        uint256 amount,
        uint256 bonderFee,
        uint256 amountOutMin,
        uint256 deadline,
        uint256 destinationAmountOutMin,
        uint256 destinationDeadline,
        address relayer,
        uint256 relayerFee
    );

    /// Constructor ///

    /// @notice Initialize the contract.
    /// @param _addresses The contract address of the spoke pool on the source chain.
    function initHop(address[] calldata _addresses) external {
        LibDiamond.enforceIsContractOwner();
        addHopBridgesInternal(_addresses);
    }

    /// @notice Enables the contract to receive native ETH token from other contracts including WETH contract
    receive() external payable { }

    /// @notice Adds a list of new addresses to the whitelisted Hop bridges
    /// @param _addresses The list of new routers
    function addHopBridges(address[] calldata _addresses) public {
        LibDiamond.enforceIsContractOwner();
        addHopBridgesInternal(_addresses);
    }

    /// @notice Removes a list of routers from the whitelisted addresses
    /// @param _addresses The list of addresses that should be deprecated
    function removeHopBridges(address[] calldata _addresses) external {
        LibDiamond.enforceIsContractOwner();
        HopStorage storage s = getHopStorage();

        for (uint i = 0; i < _addresses.length; i++) {
            delete s.hopBridges[_addresses[i]];
        }

        emit HopBridgesRemoved(_addresses);
    }

    /// @notice Executes a DEX (arbitrary) call + a Hop bridge call
    /// @param request The general swap request containing from/to token and fee/affiliate rewards
    /// @param calls The list of DEX calls, if this list is empty, it means that there is no DEX call and we are only bridging
    /// @param bridgeRequest required data for the bridging step, including the destination chain and recipient wallet address
    function hopSwapAndBridge(
        LibSwapper.SwapRequest memory request,
        LibSwapper.Call[] calldata calls,
        IRangoHop.HopRequest memory bridgeRequest
    ) external payable nonReentrant {
        uint out = LibSwapper.onChainSwapsPreBridge(request, calls, 0);
        if (request.toToken != LibSwapper.ETH) 
            LibSwapper.approve(request.toToken, bridgeRequest.bridgeAddress, out);
        doHopBridge(bridgeRequest, request.toToken, out);

        // event emission
        emit RangoBridgeInitiated(
            request.requestId,
            request.toToken,
            out,
            bridgeRequest.recipient,
            "",
            bridgeRequest.chainId,
            false,
            false,
            uint8(BridgeType.Hop),
            request.dAppTag
        );
    }

    /// @notice Executes a Hop bridge call
    /// @param request The request object containing required field by hop bridge
    function hopBridge(
        IRangoHop.HopRequest memory request,
        RangoBridgeRequest memory bridgeRequest
    ) external payable nonReentrant {
        HopStorage storage s = getHopStorage();
        uint256 amount = bridgeRequest.amount + LibSwapper.sumFees(bridgeRequest);
        // transfer tokens if necessary
        if (bridgeRequest.token == LibSwapper.ETH) {
            require(msg.value >= amount, "Insufficient ETH sent for bridging");
        } else {
            SafeERC20.safeTransferFrom(IERC20(bridgeRequest.token), msg.sender, address(this), amount);
            LibSwapper.approve(bridgeRequest.token, request.bridgeAddress, bridgeRequest.amount);
        }

        LibSwapper.collectFees(bridgeRequest);
        doHopBridge(request, bridgeRequest.token, bridgeRequest.amount);

        // event emission
        emit RangoBridgeInitiated(
            bridgeRequest.requestId,
            bridgeRequest.token,
            bridgeRequest.amount,
            request.recipient,
            "",
            request.chainId,
            false,
            false,
            uint8(BridgeType.Hop),
            bridgeRequest.dAppTag
        );
    }


    /// @notice Executes a Hop bridge call
    /// @param request The request object containing required field by hop bridge
    /// @param amount The amount to be bridged
    function doHopBridge(
        HopRequest memory request,
        address fromToken,
        uint amount
    ) internal {
        HopStorage storage s = getHopStorage();
        require(s.hopBridges[request.bridgeAddress], "Requested hop address not whitelisted");
        uint value = fromToken == LibSwapper.ETH ? amount : 0;
        
        IHop hop = IHop(request.bridgeAddress);
        if (request.actionType == HopActionType.SWAP_AND_SEND) {
            hop.swapAndSend{value: value}(
                request.chainId,
                request.recipient,
                amount,
                request.bonderFee,
                request.amountOutMin,
                request.deadline,
                request.destinationAmountOutMin,
                request.destinationDeadline
            );
        } else if (request.actionType == HopActionType.SEND_TO_L2) {
            hop.sendToL2{value: value}(
                request.chainId,
                request.recipient,
                amount,
                request.amountOutMin,
                request.deadline,
                request.relayer,
                request.relayerFee
            );
        }

        emitHopEvent(request, amount);
    }

    function emitHopEvent(HopRequest memory request, uint amount) private {
        emit HopBridgeSent(
            request.bridgeAddress,
            request.actionType,
            request.chainId,
            request.recipient,
            amount,
            request.bonderFee,
            request.amountOutMin,
            request.deadline,
            request.destinationAmountOutMin,
            request.destinationDeadline,
            request.relayer,
            request.relayerFee
        );
    }

    function addHopBridgesInternal(address[] calldata _addresses) private {
        HopStorage storage s = getHopStorage();
        for (uint i = 0; i < _addresses.length; i++) {
            s.hopBridges[_addresses[i]] = true;
        }

        emit HopBridgesAdded(_addresses);
    }

    /// @dev fetch local storage
    function getHopStorage() private pure returns (HopStorage storage s) {
        bytes32 namespace = HOP_NAMESPACE;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            s.slot := namespace
        }
    }
}

// File: contracts/facets/bridges/RangoHyphenFacet.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "../../interfaces/IWETH.sol";
import "../../interfaces/IRangoHyphen.sol";
import "../../interfaces/IRango.sol";
import "../../interfaces/IHyphenBridge.sol";
import "../../utils/ReentrancyGuard.sol";
import "../../libraries/LibSwapper.sol";
import "../../libraries/LibDiamond.sol";

/// @title The root contract that handles Rango's interaction with hyphen
/// @author Hellboy
contract RangoHyphenFacet is IRango, ReentrancyGuard, IRangoHyphen {

    /// Storage ///
    /// @dev keccak256("exchange.rango.facets.hyphen")
    bytes32 internal constant HYPHEN_NAMESPACE = hex"e55d91fd33507c47be7760850d08c4215f74dbd7bc3c006505d8961de648af93";

    struct HyphenStorage {
        /// @notice The address of hyphen contract
        address hyphenAddress;
    }

    /// @notice Emits when the hyphen address is updated
    /// @param _oldAddress The previous address
    /// @param _newAddress The new address
    event HyphenAddressUpdated(address _oldAddress, address _newAddress);

    /// @notice Initialize the contract.
    /// @param hyphenAddress The contract address of hyphen contract.
    function initHyphen(address hyphenAddress) external {
        LibDiamond.enforceIsContractOwner();
        updateHyphenAddressInternal(hyphenAddress);
    }

    /// @notice Updates the address of hyphen contract
    /// @param _address The new address of hyphen contract
    function updateHyphenAddress(address _address) public {
        LibDiamond.enforceIsContractOwner();
        updateHyphenAddressInternal(_address);
    }

    /// @notice Executes a DEX (arbitrary) call + a hyphen bridge function
    /// @param request The general swap request containing from/to token and fee/affiliate rewards
    /// @param calls The list of DEX calls, if this list is empty, it means that there is no DEX call and we are only bridging
    /// @param bridgeRequest data related to hyphen bridge
    /// @dev If this function is a success, user will automatically receive the fund in the destination in their wallet (receiver)
    function hyphenSwapAndBridge(
        LibSwapper.SwapRequest memory request,
        LibSwapper.Call[] calldata calls,
        IRangoHyphen.HyphenBridgeRequest memory bridgeRequest
    ) external payable nonReentrant {
        uint out = LibSwapper.onChainSwapsPreBridge(request, calls, 0);
        HyphenStorage storage s = getHyphenStorage();
        if (request.toToken != LibSwapper.ETH) 
            LibSwapper.approve(request.toToken, s.hyphenAddress, out);
        doHyphenBridge(bridgeRequest, request.toToken, out);

        // event emission
        emit RangoBridgeInitiated(
            request.requestId,
            request.toToken,
            out,
            bridgeRequest.receiver,
            "",
            bridgeRequest.toChainId,
            false,
            false,
            uint8(BridgeType.Hyphen),
            request.dAppTag
        );
    }

    /// @notice Executes a hyphen bridge function
    /// @param request The request object containing required field by hyphen bridge
    function hyphenBridge(
        IRangoHyphen.HyphenBridgeRequest memory request,
        RangoBridgeRequest memory bridgeRequest
    ) external payable nonReentrant {
        HyphenStorage storage s = getHyphenStorage();
        uint256 amount = bridgeRequest.amount + LibSwapper.sumFees(bridgeRequest);
        // transfer tokens if necessary
        if (bridgeRequest.token == LibSwapper.ETH) {
            require(msg.value >= amount, "Insufficient ETH sent for bridging");
        } else {
            SafeERC20.safeTransferFrom(IERC20(bridgeRequest.token), msg.sender, address(this), amount);
            LibSwapper.approve(bridgeRequest.token, s.hyphenAddress, bridgeRequest.amount);
        }
        LibSwapper.collectFees(bridgeRequest);
        doHyphenBridge(request, bridgeRequest.token, bridgeRequest.amount);

        // event emission
        emit RangoBridgeInitiated(
            bridgeRequest.requestId,
            bridgeRequest.token,
            bridgeRequest.amount,
            request.receiver,
            "",
            request.toChainId,
            false,
            false,
            uint8(BridgeType.Hyphen),
            bridgeRequest.dAppTag
        );
    }

    /// @notice Executes a bridging via hyphen
    /// @param request The extra fields required by the hyphen bridge
    /// @param token The requested token to bridge
    /// @param amount The requested amount to bridge
    function doHyphenBridge(
        HyphenBridgeRequest memory request,
        address token,
        uint256 amount
    ) internal {
        HyphenStorage storage s = getHyphenStorage();
        address receiver = request.receiver;
        uint dstChainId = request.toChainId;

        require(s.hyphenAddress != LibSwapper.ETH, 'Hyphen address not set');
        require(block.chainid != dstChainId, 'Cannot bridge to the same network');

        if (token == LibSwapper.ETH) {
            IHyphenBridge(s.hyphenAddress).depositNative{ value: amount }(receiver, dstChainId, "Rango");
        } else{
            IHyphenBridge(s.hyphenAddress).depositErc20(dstChainId, token, receiver, amount, "Rango");
        }
    }

    function updateHyphenAddressInternal(address _address) private {
        HyphenStorage storage s = getHyphenStorage();
        address oldAddress = s.hyphenAddress;
        s.hyphenAddress = _address;
        emit HyphenAddressUpdated(oldAddress, _address);
    }

    /// @dev fetch local storage
    function getHyphenStorage() private pure returns (HyphenStorage storage s) {
        bytes32 namespace = HYPHEN_NAMESPACE;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            s.slot := namespace
        }
    }
}

// File: contracts/facets/bridges/RangoMultichainFacet.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "../../interfaces/IRangoMultichain.sol";
import "../../interfaces/IRango.sol";
import "../../interfaces/IMultichainRouter.sol";
import "../../utils/ReentrancyGuard.sol";
import "../../utils/LibTransform.sol";
import "../../libraries/LibSwapper.sol";
import "../../libraries/LibDiamond.sol";
import "../../libraries/LibInterchain.sol";
import "../../interfaces/Interchain.sol";

/// @title The root contract that handles Rango's interaction with MultichainOrg bridge
/// @author George
contract RangoMultichainFacet is IRango, ReentrancyGuard, IRangoMultichain {

    /// Storage ///
    /// @dev keccak256("exchange.rango.facets.multichain")
    bytes32 internal constant MULTICHAIN_NAMESPACE = hex"13c8a23e4f93052e4f541b4dd19c72a5c4c1e8d163db3bede27c064fc6d5767c";

    struct MultichainStorage {
        /// @notice List of whitelisted MultichainOrg routers in the current chain
        mapping(address => bool) multichainRouters;
    }

    /// @notice Notifies that some new router addresses are whitelisted
    /// @param _addresses The newly whitelisted addresses
    event MultichainRoutersAdded(address[] _addresses);

    /// @notice Notifies that some router addresses are blacklisted
    /// @param _addresses The addresses that are removed
    event MultichainRoutersRemoved(address[] _addresses);

    /// @notice The constructor of this contract
    /// @param _routers The address of whitelist contracts for bridge routers
    function initMultichain(address[] calldata _routers) external {
        LibDiamond.enforceIsContractOwner();
        addMultichainRoutersInternal(_routers);
    }

    /// @notice Adds a list of new addresses to the whitelisted MultichainOrg routers
    /// @param routers The list of new routers
    function addMultichainRouters(address[] calldata routers) public {
        LibDiamond.enforceIsContractOwner();
        addMultichainRoutersInternal(routers);
    }

    /// @notice Removes a list of routers from the whitelisted addresses
    /// @param _routers The list of addresses that should be deprecated
    function removeMultichainRouters(address[] calldata _routers) external {
        LibDiamond.enforceIsContractOwner();
        MultichainStorage storage s = getMultichainStorage();
        for (uint i = 0; i < _routers.length; i++) {
            delete s.multichainRouters[_routers[i]];
        }
        emit MultichainRoutersRemoved(_routers);
    }

    /// Bridge functions

    /// @notice Executes a DEX (arbitrary) call + a MultichainOrg bridge call
    /// @param request The general swap request containing from/to token and fee/affiliate rewards
    /// @param calls The list of DEX calls, if this list is empty, it means that there is no DEX call and we are only bridging
    /// @param bridgeRequest required data for the bridging step, including the destination chain and recipient wallet address
    function multichainSwapAndBridge(
        LibSwapper.SwapRequest memory request,
        LibSwapper.Call[] calldata calls,
        IRangoMultichain.MultichainBridgeRequest memory bridgeRequest
    ) external payable nonReentrant {
        uint out = LibSwapper.onChainSwapsPreBridge(request, calls, 0);
        if (bridgeRequest.actionType == MultichainActionType.OUT_NATIVE) {
            require(request.toToken == LibSwapper.ETH, "token must be null");
        }
        if (bridgeRequest.bridgeType == MultichainBridgeType.TRANSFER) {
            doMultichainBridge(bridgeRequest, request.toToken, out);
            // event emission
            emit RangoBridgeInitiated(
                request.requestId,
                request.toToken,
                out,
                bridgeRequest.receiverAddress,
                "",
                bridgeRequest.receiverChainID,
                false,
                false,
                uint8(BridgeType.Multichain),
                request.dAppTag
            );
        } else {
            Interchain.RangoInterChainMessage memory imMessage = abi.decode((bridgeRequest.imMessage), (Interchain.RangoInterChainMessage));
            doMultichainBridgeAndAnyCall(bridgeRequest, request.toToken, out);
            // event emission
            emit RangoBridgeInitiated(
                request.requestId,
                request.toToken,
                out,
                bridgeRequest.receiverAddress,
                keccak256(bridgeRequest.imMessage),
                bridgeRequest.receiverChainID,
                true,
                imMessage.actionType != Interchain.ActionType.NO_ACTION,
                uint8(BridgeType.Multichain),
                request.dAppTag
            );
        }

    }

    /// @notice Executes a bridge through Multichain
    /// @param request The general swap request containing from/to token and fee/affiliate rewards
    /// @param bridgeRequest required data for the bridging step, including the destination chain and recipient wallet address
    function multichainBridge(
        IRangoMultichain.MultichainBridgeRequest memory request,
        RangoBridgeRequest memory bridgeRequest
    ) external payable nonReentrant {
        uint amount = bridgeRequest.amount;
        address token = bridgeRequest.token;
        uint amountWithFee = amount + LibSwapper.sumFees(bridgeRequest);
        if (token != LibSwapper.ETH) {
            SafeERC20.safeTransferFrom(IERC20(token), msg.sender, address(this), amountWithFee);
            LibSwapper.approve(token, request.multichainRouter, amount);
        } else {
            require(msg.value >= amountWithFee);
        }
        LibSwapper.collectFees(bridgeRequest);
        if (request.actionType == MultichainActionType.OUT_NATIVE) {
            require(msg.value >= amount, 'Insufficient ETH OUT_NATIVE');
        }
        if (request.bridgeType == MultichainBridgeType.TRANSFER) {
            doMultichainBridge(request, token, amount);
            // event emission
            emit RangoBridgeInitiated(
                bridgeRequest.requestId,
                token,
                amount,
                request.receiverAddress,
                "",
                request.receiverChainID,
                false,
                false,
                uint8(BridgeType.Multichain),
                bridgeRequest.dAppTag
            );
        } else {
            Interchain.RangoInterChainMessage memory imMessage = abi.decode((request.imMessage), (Interchain.RangoInterChainMessage));
            doMultichainBridgeAndAnyCall(request, token, amount);
            // event emission
            emit RangoBridgeInitiated(
                bridgeRequest.requestId,
                token,
                amount,
                request.receiverAddress,
                keccak256(request.imMessage),
                request.receiverChainID,
                true,
                imMessage.actionType != Interchain.ActionType.NO_ACTION,
                uint8(BridgeType.Multichain),
                bridgeRequest.dAppTag
            );
        }
    }

    /// @notice Executes a MultichainOrg bridge call
    /// @param fromToken The address of bridging token
    /// @param inputAmount The amount of the token to be bridged
    /// @param request The other required field by MultichainOrg bridge
    function doMultichainBridge(
        MultichainBridgeRequest memory request,
        address fromToken,
        uint inputAmount
    ) internal {
        MultichainStorage storage s = getMultichainStorage();
        require(s.multichainRouters[request.multichainRouter], 'Requested router address not whitelisted');

        if (request.actionType != MultichainActionType.OUT_NATIVE) {
            LibSwapper.approve(fromToken, request.multichainRouter, inputAmount);
        } else {
            require(fromToken == LibSwapper.ETH, 'invalid token');
        }

        IMultichainRouter router = IMultichainRouter(request.multichainRouter);

        if (request.actionType == MultichainActionType.OUT) {
            router.anySwapOut(request.underlyingToken, request.receiverAddress, inputAmount, request.receiverChainID);
        } else if (request.actionType == MultichainActionType.OUT_UNDERLYING) {
            router.anySwapOutUnderlying(request.underlyingToken, request.receiverAddress, inputAmount, request.receiverChainID);
        } else if (request.actionType == MultichainActionType.OUT_NATIVE) {
            router.anySwapOutNative{value : inputAmount}(request.underlyingToken, request.receiverAddress, request.receiverChainID);
        } else {
            revert();
        }
    }

    /// @notice Executes a MultichainOrg token bridge and call
    function doMultichainBridgeAndAnyCall(
        MultichainBridgeRequest memory request,
        address fromToken,
        uint inputAmount
    ) internal {
        MultichainStorage storage s = getMultichainStorage();
        require(s.multichainRouters[request.multichainRouter], 'router not allowed');

        if (request.actionType != MultichainActionType.OUT_NATIVE) {
            LibSwapper.approve(fromToken, request.multichainRouter, inputAmount);
        } else {
            require(fromToken == LibSwapper.ETH, 'invalid token');
        }

        IMultichainV7Router router = IMultichainV7Router(request.multichainRouter);

        if (request.actionType == MultichainActionType.OUT) {
            router.anySwapOutAndCall(
                request.underlyingToken,
                LibTransform.addressToString(request.receiverAddress),
                inputAmount,
                request.receiverChainID,
                request.anycallTargetContractOnDestChain,
                request.imMessage
            );
        } else if (request.actionType == MultichainActionType.OUT_UNDERLYING) {
            router.anySwapOutUnderlyingAndCall(
                request.underlyingToken,
                LibTransform.addressToString(request.receiverAddress),
                inputAmount,
                request.receiverChainID,
                request.anycallTargetContractOnDestChain,
                request.imMessage
            );
        } else if (request.actionType == MultichainActionType.OUT_NATIVE) {
            router.anySwapOutNativeAndCall{value : inputAmount}(
                request.underlyingToken,
                LibTransform.addressToString(request.receiverAddress),
                request.receiverChainID,
                request.anycallTargetContractOnDestChain,
                request.imMessage
            );
        } else {
            revert();
        }
    }

    function addMultichainRoutersInternal(address[] calldata _addresses) private {
        MultichainStorage storage s = getMultichainStorage();

        for (uint i = 0; i < _addresses.length; i++) {
            s.multichainRouters[_addresses[i]] = true;
        }

        emit MultichainRoutersAdded(_addresses);
    }

    /// @dev fetch local storage
    function getMultichainStorage() private pure returns (MultichainStorage storage s) {
        bytes32 namespace = MULTICHAIN_NAMESPACE;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            s.slot := namespace
        }
    }

}

// File: contracts/facets/bridges/RangoMultichainMiddleware.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "../../libraries/LibInterchain.sol";
import "../../utils/ReentrancyGuard.sol";
import "../base/RangoBaseInterchainMiddleware.sol";
import "../../interfaces/IMultichainRouter.sol";

/// @title The middleware contract that handles Rango's receive messages from Multichain.
/// @author George
/// @dev Note that this is not a facet and should be deployed separately.
contract RangoMultichainMiddleware is IRango, ReentrancyGuard, RangoBaseInterchainMiddleware, IAnycallProxy {

    /// @dev keccak256("exchange.rango.middleware.multichain")
    bytes32 internal constant MULTICHAIN_MIDDLEWARE_NAMESPACE = hex"0cf42af0773e60b292a649b87f9ceddb660d6e8bd489c0347d90c178f1d6ee6a";

    struct RangoMultichainMiddlewareStorage {
        /// @notice Addresses that can call exec on this contract
        mapping(address => bool) multichainExecutors;
    }

    constructor(
        address _owner,
        address _weth,
        address[] memory _executors
    ) RangoBaseInterchainMiddleware(_owner, address(0), _weth){
        if (_executors.length > 0)
            addMultichainExecutorsInternal(_executors);
    }

    /// Events
    /// @notice Notifies that some new router addresses are whitelisted
    /// @param _addresses The newly whitelisted addresses
    event MultichainExecutorsAdded(address[] _addresses);

    /// @notice Notifies that some router addresses are blacklisted
    /// @param _addresses The addresses that are removed
    event MultichainExecutorsRemoved(address[] _addresses);

    /// Only permit allowed executors
    modifier onlyAllowedExecutors(){
        require(getRangoMultichainMiddlewareStorage().multichainExecutors[msg.sender] == true, "not allowed");
        _;
    }

    /// External Functions
    /// @notice Adds a list of new addresses to the whitelisted MultichainOrg executors
    /// @param _executors The list of new executors
    function addMultichainExecutors(address[] memory _executors) public onlyOwner {
        addMultichainExecutorsInternal(_executors);
    }

    /// @notice Removes a list of executors from the whitelisted addresses
    /// @param _executors The list of addresses that should be deprecated
    function removeMultichainExecutors(address[] calldata _executors) external onlyOwner {
        removeMultichainExecutorsInternal(_executors);
    }


    /// @inheritdoc IAnycallProxy
    function exec(
        address token,
        address receiver,
        uint256 amount,
        bytes calldata data
    ) external nonReentrant onlyAllowedExecutors returns (bool success, bytes memory result){
        Interchain.RangoInterChainMessage memory m = abi.decode((data), (Interchain.RangoInterChainMessage));
        (address receivedToken, uint dstAmount, IRango.CrossChainOperationStatus status) = LibInterchain.handleDestinationMessage(token, amount, m);
        success = status == CrossChainOperationStatus.Succeeded;
        result = "";
        emit RangoBridgeCompleted(
            m.requestId,
            receivedToken,
            m.originalSender,
            m.recipient,
            dstAmount,
            status,
            m.dAppTag
        );
    }

    /// Private and Internal
    function addMultichainExecutorsInternal(address[] memory _executors) private {
        RangoMultichainMiddlewareStorage storage s = getRangoMultichainMiddlewareStorage();
        for (uint i = 0; i < _executors.length; i++) {
            s.multichainExecutors[_executors[i]] = true;
        }
        emit MultichainExecutorsAdded(_executors);
    }

    function removeMultichainExecutorsInternal(address[] calldata _executors) private {
        RangoMultichainMiddlewareStorage storage s = getRangoMultichainMiddlewareStorage();
        for (uint i = 0; i < _executors.length; i++) {
            delete s.multichainExecutors[_executors[i]];
        }
        emit MultichainExecutorsRemoved(_executors);
    }


    /// @dev fetch local storage
    function getRangoMultichainMiddlewareStorage() private pure returns (RangoMultichainMiddlewareStorage storage s) {
        bytes32 namespace = MULTICHAIN_MIDDLEWARE_NAMESPACE;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            s.slot := namespace
        }
    }
}

// File: contracts/facets/bridges/RangoOptimismBridgeFacet.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "../../interfaces/IRango.sol";
import "../../interfaces/IRangoOptimism.sol";
import "../../interfaces/IOptimismL1XBridge.sol";
import "../../utils/ReentrancyGuard.sol";
import "../../libraries/LibSwapper.sol";
import "../../libraries/LibDiamond.sol";

/// @title The root contract that handles Rango's interaction with Optimism bridge
/// @author AMA
contract RangoOptimismBridgeFacet is IRango, ReentrancyGuard, IRangoOptimism {

    /// @dev keccak256("exchange.rango.facets.optimism")
    bytes32 internal constant OPTIMISM_NAMESPACE = hex"d71013fddabd873f708e3a17329ab5776ce161122cfa59010e29f6c12070b69f";

    struct OptimismBridgeStorage {
        address standardBridgeAddress;
        mapping(address => address) tokenToBridgeAddresses;
    }

    struct OptimismBridgeInitData {
        address tokenAddress;
        address bridgeAddress;
    }

    /// @notice Notifies that some new optimism bridge addresses are whitelisted
    /// @param data The newly added bridge & token address
    event OptimismBridgesAdded(OptimismBridgeInitData[] data);

    /// @notice Notifies that some new optimism bridge addresses are whitelisted
    /// @param bridgeAddress The newly added standard bridge address
    event OptimismStandardBridgeAdded(address bridgeAddress);

    /// @notice Notifies that some optimism bridge addresses are blacklisted
    /// @param data The  bridge & token addresses that are removed
    event OptimismBridgesRemoved(OptimismBridgeInitData[] data);

    /// @notice Notifies that optimism bridge started
    /// @param bridge The bridge address
    /// @param recipient The receiver of funds
    /// @param token The input token of the bridge
    /// @param amount The amount that should be bridged
    event OptimismBridgeCalled(address bridge, address recipient, address token, uint256 amount, bool isSynth);

    /// @notice Initialize the contract.
    /// @param data The contract address of the L1Bridge/ERC20Bridge and associated token on the source chain.
    function initOptimism(OptimismBridgeInitData[] calldata data, address standardBridgeAddress) external {
        LibDiamond.enforceIsContractOwner();
        addOptimismBridgesInternal(data, standardBridgeAddress);
    }

    /// @notice Adds a list of new addresses to the whitelisted Optimism bridges
    /// @param data contract address of the L1Bridge/ERC20Bridge and associated token on the source chain.
    function addOptimismBridges(OptimismBridgeInitData[] calldata data, address standardBridgeAddress) public {
        LibDiamond.enforceIsContractOwner();
        addOptimismBridgesInternal(data, standardBridgeAddress);
    }

    /// @notice Removes a list of routers from the whitelisted addresses
    /// @param data The contract address of the L1Bridge/ERC20Bridge and associated token that should be deprecated.
    function removeOptimismBridges(OptimismBridgeInitData[] calldata data) external {
        LibDiamond.enforceIsContractOwner();

        OptimismBridgeStorage storage s = getOptimismBridgeStorage();
        for (uint i = 0; i < data.length; i++) {
            delete s.tokenToBridgeAddresses[data[i].tokenAddress];
        }

        emit OptimismBridgesRemoved(data);
    }

    /// @notice Executes a DEX (arbitrary) call + a Optimism bridge call
    /// @param request The general swap request containing from/to token and fee/affiliate rewards
    /// @param calls The list of DEX calls, if this list is empty, it means that there is no DEX call and we are only bridging
    /// @param bridgeRequest required data for the bridging step, including the destination chain and recipient wallet address
    function optimismSwapAndBridge(
        LibSwapper.SwapRequest memory request,
        LibSwapper.Call[] calldata calls,
        IRangoOptimism.OptimismBridgeRequest memory bridgeRequest
    ) external payable nonReentrant {
        uint out = LibSwapper.onChainSwapsPreBridge(request, calls, 0);

        doOptimismBridge(bridgeRequest, request.toToken, out);

        // event emission
        emit RangoBridgeInitiated(
            request.requestId,
            request.toToken,
            out,
            bridgeRequest.receiver,
            "",
            10,
            false,
            false,
            uint8(BridgeType.OptimismBridge),
            request.dAppTag
        );
    }

    /// @notice Executes a Arbitrum bridge call
    /// @param bridgeRequest The request object containing required field by arbitrum bridge
    function optimismBridge(
        IRangoOptimism.OptimismBridgeRequest memory request,
        RangoBridgeRequest memory bridgeRequest
    ) external payable nonReentrant {
        uint256 amount = bridgeRequest.amount + LibSwapper.sumFees(bridgeRequest);
        // transfer tokens & check inputs if necessary
        if (bridgeRequest.token == LibSwapper.ETH) {
            require(msg.value >= amount, "Insufficient ETH sent for bridging");
        } else {
            SafeERC20.safeTransferFrom(IERC20(bridgeRequest.token), msg.sender, address(this), bridgeRequest.amount);
        }

        LibSwapper.collectFees(bridgeRequest);
        doOptimismBridge(request, bridgeRequest.token, bridgeRequest.amount);

        // event emission
        emit RangoBridgeInitiated(
            bridgeRequest.requestId,
            bridgeRequest.token,
            bridgeRequest.amount,
            request.receiver,
            "",
            10,
            false,
            false,
            uint8(BridgeType.OptimismBridge),
            bridgeRequest.dAppTag
        );
    }

    /// @notice Executes a Optimism bridge call
    /// @param request The request object containing required field by Optimism bridge
    /// @param amount The amount to be bridged
    function doOptimismBridge(
        IRangoOptimism.OptimismBridgeRequest memory request,
        address fromToken,
        uint amount
    ) internal {
        OptimismBridgeStorage storage s = getOptimismBridgeStorage();
        address bridgeAddress = s.tokenToBridgeAddresses[fromToken] == address(0)
            ? s.standardBridgeAddress
            : s.tokenToBridgeAddresses[fromToken];
        IOptimismL1XBridge bridge = IOptimismL1XBridge(bridgeAddress);
            
        if (fromToken == LibSwapper.ETH) {
            bridge.depositETHTo{ value: amount }(request.receiver, request.l2Gas, "");
        } else {
            LibSwapper.approve(fromToken, bridgeAddress, amount);

            if (request.isSynth) {
                bridge.depositTo(request.receiver, amount);
            } else {
                bridge.depositERC20To(
                    fromToken,
                    request.l2TokenAddress,
                    request.receiver,
                    amount,
                    request.l2Gas,
                    ""
                );
            }
        }

        emit OptimismBridgeCalled(bridgeAddress, request.receiver, fromToken, amount, request.isSynth);
    }

    function addOptimismBridgesInternal(OptimismBridgeInitData[] calldata data, address standardBridgeAddress) private {
        OptimismBridgeStorage storage s = getOptimismBridgeStorage();
        for (uint i = 0; i < data.length; i++) {
            s.tokenToBridgeAddresses[data[i].tokenAddress] = data[i].bridgeAddress;
        }

        s.standardBridgeAddress = standardBridgeAddress;

        emit OptimismBridgesAdded(data);
        emit OptimismStandardBridgeAdded(standardBridgeAddress);
    }

    /// @dev fetch local storage
    function getOptimismBridgeStorage() private pure returns (OptimismBridgeStorage storage s) {
        bytes32 namespace = OPTIMISM_NAMESPACE;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            s.slot := namespace
        }
    }
}

// File: contracts/facets/bridges/RangoPolyFacet.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "../../interfaces/IWETH.sol";
import "../../interfaces/IRangoPoly.sol";
import "../../interfaces/IRango.sol";
import "../../interfaces/IPolyBridge.sol";
import "../../utils/ReentrancyGuard.sol";
import "../../libraries/LibSwapper.sol";
import "../../libraries/LibDiamond.sol";

/// @title The root contract that handles Rango's interaction with poly
/// @author AMA
contract RangoPolyFacet is IRango, ReentrancyGuard, IRangoPoly {

    /// Storage ///
    /// @dev keccak256("exchange.rango.facets.poly")
    bytes32 internal constant POLY_NAMESPACE = hex"dd09bd052dafcb281d30e61963e3b07fe83d05bbb2a522b1413909ef339380a7";

    struct PolyStorage {
        /// @notice The address of poly contract
        address polyWrapperAddress;
    }

    /// @notice Emits when the poly address is updated
    /// @param _oldAddress The previous address
    /// @param _newAddress The new address
    event PolyAddressUpdated(address _oldAddress, address _newAddress);

    /// @notice Initialize the contract.
    /// @param polyWrapperAddress The contract address of poly contract.
    function initPoly(address polyWrapperAddress) external {
        LibDiamond.enforceIsContractOwner();
        updatePolyAddressInternal(polyWrapperAddress);
    }

    /// @notice Updates the address of poly contract
    /// @param _address The new address of poly contract
    function updatePolyAddress(address _address) public {
        LibDiamond.enforceIsContractOwner();
        updatePolyAddressInternal(_address);
    }

    /// @notice Emits when an token (non-native) bridge request is sent to poly bridge
    /// @param dstChainId The network id of destination chain, ex: 56 for BSC
    /// @param token The requested token to bridge
    /// @param receiver The receiver address in the destination chain
    /// @param amount The requested amount to bridge
    /// @param fee The requested amount to pay for bridge fee
    event PolyDeposit(uint64 dstChainId, address token, address receiver, uint256 amount, uint256 fee);

    /// @notice Executes a DEX (arbitrary) call + a poly bridge function
    /// @param request The general swap request containing from/to token and fee/affiliate rewards
    /// @param calls The list of DEX calls, if this list is empty, it means that there is no DEX call and we are only bridging
    /// @param bridgeRequest data related to poly bridge
    /// @dev If this function is a success, user will automatically receive the fund in the destination in their wallet (receiver)
    function polySwapAndBridge(
        LibSwapper.SwapRequest memory request,
        LibSwapper.Call[] calldata calls,
        IRangoPoly.PolyBridgeRequest memory bridgeRequest
    ) external payable nonReentrant {
        uint out;
        uint bridgeAmount;

        // if toToken is native coin and the user has not paid fee in msg.value,
        // then the user can pay bridge fee using output of swap.
        if (request.toToken == LibSwapper.ETH && msg.value == 0) {
            out = LibSwapper.onChainSwapsPreBridge(request, calls, 0);
            bridgeAmount = out - bridgeRequest.fee;
        }
        else {
            out = LibSwapper.onChainSwapsPreBridge(request, calls, bridgeRequest.fee);
            bridgeAmount = out;
        }

        doPolyBridge(bridgeRequest, request.toToken, bridgeAmount);

        // event emission
        emit RangoBridgeInitiated(
            request.requestId,
            request.toToken,
            out,
            bridgeRequest.receiver,
            "",
            bridgeRequest.toChainId,
            false,
            false,
            uint8(BridgeType.Poly),
            request.dAppTag
        );
    }

    /// @notice Executes a poly bridge function
    /// @param request data related to poly bridge
    /// @param bridgeRequest data related to poly bridge
    function polyBridge(
        IRangoPoly.PolyBridgeRequest memory request,
        IRango.RangoBridgeRequest memory bridgeRequest
    ) external payable nonReentrant {
        uint256 amount = bridgeRequest.amount + LibSwapper.sumFees(bridgeRequest);
        // transfer tokens if necessary
        if (bridgeRequest.token == LibSwapper.ETH) {
            require(msg.value >= amount + request.fee, "Insufficient ETH sent for bridging");
        } else {
            require(msg.value >= request.fee, "Insufficient ETH sent for bridging");
            SafeERC20.safeTransferFrom(IERC20(bridgeRequest.token), msg.sender, address(this), bridgeRequest.amount);
        }

        LibSwapper.collectFees(bridgeRequest);
        doPolyBridge(request, bridgeRequest.token, amount);

        // event emission
        emit RangoBridgeInitiated(
            bridgeRequest.requestId,
            bridgeRequest.token,
            bridgeRequest.amount,
            request.receiver,
            "",
            request.toChainId,
            false,
            false,
            uint8(BridgeType.Poly),
            bridgeRequest.dAppTag
        );
    }

    /// @notice Executes a bridging via poly
    /// @param request The extra fields required by the poly bridge
    /// @param token The requested token to bridge
    /// @param amount The requested amount to bridge
    function doPolyBridge(
        PolyBridgeRequest memory request,
        address token,
        uint256 amount
    ) internal {
        PolyStorage storage s = getPolyStorage();
        bytes memory receiver = addressToBytes(request.receiver);
        uint64 dstChainId = request.toChainId;

        require(s.polyWrapperAddress != LibSwapper.ETH, 'Poly address not set');
        require(block.chainid != dstChainId, 'Cannot bridge to the same network');

        if (token == LibSwapper.ETH) {
            IPolyBridge(s.polyWrapperAddress).lock{ value: request.fee + amount }(
                token,
                dstChainId,
                receiver,
                amount,
                request.fee,
                request.id
            );
        } else{
            LibSwapper.approve(token, s.polyWrapperAddress, amount);
            IPolyBridge(s.polyWrapperAddress).lock{ value: request.fee }(
                token,
                dstChainId,
                receiver,
                amount,
                request.fee,
                request.id
            );
        }

        emit PolyDeposit(dstChainId, token, request.receiver, amount, request.fee);
    }

    /* @notice      Convert bytes to address
    *  @param _bs   Source bytes: bytes length must be 20
    *  @return      Converted address from source bytes
    */
    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)
    {
        require(_bs.length == 20, "bytes length does not match address");
        assembly {
            // for _bs, first word store _bs.length, second word store _bs.value
            // load 32 bytes from mem[_bs+20], convert it into Uint160, meaning we take last 20 bytes as addr (address).
            addr := mload(add(_bs, 0x14))
        }

    }

    /* @notice      Convert address to bytes
    *  @param _addr Address need to be converted
    *  @return      Converted bytes from address
    */
    function addressToBytes(address _addr) internal pure returns (bytes memory bs){
        assembly {
            // Get a location of some free memory and store it in result as
            // Solidity does for memory variables.
            bs := mload(0x40)
            // Put 20 (address byte length) at the first word, the length of bytes for uint256 value
            mstore(bs, 0x14)
            // logical shift left _a by 12 bytes, change _a from right-aligned to left-aligned
            mstore(add(bs, 0x20), shl(96, _addr))
            // Update the free-memory pointer by padding our last write location to 32 bytes
            mstore(0x40, add(bs, 0x40))
       }
    }

    function updatePolyAddressInternal(address _address) private {
        PolyStorage storage s = getPolyStorage();
        address oldAddress = s.polyWrapperAddress;
        s.polyWrapperAddress = _address;
        emit PolyAddressUpdated(oldAddress, _address);
    }

    /// @dev fetch local storage
    function getPolyStorage() private pure returns (PolyStorage storage s) {
        bytes32 namespace = POLY_NAMESPACE;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            s.slot := namespace
        }
    }
}

// File: contracts/facets/bridges/RangoSatelliteFacet.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "../../interfaces/IWETH.sol";
import "../../interfaces/IRangoSatellite.sol";
import "../../interfaces/IRango.sol";
import "../../interfaces/IAxelarGateway.sol";
import "../../interfaces/IAxelarGasService.sol";
import "../../interfaces/IUniswapV2.sol";
import "../../interfaces/IRangoMessageReceiver.sol";
import "../../interfaces/Interchain.sol";
import "../../libraries/LibInterchain.sol";
import "../../utils/LibTransform.sol";
import "../../utils/ReentrancyGuard.sol";
import "../../libraries/LibDiamond.sol";

/// @title The root contract that handles Rango's interaction with satellite
/// @author 0xiden
/// @dev This facet should be added to diamond. This facet doesn't and shouldn't receive messages. Handling messages is done through middleware.
contract RangoSatelliteFacet is IRango, ReentrancyGuard, IRangoSatellite {
    /// Storage ///
    /// @dev keccak256("exchange.rango.facets.satellite")
    bytes32 internal constant SATELLITE_NAMESPACE = hex"e97496d8273588711c444d166dc378e07de45d7ba4c6f83debe0eaef953c5a6f";

    struct SatelliteStorage {
        /// @notice The address of satellite contract
        address gatewayAddress;
        /// @notice The address of satellite gas service contract
        address gasService;
    }

    /// @notice Emitted when the satellite gateway address is updated
    /// @param _oldAddress The previous address
    /// @param _newAddress The new address
    event SatelliteGatewayAddressUpdated(address _oldAddress, address _newAddress);

    /// @notice Emitted when the satellite gasService address is updated
    /// @param _oldAddress The previous address
    /// @param _newAddress The new address
    event SatelliteGasServiceAddressUpdated(address _oldAddress, address _newAddress);

    /// @notice Initialize the contract.
    /// @param addresses The addresses of whitelist contracts for bridge
    function initSatellite(SatelliteStorage calldata addresses) external {
        LibDiamond.enforceIsContractOwner();
        updateSatelliteGatewayInternal(addresses.gatewayAddress);
        updateSatelliteGasServiceInternal(addresses.gasService);
    }

    /// @notice Updates the address of satellite gateway contract
    /// @param _address The new address of satellite gateway contract
    function updateSatelliteGatewayAddress(address _address) public {
        LibDiamond.enforceIsContractOwner();
        updateSatelliteGatewayInternal(_address);
    }

    /// @notice Updates the address of satellite gasService contract
    /// @param _address The new address of satellite gasService contract
    function updateSatelliteGasServiceAddress(address _address) public {
        LibDiamond.enforceIsContractOwner();
        updateSatelliteGasServiceInternal(_address);
    }

    /// @notice Emitted when an ERC20 token (non-native) bridge request is sent to satellite bridge
    /// @param _dstChainId The network id of destination chain, ex: 56 for BSC
    /// @param _token The requested token to bridge
    /// @param _receiver The receiver address in the destination chain
    /// @param _amount The requested amount to bridge
    event SatelliteSendTokenCalled(uint256 _dstChainId, address _token, string _receiver, uint256 _amount);

    /// @notice Executes a DEX (arbitrary) call + a Satellite bridge call
    /// @param request The general swap request containing from/to token and fee/affiliate rewards
    /// @param calls The list of DEX calls, if this list is empty, it means that there is no DEX call and we are only bridging
    /// @param bridgeRequest required data for the bridging step, including the destination chain and recipient wallet address
    function satelliteSwapAndBridge(
        LibSwapper.SwapRequest memory request,
        LibSwapper.Call[] calldata calls,
        IRangoSatellite.SatelliteBridgeRequest memory bridgeRequest
    ) external payable nonReentrant {
        uint out;
        uint bridgeAmount;
        // if toToken is native coin and the user has not paid fee in msg.value,
        // then the user can pay bridge fee using output of swap.
        if (request.toToken == LibSwapper.ETH && msg.value == 0) {
            out = LibSwapper.onChainSwapsPreBridge(request, calls, 0);
            bridgeAmount = out - bridgeRequest.relayerGas;
        }
        else {
            out = LibSwapper.onChainSwapsPreBridge(request, calls, bridgeRequest.relayerGas);
            bridgeAmount = out;
        }

        doSatelliteBridge(bridgeRequest, request.toToken, bridgeAmount);
        bool hasDestSwap = false;
        if (bridgeRequest.bridgeType == SatelliteBridgeType.TRANSFER_WITH_MESSAGE) {
            Interchain.RangoInterChainMessage memory imMessage = abi.decode((bridgeRequest.imMessage), (Interchain.RangoInterChainMessage));
            hasDestSwap = imMessage.actionType != Interchain.ActionType.NO_ACTION;
        }
        // event emission
        emit RangoBridgeInitiated(
            request.requestId,
            request.toToken,
            bridgeAmount,
            LibTransform.stringToAddress(bridgeRequest.receiver),
            "",
            bridgeRequest.toChainId,
            bridgeRequest.bridgeType == SatelliteBridgeType.TRANSFER_WITH_MESSAGE,
            hasDestSwap,
            uint8(BridgeType.Axelar),
            request.dAppTag
        );
    }

    /// @notice Executes a bridging via satellite
    /// @param request The extra fields required by the satellite bridge
    function satelliteBridge(
        SatelliteBridgeRequest memory request,
        RangoBridgeRequest memory bridgeRequest
    ) external payable nonReentrant {
        uint amount = bridgeRequest.amount;
        address token = bridgeRequest.token;
        uint amountWithFee = amount + LibSwapper.sumFees(bridgeRequest);
        // transfer tokens if necessary
        if (token != LibSwapper.ETH) {
            SafeERC20.safeTransferFrom(IERC20(token), msg.sender, address(this), amountWithFee);
            require(msg.value >= request.relayerGas);
        } else {
            require(msg.value >= amountWithFee + request.relayerGas);
        }
        LibSwapper.collectFees(bridgeRequest);
        doSatelliteBridge(request, token, amount);

        bool hasDestSwap = false;
        if (request.bridgeType == SatelliteBridgeType.TRANSFER_WITH_MESSAGE) {
            Interchain.RangoInterChainMessage memory imMessage = abi.decode((request.imMessage), (Interchain.RangoInterChainMessage));
            hasDestSwap = imMessage.actionType != Interchain.ActionType.NO_ACTION;
        }
        // event emission
        emit RangoBridgeInitiated(
            bridgeRequest.requestId,
            token,
            amount,
            LibTransform.stringToAddress(request.receiver),
            "",
            request.toChainId,
            request.bridgeType == SatelliteBridgeType.TRANSFER_WITH_MESSAGE,
            hasDestSwap,
            uint8(BridgeType.Axelar),
            bridgeRequest.dAppTag
        );
    }

    /// @notice Executes a bridging via satellite
    /// @param request The extra fields required by the satellite bridge
    /// @param token The requested token to bridge
    /// @param amount The requested amount to bridge
    function doSatelliteBridge(
        SatelliteBridgeRequest memory request,
        address token,
        uint256 amount
    ) internal {
        SatelliteStorage storage s = getSatelliteStorage();
        uint dstChainId = request.toChainId;

        require(s.gatewayAddress != LibSwapper.ETH, 'Satellite gateway address not set');
        require(block.chainid != dstChainId, 'Invalid destination Chain! Cannot bridge to the same network.');

        LibSwapper.BaseSwapperStorage storage baseStorage = LibSwapper.getBaseSwapperStorage();
        address bridgeToken = token;
        address refAddress = request.srcGasRefundAddress;
        if (token == LibSwapper.ETH) {
            bridgeToken = baseStorage.WETH;
            IWETH(bridgeToken).deposit{value : amount}();
        }
        if (refAddress == LibSwapper.ETH) {
            refAddress = msg.sender;
        }
        require(bridgeToken != LibSwapper.ETH, 'Source token address is null! Not supported by axelar!');
        LibSwapper.approve(bridgeToken, s.gatewayAddress, amount);

        if (request.bridgeType == SatelliteBridgeType.TRANSFER) {
            IAxelarGateway(s.gatewayAddress).sendToken(request.toChain, request.receiver, request.symbol, amount);
            emit SatelliteSendTokenCalled(dstChainId, bridgeToken, request.receiver, amount);
        } else {
            require(s.gasService != LibSwapper.ETH, 'Satellite gasService address not set');
            require(request.relayerGas > 0, 'axelar needs native fee for relayer');

            bytes memory payload = request.bridgeType == SatelliteBridgeType.TRANSFER_WITH_MESSAGE
            ? abi.encode(request.imMessage)
            : new bytes(0);
            IAxelarGasService(s.gasService).payNativeGasForContractCallWithToken{value : request.relayerGas}(
                address(this),
                request.toChain,
                request.receiver,
                payload,
                request.symbol,
                amount,
                refAddress
            );

            IAxelarGateway(s.gatewayAddress).callContractWithToken(
                request.toChain,
                request.receiver,
                payload,
                request.symbol,
                amount
            );
        }
    }

    function updateSatelliteGatewayInternal(address _address) private {
        SatelliteStorage storage s = getSatelliteStorage();
        address oldAddress = s.gatewayAddress;
        s.gatewayAddress = _address;
        emit SatelliteGatewayAddressUpdated(oldAddress, _address);
    }

    function updateSatelliteGasServiceInternal(address _address) private {
        SatelliteStorage storage s = getSatelliteStorage();
        address oldAddress = s.gasService;
        s.gasService = _address;
        emit SatelliteGasServiceAddressUpdated(oldAddress, _address);
    }

    /// @dev fetch local storage
    function getSatelliteStorage() private pure returns (SatelliteStorage storage s) {
        bytes32 namespace = SATELLITE_NAMESPACE;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            s.slot := namespace
        }
    }
}

// File: contracts/facets/bridges/RangoSatelliteMiddleware.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "../../interfaces/IRango.sol";
import "../../interfaces/IAxelarExecutable.sol";
import "../../interfaces/IUniswapV2.sol";
import "../../interfaces/IRangoMessageReceiver.sol";
import "../../interfaces/Interchain.sol";
import "../../libraries/LibInterchain.sol";
import "../base/RangoBaseInterchainMiddleware.sol";
import "../../utils/ReentrancyGuard.sol";

/// @title The contract that receives interchain messages
/// @author George
/// @dev This is not a facet, its deployed separately. The refund is handled by whitelisting the payload hash.
contract RangoSatelliteMiddleware is IRango, ReentrancyGuard, IAxelarExecutable, RangoBaseInterchainMiddleware {
    /// Storage ///
    /// @dev keccak256("exchange.rango.facets.satellite")
    bytes32 internal constant SATELLITE_NAMESPACE = hex"e97496d8273588711c444d166dc378e07de45d7ba4c6f83debe0eaef953c5a6f";

    constructor(
        address _owner,
        address _gatewayAddress,
        address _weth
    ) RangoBaseInterchainMiddleware(_owner, address(0), _weth){
        updateSatelliteGatewayInternal(_gatewayAddress);
    }

    struct SatelliteStorage {
        /// @notice The address of satellite contract
        address gatewayAddress;
        // @notice hashes of the transactions that should be refunded
        mapping(bytes32 => bool) refundPayloadHashes;
        // @notice used for refunds where payload cannot be decoded and instead, the receiver address is set manually
        mapping(bytes32 => address) refundPayloadAddresses;
    }

    /// @notice Emitted when the satellite gateway address is updated
    /// @param _oldAddress The previous address
    /// @param _newAddress The new address
    event SatelliteGatewayAddressUpdated(address _oldAddress, address _newAddress);
    /// @notice Emitted when a refund state is updated
    /// @param payloadHash The hash of payload which state is changed
    /// @param enabled The boolean signaling the state. true value means refund is enabled.
    /// @param refundAddress The address that should receive the refund.
    event PayloadHashRefundStateUpdated(bytes32 indexed payloadHash, bool enabled, address refundAddress);
    /// @notice Emitted when a refund has been executed
    /// @param payloadHash The hash of payload which state is changed
    /// @param refundAddress The address that should receive the refund.
    event PayloadHashRefunded(bytes32 indexed payloadHash, address refundAddress);

    /// @notice Updates the address of satellite gateway contract
    /// @param _address The new address of satellite gateway contract
    function updateSatelliteGatewayAddress(address _address) public onlyOwner {
        updateSatelliteGatewayInternal(_address);
    }

    /// @notice Add payload hashes to refund the user.
    /// @param hashes Array of payload hashes to be enabled or disabled for refund
    /// @param booleans Array of booleans corresponding to the hashes. true value means enable refund.
    /// @param addresses addresses that should receive the refund. Can be 0x0000 if the refund should be done based on interchain message
    function updateRefundHashes(
        bytes32[] calldata hashes,
        bool[] calldata booleans,
        address[] calldata addresses
    ) external onlyOwner {
        updateRefundHashesInternal(hashes, booleans, addresses);
    }

    /// Satellite Executor:

    function execute(
        bytes32 commandId,
        string calldata sourceChain,
        string calldata sourceAddress,
        bytes calldata payload
    ) external payable nonReentrant {
        SatelliteStorage storage s = getSatelliteStorage();
        bytes32 payloadHash = keccak256(payload);
        if (!IAxelarGateway(s.gatewayAddress).validateContractCall(commandId, sourceChain, sourceAddress, payloadHash)) revert NotApprovedByGateway();
        _execute(sourceChain, sourceAddress, payload);
        // todo: implement _execute in future for message passing.
    }

    function executeWithToken(
        bytes32 commandId,
        string calldata sourceChain,
        string calldata sourceAddress,
        bytes calldata payload,
        string calldata tokenSymbol,
        uint256 amount
    ) external payable nonReentrant {
        SatelliteStorage storage s = getSatelliteStorage();
        bytes32 payloadHash = keccak256(payload);
        if (!IAxelarGateway(s.gatewayAddress).validateContractCallAndMint(commandId, sourceChain, sourceAddress, payloadHash, tokenSymbol, amount))
            revert NotApprovedByGateway();
        // check if we should refund the user
        if (s.refundPayloadHashes[payloadHash] == true) {
            address refundAddr = s.refundPayloadAddresses[payloadHash];
            address requestId = LibSwapper.ETH;
            address originalSender = LibSwapper.ETH;
            uint16 dAppTag;
            if (refundAddr == address(0)) {
                Interchain.RangoInterChainMessage memory m = abi.decode((payload), (Interchain.RangoInterChainMessage));
                refundAddr = m.recipient;
                requestId = m.requestId;
                originalSender = m.originalSender;
                dAppTag = m.dAppTag;
            }
            require(refundAddr != address(0), "Cannot refund to burn address");

            address _token = IAxelarGateway(s.gatewayAddress).tokenAddresses(tokenSymbol);
            SafeERC20.safeTransfer(IERC20(_token), refundAddr, amount);
            s.refundPayloadHashes[payloadHash] = false;
            emit PayloadHashRefundStateUpdated(payloadHash, false, refundAddr);
            emit PayloadHashRefunded(payloadHash, refundAddr);
            emit RangoBridgeCompleted(
                requestId,
                _token,
                originalSender,
                refundAddr,
                amount,
                CrossChainOperationStatus.RefundInDestination,
                dAppTag
            );
        } else {
            _executeWithToken(sourceChain, sourceAddress, payload, tokenSymbol, amount);
        }
    }

    function _executeWithToken(
        string memory sourceChain,
        string memory sourceAddress,
        bytes calldata payload,
        string memory tokenSymbol,
        uint256 amount
    ) override internal virtual {
        Interchain.RangoInterChainMessage memory m = abi.decode((payload), (Interchain.RangoInterChainMessage));
        SatelliteStorage storage s = getSatelliteStorage();
        address _token = IAxelarGateway(s.gatewayAddress).tokenAddresses(tokenSymbol);
        (address receivedToken, uint dstAmount, IRango.CrossChainOperationStatus status) = LibInterchain.handleDestinationMessage(_token, amount, m);

        emit RangoBridgeCompleted(
            m.requestId,
            receivedToken,
            m.originalSender,
            m.recipient,
            dstAmount,
            status,
            m.dAppTag
        );
    }

    function updateSatelliteGatewayInternal(address _address) private {
        SatelliteStorage storage s = getSatelliteStorage();
        address oldAddress = s.gatewayAddress;
        s.gatewayAddress = _address;
        emit SatelliteGatewayAddressUpdated(oldAddress, _address);
    }

    function updateRefundHashesInternal(bytes32[] calldata hashes, bool[] calldata booleans, address[] calldata addresses) private {
        SatelliteStorage storage s = getSatelliteStorage();
        bytes32 hash;
        bool enabled;
        address refundAddr;
        for (uint256 i = 0; i < hashes.length; i++) {
            hash = hashes[i];
            enabled = booleans[i];
            s.refundPayloadHashes[hash] = enabled;
            refundAddr = addresses[i];
            if (refundAddr != address(0))
                s.refundPayloadAddresses[hash] = refundAddr;
            emit PayloadHashRefundStateUpdated(hash, enabled, refundAddr);
        }
    }

    /// @dev fetch local storage
    function getSatelliteStorage() private pure returns (SatelliteStorage storage s) {
        bytes32 namespace = SATELLITE_NAMESPACE;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            s.slot := namespace
        }
    }
}

// File: contracts/facets/bridges/RangoStargateFacet.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "../../interfaces/IUniswapV2.sol";
import "../../interfaces/IWETH.sol";
import "../../interfaces/IRangoStargate.sol";
import "../../interfaces/IStargateReceiver.sol";
import "../../interfaces/IStargateWidget.sol";
import "../../interfaces/Interchain.sol";
import "../../libraries/LibInterchain.sol";
import "../../interfaces/IRangoMessageReceiver.sol";
import "../../interfaces/IRango.sol";
import "../../utils/ReentrancyGuard.sol";
import "../../utils/LibTransform.sol";
import "../../libraries/LibDiamond.sol";
import "../../utils/LibTransform.sol";

/// @title The root contract that handles Rango's interaction with Stargate. For receiving messages from LayerZero, a middleware contract is used(RangoStargateMiddleware).
/// @author Uchiha Sasuke
contract RangoStargateFacet is IRango, ReentrancyGuard, IRangoStargate {
    /// Storage ///
    /// @dev keccak256("exchange.rango.facets.stargate")
    bytes32 internal constant STARGATE_NAMESPACE = hex"9226eefa91acf770d80880f45d613abe38399c942d4a127aff5bb29333e9d4a5";

    struct StargateStorage {
        /// @notice The address of stargate contract
        address stargateRouter;
        address stargateRouterEth;
        address stargateWidget;
        bytes2 partnerId;
    }

    /// @notice Initialize the contract.
    /// @param addresses The new addresses of Stargate contracts
    function initStargate(StargateStorage calldata addresses) external {
        LibDiamond.enforceIsContractOwner();
        updateStargateAddressInternal(addresses.stargateRouter, addresses.stargateRouterEth);
        updateStargateWidgetInternal(addresses.stargateWidget, addresses.partnerId);
    }

    /// @notice Enables the contract to receive native ETH token from other contracts including WETH contract
    receive() external payable {}

    /// @notice Emits when the stargate router address is updated
    /// @param _oldRouter The previous router address
    /// @param _oldRouterEth The previous routerEth address
    /// @param _newRouter The new router address
    /// @param _newRouterEth The new routerEth address
    event StargateAddressUpdated(address _oldRouter, address _oldRouterEth, address _newRouter, address _newRouterEth);
    /// @notice Emits when the stargate widget address is updated
    /// @param _widgetAddress The widget address of stargate
    /// @param _partnerId The partnerId of stargate
    event StargateWidgetUpdated(address _widgetAddress, bytes2 _partnerId);

    /// @notice Updates the address of Stargate contract
    /// @param _router The new address of Stargate contract
    /// @param _routerEth The new address of Stargate contract
    function updateStargateAddress(address _router, address _routerEth) public {
        LibDiamond.enforceIsContractOwner();
        updateStargateAddressInternal(_router, _routerEth);
    }
    /// @notice Updates the address of Stargate contract
    /// @param _widgetAddress The new address of Stargate contract
    /// @param _partnerId The new address of Stargate contract
    function updateStargateWidget(address _widgetAddress, bytes2 _partnerId) public {
        LibDiamond.enforceIsContractOwner();
        updateStargateWidgetInternal(_widgetAddress, _partnerId);
    }

    function stargateSwapAndBridge(
        LibSwapper.SwapRequest memory request,
        LibSwapper.Call[] calldata calls,
        IRangoStargate.StargateRequest memory stargateRequest
    ) external payable nonReentrant {
        uint out;
        uint bridgeAmount;
        // if toToken is native coin and the user has not paid fee in msg.value,
        // then the user can pay bridge fee using output of swap.
        if (request.toToken == LibSwapper.ETH && msg.value == 0) {
            out = LibSwapper.onChainSwapsPreBridge(request, calls, 0);
            bridgeAmount = out - stargateRequest.stgFee;
        }
        else {
            out = LibSwapper.onChainSwapsPreBridge(request, calls, stargateRequest.stgFee);
            bridgeAmount = out;
        }
        doStargateSwap(stargateRequest, request.toToken, bridgeAmount);

        bool hasDestSwap = false;
        if (stargateRequest.bridgeType == StargateBridgeType.TRANSFER_WITH_MESSAGE) {
            Interchain.RangoInterChainMessage memory imMessage = abi.decode((stargateRequest.imMessage), (Interchain.RangoInterChainMessage));
            hasDestSwap = imMessage.actionType != Interchain.ActionType.NO_ACTION;
        }

        // event emission
        emit RangoBridgeInitiated(
            request.requestId,
            request.toToken,
            out,
            LibTransform.bytesToAddress(stargateRequest.to),
            "",
            stargateRequest.dstChainId,
            stargateRequest.bridgeType == StargateBridgeType.TRANSFER_WITH_MESSAGE,
            hasDestSwap,
            uint8(BridgeType.Stargate),
            request.dAppTag
        );
    }

    function stargateBridge(
        IRangoStargate.StargateRequest memory stargateRequest,
        RangoBridgeRequest memory bridgeRequest
    ) external payable nonReentrant {
        uint256 amount = bridgeRequest.amount + LibSwapper.sumFees(bridgeRequest);
        // transfer tokens if necessary
        if (bridgeRequest.token != LibSwapper.ETH) {
            SafeERC20.safeTransferFrom(IERC20(bridgeRequest.token), msg.sender, address(this), bridgeRequest.amount);
        } else {
            require(msg.value >= amount + stargateRequest.stgFee, "Insufficient ETH sent for bridging");
        }
        LibSwapper.collectFees(bridgeRequest);
        doStargateSwap(stargateRequest, bridgeRequest.token, bridgeRequest.amount);

        bool hasDestSwap = false;
        if (stargateRequest.bridgeType == StargateBridgeType.TRANSFER_WITH_MESSAGE) {
            Interchain.RangoInterChainMessage memory imMessage = abi.decode((stargateRequest.imMessage), (Interchain.RangoInterChainMessage));
            hasDestSwap = imMessage.actionType != Interchain.ActionType.NO_ACTION;
        }
        // event emission
        emit RangoBridgeInitiated(
            bridgeRequest.requestId,
            bridgeRequest.token,
            bridgeRequest.amount,
            LibTransform.bytesToAddress(stargateRequest.to),
            "",
            stargateRequest.dstChainId,
            stargateRequest.bridgeType == StargateBridgeType.TRANSFER_WITH_MESSAGE,
            hasDestSwap,
            uint8(BridgeType.Stargate),
            bridgeRequest.dAppTag
        );
    }

    /// @notice Executes a Stargate call
    /// @param request Required bridge params + interchain message that contains all the required info on the destination
    /// @param fromToken The address of source token to bridge
    /// @param inputAmount The amount to be bridged (excluding the fee)
    function doStargateSwap(
        StargateRequest memory request,
        address fromToken,
        uint256 inputAmount
    ) internal {
        StargateStorage storage s = getStargateStorage();

        address router = fromToken == LibSwapper.ETH ? s.stargateRouterEth : s.stargateRouter;
        require(router != LibSwapper.ETH, "Stargate router address not set");

        if (fromToken != LibSwapper.ETH) {
            LibSwapper.approve(fromToken, router, inputAmount);
        }

        bytes memory payload = request.bridgeType == StargateBridgeType.TRANSFER_WITH_MESSAGE
        ? request.imMessage
        : new bytes(0);

        if (fromToken == LibSwapper.ETH) {
            if (request.bridgeType == StargateBridgeType.TRANSFER_WITH_MESSAGE) {
                revert("Payload not supported on swapETH");
            }
            stargateRouterSwapEth(request, router, inputAmount);
        } else {
            stargateRouterSwap(request, router, inputAmount, request.stgFee, payload);
        }
        if (s.stargateWidget != LibSwapper.ETH) {
            IStargateWidget(s.stargateWidget).partnerSwap(s.partnerId);
        }
    }

    function stargateRouterSwapEth(StargateRequest memory request, address router, uint256 bridgeAmount) private {
        IStargateRouter(router).swapETH{value : bridgeAmount + request.stgFee}(
            request.dstChainId,
            request.srcGasRefundAddress,
            request.to,
            bridgeAmount,
            request.minAmountLD
        );
    }

    function stargateRouterSwap(
        StargateRequest memory request,
        address router,
        uint256 inputAmount,
        uint256 value,
        bytes memory payload
    ) private {
        IStargateRouter.lzTxObj memory lzTx = IStargateRouter.lzTxObj(
            request.dstGasForCall,
            request.dstNativeAmount,
            request.dstNativeAddr
        );
        IStargateRouter(router).swap{value : value}(
            request.dstChainId,
            request.srcPoolId,
            request.dstPoolId,
            request.srcGasRefundAddress,
            inputAmount,
            request.minAmountLD,
            lzTx,
            request.to,
            payload
        );
    }

    function updateStargateAddressInternal(address _router, address _routerEth) private {
        StargateStorage storage s = getStargateStorage();
        address oldAddressRouter = s.stargateRouter;
        s.stargateRouter = _router;

        address oldAddressRouterEth = s.stargateRouterEth;
        s.stargateRouterEth = _routerEth;

        emit StargateAddressUpdated(oldAddressRouter, oldAddressRouterEth, _router, _routerEth);
    }

    function updateStargateWidgetInternal(address _widgetAddress, bytes2 _partnerId) private {
        StargateStorage storage s = getStargateStorage();
        s.stargateWidget = _widgetAddress;
        s.partnerId = _partnerId;

        emit StargateWidgetUpdated(_widgetAddress, _partnerId);
    }

    /// @dev fetch local storage
    function getStargateStorage() private pure returns (StargateStorage storage s) {
        bytes32 namespace = STARGATE_NAMESPACE;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            s.slot := namespace
        }
    }
}

// File: contracts/facets/bridges/RangoStargateMiddleware.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "../../libraries/LibInterchain.sol";
import "../../utils/ReentrancyGuard.sol";
import "../base/RangoBaseInterchainMiddleware.sol";

/// @title The middleware contract that handles Rango's receive messages from stargate.
/// @author George
/// @dev Note that this is not a facet and should be deployed separately.
contract RangoStargateMiddleware is ReentrancyGuard, IRango, IStargateReceiver, RangoBaseInterchainMiddleware {

    /// @dev keccak256("exchange.rango.middleware.stargate")
    bytes32 internal constant STARGATE_MIDDLEWARE_NAMESPACE = hex"8f95700cb6d0d3fbe23970b0fed4ae8d3a19af1ff9db49b72f280b34bdf7bad8";

    struct RangoStargateMiddlewareStorage {
        address stargateRouter;
    }

    constructor(
        address _owner,
        address _stargateRouter,
        address _weth
    ) RangoBaseInterchainMiddleware(_owner, address(0), _weth){
        updateStargateRouterAddressInternal(_stargateRouter);
    }

    /// Events

    /// @notice Emits when the Stargate address is updated
    /// @param oldAddress The previous address
    /// @param newAddress The new address
    event StargateRouterAddressUpdated(address oldAddress, address newAddress);

    /// External Functions

    /// @notice Updates the address of stargateRouter
    /// @param newAddress The new address of owner
    function updateStargateRouter(address newAddress) external onlyOwner {
        updateStargateRouterAddressInternal(newAddress);
    }

    // @param _chainId The remote chainId sending the tokens
    // @param _srcAddress The remote Bridge address
    // @param _nonce The message ordering nonce
    // @param _token The token contract on the local chain
    // @param amountLD The qty of local _token contract tokens
    // @param _payload The bytes containing the _tokenOut, _deadline, _amountOutMin, _toAddr
    function sgReceive(
        uint16,
        bytes memory,
        uint256,
        address _token,
        uint256 amountLD,
        bytes memory payload
    ) external override nonReentrant {
        require(msg.sender == getRangoStargateMiddlewareStorage().stargateRouter,
            "sgReceive function can only be called by Stargate router");
        Interchain.RangoInterChainMessage memory m = abi.decode((payload), (Interchain.RangoInterChainMessage));
        (address receivedToken, uint dstAmount, IRango.CrossChainOperationStatus status) = LibInterchain.handleDestinationMessage(_token, amountLD, m);

        emit RangoBridgeCompleted(
            m.requestId,
            receivedToken,
            m.originalSender,
            m.recipient,
            dstAmount,
            status,
            m.dAppTag
        );
    }

    /// Private and Internal
    function updateStargateRouterAddressInternal(address newAddress) private {
        RangoStargateMiddlewareStorage storage s = getRangoStargateMiddlewareStorage();
        address oldAddress = s.stargateRouter;
        s.stargateRouter = newAddress;
        emit StargateRouterAddressUpdated(oldAddress, newAddress);
    }

    /// @dev fetch local storage
    function getRangoStargateMiddlewareStorage() private pure returns (RangoStargateMiddlewareStorage storage s) {
        bytes32 namespace = STARGATE_MIDDLEWARE_NAMESPACE;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            s.slot := namespace
        }
    }
}

// File: contracts/facets/bridges/RangoSymbiosisFacet.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "../../interfaces/IWETH.sol";
import "../../interfaces/IRangoSymbiosis.sol";
import "../../interfaces/ISymbiosisMetaRouter.sol";
import "../../interfaces/IUniswapV2.sol";
import "../../interfaces/IRangoMessageReceiver.sol";
import "../../interfaces/IRango.sol";
import "../../interfaces/Interchain.sol";
import "../../libraries/LibInterchain.sol";
import "../../libraries/LibDiamond.sol";
import "../../utils/ReentrancyGuard.sol";


/// @title The root contract that handles Rango's interaction with symbiosis
/// @author Rza
contract RangoSymbiosisFacet is IRango, ReentrancyGuard, IRangoSymbiosis {
    /// Storage ///
    /// @dev keccak256("exchange.rango.facets.symbiosis")
    bytes32 internal constant SYMBIOSIS_NAMESPACE = hex"81ce8a65cc4e11b9c999b4c5d66459bb20272ba6288f99768bc4d0cb2c8ca95d";

    struct SymbiosisStorage {
        /// @notice The address of symbiosis meta router contract
        address symbiosisMetaRouter;
        /// @notice The address of symbiosis meta router gateway contract
        address symbiosisMetaRouterGateway;
    }

    /// @notice Emits when the symbiosis contracts address is updated
    /// @param oldMetaRouter The previous address for MetaRouter contract
    /// @param oldMetaRouterGateway The previous address for MetaRouterGateway contract
    /// @param newMetaRouter The updated address for MetaRouter contract
    /// @param newMetaRouterGateway The updated address for MetaRouterGateway contract
    event SymbiosisAddressUpdated(
        address oldMetaRouter,
        address oldMetaRouterGateway,
        address indexed newMetaRouter,
        address indexed newMetaRouterGateway
    );

    /// @notice A series of events with different status value to help us track the progress of cross-chain swap
    /// @param token The token address in the current network that is being bridged
    /// @param outputAmount The latest observed amount in the path, aka: input amount for source and output amount on dest
    /// @param status The latest status of the overall flow
    /// @param source The source address that initiated the transaction
    /// @param destination The destination address that received the money, ZERO address if not sent to the end-user yet
    event SymbiosisSwapStatusUpdated(
        address token,
        uint256 outputAmount,
        IRango.CrossChainOperationStatus status,
        address source,
        address destination
    );

    /// @notice Initialize the contract.
    /// @param addresses addresses of Symbiosis routers
    function initSymbiosis(SymbiosisStorage calldata addresses) external {
        LibDiamond.enforceIsContractOwner();
        updateSymbiosisAddressInternal(addresses.symbiosisMetaRouter, addresses.symbiosisMetaRouterGateway);
    }

    /// @notice Updates the address of symbiosis contract
    /// @param metaRouter The new address of symbiosis MetaRouter contract
    /// @param metaRouterGateway The new address of symbiosis MetaRouterGateway contract
    function updateSymbiosisAddress(address metaRouter, address metaRouterGateway) public {
        LibDiamond.enforceIsContractOwner();
        updateSymbiosisAddressInternal(metaRouter, metaRouterGateway);
    }

    /// @inheritdoc IRangoSymbiosis
    function messageReceive(
        uint256 amount,
        address token,
        Interchain.RangoInterChainMessage memory receivedMessage
    ) external payable override nonReentrant {
        (address receivedToken, uint dstAmount, IRango.CrossChainOperationStatus status) = LibInterchain.handleDestinationMessage(token, amount, receivedMessage);

        emit SymbiosisSwapStatusUpdated(receivedToken, dstAmount, status, receivedMessage.originalSender, receivedMessage.recipient);
    }

    /// @notice Executes a DEX call + a Symbiosis bridge call + a Dex call
    /// @param request The general swap request containing from/to token and fee/affiliate rewards
    /// @param calls The list of DEX calls, if this list is empty, it means that there is no DEX call and we are only bridging
    /// @param bridgeRequest required data for the bridging step, including the destination chain and recipient wallet address
    function symbiosisBridge(
        LibSwapper.SwapRequest memory request,
        LibSwapper.Call[] calldata calls,
        IRangoSymbiosis.SymbiosisBridgeRequest memory bridgeRequest
    ) external payable nonReentrant {
        uint out = LibSwapper.onChainSwapsPreBridge(request, calls, 0);
        doSymbiosisBridge(bridgeRequest, request.toToken, out);

        // event emission
        emit RangoBridgeInitiated(
            request.requestId,
            request.toToken,
            out,
            bridgeRequest.otherSideData.chain2address,
            "",
            bridgeRequest.bridgeData.chainID,
            false,
            false,
            uint8(BridgeType.Symbiosis),
            request.dAppTag
        );
    }

    function symbiosisBridge(
        IRangoSymbiosis.SymbiosisBridgeRequest memory symbiosisRequest,
        IRango.RangoBridgeRequest memory bridgeRequest
    ) external payable nonReentrant {
        SymbiosisStorage storage s = getSymbiosisStorage();
        uint256 amount = bridgeRequest.amount + LibSwapper.sumFees(bridgeRequest);
        // transfer tokens if necessary
        if (bridgeRequest.token == LibSwapper.ETH) {
            require(msg.value >= amount, "Insufficient ETH sent for bridging");
        } else {
            SafeERC20.safeTransferFrom(IERC20(bridgeRequest.token), msg.sender, address(this), amount);
            LibSwapper.approve(bridgeRequest.token, s.symbiosisMetaRouterGateway, bridgeRequest.amount);
        }

        LibSwapper.collectFees(bridgeRequest);
        doSymbiosisBridge(symbiosisRequest, bridgeRequest.token, bridgeRequest.amount);

        // event emission
        emit RangoBridgeInitiated(
            bridgeRequest.requestId,
            bridgeRequest.token,
            bridgeRequest.amount,
            symbiosisRequest.otherSideData.chain2address,
            "",
            symbiosisRequest.bridgeData.chainID,
            false,
            false,
            uint8(BridgeType.Symbiosis),
            bridgeRequest.dAppTag
        );
    }

    /// @notice Executes a bridging via symbiosis
    /// @param request The extra fields required by the symbiosis bridge
    /// @param token The requested token to bridge
    /// @param amount The requested amount to bridge
    function doSymbiosisBridge(
        SymbiosisBridgeRequest memory request,
        address token,
        uint256 amount
    ) internal {
        SymbiosisStorage storage s = getSymbiosisStorage();
        require(s.symbiosisMetaRouter != LibSwapper.ETH, 'Symbiosis meta router address not set');
        require(s.symbiosisMetaRouterGateway != LibSwapper.ETH, 'Symbiosis meta router gateway address not set');
        require(token != LibSwapper.ETH, 'Symbiosis contract handles only ERC20 tokens');

        

        MetaRouteTransaction memory transactionData = request.metaRouteTransaction;
        bytes memory otherSideCalldata;
        if (request.bridgeType == SymbiosisBridgeType.META_BURN) {
            MetaBurnTransaction memory metaData = metaBurnData(request);
            otherSideCalldata = abi.encodeWithSelector(0xe691a2aa, metaData); // metaBurn selector
        } else {
            MetaSynthesizeTransaction memory metaData = metaSynthesizeData(request);
            otherSideCalldata = abi.encodeWithSelector(0xce654c17, metaData); // metaSynthesizeSelector
        }
        transactionData.otherSideCalldata = otherSideCalldata;
        transactionData.amount = amount;

        ISymbiosisMetaRouter(s.symbiosisMetaRouter).metaRoute(transactionData);
    }

    function metaBurnData(
        SymbiosisBridgeRequest memory request
    ) private pure returns (MetaBurnTransaction memory) {
        address finalReceiveSide;
        bytes memory finalCalldata;
        uint256 finalOffset;

        if (request.hasFinalCall) {
            finalReceiveSide = request.otherSideData.finalReceiveSide;
            finalCalldata = finalReceiveCalldata(request);
            finalOffset = 36;
        } else {
            finalReceiveSide = LibSwapper.ETH;
            finalCalldata = "";
            finalOffset = 0;
        }

        return MetaBurnTransaction(
            request.otherSideData.stableBridgingFee,
            request.otherSideData.amount,
            request.userData.syntCaller,
            finalReceiveSide,
            request.userData.token,
            finalCalldata,
            finalOffset,
            request.otherSideData.chain2address,
            request.userData.receiveSide,
            request.bridgeData.oppositeBridge,
            request.userData.revertableAddress,
            request.bridgeData.chainID,
            request.bridgeData.clientID
        );
    }

    function metaSynthesizeData(
        SymbiosisBridgeRequest memory request
    ) private pure returns (MetaSynthesizeTransaction memory) {
        address finalReceiveSide;
        bytes memory finalCalldata;
        uint256 finalOffset;

        if (request.hasFinalCall) {
            finalReceiveSide = request.otherSideData.finalReceiveSide;
            finalCalldata = finalReceiveCalldata(request);
            finalOffset = 36;
        } else {
            finalReceiveSide = LibSwapper.ETH;
            finalCalldata = "";
            finalOffset = 0;
        }

        return MetaSynthesizeTransaction(
            request.otherSideData.stableBridgingFee,
            request.otherSideData.amount,
            request.userData.token,
            request.otherSideData.chain2address,
            request.userData.receiveSide,
            request.bridgeData.oppositeBridge,
            request.userData.syntCaller,
            request.bridgeData.chainID,
            request.otherSideData.swapTokens,
            request.swapData.poolAddress,
            request.swapData.poolData,
            finalReceiveSide,
            finalCalldata,
            finalOffset,
            request.userData.revertableAddress,
            request.bridgeData.clientID
        );
    }

    function finalReceiveCalldata(
        SymbiosisBridgeRequest memory request
    ) private pure returns (bytes memory finalCalldata){
        finalCalldata = abi.encodeWithSelector(
            0x06e39ced, // messageReceive selector
            request.otherSideData.finalAmount,
            request.otherSideData.finalToken,
            request.imMessage
        );
    }

    function updateSymbiosisAddressInternal(address metaRouter, address metaRouterGateway) private {
        SymbiosisStorage storage s = getSymbiosisStorage();
        address oldMetaRouter = s.symbiosisMetaRouter;
        address oldMetaRouterGateway = s.symbiosisMetaRouterGateway;
        s.symbiosisMetaRouter = metaRouter;
        s.symbiosisMetaRouterGateway = metaRouterGateway;
        emit SymbiosisAddressUpdated(oldMetaRouter, oldMetaRouterGateway, metaRouter, metaRouterGateway);
    }

    /// @dev fetch local storage
    function getSymbiosisStorage() private pure returns (SymbiosisStorage storage s) {
        bytes32 namespace = SYMBIOSIS_NAMESPACE;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            s.slot := namespace
        }
    }
}


// File: contracts/facets/bridges/RangoSynapseFacet.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "../../interfaces/ISynapseRouter.sol";
import "../../interfaces/IRangoSynapse.sol";
import "../../interfaces/IRango.sol";
import "../../utils/ReentrancyGuard.sol";
import "../../libraries/LibSwapper.sol";
import "../../libraries/LibDiamond.sol";

/// @title The root contract that handles Rango's interaction with Synapse bridge
/// @author Rango DeXter
contract RangoSynapseFacet is IRango, ReentrancyGuard, IRangoSynapse {
    /// Storage ///
    /// @dev keccak256("exchange.rango.facets.synapse")
    bytes32 internal constant SYNAPSE_NAMESPACE = hex"02869f424030b590e41301e776e7c113e07b544e24de2460494da4c5d586976c";

    struct SynapseStorage {
        /// @notice Synapse router address in the current chain
        address routerAddress;
    }

    /// @notice Initialize the contract.
    /// @param _address Synapse router contract address
    function initSynapse(address _address) external {
        LibDiamond.enforceIsContractOwner();
        updateSynapseRoutersInternal(_address);
    }

    /// @notice Emits when the synapse address is updated
    /// @param _oldAddress The previous address
    /// @param _newAddress The new address
    event SynapseAddressUpdated(address _oldAddress, address _newAddress);

    /// @notice Enables the contract to receive native ETH token from other contracts including WETH contract
    receive() external payable {}

    /// @notice update whitelisted Synapse router
    /// @param _address Synapse zap router
    function updateSynapseRouters(address _address) public {
        LibDiamond.enforceIsContractOwner();
        updateSynapseRoutersInternal(_address);
    }

    /// @notice Executes a DEX (arbitrary) call + a Synapse bridge call
    /// @param request The general swap request containing from/to token and fee/affiliate rewards
    /// @param calls The list of DEX calls, if this list is empty, it means that there is no DEX call and we are only bridging
    /// @param bridgeRequest required data for the bridging step, including the destination chain and recipient wallet address
    function synapseBridge(
        LibSwapper.SwapRequest memory request,
        LibSwapper.Call[] calldata calls,
        IRangoSynapse.SynapseBridgeRequest memory bridgeRequest
    ) external payable nonReentrant {
        uint out = LibSwapper.onChainSwapsPreBridge(request, calls, 0);
        doSynapseBridge(bridgeRequest, request.toToken, out);
    }

    /// @notice Executes a Synapse bridge call
    /// @param request required data for bridge
    /// @param inputToken The address of bridging token
    /// @param inputAmount The amount of the token to be bridged
    function doSynapseBridge(
        SynapseBridgeRequest memory request,
        address inputToken,
        uint inputAmount
    ) internal {
        SynapseStorage storage s = getSynapseStorage();
        require(s.routerAddress == request.router, 'Requested router address not whitelisted');
        require(request.to != LibSwapper.ETH, "Invalid recipient address");
        require(request.chainId != 0, "Invalid recipient chain");
        require(inputAmount > 0, "Invalid amount");
        if (inputToken == LibSwapper.ETH)
            require(msg.value >= inputAmount, "Invalid value");

        if (inputToken != LibSwapper.ETH) {
            LibSwapper.approve(inputToken, request.router, inputAmount);
        }

        ISynapseRouter router = ISynapseRouter(request.router);

        if (request.bridgeType == SynapseBridgeType.SWAP_AND_REDEEM)
            synapseSwapAndRedeem(router, request, inputAmount);
        else if (request.bridgeType == SynapseBridgeType.SWAP_AND_REDEEM_AND_SWAP)
            synapseSwapAndRedeemAndSwap(router, request, inputAmount);
        else if (request.bridgeType == SynapseBridgeType.SWAP_AND_REDEEM_AND_REMOVE)
            synapseSwapAndRedeemAndRemove(router, request, inputAmount);
        else if (request.bridgeType == SynapseBridgeType.REDEEM)
            synapseRedeem(router, request, inputAmount);
        else if (request.bridgeType == SynapseBridgeType.REDEEM_AND_SWAP)
            synapseRedeemAndSwap(router, request, inputAmount);
        else if (request.bridgeType == SynapseBridgeType.REDEEM_AND_REMOVE)
            synapseRedeemAndRemove(router, request, inputAmount);
        else if (request.bridgeType == SynapseBridgeType.DEPOSIT)
            synapseDeposit(router, request, inputAmount);
        else if (request.bridgeType == SynapseBridgeType.DEPOSIT_ETH)
            synapseDepositETH(router, request, inputAmount);
        else if (request.bridgeType == SynapseBridgeType.DEPOSIT_ETH_AND_SWAP)
            synapseDepositETHAndSwap(router, request, inputAmount);
        else if (request.bridgeType == SynapseBridgeType.DEPOSIT_AND_SWAP)
            synapseDepositAndSwap(router, request, inputAmount);
        else if (request.bridgeType == SynapseBridgeType.SWAP_ETH_AND_REDEEM)
            synapseSwapETHAndRedeem(router, request, inputAmount);
        else if (request.bridgeType == SynapseBridgeType.ZAP_AND_DEPOSIT)
            synapseZapAndDeposit(router, request, inputAmount);
        else if (request.bridgeType == SynapseBridgeType.ZAP_AND_DEPOSIT_AND_SWAP)
            synapseZapAndDepositAndSwap(router, request, inputAmount);
        else
            revert("Invalid bridge type");


        emit SynapseBridgeEvent(
            inputToken, inputAmount, request.bridgeType, request.to, request.chainId, request.token
        );

        emit SynapseBridgeDetailEvent(
            request.tokenIndexFrom, request.tokenIndexTo, request.minDy, request.deadline, request.swapTokenIndexFrom,
            request.swapTokenIndexTo, request.swapMinDy, request.swapDeadline
        );

    }

    function synapseDeposit(ISynapseRouter router, SynapseBridgeRequest memory request, uint inputAmount) private {
        router.deposit(request.to, request.chainId, IERC20(request.token), inputAmount);
    }

    function synapseRedeem(ISynapseRouter router, SynapseBridgeRequest memory request, uint inputAmount) private {
        router.redeem(request.to, request.chainId, IERC20(request.token), inputAmount);
    }

    function synapseDepositAndSwap(ISynapseRouter router, SynapseBridgeRequest memory request, uint inputAmount) private {
        router.depositAndSwap(
            request.to, request.chainId, IERC20(request.token), inputAmount, request.tokenIndexFrom,
            request.tokenIndexTo, request.minDy, request.deadline
        );
    }

    function synapseDepositETH(ISynapseRouter router, SynapseBridgeRequest memory request, uint inputAmount) private {
        router.depositETH{value : inputAmount}(request.to, request.chainId, inputAmount);
    }

    function synapseDepositETHAndSwap(ISynapseRouter router, SynapseBridgeRequest memory request, uint inputAmount) private {
        router.depositETHAndSwap{value : inputAmount}(
            request.to, request.chainId, inputAmount, request.tokenIndexFrom, request.tokenIndexTo, request.minDy,
            request.deadline
        );
    }

    function synapseRedeemAndSwap(ISynapseRouter router, SynapseBridgeRequest memory request, uint inputAmount) private {
        router.redeemAndSwap(
            request.to, request.chainId, IERC20(request.token), inputAmount, request.tokenIndexFrom,
            request.tokenIndexTo, request.minDy, request.deadline
        );
    }

    function synapseRedeemAndRemove(ISynapseRouter router, SynapseBridgeRequest memory request, uint inputAmount) private {
        router.redeemAndRemove(
            request.to, request.chainId, IERC20(request.token), inputAmount, request.tokenIndexFrom,
            request.minDy, request.deadline
        );
    }

    function synapseSwapAndRedeem(ISynapseRouter router, SynapseBridgeRequest memory request, uint inputAmount) private {
        router.swapAndRedeem(
            request.to, request.chainId, IERC20(request.token), request.tokenIndexFrom,
            request.tokenIndexTo, inputAmount, request.minDy, request.deadline
        );
    }

    function synapseSwapETHAndRedeem(ISynapseRouter router, SynapseBridgeRequest memory request, uint inputAmount) private {
        router.swapETHAndRedeem{value : inputAmount}(
            request.to, request.chainId, IERC20(request.token), request.tokenIndexFrom, request.tokenIndexTo,
            inputAmount, request.minDy, request.deadline
        );
    }

    function synapseSwapAndRedeemAndSwap(ISynapseRouter router, SynapseBridgeRequest memory request, uint inputAmount) private {
        router.swapAndRedeemAndSwap(
            request.to, request.chainId, IERC20(request.token), request.tokenIndexFrom, request.tokenIndexTo,
            inputAmount, request.minDy, request.deadline, request.swapTokenIndexFrom, request.swapTokenIndexTo,
            request.swapMinDy, request.swapDeadline
        );
    }

    function synapseSwapAndRedeemAndRemove(ISynapseRouter router, SynapseBridgeRequest memory request, uint inputAmount) private {
        router.swapAndRedeemAndRemove(
            request.to, request.chainId, IERC20(request.token), request.tokenIndexFrom, request.tokenIndexTo,
            inputAmount, request.minDy, request.deadline, request.swapTokenIndexFrom, request.minDy,
            request.swapDeadline
        );
    }

    function synapseZapAndDeposit(ISynapseRouter router, SynapseBridgeRequest memory request, uint inputAmount) private {
        router.zapAndDeposit(
            request.to, request.chainId, IERC20(request.token), request.liquidityAmounts, request.minDy,
            request.deadline
        );
    }

    function synapseZapAndDepositAndSwap(ISynapseRouter router, SynapseBridgeRequest memory request, uint inputAmount) private {
        router.zapAndDepositAndSwap(
            request.to, request.chainId, IERC20(request.token), request.liquidityAmounts, request.minDy,
            request.deadline, request.tokenIndexFrom, request.tokenIndexTo, request.swapMinDy, request.swapDeadline
        );
    }

    function updateSynapseRoutersInternal(address _address) private {
        SynapseStorage storage s = getSynapseStorage();
        address oldAddress = s.routerAddress;
        s.routerAddress = _address;

        emit SynapseAddressUpdated(oldAddress, _address);
    }

    /// @dev fetch local storage
    function getSynapseStorage() private pure returns (SynapseStorage storage s) {
        bytes32 namespace = SYNAPSE_NAMESPACE;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            s.slot := namespace
        }
    }
}

// File: contracts/facets/bridges/RangoVoyagerFacet.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "../../interfaces/IRangoVoyager.sol";
import "../../interfaces/IVoyager.sol";
import "../../interfaces/IRango.sol";
import "../../utils/ReentrancyGuard.sol";
import "../../utils/LibTransform.sol";
import "../../libraries/LibInterchain.sol";
import "../../libraries/LibDiamond.sol";

// @title Facet contract to interact with Voyager bridge.
// @dev In current version, paying bridge fees is only possible with native token. (only depositETH is implemented)
contract RangoVoyagerFacet is IRango, ReentrancyGuard, IRangoVoyager {
    /// Storage ///
    /// @dev keccak256("exchange.rango.facets.voyager")
    bytes32 internal constant VOYAGER_NAMESPACE = hex"2237235c23b61f52702df59dac601909c9db9f9eb24657d730ec4417623a598e";

    struct VoyagerStorage {
        address routerBridgeAddress;
        address reserveHandlerAddress;
        address voyagerSpecificNativeWrappedAddress;
    }

    /// Events ///

    /// @notice Emits when the Voyager address is updated
    /// @param _oldAddress The previous address
    /// @param _newAddress The new address
    event RouterBridgeAddressUpdated(address _oldAddress, address _newAddress);
    /// @notice Emits when the Voyager address is updated
    /// @param _oldAddress The previous address
    /// @param _newAddress The new address
    event ReserveHandlerAddressUpdated(address _oldAddress, address _newAddress);

    /// @notice Emits when Voyager deposit process is done
    event VoyagerDepositETH(
        uint8 destinationChainID,
        bytes32 resourceID,
        address sender,
        address fromToken,
        uint256 amount,
        address feeTokenAddress
    );

    /// @notice Initialize the contract.
    /// @param voyagerAddresses The address of WETH, WBNB, etc of the current network plus voyager contract address
    function initVoyager(VoyagerStorage calldata voyagerAddresses) external {
        LibDiamond.enforceIsContractOwner();
        updateRouterBridgeAddressInternal(voyagerAddresses.routerBridgeAddress);
        updateReserveHandlerAddressInternal(voyagerAddresses.reserveHandlerAddress);
        updateVoyagerSpecificNativeWrappedAddressInternal(voyagerAddresses.voyagerSpecificNativeWrappedAddress);
    }

    /// @notice update routerBridgeAddress
    /// @param _address routerBridgeAddress
    function updateVoyagerRouters(address _address) public {
        LibDiamond.enforceIsContractOwner();
        updateRouterBridgeAddressInternal(_address);
    }

    /// @notice update reserveHandler
    /// @param _address reserveHandler
    function updateVoyagerReserveHandler(address _address) public {
        LibDiamond.enforceIsContractOwner();
        updateReserveHandlerAddressInternal(_address);
    }

    /// @notice update voyagerSpecificNativeWrappedAddress
    /// @param _address voyagerSpecificNativeWrappedAddress
    function updateVoyagerSpecificNativeWrappedAddress(address _address) public {
        LibDiamond.enforceIsContractOwner();
        updateVoyagerSpecificNativeWrappedAddressInternal(_address);
    }

    function voyagerBridge(
        LibSwapper.SwapRequest memory request,
        LibSwapper.Call[] calldata calls,
        IRangoVoyager.VoyagerBridgeRequest memory bridgeRequest
    ) external payable nonReentrant {
        uint out;
        uint bridgeAmount;
        // if toToken is native coin and the user has not paid fee in msg.value,
        // then the user can pay bridge fee using output of swap.
        if (request.toToken == LibSwapper.ETH && msg.value == 0) {
            out = LibSwapper.onChainSwapsPreBridge(request, calls, 0);
            bridgeAmount = out - bridgeRequest.feeAmount;
        }
        else {
            out = LibSwapper.onChainSwapsPreBridge(request, calls, bridgeRequest.feeAmount);
            bridgeAmount = out;
        }

        doVoyagerBridge(bridgeRequest, request.toToken, bridgeAmount);
    }

    function voyagerBridge(
        IRangoVoyager.VoyagerBridgeRequest memory bridgeRequest,
        address token,
        uint256 amount
    ) external payable nonReentrant {
        // transfer tokens if necessary
        if (token != LibSwapper.ETH) {
            SafeERC20.safeTransferFrom(IERC20(token), msg.sender, address(this), amount);
            require(msg.value >= bridgeRequest.feeAmount, "Insufficient ETH for fee");
        } else {
            require(msg.value >= amount + bridgeRequest.feeAmount, "Insufficient ETH for bridging and fee");
        }
        doVoyagerBridge(bridgeRequest, token, amount);
    }

    /// @notice Executes an Voyager bridge call
    /// @param request The other required fields for Voyager bridge contract
    /// @param fromToken The erc20 address of the input token, 0x000...00 for native token
    /// @param amount Amount of tokens to deposit. Will be amount of tokens to receive less fees.
    function doVoyagerBridge(
        VoyagerBridgeRequest memory request,
        address fromToken,
        uint256 amount
    ) internal {
        VoyagerStorage storage s = getVoyagerStorage();
        address weth = s.voyagerSpecificNativeWrappedAddress;
        require(request.feeTokenAddress == weth,
            "Fee is only acceptable in native token in current version");
        uint approveAmount = request.feeAmount;
        if (fromToken != LibSwapper.ETH) {
            LibSwapper.approve(fromToken, s.reserveHandlerAddress, amount);
        } else {
            approveAmount = amount + approveAmount;
        }
        LibSwapper.approve(request.feeTokenAddress, s.reserveHandlerAddress, approveAmount);

        IVoyager voyager = IVoyager(s.routerBridgeAddress);

        callVoyager(voyager, request, fromToken, amount);

        emit VoyagerDepositETH(
            request.voyagerDestinationChainId,
            request.resourceID,
            msg.sender,
            fromToken,
            amount,
            request.feeTokenAddress
        );
    }

    function callVoyager(
        IVoyager voyager,
        VoyagerBridgeRequest memory request,
        address fromToken,
        uint256 amount
    ) private {
        bytes memory encodedParams = bytes.concat(
            abi.encode(
                amount,
                amount,
                request.dstTokenAmount,
                request.dstTokenAmount
            ), request.data
        );

        uint256[] memory flags;
        address[] memory path;
        bytes[] memory dataTx;

        voyager.depositETH{value : fromToken == LibSwapper.ETH ? amount + request.feeAmount : request.feeAmount}(
            request.voyagerDestinationChainId,
            request.resourceID,
            encodedParams,
            flags, path, dataTx,
            request.feeTokenAddress
        );
    }

    function updateRouterBridgeAddressInternal(address _address) private {
        VoyagerStorage storage s = getVoyagerStorage();
        address oldAddress = s.routerBridgeAddress;
        s.routerBridgeAddress = _address;
        emit RouterBridgeAddressUpdated(oldAddress, _address);
    }

    function updateReserveHandlerAddressInternal(address _address) private {
        VoyagerStorage storage s = getVoyagerStorage();
        address oldAddress = s.reserveHandlerAddress;
        s.reserveHandlerAddress = _address;
        emit ReserveHandlerAddressUpdated(oldAddress, _address);
    }

    function updateVoyagerSpecificNativeWrappedAddressInternal(address _address) private {
        VoyagerStorage storage s = getVoyagerStorage();
        address oldAddress = s.voyagerSpecificNativeWrappedAddress;
        s.voyagerSpecificNativeWrappedAddress = _address;
        emit ReserveHandlerAddressUpdated(oldAddress, _address);
    }

    /// @dev fetch local storage
    function getVoyagerStorage() private pure returns (VoyagerStorage storage s) {
        bytes32 namespace = VOYAGER_NAMESPACE;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            s.slot := namespace
        }
    }
}

// File: contracts/facets/bridges/RangoWormholeFacet.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "../../interfaces/IWETH.sol";
import "../../interfaces/IRangoWormhole.sol";
import "../../interfaces/IRango.sol";
import "../../interfaces/IWormholeRouter.sol";
import "../../interfaces/IWormholeTokenBridge.sol";
import "../../interfaces/WormholeBridgeStructs.sol";
import "../../utils/ReentrancyGuard.sol";
import "../../libraries/LibSwapper.sol";
import "../../libraries/LibDiamond.sol";
import "../../interfaces/Interchain.sol";

/// @title The root contract that handles Rango's interaction with wormhole
/// @author AMA
contract RangoWormholeFacet is IRango, ReentrancyGuard, IRangoWormhole {

    /// Storage ///
    /// @dev keccak256("exchange.rango.facets.wormhole")
    bytes32 internal constant WORMHOLE_NAMESPACE = hex"793f7e3915857b52a2ca33e83f8b2c68a049de66d28e53738de96c395c5ad94d";

    struct WormholeStorage {
        /// @notice The address of wormhole contract
        address wormholeRouter;
    }

    /// @notice Emits when the wormhole address is updated
    /// @param _oldAddress The previous address
    /// @param _newAddress The new address
    event WormholeAddressUpdated(address _oldAddress, address _newAddress);

    /// @notice Initialize the contract.
    /// @param wormholeRouter The contract address of wormhole contract.
    function initWormhole(address wormholeRouter) external {
        LibDiamond.enforceIsContractOwner();
        updateWormholeAddressInternal(wormholeRouter);
    }

    /// @notice Updates the address of wormhole contract
    /// @param _address The new address of wormhole contract
    function updateWormholeAddress(address _address) public {
        LibDiamond.enforceIsContractOwner();
        updateWormholeAddressInternal(_address);
    }

    /// @notice Emits when a token bridge request is sent to wormhole bridge
    /// @param token The token address in the current network that is being bridged
    /// @param inputAmount The latest observed amount in the path, aka: input amount for source and output amount on dest
    /// @param source The source address that initiated the transaction
    /// @param destination The destination address that received the money, ZERO address if not sent to the end-user yet
    event WormholeDeposit(address token, uint256 inputAmount, address source, address destination);

    /// @notice Executes a DEX (arbitrary) call + a wormhole bridge function
    /// @param request The general swap request containing from/to token and fee/affiliate rewards
    /// @param calls The list of DEX calls, if this list is empty, it means that there is no DEX call and we are only bridging
    /// @param bridgeRequest data related to wormhole bridge
    /// @dev The wormhole bridge part is handled in the RangoWormhole.sol contract
    /// @dev If this function is a success, user will automatically receive the fund in the destination in their wallet (receiver)
    function wormholeSwapAndBridge(
        LibSwapper.SwapRequest memory request,
        LibSwapper.Call[] calldata calls,
        IRangoWormhole.WormholeBridgeRequest memory bridgeRequest
    ) external payable nonReentrant {
        uint out = LibSwapper.onChainSwapsPreBridge(request, calls, 0);
        doWormholeBridge(bridgeRequest, request.toToken, out);

        bool hasInterchainMessage = false;
        bool hasDestSwap = false;
        if (bridgeRequest.bridgeType == WormholeBridgeType.TRANSFER_WITH_MESSAGE) {
            hasInterchainMessage = true;
            Interchain.RangoInterChainMessage memory imMessage = abi.decode((bridgeRequest.imMessage), (Interchain.RangoInterChainMessage));
            hasDestSwap = imMessage.actionType != Interchain.ActionType.NO_ACTION;
        }

        // event emission
        emit RangoBridgeInitiated(
            request.requestId,
            request.toToken,
            out,
            address(uint160(bytes20(bridgeRequest.targetAddress))),
            "",
            bridgeRequest.recipientChain,
            hasInterchainMessage,
            hasDestSwap,
            uint8(BridgeType.Wormhole),
            request.dAppTag
        );
    }

    /// @notice Executes a wormhole bridge function
    /// @param request data related to wormhole bridge
    /// @param bridgeRequest data related to wormhole bridge
    function wormholeBridge(
        IRangoWormhole.WormholeBridgeRequest memory request,
        IRango.RangoBridgeRequest memory bridgeRequest
    ) external payable nonReentrant {
        uint256 amountWithFee = bridgeRequest.amount + LibSwapper.sumFees(bridgeRequest);
        // transfer tokens if necessary
        if (bridgeRequest.token == LibSwapper.ETH) {
            require(msg.value >= amountWithFee, "Insufficient ETH sent for bridging");
        } else {
            SafeERC20.safeTransferFrom(IERC20(bridgeRequest.token), msg.sender, address(this), amountWithFee);
        }

        LibSwapper.collectFees(bridgeRequest);
        doWormholeBridge(request, bridgeRequest.token, bridgeRequest.amount);

        bool hasInterchainMessage = false;
        bool hasDestSwap = false;
        if (request.bridgeType == WormholeBridgeType.TRANSFER_WITH_MESSAGE) {
            hasInterchainMessage = true;
            Interchain.RangoInterChainMessage memory imMessage = abi.decode((request.imMessage), (Interchain.RangoInterChainMessage));
            hasDestSwap = imMessage.actionType != Interchain.ActionType.NO_ACTION;
        }

        // event emission
        emit RangoBridgeInitiated(
            bridgeRequest.requestId,
            bridgeRequest.token,
            bridgeRequest.amount,
            address(uint160(bytes20(request.targetAddress))),
            "",
            request.recipientChain,
            hasInterchainMessage,
            hasDestSwap,
            uint8(BridgeType.Wormhole),
            bridgeRequest.dAppTag
        );
    }

    /// @notice Executes a bridging via wormhole
    /// @param request The extra fields required by the wormhole bridge
    /// @param token The requested token to bridge
    /// @param amount The requested amount to bridge
    function doWormholeBridge(
        IRangoWormhole.WormholeBridgeRequest memory request,
        address token,
        uint256 amount
    ) internal {
        WormholeStorage storage s = getWormholeStorage();
        require(s.wormholeRouter != LibSwapper.ETH, 'Wormhole address not set');

        if (request.bridgeType == WormholeBridgeType.TRANSFER_WITH_MESSAGE) {
            Interchain.RangoInterChainMessage memory imMessage = abi.decode((request.imMessage), (Interchain.RangoInterChainMessage));
            if (token == LibSwapper.ETH) {
                IWormholeRouter(s.wormholeRouter).wrapAndTransferETHWithPayload{value : amount}(
                    request.recipientChain,
                    request.targetAddress,
                    request.nonce,
                    request.imMessage
                );
            } else {
                IWormholeRouter(s.wormholeRouter).transferTokensWithPayload(
                    request.fromAddress,
                    amount,
                    request.recipientChain,
                    request.targetAddress,
                    request.nonce,
                    request.imMessage
                );
            }
            emit WormholeDeposit(
                token,
                amount,
                imMessage.originalSender, // TODO: check if this should be msg.sender instead of imMessage.originalSender
                imMessage.recipient
            );
        } else {
            if (token == LibSwapper.ETH) {
                IWormholeRouter(s.wormholeRouter).wrapAndTransferETH{value : amount}(
                    request.recipientChain,
                    request.targetAddress,
                    request.fee,
                    request.nonce
                );
            } else {
                IWormholeRouter(s.wormholeRouter).transferTokens(
                    request.fromAddress,
                    amount,
                    request.recipientChain,
                    request.targetAddress,
                    request.fee,
                    request.nonce
                );
            }
        }
    }

    function updateWormholeAddressInternal(address _address) private {
        WormholeStorage storage s = getWormholeStorage();
        address oldAddress = s.wormholeRouter;
        s.wormholeRouter = _address;
        emit WormholeAddressUpdated(oldAddress, _address);
    }

    /// @dev fetch local storage
    function getWormholeStorage() private pure returns (WormholeStorage storage s) {
        bytes32 namespace = WORMHOLE_NAMESPACE;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            s.slot := namespace
        }
    }
}

// File: contracts/facets/bridges/RangoWormholeMiddleware.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "../../libraries/LibInterchain.sol";
import "../../utils/ReentrancyGuard.sol";
import "../base/RangoBaseInterchainMiddleware.sol";
import "../../interfaces/IWormholeRouter.sol";
import "../../interfaces/IWormholeTokenBridge.sol";
import "../../interfaces/WormholeBridgeStructs.sol";

/// @title The middleware contract that handles Rango's receive messages from wormhole.
/// @author AMA
/// @dev Note that this is not a facet and should be deployed separately.
contract RangoWormholeMiddleware is ReentrancyGuard, IRango, RangoBaseInterchainMiddleware {

    /// @dev keccak256("exchange.rango.middleware.wormhole")
    bytes32 internal constant WORMHOLE_MIDDLEWARE_NAMESPACE = hex"03b65cc2ae1a0403a8a39c713a7539556dcb0e1f9e232988c2d31a10f06ab207";

    struct RangoWormholeMiddlewareStorage {
        address wormholeRouter;
    }

    constructor(
        address _owner,
        address _wormholeRouter,
        address _weth
    ) RangoBaseInterchainMiddleware(_owner, address(0), _weth){
        updateWormholeRouterAddressInternal(_wormholeRouter);
    }

    /// Events

    /// @notice Emits when the Wormhole address is updated
    /// @param oldAddress The previous address
    /// @param newAddress The new address
    event WormholeRouterAddressUpdated(address oldAddress, address newAddress);

    /// External Functions

    /// @notice Updates the address of wormholeRouter
    /// @param newAddress The new address of owner
    function updateWormholeRouter(address newAddress) external onlyOwner {
        updateWormholeRouterAddressInternal(newAddress);
    }

    function completeTransferWithPayload(
        address expectedToken,
        bytes memory vaas
    ) external nonReentrant
    {
        require(expectedToken != LibSwapper.ETH,"received token can not be native");
        RangoWormholeMiddlewareStorage storage s = getRangoWormholeMiddlewareStorage();

        uint balanceBefore = IERC20(expectedToken).balanceOf(address(this));
        
        address wormholeTokenBridgeAddress = address(s.wormholeRouter);
        IWormholeTokenBridge whTokenBridge = IWormholeTokenBridge(wormholeTokenBridgeAddress);
        bytes memory payload = whTokenBridge.completeTransferWithPayload(vaas);
    
        WormholeBridgeStructs.TransferWithPayload memory transfer = whTokenBridge.parseTransferWithPayload(payload);
        Interchain.RangoInterChainMessage memory m = abi.decode((transfer.payload), (Interchain.RangoInterChainMessage));
        
        uint balanceAfter = IERC20(expectedToken).balanceOf(address(this));
        require(balanceAfter-balanceBefore >= transfer.amount, "expected amount not transfered" );
        require(expectedToken == m.bridgeRealOutput, "expected token is not equal to received token");

        (,bytes memory queriedDecimals) = m.bridgeRealOutput.staticcall(abi.encodeWithSignature("decimals()"));
        uint8 decimals = abi.decode(queriedDecimals, (uint8));
        

        // adjust decimals
        uint256 exactAmount = deNormalizeAmount(transfer.amount, decimals);
        (address receivedToken, uint dstAmount, IRango.CrossChainOperationStatus status) = LibInterchain.handleDestinationMessage(
                m.bridgeRealOutput,
                exactAmount,
                m
        );
        emit RangoBridgeCompleted(
            m.requestId,
            receivedToken,
            m.originalSender,
            m.recipient,
            dstAmount,
            status,
            m.dAppTag
        );
    }

    function deNormalizeAmount(uint256 amount, uint8 decimals) internal pure returns(uint256){
        if (decimals > 8) {
            amount *= 10 ** (decimals - 8);
        }
        return amount;
    }

    /// Private and Internal
    function updateWormholeRouterAddressInternal(address newAddress) private {
        RangoWormholeMiddlewareStorage storage s = getRangoWormholeMiddlewareStorage();
        address oldAddress = s.wormholeRouter;
        s.wormholeRouter = newAddress;
        emit WormholeRouterAddressUpdated(oldAddress, newAddress);
    }

    /// @dev fetch local storage
    function getRangoWormholeMiddlewareStorage() private pure returns (RangoWormholeMiddlewareStorage storage s) {
        bytes32 namespace = WORMHOLE_MIDDLEWARE_NAMESPACE;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            s.slot := namespace
        }
    }
}

// File: contracts/facets/bridges/thorchain/RangoThorchainFacet.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "../../../interfaces/IThorchainRouter.sol";
import "../../../interfaces/IRangoThorchain.sol";
import "../../../interfaces/IRango.sol";
import "../../../libraries/LibSwapper.sol";
import "../../../utils/ReentrancyGuard.sol";

/// @title A contract to handle interactions with Thorchain Router contract on evm chains.
/// @author Thinking Particle
/// @notice This facet interacts with thorchain router.
/// @dev This contract checks for basic validation and also checks that provided thorchain router is whitelisted.
contract RangoThorchainFacet is IRango, IRangoThorchain, ReentrancyGuard {
    /// @notice emitted to notify that a swap to thorchain has been initiated by rango and provides the parameters used for the swap.
    /// @param vault The vault address of Thorchain. This cannot be hardcoded because Thorchain rotates vaults.
    /// @param token The token contract address (if token is native, should be 0x0000000000000000000000000000000000000000)
    /// @param amount The amount of token to be swapped. It should be positive and if token is native, msg.value should be bigger than amount.
    /// @param memo The transaction memo used by Thorchain which contains the thorchain swap data. More info: https://dev.thorchain.org/thorchain-dev/memos
    /// @param expiration The expiration block number. If the tx is included after this block, it will be reverted.
    event ThorchainTxInitiated(address vault, address token, uint amount, string memo, uint expiration);

    receive() external payable {}

    /// @notice Swap tokens if necessary, then pass it to RangoThorchain
    /// @dev Swap tokens if necessary, then pass it to RangoThorchain. If no swap is required (calls.length==0) the provided token is passed to RangoThorchain without change.
    /// @param request The swap information used to check input and output token addresses and balances, as well as the fees if any. Together with calls param, determines the swap logic before passing to Thorchain.
    /// @param calls The contract call data that is used to swap (can be empty if no swap is needed). Together with request param, determines the swap logic before passing to Thorchain.
    /// @param tcRouter The router contract address of Thorchain. This cannot be hardcoded because Thorchain can upgrade its router and the address might change.
    /// @param tcVault The vault address of Thorchain. This cannot be hardcoded because Thorchain rotates vaults.
    /// @param thorchainMemo The transaction memo used by Thorchain which contains the thorchain swap data. More info: https://dev.thorchain.org/thorchain-dev/memos
    /// @param expiration The expiration block number. If the tx is included after this block, it will be reverted.
    function thorchainSwapAndBridge(
        LibSwapper.SwapRequest memory request,
        LibSwapper.Call[] calldata calls,
        address tcRouter,
        address tcVault,
        string calldata thorchainMemo,
        uint expiration
    ) external payable nonReentrant {
        uint out = LibSwapper.onChainSwapsPreBridge(request, calls, 0);
        if (request.toToken != LibSwapper.ETH) {
            LibSwapper.approve(request.toToken, tcRouter, out);
        }

        doSwapInToThorchain(
            request.toToken,
            out,
            tcRouter,
            tcVault,
            thorchainMemo,
            expiration
        );
        // event emission
        emit RangoBridgeInitiated(
            request.requestId,
            request.toToken,
            out,
            LibSwapper.ETH,
            "",
            0,
            false,
            false,
            uint8(BridgeType.Thorchain),
            request.dAppTag
        );
    }

    /// @notice Do a swap through thorchain
    /// @param request The necessary data for bridging
    /// @param tcRouter The router contract address of Thorchain. This cannot be hardcoded because Thorchain can upgrade its router and the address might change.
    /// @param tcVault The vault address of Thorchain. This cannot be hardcoded because Thorchain rotates vaults.
    /// @param thorchainMemo The transaction memo used by Thorchain which contains the thorchain swap data. More info: https://dev.thorchain.org/thorchain-dev/memos
    /// @param expiration The expiration block number. If the tx is included after this block, it will be reverted.
    function thorchainBridge(
        RangoBridgeRequest memory request,
        address tcRouter,
        address tcVault,
        string calldata thorchainMemo,
        uint expiration
    ) external payable nonReentrant {
        uint amount = request.amount;
        uint amountWithFee = amount + LibSwapper.sumFees(request);
        address token = request.token;
        if (token == LibSwapper.ETH) {
            require(msg.value >= amountWithFee, "insufficient ETH sent");
        } else {
            SafeERC20.safeTransferFrom(IERC20(token), msg.sender, address(this), amountWithFee);
            LibSwapper.approve(token, tcRouter, amount);
        }
        LibSwapper.collectFees(request);

        doSwapInToThorchain(
            token,
            amount,
            tcRouter,
            tcVault,
            thorchainMemo,
            expiration
        );

        // event emission
        emit RangoBridgeInitiated(
            request.requestId,
            token,
            amount,
            LibSwapper.ETH,
            "",
            0,
            false,
            false,
            uint8(BridgeType.Thorchain),
            request.dAppTag
        );
    }

    /// @notice Defines parameters used for swapIn functionality on thorchain router.
    /// @param token The token contract address (if token is native, should be 0x0000000000000000000000000000000000000000)
    /// @param amount The amount of token to be swapped. It should be positive and if token is native, msg.value should be bigger than amount.
    /// @param tcRouter The router contract address of Thorchain. This cannot be hardcoded because Thorchain can upgrade its router and the address might change.
    /// @param tcVault The vault address of Thorchain. This cannot be hardcoded because Thorchain rotates vaults.
    /// @param thorchainMemo The transaction memo used by Thorchain which contains the thorchain swap data. More info: https://dev.thorchain.org/thorchain-dev/memos
    /// @param expiration The expiration block number. If the tx is included after this block, it will be reverted.
    function doSwapInToThorchain(
        address token,
        uint amount,
        address tcRouter,
        address tcVault,
        string calldata thorchainMemo,
        uint expiration
    ) internal {
        LibSwapper.BaseSwapperStorage storage baseStorage = LibSwapper.getBaseSwapperStorage();
        require(baseStorage.whitelistContracts[tcRouter], "given thorchain router not whitelisted");

        IThorchainRouter(tcRouter).depositWithExpiry{value : token == LibSwapper.ETH ? amount : 0}(
            payable(tcVault), // address payable vault,
            token, // address asset,
            amount, // uint amount,
            thorchainMemo, // string calldata memo,
            expiration  // uint expiration) external payable;
        );
        emit ThorchainTxInitiated(tcVault, token, amount, thorchainMemo, expiration);
    }

}

// File: contracts/facets/bridges/thorchain/RangoThorchainOutputAggUniV2.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "../../../interfaces/IThorchainRouter.sol";
import "../../../interfaces/IUniswapV2.sol";

/// @title Contract to handle thorchain output and pass it to a dex that implements UniV2 interface.
/// @author Thinking Particle
/// @notice Thorchain provides native token on destination chain. To swap it to desired token, this contract passes the native token to a dex.
/// @dev Thorchain only provides the desired token and the minimum amount to be received. Therefore, we cannot implement a single contract that supports all dexes. Instead we should deploy multiple instances of this contract for each dex and find the best one when creating the input transaction.
contract RangoThorchainOutputAggUniV2 is ReentrancyGuard {
    /// @dev wrapped native token contract address
    address public WETH;
    /// @dev router contract address which implements UniswapV2 router
    IUniswapV2 public dexRouter;

    /// @param _weth wrapped native token contract address
    /// @param _dexRouter router contract address which implements UniswapV2 router
    constructor(address _weth, address _dexRouter) {
        WETH = _weth;
        dexRouter = IUniswapV2(_dexRouter);
    }

    /// @dev This contract is only implemented to handle for swap output of thorchain. Therefore swapIn function is implemented as a revert to make sure that it won't be called as swapIn handler.
    function swapIn(
        address,
        address,
        string calldata,
        address,
        uint,
        uint,
        uint
    ) public nonReentrant {
        revert("this contract only supports swapOut");
    }

    /// @notice This function is called by thorchain nodes. It receives native token and swaps it to the desired token using the dex.
    /// @dev This function creates a simple 1 step path for uniswap v2 router. Note that this function can be called by anyone including (thorchain nodes).
    /// @param token The desired token contract address
    /// @param to The wallet address should receive the output.
    /// @param amountOutMin The minimum output amount below which the swap is invalid.
    function swapOut(address token, address to, uint256 amountOutMin) public payable nonReentrant {
        address[] memory path = new address[](2);
        path[0] = WETH;
        path[1] = token;
        dexRouter.swapExactETHForTokens{value : msg.value}(amountOutMin, path, to, type(uint).max);
    }

}

// File: contracts/facets/bridges/thorchain/RangoThorchainOutputAggUniV3.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "../../../interfaces/IThorchainRouter.sol";
import "../../../interfaces/IUniswapV3.sol";
import "../../../interfaces/IWETH.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

/// @title Contract to handle thorchain output and pass it to a dex that implements UniV3 interface.
/// @author Thinking Particle
/// @notice Thorchain provides native token on destination chain. To swap it to desired token, this contract passes the native token to a dex.
/// @dev Thorchain only provides the desired token and the minimum amount to be received. Therefore, we cannot implement a single contract that supports all dexes. Instead we should deploy multiple instances of this contract for each dex and find the best one when creating the input transaction.
contract RangoThorchainOutputAggUniV3 is ReentrancyGuard {
    /// @dev wrapped native token interface
    IWETH public nativeWrappedToken;
    /// @dev router contract address which implements UniswapV3 router
    IUniswapV3 public dexRouter;
    /// @dev pool fee value of UniswapV3
    uint24 public v3PoolFee;

    /// @param _weth The contract address of wrapped native token
    /// @param _dexRouter The contract address of UniswapV3 router
    /// @param _v3PoolFee The pool fee value of UniswapV3
    constructor(address _weth, address _dexRouter, uint24 _v3PoolFee) {
        nativeWrappedToken = IWETH(_weth);
        dexRouter = IUniswapV3(_dexRouter);
        v3PoolFee = _v3PoolFee;
    }

    /// @dev This contract is only implemented to handle for swap output of thorchain. Therefore swapIn function is implemented as a revert to make sure that it won't be called as swapIn handler.
    function swapIn(
        address,
        address,
        string calldata,
        address,
        uint,
        uint,
        uint
    ) public nonReentrant {
        revert("this contract only supports swapOut");
    }

    /// @notice This function is called by thorchain nodes. It receives native token and swaps it to the desired token using the dex.
    /// @dev This function creates a simple 1 step path for uniswap v2 router. Note that this function can be called by anyone including (thorchain nodes).
    /// @param token The desired token contract address
    /// @param to The wallet address should receive the output.
    /// @param amountOutMin The minimum output amount below which the swap is invalid.
    function swapOut(address token, address to, uint256 amountOutMin) public payable nonReentrant {
        nativeWrappedToken.deposit{value : msg.value}();
        SafeERC20.safeIncreaseAllowance(IERC20(address(nativeWrappedToken)), address(dexRouter), msg.value);
        dexRouter.exactInputSingle(
            IUniswapV3.ExactInputSingleParams(
            {
            tokenIn : address(nativeWrappedToken),
            tokenOut : token,
            fee : v3PoolFee,
            recipient : to,
            deadline : type(uint).max,
            amountIn : msg.value,
            amountOutMinimum : amountOutMin,
            sqrtPriceLimitX96 : 0
            })
        );
    }

}

// File: contracts/interfaces/IAcrossSpokePool.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

/// @title The root contract that handles Rango's interaction with Across bridge
/// @author Uchiha Sasuke
interface IAcrossSpokePool {
    function deposit(
        address recipient,
        address originToken,
        uint256 amount,
        uint256 destinationChainId,
        uint64 relayerFeePct,
        uint32 quoteTimestamp
    ) external payable;
}

// File: contracts/interfaces/IAllBridgeRouter.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.16;

interface IAllBridgeRouter {

    enum MessengerProtocol {
        None,
        Allbridge,
        Wormhole,
        LayerZero
    }

    function swapAndBridge(
        bytes32 tokenAddress,
        uint256 amount,
        bytes32 recipient,
        uint8 destinationChainId,
        bytes32 receiveTokenAddress,
        uint256 nonce,
        MessengerProtocol messenger) external payable;


    // mapping(bytes32 => Pool) public pools;
    function pools(bytes32 b) external returns (address);
}

// File: contracts/interfaces/IArbitrumBridgeInbox.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

/// @title The interface for interacting with arbitrum bridge delayed inbox
/// @author AMA
interface IArbitrumBridgeInbox {
    /**
     * @notice Put a message in the L2 inbox that can be reexecuted for some fixed amount of time if it reverts
     * @dev Same as createRetryableTicket, but does not guarantee that submission will succeed by requiring the needed funds
     * come from the deposit alone, rather than falling back on the user's L2 balance
     * @dev Advanced usage only (does not rewrite aliases for excessFeeRefundAddress and callValueRefundAddress).
     * createRetryableTicket method is the recommended standard.
     * @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error
     * @param to destination L2 contract address
     * @param l2CallValue call value for retryable L2 message
     * @param maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee
     * @param excessFeeRefundAddress gasLimit x maxFeePerGas - execution cost gets credited here on L2 balance
     * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled
     * @param gasLimit Max gas deducted from user's L2 balance to cover L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)
     * @param maxFeePerGas price bid for L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)
     * @param data ABI encoded data of L2 message
     * @return unique message number of the retryable transaction
     */
    function unsafeCreateRetryableTicket(
        address to,
        uint256 l2CallValue,
        uint256 maxSubmissionCost,
        address excessFeeRefundAddress,
        address callValueRefundAddress,
        uint256 gasLimit,
        uint256 maxFeePerGas,
        bytes calldata data
    ) external payable returns (uint256);
}

// File: contracts/interfaces/IArbitrumBridgeRouter.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

/// @title The interface for interacting with arbitrum bridge router
/// @author AMA
interface IArbitrumBridgeRouter {
    function getGateway(address _token) external view returns (address gateway);

    function outboundTransfer(
        address _token,
        address _to,
        uint256 _amount,
        uint256 _maxGas,
        uint256 _gasPriceBid,
        bytes calldata _data
    ) external payable returns (bytes memory);
}

// File: contracts/interfaces/IAxelarExecutable.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.16;

import { IAxelarGateway } from './IAxelarGateway.sol';

abstract contract IAxelarExecutable {
    error NotApprovedByGateway();

    function _execute(
        string memory sourceChain,
        string memory sourceAddress,
        bytes calldata payload
    ) internal virtual {}

    function _executeWithToken(
        string memory sourceChain,
        string memory sourceAddress,
        bytes calldata payload,
        string memory tokenSymbol,
        uint256 amount
    ) internal virtual {}

}

// File: contracts/interfaces/IAxelarGasService.sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.16;

import './IUpgradable.sol';

// This should be owned by the microservice that is paying for gas.
interface IAxelarGasService is IUpgradable {
    error NothingReceived();
    error TransferFailed();
    error InvalidAddress();
    error NotCollector();
    error InvalidAmounts();

    event GasPaidForContractCall(
        address indexed sourceAddress,
        string destinationChain,
        string destinationAddress,
        bytes32 indexed payloadHash,
        address gasToken,
        uint256 gasFeeAmount,
        address refundAddress
    );

    event GasPaidForContractCallWithToken(
        address indexed sourceAddress,
        string destinationChain,
        string destinationAddress,
        bytes32 indexed payloadHash,
        string symbol,
        uint256 amount,
        address gasToken,
        uint256 gasFeeAmount,
        address refundAddress
    );

    event NativeGasPaidForContractCall(
        address indexed sourceAddress,
        string destinationChain,
        string destinationAddress,
        bytes32 indexed payloadHash,
        uint256 gasFeeAmount,
        address refundAddress
    );

    event NativeGasPaidForContractCallWithToken(
        address indexed sourceAddress,
        string destinationChain,
        string destinationAddress,
        bytes32 indexed payloadHash,
        string symbol,
        uint256 amount,
        uint256 gasFeeAmount,
        address refundAddress
    );

    event GasAdded(bytes32 indexed txHash, uint256 indexed logIndex, address gasToken, uint256 gasFeeAmount, address refundAddress);

    event NativeGasAdded(bytes32 indexed txHash, uint256 indexed logIndex, uint256 gasFeeAmount, address refundAddress);

    // This is called on the source chain before calling the gateway to execute a remote contract.
    function payGasForContractCall(
        address sender,
        string calldata destinationChain,
        string calldata destinationAddress,
        bytes calldata payload,
        address gasToken,
        uint256 gasFeeAmount,
        address refundAddress
    ) external;

    // This is called on the source chain before calling the gateway to execute a remote contract.
    function payGasForContractCallWithToken(
        address sender,
        string calldata destinationChain,
        string calldata destinationAddress,
        bytes calldata payload,
        string calldata symbol,
        uint256 amount,
        address gasToken,
        uint256 gasFeeAmount,
        address refundAddress
    ) external;

    // This is called on the source chain before calling the gateway to execute a remote contract.
    function payNativeGasForContractCall(
        address sender,
        string calldata destinationChain,
        string calldata destinationAddress,
        bytes calldata payload,
        address refundAddress
    ) external payable;

    // This is called on the source chain before calling the gateway to execute a remote contract.
    function payNativeGasForContractCallWithToken(
        address sender,
        string calldata destinationChain,
        string calldata destinationAddress,
        bytes calldata payload,
        string calldata symbol,
        uint256 amount,
        address refundAddress
    ) external payable;

    function addGas(
        bytes32 txHash,
        uint256 txIndex,
        address gasToken,
        uint256 gasFeeAmount,
        address refundAddress
    ) external;

    function addNativeGas(
        bytes32 txHash,
        uint256 logIndex,
        address refundAddress
    ) external payable;

    function collectFees(
        address payable receiver,
        address[] calldata tokens,
        uint256[] calldata amounts
    ) external;

    function refund(
        address payable receiver,
        address token,
        uint256 amount
    ) external;

    function gasCollector() external returns (address);
}

// File: contracts/interfaces/IAxelarGateway.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.16;

interface IAxelarGateway {

    function sendToken(
        string calldata destinationChain,
        string calldata destinationAddress,
        string calldata symbol,
        uint256 amount
    ) external;

    function callContract(
        string calldata destinationChain,
        string calldata contractAddress,
        bytes calldata payload
    ) external;

    function callContractWithToken(
        string calldata destinationChain,
        string calldata contractAddress,
        bytes calldata payload,
        string calldata symbol,
        uint256 amount
    ) external;

    function validateContractCall(
        bytes32 commandId,
        string calldata sourceChain,
        string calldata sourceAddress,
        bytes32 payloadHash
    ) external returns (bool);

    function validateContractCallAndMint(
        bytes32 commandId,
        string calldata sourceChain,
        string calldata sourceAddress,
        bytes32 payloadHash,
        string calldata symbol,
        uint256 amount
    ) external returns (bool);

    function tokenAddresses(string memory symbol) external view returns (address);
}

// File: contracts/interfaces/IDiamondCut.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.16;

interface IDiamondCut {
    enum FacetCutAction {
        Add,
        Replace,
        Remove
    }
    // Add=0, Replace=1, Remove=2

    struct FacetCut {
        address facetAddress;
        FacetCutAction action;
        bytes4[] functionSelectors;
    }

    /// @notice Add/replace/remove any number of functions and optionally execute
    ///         a function with delegatecall
    /// @param _diamondCut Contains the facet addresses and function selectors
    /// @param _init The address of the contract or facet to execute _calldata
    /// @param _calldata A function call, including function selector and arguments
    ///                  _calldata is executed with delegatecall on _init
    function diamondCut(
        FacetCut[] calldata _diamondCut,
        address _init,
        bytes calldata _calldata
    ) external;

    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);
}


// File: contracts/interfaces/IDiamondLoupe.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.16;

// A loupe is a small magnifying glass used to look at diamonds.
// These functions look at diamonds
interface IDiamondLoupe {
    /// These functions are expected to be called frequently
    /// by tools.

    struct Facet {
        address facetAddress;
        bytes4[] functionSelectors;
    }

    /// @notice Gets all facet addresses and their four byte function selectors.
    /// @return facets_ Facet
    function facets() external view returns (Facet[] memory facets_);

    /// @notice Gets all the function selectors supported by a specific facet.
    /// @param _facet The facet address.
    /// @return facetFunctionSelectors_
    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);

    /// @notice Get all the facet addresses used by a diamond.
    /// @return facetAddresses_
    function facetAddresses() external view returns (address[] memory facetAddresses_);

    /// @notice Gets the facet that supports the given selector.
    /// @dev If facet is not found return address(0).
    /// @param _functionSelector The function selector.
    /// @return facetAddress_ The facet address.
    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);
}


// File: contracts/interfaces/IERC165.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.16;

interface IERC165 {
    /// @notice Query if a contract implements an interface
    /// @param interfaceId The interface identifier, as specified in ERC-165
    /// @dev Interface identification is specified in ERC-165. This function
    ///  uses less than 30,000 gas.
    /// @return `true` if the contract implements `interfaceID` and
    ///  `interfaceID` is not 0xffffffff, `false` otherwise
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}


// File: contracts/interfaces/IERC173.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.16;

/// @title ERC-173 Contract Ownership Standard
///  Note: the ERC-165 identifier for this interface is 0x7f5828d0
/* is ERC165 */
interface IERC173 {
    /// @dev This emits when ownership of a contract changes.
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /// @notice Get the address of the owner
    /// @return owner_ The address of the owner.
    function owner() external view returns (address owner_);

    /// @notice Set the address of the new owner of the contract
    /// @dev Set _newOwner to address(0) to renounce any ownership.
    /// @param _newOwner The address of the new owner of the contract
    function transferOwnership(address _newOwner) external;
}


// File: contracts/interfaces/IHop.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

/// @title The root contract that handles Rango's interaction with Hop bridge
/// @author Uchiha Sasuke
interface IHop {
    function swapAndSend(
        uint256 chainId,
        address recipient,
        uint256 amount,
        uint256 bonderFee,
        uint256 amountOutMin,
        uint256 deadline,
        uint256 destinationAmountOutMin,
        uint256 destinationDeadline
    ) external payable;

    function sendToL2(
        uint256 chainId,
        address recipient,
        uint256 amount,
        uint256 amountOutMin,
        uint256 deadline,
        address relayer,
        uint256 relayerFee
    ) external payable;
}

// File: contracts/interfaces/IHyphenBridge.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.16;

/// @title An interface to RangoHyphen.sol contract to improve type hinting
/// @author Hellboy
interface IHyphenBridge {

    /// @notice Executes a hyphen bridge call for native tokens
    /// @param receiver The receiver address in the destination chain
    /// @param toChainId The network id of destination chain, ex: 56 for BSC
    /// @param tag The tag string that is only used for analytics purposes in hyphen
    function depositNative(
        address receiver,
        uint256 toChainId,
        string calldata tag
    ) external payable;

    /// @notice Executes a hyphen bridge call for ERC20 (non-native) tokens
    /// @param receiver The receiver address in the destination chain
    /// @param toChainId The network id of destination chain, ex: 56 for BSC
    /// @param tokenAddress The requested token to bridge
    /// @param amount The requested amount to bridge
    /// @param tag The tag string that is only used for analytics purposes in hyphen
    function depositErc20(
        uint256 toChainId,
        address tokenAddress,
        address receiver,
        uint256 amount,
        string calldata tag
    ) external;

}

// File: contracts/interfaces/IMultichainRouter.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

/// @title The root contract that handles Rango's interaction with MultichainOrg bridge
/// @author George
interface IMultichainRouter {
    function anySwapOutUnderlying(address token, address to, uint amount, uint toChainID) external;
    function anySwapOutNative(address token, address to, uint toChainID) external payable;
    function anySwapOut(address token, address to, uint amount, uint toChainID) external;
}

interface IMultichainV7Router {
    // Swaps `amount` `token` from this chain to `toChainID` chain and call anycall proxy with `data`
    // `to` is the fallback receive address when exec failed on the `destination` chain
    function anySwapOutAndCall(
        address token,
        string calldata to,
        uint256 amount,
        uint256 toChainID,
        string calldata anycallProxy,
        bytes calldata data
    ) external;

    // Swaps `amount` `token` from this chain to `toChainID` chain and call anycall proxy with `data`
    // `to` is the fallback receive address when exec failed on the `destination` chain
    function anySwapOutUnderlyingAndCall(
        address token,
        string calldata to,
        uint256 amount,
        uint256 toChainID,
        string calldata anycallProxy,
        bytes calldata data
    ) external;

    // Swaps `msg.value` `Native` from this chain to `toChainID` chain and call anycall proxy with `data`
    // `to` is the fallback receive address when exec failed on the `destination` chain
    function anySwapOutNativeAndCall(
        address token,
        string calldata to,
        uint256 toChainID,
        string calldata anycallProxy,
        bytes calldata data
    ) external payable;
}

/// IAnycallProxy interface of the anycall proxy
interface IAnycallProxy {
    /// @notice Executor function (called in destination chain)
    /// Note that the onlyAllowedExecutors limits the caller of this function to be only allowed executors.
    /// @param token The token that is received on destination
    /// @param receiver The address that should receive tokens in case of failure as a fallback.
    /// @param amount Token amount
    /// @param data The data sent along with the token
    function exec(
        address token,
        address receiver,
        uint256 amount,
        bytes calldata data
    ) external returns (bool success, bytes memory result);
}


// File: contracts/interfaces/Interchain.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

/// @title An interface to interchain message types
/// @author Uchiha Sasuke
interface Interchain {
    enum ActionType { NO_ACTION, UNI_V2, UNI_V3, WRAP, UNWRAP, CALL }
    enum CallSubActionType { WRAP, UNWRAP, NO_ACTION }

    struct RangoInterChainMessage {
        address requestId;
        uint64 dstChainId;
        address bridgeRealOutput;
        address toToken;
        address originalSender;
        address recipient;
        ActionType actionType;
        bytes action;
        CallSubActionType postAction;
        uint16 dAppTag;

        // Extra message
        bytes dAppMessage;
        address dAppSourceContract;
        address dAppDestContract;
    }

    struct UniswapV2Action {
        address dexAddress;
        uint amountOutMin;
        address[] path;
        uint deadline;
    }

    struct UniswapV3ActionExactInputSingleParams {
        address dexAddress;
        address tokenIn;
        address tokenOut;
        uint24 fee;
        uint256 deadline;
        uint256 amountOutMinimum;
        uint160 sqrtPriceLimitX96;
    }

    /// @notice The requested call data which is computed off-chain and passed to the contract
    /// @param target The dex contract address that should be called
    /// @param callData The required data field that should be give to the dex contract to perform swap
    struct CallAction {
        address tokenIn;
        address spender;
        CallSubActionType preAction;
        address payable target;
        bytes callData;
    }
}

// File: contracts/interfaces/IOptimismL1XBridge.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

/// @title IOptimismL1XBridge
/// @author AMA
/// @dev This is the interface for interacting with optimis bridge from rango
interface IOptimismL1XBridge {
    /**********
     * Events *
     **********/
    event ETHDepositInitiated(
        address indexed _from,
        address indexed _to,
        uint256 _amount,
        bytes _data
    );

    event ETHWithdrawalFinalized(
        address indexed _from,
        address indexed _to,
        uint256 _amount,
        bytes _data
    );

    event ERC20DepositInitiated(
        address indexed _l1Token,
        address indexed _l2Token,
        address indexed _from,
        address _to,
        uint256 _amount,
        bytes _data
    );

    event ERC20WithdrawalFinalized(
        address indexed _l1Token,
        address indexed _l2Token,
        address indexed _from,
        address _to,
        uint256 _amount,
        bytes _data
    );

    /********************
     * Public Functions *
     ********************/

    /**
     * @dev Deposit an amount of the ETH to the caller's balance on L2.
     * @param _l2Gas Gas limit required to complete the deposit on L2.
     * @param _data Optional data to forward to L2. This data is provided
     *        solely as a convenience for external contracts. Aside from enforcing a maximum
     *        length, these contracts provide no guarantees about its content.
     */
    function depositETH(uint32 _l2Gas, bytes calldata _data) external payable;

    /**
     * @dev Deposit an amount of ETH to a recipient's balance on L2.
     * @param _to L2 address to credit the withdrawal to.
     * @param _l2Gas Gas limit required to complete the deposit on L2.
     * @param _data Optional data to forward to L2. This data is provided
     *        solely as a convenience for external contracts. Aside from enforcing a maximum
     *        length, these contracts provide no guarantees about its content.
     */
    function depositETHTo(
        address _to,
        uint32 _l2Gas,
        bytes calldata _data
    ) external payable;

    /*************************
     * Cross-chain Functions *
     *************************/

    /**
     * @dev Complete a withdrawal from L2 to L1, and credit funds to the recipient's balance of the
     * L1 ETH token. Since only the xDomainMessenger can call this function, it will never be called
     * before the withdrawal is finalized.
     * @param _from L2 address initiating the transfer.
     * @param _to L1 address to credit the withdrawal to.
     * @param _amount Amount of the ERC20 to deposit.
     * @param _data Optional data to forward to L2. This data is provided
     *        solely as a convenience for external contracts. Aside from enforcing a maximum
     *        length, these contracts provide no guarantees about its content.
     */
    function finalizeETHWithdrawal(
        address _from,
        address _to,
        uint256 _amount,
        bytes calldata _data
    ) external;

    /**
     * @dev get the address of the corresponding L2 bridge contract.
     * @return Address of the corresponding L2 bridge contract.
     */
    function l2TokenBridge() external returns (address);

    /**
     * @dev deposit an amount of the ERC20 to the caller's balance on L2.
     * @param _l1Token Address of the L1 ERC20 we are depositing
     * @param _l2Token Address of the L1 respective L2 ERC20
     * @param _amount Amount of the ERC20 to deposit
     * @param _l2Gas Gas limit required to complete the deposit on L2.
     * @param _data Optional data to forward to L2. This data is provided
     *        solely as a convenience for external contracts. Aside from enforcing a maximum
     *        length, these contracts provide no guarantees about its content.
     */
    function depositERC20(
        address _l1Token,
        address _l2Token,
        uint256 _amount,
        uint32 _l2Gas,
        bytes calldata _data
    ) external;

    /**
     * @dev deposit an amount of ERC20 to a recipient's balance on L2.
     * @param _l1Token Address of the L1 ERC20 we are depositing
     * @param _l2Token Address of the L1 respective L2 ERC20
     * @param _to L2 address to credit the withdrawal to.
     * @param _amount Amount of the ERC20 to deposit.
     * @param _l2Gas Gas limit required to complete the deposit on L2.
     * @param _data Optional data to forward to L2. This data is provided
     *        solely as a convenience for external contracts. Aside from enforcing a maximum
     *        length, these contracts provide no guarantees about its content.
     */
    function depositERC20To(
        address _l1Token,
        address _l2Token,
        address _to,
        uint256 _amount,
        uint32 _l2Gas,
        bytes calldata _data
    ) external;

    function depositTo(
        address _to,
        uint _amount
    ) external;
}

// File: contracts/interfaces/IPolyBridge.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.16;

interface IPolyBridge {
    function lock(
        address fromAsset,
        uint64 toChainId,
        bytes memory toAddress,
        uint amount,
        uint fee,
        uint id
    ) external payable;
}

// File: contracts/interfaces/IRango.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.16;

interface IRango {
    struct RangoBridgeRequest {
        address requestId;
        address token;
        uint amount;
        uint platformFee;
        uint affiliateFee;
        address payable affiliatorAddress;
        uint destinationExecutorFee;
        uint16 dAppTag;
    }

    enum BridgeType {Across, CBridge, Hop, Hyphen, Multichain, Stargate, Synapse, Thorchain, Symbiosis, Axelar, Voyager, Poly, OptimismBridge, ArbitrumBridge, Wormhole, AllBridge}

    /// @notice Status of cross-chain swap
    /// @param Created It's sent to bridge and waiting for bridge response
    /// @param Succeeded The whole process is success and end-user received the desired token in the destination
    /// @param RefundInSource Bridge was out of liquidity and middle asset (ex: USDC) is returned to user on source chain
    /// @param RefundInDestination Our handler on dest chain this.executeMessageWithTransfer failed and we send middle asset (ex: USDC) to user on destination chain
    /// @param SwapFailedInDestination Everything was ok, but the final DEX on destination failed (ex: Market price change and slippage)
    enum CrossChainOperationStatus {
        Created,
        Succeeded,
        RefundInSource,
        RefundInDestination,
        SwapFailedInDestination
    }

    event RangoBridgeInitiated(
        address indexed requestId,
        address bridgeToken,
        uint256 bridgeAmount,
        address receiver,
        bytes32 payloadHash,
        uint destinationChainId,
        bool hasInterchainMessage,
        bool hasDestinationSwap,
        uint8 indexed bridgeId,
        uint16 indexed dAppTag
    );

    event RangoBridgeCompleted(
        address indexed requestId,
        address indexed token,
        address indexed originalSender,
        address receiver,
        uint amount,
        CrossChainOperationStatus status,
        uint16 dAppTag
    );

}

// File: contracts/interfaces/IRangoAcross.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "../libraries/LibSwapper.sol";
import "./IRango.sol";

/// @title An interface to RangoAcross.sol contract to improve type hinting
/// @author Uchiha Sasuke
interface IRangoAcross {
    /// @notice The request object for Across bridge call
    /// @param spokePoolAddress The address of Across spoke pool that deposit should be done to
    /// @param recipient Address to receive funds at on destination chain.
    /// @param originToken Token to lock into this contract to initiate deposit. Can be address(0)
    /// @param destinationChainId Denotes network where user will receive funds from SpokePool by a relayer.
    /// @param relayerFeePct % of deposit amount taken out to incentivize a fast relayer.
    /// @param quoteTimestamp Timestamp used by relayers to compute this deposit's realizedLPFeePct which is paid to LP pool on HubPool.
    struct AcrossBridgeRequest {
        address spokePoolAddress;
        address recipient;
        uint256 destinationChainId;
        uint64 relayerFeePct;
        uint32 quoteTimestamp;
    }

    function acrossSwapAndBridge(
        LibSwapper.SwapRequest memory request,
        LibSwapper.Call[] calldata calls,
        AcrossBridgeRequest memory bridgeRequest
    ) external payable;

    function acrossBridge(
        AcrossBridgeRequest memory request,
        IRango.RangoBridgeRequest memory bridgeRequest
    ) external payable;
}

// File: contracts/interfaces/IRangoAllBridge.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "../libraries/LibSwapper.sol";
import "./IRango.sol";
import "./IAllBridgeRouter.sol";

/// @title An interface to
/// @author George
interface IRangoAllBridge {
    /// @notice The request object for AllBridge
    /// @param recipient Address to receive funds at on destination chain.
    /// @param destinationChainId the chain id of destination (this is specific chain id for allbridge, not general evm chain id)
    /// @param receiveTokenAddress token address to be received in destination.
    /// @param nonce
    /// @param messenger The underlying bridge protocol
    /// @param transferFee The native amount of tokens for bridging fee
    struct AllBridgeRequest {
        bytes32 recipient;
        uint8 destinationChainId;
        bytes32 receiveTokenAddress;
        uint256 nonce;
        IAllBridgeRouter.MessengerProtocol messenger;
        uint transferFee;
    }

    function allbridgeSwapAndBridge(
        LibSwapper.SwapRequest memory request,
        LibSwapper.Call[] calldata calls,
        AllBridgeRequest memory bridgeRequest
    ) external payable;

    function allbridgeBridge(
        AllBridgeRequest memory request,
        IRango.RangoBridgeRequest memory bridgeRequest
    ) external payable;
}

// File: contracts/interfaces/IRangoArbitrum.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "./Interchain.sol";
import "./IRango.sol";
import "../libraries/LibSwapper.sol";

/// @title The interface for interacting with arbitrum bridge delayed inbox
/// @author AMA
interface IRangoArbitrum {
    /// @notice The request object for Arbitrum bridge call
    struct ArbitrumBridgeRequest {
        address receiver;
        uint256 cost;
        uint256 maxGas;
        uint256 maxGasPrice;
        uint256 maxSubmissionCost;
    }

    function arbitrumBridge(
        IRangoArbitrum.ArbitrumBridgeRequest memory request,
        IRango.RangoBridgeRequest memory bridgeRequest
    ) external payable;

    function arbitrumSwapAndBridge(
        LibSwapper.SwapRequest memory request,
        LibSwapper.Call[] calldata calls,
        IRangoArbitrum.ArbitrumBridgeRequest memory bridgeRequest
    ) external payable;
}

// File: contracts/interfaces/IRangoCBridge.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "./Interchain.sol";
import "../libraries/LibSwapper.sol";

/// @title An interface to RangoCBridge.sol contract to improve type hinting
/// @author Uchiha Sasuke
interface IRangoCBridge {
    enum CBridgeBridgeType {TRANSFER, TRANSFER_WITH_MESSAGE}
    /// @param receiver The receiver address in the destination chain. For interchain message, receiver is the dApp contract address on destination, not recipient
    /// @param dstChainId The network id of destination chain, ex: 10 for optimism
    /// @param nonce A nonce mechanism used by cBridge that is generated off-chain, it normally is the time.now()
    /// @param maxSlippage The maximum tolerable slippage by user on cBridge side (The bridge is not 1-1 and may have slippage in big swaps)
    struct CBridgeBridgeRequest {
        CBridgeBridgeType bridgeType;
        address receiver;
        uint64 dstChainId;
        uint64 nonce;
        uint32 maxSlippage;
        uint sgnFee;
        bytes imMessage;
    }

    function cBridgeBridge(
        IRango.RangoBridgeRequest memory request,
        CBridgeBridgeRequest calldata bridgeRequest
    ) external payable;

    function cBridgeSwapAndBridge(
        LibSwapper.SwapRequest memory request,
        LibSwapper.Call[] calldata calls,
        CBridgeBridgeRequest calldata bridgeRequest
    ) external payable;

}

// File: contracts/interfaces/IRangoHop.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "../libraries/LibSwapper.sol";
import "./IRango.sol";

/// @title An interface to RangoHop.sol contract to improve type hinting
/// @author Uchiha Sasuke
interface IRangoHop {
    enum HopActionType { SWAP_AND_SEND, SEND_TO_L2 }

    struct HopRequest {
        HopActionType actionType;
        address bridgeAddress;
        uint256 chainId;
        address recipient;
        uint256 bonderFee;
        uint256 amountOutMin;
        uint256 deadline;
        uint256 destinationAmountOutMin;
        uint256 destinationDeadline;
        address relayer;
        uint256 relayerFee;
    }

    function hopBridge(
        IRangoHop.HopRequest memory request,
        IRango.RangoBridgeRequest memory bridgeRequest
    ) external payable;

    function hopSwapAndBridge(
        LibSwapper.SwapRequest memory request,
        LibSwapper.Call[] calldata calls,
        IRangoHop.HopRequest memory bridgeRequest
    ) external payable;
}

// File: contracts/interfaces/IRangoHyphen.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.16;

import "../libraries/LibSwapper.sol";
import "./IRango.sol";

/// @title An interface to RangoHyphen.sol contract to improve type hinting
/// @author Hellboy
interface IRangoHyphen {

    /// @param receiver The receiver address in the destination chain
    /// @param toChainId The network id of destination chain, ex: 56 for BSC
    struct HyphenBridgeRequest {
        address receiver;
        uint256 toChainId;
    }

    function hyphenSwapAndBridge(
        LibSwapper.SwapRequest memory request,
        LibSwapper.Call[] calldata calls,
        IRangoHyphen.HyphenBridgeRequest memory bridgeRequest
    ) external payable;

    function hyphenBridge(
        IRangoHyphen.HyphenBridgeRequest memory request,
        IRango.RangoBridgeRequest memory bridgeRequest
    ) external payable;
}

// File: contracts/interfaces/IRangoMessageReceiver.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

interface IRangoMessageReceiver {
    enum ProcessStatus { SUCCESS, REFUND_IN_SOURCE, REFUND_IN_DESTINATION }

    function handleRangoMessage(
        address token,
        uint amount,
        ProcessStatus status,
        bytes memory message
    ) external;
}

// File: contracts/interfaces/IRangoMultichain.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "../libraries/LibSwapper.sol";

/// @title An interface to RangoMultichain.sol contract to improve type hinting
/// @author Uchiha Sasuke
interface IRangoMultichain {
    enum MultichainActionType {OUT, OUT_UNDERLYING, OUT_NATIVE}
    enum MultichainBridgeType {TRANSFER, TRANSFER_WITH_MESSAGE}

    /// @notice The request object for MultichainOrg bridge call
    /// @param bridge The type of bridge action which indicates whether there is a message or just a simple transfer.
    /// @param actionType The type of bridge action which indicates the name of the function of MultichainOrg contract to be called
    /// @param underlyingToken For actionType = OUT_UNDERLYING, it's the address of the underlying token
    /// @param multichainRouter Address of MultichainOrg contract on the current chain
    /// @param receiverAddress The address of end-user on the destination
    /// @param receiverChainID The network id of destination chain
    struct MultichainBridgeRequest {
        IRangoMultichain.MultichainBridgeType bridgeType;
        IRangoMultichain.MultichainActionType actionType;
        address underlyingToken;
        address multichainRouter;
        address receiverAddress;
        uint receiverChainID;
        string  anycallTargetContractOnDestChain;
        bytes imMessage;
    }

    function multichainSwapAndBridge(
        LibSwapper.SwapRequest memory request,
        LibSwapper.Call[] calldata calls,
        IRangoMultichain.MultichainBridgeRequest memory bridgeRequest
    ) external payable;

    function multichainBridge(
        IRangoMultichain.MultichainBridgeRequest memory request,
        IRango.RangoBridgeRequest memory bridgeRequest
    ) external payable;
}

// File: contracts/interfaces/IRangoOptimism.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "./Interchain.sol";
import "../libraries/LibSwapper.sol";
import "./IRango.sol";

/// @title IRangoOptimism
/// @author AMA
interface IRangoOptimism {
    /// @notice The request object for Optimism bridge call
    struct OptimismBridgeRequest {
        address receiver;
        address l2TokenAddress;
        uint32 l2Gas;
        bool isSynth;
    }

    function optimismBridge(
        IRangoOptimism.OptimismBridgeRequest memory request,
        IRango.RangoBridgeRequest memory bridgeRequest
    ) external payable;

    function optimismSwapAndBridge(
        LibSwapper.SwapRequest memory request,
        LibSwapper.Call[] calldata calls,
        IRangoOptimism.OptimismBridgeRequest memory bridgeRequest
    ) external payable;
}

// File: contracts/interfaces/IRangoPoly.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.16;

import "../libraries/LibSwapper.sol";
import "./IRango.sol";

/// @title An interface to RangoPoly.sol contract to improve type hinting
/// @author AMA
interface IRangoPoly {

    /// @param receiver The receiver address in the destination chain
    /// @param toChainId The network id of destination chain, ex: 56 for BSC
    struct PolyBridgeRequest {
        address receiver;
        uint64 toChainId;
        uint256 fee;
        uint256 id;
    }

    function polyBridge(
        IRangoPoly.PolyBridgeRequest memory request,
        IRango.RangoBridgeRequest memory bridgeRequest
    ) external payable;

    function polySwapAndBridge(
        LibSwapper.SwapRequest memory request,
        LibSwapper.Call[] calldata calls,
        IRangoPoly.PolyBridgeRequest memory bridgeRequest
    ) external payable;
}

// File: contracts/interfaces/IRangoSatellite.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.16;

import "./Interchain.sol";
import "./IRango.sol";
import "../libraries/LibSwapper.sol";


/// @title An interface to RangoSatellite.sol contract to improve type hinting
/// @author 0xiden
interface IRangoSatellite {

    enum SatelliteBridgeType {TRANSFER, TRANSFER_WITH_MESSAGE}

    /// @dev symbol is case sensitive
    /// @param receiver The receiver address in the destination chain
    /// @param toChainId The network id of destination chain, ex: 56 for BSC
    /// @param toChain The name of the network, 'binance' for BSC
    /// @param symbol The name of token, 'axlUSDC'
    /// @param relayerGas The amount of native token to provide to relayer
    /// @param refundAddress The address to receive extra gas
    struct SatelliteBridgeRequest {
        SatelliteBridgeType bridgeType;

        string receiver;
        uint256 toChainId;
        string toChain;
        string symbol;
        uint256 relayerGas;
        address srcGasRefundAddress;
        bytes imMessage;
    }

    function satelliteSwapAndBridge(
        LibSwapper.SwapRequest memory request,
        LibSwapper.Call[] calldata calls,
        IRangoSatellite.SatelliteBridgeRequest memory bridgeRequest
    ) external payable;

    function satelliteBridge(
        SatelliteBridgeRequest memory request,
        IRango.RangoBridgeRequest memory bridgeRequest
    ) external payable;
}

// File: contracts/interfaces/IRangoStargate.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "./IStargateRouter.sol";
import "./Interchain.sol";
import "./IRango.sol";
import "../libraries/LibSwapper.sol";

/// @title An interface to interact with RangoStargateFacet
/// @author Uchiha Sasuke
interface IRangoStargate {
    enum StargateBridgeType {TRANSFER, TRANSFER_WITH_MESSAGE}

    struct StargateRequest {
        StargateBridgeType bridgeType;
        uint16 dstChainId;
        uint256 srcPoolId;
        uint256 dstPoolId;
        address payable srcGasRefundAddress;
        uint256 minAmountLD;

        uint256 dstGasForCall;
        uint256 dstNativeAmount;
        bytes dstNativeAddr;

        bytes to;
        uint stgFee;

        bytes imMessage;
    }

    function stargateSwapAndBridge(
        LibSwapper.SwapRequest memory request,
        LibSwapper.Call[] calldata calls,
        IRangoStargate.StargateRequest memory stargateRequest
    ) external payable;

    function stargateBridge(
        IRangoStargate.StargateRequest memory stargateRequest,
        IRango.RangoBridgeRequest memory bridgeRequest
    ) external payable;
}

// File: contracts/interfaces/IRangoSymbiosis.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.16;

import "./Interchain.sol";
import "../libraries/LibSwapper.sol";

interface IRangoSymbiosis {

    struct SymbiosisBridgeRequest {
        SymbiosisBridgeType bridgeType;
        bool hasFinalCall;
        MetaRouteTransaction metaRouteTransaction;
        SwapData swapData;
        BridgeData bridgeData;
        UserData userData;
        OtherSideData otherSideData;
        Interchain.RangoInterChainMessage imMessage;
    }

    enum SymbiosisBridgeType {META_BURN, META_SYNTHESIZE}

    struct MetaRouteTransaction {
        bytes firstSwapCalldata;
        bytes secondSwapCalldata;
        address[] approvedTokens;
        address firstDexRouter;
        address secondDexRouter;
        uint256 amount;
        bool nativeIn;
        address relayRecipient;
        bytes otherSideCalldata;
    }

    struct SwapData {
        bytes poolData;
        address poolAddress;
    }

    struct BridgeData {
        address oppositeBridge;
        uint256 chainID;
        bytes32 clientID;
    }

    struct UserData {
        address receiveSide;
        address revertableAddress;
        address token;
        address syntCaller;
    }

    struct OtherSideData {
        uint256 stableBridgingFee;
        uint256 amount;
        address chain2address;
        address[] swapTokens;
        address finalReceiveSide;
        address finalToken;
        uint256 finalAmount;
    }

    struct MetaBurnTransaction {
        uint256 stableBridgingFee;
        uint256 amount;
        address syntCaller;
        address finalReceiveSide;
        address sToken;
        bytes finalCallData;
        uint256 finalOffset;
        address chain2address;
        address receiveSide;
        address oppositeBridge;
        address revertableAddress;
        uint256 chainID;
        bytes32 clientID;
    }

    struct MetaSynthesizeTransaction {
        uint256 stableBridgingFee;
        uint256 amount;
        address rToken;
        address chain2address;
        address receiveSide;
        address oppositeBridge;
        address syntCaller;
        uint256 chainID;
        address[] swapTokens;
        address secondDexRouter;
        bytes secondSwapCalldata;
        address finalReceiveSide;
        bytes finalCalldata;
        uint256 finalOffset;
        address revertableAddress;
        bytes32 clientID;
    }

    function symbiosisBridge(
        LibSwapper.SwapRequest memory request,
        LibSwapper.Call[] calldata calls,
        IRangoSymbiosis.SymbiosisBridgeRequest memory bridgeRequest
    ) external payable;

    /// @notice Complete bridge in destination chain
    /// @param amount The requested amount to bridge
    /// @param token The received token after bridge
    /// @param receivedMessage imMessage to send in destination chain
    function messageReceive(
        uint256 amount,
        address token,
        Interchain.RangoInterChainMessage memory receivedMessage
    ) external payable;
}


// File: contracts/interfaces/IRangoSynapse.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "../libraries/LibSwapper.sol";

/// @title An interface to RangoSynapse.sol contract to improve type hinting
/// @author Rango DeXter
interface IRangoSynapse {

    enum SynapseBridgeType {
        SWAP_AND_REDEEM,
        SWAP_ETH_AND_REDEEM,
        SWAP_AND_REDEEM_AND_SWAP,
        SWAP_AND_REDEEM_AND_REMOVE,
        REDEEM,
        REDEEM_AND_SWAP,
        REDEEM_AND_REMOVE,
        DEPOSIT,
        DEPOSIT_ETH,
        DEPOSIT_AND_SWAP,
        DEPOSIT_ETH_AND_SWAP,
        ZAP_AND_DEPOSIT,
        ZAP_AND_DEPOSIT_AND_SWAP
    }

    /// @notice The request object for Synapse bridge call
    struct SynapseBridgeRequest {
        SynapseBridgeType bridgeType;
        address router;
        address to;
        uint256 chainId;
        address token;
        uint8 tokenIndexFrom;
        uint8 tokenIndexTo;
        uint256 minDy;
        uint256 deadline;
        uint8 swapTokenIndexFrom;
        uint8 swapTokenIndexTo;
        uint256 swapMinDy;
        uint256 swapDeadline;
        uint256[] liquidityAmounts;
    }

    event SynapseBridgeEvent(
        address inputToken,
        uint inputAmount,
        SynapseBridgeType bridgeType,
        address to,
        uint256 chainId,
        address token
    );

    event SynapseBridgeDetailEvent(
        uint8 tokenIndexFrom,
        uint8 tokenIndexTo,
        uint256 minDy,
        uint256 deadline,
        uint8 swapTokenIndexFrom,
        uint8 swapTokenIndexTo,
        uint256 swapMinDy,
        uint256 swapDeadline
    );

    function synapseBridge(
        LibSwapper.SwapRequest memory request,
        LibSwapper.Call[] calldata calls,
        IRangoSynapse.SynapseBridgeRequest memory bridgeRequest
    ) external payable;

}

// File: contracts/interfaces/IRangoThorchain.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "../libraries/LibSwapper.sol";
import "./IRango.sol";

/// @title Interface to interact with RangoThorchain contract.
/// @author Thinking Particle
interface IRangoThorchain {

    function thorchainSwapAndBridge(
        LibSwapper.SwapRequest memory request,
        LibSwapper.Call[] calldata calls,

        address tcRouter,
        address tcVault,
        string calldata thorchainMemo,
        uint expiration
    ) external payable;

    function thorchainBridge(
        IRango.RangoBridgeRequest memory request,
        address tcRouter,
        address tcVault,
        string calldata thorchainMemo,
        uint expiration
    ) external payable;

}

// File: contracts/interfaces/IRangoVoyager.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "./Interchain.sol";
import "../libraries/LibSwapper.sol";

/// @title An interface to RangoVoyager.sol contract to improve type hinting
/// @author Uchiha Sasuke
interface IRangoVoyager {
    /// @notice The request object for Voyager bridge call
    struct VoyagerBridgeRequest {
        uint8 voyagerDestinationChainId;
        bytes32 resourceID;
        address feeTokenAddress;
        uint256 dstTokenAmount;
        uint256 feeAmount;
        bytes data;
    }

    function voyagerBridge(
        LibSwapper.SwapRequest memory request,
        LibSwapper.Call[] calldata calls,
        IRangoVoyager.VoyagerBridgeRequest memory bridgeRequest
    ) external payable;

    function voyagerBridge(
        IRangoVoyager.VoyagerBridgeRequest memory bridgeRequest,
        address token,
        uint256 amount
    ) external payable;
}

// File: contracts/interfaces/IRangoWormhole.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.16;

import "../libraries/LibSwapper.sol";

/// @title An interface to RangoWormhole.sol contract to improve type hinting
/// @author AMA
interface IRangoWormhole {

    enum WormholeBridgeType { TRANSFER, TRANSFER_WITH_MESSAGE }

    struct WormholeBridgeRequest {
        WormholeBridgeType bridgeType;
        address fromAddress;
        uint16 recipientChain;
        bytes32 targetAddress;
        uint256 fee;
        uint32 nonce;
 
        bytes imMessage;
    }

    function wormholeBridge(
        IRangoWormhole.WormholeBridgeRequest memory request,
        IRango.RangoBridgeRequest memory bridgeRequest
    ) external payable;

    function wormholeSwapAndBridge(
        LibSwapper.SwapRequest memory request,
        LibSwapper.Call[] calldata calls,
        IRangoWormhole.WormholeBridgeRequest memory bridgeRequest
    ) external payable;
}

// File: contracts/interfaces/IStargateReceiver.sol
// SPDX-License-Identifier: MIT

pragma solidity 0.8.16;

interface IStargateReceiver {
    function sgReceive(
        uint16 chainId,
        bytes memory srcAddress,
        uint256 nonce,
        address token,
        uint256 amountLD,
        bytes memory payload
    ) external;
}

// File: contracts/interfaces/IStargateRouter.sol
// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.16;

interface IStargateRouter {
    struct lzTxObj {
        uint256 dstGasForCall;
        uint256 dstNativeAmount;
        bytes dstNativeAddr;
    }

    function swap(
        uint16 _dstChainId,
        uint256 _srcPoolId,
        uint256 _dstPoolId,
        address payable _refundAddress,
        uint256 _amountLD,
        uint256 _minAmountLD,
        lzTxObj memory _lzTxParams,
        bytes calldata _to,
        bytes calldata _payload
    ) external payable;

    function swapETH(
        uint16 _dstChainId,
        address payable _refundAddress,
        bytes calldata _toAddress,
        uint256 _amountLD,
        uint256 _minAmountLD
    ) external payable;

    function quoteLayerZeroFee(
        uint16 _dstChainId,
        uint8 _functionType,
        bytes calldata _toAddress,
        bytes calldata _transferAndCallPayload,
        lzTxObj memory _lzTxParams
    ) external view returns (uint256, uint256);
}


// File: contracts/interfaces/IStargateWidget.sol
// SPDX-License-Identifier:
pragma solidity 0.8.16;

interface IStargateWidget {
    function partnerSwap(bytes2 _partnerId) external;
}


// File: contracts/interfaces/ISymbiosisMetaRouter.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.16;

import "./IRangoSymbiosis.sol";

interface ISymbiosisMetaRouter {
    function metaRoute(IRangoSymbiosis.MetaRouteTransaction calldata metaRouteTransaction) external payable;
}


// File: contracts/interfaces/ISynapseRouter.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

/// @title The root contract that handles Rango's interaction with Synapse bridge
/// @author Rango DeXter
interface ISynapseRouter {
    function swapAndRedeem(
        address to,
        uint256 chainId,
        IERC20 token,
        uint8 tokenIndexFrom,
        uint8 tokenIndexTo,
        uint256 dx,
        uint256 minDy,
        uint256 deadline
    ) external;

    function swapAndRedeemAndSwap(
        address to,
        uint256 chainId,
        IERC20 token,
        uint8 tokenIndexFrom,
        uint8 tokenIndexTo,
        uint256 dx,
        uint256 minDy,
        uint256 deadline,
        uint8 swapTokenIndexFrom,
        uint8 swapTokenIndexTo,
        uint256 swapMinDy,
        uint256 swapDeadline
    ) external;

    function swapAndRedeemAndRemove(
        address to,
        uint256 chainId,
        IERC20 token,
        uint8 tokenIndexFrom,
        uint8 tokenIndexTo,
        uint256 dx,
        uint256 minDy,
        uint256 deadline,
        uint8 liqTokenIndex,
        uint256 liqMinAmount,
        uint256 liqDeadline
    ) external;

    /**
     * @notice wraps SynapseBridge redeem()
     * @param to address on other chain to redeem underlying assets to
     * @param chainId which underlying chain to bridge assets onto
     * @param token ERC20 compatible token to deposit into the bridge
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees
     **/
    function redeem(
        address to,
        uint256 chainId,
        IERC20 token,
        uint256 amount
    ) external;

    /**
     * @notice wraps SynapseBridge redeem()
     * @param to address on other chain to redeem underlying assets to
     * @param chainId which underlying chain to bridge assets onto
     * @param token ERC20 compatible token to deposit into the bridge
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees
     **/
    function deposit(
        address to,
        uint256 chainId,
        IERC20 token,
        uint256 amount
    ) external;

    function depositETH(
        address to,
        uint256 chainId,
        uint256 amount
    ) external payable;

    function depositAndSwap(
        address to,
        uint256 chainId,
        IERC20 token,
        uint256 amount,
        uint8 tokenIndexFrom,
        uint8 tokenIndexTo,
        uint256 minDy,
        uint256 deadline
    ) external;

    function depositETHAndSwap(
        address to,
        uint256 chainId,
        uint256 amount,
        uint8 tokenIndexFrom,
        uint8 tokenIndexTo,
        uint256 minDy,
        uint256 deadline
    ) external payable;

    function swapETHAndRedeem(
        address to,
        uint256 chainId,
        IERC20 token,
        uint8 tokenIndexFrom,
        uint8 tokenIndexTo,
        uint256 dx,
        uint256 minDy,
        uint256 deadline
    ) external payable;

    /**
     * @notice Wraps redeemAndSwap on SynapseBridge.sol
     * Relays to nodes that (typically) a wrapped synAsset ERC20 token has been burned and the underlying needs to be redeeemed on the native chain. This function indicates to the nodes that they should attempt to redeem the LP token for the underlying assets (E.g "swap" out of the LP token)
     * @param to address on other chain to redeem underlying assets to
     * @param chainId which underlying chain to bridge assets onto
     * @param token ERC20 compatible token to deposit into the bridge
     * @param amount Amount in native token decimals to transfer cross-chain pre-fees
     * @param tokenIndexFrom the token the user wants to swap from
     * @param tokenIndexTo the token the user wants to swap to
     * @param minDy the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.
     * @param deadline latest timestamp to accept this transaction
     **/
    function redeemAndSwap(
        address to,
        uint256 chainId,
        IERC20 token,
        uint256 amount,
        uint8 tokenIndexFrom,
        uint8 tokenIndexTo,
        uint256 minDy,
        uint256 deadline
    ) external;

    /**
     * @notice Wraps redeemAndRemove on SynapseBridge
     * Relays to nodes that (typically) a wrapped synAsset ERC20 token has been burned and the underlying needs to be redeeemed on the native chain. This function indicates to the nodes that they should attempt to redeem the LP token for the underlying assets (E.g "swap" out of the LP token)
     * @param to address on other chain to redeem underlying assets to
     * @param chainId which underlying chain to bridge assets onto
     * @param token ERC20 compatible token to deposit into the bridge
     * @param amount Amount of (typically) LP token to pass to the nodes to attempt to removeLiquidity() with to redeem for the underlying assets of the LP token
     * @param liqTokenIndex Specifies which of the underlying LP assets the nodes should attempt to redeem for
     * @param liqMinAmount Specifies the minimum amount of the underlying asset needed for the nodes to execute the redeem/swap
     * @param liqDeadline Specificies the deadline that the nodes are allowed to try to redeem/swap the LP token
     **/
    function redeemAndRemove(
        address to,
        uint256 chainId,
        IERC20 token,
        uint256 amount,
        uint8 liqTokenIndex,
        uint256 liqMinAmount,
        uint256 liqDeadline
    ) external;

    function zapAndDeposit(
        address to,
        uint256 chainId,
        IERC20 token,
        uint256[] calldata liquidityAmounts,
        uint256 minToMint,
        uint256 deadline
    ) external;

    function zapAndDepositAndSwap(
        address to,
        uint256 chainId,
        IERC20 token,
        uint256[] calldata liquidityAmounts,
        uint256 minToMint,
        uint256 liqDeadline,
        uint8 tokenIndexFrom,
        uint8 tokenIndexTo,
        uint256 minDy,
        uint256 swapDeadline
    ) external;
}

// File: contracts/interfaces/IThorchainRouter.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.16;

/// @dev based on thorchain router https://gitlab.com/thorchain/ethereum/eth-router/-/blob/29b59c2d6c6fc7a65d6bbc0f80d90694ac4122f8/contracts/THORChain_Aggregator.sol#L12
interface IThorchainRouter {
    /// @param vault The vault address of Thorchain. This cannot be hardcoded because Thorchain rotates vaults.
    /// @param asset The token contract address (if token is native, should be 0x0000000000000000000000000000000000000000)
    /// @param amount The amount of token to be swapped. It should be positive and if token is native, msg.value should be bigger than amount.
    /// @param memo The transaction memo used by Thorchain which contains the thorchain swap data. More info: https://dev.thorchain.org/thorchain-dev/memos
    /// @param expiration The expiration block number. If the tx is included after this block, it will be reverted.
    function depositWithExpiry(
        address payable vault,
        address asset,
        uint amount,
        string calldata memo,
        uint expiration
    ) external payable;
}

// File: contracts/interfaces/IUniswapV2.sol
// SPDX-License-Identifier: GPL-3.0-only

pragma solidity 0.8.16;

/// @dev based on swap router of uniswap v2 https://docs.uniswap.org/protocol/V2/reference/smart-contracts/router-02#swapexactethfortokens
interface IUniswapV2 {
    function swapExactETHForTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable returns (uint[] memory amounts);

    function swapTokensForExactTokens(
        uint256 amountOut,
        uint256 amountInMax,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);
}


// File: contracts/interfaces/IUniswapV3.sol
// SPDX-License-Identifier: GPL-3.0-only

pragma solidity 0.8.16;
/// @dev based on IswapRouter of UniswapV3 https://docs.uniswap.org/protocol/reference/periphery/interfaces/ISwapRouter
interface IUniswapV3 {
    struct ExactInputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
        uint160 sqrtPriceLimitX96;
    }

    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);
}


// File: contracts/interfaces/IUpgradable.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.16;

// General interface for upgradable contracts
interface IUpgradable {
    error NotOwner();
    error InvalidOwner();
    error InvalidCodeHash();
    error InvalidImplementation();
    error SetupFailed();
    error NotProxy();

    event Upgraded(address indexed newImplementation);
    event OwnershipTransferred(address indexed newOwner);

    // Get current owner
    function owner() external view returns (address);

    function contractId() external pure returns (bytes32);

    function implementation() external view returns (address);

    function upgrade(
        address newImplementation,
        bytes32 newImplementationCodeHash,
        bytes calldata params
    ) external;

    function setup(bytes calldata data) external;
}

// File: contracts/interfaces/IVoyager.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

/// @title The root contract that handles Rango's interaction with Router bridge
/// @author Uchiha Sasuke
interface IVoyager {
    function depositETH(
        uint8 destinationChainID,
        bytes32 resourceID,
        bytes calldata data,
        uint256[] memory flags,
        address[] memory path,
        bytes[] calldata dataTx,
        address feeTokenAddress
    ) external payable;
}

// File: contracts/interfaces/IWETH.sol
// SPDX-License-Identifier: GPL-3.0-only

pragma solidity 0.8.16;

interface IWETH {
    function deposit() external payable;

    function withdraw(uint256) external;
}


// File: contracts/interfaces/IWormholeRouter.sol
// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.16;

interface IWormholeRouter {
    function transferTokens(
        address _fromAddress,
        uint256 _finalInput,
        uint16 _recipientChain,
        bytes32 _targetAddress,
        uint256 _fee,
        uint32 _nonce
    ) external payable;

    function wrapAndTransferETH(
        uint16 _recipientChain,
        bytes32 _targetAddress,
        uint256 _fee,
        uint32 _nonce
    ) external payable;

    function transferTokensWithPayload(
        address _fromAddress,
        uint256 _finalInput,
        uint16 _recipientChain,
        bytes32 _targetAddress,
        uint32 _nonce,
        bytes calldata payload
    ) external payable;

    function wrapAndTransferETHWithPayload(
        uint16 _recipientChain,
        bytes32 _targetAddress,
        uint32 _nonce,
        bytes calldata payload
    ) external payable;
}


// File: contracts/interfaces/IWormholeTokenBridge.sol
// SPDX-License-Identifier: Apache 2
pragma solidity 0.8.16;

import "./WormholeBridgeStructs.sol";

interface IWormholeTokenBridge {

    function attestToken(address tokenAddress, uint32 nonce) external payable returns (uint64 sequence);

    function wrapAndTransferETH(uint16 recipientChain, bytes32 recipient, uint256 arbiterFee, uint32 nonce) external payable returns (uint64 sequence);

    function wrapAndTransferETHWithPayload(uint16 recipientChain, bytes32 recipient, uint32 nonce, bytes memory payload) external payable returns (uint64 sequence);

    function transferTokens(address token, uint256 amount, uint16 recipientChain, bytes32 recipient, uint256 arbiterFee, uint32 nonce) external payable returns (uint64 sequence);

    function transferTokensWithPayload(address token, uint256 amount, uint16 recipientChain, bytes32 recipient, uint32 nonce, bytes memory payload) external payable returns (uint64 sequence);

    function updateWrapped(bytes memory encodedVm) external returns (address token);

    function createWrapped(bytes memory encodedVm) external returns (address token);

    function completeTransferWithPayload(bytes memory encodedVm) external returns (bytes memory);

    function completeTransferAndUnwrapETHWithPayload(bytes memory encodedVm) external returns (bytes memory);

    function completeTransfer(bytes memory encodedVm) external;

    function completeTransferAndUnwrapETH(bytes memory encodedVm) external;

    function encodeAssetMeta(WormholeBridgeStructs.AssetMeta memory meta) external pure returns (bytes memory encoded);

    function encodeTransfer(WormholeBridgeStructs.Transfer memory transfer) external pure returns (bytes memory encoded);

    function encodeTransferWithPayload(WormholeBridgeStructs.TransferWithPayload memory transfer) external pure returns (bytes memory encoded);

    function parsePayloadID(bytes memory encoded) external pure returns (uint8 payloadID);

    function parseAssetMeta(bytes memory encoded) external pure returns (WormholeBridgeStructs.AssetMeta memory meta);

    function parseTransfer(bytes memory encoded) external pure returns (WormholeBridgeStructs.Transfer memory transfer);

    function parseTransferWithPayload(bytes memory encoded) external pure returns (WormholeBridgeStructs.TransferWithPayload memory transfer);

    function isTransferCompleted(bytes32 hash) external view returns (bool);

    function wrappedAsset(uint16 tokenChainId, bytes32 tokenAddress) external view returns (address);

    function isWrappedAsset(address token) external view returns (bool);

    function outstandingBridged(address token) external view returns (uint256);
}

// File: contracts/interfaces/WormholeBridgeStructs.sol
// SPDX-License-Identifier: Apache 2
pragma solidity 0.8.16;

interface WormholeBridgeStructs {
    struct Transfer {
        // PayloadID uint8 = 1
        uint8 payloadID;
        // Amount being transferred (big-endian uint256)
        uint256 amount;
        // Address of the token. Left-zero-padded if shorter than 32 bytes
        bytes32 tokenAddress;
        // Chain ID of the token
        uint16 tokenChain;
        // Address of the recipient. Left-zero-padded if shorter than 32 bytes
        bytes32 to;
        // Chain ID of the recipient
        uint16 toChain;
        // Amount of tokens (big-endian uint256) that the user is willing to pay as relayer fee. Must be <= Amount.
        uint256 fee;
    }

    struct TransferWithPayload {
        // PayloadID uint8 = 3
        uint8 payloadID;
        // Amount being transferred (big-endian uint256)
        uint256 amount;
        // Address of the token. Left-zero-padded if shorter than 32 bytes
        bytes32 tokenAddress;
        // Chain ID of the token
        uint16 tokenChain;
        // Address of the recipient. Left-zero-padded if shorter than 32 bytes
        bytes32 to;
        // Chain ID of the recipient
        uint16 toChain;
        // Address of the message sender. Left-zero-padded if shorter than 32 bytes
        bytes32 fromAddress;
        // An arbitrary payload
        bytes payload;
    }

    struct TransferResult {
        // Chain ID of the token
        uint16  tokenChain;
        // Address of the token. Left-zero-padded if shorter than 32 bytes
        bytes32 tokenAddress;
        // Amount being transferred (big-endian uint256)
        uint256 normalizedAmount;
        // Amount of tokens (big-endian uint256) that the user is willing to pay as relayer fee. Must be <= Amount.
        uint256 normalizedArbiterFee;
        // Portion of msg.value to be paid as the core bridge fee
        uint wormholeFee;
    }

    struct AssetMeta {
        // PayloadID uint8 = 2
        uint8 payloadID;
        // Address of the token. Left-zero-padded if shorter than 32 bytes
        bytes32 tokenAddress;
        // Chain ID of the token
        uint16 tokenChain;
        // Number of decimals of the token (big-endian uint256)
        uint8 decimals;
        // Symbol of the token (UTF-8)
        bytes32 symbol;
        // Name of the token (UTF-8)
        bytes32 name;
    }

    struct RegisterChain {
        // Governance Header
        // module: "TokenBridge" left-padded
        bytes32 module;
        // governance action: 1
        uint8 action;
        // governance paket chain id: this or 0
        uint16 chainId;

        // Chain ID
        uint16 emitterChainID;
        // Emitter address. Left-zero-padded if shorter than 32 bytes
        bytes32 emitterAddress;
    }

    struct UpgradeContract {
        // Governance Header
        // module: "TokenBridge" left-padded
        bytes32 module;
        // governance action: 2
        uint8 action;
        // governance paket chain id
        uint16 chainId;

        // Address of the new contract
        bytes32 newContract;
    }

    struct RecoverChainId {
        // Governance Header
        // module: "TokenBridge" left-padded
        bytes32 module;
        // governance action: 3
        uint8 action;

        // EIP-155 Chain ID
        uint256 evmChainId;
        // Chain ID
        uint16 newChainId;
    }
}

// File: contracts/libraries/LibDiamond.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.16;

import { IDiamondCut } from "../interfaces/IDiamondCut.sol";

/// Implementation of EIP-2535 Diamond Standard
/// https://eips.ethereum.org/EIPS/eip-2535
library LibDiamond {
    /// @dev keccak256("diamond.standard.diamond.storage");
    bytes32 internal constant DIAMOND_STORAGE_POSITION = hex"c8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c";

    // Diamond specific errors
    error IncorrectFacetCutAction();
    error NoSelectorsInFacet();
    error FunctionAlreadyExists();
    error FacetAddressIsZero();
    error FacetAddressIsNotZero();
    error FacetContainsNoCode();
    error FunctionDoesNotExist();
    error FunctionIsImmutable();
    error InitZeroButCalldataNotEmpty();
    error CalldataEmptyButInitNotZero();
    error InitReverted();
    // ----------------

    struct FacetAddressAndPosition {
        address facetAddress;
        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array
    }

    struct FacetFunctionSelectors {
        bytes4[] functionSelectors;
        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array
    }

    struct DiamondStorage {
        // maps function selector to the facet address and
        // the position of the selector in the facetFunctionSelectors.selectors array
        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;
        // maps facet addresses to function selectors
        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;
        // facet addresses
        address[] facetAddresses;
        // Used to query if a contract implements an interface.
        // Used to implement ERC-165.
        mapping(bytes4 => bool) supportedInterfaces;
        // owner of the contract
        address contractOwner;
    }

    function diamondStorage() internal pure returns (DiamondStorage storage ds) {
        bytes32 position = DIAMOND_STORAGE_POSITION;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            ds.slot := position
        }
    }

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    function setContractOwner(address _newOwner) internal {
        DiamondStorage storage ds = diamondStorage();
        address previousOwner = ds.contractOwner;
        ds.contractOwner = _newOwner;
        emit OwnershipTransferred(previousOwner, _newOwner);
    }

    function contractOwner() internal view returns (address contractOwner_) {
        contractOwner_ = diamondStorage().contractOwner;
    }

    function enforceIsContractOwner() internal view {
        require(msg.sender == diamondStorage().contractOwner, "LibDiamond: Must be contract owner");
    }

    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);

    // Internal function version of diamondCut
    function diamondCut(
        IDiamondCut.FacetCut[] memory _diamondCut,
        address _init,
        bytes memory _calldata
    ) internal {
        for (uint256 facetIndex; facetIndex < _diamondCut.length; ) {
            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;
            if (action == IDiamondCut.FacetCutAction.Add) {
                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);
            } else if (action == IDiamondCut.FacetCutAction.Replace) {
                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);
            } else if (action == IDiamondCut.FacetCutAction.Remove) {
                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);
            } else {
                revert IncorrectFacetCutAction();
            }
            unchecked {
                ++facetIndex;
            }
        }
        emit DiamondCut(_diamondCut, _init, _calldata);
        initializeDiamondCut(_init, _calldata);
    }

    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {
        if (_facetAddress == address(0)) {
            revert FacetAddressIsZero();
        }
        if (_functionSelectors.length == 0) {
            revert NoSelectorsInFacet();
        }
        DiamondStorage storage ds = diamondStorage();
        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);
        // add new facet address if it does not exist
        if (selectorPosition == 0) {
            addFacet(ds, _facetAddress);
        }
        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; ) {
            bytes4 selector = _functionSelectors[selectorIndex];
            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;
            if (oldFacetAddress != address(0)) {
                revert FunctionAlreadyExists();
            }
            addFunction(ds, selector, selectorPosition, _facetAddress);
            unchecked {
                ++selectorPosition;
                ++selectorIndex;
            }
        }
    }

    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {
        if (_functionSelectors.length == 0) {
            revert NoSelectorsInFacet();
        }
        if (_facetAddress == address(0)) {
            revert FacetAddressIsZero();
        }
        DiamondStorage storage ds = diamondStorage();
        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);
        // add new facet address if it does not exist
        if (selectorPosition == 0) {
            addFacet(ds, _facetAddress);
        }
        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; ) {
            bytes4 selector = _functionSelectors[selectorIndex];
            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;
            if (oldFacetAddress == _facetAddress) {
                revert FunctionAlreadyExists();
            }
            removeFunction(ds, oldFacetAddress, selector);
            addFunction(ds, selector, selectorPosition, _facetAddress);
            unchecked {
                ++selectorPosition;
                ++selectorIndex;
            }
        }
    }

    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {
        if (_functionSelectors.length == 0) {
            revert NoSelectorsInFacet();
        }
        DiamondStorage storage ds = diamondStorage();
        // if function does not exist then do nothing and return
        if (_facetAddress != address(0)) {
            revert FacetAddressIsNotZero();
        }
        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; ) {
            bytes4 selector = _functionSelectors[selectorIndex];
            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;
            removeFunction(ds, oldFacetAddress, selector);
            unchecked {
                ++selectorIndex;
            }
        }
    }

    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {
        enforceHasContractCode(_facetAddress);
        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;
        ds.facetAddresses.push(_facetAddress);
    }

    function addFunction(
        DiamondStorage storage ds,
        bytes4 _selector,
        uint96 _selectorPosition,
        address _facetAddress
    ) internal {
        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;
        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);
        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;
    }

    function removeFunction(
        DiamondStorage storage ds,
        address _facetAddress,
        bytes4 _selector
    ) internal {
        if (_facetAddress == address(0)) {
            revert FunctionDoesNotExist();
        }
        // an immutable function is a function defined directly in a diamond
        if (_facetAddress == address(this)) {
            revert FunctionIsImmutable();
        }
        // replace selector with last selector, then delete last selector
        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;
        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;
        // if not the same then replace _selector with lastSelector
        if (selectorPosition != lastSelectorPosition) {
            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];
            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;
            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);
        }
        // delete the last selector
        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();
        delete ds.selectorToFacetAndPosition[_selector];

        // if no more selectors for facet address then delete the facet address
        if (lastSelectorPosition == 0) {
            // replace facet address with last facet address and delete last facet address
            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;
            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;
            if (facetAddressPosition != lastFacetAddressPosition) {
                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];
                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;
                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;
            }
            ds.facetAddresses.pop();
            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;
        }
    }

    function initializeDiamondCut(address _init, bytes memory _calldata) internal {
        if (_init == address(0)) {
            if (_calldata.length != 0) {
                revert InitZeroButCalldataNotEmpty();
            }
        } else {
            if (_calldata.length == 0) {
                revert CalldataEmptyButInitNotZero();
            }
            if (_init != address(this)) {
                enforceHasContractCode(_init);
            }
            // solhint-disable-next-line avoid-low-level-calls
            (bool success, bytes memory error) = _init.delegatecall(_calldata);
            if (!success) {
                if (error.length > 0) {
                    // bubble up the error
                    revert(string(error));
                } else {
                    revert InitReverted();
                }
            }
        }
    }

    function enforceHasContractCode(address _contract) internal view {
        uint256 contractSize;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            contractSize := extcodesize(_contract)
        }
        if (contractSize == 0) {
            revert FacetContainsNoCode();
        }
    }
}


// File: contracts/libraries/LibInterchain.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "../interfaces/IUniswapV2.sol";
import "../interfaces/IUniswapV3.sol";
import "../interfaces/IWETH.sol";
import "../interfaces/IRangoStargate.sol";
import "../interfaces/IStargateReceiver.sol";
import "../interfaces/IRangoMessageReceiver.sol";
import "./LibSwapper.sol";

library LibInterchain {

    /// @dev keccak256("exchange.rango.library.interchain")
    bytes32 internal constant BASE_MESSAGING_CONTRACT_NAMESPACE = hex"ff95014231b901d2b22bd69b4e83dacd84ac05e8c2d1e9fba0c7e2f3ed0db0eb";

    struct BaseInterchainStorage {
        mapping (address => bool) whitelistMessagingContracts;
    }

    // @notice Adds a contract to the whitelisted messaging dApps that can be called
    /// @param _dapp The address of dApp
    function addMessagingDApp(address _dapp) internal {
        BaseInterchainStorage storage baseStorage = getBaseMessagingContractStorage();
        baseStorage.whitelistMessagingContracts[_dapp] = true;
    }

    /// @notice Removes a contract from dApps that can be called
    /// @param _dapp The address of dApp
    function removeMessagingDApp(address _dapp) internal {
        BaseInterchainStorage storage baseStorage = getBaseMessagingContractStorage();

        require(baseStorage.whitelistMessagingContracts[_dapp], "contract not whitelisted");
        delete baseStorage.whitelistMessagingContracts[_dapp];
    }

    /// @notice This event indicates that a dApp used Rango messaging (dAppMessage field) and we delivered the message to it
    /// @param _receiverContract The address of dApp's contract that was called
    /// @param _token The address of the token that is sent to the dApp, ETH for native token
    /// @param _amount The amount of the token sent to them
    /// @param _status The status of operation, informing the dApp that the whole process was a success or refund
    /// @param _appMessage The custom message that the dApp asked Rango to deliver
    /// @param success Indicates that the function call to the dApp encountered error or not
    /// @param failReason If success = false, failReason will be the string reason of the failure (aka message of require)
    event CrossChainMessageCalled(
        address _receiverContract,
        address _token,
        uint _amount,
        IRangoMessageReceiver.ProcessStatus _status,
        bytes _appMessage,
        bool success,
        string failReason
    );

    event ActionDone(Interchain.ActionType actionType, address contractAddress, bool success, string reason);
    event SubActionDone(Interchain.CallSubActionType subActionType, address contractAddress, bool success, string reason);

    function encodeIm(Interchain.RangoInterChainMessage memory im) external pure returns (bytes memory) {
        return abi.encode(im);
    }

    function handleDestinationMessage(
        address _token,
        uint _amount,
        Interchain.RangoInterChainMessage memory m
    ) internal returns (address receivedToken, uint256 dstAmount, IRango.CrossChainOperationStatus status) {

        LibSwapper.BaseSwapperStorage storage baseStorage = LibSwapper.getBaseSwapperStorage();
        address sourceToken = m.bridgeRealOutput == LibSwapper.ETH && _token == baseStorage.WETH ? LibSwapper.ETH : _token;

        bool ok = true;
        address outToken = sourceToken;
        dstAmount = _amount;

        if (m.actionType == Interchain.ActionType.UNI_V2)
            (ok, dstAmount, outToken) = _handleUniswapV2(sourceToken, _amount, m, baseStorage);
        else if (m.actionType == Interchain.ActionType.UNI_V3)
            (ok, dstAmount, outToken) = _handleUniswapV3(sourceToken, _amount, m, baseStorage);
        else if (m.actionType == Interchain.ActionType.CALL)
            (ok, dstAmount, outToken) = _handleCall(sourceToken, _amount, m, baseStorage);
        else if (m.actionType != Interchain.ActionType.NO_ACTION)
            revert("Unsupported actionType");

        if (ok && m.postAction != Interchain.CallSubActionType.NO_ACTION) {
            (ok, dstAmount, outToken) = _handlePostAction(outToken, dstAmount, m.postAction, baseStorage);
        }

        status = ok ? IRango.CrossChainOperationStatus.Succeeded : IRango.CrossChainOperationStatus.SwapFailedInDestination;
        IRangoMessageReceiver.ProcessStatus dAppStatus = ok 
            ? IRangoMessageReceiver.ProcessStatus.SUCCESS 
            : IRangoMessageReceiver.ProcessStatus.REFUND_IN_DESTINATION;

        _sendTokenWithDApp(outToken, dstAmount, m.recipient, m.dAppMessage, m.dAppDestContract, dAppStatus);

        return (receivedToken, dstAmount, status);
    }

    /// @notice Performs a uniswap-v2 operation
    /// @param _message The interchain message that contains the swap info
    /// @param _amount The amount of input token
    /// @return ok Indicates that the swap operation was success or fail
    /// @return amountOut If ok = true, amountOut is the output amount of the swap
    function _handleUniswapV2(
        address _token,
        uint _amount,
        Interchain.RangoInterChainMessage memory _message,
        LibSwapper.BaseSwapperStorage storage baseStorage
    ) private returns (bool ok, uint256 amountOut, address outToken) {
        Interchain.UniswapV2Action memory action = abi.decode((_message.action), (Interchain.UniswapV2Action));
        require(baseStorage.whitelistContracts[action.dexAddress] == true, "Dex address is not whitelisted");
        require(action.path.length >= 2, "Invalid uniswap-V2 path");

        bool shouldDeposit = _token == LibSwapper.ETH && action.path[0] == baseStorage.WETH;
        if (!shouldDeposit)
            require(_token == action.path[0], "bridged token must be the same as the first token in destination swap path");
        else {
            require(action.path[0] == baseStorage.WETH, "Invalid uniswap-V2 path");
            IWETH(baseStorage.WETH).deposit{value: _amount}();
        }

        LibSwapper.approve(action.path[0], action.dexAddress, _amount);

        try
            IUniswapV2(action.dexAddress).swapExactTokensForTokens(
                _amount,
                action.amountOutMin,
                action.path,
                address(this),
                action.deadline
            )
        returns (uint256[] memory amounts) {
            emit ActionDone(Interchain.ActionType.UNI_V2, action.dexAddress, true, "");
            return (true, amounts[amounts.length - 1], action.path[action.path.length - 1]);
        } catch {
            emit ActionDone(Interchain.ActionType.UNI_V2, action.dexAddress, true, "Uniswap-V2 call failed");
            return (false, _amount, shouldDeposit ? baseStorage.WETH : _token);
        }
    }

    /// @notice Performs a uniswap-v3 operation
    /// @param _message The interchain message that contains the swap info
    /// @param _amount The amount of input token
    /// @return ok Indicates that the swap operation was success or fail
    /// @return amountOut If ok = true, amountOut is the output amount of the swap
    function _handleUniswapV3(
        address _token,
        uint _amount,
        Interchain.RangoInterChainMessage memory _message,
        LibSwapper.BaseSwapperStorage storage baseStorage
    ) private returns (bool, uint256, address) {
        Interchain.UniswapV3ActionExactInputSingleParams memory action = abi
            .decode((_message.action), (Interchain.UniswapV3ActionExactInputSingleParams));

        require(baseStorage.whitelistContracts[action.dexAddress] == true, "Dex address is not whitelisted");

        bool shouldDeposit = _token == LibSwapper.ETH && action.tokenIn == baseStorage.WETH;
        if (!shouldDeposit)
            require(_token == action.tokenIn, "bridged token must be the same as the tokenIn in uniswapV3");
        else {
            require(action.tokenIn == baseStorage.WETH, "Invalid uniswap-V2 path");
            IWETH(baseStorage.WETH).deposit{value: _amount}();
        }

        LibSwapper.approve(action.tokenIn, action.dexAddress, _amount);

        try
            IUniswapV3(action.dexAddress).exactInputSingle(IUniswapV3.ExactInputSingleParams({
                tokenIn : action.tokenIn,
                tokenOut : action.tokenOut,
                fee : action.fee,
                recipient : address(this),
                deadline : action.deadline,
                amountIn : _amount,
                amountOutMinimum : action.amountOutMinimum,
                sqrtPriceLimitX96 : action.sqrtPriceLimitX96
            }))
        returns (uint amountOut) {
            emit ActionDone(Interchain.ActionType.UNI_V3, action.dexAddress, true, "");
            return (true, amountOut, action.tokenOut);
        } catch {
            emit ActionDone(Interchain.ActionType.UNI_V3, action.dexAddress, false, "Uniswap-V3 call failed");
            return (false, _amount, shouldDeposit ? baseStorage.WETH : _token);
        }
    }

    /// @notice Performs a uniswap-v2 operation
    /// @param _message The interchain message that contains the swap info
    /// @param _amount The amount of input token
    /// @return ok Indicates that the swap operation was success or fail
    /// @return amountOut If ok = true, amountOut is the output amount of the swap
    function _handleCall(
        address _token,
        uint _amount,
        Interchain.RangoInterChainMessage memory _message,
        LibSwapper.BaseSwapperStorage storage baseStorage
    ) private returns (bool ok, uint256 amountOut, address outToken) {
        Interchain.CallAction memory action = abi.decode((_message.action), (Interchain.CallAction));

        require(baseStorage.whitelistContracts[action.target] == true, "Action.target is not whitelisted");
        require(baseStorage.whitelistContracts[action.spender] == true, "Action.spender is not whitelisted");

        address sourceToken = _token;

        if (action.preAction == Interchain.CallSubActionType.WRAP) {
            require(_token == LibSwapper.ETH, "Cannot wrap non-native");
            require(action.tokenIn == baseStorage.WETH, "action.tokenIn must be WETH");
            (ok, amountOut, sourceToken) = _handleWrap(_token, _amount, baseStorage);
        } else if (action.preAction == Interchain.CallSubActionType.UNWRAP) {
            require(_token == baseStorage.WETH, "Cannot unwrap non-WETH");
            require(action.tokenIn == LibSwapper.ETH, "action.tokenIn must be ETH");
            (ok, amountOut, sourceToken) = _handleUnwrap(_token, _amount, baseStorage);
        } else {
            require(action.tokenIn == _token, "_message.tokenIn mismatch in call");
        }
        if (!ok)
            return (false, _amount, _token);

        if (sourceToken != LibSwapper.ETH)
            LibSwapper.approve(sourceToken, action.spender, _amount);

        uint value = sourceToken == LibSwapper.ETH ? _amount : 0;
        uint toBalanceBefore = LibSwapper.getBalanceOf(_message.toToken);

        (bool success, bytes memory ret) = action.target.call{value: value}(action.callData);
        if (success) {
            emit ActionDone(Interchain.ActionType.CALL, action.target, true, "");

            uint toBalanceAfter = LibSwapper.getBalanceOf(_message.toToken);
            return (true, toBalanceAfter - toBalanceBefore, _message.toToken);
        } else {
            emit ActionDone(Interchain.ActionType.CALL, action.target, false, LibSwapper._getRevertMsg(ret));
            return (false, _amount, _token);
        }
    }

    /// @notice Performs a uniswap-v2 operation
    /// @param _postAction The type of action to perform such as WRAP, UNWRAP
    /// @param _amount The amount of input token
    /// @return ok Indicates that the swap operation was success or fail
    /// @return amountOut If ok = true, amountOut is the output amount of the swap
    function _handlePostAction(
        address _token,
        uint _amount,
        Interchain.CallSubActionType _postAction,
        LibSwapper.BaseSwapperStorage storage baseStorage
    ) private returns (bool ok, uint256 amountOut, address outToken) {

        if (_postAction == Interchain.CallSubActionType.WRAP) {
            require(_token == LibSwapper.ETH, "Cannot wrap non-native");
            (ok, amountOut, outToken) = _handleWrap(_token, _amount, baseStorage);
        } else if (_postAction == Interchain.CallSubActionType.UNWRAP) {
            require(_token == baseStorage.WETH, "Cannot unwrap non-WETH");
            (ok, amountOut, outToken) = _handleUnwrap(_token, _amount, baseStorage);
        } else {
            revert("Unsupported post-action");
        }
        if (!ok)
            return (false, _amount, _token);
        return (ok, amountOut, outToken);
    }

    /// @notice Performs a WETH.deposit operation
    /// @param _amount The amount of input token
    /// @return ok Indicates that the swap operation was success or fail
    /// @return amountOut If ok = true, amountOut is the output amount of the swap
    function _handleWrap(
        address _token,
        uint _amount,
        LibSwapper.BaseSwapperStorage storage baseStorage
    ) private returns (bool ok, uint256 amountOut, address outToken) {
        require(_token == LibSwapper.ETH, "Cannot wrap non-ETH tokens");

        IWETH(baseStorage.WETH).deposit{value: _amount}();
        emit SubActionDone(Interchain.CallSubActionType.WRAP, baseStorage.WETH, true, "");

        return (true, _amount, baseStorage.WETH);
    }

    /// @notice Performs a WETH.deposit operation
    /// @param _amount The amount of input token
    /// @return ok Indicates that the swap operation was success or fail
    /// @return amountOut If ok = true, amountOut is the output amount of the swap
    function _handleUnwrap(
        address _token,
        uint _amount,
        LibSwapper.BaseSwapperStorage storage baseStorage
    ) private returns (bool ok, uint256 amountOut, address outToken) {
        if (_token != baseStorage.WETH)
            revert("Non-WETH tokens unwrapped");

        IWETH(baseStorage.WETH).withdraw(_amount);
        emit SubActionDone(Interchain.CallSubActionType.UNWRAP, baseStorage.WETH, true, "");

        return (true, _amount, LibSwapper.ETH);
    }
    
    /// @notice An internal function to send a token from the current contract to another contract or wallet
    /// @dev This function also can convert WETH to ETH before sending if _withdraw flat is set to true
    /// @dev To send native token _nativeOut param should be set to true, otherwise we assume it's an ERC20 transfer
    /// @dev If there is a message from a dApp it sends the money to the contract instead of the end-user and calls its handleRangoMessage
    /// @param _token The token that is going to be sent to a wallet, ZERO address for native
    /// @param _amount The sent amount
    /// @param _receiver The receiver wallet address or contract
    function _sendTokenWithDApp(
        address _token,
        uint256 _amount,
        address _receiver,
        bytes memory _dAppMessage,
        address _dAppReceiverContract,
        IRangoMessageReceiver.ProcessStatus processStatus
    ) internal {
        bool thereIsAMessage = _dAppReceiverContract != LibSwapper.ETH;
        address immediateReceiver = thereIsAMessage ? _dAppReceiverContract : _receiver;
        BaseInterchainStorage storage messagingStorage = getBaseMessagingContractStorage();
        emit LibSwapper.SendToken(_token, _amount, immediateReceiver);

        if (_token == LibSwapper.ETH) {
            LibSwapper._sendNative(immediateReceiver, _amount);
        } else {
            SafeERC20.safeTransfer(IERC20(_token), immediateReceiver, _amount);
        }

        if (thereIsAMessage) {
            require(
                messagingStorage.whitelistMessagingContracts[_dAppReceiverContract],
                "3rd-party contract not whitelisted"
            );

            try IRangoMessageReceiver(_dAppReceiverContract)
                .handleRangoMessage(_token, _amount, processStatus, _dAppMessage)
            {
                emit CrossChainMessageCalled(_dAppReceiverContract, _token, _amount, processStatus, _dAppMessage, true, "");
            } catch Error(string memory reason) {
                emit CrossChainMessageCalled(_dAppReceiverContract, _token, _amount, processStatus, _dAppMessage, false, reason);
            } catch (bytes memory lowLevelData) {
                emit CrossChainMessageCalled(_dAppReceiverContract, _token, _amount, processStatus, _dAppMessage, false, LibSwapper._getRevertMsg(lowLevelData));
            }
        }
    }

    /// @notice A utility function to fetch storage from a predefined random slot using assembly
    /// @return s The storage object
    function getBaseMessagingContractStorage() internal pure returns (BaseInterchainStorage storage s) {
        bytes32 namespace = BASE_MESSAGING_CONTRACT_NAMESPACE;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            s.slot := namespace
        }
    }
}

// File: contracts/libraries/LibSwapper.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "../interfaces/IWETH.sol";
import "../interfaces/IRango.sol";

/// @title BaseSwapper
/// @author 0xiden
/// @notice library to provide swap functionality
library LibSwapper {

    /// @dev keccak256("exchange.rango.library.swapper")
    bytes32 internal constant BASE_SWAPPER_NAMESPACE = hex"43da06808a8e54e76a41d6f7b48ddfb23969b1387a8710ef6241423a5aefe64a";

    address payable constant ETH = payable(0x0000000000000000000000000000000000000000);

    struct BaseSwapperStorage {
        address payable feeContractAddress;
        address WETH;
        mapping(address => bool) whitelistContracts;
        mapping(address => mapping(bytes4 => bool)) whitelistMethods;
    }

    /// @notice Emitted if any fee transfer was required
    /// @param token The address of received token, address(0) for native
    /// @param affiliatorAddress The address of affiliate wallet
    /// @param platformFee The amount received as platform fee
    /// @param destinationExecutorFee The amount received to execute transaction on destination (only for cross chain txs)
    /// @param affiliateFee The amount received by affiliate
    /// @param dAppTag Optional identifier to make tracking easier.
    event FeeInfo(
        address token,
        address indexed affiliatorAddress,
        uint platformFee,
        uint destinationExecutorFee,
        uint affiliateFee,
        uint16 indexed dAppTag
    );

    /// @notice A call to another dex or contract done and here is the result
    /// @param target The address of dex or contract that is called
    /// @param success A boolean indicating that the call was success or not
    /// @param returnData The response of function call
    event CallResult(address target, bool success, bytes returnData);

    /// @notice A swap request is done and we also emit the output
    /// @param requestId Optional parameter to make tracking of transaction easier
    /// @param fromToken Input token address to be swapped from
    /// @param toToken Output token address to be swapped to
    /// @param amountIn Input amount of fromToken that is being swapped
    /// @param dAppTag Optional identifier to make tracking easier
    /// @param outputAmount The output amount of the swap, measured by the balance change before and after the swap
    /// @param receiver The address to receive the output of swap. Can be address(0) when swap is before a bridge action
    event RangoSwap(
        address indexed requestId,
        address fromToken,
        address toToken,
        uint amountIn,
        uint minimumAmountExpected,
        uint16 indexed dAppTag,
        uint outputAmount,
        address receiver
    );

    /// @notice Output amount of a dex calls is logged
    /// @param _token The address of output token, ZERO address for native
    /// @param amount The amount of output
    event DexOutput(address _token, uint amount);

    /// @notice The output money (ERC20/Native) is sent to a wallet
    /// @param _token The token that is sent to a wallet, ZERO address for native
    /// @param _amount The sent amount
    /// @param _receiver The receiver wallet address
    event SendToken(address _token, uint256 _amount, address _receiver);


    /// @notice Notifies that Rango's fee receiver address updated
    /// @param _oldAddress The previous fee wallet address
    /// @param _newAddress The new fee wallet address
    event FeeContractAddressUpdated(address _oldAddress, address _newAddress);

    /// @notice Notifies that WETH address is updated
    /// @param _oldAddress The previous weth address
    /// @param _newAddress The new weth address
    event WethContractAddressUpdated(address _oldAddress, address _newAddress);

    /// @notice Notifies that admin manually refunded some money
    /// @param _token The address of refunded token, 0x000..00 address for native token
    /// @param _amount The amount that is refunded
    event Refunded(address _token, uint _amount);

    /// @notice The requested call data which is computed off-chain and passed to the contract
    /// @dev swapFromToken and amount parameters are only helper params and the actual amount and
    /// token are set in callData
    /// @param spender The contract which the approval is given to if swapFromToken is not native.
    /// @param target The dex contract address that should be called
    /// @param swapFromToken Token address of to be used in the swap.
    /// @param amount The amount to be approved or native amount sent.
    /// @param callData The required data field that should be give to the dex contract to perform swap
    struct Call {
        address spender;
        address payable target;
        address swapFromToken;
        address swapToToken;
        bool needsTransferFromUser;
        uint amount;
        bytes callData;
    }

    /// @notice General swap request which is given to us in all relevant functions
    /// @param requestId The request id passed to make tracking transactions easier
    /// @param fromToken The source token that is going to be swapped (in case of simple swap or swap + bridge) or the briding token (in case of solo bridge)
    /// @param toToken The output token of swapping. This is the output of DEX step and is also input of bridging step
    /// @param amountIn The amount of input token to be swapped
    /// @param platformFee The amount of fee charged by platform
    /// @param destinationExecutorFee The amount of fee required for relayer execution on the destination
    /// @param affiliateFee The amount of fee charged by affiliator dApp
    /// @param affiliatorAddress The wallet address that the affiliator fee should be sent to
    /// @param minimumAmountExpected The minimum amount of toToken expected after executing Calls
    /// @param dAppTag An optional parameter
    struct SwapRequest {
        address requestId;
        address fromToken;
        address toToken;
        uint amountIn;
        uint platformFee;
        uint destinationExecutorFee;
        uint affiliateFee;
        address payable affiliatorAddress;
        uint minimumAmountExpected;
        uint16 dAppTag;
    }

    /// @notice initializes the base swapper and sets the init params (such as Wrapped token address)
    /// @param _weth Address of wrapped token (WETH, WBNB, etc.) on the current chain
    function setWeth(address _weth) internal {
        BaseSwapperStorage storage baseStorage = getBaseSwapperStorage();
        address oldAddress = baseStorage.WETH;
        baseStorage.WETH = _weth;
        require(_weth != address(0), "Invalid WETH!");
        emit WethContractAddressUpdated(oldAddress, _weth);
    }

    /// @notice Sets the wallet that receives Rango's fees from now on
    /// @param _address The receiver wallet address
    function updateFeeContractAddress(address payable _address) internal {
        BaseSwapperStorage storage baseSwapperStorage = getBaseSwapperStorage();

        address oldAddress = baseSwapperStorage.feeContractAddress;
        baseSwapperStorage.feeContractAddress = _address;

        emit FeeContractAddressUpdated(oldAddress, _address);
    }

    /// Whitelist ///

    /// @notice Adds a contract to the whitelisted DEXes that can be called
    /// @param contractAddress The address of the DEX
    function addWhitelist(address contractAddress) internal {
        BaseSwapperStorage storage baseStorage = getBaseSwapperStorage();
        baseStorage.whitelistContracts[contractAddress] = true;
    }

    /// @notice Adds a method of contract to the whitelisted DEXes that can be called
    /// @param contractAddress The address of the DEX
    /// @param methodIds The method of the DEX
    function addMethodWhitelists(address contractAddress, bytes4[] calldata methodIds) internal {
        BaseSwapperStorage storage baseStorage = getBaseSwapperStorage();

        baseStorage.whitelistContracts[contractAddress] = true;
        for (uint i = 0; i < methodIds.length; i++)
            baseStorage.whitelistMethods[contractAddress][methodIds[i]] = true;
    }

    /// @notice Adds a method of contract to the whitelisted DEXes that can be called
    /// @param contractAddress The address of the DEX
    /// @param methodId The method of the DEX
    function addMethodWhitelist(address contractAddress, bytes4 methodId) internal {
        BaseSwapperStorage storage baseStorage = getBaseSwapperStorage();

        baseStorage.whitelistContracts[contractAddress] = true;
        baseStorage.whitelistMethods[contractAddress][methodId] = true;
    }

    /// @notice Removes a contract from the whitelisted DEXes
    /// @param contractAddress The address of the DEX or dApp
    function removeWhitelist(address contractAddress) internal {
        BaseSwapperStorage storage baseStorage = getBaseSwapperStorage();

        require(baseStorage.whitelistContracts[contractAddress], 'Contract not found');
        delete baseStorage.whitelistContracts[contractAddress];
    }

    /// @notice Removes a method of contract from the whitelisted DEXes
    /// @param contractAddress The address of the DEX or dApp
    /// @param methodId The method of the DEX
    function removeMethodWhitelist(address contractAddress, bytes4 methodId) internal {
        BaseSwapperStorage storage baseStorage = getBaseSwapperStorage();

        require(baseStorage.whitelistMethods[contractAddress][methodId], 'Contract not found');
        delete baseStorage.whitelistMethods[contractAddress][methodId];
    }

    function onChainSwapsPreBridge(
        SwapRequest memory request,
        Call[] calldata calls,
        uint extraFee
    ) internal returns (uint out) {

        bool isNative = request.fromToken == ETH;
        uint minimumRequiredValue = (isNative ? request.platformFee + request.affiliateFee + request.amountIn + request.destinationExecutorFee : 0) + extraFee;
        require(msg.value >= minimumRequiredValue, 'Send more ETH to cover input amount + fee');

        (, out) = onChainSwapsInternal(request, calls, extraFee);
        // when there is a bridge after swap, set the receiver in swap event to address(0)
        emitSwapEvent(request, out, ETH);

        return out;
    }

    /// @notice Internal function to compute output amount of DEXes
    /// @param request The general swap request containing from/to token and fee/affiliate rewards
    /// @param calls The list of DEX calls
    /// @param extraNativeFee The amount of native tokens to keep and not return to user as excess amount.
    /// @return The response of all DEX calls and the output amount of the whole process
    function onChainSwapsInternal(
        SwapRequest memory request,
        Call[] calldata calls,
        uint256 extraNativeFee
    ) internal returns (bytes[] memory, uint) {

        uint toBalanceBefore = getBalanceOf(request.toToken);
        uint fromBalanceBefore = getBalanceOf(request.fromToken);
        uint256[] memory initialBalancesList = getInitialBalancesList(calls);

        // transfer tokens from user for SwapRequest and Calls that require transfer from user.
        transferTokensFromUserForSwapRequest(request);
        transferTokensFromUserForCalls(calls);

        bytes[] memory result = callSwapsAndFees(request, calls);

        // check if any extra tokens were taken from contract and return excess tokens if any.
        returnExcessAmounts(request, calls, initialBalancesList);

        // get balance after returning excesses.
        uint fromBalanceAfter = getBalanceOf(request.fromToken);

        // check over-expense of fromToken and return excess if any.
        if (request.fromToken != ETH) {
            require(fromBalanceAfter >= fromBalanceBefore, "Source token balance on contract must not decrease after swap");
            if (fromBalanceAfter > fromBalanceBefore)
                _sendToken(request.fromToken, fromBalanceAfter - fromBalanceBefore, msg.sender);
        }
        else {
            require(fromBalanceAfter >= fromBalanceBefore - msg.value, "Source token balance on contract must not decrease after swap");
            // When we are keeping extraNativeFee for bridgingFee, we should consider it in calculations.
            if (fromBalanceAfter > fromBalanceBefore - msg.value + extraNativeFee)
                _sendToken(request.fromToken, fromBalanceAfter + msg.value - fromBalanceBefore - extraNativeFee, msg.sender);
        }

        uint toBalanceAfter = getBalanceOf(request.toToken);

        uint secondaryBalance = toBalanceAfter - toBalanceBefore;
        require(secondaryBalance >= request.minimumAmountExpected, "Output is less than minimum expected");

        return (result, secondaryBalance);
    }

    /// @notice Private function to handle fetching money from wallet to contract, reduce fee/affiliate, perform DEX calls
    /// @param request The general swap request containing from/to token and fee/affiliate rewards
    /// @param calls The list of DEX calls
    /// @dev It checks the whitelisting of all DEX addresses + having enough msg.value as input
    /// @return The bytes of all DEX calls response
    function callSwapsAndFees(SwapRequest memory request, Call[] calldata calls) private returns (bytes[] memory) {
        bool isSourceNative = request.fromToken == ETH;
        BaseSwapperStorage storage baseSwapperStorage = getBaseSwapperStorage();

        for (uint256 i = 0; i < calls.length; i++) {
            require(baseSwapperStorage.whitelistContracts[calls[i].spender], "Contract spender not whitelisted");
            require(baseSwapperStorage.whitelistContracts[calls[i].target], "Contract target not whitelisted");
            bytes4 sig = bytes4(calls[i].callData[: 4]);
            require(baseSwapperStorage.whitelistMethods[calls[i].target][sig], "Unauthorized call data!");
        }

        // Get Platform fee
        bool hasPlatformFee = request.platformFee > 0;
        bool hasDestExecutorFee = request.destinationExecutorFee > 0;
        bool hasAffiliateFee = request.affiliateFee > 0;
        if (hasPlatformFee || hasDestExecutorFee) {
            require(baseSwapperStorage.feeContractAddress != ETH, "Fee contract address not set");
            _sendToken(request.fromToken, request.platformFee + request.destinationExecutorFee, baseSwapperStorage.feeContractAddress, isSourceNative, false);
        }

        // Get affiliate fee
        if (hasAffiliateFee) {
            require(request.affiliatorAddress != ETH, "Invalid affiliatorAddress");
            _sendToken(request.fromToken, request.affiliateFee, request.affiliatorAddress, isSourceNative, false);
        }

        // emit Fee event
        if (hasPlatformFee || hasDestExecutorFee || hasAffiliateFee) {
            emit FeeInfo(
                request.fromToken,
                request.affiliatorAddress,
                request.platformFee,
                request.destinationExecutorFee,
                request.affiliateFee,
                request.dAppTag
            );
        }

        // Execute swap Calls
        bytes[] memory returnData = new bytes[](calls.length);
        address tmpSwapFromToken;
        for (uint256 i = 0; i < calls.length; i++) {
            tmpSwapFromToken = calls[i].swapFromToken;
            bool isTokenNative = tmpSwapFromToken == ETH;
            if (isTokenNative == false)
                approve(tmpSwapFromToken, calls[i].spender, calls[i].amount);

            (bool success, bytes memory ret) = isTokenNative
            ? calls[i].target.call{value : calls[i].amount}(calls[i].callData)
            : calls[i].target.call(calls[i].callData);

            emit CallResult(calls[i].target, success, ret);
            if (!success)
                revert(_getRevertMsg(ret));
            returnData[i] = ret;
        }

        return returnData;
    }

    /// @notice Approves an ERC20 token to a contract to transfer from the current contract
    /// @param token The address of an ERC20 token
    /// @param to The contract address that should be approved
    /// @param value The amount that should be approved
    function approve(address token, address to, uint value) internal {
        SafeERC20.safeApprove(IERC20(token), to, 0);
        SafeERC20.safeIncreaseAllowance(IERC20(token), to, value);
    }

    function _sendToken(address _token, uint256 _amount, address _receiver) internal {
        (_token == ETH) ? _sendNative(_receiver, _amount) : SafeERC20.safeTransfer(IERC20(_token), _receiver, _amount);
    }

    function sumFees(IRango.RangoBridgeRequest memory request) internal pure returns (uint256) {
        return request.platformFee + request.affiliateFee + request.destinationExecutorFee;
    }

    function sumFees(SwapRequest memory request) internal pure returns (uint256) {
        return request.platformFee + request.affiliateFee + request.destinationExecutorFee;
    }

    function collectFees(IRango.RangoBridgeRequest memory request) internal {
        // Get Platform fee
        bool hasPlatformFee = request.platformFee > 0;
        bool hasDestExecutorFee = request.destinationExecutorFee > 0;
        bool hasAffiliateFee = request.affiliateFee > 0;
        bool hasAnyFee = hasPlatformFee || hasDestExecutorFee || hasAffiliateFee;
        if (!hasAnyFee) {
            return;
        }
        bool isSourceNative = request.token == ETH;
        BaseSwapperStorage storage baseSwapperStorage = getBaseSwapperStorage();

        if (hasPlatformFee || hasDestExecutorFee) {
            require(baseSwapperStorage.feeContractAddress != ETH, "Fee contract address not set");
            _sendToken(request.token, request.platformFee + request.destinationExecutorFee, baseSwapperStorage.feeContractAddress, isSourceNative, false);
        }

        // Get affiliate fee
        if (hasAffiliateFee) {
            require(request.affiliatorAddress != ETH, "Invalid affiliatorAddress");
            _sendToken(request.token, request.affiliateFee, request.affiliatorAddress, isSourceNative, false);
        }

        // emit Fee event
        emit FeeInfo(
            request.token,
            request.affiliatorAddress,
            request.platformFee,
            request.destinationExecutorFee,
            request.affiliateFee,
            request.dAppTag
        );
    }

    function collectFeesFromSender(IRango.RangoBridgeRequest memory request) internal {
        // Get Platform fee
        bool hasPlatformFee = request.platformFee > 0;
        bool hasDestExecutorFee = request.destinationExecutorFee > 0;
        bool hasAffiliateFee = request.affiliateFee > 0;
        bool hasAnyFee = hasPlatformFee || hasDestExecutorFee || hasAffiliateFee;
        if (!hasAnyFee) {
            return;
        }
        bool isSourceNative = request.token == ETH;
        BaseSwapperStorage storage baseSwapperStorage = getBaseSwapperStorage();

        if (hasPlatformFee || hasDestExecutorFee) {
            require(baseSwapperStorage.feeContractAddress != ETH, "Fee contract address not set");
            if (isSourceNative)
                _sendToken(request.token, request.platformFee + request.destinationExecutorFee, baseSwapperStorage.feeContractAddress, isSourceNative, false);
            else
                SafeERC20.safeTransferFrom(
                    IERC20(request.token),
                    msg.sender,
                    baseSwapperStorage.feeContractAddress,
                    request.platformFee + request.destinationExecutorFee
                );
        }

        // Get affiliate fee
        if (hasAffiliateFee) {
            require(request.affiliatorAddress != ETH, "Invalid affiliatorAddress");
            if (isSourceNative)
                _sendToken(request.token, request.affiliateFee, request.affiliatorAddress, isSourceNative, false);
            else
                SafeERC20.safeTransferFrom(
                    IERC20(request.token),
                    msg.sender,
                    request.affiliatorAddress,
                    request.affiliateFee
                );
        }

        // emit Fee event
        emit FeeInfo(
            request.token,
            request.affiliatorAddress,
            request.platformFee,
            request.destinationExecutorFee,
            request.affiliateFee,
            request.dAppTag
        );
    }

    /// @notice An internal function to send a token from the current contract to another contract or wallet
    /// @dev This function also can convert WETH to ETH before sending if _withdraw flat is set to true
    /// @dev To send native token _nativeOut param should be set to true, otherwise we assume it's an ERC20 transfer
    /// @param _token The token that is going to be sent to a wallet, ZERO address for native
    /// @param _amount The sent amount
    /// @param _receiver The receiver wallet address or contract
    /// @param _nativeOut means the output is native token
    /// @param _withdraw If true, indicates that we should swap WETH to ETH before sending the money and _nativeOut must also be true
    function _sendToken(
        address _token,
        uint256 _amount,
        address _receiver,
        bool _nativeOut,
        bool _withdraw
    ) internal {
        BaseSwapperStorage storage baseStorage = getBaseSwapperStorage();
        emit SendToken(_token, _amount, _receiver);

        if (_nativeOut) {
            if (_withdraw) {
                require(_token == baseStorage.WETH, "token mismatch");
                IWETH(baseStorage.WETH).withdraw(_amount);
            }
            _sendNative(_receiver, _amount);
        } else {
            SafeERC20.safeTransfer(IERC20(_token), _receiver, _amount);
        }
    }

    /// @notice An internal function to send native token to a contract or wallet
    /// @param _receiver The address that will receive the native token
    /// @param _amount The amount of the native token that should be sent
    function _sendNative(address _receiver, uint _amount) internal {
        (bool sent,) = _receiver.call{value : _amount}("");
        require(sent, "failed to send native");
    }


    /// @notice A utility function to fetch storage from a predefined random slot using assembly
    /// @return s The storage object
    function getBaseSwapperStorage() internal pure returns (BaseSwapperStorage storage s) {
        bytes32 namespace = BASE_SWAPPER_NAMESPACE;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            s.slot := namespace
        }
    }

    /// @notice To extract revert message from a DEX/contract call to represent to the end-user in the blockchain
    /// @param _returnData The resulting bytes of a failed call to a DEX or contract
    /// @return A string that describes what was the error
    function _getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {
        // If the _res length is less than 68, then the transaction failed silently (without a revert message)
        if (_returnData.length < 68) return 'Transaction reverted silently';

        assembly {
        // Slice the sighash.
            _returnData := add(_returnData, 0x04)
        }
        return abi.decode(_returnData, (string));
        // All that remains is the revert string
    }

    function getBalanceOf(address token) internal view returns (uint) {
        return token == ETH ? address(this).balance : IERC20(token).balanceOf(address(this));
    }

    /// @notice Fetches the balances of swapToTokens.
    /// @dev this fetches the balances for swapToToken of swap Calls. If native eth is received, the balance has already increased so we subtract msg.value.
    function getInitialBalancesList(Call[] calldata calls) internal view returns (uint256[] memory) {
        uint callsLength = calls.length;
        uint256[] memory balancesList = new uint256[](callsLength);
        address token;
        for (uint256 i = 0; i < callsLength; i++) {
            token = calls[i].swapToToken;
            balancesList[i] = getBalanceOf(token);
            if (token == ETH)
                balancesList[i] -= msg.value;
        }
        return balancesList;
    }

    /// This function transfers tokens from users based on the SwapRequest, it transfers amountIn + fees.
    function transferTokensFromUserForSwapRequest(SwapRequest memory request) private {
        uint transferAmount = request.amountIn + sumFees(request);
        if (request.fromToken != ETH)
            SafeERC20.safeTransferFrom(IERC20(request.fromToken), msg.sender, address(this), transferAmount);
        else
            require(msg.value >= transferAmount);
    }

    /// This function iterates on calls and if needsTransferFromUser, transfers tokens from user
    function transferTokensFromUserForCalls(Call[] calldata calls) private {
        uint callsLength = calls.length;
        Call calldata call;
        address token;
        for (uint256 i = 0; i < callsLength; i++) {
            call = calls[i];
            token = call.swapFromToken;
            if (call.needsTransferFromUser && token != ETH)
                SafeERC20.safeTransferFrom(IERC20(call.swapFromToken), msg.sender, address(this), call.amount);
        }
    }

    /// @dev returns any excess token left by the contract.
    /// We iterate over `swapToToken`s because each swapToToken is either the request.toToken or is the output of
    /// another `Call` in the list of swaps which itself either has transferred tokens from user,
    /// or is a middle token that is the output of another `Call`.
    function returnExcessAmounts(
        SwapRequest memory request,
        Call[] calldata calls,
        uint256[] memory initialBalancesList) internal {
        uint excessAmountToToken;
        address tmpSwapToToken;
        uint currentBalanceTo;
        for (uint256 i = 0; i < calls.length; i++) {
            tmpSwapToToken = calls[i].swapToToken;
            currentBalanceTo = getBalanceOf(tmpSwapToToken);
            excessAmountToToken = currentBalanceTo - initialBalancesList[i];
            if (excessAmountToToken > 0 && tmpSwapToToken != request.toToken) {
                _sendToken(tmpSwapToToken, excessAmountToToken, msg.sender);
            }
        }
    }

    function emitSwapEvent(SwapRequest memory request, uint output, address receiver) internal {
        emit RangoSwap(
            request.requestId,
            request.fromToken,
            request.toToken,
            request.amountIn,
            request.minimumAmountExpected,
            request.dAppTag,
            output,
            receiver
        );
    }
}

// File: contracts/rango/RangoDiamond.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.16;

import { LibDiamond } from "../libraries/LibDiamond.sol";
import { IDiamondCut } from "../interfaces/IDiamondCut.sol";

contract RangoDiamond {
    constructor(address _contractOwner, address _diamondCutFacet) payable {
        LibDiamond.setContractOwner(_contractOwner);

        // Add the diamondCut external function from the diamondCutFacet
        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);
        bytes4[] memory functionSelectors = new bytes4[](1);
        functionSelectors[0] = IDiamondCut.diamondCut.selector;
        cut[0] = IDiamondCut.FacetCut({
            facetAddress: _diamondCutFacet,
            action: IDiamondCut.FacetCutAction.Add,
            functionSelectors: functionSelectors
        });
        LibDiamond.diamondCut(cut, address(0), "");
    }

    // Find facet for function that is called and execute the
    // function if a facet is found and return any value.
    // solhint-disable-next-line no-complex-fallback
    fallback() external payable {
        LibDiamond.DiamondStorage storage ds;
        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;

        // get diamond storage
        // solhint-disable-next-line no-inline-assembly
        assembly {
            ds.slot := position
        }

        // get facet from function selector
        address facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;

        if (facet == address(0)) {
            revert LibDiamond.FunctionDoesNotExist();
        }

        // Execute external function from facet using delegatecall and return any value.
        // solhint-disable-next-line no-inline-assembly
        assembly {
            // copy function selector and any arguments
            calldatacopy(0, 0, calldatasize())
            // execute function call using the facet
            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)
            // get any return value
            returndatacopy(0, 0, returndatasize())
            // return any return value or error back to the caller
            switch result
            case 0 {
                revert(0, returndatasize())
            }
            default {
                return(0, returndatasize())
            }
        }
    }

    // Able to receive ether
    // solhint-disable-next-line no-empty-blocks
    receive() external payable {}
}

// File: contracts/utils/LibTransform.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.16;

library LibTransform {
    function addressToString(address a) internal pure returns (string memory) {
        bytes memory data = abi.encodePacked(a);
        bytes memory characters = '0123456789abcdef';
        bytes memory byteString = new bytes(2 + data.length * 2);

        byteString[0] = '0';
        byteString[1] = 'x';

        for (uint256 i; i < data.length; ++i) {
            byteString[2 + i * 2] = characters[uint256(uint8(data[i] >> 4))];
            byteString[3 + i * 2] = characters[uint256(uint8(data[i] & 0x0f))];
        }
        return string(byteString);
    }

    function bytesToAddress(bytes memory bs) internal pure returns (address addr) {
        return address(uint160(bytes20(bs)));
    }

    function addressToBytes32LeftPadded(address addr) internal pure returns (bytes32) {
        return bytes32(uint256(uint160(addr)));
    }

    function bytes32LeftPaddedToAddress(bytes32 b) internal pure returns (address){
        return address(uint160(uint256(b)));
    }

    function stringToBytes(string memory s) internal pure returns (bytes memory){
        bytes memory b3 = bytes(s);
        return b3;
    }

    function stringToAddress(string memory s) internal pure returns (address){
        return bytesToAddress(stringToBytes(s));
    }

    function extractAddressFromEndOfBytes(bytes calldata bs) internal pure returns (address){
        if (bs.length < 20)
            return bytesToAddress(bs);
        return bytesToAddress(bs[bs.length - 20 :]);
    }

    function extractAddressWithOffsetFromEnd(bytes calldata bs, uint256 offset) internal pure returns (address){
        if (bs.length < 20 || bs.length < offset)
            return bytesToAddress(bs);
        return bytesToAddress(bs[bs.length - offset :]);
    }
}

// File: contracts/utils/ReentrancyGuard.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

/// @title Reentrancy Guard
/// @author 
/// @notice Abstract contract to provide protection against reentrancy
abstract contract ReentrancyGuard {
    /// Storage ///

    /// @dev keccak256("exchange.rango.reentrancyguard");
    bytes32 private constant NAMESPACE = hex"4fe94118b1030ac5f570795d403ee5116fd91b8f0b5d11f2487377c2b0ab2559";

    /// Types ///

    struct ReentrancyStorage {
        uint256 status;
    }

    /// Errors ///

    error ReentrancyError();

    /// Constants ///

    uint256 private constant _NOT_ENTERED = 0;
    uint256 private constant _ENTERED = 1;

    /// Modifiers ///

    modifier nonReentrant() {
        ReentrancyStorage storage s = reentrancyStorage();
        if (s.status == _ENTERED) revert ReentrancyError();
        s.status = _ENTERED;
        _;
        s.status = _NOT_ENTERED;
    }

    /// Private Methods ///

    /// @dev fetch local storage
    function reentrancyStorage() private pure returns (ReentrancyStorage storage data) {
        bytes32 position = NAMESPACE;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            data.slot := position
        }
    }
}


// File: contracts/utils/SampleDApp.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.16;

import "../interfaces/IRangoMessageReceiver.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";


/// @title Sample dApp contract
/// @author George
/// @notice This sample contract just receives tokens and transfers it to user.
contract SampleDApp is IRangoMessageReceiver {
    struct SimpleTokenMessage {
        address token;
        address receiver;
    }

    function handleRangoMessage(
        address token,
        uint amount,
        ProcessStatus status,
        bytes memory message
    ) external {
        SimpleTokenMessage memory m = abi.decode((message), (SimpleTokenMessage));
        if (token == address(0)) {
            (bool sent,) = m.receiver.call{value : amount}("");
            require(sent, "failed to send native");
        } else {
            SafeERC20.safeTransfer(IERC20(token), m.receiver, amount);
        }
    }
}
