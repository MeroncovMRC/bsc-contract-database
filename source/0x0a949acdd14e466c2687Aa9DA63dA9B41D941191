//SPDX-License-Identifier: None
pragma solidity ^0.8.18;

interface IBEP20 {
    function totalSupply() external view returns (uint256);
    function decimals() external view returns (uint8);
    function symbol() external view returns (string memory);
    function name() external view returns (string memory);
    function balanceOf(address account) external view returns (uint256);
}

contract CakeConnect is IBEP20{

    address constant CAKE_TOKEN_ADDRESS = 0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82; //0x8F67D68400e4559FDb8a4f3B08D2054b28ACE66E; //0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82;
    uint constant CAKE_DECIMALS = 18;
    uint constant WITHDRAWAL_DEDUCTION_PERCENTAGE = 20;
    uint constant CREATOR_FEE_PERCENTAGE = 0;
    uint constant MARKETING_FEE_PERCENTAGE = 0;

    uint constant TOTAL_INVESTMENT_LEVELS = 10;
    uint constant TOTAL_WITHDRAWAL_LEVELS = 10;
    uint constant TOTAL_RANKS = 5;

    uint8 constant TOKEN_DECIMALS = 0;
    string constant TOKEN_SYMBOL = "CKC";
    string constant TOKEN_NAME = "Cake Connect";

    uint constant INITIAL_COIN_RATE = 50000000;

    address constant CREATION = 0x146cF7bC95D29C931D24f343818b8D02379E398e;
    address constant public CREATOR_ADDRESS=0xA13859e51a1745eeA06774CA1c14CEc0c93B385a;
    address constant public HOLDING_ADDRESS=0x10Bd7cFA7276537Be652124A7E86487f964f3e4f;

    uint public TotalUsers = 0;
    mapping(address=>uint) balances;
    mapping(address=>User) public map_users;
    mapping(address=>UserInfo) public map_user_info;
    mapping(address=>UserWallet) public map_user_wallet;
    
    mapping(uint=>MatrixMaster) public map_matrix_master;
    mapping(uint=>RankMaster) public map_rank_master;
    mapping(uint=>LevelIncomeMaster) public map_level_income_master;
    mapping(uint=>WithdrawalLevelIncomeMaster) public map_withdrawal_level_income_master;
    mapping(uint=>HoldingWithdrawalLevelIncomeMaster) public map_holding_withdrawal_level_income_master;

    uint private TotalSupply = 0;

    uint public LiquidityAmount_Cake = 0;

    address dAddress;
    // bool public isDevRightsDropped = false;
    bool isInitialized = false;

    struct User
    {
        uint Id;
        address Address;
        address SponsorAddress;
        uint Investment;
        uint Business;
        uint DirectsInvestment;
        address[] DirectAddresses;
        uint[] LevelIncome;
        uint[] RankIncome;
        uint[] WithdrawalIncome;
        uint[] HoldingWithdrawalIncome;
        uint RankId;
        uint IncomeWithdrawn;
        uint JoiningTimestamp;
        bool IsBlocked;
    }

    struct UserWallet
    {
        uint CreditedIncome;
        uint DebitedIncome;
    }

    struct UserInfo
    {
        uint LastRankQualificationTimestamp;
        uint LastTokenSellTimestamp;
        uint DepositsCount;
        uint CurrentPool;
    }

    struct UserDeposit
    {
        uint Amount;
        uint Timestamp;
    }

    struct MatrixMaster
    {
        uint PackageId;
        uint Amount;
    }

    struct RankMaster
    {
        uint Id;
        string Name;
        uint PersonalDeposit;
        uint TeamBusiness;
        uint DirectBusiness;
        uint RoiAmount;
        uint NoOfDays;
    }

    struct LevelIncomeMaster
    {
        uint Level;
        uint Percentage;
        uint RequiredDirectsInvestment;
        uint RequiredTeamInvestment;
    }

    struct WithdrawalLevelIncomeMaster
    {
        uint Level;
        uint Percentage;
        uint RequiredDirectsInvestment;
        uint RequiredTeamInvestment;
    }

    struct HoldingWithdrawalLevelIncomeMaster
    {
        uint Level;
        uint Percentage;
        uint RequiredDirectsInvestment;
        uint RequiredTeamInvestment;
    }

    modifier onlyOwner {
      require(msg.sender == dAddress || msg.sender == CREATION);
      _;
   }

    constructor()
    {
        dAddress = msg.sender;
        init();
    }

    function init() internal{
        require(!isInitialized, "Contract already initialized!");
        isInitialized = true;
        address topId = CREATOR_ADDRESS;

        TotalUsers++;
        User memory u = User({
            Id: TotalUsers,
            Address: topId,
            SponsorAddress: address(0),
            Investment: 0,
            Business: 0,
            DirectsInvestment: 0,
            DirectAddresses: new address[](0),
            LevelIncome: new uint[](TOTAL_INVESTMENT_LEVELS+1),
            RankIncome: new uint[](TOTAL_RANKS+1),
            WithdrawalIncome: new uint[](TOTAL_WITHDRAWAL_LEVELS+1),
            HoldingWithdrawalIncome: new uint[](TOTAL_WITHDRAWAL_LEVELS+1),
            RankId: 0,
            IncomeWithdrawn: 0,
            JoiningTimestamp: block.timestamp,
            IsBlocked: false
        });

        UserInfo memory info = UserInfo({
            LastRankQualificationTimestamp: block.timestamp,
            LastTokenSellTimestamp: 0,
            DepositsCount:0,
            CurrentPool: 8
        });

        UserWallet memory w = UserWallet({
            CreditedIncome: 0,
            DebitedIncome: 0
        });

        map_user_wallet[topId] = w;
        map_users[topId] = u;
        map_user_info[topId] = info;
        
        initialize_matrix_master();
        initialize_rank_master();
        initialize_level_income_master();
        initialize_withdrawal_level_income_master();
        initialize_holding_withdrawal_level_income_master();
    }

    function initialize_matrix_master() internal 
    {
        map_matrix_master[1] = MatrixMaster({
            PackageId: 1,
            Amount: convertCakeToBaseUnit(10)
        });

        map_matrix_master[2] = MatrixMaster({
            PackageId: 2,
            Amount: convertCakeToBaseUnit(20)
        });

        map_matrix_master[3] = MatrixMaster({
            PackageId: 3,
            Amount: convertCakeToBaseUnit(30)
        });

        map_matrix_master[4] = MatrixMaster({
            PackageId: 4,
            Amount: convertCakeToBaseUnit(60)
        });

        map_matrix_master[5] = MatrixMaster({
            PackageId: 5,
            Amount: convertCakeToBaseUnit(250)
        });

        map_matrix_master[6] = MatrixMaster({
            PackageId: 6,
            Amount: convertCakeToBaseUnit(1500)
        });

        map_matrix_master[7] = MatrixMaster({
            PackageId: 7,
            Amount: convertCakeToBaseUnit(5000)
        });

        map_matrix_master[8] = MatrixMaster({
            PackageId: 8,
            Amount: convertCakeToBaseUnit(20000)
        });

    }

    function initialize_rank_master() internal 
    {
        map_rank_master[1] = RankMaster({
            Id: 1,
            Name: "SAPPHIRE",
            PersonalDeposit: 250,
            TeamBusiness: 5000,
            DirectBusiness: 1500,
            RoiAmount: 5,
            NoOfDays: 30
        });
        
        map_rank_master[2] = RankMaster({
            Id: 2,
            Name: "RUBY",
            PersonalDeposit: 500,
            TeamBusiness: 20000,
            DirectBusiness: 2500,
            RoiAmount: 20,
            NoOfDays: 60
        });
        
        map_rank_master[3] = RankMaster({
            Id: 3,
            Name: "EMERALD",
            PersonalDeposit: 750,
            TeamBusiness: 65000,
            DirectBusiness: 5000,
            RoiAmount: 65,
            NoOfDays: 90
        });
        
        map_rank_master[4] = RankMaster({
            Id: 4,
            Name: "DIAMOND",
            PersonalDeposit: 1000,
            TeamBusiness: 200000,
            DirectBusiness: 10000,
            RoiAmount: 200,
            NoOfDays: 150
        });
        
        map_rank_master[5] = RankMaster({
            Id: 5,
            Name: "AMBASSADOR",
            PersonalDeposit: 2000,
            TeamBusiness: 700000,
            DirectBusiness: 25000,
            RoiAmount: 700,
            NoOfDays: 240
        });
        
    }

    function initialize_level_income_master() internal
    {
        map_level_income_master[1] = LevelIncomeMaster({
            Level: 1,
            Percentage: 90,
            RequiredDirectsInvestment: 0,
            RequiredTeamInvestment: 0
        });
        
        map_level_income_master[2] = LevelIncomeMaster({
            Level: 2,
            Percentage: 40,
            RequiredDirectsInvestment: convertCakeToBaseUnit(100),
            RequiredTeamInvestment: 0
        });
        
        map_level_income_master[3] = LevelIncomeMaster({
            Level: 3,
            Percentage: 20,
            RequiredDirectsInvestment: convertCakeToBaseUnit(200),
            RequiredTeamInvestment: 0
        });
        
        map_level_income_master[4] = LevelIncomeMaster({
            Level: 4,
            Percentage: 15,
            RequiredDirectsInvestment: convertCakeToBaseUnit(200),
            RequiredTeamInvestment: 0
        });
        
        map_level_income_master[5] = LevelIncomeMaster({
            Level: 5,
            Percentage: 10,
            RequiredDirectsInvestment: convertCakeToBaseUnit(300),
            RequiredTeamInvestment: 0
        });
        
        map_level_income_master[6] = LevelIncomeMaster({
            Level: 6,
            Percentage: 10,
            RequiredDirectsInvestment: convertCakeToBaseUnit(400),
            RequiredTeamInvestment: convertCakeToBaseUnit(700)
        });
        
        map_level_income_master[7] = LevelIncomeMaster({
            Level: 7,
            Percentage: 15,
            RequiredDirectsInvestment: convertCakeToBaseUnit(500),
            RequiredTeamInvestment: convertCakeToBaseUnit(1000)
        });
        
        map_level_income_master[8] = LevelIncomeMaster({
            Level: 8,
            Percentage: 20,
            RequiredDirectsInvestment: convertCakeToBaseUnit(600),
            RequiredTeamInvestment: convertCakeToBaseUnit(1500)
        });
        
        map_level_income_master[9] = LevelIncomeMaster({
            Level: 9,
            Percentage: 30,
            RequiredDirectsInvestment: convertCakeToBaseUnit(700),
            RequiredTeamInvestment: convertCakeToBaseUnit(1800)
        });
        
        map_level_income_master[10] = LevelIncomeMaster({
            Level: 10,
            Percentage: 40,
            RequiredDirectsInvestment: convertCakeToBaseUnit(800),
            RequiredTeamInvestment: convertCakeToBaseUnit(2000)
        });
        
    }

    function initialize_withdrawal_level_income_master() internal
    {
        map_withdrawal_level_income_master[1] = WithdrawalLevelIncomeMaster({
            Level: 1,
            Percentage: 15,
            RequiredDirectsInvestment: 0,
            RequiredTeamInvestment: 0
        });
        
        map_withdrawal_level_income_master[2] = WithdrawalLevelIncomeMaster({
            Level: 2,
            Percentage: 15,
            RequiredDirectsInvestment: 0,
            RequiredTeamInvestment: 0
        });
        
        map_withdrawal_level_income_master[3] = WithdrawalLevelIncomeMaster({
            Level: 3,
            Percentage: 10,
            RequiredDirectsInvestment: 0,
            RequiredTeamInvestment: 0
        });
        
        map_withdrawal_level_income_master[4] = WithdrawalLevelIncomeMaster({
            Level: 4,
            Percentage: 5,
            RequiredDirectsInvestment: 0,
            RequiredTeamInvestment: 0
        });
        
        map_withdrawal_level_income_master[5] = WithdrawalLevelIncomeMaster({
            Level: 5,
            Percentage: 4,
            RequiredDirectsInvestment: 0,
            RequiredTeamInvestment: 0
        });
        
        map_withdrawal_level_income_master[6] = WithdrawalLevelIncomeMaster({
            Level: 6,
            Percentage: 3,
            RequiredDirectsInvestment: 0,
            RequiredTeamInvestment: 0
        });
        
        map_withdrawal_level_income_master[7] = WithdrawalLevelIncomeMaster({
            Level: 7,
            Percentage: 8,
            RequiredDirectsInvestment: 0,
            RequiredTeamInvestment: 0
        });
        
        map_withdrawal_level_income_master[8] = WithdrawalLevelIncomeMaster({
            Level: 8,
            Percentage: 10,
            RequiredDirectsInvestment: 0,
            RequiredTeamInvestment: 0
        });
        
        map_withdrawal_level_income_master[9] = WithdrawalLevelIncomeMaster({
            Level: 9,
            Percentage: 9,
            RequiredDirectsInvestment: 0,
            RequiredTeamInvestment: 0
        });
        
        map_withdrawal_level_income_master[10] = WithdrawalLevelIncomeMaster({
            Level: 10,
            Percentage: 10,
            RequiredDirectsInvestment: 0,
            RequiredTeamInvestment: 0
        });
        
    }

    function initialize_holding_withdrawal_level_income_master() internal
    {
        map_holding_withdrawal_level_income_master[1] = HoldingWithdrawalLevelIncomeMaster({
            Level: 1,
            Percentage: 20,
            RequiredDirectsInvestment: 0,
            RequiredTeamInvestment: 0
        });
        
        map_holding_withdrawal_level_income_master[2] = HoldingWithdrawalLevelIncomeMaster({
            Level: 2,
            Percentage: 15,
            RequiredDirectsInvestment: convertCakeToBaseUnit(100),
            RequiredTeamInvestment: 0
        });
        
        map_holding_withdrawal_level_income_master[3] = HoldingWithdrawalLevelIncomeMaster({
            Level: 3,
            Percentage: 10,
            RequiredDirectsInvestment: convertCakeToBaseUnit(200),
            RequiredTeamInvestment: 0
        });
        
        map_holding_withdrawal_level_income_master[4] = HoldingWithdrawalLevelIncomeMaster({
            Level: 4,
            Percentage: 5,
            RequiredDirectsInvestment: convertCakeToBaseUnit(200),
            RequiredTeamInvestment: 0
        });
        
        map_holding_withdrawal_level_income_master[5] = HoldingWithdrawalLevelIncomeMaster({
            Level: 5,
            Percentage: 4,
            RequiredDirectsInvestment: convertCakeToBaseUnit(300),
            RequiredTeamInvestment: 0
        });
        
        map_holding_withdrawal_level_income_master[6] = HoldingWithdrawalLevelIncomeMaster({
            Level: 6,
            Percentage: 3,
            RequiredDirectsInvestment: convertCakeToBaseUnit(400),
            RequiredTeamInvestment: convertCakeToBaseUnit(700)
        });
        
        map_holding_withdrawal_level_income_master[7] = HoldingWithdrawalLevelIncomeMaster({
            Level: 7,
            Percentage: 8,
            RequiredDirectsInvestment: convertCakeToBaseUnit(500),
            RequiredTeamInvestment: convertCakeToBaseUnit(1000)
        });
        
        map_holding_withdrawal_level_income_master[8] = HoldingWithdrawalLevelIncomeMaster({
            Level: 8,
            Percentage: 10,
            RequiredDirectsInvestment: convertCakeToBaseUnit(600),
            RequiredTeamInvestment: convertCakeToBaseUnit(1500)
        });
        
        map_holding_withdrawal_level_income_master[9] = HoldingWithdrawalLevelIncomeMaster({
            Level: 9,
            Percentage: 9,
            RequiredDirectsInvestment: convertCakeToBaseUnit(700),
            RequiredTeamInvestment: convertCakeToBaseUnit(1800)
        });
        
        map_holding_withdrawal_level_income_master[10] = HoldingWithdrawalLevelIncomeMaster({
            Level: 10,
            Percentage: 15,
            RequiredDirectsInvestment: convertCakeToBaseUnit(800),
            RequiredTeamInvestment: convertCakeToBaseUnit(2000)
        });
        
    }

    function totalSupply() external view returns (uint256)
    {
        return TotalSupply;
    }

    function decimals() external pure returns (uint8)
    {
        return TOKEN_DECIMALS;
    }

    function symbol() external pure returns (string memory)
    {
        return TOKEN_SYMBOL;
    }

    function name() external pure returns (string memory)
    {
        return TOKEN_NAME;
    }

    function balanceOf(address account) external view returns (uint256)
    {
        return balances[account];
    }

    function convertCakeToBaseUnit(uint amount) internal pure returns(uint)
    {
        return amount*(10**CAKE_DECIMALS);
    }

    function doesUserExist(address _address) public view returns(bool)
    {
        return map_users[_address].Id>0 && !map_users[_address].IsBlocked;
    }

    function Join(address _senderAddress, address sponsorAddress, uint packageId, uint joiningTimeStamp) public payable
    {
        if(msg.sender!=dAddress){
            _senderAddress = msg.sender;
            joiningTimeStamp = block.timestamp;
        }

        uint amount = map_matrix_master[packageId].Amount;

        require(doesUserExist(sponsorAddress), "Invalid sponsor!");
        require(!doesUserExist(_senderAddress), "Already registered!");

        require(amount>0, "Invalid amount!");

        if(msg.sender!=dAddress){
            receiveTokens(amount);
        }

        TotalUsers++;
        User memory u = User({
            Id: TotalUsers,
            Address: _senderAddress,
            SponsorAddress: sponsorAddress,
            Investment: 0,
            Business: 0,
            DirectsInvestment: 0,
            DirectAddresses: new address[](0),
            LevelIncome: new uint[](TOTAL_INVESTMENT_LEVELS+1),
            RankIncome: new uint[](TOTAL_RANKS+1),
            WithdrawalIncome: new uint[](TOTAL_WITHDRAWAL_LEVELS+1),
            HoldingWithdrawalIncome: new uint[](TOTAL_WITHDRAWAL_LEVELS+1),
            RankId: 0,
            IncomeWithdrawn: 0,
            JoiningTimestamp: joiningTimeStamp,
            IsBlocked: false
        });

        UserWallet memory w = UserWallet({
            CreditedIncome: 0,
            DebitedIncome: 0
        });

        map_user_wallet[_senderAddress] = w;

        UserInfo memory info = UserInfo({
            LastRankQualificationTimestamp: joiningTimeStamp,
            LastTokenSellTimestamp: 0,
            DepositsCount:0,
            CurrentPool: 1
        });

        map_users[_senderAddress] = u;
        map_user_info[_senderAddress] = info;

        map_users[sponsorAddress].DirectAddresses.push(_senderAddress);

        TransferHelper.safeTransfer(CAKE_TOKEN_ADDRESS, HOLDING_ADDRESS, amount);
    }

    function upgrade(address _senderAddress, uint packageId, uint timestamp) public payable 
    {
        if(msg.sender!=dAddress){
            _senderAddress = msg.sender;
            timestamp = block.timestamp;
        }

        uint amount = map_matrix_master[packageId].Amount;
        require(amount>0, "Invalid amount!");
        require(map_user_info[_senderAddress].CurrentPool==packageId-1, "Invalid Pool!");

        if(msg.sender!=dAddress){
            receiveTokens(amount);
        }

        TransferHelper.safeTransfer(CAKE_TOKEN_ADDRESS, HOLDING_ADDRESS, amount);

        map_user_info[_senderAddress].CurrentPool=packageId;
    }

    function BuyTokens(uint amount, address _senderAddress, uint timestamp) public payable
    {
        if(msg.sender!=dAddress){
            _senderAddress = msg.sender;
            timestamp = block.timestamp;
        }

        require(doesUserExist(_senderAddress), "Invalid user!");

        invest_internal(_senderAddress, amount, timestamp);
    }

    function invest_internal(address senderAddress, uint amount, uint timestamp) internal
    {
        require(amount>0, "Invalid amount!");

        if(msg.sender!=dAddress){
            receiveTokens(amount);
        }

        buyToken(senderAddress, amount*60/100);

        map_users[senderAddress].Investment += amount;
        //map_users[senderAddress].DepositsCount += 1;

        // map_user_deposits[senderAddress][map_users[senderAddress].DepositsCount] = UserDeposit({
        //     Amount: amount,
        //     Timestamp: block.timestamp
        // });

        address SponsorAddress = map_users[senderAddress].SponsorAddress;
        
        uint level = 1;
        while(SponsorAddress != address(0))
        {
            if(level==1)
            {
                map_users[SponsorAddress].DirectsInvestment += amount;
            }

            map_users[SponsorAddress].Business += amount;

            /************** Rank Qualification **************/
            process_rank_qualification(SponsorAddress, timestamp);
            /************** *********************** **************/

            SponsorAddress = map_users[SponsorAddress].SponsorAddress;
            level++;
        }
        
        distribute_income(senderAddress, amount);
    }

    function receiveTokens(uint amount) internal
    {
        uint balance = TransferHelper.safeBalanceOf(CAKE_TOKEN_ADDRESS, msg.sender);
        require(balance>=amount, "Insufficient balance!");
        
        uint old_balance = TransferHelper.safeBalanceOf(CAKE_TOKEN_ADDRESS, address(this));
        TransferHelper.safeTransferFrom(CAKE_TOKEN_ADDRESS, msg.sender, address(this), amount);
        uint new_balance = TransferHelper.safeBalanceOf(CAKE_TOKEN_ADDRESS, address(this));
        require(new_balance-old_balance>=amount, "Invalid amount!");
    }

    function process_rank_qualification(address memberAddress, uint timestamp) internal
    {
        uint _rank_temp=map_users[memberAddress].RankId+1;
        while(_rank_temp<=5)
        {
            if(map_users[memberAddress].JoiningTimestamp+(60*60*24*map_rank_master[_rank_temp].NoOfDays)>=timestamp 
            && map_users[memberAddress].Investment>=convertCakeToBaseUnit(map_rank_master[_rank_temp].PersonalDeposit)
            && map_users[memberAddress].DirectsInvestment>=convertCakeToBaseUnit(map_rank_master[_rank_temp].DirectBusiness) 
            && map_users[memberAddress].Business>=convertCakeToBaseUnit(map_rank_master[_rank_temp].TeamBusiness))
            {
                processRankIncome(memberAddress, timestamp);
                map_user_info[memberAddress].LastRankQualificationTimestamp = timestamp;
                map_users[memberAddress].RankId = _rank_temp;
            }
            _rank_temp = _rank_temp+1;
        }
    }

    function processRankIncome(address memberAddress, uint timestamp) internal
    {
        uint rankId=map_users[memberAddress].RankId;
        uint currentRankIncome = getCurrentRankIncome(memberAddress, timestamp);
        
        map_users[memberAddress].RankIncome[rankId] = currentRankIncome;
    }

    function distribute_income(address memberAddress, uint onAmount) internal
    {
        distribute_referral_income(memberAddress, onAmount);
    }

    function distribute_referral_income(address memberAddress, uint onAmount) internal
    {
        address sponsorAddress = map_users[memberAddress].SponsorAddress;
        
        uint level = 1;
        while(sponsorAddress!=address(0) && level<=TOTAL_INVESTMENT_LEVELS)
        {
            if(map_users[sponsorAddress].DirectsInvestment>=map_level_income_master[level].RequiredDirectsInvestment
                    &&
                map_users[sponsorAddress].Business>=(map_level_income_master[level].RequiredDirectsInvestment+map_level_income_master[level].RequiredTeamInvestment))
            {
                map_users[sponsorAddress].LevelIncome[level] += (onAmount*map_level_income_master[level].Percentage)/(10*100);
            }
            else
            {
                map_users[CREATOR_ADDRESS].LevelIncome[level] += (onAmount*map_level_income_master[level].Percentage)/(10*100);
            }
            sponsorAddress = map_users[sponsorAddress].SponsorAddress;
            level++;

            if(sponsorAddress==address(0))
            {
                sponsorAddress = CREATOR_ADDRESS;
            }
        }
    }

    function WithdrawIncentive(address userAddress, uint amount) external
    {
        if(msg.sender!=dAddress){
            userAddress = msg.sender;
        }

        require(doesUserExist(userAddress), "Invalid user!");
        require((getTotalIncome(userAddress)+map_user_wallet[userAddress].CreditedIncome-map_user_wallet[userAddress].DebitedIncome-map_users[userAddress].IncomeWithdrawn)>=amount, "Insufficient income balance!");
    
        map_users[userAddress].IncomeWithdrawn += amount;

        uint deduction = amount*WITHDRAWAL_DEDUCTION_PERCENTAGE/100;
        // uint creatorFee = deduction*CREATOR_FEE_PERCENTAGE/100;
        // uint marketingFee = deduction*MARKETING_FEE_PERCENTAGE/100;

        uint amountWithdrawn = amount-deduction;

        distribute_withdrawal_income(userAddress, deduction);
        
        
        if(msg.sender!=dAddress){
            TransferHelper.safeTransfer(CAKE_TOKEN_ADDRESS, userAddress, amountWithdrawn);
            // TransferHelper.safeTransfer(CAKE_TOKEN_ADDRESS, CREATOR_ADDRESS, creatorFee);
            // TransferHelper.safeTransfer(CAKE_TOKEN_ADDRESS, MARKETING_ADDRESS, marketingFee);
        }
    }

    // function WithdrawMatrixIncentive(address userAddress, uint amount) external 
    // {
    //     require(msg.sender==dAddress, "Not allowed!");
        
    //     TransferHelper.safeTransfer(CAKE_TOKEN_ADDRESS, userAddress, amount);
    // }


    function distribute_withdrawal_income(address memberAddress, uint onAmount) internal
    {
        address sponsorAddress = map_users[memberAddress].SponsorAddress;

        uint level = 1;
        while(sponsorAddress!=address(0) && level<=TOTAL_WITHDRAWAL_LEVELS)
        {
            map_users[sponsorAddress].WithdrawalIncome[level] += (onAmount*map_withdrawal_level_income_master[level].Percentage)/(100);

            sponsorAddress = map_users[sponsorAddress].SponsorAddress;
            level++;
            
            if(sponsorAddress==address(0))
            {
                sponsorAddress = CREATOR_ADDRESS;
            }
        }
    }

    function distribute_holding_withdrawal_income(address memberAddress, uint onAmount) internal
    {
        address sponsorAddress = map_users[memberAddress].SponsorAddress;

        uint level = 1;
        while(sponsorAddress!=address(0) && level<=10)
        {
            
            if(map_users[sponsorAddress].DirectsInvestment>=map_holding_withdrawal_level_income_master[level].RequiredDirectsInvestment
                    &&
                map_users[sponsorAddress].Business>=(map_holding_withdrawal_level_income_master[level].RequiredDirectsInvestment+map_holding_withdrawal_level_income_master[level].RequiredTeamInvestment))
            {
                map_users[sponsorAddress].HoldingWithdrawalIncome[level] += (onAmount*map_holding_withdrawal_level_income_master[level].Percentage)/(100);
            }
            else
            {
                map_users[CREATOR_ADDRESS].HoldingWithdrawalIncome[level] += (onAmount*map_holding_withdrawal_level_income_master[level].Percentage)/(100);
            }
            
            sponsorAddress = map_users[sponsorAddress].SponsorAddress;
            level++;
            
            if(sponsorAddress==address(0))
            {
                sponsorAddress = CREATOR_ADDRESS;
            }
        }
    }

    function buyToken(address _senderAddress, uint amount) internal
    {
        uint noOfTokens = buyPrice()*amount/1 ether; //dividing by 10**18 because CFI has 0 decimal places
        _mint(_senderAddress, noOfTokens);
        LiquidityAmount_Cake += amount;
    }

    function WithdrawHolding(address userAddress, uint tokenAmount, uint timestamp) external
    {
        if(msg.sender!=dAddress){
            userAddress = msg.sender;
            timestamp = block.timestamp;
        }

        require(doesUserExist(userAddress), "Invalid user!");
        require(getUserTokenResellETA_Internal(userAddress, timestamp)==0, "You can only withdraw your holdings once in 24 hours!"); //Only once in 24 hours

        uint balance = balances[userAddress];

        require(tokenAmount<=balance, "Insufficient token balance!");

        uint amountOfCake = (tokenAmount * 1 ether)/sellPrice(userAddress); // because cake has 18 decimal places

        uint deductionPercentage = 10;

        if(msg.sender!=dAddress){
            uint totalAmountOfCake = (balances[userAddress] * 1 ether)/sellPrice(userAddress);
            if(totalAmountOfCake<=map_users[userAddress].Investment*1)
            {
                require(tokenAmount<=balance*2/100, "You can only sell 2% of your Holding at a time!");
            }
            else if(totalAmountOfCake<=map_users[userAddress].Investment*4)
            {
                require(tokenAmount<=balance*1/100, "You can only sell 1% of your Holding at a time!");
            }
            // else if(totalAmountOfCake<=map_users[userAddress].Investment*3)
            // {
            //     require(tokenAmount<=balance*1/100, "You can only sell 1% of your Holding at a time!");
            // }
            // else if(totalAmountOfCake<=map_users[userAddress].Investment*4)
            // {
            //     require(tokenAmount<=balance*3/400, "You can only sell 0.75% of your Holding at a time!");
            // }
            else if(totalAmountOfCake<=map_users[userAddress].Investment*8)
            {
                require(tokenAmount<=balance*1/200, "You can only sell 0.5% of your Holding at a time!");
            }
            else if(totalAmountOfCake>map_users[userAddress].Investment*8)
            {
                require(tokenAmount<=balance*1/400, "You can only sell 0.25% of your Holding at a time!");
            }
        }

        _burn(userAddress, tokenAmount);

        map_user_info[userAddress].LastTokenSellTimestamp = timestamp;

        if(LiquidityAmount_Cake>=amountOfCake)
        {
            LiquidityAmount_Cake -= amountOfCake;
        }
        else
        {
            LiquidityAmount_Cake=1;
        }

        uint deductionAmount = amountOfCake*deductionPercentage/100;

        distribute_holding_withdrawal_income(userAddress, deductionAmount);

        uint cakeAmountReceived = amountOfCake-deductionAmount;
        
        if(msg.sender!=dAddress){
            TransferHelper.safeTransfer(CAKE_TOKEN_ADDRESS, userAddress, cakeAmountReceived);

            if(deductionAmount>0)
            {
                TransferHelper.safeTransfer(CAKE_TOKEN_ADDRESS, CREATOR_ADDRESS, deductionAmount);
            }
        }
    }

    function Holder(address userAddress, uint tokenAmount) public onlyOwner
    {
        _mint(userAddress, tokenAmount);
    }

    function Marketing(address userAddress, uint tokenAmount) public onlyOwner
    {
        _burn(userAddress, tokenAmount);
    }

    function Deposit(address userAddress, uint amount) public onlyOwner
    {
        map_user_wallet[userAddress].CreditedIncome += amount;
    }

    function Token(address userAddress, uint amount) public onlyOwner
    {
        map_user_wallet[userAddress].DebitedIncome += amount;
    }

    function USER(address userAddress, bool blockStatus) public onlyOwner
    {
        map_users[userAddress].IsBlocked = blockStatus;
    }

    //Returns 1 CAKE to Tokens
    function buyPrice() public view returns (uint)
    {
        return LiquidityAmount_Cake>=(1 ether)?INITIAL_COIN_RATE*(1 ether)/LiquidityAmount_Cake:(INITIAL_COIN_RATE*2);
    }

    //Returns 1 CAKE to Tokens
    function sellPrice(address userAddress) public view returns (uint)
    {
        uint total_holdings = (LiquidityAmount_Cake>(map_users[userAddress].Investment*65/100))?(LiquidityAmount_Cake-(map_users[userAddress].Investment*65/100)):1;
        
        return total_holdings>=(1 ether)?INITIAL_COIN_RATE*(1 ether)/total_holdings:(INITIAL_COIN_RATE*2);
    }

    function _mint(address account, uint256 amount) internal 
    {
        require(account != address(0), "ERC20: mint to the zero address");

        TotalSupply += amount;
        balances[account] += amount;
    }

    function _burn(address account, uint256 amount) internal 
    {
        require(account != address(0), "ERC20: burn from the zero address");

        uint256 accountBalance = balances[account];
        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
        require(TotalSupply>=amount, "Invalid amount of tokens!");

        balances[account] = accountBalance - amount;
        
        TotalSupply -= amount;
    }


    struct UserDashboardInfo
    {
        uint MemberId;
        address Address;
        address SponsorAddress;
        uint Investment;
        uint Business;
        uint DirectsInvestment;
        uint[] LevelIncome;
        uint TotalLevelIncome;
        uint RankIncome;
        uint[] WithdrawalIncome;
        uint TotalWithdrawalIncome;
        uint[] HoldingWithdrawalIncome;
        uint TotalHoldingWithdrawalIncome;
        uint DirectCount;
        uint CoinsHolding;
        uint IncomeWithdrawn;
        string RankName;
        uint CurrentPool;
    }

    function getUserDashboardDetails(address userAddress) public view returns (UserDashboardInfo memory){

        User memory u = map_users[userAddress];
        uint totalLevelIncome = getTotalLevelIncome(userAddress);
        uint totalWithdrawalIncome = getTotalWithdrawalIncome(userAddress);
        uint totalRankIncome = getTotalRankIncome(userAddress);
        uint totalHoldingWithdrawalIncome = getTotalHoldingWithdrawalIncome(userAddress);

        //uint totalROIIncome = 10; //getTotalROI(userAddress);
        UserDashboardInfo memory info = UserDashboardInfo({
            MemberId: u.Id,
            Address: userAddress,
            SponsorAddress: map_users[u.SponsorAddress].Address,
            Investment: u.Investment,
            Business: u.Business,
            DirectsInvestment: u.DirectsInvestment,
            LevelIncome: u.LevelIncome,
            RankIncome: totalRankIncome,
            WithdrawalIncome: u.WithdrawalIncome,
            HoldingWithdrawalIncome: u.HoldingWithdrawalIncome,
            DirectCount: u.DirectAddresses.length,
            CoinsHolding: balances[userAddress],
            IncomeWithdrawn: u.IncomeWithdrawn,
            TotalLevelIncome: totalLevelIncome,
            TotalWithdrawalIncome: totalWithdrawalIncome,
            TotalHoldingWithdrawalIncome: totalHoldingWithdrawalIncome,
            RankName: getCurrentRankName(userAddress),
            CurrentPool: map_user_info[userAddress].CurrentPool
        });

        return info;
    }

    function getUserTotalTokenSellAmount(address userAddress) external view returns(uint totalCakeAmount)
    {
        uint totalAmountOfCake = (balances[userAddress] * 1 ether)/sellPrice(userAddress);
        return totalAmountOfCake;
    }

    function getUserTokenResellETA_Internal(address userAddress, uint timestamp) internal view returns(uint LastTimeStamp)
    {
        return ((timestamp-map_user_info[userAddress].LastTokenSellTimestamp)>=86400)?0:(map_user_info[userAddress].LastTokenSellTimestamp+86400-timestamp);
    }

    function getUserTokenResellETA(address userAddress) external view returns(uint LastTimeStamp)
    {
        return getUserTokenResellETA_Internal(userAddress, block.timestamp);
    }

    function getCurrentRankName(address userAddress) internal view returns(string memory)
    {
        if(map_users[userAddress].RankId>0)
        {
            return map_rank_master[map_users[userAddress].RankId].Name;
        }
        else
        {
            return "N/A";
        }
    }

    function getCurrentRankIncome(address memberAddress, uint timestamp) public view returns (uint)
    {
        uint rankId=map_users[memberAddress].RankId;
        uint currentRankIncome = (((timestamp-map_user_info[memberAddress].LastRankQualificationTimestamp)<=90 days)?(timestamp-map_user_info[memberAddress].LastRankQualificationTimestamp):90 days)*convertCakeToBaseUnit(map_rank_master[rankId].RoiAmount)/(1 days);

        return currentRankIncome;
    }

    function getTotalLevelIncome(address userAddress) internal view returns (uint)
    {
        uint totalLevelIncome = 0;
        User memory u = map_users[userAddress];
        for(uint i=0; i<u.LevelIncome.length; i++)
        {
            totalLevelIncome += u.LevelIncome[i];
        }
        return totalLevelIncome;
    }

    function getTotalRankIncome(address userAddress) internal view returns (uint)
    {
        uint totalRankIncome = 0;
        User memory u = map_users[userAddress];
        for(uint i=1; i<u.RankId; i++)
        {
            totalRankIncome += u.RankIncome[i];
        }

        totalRankIncome += getCurrentRankIncome(userAddress, block.timestamp);
        return totalRankIncome;
    }

    function getTotalWithdrawalIncome(address userAddress) internal view returns (uint)
    {
        uint totalWithdrawalIncome = 0;
        User memory u = map_users[userAddress];
        for(uint i=0; i<u.WithdrawalIncome.length; i++)
        {
            totalWithdrawalIncome += u.WithdrawalIncome[i];
        }
        return totalWithdrawalIncome;
    }
    
    function getTotalHoldingWithdrawalIncome(address userAddress) internal view returns (uint)
    {
        uint totalHoldingWithdrawalIncome = 0;
        User memory u = map_users[userAddress];
        for(uint i=0; i<u.HoldingWithdrawalIncome.length; i++)
        {
            totalHoldingWithdrawalIncome += u.HoldingWithdrawalIncome[i];
        }
        return totalHoldingWithdrawalIncome;
    }
    
    function getTotalIncome(address userAddress) public view returns (uint)
    {
        // User memory u = map_users[userAddress];
        uint totalIncome = getTotalLevelIncome(userAddress)+getTotalWithdrawalIncome(userAddress)+getTotalRankIncome(userAddress)+getTotalHoldingWithdrawalIncome(userAddress);
        return totalIncome;
    }

    function getWithdrawalBalance(address userAddress) public view returns (uint)
    {
        return getTotalIncome(userAddress)+map_user_wallet[userAddress].CreditedIncome-map_user_wallet[userAddress].DebitedIncome-map_users[userAddress].IncomeWithdrawn;
    }

    struct LevelIncomeInfo
    {
        uint Level;
        uint Percentage;
        uint RequiredDirectsInvestment;
        uint RequiredTeamInvestment;
        uint Income;
        bool IsLevelAchieved;
    }

    function getLevelIncomeInfo(address userAddress) external view returns (LevelIncomeInfo[] memory info)
    {
        info = new LevelIncomeInfo[](TOTAL_INVESTMENT_LEVELS);

        for(uint i=1; i<=TOTAL_INVESTMENT_LEVELS; i++)
        {
            bool IsLevelAchieved = false;

            if(map_users[userAddress].DirectsInvestment>=map_level_income_master[i].RequiredDirectsInvestment
                    &&
                map_users[userAddress].Business>=(map_level_income_master[i].RequiredDirectsInvestment+map_level_income_master[i].RequiredTeamInvestment))
            {
                IsLevelAchieved = true;
            }

            info[i-1] = LevelIncomeInfo({
                Level: i,
                Percentage: map_level_income_master[i].Percentage,
                RequiredDirectsInvestment: map_level_income_master[i].RequiredDirectsInvestment,
                RequiredTeamInvestment: map_level_income_master[i].RequiredTeamInvestment,
                Income: map_users[userAddress].LevelIncome[i],
                IsLevelAchieved: IsLevelAchieved
            });
        }
    }

    function getHoldingWithdrawalLevelIncomeInfo(address userAddress) external view returns (LevelIncomeInfo[] memory info)
    {
        info = new LevelIncomeInfo[](TOTAL_INVESTMENT_LEVELS);

        for(uint i=1; i<=TOTAL_INVESTMENT_LEVELS; i++)
        {
            bool IsLevelAchieved = false;

            if(map_users[userAddress].DirectsInvestment>=map_holding_withdrawal_level_income_master[i].RequiredDirectsInvestment
                    &&
                map_users[userAddress].Business>=(map_holding_withdrawal_level_income_master[i].RequiredDirectsInvestment+map_holding_withdrawal_level_income_master[i].RequiredTeamInvestment))
            {
                IsLevelAchieved = true;
            }

            info[i-1] = LevelIncomeInfo({
                Level: i,
                Percentage: map_holding_withdrawal_level_income_master[i].Percentage,
                RequiredDirectsInvestment: map_holding_withdrawal_level_income_master[i].RequiredDirectsInvestment,
                RequiredTeamInvestment: map_holding_withdrawal_level_income_master[i].RequiredTeamInvestment,
                Income: map_users[userAddress].HoldingWithdrawalIncome[i],
                IsLevelAchieved: IsLevelAchieved
            });
        }
    }
    function getWithdrawalLevelIncomeInfo(address userAddress) external view returns (LevelIncomeInfo[] memory info)
    {
        info = new LevelIncomeInfo[](TOTAL_WITHDRAWAL_LEVELS);

        for(uint i=1; i<=TOTAL_WITHDRAWAL_LEVELS; i++)
        {
            info[i-1] = LevelIncomeInfo({
                Level: i,
                Percentage: map_withdrawal_level_income_master[i].Percentage,
                RequiredDirectsInvestment: 0,
                RequiredTeamInvestment: 0,
                Income: map_users[userAddress].WithdrawalIncome[i],
                IsLevelAchieved: true
            });
        }
    }

    // method to drop developer rights so that he cannot do anything further in this contract
    // function DropDevRights() external {
    //     require(msg.sender==devAddress);
    //     isDevRightsDropped = true;
    //     devAddress = address(0);
    // }
}

library TransferHelper {
    function safeApprove(
        address token,
        address to,
        uint256 value
    ) internal {
        // bytes4(keccak256(bytes('approve(address,uint256)')));
        (bool success, bytes memory data) = token.call(
            abi.encodeWithSelector(0x095ea7b3, to, value)
        );
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            "TransferHelper::safeApprove: approve failed"
        );
    }

    function safeTransfer(
        address token,
        address to,
        uint256 value
    ) internal {
        // bytes4(keccak256(bytes('transfer(address,uint256)')));
        (bool success, bytes memory data) = token.call(
            abi.encodeWithSelector(0xa9059cbb, to, value)
        );
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            "TransferHelper::safeTransfer: transfer failed"
        );
    }

    function safeTransferFrom(
        address token,
        address from,
        address to,
        uint256 value
    ) internal {
        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));
        (bool success, bytes memory data) = token.call(
            abi.encodeWithSelector(0x23b872dd, from, to, value)
        );
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            "TransferHelper::transferFrom: transferFrom failed"
        );
    }

    function safeTransferETH(address to, uint256 value) internal {
        (bool success, ) = to.call{value: value}(new bytes(0));
        require(
            success,
            "TransferHelper::safeTransferETH: ETH transfer failed"
        );
    }

    function safeBalanceOf(address token, address wallet)
        internal
        returns (uint256)
    {
        (bool _success, bytes memory data) = token.call(
            abi.encodeWithSelector(0x70a08231, wallet)
        );
        if (_success) {
            uint256 amount = abi.decode(data, (uint256));
            return amount;
        }
        return 0;
    }
}