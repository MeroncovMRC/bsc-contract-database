{"IERC20.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    \r\n    function symbol() external view returns(string memory);\r\n    \r\n    function name() external view returns(string memory);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n    \r\n    /**\r\n     * @dev Returns the number of decimal places\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"},"IUniswapV2Router02.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\n\r\n\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}"},"Ownable.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity 0.8.4;\r\n\r\n/**\r\n * @title Owner\r\n * @dev Set \u0026 change owner\r\n */\r\ncontract Ownable {\r\n\r\n    address private owner;\r\n    \r\n    // event for EVM logging\r\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\r\n    \r\n    // modifier to check if caller is owner\r\n    modifier onlyOwner() {\r\n        // If the first argument of \u0027require\u0027 evaluates to \u0027false\u0027, execution terminates and all\r\n        // changes to the state and to Ether balances are reverted.\r\n        // This used to consume all gas in old EVM versions, but not anymore.\r\n        // It is often a good idea to use \u0027require\u0027 to check if functions are called correctly.\r\n        // As a second argument, you can also provide an explanation about what went wrong.\r\n        require(msg.sender == owner, \"Caller is not owner\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Set contract deployer as owner\r\n     */\r\n    constructor() {\r\n        owner = msg.sender; // \u0027msg.sender\u0027 is sender of current call, contract deployer for a constructor\r\n        emit OwnerSet(address(0), owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Change owner\r\n     * @param newOwner address of new owner\r\n     */\r\n    function changeOwner(address newOwner) public onlyOwner {\r\n        emit OwnerSet(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Return owner address \r\n     * @return address of owner\r\n     */\r\n    function getOwner() external view returns (address) {\r\n        return owner;\r\n    }\r\n}"},"ResourceCollector.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./Ownable.sol\";\r\nimport \"./IUniswapV2Router02.sol\";\r\n\r\ninterface IXUSDReceiver {\r\n    function deposit(uint256 amount) external;\r\n}\r\n\r\ninterface IXSurge {\r\n    function sell(uint256 amount) external returns (address, uint256);\r\n    function getUnderlyingAssets() external view returns(address[] memory);\r\n}\r\n\r\ncontract SwapHelper {\r\n\r\n    address public immutable DEX;\r\n    IUniswapV2Router02 immutable public router;\r\n\r\n    constructor(address dex) {\r\n        DEX = dex;\r\n        router = IUniswapV2Router02(dex);\r\n    }\r\n\r\n    function _sellSurge(address surge) internal {\r\n        IXSurge(surge).sell(IERC20(surge).balanceOf(address(this)));\r\n    }\r\n\r\n    function _tokenToToken(address tokenIn, address tokenOut, uint256 amountIn) internal {\r\n\r\n        // approve router\r\n        IERC20(tokenIn).approve(DEX, amountIn);\r\n\r\n        address[] memory path = new address[](3);\r\n        path[0] = tokenIn;\r\n        path[1] = router.WETH();\r\n        path[2] = tokenOut;\r\n\r\n        // swap token for bnb\r\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(amountIn, 0, path, address(this), block.timestamp + 300);\r\n\r\n        delete path;\r\n    }\r\n\r\n    function _tokenToTokenDirect(address tokenIn, address tokenOut, uint256 amountIn) internal {\r\n    \r\n        // approve router\r\n        IERC20(tokenIn).approve(DEX, amountIn);\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = tokenIn;\r\n        path[1] = tokenOut;\r\n\r\n        // swap token for bnb\r\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(amountIn, 0, path, address(this), block.timestamp + 300);\r\n\r\n        delete path;\r\n    }\r\n\r\n    function _bnbToToken(address token, uint256 amount) internal {\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = router.WETH();\r\n        path[1] = token;\r\n\r\n        // swap token for bnb\r\n        router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount}(0, path, address(this), block.timestamp + 300);\r\n\r\n        delete path;\r\n    }\r\n\r\n    function _tokenToBNB(address tokenIn, uint256 amountIn) internal {\r\n\r\n        // approve router\r\n        IERC20(tokenIn).approve(DEX, amountIn);\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = tokenIn;\r\n        path[1] = router.WETH();\r\n\r\n        // swap token for bnb\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(amountIn, 0, path, address(this), block.timestamp + 300);\r\n\r\n        delete path;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n    Allocates XUSD Taxation Across Various Resources\r\n */\r\ncontract ResourceCollector is Ownable, SwapHelper(0x10ED43C718714eb63d5aA57B78B54704E256024E){\r\n\r\n    // receiving structure\r\n    struct Receiver {\r\n        uint256 points;\r\n        uint256 index;\r\n    }\r\n\r\n    // divides up XUSD based on resourcePoints / totalPoints\r\n    mapping ( address =\u003e Receiver ) public receivers;\r\n\r\n    // list of resources to receive funding\r\n    address[] public resources;\r\n\r\n    // total points\r\n    uint256 public totalPoints;\r\n\r\n    // XUSD Address\r\n    address public XUSD;\r\n\r\n    // Events\r\n    event ResourceAdded(address resource, uint256 points);\r\n    event ResourceRemoved(address resource);\r\n\r\n    constructor(address _XUSD){\r\n        XUSD = _XUSD;\r\n    }\r\n\r\n    function withdraw(address token) external onlyOwner {\r\n        IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this)));\r\n    }\r\n    \r\n    function withdraw() external onlyOwner {\r\n        (bool s,) = payable(msg.sender).call{value: address(this).balance}(\"\");\r\n        require(s);\r\n    }\r\n\r\n    function setXUSD(address XUSD_) external onlyOwner {\r\n        XUSD = XUSD_;\r\n    }\r\n\r\n    function tokenToBNB(address token) external onlyOwner {\r\n        if (IERC20(token).balanceOf(address(this)) \u003e 0) {\r\n            _tokenToBNB(token, IERC20(token).balanceOf(address(this)));\r\n        }\r\n    }\r\n\r\n    function bnbToToken(address token) external onlyOwner {\r\n        if (address(this).balance \u003e 0) {\r\n            _bnbToToken(token, address(this).balance);\r\n        }\r\n    }\r\n\r\n    function deliver() external onlyOwner {\r\n        _deliver();\r\n    }\r\n\r\n    function sellAndDeliver(address token) external onlyOwner {\r\n        _tokenToBNB(token, IERC20(token).balanceOf(address(this)));\r\n        _deliver();\r\n    }\r\n\r\n    function sellXUSDAndDeliver() external onlyOwner {\r\n        (address token,) = IXSurge(XUSD).sell(IERC20(XUSD).balanceOf(address(this)));\r\n        _tokenToBNB(token, IERC20(token).balanceOf(address(this)));\r\n        _deliver();\r\n    }\r\n\r\n    function sellAllAndDeliver() external {\r\n        if (IERC20(XUSD).balanceOf(address(this)) \u003e 0) {\r\n            _sellSurge(XUSD);\r\n        }\r\n        address[] memory tokensToSell = IXSurge(XUSD).getUnderlyingAssets();\r\n        for (uint i = 0; i \u003c tokensToSell.length; i++) {\r\n            if (IERC20(tokensToSell[i]).balanceOf(address(this)) \u003e 0) {\r\n                _tokenToBNB(tokensToSell[i], IERC20(tokensToSell[i]).balanceOf(address(this)));\r\n            }\r\n        }\r\n        _deliver();\r\n    }\r\n\r\n    function deliverToken(address token) external onlyOwner {\r\n        _deliverToken(token);\r\n    }\r\n\r\n    function deliverSellableTokens() external onlyOwner {\r\n        address[] memory tokensToSell = IXSurge(XUSD).getUnderlyingAssets();\r\n        for (uint i = 0; i \u003c tokensToSell.length; i++) {\r\n            if (IERC20(tokensToSell[i]).balanceOf(address(this)) \u003e 100) {\r\n                _deliverToken(tokensToSell[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _deliver() internal {\r\n        uint256[] memory distributions = _fetchDistribution(address(this).balance);        \r\n        for (uint i = 0; i \u003c resources.length; i++) {\r\n            if (distributions[i] \u003e 0) {\r\n                (bool s,) = payable(resources[i]).call{value: distributions[i]}(\"\");\r\n                require(s);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _deliverToken(address token) internal {\r\n        uint256[] memory distributions = _fetchDistribution(IERC20(token).balanceOf(address(this)));        \r\n        for (uint i = 0; i \u003c resources.length; i++) {\r\n            if (distributions[i] \u003e 0) {\r\n                IERC20(token).transfer(resources[i], distributions[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    function sellXUSD() external onlyOwner {\r\n        _sellSurge(XUSD);\r\n    }\r\n\r\n    function sellSurge(address surge) external onlyOwner {\r\n        _sellSurge(surge);\r\n    }\r\n\r\n    function changeResourcePoints(address resource, uint newPoints) external onlyOwner {\r\n        require(receivers[resource].points \u003e 0, \u0027No Points\u0027);\r\n        require(newPoints \u003e 0, \u0027Remove Resource If Points Are Set To Zero\u0027);\r\n\r\n        totalPoints = totalPoints - receivers[resource].points + newPoints;\r\n        receivers[resource].points = newPoints;\r\n    }\r\n\r\n    function addResource(\r\n        address resource,\r\n        uint256 points\r\n    ) external onlyOwner {\r\n\r\n        // set structure data\r\n        receivers[resource].points = points;\r\n        receivers[resource].index = resources.length;\r\n\r\n        // increment total points\r\n        totalPoints += points;\r\n\r\n        // add resource to list\r\n        resources.push(resource);\r\n        emit ResourceAdded(resource, points);\r\n    }\r\n\r\n    function removeResource(\r\n        address resource\r\n    ) external onlyOwner {\r\n        require(\r\n            receivers[resource].points \u003e 0,\r\n            \u0027Not Receiver\u0027\r\n        );\r\n\r\n        // decrement total points\r\n        totalPoints -= receivers[resource].points;\r\n\r\n        // remove element from array and mapping\r\n        receivers[\r\n            resources[resources.length - 1]\r\n        ].index = receivers[resource].index;\r\n        resources[\r\n            receivers[resource].index\r\n        ] = resources[resources.length - 1];\r\n        resources.pop();\r\n        delete receivers[resource];\r\n        emit ResourceRemoved(resource);\r\n    }\r\n\r\n    /**\r\n        Iterates through resources and fractions out amount\r\n        Between them based on their points score\r\n     */\r\n    function _fetchDistribution(uint256 amount) internal view returns (uint256[] memory) {\r\n        uint256[] memory distributions = new uint256[](resources.length);\r\n        for (uint i = 0; i \u003c resources.length; i++) {\r\n            distributions[i] = ( amount * receivers[resources[i]].points / totalPoints ) - 1;\r\n        }\r\n        return distributions;\r\n    }\r\n\r\n    receive() external payable {}\r\n}"}}