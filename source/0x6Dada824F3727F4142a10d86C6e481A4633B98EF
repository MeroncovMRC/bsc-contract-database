{"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n    @title ERC20 interface.\r\n    @author @farruhsydykov.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n        @dev returns the amount of tokens that currently exist.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n        @dev returns the amount of tokens owned by account.\r\n        @param account is the account which\u0027s balance is checked\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n        @dev sends caller\u0027s tokens to the recipient\u0027s account.\r\n        @param recipient account that will recieve tokens in case of transfer success\r\n        @param amount amount of tokens being sent\r\n        @return bool representing success of operation.\r\n        @notice if success emits transfer event\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n        @dev returns the remaining amount of tokens that spender is allowed\r\n        to spend on behalf of owner.\r\n        @param owner is the account which\u0027s tokens are allowed to be spent by spender.\r\n        @param spender is the account which is allowed to spend owners tokens.\r\n        @return amount of tokens in uint256 that are allowed to spender.\r\n        @notice allowance value changes when aprove or transferFrom functions are called.\r\n        @notice allowance is zero by default.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n        @dev allowes spender to spend a set amount of caller\u0027s tokens throught transferFrom.\r\n        @param spender is the account which will be allowed to spend owners tokens.\r\n        @param amount is the amount of caller\u0027s tokens allowed to be spent by spender.\r\n        @return bool representing a success or failure of the function call.\r\n        @notice emits and Approval event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n        @dev sends amount of allowed tokens from the sender\u0027s account to recipient\u0027saccount.\r\n        amount is then deducted from the caller\u0027s allowance.\r\n        @param sender is the account which\u0027s tokens are allowed to and sent by the caller.\r\n        @param recipient is the account which will receive tokens from the sender.\r\n        @param amount is the amount of tokens sent from the sender.\r\n        @return bool representing a success or a failure of transaction.\r\n        @notice emits Transfer event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n        @dev emitted when a transfer occures. Notifies about the value sent from which to which account.\r\n        @param from acccount that sent tokens.\r\n        @param to account that received tokens.\r\n        @param value value sent from sender to receiver.\r\n        @notice value may be zero\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n        @dev emitted when an account allowed another account to spend it\u0027s tokens on it\u0027s behalf.\r\n        @param owner owner of tokens which allowed it\u0027s tokens to be spent.\r\n        @param spender account who was allowed to spend tokens on another\u0027s account behalf.\r\n        @param value amount of tokens allowed to spend by spender from owner\u0027s account.\r\n        @notice value is always the allowed amount. It does not accumulated with calls to approve.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract Ownable {\r\n    address private _owner;\r\n\r\n    /**\r\n        @dev emitted when ownership is transfered \r\n     */\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n        @dev creates a contract instance and sets deployer as its _owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(msg.sender);\r\n    }\r\n\r\n    /**\r\n        @dev returns address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n        @dev checks if caller of the function is _owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == msg.sender, \"You are not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n       @dev transfers the ownership to 0x00 address.\r\n       @notice after renouncing contract ownership functions with onlyOwner modifier will not be accessible.\r\n       @notice can be called only be _owner\r\n    */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n        @dev transfers ownership to newOwner.\r\n        @notice can not be transfered to 0x00 addres.\r\n        @notice can be called only be _owner\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"zero address can not be owner\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n        @dev internal function to transfer ownership.\r\n        @notice can only be called internally and only by _owner.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}"},"WildGamesFive.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n\r\nimport \"./Ownable.sol\";\r\nimport \"./IERC20.sol\";\r\n\r\n\r\ncontract WildGamesFive is Ownable {\r\n    IERC20 paymentToken;\r\n    address public wildGamesVault;\r\n    uint8 public amountGamesUntilExtraGame;\r\n    mapping(address =\u003e uint256) public payments;\r\n    mapping(address =\u003e mapping(uint256 =\u003e uint256[])) private addressToGameIndexToGames;\r\n\r\n    struct Game {\r\n        uint128 id;\r\n        address[5] players;\r\n        uint8 playersNow;\r\n        uint8 extraGameFundCounter;\r\n        uint256 extraGameFundBalance;\r\n        address[] losers;\r\n        uint256 betValue;\r\n        uint256[5] playerNotes;\r\n    }\r\n\r\n    struct WinnerLog{\r\n        address winner;\r\n        uint256 gameId;\r\n        uint256 betValue;\r\n        uint256 winnerPayout;\r\n    }\r\n\r\n    Game[] public AllGames;\r\n    WinnerLog[] public AllWinners;\r\n\r\n    event UserEnteredGame(address indexed user, uint256 indexed betIndex, uint256 indexed gameIndex, address[5] participants);\r\n    event GameFinished(uint256 indexed betIndex, uint256 betValue, uint256 indexed gameIndex, address looser, address[5] participants);\r\n    event ExtraGameFinished(address loser, uint128 gameId, uint256 betValue, uint256 extraGameFundBalance);\r\n\r\n\r\n    constructor() {\r\n        paymentToken = IERC20(0x55d398326f99059fF775485246999027B3197955);\r\n        \r\n        wildGamesVault = 0xddF056C6C9907a29C3145B8C6e6924F9759103E4;\r\n        amountGamesUntilExtraGame = 100;\r\n\r\n         createGame(50000000000000000000); // 50\r\n        createGame(100000000000000000000); // 100\r\n        createGame(500000000000000000000); // 500\r\n        createGame(1000000000000000000000); // 1000\r\n        createGame(5000000000000000000000); // 5000\r\n        createGame(10000000000000000000000); // 10000\r\n        createGame(50000000000000000000000); // 50000\r\n        createGame(100000000000000000000000); // 100000\r\n\r\n        transferOwnership(0xddF056C6C9907a29C3145B8C6e6924F9759103E4);\r\n    }\r\n\r\n    function setPaymentToken(address _newPaymentToken) public onlyOwner   {\r\n        paymentToken = IERC20(_newPaymentToken);\r\n    }\r\n\r\n    function getTokenBalanceContract() external view returns(uint) {\r\n        return paymentToken.balanceOf(address(this));\r\n    }\r\n\r\n    function createGame(uint256 _betValue) public onlyOwner {\r\n        address[] memory emptyArr;\r\n        address[5] memory playersArr;\r\n        uint256[5] memory playersNotesArr;\r\n\r\n        AllGames.push(Game(0, playersArr, 0, 0 ,0, emptyArr, _betValue, playersNotesArr));\r\n    }\r\n\r\n    function getPaymentTokenBalance(address _who) public view returns(uint256) {\r\n        return paymentToken.balanceOf(_who);\r\n    }\r\n\r\n    function _DepositIntoContract( uint256 amount) internal  returns (bool) {\r\n        paymentToken.transferFrom(tx.origin,address(this), amount);\r\n        payments[tx.origin] += amount;\r\n        return true;\r\n    }\r\n\r\n    function checkAllowanceFrom(address _who) public view returns(uint256) {\r\n        return paymentToken.allowance(_who, address(this));\r\n    }\r\n\r\n    function withdrawContract() public onlyOwner {\r\n        paymentToken.transfer( owner(),  paymentToken.balanceOf(address(this)));\r\n    }\r\n\r\n    function getLosersByGame(uint _indexGame) public view returns(address[] memory) {\r\n        Game storage currentGame = AllGames[_indexGame];\r\n        return currentGame.losers;\r\n    }\r\n\r\n    function isPlayerInGame(address _player, uint _indexGame) public view returns(bool) {\r\n        Game memory currentGame = AllGames[_indexGame];\r\n        for(uint i = 0; i \u003c currentGame.players.length; i++) {\r\n            if(currentGame.players[i] == _player) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function enterinGame (uint _indexGame, uint256 _playerNote) public {\r\n        Game storage currentGame = AllGames[_indexGame];\r\n        require(!isPlayerInGame(msg.sender, _indexGame), \"you\u0027re already entered\");\r\n        require(checkAllowanceFrom(msg.sender) \u003e= currentGame.betValue, \"not enough allowance\");\r\n\r\n        _DepositIntoContract(currentGame.betValue);\r\n        pushPlayerIn(msg.sender, _indexGame, _playerNote);\r\n\r\n        addressToGameIndexToGames[msg.sender][_indexGame].push(currentGame.id);\r\n\r\n        currentGame.playersNow++;    \r\n\r\n        // check occupancy of players array\r\n        if(currentGame.playersNow == 5) {\r\n            drawProcess(_indexGame);\r\n            currentGame.extraGameFundCounter++;\r\n\r\n             if(currentGame.extraGameFundCounter == amountGamesUntilExtraGame) {\r\n            extraGameDraw(_indexGame);\r\n            currentGame.extraGameFundCounter = 0;\r\n        }\r\n        }\r\n\r\n       \r\n\r\n        emit UserEnteredGame(msg.sender, _indexGame, currentGame.id, currentGame.players);\r\n    }\r\n\r\n    function viewPlayersByGame(uint _indexGame) public view returns(address[5] memory) {\r\n        Game storage currentGame = AllGames[_indexGame];\r\n        return currentGame.players;\r\n    }\r\n\r\n    function pushPlayerIn(address _player, uint _index, uint256 _playerNote) internal {\r\n        Game storage currentGame = AllGames[_index];\r\n        for(uint i = 0; i \u003c currentGame.players.length; i++) {\r\n            if(currentGame.players[i] == address(0) ) {\r\n                currentGame.players[i] = _player;\r\n                currentGame.playerNotes[i] = _playerNote ;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function cancelBet( uint _indexGame) public  returns (bool) {\r\n        Game storage currentGame = AllGames[_indexGame];\r\n        require(isPlayerInGame(msg.sender, _indexGame), \"you\u0027re not a player\");\r\n        require(payments[msg.sender] \u003e= currentGame.betValue, \"not enough allowance for cancelBet\");\r\n\r\n        currentGame.playersNow--;    \r\n        addressToGameIndexToGames[msg.sender][_indexGame].pop();\r\n\r\n        for(uint i = 0; i \u003c currentGame.players.length; i++) {\r\n            if(msg.sender == currentGame.players[i]) {\r\n                delete currentGame.players[i];\r\n                delete currentGame.playerNotes[i];\r\n            }\r\n        }\r\n\r\n        payments[msg.sender] -= currentGame.betValue;\r\n        paymentToken.transfer(tx.origin, currentGame.betValue); //msg sender or tx origin?\r\n\r\n        return true;        \r\n    }\r\n\r\n    function removeGame(uint _indexGame) public onlyOwner{\r\n        delete AllGames[_indexGame];\r\n    }\r\n \r\n    function getAllGamesData() external view returns(Game[] memory) {\r\n        return AllGames;\r\n    }\r\n    \r\n    function getGameByIndex(uint _indexGame) external view returns(Game memory) {\r\n        return AllGames[_indexGame];\r\n    }\r\n\r\n ////////////////////////////////////////////\r\n    receive() external payable {}\r\n ////////////////////////////////////////////\r\n\r\n    function setAmountUntilExtra(uint8 _amount) public onlyOwner {\r\n        amountGamesUntilExtraGame = _amount;\r\n    }\r\n\r\n    function checkBalanceWildGamesVault() public onlyOwner view returns(uint256) {\r\n        return paymentToken.balanceOf(wildGamesVault);\r\n    }\r\n\r\n    function drawProcess(uint _indexGame) internal {\r\n        Game storage currentGame = AllGames[_indexGame];\r\n        // gameLogs[_indexGame].push(currentGame);\r\n        uint payoutForWinner = (currentGame.betValue * 120) / 100; //80%\r\n        uint indexLoser =  random(currentGame.players.length, _indexGame); \r\n\r\n        //send loser to losers list\r\n        currentGame.losers.push(currentGame.players[indexLoser]);\r\n\r\n        //distribute to winners\r\n        for (uint i = 0; i \u003c currentGame.players.length ; i++) {\r\n            if(i != indexLoser ) {\r\n                paymentToken.transfer( payable(currentGame.players[i]), payoutForWinner);\r\n            }\r\n        }\r\n\r\n        // distribute for WildGamesFund\r\n        paymentToken.transfer(wildGamesVault, (currentGame.betValue * 11/100)); //11%\r\n\r\n        // distribute to extraGameFund\r\n        currentGame.extraGameFundBalance += (currentGame.betValue * 9) / 100; //9%\r\n      \r\n\r\n        emit GameFinished(_indexGame, currentGame.betValue, currentGame.id++, currentGame.players[indexLoser], currentGame.players);\r\n\r\n        delete currentGame.players;\r\n        delete currentGame.playerNotes;\r\n        currentGame.playersNow = 0;\r\n\r\n    }\r\n\r\n    function setWildGamesFundReceiver(address _receiver) public onlyOwner {\r\n        wildGamesVault = _receiver;\r\n    }\r\n\r\n\r\n    function getAllGameIdsUserParticipated(address _user, uint256 _indexGame) external view returns (uint256[] memory) {\r\n        return addressToGameIndexToGames[_user][_indexGame];\r\n    }\r\n\r\n    function extraGameDraw(uint _indexGame) internal   {\r\n        Game storage currentGame = AllGames[_indexGame];\r\n        uint winnerIndex = random(currentGame.losers.length, _indexGame);\r\n        paymentToken.transfer(currentGame.losers[winnerIndex], currentGame.extraGameFundBalance);\r\n        emit ExtraGameFinished(currentGame.losers[winnerIndex], currentGame.id, currentGame.betValue, currentGame.extraGameFundBalance);\r\n        delete currentGame.losers;\r\n    }\r\n        \r\n    function random(uint _value, uint _indexGame) internal view returns(uint){\r\n        Game memory currentGame = AllGames[_indexGame];\r\n        return uint(keccak256(abi.encodePacked(block.timestamp,block.difficulty,blockhash(block.number - 1), currentGame.playerNotes, msg.sender))) % _value; //11 + add -1 to block number\r\n    }\r\n}"}}