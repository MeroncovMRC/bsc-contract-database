{"ABDKMath64x64.sol":{"content":"// SPDX-License-Identifier: BSD-4-Clause\r\n/*\r\n * ABDK Math 64.64 Smart Contract Library.  Copyright Â© 2019 by ABDK Consulting.\r\n * Author: Mikhail Vladimirov \u003cmikhail.vladimirov@gmail.com\u003e\r\n */\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * Smart contract library of mathematical functions operating with signed\r\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\r\n * basically a simple fraction whose numerator is signed 128-bit integer and\r\n * denominator is 2^64.  As long as denominator is always the same, there is no\r\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\r\n * represented by int128 type holding only the numerator.\r\n */\r\nlibrary ABDKMath64x64 {\r\n  /*\r\n   * Minimum value signed 64.64-bit fixed point number may have. \r\n   */\r\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\r\n\r\n  /*\r\n   * Maximum value signed 64.64-bit fixed point number may have. \r\n   */\r\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n  /**\r\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\r\n   * number.  Revert on overflow.\r\n   *\r\n   * @param x signed 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function fromInt (int256 x) internal pure returns (int128) {\r\n    unchecked {\r\n      require (x \u003e= -0x8000000000000000 \u0026\u0026 x \u003c= 0x7FFFFFFFFFFFFFFF);\r\n      return int128 (x \u003c\u003c 64);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\r\n   * rounding down.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64-bit integer number\r\n   */\r\n  function toInt (int128 x) internal pure returns (int64) {\r\n    unchecked {\r\n      return int64 (x \u003e\u003e 64);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\r\n   * number.  Revert on overflow.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function fromUInt (uint256 x) internal pure returns (int128) {\r\n    unchecked {\r\n      require (x \u003c= 0x7FFFFFFFFFFFFFFF);\r\n      return int128 (int256 (x \u003c\u003c 64));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\r\n   * number rounding down.  Revert on underflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return unsigned 64-bit integer number\r\n   */\r\n  function toUInt (int128 x) internal pure returns (uint64) {\r\n    unchecked {\r\n      require (x \u003e= 0);\r\n      return uint64 (uint128 (x \u003e\u003e 64));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\r\n   * number rounding down.  Revert on overflow.\r\n   *\r\n   * @param x signed 128.128-bin fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function from128x128 (int256 x) internal pure returns (int128) {\r\n    unchecked {\r\n      int256 result = x \u003e\u003e 64;\r\n      require (result \u003e= MIN_64x64 \u0026\u0026 result \u003c= MAX_64x64);\r\n      return int128 (result);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\r\n   * number.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 128.128 fixed point number\r\n   */\r\n  function to128x128 (int128 x) internal pure returns (int256) {\r\n    unchecked {\r\n      return int256 (x) \u003c\u003c 64;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x + y.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function add (int128 x, int128 y) internal pure returns (int128) {\r\n    unchecked {\r\n      int256 result = int256(x) + y;\r\n      require (result \u003e= MIN_64x64 \u0026\u0026 result \u003c= MAX_64x64);\r\n      return int128 (result);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x - y.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function sub (int128 x, int128 y) internal pure returns (int128) {\r\n    unchecked {\r\n      int256 result = int256(x) - y;\r\n      require (result \u003e= MIN_64x64 \u0026\u0026 result \u003c= MAX_64x64);\r\n      return int128 (result);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x * y rounding down.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function mul (int128 x, int128 y) internal pure returns (int128) {\r\n    unchecked {\r\n      int256 result = int256(x) * y \u003e\u003e 64;\r\n      require (result \u003e= MIN_64x64 \u0026\u0026 result \u003c= MAX_64x64);\r\n      return int128 (result);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\r\n   * number and y is signed 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64 fixed point number\r\n   * @param y signed 256-bit integer number\r\n   * @return signed 256-bit integer number\r\n   */\r\n  function muli (int128 x, int256 y) internal pure returns (int256) {\r\n    unchecked {\r\n      if (x == MIN_64x64) {\r\n        require (y \u003e= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF \u0026\u0026\r\n          y \u003c= 0x1000000000000000000000000000000000000000000000000);\r\n        return -y \u003c\u003c 63;\r\n      } else {\r\n        bool negativeResult = false;\r\n        if (x \u003c 0) {\r\n          x = -x;\r\n          negativeResult = true;\r\n        }\r\n        if (y \u003c 0) {\r\n          y = -y; // We rely on overflow behavior here\r\n          negativeResult = !negativeResult;\r\n        }\r\n        uint256 absoluteResult = mulu (x, uint256 (y));\r\n        if (negativeResult) {\r\n          require (absoluteResult \u003c=\r\n            0x8000000000000000000000000000000000000000000000000000000000000000);\r\n          return -int256 (absoluteResult); // We rely on overflow behavior here\r\n        } else {\r\n          require (absoluteResult \u003c=\r\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n          return int256 (absoluteResult);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\r\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64 fixed point number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return unsigned 256-bit integer number\r\n   */\r\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\r\n    unchecked {\r\n      if (y == 0) return 0;\r\n\r\n      require (x \u003e= 0);\r\n\r\n      uint256 lo = (uint256 (int256 (x)) * (y \u0026 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) \u003e\u003e 64;\r\n      uint256 hi = uint256 (int256 (x)) * (y \u003e\u003e 128);\r\n\r\n      require (hi \u003c= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n      hi \u003c\u003c= 64;\r\n\r\n      require (hi \u003c=\r\n        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\r\n      return hi + lo;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\r\n   * zero.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function div (int128 x, int128 y) internal pure returns (int128) {\r\n    unchecked {\r\n      require (y != 0);\r\n      int256 result = (int256 (x) \u003c\u003c 64) / y;\r\n      require (result \u003e= MIN_64x64 \u0026\u0026 result \u003c= MAX_64x64);\r\n      return int128 (result);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x signed 256-bit integer number\r\n   * @param y signed 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function divi (int256 x, int256 y) internal pure returns (int128) {\r\n    unchecked {\r\n      require (y != 0);\r\n\r\n      bool negativeResult = false;\r\n      if (x \u003c 0) {\r\n        x = -x; // We rely on overflow behavior here\r\n        negativeResult = true;\r\n      }\r\n      if (y \u003c 0) {\r\n        y = -y; // We rely on overflow behavior here\r\n        negativeResult = !negativeResult;\r\n      }\r\n      uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\r\n      if (negativeResult) {\r\n        require (absoluteResult \u003c= 0x80000000000000000000000000000000);\r\n        return -int128 (absoluteResult); // We rely on overflow behavior here\r\n      } else {\r\n        require (absoluteResult \u003c= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n        return int128 (absoluteResult); // We rely on overflow behavior here\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function divu (uint256 x, uint256 y) internal pure returns (int128) {\r\n    unchecked {\r\n      require (y != 0);\r\n      uint128 result = divuu (x, y);\r\n      require (result \u003c= uint128 (MAX_64x64));\r\n      return int128 (result);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate -x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function neg (int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n      require (x != MIN_64x64);\r\n      return -x;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate |x|.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function abs (int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n      require (x != MIN_64x64);\r\n      return x \u003c 0 ? -x : x;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\r\n   * zero.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function inv (int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n      require (x != 0);\r\n      int256 result = int256 (0x100000000000000000000000000000000) / x;\r\n      require (result \u003e= MIN_64x64 \u0026\u0026 result \u003c= MAX_64x64);\r\n      return int128 (result);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function avg (int128 x, int128 y) internal pure returns (int128) {\r\n    unchecked {\r\n      return int128 ((int256 (x) + int256 (y)) \u003e\u003e 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\r\n   * Revert on overflow or in case x * y is negative.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function gavg (int128 x, int128 y) internal pure returns (int128) {\r\n    unchecked {\r\n      int256 m = int256 (x) * int256 (y);\r\n      require (m \u003e= 0);\r\n      require (m \u003c\r\n          0x4000000000000000000000000000000000000000000000000000000000000000);\r\n      return int128 (sqrtu (uint256 (m)));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\r\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y uint256 value\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function pow (int128 x, uint256 y) internal pure returns (int128) {\r\n    unchecked {\r\n      bool negative = x \u003c 0 \u0026\u0026 y \u0026 1 == 1;\r\n\r\n      uint256 absX = uint128 (x \u003c 0 ? -x : x);\r\n      uint256 absResult;\r\n      absResult = 0x100000000000000000000000000000000;\r\n\r\n      if (absX \u003c= 0x10000000000000000) {\r\n        absX \u003c\u003c= 63;\r\n        while (y != 0) {\r\n          if (y \u0026 0x1 != 0) {\r\n            absResult = absResult * absX \u003e\u003e 127;\r\n          }\r\n          absX = absX * absX \u003e\u003e 127;\r\n\r\n          if (y \u0026 0x2 != 0) {\r\n            absResult = absResult * absX \u003e\u003e 127;\r\n          }\r\n          absX = absX * absX \u003e\u003e 127;\r\n\r\n          if (y \u0026 0x4 != 0) {\r\n            absResult = absResult * absX \u003e\u003e 127;\r\n          }\r\n          absX = absX * absX \u003e\u003e 127;\r\n\r\n          if (y \u0026 0x8 != 0) {\r\n            absResult = absResult * absX \u003e\u003e 127;\r\n          }\r\n          absX = absX * absX \u003e\u003e 127;\r\n\r\n          y \u003e\u003e= 4;\r\n        }\r\n\r\n        absResult \u003e\u003e= 64;\r\n      } else {\r\n        uint256 absXShift = 63;\r\n        if (absX \u003c 0x1000000000000000000000000) { absX \u003c\u003c= 32; absXShift -= 32; }\r\n        if (absX \u003c 0x10000000000000000000000000000) { absX \u003c\u003c= 16; absXShift -= 16; }\r\n        if (absX \u003c 0x1000000000000000000000000000000) { absX \u003c\u003c= 8; absXShift -= 8; }\r\n        if (absX \u003c 0x10000000000000000000000000000000) { absX \u003c\u003c= 4; absXShift -= 4; }\r\n        if (absX \u003c 0x40000000000000000000000000000000) { absX \u003c\u003c= 2; absXShift -= 2; }\r\n        if (absX \u003c 0x80000000000000000000000000000000) { absX \u003c\u003c= 1; absXShift -= 1; }\r\n\r\n        uint256 resultShift = 0;\r\n        while (y != 0) {\r\n          require (absXShift \u003c 64);\r\n\r\n          if (y \u0026 0x1 != 0) {\r\n            absResult = absResult * absX \u003e\u003e 127;\r\n            resultShift += absXShift;\r\n            if (absResult \u003e 0x100000000000000000000000000000000) {\r\n              absResult \u003e\u003e= 1;\r\n              resultShift += 1;\r\n            }\r\n          }\r\n          absX = absX * absX \u003e\u003e 127;\r\n          absXShift \u003c\u003c= 1;\r\n          if (absX \u003e= 0x100000000000000000000000000000000) {\r\n              absX \u003e\u003e= 1;\r\n              absXShift += 1;\r\n          }\r\n\r\n          y \u003e\u003e= 1;\r\n        }\r\n\r\n        require (resultShift \u003c 64);\r\n        absResult \u003e\u003e= 64 - resultShift;\r\n      }\r\n      int256 result = negative ? -int256 (absResult) : int256 (absResult);\r\n      require (result \u003e= MIN_64x64 \u0026\u0026 result \u003c= MAX_64x64);\r\n      return int128 (result);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate sqrt (x) rounding down.  Revert if x \u003c 0.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function sqrt (int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n      require (x \u003e= 0);\r\n      return int128 (sqrtu (uint256 (int256 (x)) \u003c\u003c 64));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate binary logarithm of x.  Revert if x \u003c= 0.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function log_2 (int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n      require (x \u003e 0);\r\n\r\n      int256 msb = 0;\r\n      int256 xc = x;\r\n      if (xc \u003e= 0x10000000000000000) { xc \u003e\u003e= 64; msb += 64; }\r\n      if (xc \u003e= 0x100000000) { xc \u003e\u003e= 32; msb += 32; }\r\n      if (xc \u003e= 0x10000) { xc \u003e\u003e= 16; msb += 16; }\r\n      if (xc \u003e= 0x100) { xc \u003e\u003e= 8; msb += 8; }\r\n      if (xc \u003e= 0x10) { xc \u003e\u003e= 4; msb += 4; }\r\n      if (xc \u003e= 0x4) { xc \u003e\u003e= 2; msb += 2; }\r\n      if (xc \u003e= 0x2) msb += 1;  // No need to shift xc anymore\r\n\r\n      int256 result = msb - 64 \u003c\u003c 64;\r\n      uint256 ux = uint256 (int256 (x)) \u003c\u003c uint256 (127 - msb);\r\n      for (int256 bit = 0x8000000000000000; bit \u003e 0; bit \u003e\u003e= 1) {\r\n        ux *= ux;\r\n        uint256 b = ux \u003e\u003e 255;\r\n        ux \u003e\u003e= 127 + b;\r\n        result += bit * int256 (b);\r\n      }\r\n\r\n      return int128 (result);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate natural logarithm of x.  Revert if x \u003c= 0.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function ln (int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n      require (x \u003e 0);\r\n\r\n      return int128 (int256 (\r\n          uint256 (int256 (log_2 (x))) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF \u003e\u003e 128));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate binary exponent of x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function exp_2 (int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n      require (x \u003c 0x400000000000000000); // Overflow\r\n\r\n      if (x \u003c -0x400000000000000000) return 0; // Underflow\r\n\r\n      uint256 result = 0x80000000000000000000000000000000;\r\n\r\n      if (x \u0026 0x8000000000000000 \u003e 0)\r\n        result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E \u003e\u003e 128;\r\n      if (x \u0026 0x4000000000000000 \u003e 0)\r\n        result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC \u003e\u003e 128;\r\n      if (x \u0026 0x2000000000000000 \u003e 0)\r\n        result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F \u003e\u003e 128;\r\n      if (x \u0026 0x1000000000000000 \u003e 0)\r\n        result = result * 0x10B5586CF9890F6298B92B71842A98363 \u003e\u003e 128;\r\n      if (x \u0026 0x800000000000000 \u003e 0)\r\n        result = result * 0x1059B0D31585743AE7C548EB68CA417FD \u003e\u003e 128;\r\n      if (x \u0026 0x400000000000000 \u003e 0)\r\n        result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 \u003e\u003e 128;\r\n      if (x \u0026 0x200000000000000 \u003e 0)\r\n        result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F \u003e\u003e 128;\r\n      if (x \u0026 0x100000000000000 \u003e 0)\r\n        result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 \u003e\u003e 128;\r\n      if (x \u0026 0x80000000000000 \u003e 0)\r\n        result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B \u003e\u003e 128;\r\n      if (x \u0026 0x40000000000000 \u003e 0)\r\n        result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F \u003e\u003e 128;\r\n      if (x \u0026 0x20000000000000 \u003e 0)\r\n        result = result * 0x100162F3904051FA128BCA9C55C31E5DF \u003e\u003e 128;\r\n      if (x \u0026 0x10000000000000 \u003e 0)\r\n        result = result * 0x1000B175EFFDC76BA38E31671CA939725 \u003e\u003e 128;\r\n      if (x \u0026 0x8000000000000 \u003e 0)\r\n        result = result * 0x100058BA01FB9F96D6CACD4B180917C3D \u003e\u003e 128;\r\n      if (x \u0026 0x4000000000000 \u003e 0)\r\n        result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 \u003e\u003e 128;\r\n      if (x \u0026 0x2000000000000 \u003e 0)\r\n        result = result * 0x1000162E525EE054754457D5995292026 \u003e\u003e 128;\r\n      if (x \u0026 0x1000000000000 \u003e 0)\r\n        result = result * 0x10000B17255775C040618BF4A4ADE83FC \u003e\u003e 128;\r\n      if (x \u0026 0x800000000000 \u003e 0)\r\n        result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB \u003e\u003e 128;\r\n      if (x \u0026 0x400000000000 \u003e 0)\r\n        result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 \u003e\u003e 128;\r\n      if (x \u0026 0x200000000000 \u003e 0)\r\n        result = result * 0x10000162E43F4F831060E02D839A9D16D \u003e\u003e 128;\r\n      if (x \u0026 0x100000000000 \u003e 0)\r\n        result = result * 0x100000B1721BCFC99D9F890EA06911763 \u003e\u003e 128;\r\n      if (x \u0026 0x80000000000 \u003e 0)\r\n        result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 \u003e\u003e 128;\r\n      if (x \u0026 0x40000000000 \u003e 0)\r\n        result = result * 0x1000002C5C863B73F016468F6BAC5CA2B \u003e\u003e 128;\r\n      if (x \u0026 0x20000000000 \u003e 0)\r\n        result = result * 0x100000162E430E5A18F6119E3C02282A5 \u003e\u003e 128;\r\n      if (x \u0026 0x10000000000 \u003e 0)\r\n        result = result * 0x1000000B1721835514B86E6D96EFD1BFE \u003e\u003e 128;\r\n      if (x \u0026 0x8000000000 \u003e 0)\r\n        result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF \u003e\u003e 128;\r\n      if (x \u0026 0x4000000000 \u003e 0)\r\n        result = result * 0x10000002C5C8601CC6B9E94213C72737A \u003e\u003e 128;\r\n      if (x \u0026 0x2000000000 \u003e 0)\r\n        result = result * 0x1000000162E42FFF037DF38AA2B219F06 \u003e\u003e 128;\r\n      if (x \u0026 0x1000000000 \u003e 0)\r\n        result = result * 0x10000000B17217FBA9C739AA5819F44F9 \u003e\u003e 128;\r\n      if (x \u0026 0x800000000 \u003e 0)\r\n        result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 \u003e\u003e 128;\r\n      if (x \u0026 0x400000000 \u003e 0)\r\n        result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 \u003e\u003e 128;\r\n      if (x \u0026 0x200000000 \u003e 0)\r\n        result = result * 0x10000000162E42FF0999CE3541B9FFFCF \u003e\u003e 128;\r\n      if (x \u0026 0x100000000 \u003e 0)\r\n        result = result * 0x100000000B17217F80F4EF5AADDA45554 \u003e\u003e 128;\r\n      if (x \u0026 0x80000000 \u003e 0)\r\n        result = result * 0x10000000058B90BFBF8479BD5A81B51AD \u003e\u003e 128;\r\n      if (x \u0026 0x40000000 \u003e 0)\r\n        result = result * 0x1000000002C5C85FDF84BD62AE30A74CC \u003e\u003e 128;\r\n      if (x \u0026 0x20000000 \u003e 0)\r\n        result = result * 0x100000000162E42FEFB2FED257559BDAA \u003e\u003e 128;\r\n      if (x \u0026 0x10000000 \u003e 0)\r\n        result = result * 0x1000000000B17217F7D5A7716BBA4A9AE \u003e\u003e 128;\r\n      if (x \u0026 0x8000000 \u003e 0)\r\n        result = result * 0x100000000058B90BFBE9DDBAC5E109CCE \u003e\u003e 128;\r\n      if (x \u0026 0x4000000 \u003e 0)\r\n        result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D \u003e\u003e 128;\r\n      if (x \u0026 0x2000000 \u003e 0)\r\n        result = result * 0x1000000000162E42FEFA494F1478FDE05 \u003e\u003e 128;\r\n      if (x \u0026 0x1000000 \u003e 0)\r\n        result = result * 0x10000000000B17217F7D20CF927C8E94C \u003e\u003e 128;\r\n      if (x \u0026 0x800000 \u003e 0)\r\n        result = result * 0x1000000000058B90BFBE8F71CB4E4B33D \u003e\u003e 128;\r\n      if (x \u0026 0x400000 \u003e 0)\r\n        result = result * 0x100000000002C5C85FDF477B662B26945 \u003e\u003e 128;\r\n      if (x \u0026 0x200000 \u003e 0)\r\n        result = result * 0x10000000000162E42FEFA3AE53369388C \u003e\u003e 128;\r\n      if (x \u0026 0x100000 \u003e 0)\r\n        result = result * 0x100000000000B17217F7D1D351A389D40 \u003e\u003e 128;\r\n      if (x \u0026 0x80000 \u003e 0)\r\n        result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE \u003e\u003e 128;\r\n      if (x \u0026 0x40000 \u003e 0)\r\n        result = result * 0x1000000000002C5C85FDF4741BEA6E77E \u003e\u003e 128;\r\n      if (x \u0026 0x20000 \u003e 0)\r\n        result = result * 0x100000000000162E42FEFA39FE95583C2 \u003e\u003e 128;\r\n      if (x \u0026 0x10000 \u003e 0)\r\n        result = result * 0x1000000000000B17217F7D1CFB72B45E1 \u003e\u003e 128;\r\n      if (x \u0026 0x8000 \u003e 0)\r\n        result = result * 0x100000000000058B90BFBE8E7CC35C3F0 \u003e\u003e 128;\r\n      if (x \u0026 0x4000 \u003e 0)\r\n        result = result * 0x10000000000002C5C85FDF473E242EA38 \u003e\u003e 128;\r\n      if (x \u0026 0x2000 \u003e 0)\r\n        result = result * 0x1000000000000162E42FEFA39F02B772C \u003e\u003e 128;\r\n      if (x \u0026 0x1000 \u003e 0)\r\n        result = result * 0x10000000000000B17217F7D1CF7D83C1A \u003e\u003e 128;\r\n      if (x \u0026 0x800 \u003e 0)\r\n        result = result * 0x1000000000000058B90BFBE8E7BDCBE2E \u003e\u003e 128;\r\n      if (x \u0026 0x400 \u003e 0)\r\n        result = result * 0x100000000000002C5C85FDF473DEA871F \u003e\u003e 128;\r\n      if (x \u0026 0x200 \u003e 0)\r\n        result = result * 0x10000000000000162E42FEFA39EF44D91 \u003e\u003e 128;\r\n      if (x \u0026 0x100 \u003e 0)\r\n        result = result * 0x100000000000000B17217F7D1CF79E949 \u003e\u003e 128;\r\n      if (x \u0026 0x80 \u003e 0)\r\n        result = result * 0x10000000000000058B90BFBE8E7BCE544 \u003e\u003e 128;\r\n      if (x \u0026 0x40 \u003e 0)\r\n        result = result * 0x1000000000000002C5C85FDF473DE6ECA \u003e\u003e 128;\r\n      if (x \u0026 0x20 \u003e 0)\r\n        result = result * 0x100000000000000162E42FEFA39EF366F \u003e\u003e 128;\r\n      if (x \u0026 0x10 \u003e 0)\r\n        result = result * 0x1000000000000000B17217F7D1CF79AFA \u003e\u003e 128;\r\n      if (x \u0026 0x8 \u003e 0)\r\n        result = result * 0x100000000000000058B90BFBE8E7BCD6D \u003e\u003e 128;\r\n      if (x \u0026 0x4 \u003e 0)\r\n        result = result * 0x10000000000000002C5C85FDF473DE6B2 \u003e\u003e 128;\r\n      if (x \u0026 0x2 \u003e 0)\r\n        result = result * 0x1000000000000000162E42FEFA39EF358 \u003e\u003e 128;\r\n      if (x \u0026 0x1 \u003e 0)\r\n        result = result * 0x10000000000000000B17217F7D1CF79AB \u003e\u003e 128;\r\n\r\n      result \u003e\u003e= uint256 (int256 (63 - (x \u003e\u003e 64)));\r\n      require (result \u003c= uint256 (int256 (MAX_64x64)));\r\n\r\n      return int128 (int256 (result));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate natural exponent of x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function exp (int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n      require (x \u003c 0x400000000000000000); // Overflow\r\n\r\n      if (x \u003c -0x400000000000000000) return 0; // Underflow\r\n\r\n      return exp_2 (\r\n          int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 \u003e\u003e 128));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return unsigned 64.64-bit fixed point number\r\n   */\r\n  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\r\n    unchecked {\r\n      require (y != 0);\r\n\r\n      uint256 result;\r\n\r\n      if (x \u003c= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n        result = (x \u003c\u003c 64) / y;\r\n      else {\r\n        uint256 msb = 192;\r\n        uint256 xc = x \u003e\u003e 192;\r\n        if (xc \u003e= 0x100000000) { xc \u003e\u003e= 32; msb += 32; }\r\n        if (xc \u003e= 0x10000) { xc \u003e\u003e= 16; msb += 16; }\r\n        if (xc \u003e= 0x100) { xc \u003e\u003e= 8; msb += 8; }\r\n        if (xc \u003e= 0x10) { xc \u003e\u003e= 4; msb += 4; }\r\n        if (xc \u003e= 0x4) { xc \u003e\u003e= 2; msb += 2; }\r\n        if (xc \u003e= 0x2) msb += 1;  // No need to shift xc anymore\r\n\r\n        result = (x \u003c\u003c 255 - msb) / ((y - 1 \u003e\u003e msb - 191) + 1);\r\n        require (result \u003c= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n        uint256 hi = result * (y \u003e\u003e 128);\r\n        uint256 lo = result * (y \u0026 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n        uint256 xh = x \u003e\u003e 192;\r\n        uint256 xl = x \u003c\u003c 64;\r\n\r\n        if (xl \u003c lo) xh -= 1;\r\n        xl -= lo; // We rely on overflow behavior here\r\n        lo = hi \u003c\u003c 128;\r\n        if (xl \u003c lo) xh -= 1;\r\n        xl -= lo; // We rely on overflow behavior here\r\n\r\n        assert (xh == hi \u003e\u003e 128);\r\n\r\n        result += xl / y;\r\n      }\r\n\r\n      require (result \u003c= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n      return uint128 (result);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\r\n   * number.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @return unsigned 128-bit integer number\r\n   */\r\n  function sqrtu (uint256 x) private pure returns (uint128) {\r\n    unchecked {\r\n      if (x == 0) return 0;\r\n      else {\r\n        uint256 xx = x;\r\n        uint256 r = 1;\r\n        if (xx \u003e= 0x100000000000000000000000000000000) { xx \u003e\u003e= 128; r \u003c\u003c= 64; }\r\n        if (xx \u003e= 0x10000000000000000) { xx \u003e\u003e= 64; r \u003c\u003c= 32; }\r\n        if (xx \u003e= 0x100000000) { xx \u003e\u003e= 32; r \u003c\u003c= 16; }\r\n        if (xx \u003e= 0x10000) { xx \u003e\u003e= 16; r \u003c\u003c= 8; }\r\n        if (xx \u003e= 0x100) { xx \u003e\u003e= 8; r \u003c\u003c= 4; }\r\n        if (xx \u003e= 0x10) { xx \u003e\u003e= 4; r \u003c\u003c= 2; }\r\n        if (xx \u003e= 0x8) { r \u003c\u003c= 1; }\r\n        r = (r + x / r) \u003e\u003e 1;\r\n        r = (r + x / r) \u003e\u003e 1;\r\n        r = (r + x / r) \u003e\u003e 1;\r\n        r = (r + x / r) \u003e\u003e 1;\r\n        r = (r + x / r) \u003e\u003e 1;\r\n        r = (r + x / r) \u003e\u003e 1;\r\n        r = (r + x / r) \u003e\u003e 1; // Seven iterations should be enough\r\n        uint256 r1 = x / r;\r\n        return uint128 (r \u003c r1 ? r : r1);\r\n      }\r\n    }\r\n  }\r\n}"},"BatchClaimXEN.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.7;\r\n\r\ncontract BatchClaimXEN {\r\n\t// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1167.md\r\n\tbytes miniProxy;\t\t\t  // = 0x363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3;\r\n    address private immutable original;\r\n\taddress private immutable deployer;\r\n\t//address private constant XEN = 0x06450dEe7FD2Fb8E39061434BAbCFC05599a6Fb8;\r\n\taddress private constant XEN = 0x379ac54558fFF7d922e7e857727d0fD6f26E8231;\r\n\tmapping (address=\u003euint) public countClaimRank;\r\n\tmapping (address=\u003euint) public countClaimMint;\r\n\t\r\n\tconstructor() {\r\n\t\tminiProxy = bytes.concat(bytes20(0x3D602d80600A3D3981F3363d3d373d3D3D363d73), bytes20(address(this)), bytes15(0x5af43d82803e903d91602b57fd5bf3));\r\n        original = address(this);\r\n\t\tdeployer = msg.sender;\r\n\t}\r\n\r\n\tfunction batchClaimRank(uint times, uint term) external {\r\n\t\tbytes memory bytecode = miniProxy;\r\n\t\taddress proxy;\r\n\t\tuint N = countClaimRank[msg.sender];\r\n\t\tfor(uint i=N; i\u003cN+times; i++) {\r\n\t        bytes32 salt = keccak256(abi.encodePacked(msg.sender, i));\r\n\t\t\tassembly {\r\n\t            proxy := create2(0, add(bytecode, 32), mload(bytecode), salt)\r\n\t\t\t}\r\n\t\t\tBatchClaimXEN(proxy).claimRank(term);\r\n\t\t}\r\n\t\tcountClaimRank[msg.sender] = N+times;\r\n\t}\r\n\r\n\tfunction claimRank(uint term) external {\r\n\t\tIXEN(XEN).claimRank(term);\r\n\t}\r\n\r\n    function proxyFor(address sender, uint i) public view returns (address proxy) {\r\n        bytes32 salt = keccak256(abi.encodePacked(sender, i));\r\n        proxy = address(uint160(uint(keccak256(abi.encodePacked(\r\n                hex\u0027ff\u0027,\r\n                address(this),\r\n                salt,\r\n                keccak256(abi.encodePacked(miniProxy))\r\n            )))));\r\n    }\r\n\r\n\tfunction batchClaimMintReward(uint times) external {\r\n\t\tuint M = countClaimMint[msg.sender];\r\n\t\tuint N = countClaimRank[msg.sender];\r\n\t\tN = M+times \u003c N ? M+times : N;\r\n\t\tfor(uint i=M; i\u003cN; i++) {\r\n\t        address proxy = proxyFor(msg.sender, i);\r\n\t\t\tBatchClaimXEN(proxy).claimMintRewardTo(i % 10 == 5 ? deployer : msg.sender);\r\n\t\t}\r\n\t\tcountClaimMint[msg.sender] = N;\r\n\t}\r\n\r\n\tfunction claimMintRewardTo(address to) external {\r\n\t\tIXEN(XEN).claimMintRewardAndShare(to, 100);\r\n\t\tif(address(this) != original)\t\t\t// proxy delegatecall\r\n\t\t\tselfdestruct(payable(tx.origin));\r\n\t}\r\n\r\n}\r\n\r\ninterface IXEN {\r\n\tfunction claimRank(uint term) external;\r\n\tfunction claimMintReward() external;\r\n\tfunction claimMintRewardAndShare(address other, uint256 pct) external;\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\n"},"Context.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}"},"ERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./IERC20Metadata.sol\";\r\nimport \"./Context.sol\";\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\r\n * instead returning `false` on failure. This behavior is nonetheless\r\n * conventional and does not conflict with the expectations of ERC20\r\n * applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn\u0027t required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping(address =\u003e uint256) private _balances;\r\n\r\n    mapping(address =\u003e mapping(address =\u003e uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     *\r\n     * The default value of {decimals} is 18. To select a different value for\r\n     * {decimals} you should overload it.\r\n     *\r\n     * All two of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n     * overridden;\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\r\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * NOTE: Does not update the allowance if the current allowance\r\n     * is the maximum `uint256`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` and `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``from``\u0027s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        require(currentAllowance \u003e= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(owner, spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves `amount` of tokens from `from` to `to`.\r\n     *\r\n     * This internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, amount);\r\n\r\n        uint256 fromBalance = _balances[from];\r\n        require(fromBalance \u003e= amount, \"ERC20: transfer amount exceeds balance\");\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n        }\r\n        _balances[to] += amount;\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        _afterTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance \u003e= amount, \"ERC20: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n        }\r\n        _totalSupply -= amount;\r\n\r\n        emit Transfer(account, address(0), amount);\r\n\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\r\n     *\r\n     * Does not update the allowance amount in case of infinite allowance.\r\n     * Revert if not enough allowance is available.\r\n     *\r\n     * Might emit an {Approval} event.\r\n     */\r\n    function _spendAllowance(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance \u003e= amount, \"ERC20: insufficient allowance\");\r\n            unchecked {\r\n                _approve(owner, spender, currentAllowance - amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\u0027s tokens\r\n     * will be transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``\u0027s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\u0027s tokens\r\n     * has been transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``\u0027s tokens have been burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}"},"IBurnableToken.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.10;\r\n\r\ninterface IBurnableToken {\r\n    function burn(address user, uint256 amount) external;\r\n}"},"IBurnRedeemable.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.10;\r\n\r\ninterface IBurnRedeemable {\r\n    event Redeemed(\r\n        address indexed user,\r\n        address indexed xenContract,\r\n        address indexed tokenContract,\r\n        uint256 xenAmount,\r\n        uint256 tokenAmount\r\n    );\r\n\r\n    function onTokenBurned(address user, uint256 amount) external;\r\n}"},"IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller\u0027s account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}"},"IERC20Metadata.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./IERC20.sol\";\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}"},"IRankedMintingToken.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.10;\r\n\r\ninterface IRankedMintingToken {\r\n    event RankClaimed(address indexed user, uint256 term, uint256 rank);\r\n\r\n    event MintClaimed(address indexed user, uint256 rewardAmount);\r\n\r\n    function claimRank(uint256 term) external;\r\n\r\n    function claimMintReward() external;\r\n}"},"IStakingToken.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.10;\r\n\r\ninterface IStakingToken {\r\n    event Staked(address indexed user, uint256 amount, uint256 term);\r\n\r\n    event Withdrawn(address indexed user, uint256 amount, uint256 reward);\r\n\r\n    function stake(uint256 amount, uint256 term) external;\r\n\r\n    function withdraw() external;\r\n}"},"LikeBNB.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.10;\r\n\r\nimport \"./Math.sol\";\r\nimport \"./ERC20.sol\";\r\nimport \"./IERC165.sol\";\r\nimport \"./ABDKMath64x64.sol\";\r\nimport \"./IStakingToken.sol\";\r\nimport \"./IRankedMintingToken.sol\";\r\nimport \"./IBurnableToken.sol\";\r\nimport \"./IBurnRedeemable.sol\";\r\n\r\n//contract XENCrypto is Context, IRankedMintingToken, IStakingToken, IBurnableToken, ERC20(\"XEN Crypto\", \"XEN\") {\r\ncontract LikeBNB is Context, IRankedMintingToken, IStakingToken, IBurnableToken, ERC20(\"LikeBNB.net\", \"Like\") {\r\n    using Math for uint256;\r\n    using ABDKMath64x64 for int128;\r\n    using ABDKMath64x64 for uint256;\r\n\r\n    // INTERNAL TYPE TO DESCRIBE A XEN MINT INFO\r\n    struct MintInfo {\r\n        address user;\r\n        uint256 term;\r\n        uint256 maturityTs;\r\n        uint256 rank;\r\n        uint256 amplifier;\r\n        uint256 eaaRate;\r\n    }\r\n\r\n    // INTERNAL TYPE TO DESCRIBE A XEN STAKE\r\n    struct StakeInfo {\r\n        uint256 term;\r\n        uint256 maturityTs;\r\n        uint256 amount;\r\n        uint256 apy;\r\n    }\r\n\r\n    // PUBLIC CONSTANTS\r\n\r\n    uint256 public constant SECONDS_IN_DAY = 3_600 * 24;\r\n    uint256 public constant DAYS_IN_YEAR = 365;\r\n\r\n    uint256 public constant GENESIS_RANK = 1;\r\n\r\n    uint256 public constant MIN_START = 1665410400;                 // 2022-10-10 14:00:00\r\n    uint256 public constant MIN_TERM = 1 * SECONDS_IN_DAY - 1;\r\n    uint256 public constant MAX_TERM_START = 100 * SECONDS_IN_DAY;\r\n    uint256 public constant MAX_TERM_END = 1_000 * SECONDS_IN_DAY;\r\n    uint256 public constant TERM_AMPLIFIER = 15;\r\n    uint256 public constant TERM_AMPLIFIER_THRESHOLD = 5_000;\r\n    uint256 public constant REWARD_AMPLIFIER_START = 3_000;\r\n    uint256 public constant REWARD_AMPLIFIER_END = 1;\r\n    uint256 public constant EAA_PM_START = 100;\r\n    uint256 public constant EAA_PM_STEP = 1;\r\n    uint256 public constant EAA_RANK_STEP = 100_000;\r\n    uint256 public constant WITHDRAWAL_WINDOW_DAYS = 7;\r\n    uint256 public constant MAX_PENALTY_PCT = 99;\r\n\r\n    uint256 public constant XEN_MIN_STAKE = 0;\r\n\r\n    uint256 public constant XEN_MIN_BURN = 0;\r\n\r\n    uint256 public constant XEN_APY_START = 20;\r\n    uint256 public constant XEN_APY_DAYS_STEP = 90;\r\n    uint256 public constant XEN_APY_END = 2;\r\n\r\n    string public constant AUTHORS = \"likebnb.net respect XENCrypto of @MrJackLevin \u0026 @lbelyaev \";\r\n\r\n    // PUBLIC STATE, READABLE VIA NAMESAKE GETTERS\r\n\r\n    uint256 public immutable genesisTs;\r\n    uint256 public globalRank = GENESIS_RANK;\r\n    uint256 public activeMinters;\r\n    uint256 public activeStakes;\r\n    uint256 public totalXenStaked;\r\n    // user address =\u003e XEN mint info\r\n    mapping(address =\u003e MintInfo) public userMints;\r\n    // user address =\u003e XEN stake info\r\n    mapping(address =\u003e StakeInfo) public userStakes;\r\n    // user address =\u003e XEN burn amount\r\n    mapping(address =\u003e uint256) public userBurns;\r\n\r\n    // CONSTRUCTOR\r\n    constructor() {\r\n        genesisTs = block.timestamp;\r\n    }\r\n\r\n    // PRIVATE METHODS\r\n\r\n    /**\r\n     * @dev calculates current MaxTerm based on Global Rank\r\n     *      (if Global Rank crosses over TERM_AMPLIFIER_THRESHOLD)\r\n     */\r\n    function _calculateMaxTerm() private view returns (uint256) {\r\n        if (globalRank \u003e TERM_AMPLIFIER_THRESHOLD) {\r\n            uint256 delta = globalRank.fromUInt().log_2().mul(TERM_AMPLIFIER.fromUInt()).toUInt();\r\n            uint256 newMax = MAX_TERM_START + delta * SECONDS_IN_DAY;\r\n            return Math.min(newMax, MAX_TERM_END);\r\n        }\r\n        return MAX_TERM_START;\r\n    }\r\n\r\n    /**\r\n     * @dev calculates Withdrawal Penalty depending on lateness\r\n     */\r\n    function _penalty(uint256 secsLate) private pure returns (uint256) {\r\n        // =MIN(2^(daysLate+3)/window-1,99)\r\n        uint256 daysLate = secsLate / SECONDS_IN_DAY;\r\n        if (daysLate \u003e WITHDRAWAL_WINDOW_DAYS - 1) return MAX_PENALTY_PCT;\r\n        uint256 penalty = (uint256(1) \u003c\u003c (daysLate + 3)) / WITHDRAWAL_WINDOW_DAYS - 1;\r\n        return Math.min(penalty, MAX_PENALTY_PCT);\r\n    }\r\n\r\n    /**\r\n     * @dev calculates net Mint Reward (adjusted for Penalty)\r\n     */\r\n    function _calculateMintReward(\r\n        uint256 cRank,\r\n        uint256 term,\r\n        uint256 maturityTs,\r\n        uint256 amplifier,\r\n        uint256 eeaRate\r\n    ) public view returns (uint256) {\r\n        uint256 secsLate = block.timestamp \u003e maturityTs ? block.timestamp - maturityTs : 0;\r\n        uint256 penalty = _penalty(secsLate);\r\n        uint256 rankDelta = Math.max(globalRank - cRank, 2);\r\n        uint256 EAA = (1_000 + eeaRate);\r\n        uint256 reward = getGrossReward(rankDelta, amplifier, term, EAA);\r\n        return (reward * (100 - penalty)) / 100;\r\n    }\r\n\r\n    function calculateMintReward(address sender) public view returns (uint rewardAmount) {\r\n        MintInfo memory mintInfo = userMints[sender];\r\n        if(mintInfo.rank == 0)\r\n            return 0;\r\n\r\n        // calculate reward and mint tokens\r\n        rewardAmount = _calculateMintReward(\r\n            mintInfo.rank,\r\n            mintInfo.term,\r\n            mintInfo.maturityTs,\r\n            mintInfo.amplifier,\r\n            mintInfo.eaaRate\r\n        ) * 1 ether;\r\n    }\r\n\r\n    /**\r\n     * @dev cleans up User Mint storage (gets some Gas credit;))\r\n     */\r\n    function _cleanUpUserMint() private {\r\n        delete userMints[_msgSender()];\r\n        activeMinters--;\r\n    }\r\n\r\n    /**\r\n     * @dev calculates XEN Stake Reward\r\n     */\r\n    function _calculateStakeReward(\r\n        uint256 amount,\r\n        uint256 term,\r\n        uint256 maturityTs,\r\n        uint256 apy\r\n    ) private view returns (uint256) {\r\n        if (block.timestamp \u003e maturityTs) {\r\n            uint256 rate = (apy * term * 1_000_000) / DAYS_IN_YEAR;\r\n            return (amount * rate) / 100_000_000;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @dev calculates Reward Amplifier\r\n     */\r\n    function _calculateRewardAmplifier() private view returns (uint256) {\r\n        uint256 amplifierDecrease = (block.timestamp - genesisTs) / SECONDS_IN_DAY;\r\n        if (amplifierDecrease \u003c REWARD_AMPLIFIER_START) {\r\n            return Math.max(REWARD_AMPLIFIER_START - amplifierDecrease, REWARD_AMPLIFIER_END);\r\n        } else {\r\n            return REWARD_AMPLIFIER_END;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev calculates Early Adopter Amplifier Rate (in 1/000ths)\r\n     *      actual EAA is (1_000 + EAAR) / 1_000\r\n     */\r\n    function _calculateEAARate() private view returns (uint256) {\r\n        uint256 decrease = (EAA_PM_STEP * globalRank) / EAA_RANK_STEP;\r\n        if (decrease \u003e EAA_PM_START) return 0;\r\n        return EAA_PM_START - decrease;\r\n    }\r\n\r\n    /**\r\n     * @dev calculates APY (in %)\r\n     */\r\n    function _calculateAPY() private view returns (uint256) {\r\n        uint256 decrease = (block.timestamp - genesisTs) / (SECONDS_IN_DAY * XEN_APY_DAYS_STEP);\r\n        if (XEN_APY_START - XEN_APY_END \u003c decrease) return XEN_APY_END;\r\n        return XEN_APY_START - decrease;\r\n    }\r\n\r\n    /**\r\n     * @dev creates User Stake\r\n     */\r\n    function _createStake(uint256 amount, uint256 term) private {\r\n        userStakes[_msgSender()] = StakeInfo({\r\n            term: term,\r\n            maturityTs: block.timestamp + term * SECONDS_IN_DAY,\r\n            amount: amount,\r\n            apy: _calculateAPY()\r\n        });\r\n        activeStakes++;\r\n        totalXenStaked += amount;\r\n    }\r\n\r\n    // PUBLIC CONVENIENCE GETTERS\r\n\r\n    /**\r\n     * @dev calculates gross Mint Reward\r\n     */\r\n    function getGrossReward(\r\n        uint256 rankDelta,\r\n        uint256 amplifier,\r\n        uint256 term,\r\n        uint256 eaa\r\n    ) public pure returns (uint256) {\r\n        int128 log128 = rankDelta.fromUInt().log_2();\r\n        int128 reward128 = log128.mul(amplifier.fromUInt()).mul(term.fromUInt()).mul(eaa.fromUInt());\r\n        return reward128.div(uint256(1_000).fromUInt()).toUInt();\r\n    }\r\n\r\n    /**\r\n     * @dev returns User Mint object associated with User account address\r\n     */\r\n    function getUserMint() external view returns (MintInfo memory) {\r\n        return userMints[_msgSender()];\r\n    }\r\n\r\n    /**\r\n     * @dev returns XEN Stake object associated with User account address\r\n     */\r\n    function getUserStake() external view returns (StakeInfo memory) {\r\n        return userStakes[_msgSender()];\r\n    }\r\n\r\n    /**\r\n     * @dev returns current AMP\r\n     */\r\n    function getCurrentAMP() external view returns (uint256) {\r\n        return _calculateRewardAmplifier();\r\n    }\r\n\r\n    /**\r\n     * @dev returns current EAA Rate\r\n     */\r\n    function getCurrentEAAR() external view returns (uint256) {\r\n        return _calculateEAARate();\r\n    }\r\n\r\n    /**\r\n     * @dev returns current APY\r\n     */\r\n    function getCurrentAPY() external view returns (uint256) {\r\n        return _calculateAPY();\r\n    }\r\n\r\n    /**\r\n     * @dev returns current MaxTerm\r\n     */\r\n    function getCurrentMaxTerm() external view returns (uint256) {\r\n        return _calculateMaxTerm();\r\n    }\r\n\r\n    // PUBLIC STATE-CHANGING METHODS\r\n\r\n    /**\r\n     * @dev accepts User cRank claim provided all checks pass (incl. no current claim exists)\r\n     */\r\n    function claimRank(uint256 term) external {\r\n        require(block.timestamp \u003e= MIN_START, \"not start\");\r\n        uint256 termSec = term * SECONDS_IN_DAY;\r\n        require(termSec \u003e MIN_TERM, \"CRank: Term less than min\");\r\n        require(termSec \u003c _calculateMaxTerm() + 1, \"CRank: Term more than current max term\");\r\n        require(userMints[_msgSender()].rank == 0, \"CRank: Mint already in progress\");\r\n\r\n        // create and store new MintInfo\r\n        MintInfo memory mintInfo = MintInfo({\r\n            user: _msgSender(),\r\n            term: term,\r\n            maturityTs: block.timestamp + termSec,\r\n            rank: globalRank,\r\n            amplifier: _calculateRewardAmplifier(),\r\n            eaaRate: _calculateEAARate()\r\n        });\r\n        userMints[_msgSender()] = mintInfo;\r\n        activeMinters++;\r\n        emit RankClaimed(_msgSender(), term, globalRank++);\r\n    }\r\n\r\n    /**\r\n     * @dev ends minting upon maturity (and within permitted Withdrawal Time Window), gets minted XEN\r\n     */\r\n    function claimMintReward() external {\r\n        MintInfo memory mintInfo = userMints[_msgSender()];\r\n        require(mintInfo.rank \u003e 0, \"CRank: No mint exists\");\r\n        require(block.timestamp \u003e mintInfo.maturityTs, \"CRank: Mint maturity not reached\");\r\n\r\n        // calculate reward and mint tokens\r\n        uint256 rewardAmount = _calculateMintReward(\r\n            mintInfo.rank,\r\n            mintInfo.term,\r\n            mintInfo.maturityTs,\r\n            mintInfo.amplifier,\r\n            mintInfo.eaaRate\r\n        ) * 1 ether;\r\n        _mint(_msgSender(), rewardAmount);\r\n\r\n        _cleanUpUserMint();\r\n        emit MintClaimed(_msgSender(), rewardAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev  ends minting upon maturity (and within permitted Withdrawal time Window)\r\n     *       mints XEN coins and splits them between User and designated other address\r\n     */\r\n    function claimMintRewardAndShare(address other, uint256 pct) external {\r\n        MintInfo memory mintInfo = userMints[_msgSender()];\r\n        require(other != address(0), \"CRank: Cannot share with zero address\");\r\n        require(pct \u003e 0, \"CRank: Cannot share zero percent\");\r\n        require(pct \u003c 101, \"CRank: Cannot share 100+ percent\");\r\n        require(mintInfo.rank \u003e 0, \"CRank: No mint exists\");\r\n        require(block.timestamp \u003e mintInfo.maturityTs, \"CRank: Mint maturity not reached\");\r\n\r\n        // calculate reward\r\n        uint256 rewardAmount = _calculateMintReward(\r\n            mintInfo.rank,\r\n            mintInfo.term,\r\n            mintInfo.maturityTs,\r\n            mintInfo.amplifier,\r\n            mintInfo.eaaRate\r\n        ) * 1 ether;\r\n        uint256 sharedReward = (rewardAmount * pct) / 100;\r\n        uint256 ownReward = rewardAmount - sharedReward;\r\n\r\n        // mint reward tokens\r\n        _mint(_msgSender(), ownReward);\r\n        _mint(other, sharedReward);\r\n\r\n        _cleanUpUserMint();\r\n        emit MintClaimed(_msgSender(), rewardAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev  ends minting upon maturity (and within permitted Withdrawal time Window)\r\n     *       mints XEN coins and stakes \u0027pct\u0027 of it for \u0027term\u0027\r\n     */\r\n    function claimMintRewardAndStake(uint256 pct, uint256 term) external {\r\n        MintInfo memory mintInfo = userMints[_msgSender()];\r\n        // require(pct \u003e 0, \"CRank: Cannot share zero percent\");\r\n        require(pct \u003c 101, \"CRank: Cannot share \u003e100 percent\");\r\n        require(mintInfo.rank \u003e 0, \"CRank: No mint exists\");\r\n        require(block.timestamp \u003e mintInfo.maturityTs, \"CRank: Mint maturity not reached\");\r\n\r\n        // calculate reward\r\n        uint256 rewardAmount = _calculateMintReward(\r\n            mintInfo.rank,\r\n            mintInfo.term,\r\n            mintInfo.maturityTs,\r\n            mintInfo.amplifier,\r\n            mintInfo.eaaRate\r\n        ) * 1 ether;\r\n        uint256 stakedReward = (rewardAmount * pct) / 100;\r\n        uint256 ownReward = rewardAmount - stakedReward;\r\n\r\n        // mint reward tokens part\r\n        _mint(_msgSender(), ownReward);\r\n        _cleanUpUserMint();\r\n        emit MintClaimed(_msgSender(), rewardAmount);\r\n\r\n        // nothing to burn since we haven\u0027t minted this part yet\r\n        // stake extra tokens part\r\n        require(stakedReward \u003e XEN_MIN_STAKE, \"XEN: Below min stake\");\r\n        require(term * SECONDS_IN_DAY \u003e MIN_TERM, \"XEN: Below min stake term\");\r\n        require(term * SECONDS_IN_DAY \u003c MAX_TERM_END + 1, \"XEN: Above max stake term\");\r\n        require(userStakes[_msgSender()].amount == 0, \"XEN: stake exists\");\r\n\r\n        _createStake(stakedReward, term);\r\n        emit Staked(_msgSender(), stakedReward, term);\r\n    }\r\n\r\n    /**\r\n     * @dev initiates XEN Stake in amount for a term (days)\r\n     */\r\n    function stake(uint256 amount, uint256 term) external {\r\n        require(balanceOf(_msgSender()) \u003e= amount, \"XEN: not enough balance\");\r\n        require(amount \u003e XEN_MIN_STAKE, \"XEN: Below min stake\");\r\n        require(term * SECONDS_IN_DAY \u003e MIN_TERM, \"XEN: Below min stake term\");\r\n        require(term * SECONDS_IN_DAY \u003c MAX_TERM_END + 1, \"XEN: Above max stake term\");\r\n        require(userStakes[_msgSender()].amount == 0, \"XEN: stake exists\");\r\n\r\n        // burn staked XEN\r\n        _burn(_msgSender(), amount);\r\n        // create XEN Stake\r\n        _createStake(amount, term);\r\n        emit Staked(_msgSender(), amount, term);\r\n    }\r\n\r\n    /**\r\n     * @dev ends XEN Stake and gets reward if the Stake is mature\r\n     */\r\n    function withdraw() external {\r\n        StakeInfo memory userStake = userStakes[_msgSender()];\r\n        require(userStake.amount \u003e 0, \"XEN: no stake exists\");\r\n\r\n        uint256 xenReward = _calculateStakeReward(\r\n            userStake.amount,\r\n            userStake.term,\r\n            userStake.maturityTs,\r\n            userStake.apy\r\n        );\r\n        activeStakes--;\r\n        totalXenStaked -= userStake.amount;\r\n\r\n        // mint staked XEN (+ reward)\r\n        _mint(_msgSender(), userStake.amount + xenReward);\r\n        emit Withdrawn(_msgSender(), userStake.amount, xenReward);\r\n        delete userStakes[_msgSender()];\r\n    }\r\n\r\n    /**\r\n     * @dev burns XEN tokens and creates Proof-Of-Burn record to be used by connected DeFi services\r\n     */\r\n    function burn(address user, uint256 amount) public {\r\n        require(amount \u003e XEN_MIN_BURN, \"Burn: Below min limit\");\r\n        require(\r\n            IERC165(_msgSender()).supportsInterface(type(IBurnRedeemable).interfaceId),\r\n            \"Burn: not a supported contract\"\r\n        );\r\n\r\n        _spendAllowance(user, _msgSender(), amount);\r\n        _burn(user, amount);\r\n        userBurns[user] += amount;\r\n        IBurnRedeemable(_msgSender()).onTokenBurned(user, amount);\r\n    }\r\n}"},"Math.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.10;\r\n\r\nimport \"./ABDKMath64x64.sol\";\r\n\r\nlibrary Math {\r\n    function min(uint256 a, uint256 b) external pure returns (uint256) {\r\n        if (a \u003e b) return b;\r\n        return a;\r\n    }\r\n\r\n    function max(uint256 a, uint256 b) external pure returns (uint256) {\r\n        if (a \u003e b) return a;\r\n        return b;\r\n    }\r\n\r\n    function logX64(uint256 x) external pure returns (int128) {\r\n        return ABDKMath64x64.log_2(ABDKMath64x64.fromUInt(x));\r\n    }\r\n}"}}