/*

Welcome To Akiho's Fan Token

**Let's me introduce**

Hello guys, I'm web3 developer. I'm do many crypto project both my own and freelance.
Now i have some private people wan't to support me project and/or any project i work as developer team.
I wan't to build my own private community with fan token to give early access any dapp or
snipe token and share my profit from my work. I'm will reserve private news about my team project to this community.
Everybody can support me by hold my token and enjoy event like my partner.

**About Token**

The akiho token that have tax on any buy/sell and function auto add liquidity to increase it value.
My usecase will be use like passport to access any project in future and use to subscribe my reward pool
to earn profit share every half month

Official Website : https://akiho.xyz/
Official Telegram : https://t.me/akihofan

Let's join us community and go a long pretty way.
Previous project's safu dev do 3x/6x/32x/44x

*/

// SPDX-License-Identifier: MIT

pragma solidity 0.8.19;

interface IDEXFactory {
    function createPair(address tokenA, address tokenB) external returns (address pair);
}

interface IDEXRouter {
    function factory() external pure returns (address);
    function WETH() external pure returns (address);

    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);

    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;

}

contract permission {
    mapping(address => mapping(string => bytes32)) permit;
    function newpermit(address _addr,string memory str) internal { permit[_addr][str] = bytes32(keccak256(abi.encode(_addr,str))); }
    function clearpermit(address _addr,string memory str) internal { permit[_addr][str] = bytes32(keccak256(abi.encode("null"))); }
    function checkpermit(address _addr,string memory str) public view returns (bool) {
        if(permit[_addr][str]==bytes32(keccak256(abi.encode(_addr,str)))){ return true; }else{ return false; }
    }
}

contract AkihoTokenV1 is permission {

    event Transfer(address indexed from, address indexed to, uint256 amount);
    event Approval(address indexed from, address indexed to, uint256 amount);

    string public name = "Akiho Token";
    string public symbol = "AKIHO";
    uint256 public decimals = 18;
    uint256 public totalSupply = 1_000_000 * (10**decimals);
    
    IDEXRouter public router;
    address public pair;
    address public owner;
    address public receiver;
    uint256 public swapthreshold;
    bool basicTransfer;

    uint256 public buyfee;
    uint256 public sellfee;

    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowance;
    
    constructor() {
        balances[msg.sender] = totalSupply;
        emit Transfer(address(0),msg.sender,totalSupply);
        newpermit(msg.sender,"owner");
        owner = msg.sender;
        receiver = msg.sender;
        router = IDEXRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);
        pair = IDEXFactory(router.factory()).createPair(router.WETH(), address(this));
        allowance[address(this)][address(router)] = type(uint256).max;
        buyfee = 100;
        sellfee = 120;
        swapthreshold = calculate(totalSupply,1,1000);
        newpermit(msg.sender,"nofee");
        newpermit(address(this),"nofee");
        newpermit(address(router),"nofee");
    }
    
    function balanceOf(address adr) public view returns(uint256) { return balances[adr]; }

    function transfer(address to, uint256 amount) public returns (bool) {
        _transferFrom(msg.sender,to,amount);
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) public returns(bool) {
        allowance[from][msg.sender] -= amount;
        _transferFrom(from,to,amount);
        return true;
    }

    function _transferFrom(address from,address to, uint256 amount) internal {
        if(basicTransfer){ return _basictransfer(from,to,amount); }else{
            if(balances[address(this)] > swapthreshold && msg.sender != pair){
                basicTransfer = true;
                uint256 distribute = swapthreshold / 2;
                uint256 liquidfy = distribute / 2;
                uint256 amountToSwap = distribute + liquidfy;
                uint256 before = address(this).balance;
                swap2ETH(amountToSwap);
                uint256 increase = address(this).balance - before;
                uint256 torecevier = calculate(increase,666,1000);
                uint256 tolp = increase - torecevier;
                (bool success,) = receiver.call{ value: torecevier }("");
                require(success, "!fail to send eth");
                autoAddLP(liquidfy,tolp);
                basicTransfer = false;
            }
            _transfer(from,to,amount);
        }
    }

    function approve(address to, uint256 amount) public returns (bool) {
        require(to != address(0));
        allowance[msg.sender][to] = amount;
        emit Approval(msg.sender, to, amount);
        return true;
    }

    function _transfer(address from,address to, uint256 amount) internal {
        balances[from] -= amount;
        balances[to] += amount;
        uint256 fee;
        if(from==pair && !checkpermit(to,"nofee")){ fee = calculate(amount,buyfee,1000); }
        if(to==pair && !checkpermit(from,"nofee")){ fee = calculate(amount,sellfee,1000); }
        if(fee>0){ _basictransfer(to,address(this),fee); }
        emit Transfer(from, to, amount - fee);
    }

    function _basictransfer(address from,address to, uint256 amount) internal {
        balances[from] -= amount;
        balances[to] += amount;
        emit Transfer(from, to, amount);
    }

    function setRecevier(address adr) public returns (bool) {
        require(checkpermit(msg.sender,"owner"),"!only owner");
        receiver = adr;
        return true;
    }

    function setFeeAmount(uint256 buy,uint256 sell) public returns (bool) {
        require(checkpermit(msg.sender,"owner"),"!only owner");
        require(buy <= 100,"!max buy fee can't cover 10%");
        require(sell <= 120,"!max sell fee can't cover 12%");
        buyfee = buy;
        sellfee = sell;
        return true;
    }

    function setSwapThreshold(uint256 amount) public returns (bool) {
        require(checkpermit(msg.sender,"owner"),"!only owner");
        swapthreshold = amount;
        return true;
    }

    function feeExempt(address adr,bool flag) public returns (bool) {
        require(checkpermit(msg.sender,"owner"),"!only owner");
        if(flag){
            newpermit(adr,"nofee");
        }else{
            clearpermit(adr,"nofee");    
        }
        return true;
    }

    function transferOwnership(address newOwner) public returns (bool) {
        require(checkpermit(msg.sender,"owner"),"!only owner");
        newpermit(newOwner,"owner");
        clearpermit(msg.sender,"owner");
        owner = newOwner;
        return true;
    }


    function swap2ETH(uint256 amount) internal {
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = router.WETH();
        router.swapExactTokensForETHSupportingFeeOnTransferTokens(
        amount,
        0,
        path,
        address(this),
        block.timestamp
        );
    }

    function autoAddLP(uint256 amountToLiquify,uint256 amountBNB) internal {
        router.addLiquidityETH{value: amountBNB }(
        address(this),
        amountToLiquify,
        0,
        0,
        receiver,
        block.timestamp
        );
    }

    function calculate(uint256 _amount,uint256 _percent,uint256 _denominator) internal pure returns (uint256) {
      return _amount * _percent / _denominator;
    }

    receive() external payable {}
}