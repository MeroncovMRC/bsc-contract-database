
// File: @openzeppelin/contracts/access/Ownable.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)

pragma solidity ^0.8.0;

import "../utils/Context.sol";

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _transferOwnership(_msgSender());
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if the sender is not the owner.
     */
    function _checkOwner() internal view virtual {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Internal function without access restriction.
     */
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}


// File: @openzeppelin/contracts/security/ReentrancyGuard.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)

pragma solidity ^0.8.0;

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and making it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        _nonReentrantBefore();
        _;
        _nonReentrantAfter();
    }

    function _nonReentrantBefore() private {
        // On the first call to nonReentrant, _status will be _NOT_ENTERED
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;
    }

    function _nonReentrantAfter() private {
        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}


// File: @openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
 * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
 *
 * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
 * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't
 * need to send a transaction, and thus is not required to hold Ether at all.
 */
interface IERC20Permit {
    /**
     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,
     * given ``owner``'s signed approval.
     *
     * IMPORTANT: The same issues {IERC20-approve} has related to transaction
     * ordering also apply here.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `deadline` must be a timestamp in the future.
     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
     * over the EIP712-formatted function arguments.
     * - the signature must use ``owner``'s current nonce (see {nonces}).
     *
     * For more information on the signature format, see the
     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
     * section].
     */
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    /**
     * @dev Returns the current nonce for `owner`. This value must be
     * included whenever a signature is generated for {permit}.
     *
     * Every successful call to {permit} increases ``owner``'s nonce by one. This
     * prevents a signature from being used multiple times.
     */
    function nonces(address owner) external view returns (uint256);

    /**
     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.
     */
    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32);
}


// File: @openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)

pragma solidity ^0.8.0;

import "../IERC20.sol";

/**
 * @dev Interface for the optional metadata functions from the ERC20 standard.
 *
 * _Available since v4.1._
 */
interface IERC20Metadata is IERC20 {
    /**
     * @dev Returns the name of the token.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the symbol of the token.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the decimals places of the token.
     */
    function decimals() external view returns (uint8);
}


// File: @openzeppelin/contracts/token/ERC20/IERC20.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `from` to `to` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
}


// File: @openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)

pragma solidity ^0.8.0;

import "../IERC20.sol";
import "../extensions/draft-IERC20Permit.sol";
import "../../../utils/Address.sol";

/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
    using Address for address;

    function safeTransfer(
        IERC20 token,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(
        IERC20 token,
        address from,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    /**
     * @dev Deprecated. This function has issues similar to the ones found in
     * {IERC20-approve}, and its usage is discouraged.
     *
     * Whenever possible, use {safeIncreaseAllowance} and
     * {safeDecreaseAllowance} instead.
     */
    function safeApprove(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        require(
            (value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance = token.allowance(address(this), spender) + value;
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        unchecked {
            uint256 oldAllowance = token.allowance(address(this), spender);
            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");
            uint256 newAllowance = oldAllowance - value;
            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
        }
    }

    function safePermit(
        IERC20Permit token,
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal {
        uint256 nonceBefore = token.nonces(owner);
        token.permit(owner, spender, value, deadline, v, r, s);
        uint256 nonceAfter = token.nonces(owner);
        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
        if (returndata.length > 0) {
            // Return data is optional
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}


// File: @openzeppelin/contracts/utils/Address.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)

pragma solidity ^0.8.1;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     *
     * [IMPORTANT]
     * ====
     * You shouldn't rely on `isContract` to protect against flash loan attacks!
     *
     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
     * constructor.
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize/address.code.length, which returns 0
        // for contracts in construction, since the code is only stored at the end
        // of the constructor execution.

        return account.code.length > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain `call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling
     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.
     *
     * _Available since v4.8._
     */
    function verifyCallResultFromTarget(
        address target,
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        if (success) {
            if (returndata.length == 0) {
                // only check isContract if the call was successful and the return data is empty
                // otherwise we already know that it was a contract
                require(isContract(target), "Address: call to non-contract");
            }
            return returndata;
        } else {
            _revert(returndata, errorMessage);
        }
    }

    /**
     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the
     * revert reason or using the provided one.
     *
     * _Available since v4.3._
     */
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            _revert(returndata, errorMessage);
        }
    }

    function _revert(bytes memory returndata, string memory errorMessage) private pure {
        // Look for revert reason and bubble it up if present
        if (returndata.length > 0) {
            // The easiest way to bubble the revert reason is using memory via assembly
            /// @solidity memory-safe-assembly
            assembly {
                let returndata_size := mload(returndata)
                revert(add(32, returndata), returndata_size)
            }
        } else {
            revert(errorMessage);
        }
    }
}


// File: @openzeppelin/contracts/utils/Context.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)

pragma solidity ^0.8.0;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}


// File: contracts/interfaces/ICheckDec.sol
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0 <=0.8.6;


interface CheckDec {
    function decimals() external view returns (uint8);
}


// File: contracts/interfaces/IFactory.sol
pragma solidity >=0.5.0;


interface IFactory {
    event PairCreated(
        address indexed token0,
        address indexed token1,
        address pair,
        uint256
    );

    function feeTo() external view returns (address);

    function feeToSetter() external view returns (address);

    function getPair(address tokenA, address tokenB)
        external
        view
        returns (address pair);

    function allPairs(uint256) external view returns (address pair);

    function allPairsLength() external view returns (uint256);

    function createPair(address tokenA, address tokenB)
        external
        returns (address pair);

    function setFeeTo(address) external;

    function setFeeToSetter(address) external;
}


// File: contracts/interfaces/IRouterV1.sol
// SPDX-License-Identifier: MIT
pragma solidity >=0.6.2;


interface IRouterV1 {
    function factory() external pure returns (address);

    function WETH() external pure returns (address);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint256 amountADesired,
        uint256 amountBDesired,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    )
        external
        returns (
            uint256 amountA,
            uint256 amountB,
            uint256 liquidity
        );

    function addLiquidityETH(
        address token,
        uint256 amountTokenDesired,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    )
        external
        payable
        returns (
            uint256 amountToken,
            uint256 amountETH,
            uint256 liquidity
        );

    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint256 liquidity,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountA, uint256 amountB);

    function removeLiquidityETH(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountToken, uint256 amountETH);

    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint256 liquidity,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline,
        bool approveMax,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (uint256 amountA, uint256 amountB);

    function removeLiquidityETHWithPermit(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline,
        bool approveMax,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (uint256 amountToken, uint256 amountETH);

    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapTokensForExactTokens(
        uint256 amountOut,
        uint256 amountInMax,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapExactETHForTokens(
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable returns (uint256[] memory amounts);

    function swapTokensForExactETH(
        uint256 amountOut,
        uint256 amountInMax,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapExactTokensForETH(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapETHForExactTokens(
        uint256 amountOut,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable returns (uint256[] memory amounts);

    function quote(
        uint256 amountA,
        uint256 reserveA,
        uint256 reserveB
    ) external pure returns (uint256 amountB);

    function getAmountOut(
        uint256 amountIn,
        uint256 reserveIn,
        uint256 reserveOut
    ) external pure returns (uint256 amountOut);

    function getAmountIn(
        uint256 amountOut,
        uint256 reserveIn,
        uint256 reserveOut
    ) external pure returns (uint256 amountIn);

    function getAmountsOut(uint256 amountIn, address[] calldata path)
        external
        view
        returns (uint256[] memory amounts);

    function getAmountsIn(uint256 amountOut, address[] calldata path)
        external
        view
        returns (uint256[] memory amounts);
}


// File: contracts/interfaces/IRouterV2.sol
// SPDX-License-Identifier: MIT
pragma solidity >=0.6.2;

import "./IRouterV1.sol";


interface IRouterV2 is IRouterV1 {
    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountETH);

    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline,
        bool approveMax,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (uint256 amountETH);

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;

    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable;

    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;
}


// File: contracts/interfaces/ISync.sol
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0 <=0.8.6;


interface ISync {
    function sync() external;
}


// File: contracts/staking/MyStaking.sol
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0 <=0.8.6;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import "../token/MyShare.sol";


/**
 * @title The magical MyStaking contract.
 * @author int(200/0), slidingpanda
 */
contract MyStaking is Ownable, ReentrancyGuard {
    using SafeERC20 for IERC20;

    struct User {
        uint256 stakeBegin;
        uint256 share;
        uint256 lastRewardsPerShare;
        uint256 unclaimedAmount;
    }

    mapping(address => User) public userInfo;

    MyShare public myShare;

    uint256 public constant PERIOD0 = 86400; // 1 day
    uint256 public constant PERIOD1 = 7 * PERIOD0; // 1 week
    uint256 public constant PERIOD2 = 2 * PERIOD1; // 2 weeks
    uint256 public constant PERIOD3 = 2 * PERIOD2; // 4 weeks
    uint256 public constant PERIOD4 = 2 * PERIOD3; // 8 weeks

    uint256 public lpPeriod0Fee = 10;
    uint256 public lpPeriod1Fee = 20;
    uint256 public lpPeriod2Fee = 30;
    uint256 public lpPeriod3Fee = 20;
    uint256 public lpPeriod4Fee = 10;
    uint256 public lpStandardFee = 5;

    uint256 public period0Divisor = 6;
    uint256 public period1Divisor = 5;
    uint256 public period2Divisor = 4;
    uint256 public period3Divisor = 3;
    uint256 public period4Divisor = 2;
    uint256 public period5Divisor = 1;

    address public stakeToken;

    uint256 public totalShares;
    uint256 constant SHARE_DIVISOR = 10**6;

    uint256 public lastEmission;
    uint256 private _rewardsPerShare;
    uint256 private _rewardsPerShareResidual;

    uint256 public stakerCount;

    bool public isActive;

    /**
     * Creates the staking contract.
	 * Needs the myShare token which is able to mint rewards and the token which will be staked.
	 *
     * @param myShareAddr myShare token address.
     * @param lpAddr To-stake token address
     */
    constructor(address myShareAddr, address lpAddr, address owner_) {
        myShare = MyShare(myShareAddr);
        stakeToken = lpAddr;
        transferOwnership(owner_);
    }

    /**
     * Activates/Deactivates the staking pool if there are more than 0 tokens staked.
	 * Otherwise there is no need to emit or calculate the emission.
	 *
     * @notice - There also is an activity flag in the myShare token
	 *         - If there are some shares and this contract is active, it will activate the minter/emission for this contract as a minter
     *         - Otherwise it will deactivate the minter/emission for this contract as a minter
     */
    function _setActivity() internal {
        if (myShare.isMinter(address(this))) {
            if (totalShares > 0) {
                myShare.setMinterActivity(address(this), isActive);
            } else {
                myShare.setMinterActivity(address(this), false);
            }
        }
    }

    /**
     * Activates/Deactives this contract.
	 * If there already are shares, it activates the minter/emission for this contract as a minter.
	 *
     * @param toSet determines if address should be whitelisted
     */
    function setActivity(bool toSet) external onlyOwner {
        updateRewards();
        isActive = toSet;
        _setActivity();
    }

    /**
     * Calculates the uncalculated rewards.
     * - 1) The rewards of the myShare tokens -> minter/emission = X
     * - 2) The rewards for the staker depending on X -> X/shares
	 *
	 * @notice example (the same happens on the myShare contract):
     *         - (R)ewards = 1002, (S)hares = 10 -> (R+Residual)/S = RPS
     *         - (R)ewards(P)er(S)hare = 100
     *         - (Residual) = 2
	 *
     * @return uncalculatedRewardsPerShare returns the actual calculated rewards
     * @return uncalculatedResidual returns the residual which is not calculated but will be calculated in the next time
     */
    function getUncalculated() public view returns (uint256 uncalculatedRewardsPerShare, uint256 uncalculatedResidual) {
        uint256 tempLastEmission;

        if (myShare.isActiveMinter(address(this)) == true) {
            tempLastEmission = myShare.emissionPerSecondPerMinter() + myShare.uncalculatedEmission() - lastEmission;
        } else {
            tempLastEmission = 0;
        }

        if (totalShares > 0) {
            uint256 tempSum = tempLastEmission + _rewardsPerShareResidual;
            uncalculatedRewardsPerShare = tempSum / totalShares;
            uncalculatedResidual = tempSum % totalShares;
        }
    }

    /**
     * Changes the state of the contract on the chain based on the return values of "getUncalculated()".
     */
    function updateRewards() public {
        myShare.updateEmission();
        (uint256 rps, uint256 rpsr) = getUncalculated();

        lastEmission = myShare.emissionPerSecondPerMinter();
        _rewardsPerShareResidual = rpsr;
        _rewardsPerShare += rps;
    }

    /**
     * Changes the start time of a staker to the actual time.
	 * This takes care of that stakers have the correct fees when they withdraw or claim.
     */
    function _setTimer() internal {
        userInfo[msg.sender].stakeBegin = block.timestamp;
    }

    /**
     * Returns the lp withdraw fees, the divisor of the earned rewards and the staked time.
	 *
     * @notice claim:
     *         - 1 Day -> rewards / 6
     *         - <7 Days -> rewards / 5
     *         - <14 Days -> rewards / 4
     *         - <28 Days -> rewards / 3
     *         - <56 Days -> rewards / 2
     *         - >56 Days -> rewards / 1
     *         withdraw:
     *         - 1 Day -> 1%
     *         - <7 Days -> 2%
     *         - <14 Days -> 3%
     *         - <28 Days -> 2%
     *         - <56 Days -> 1%
     *         - >56 Days -> 0.5%
	 *
     * @param user address
     * @return lpFeeMultiplier lp/withdraw fee multiplier
     * @return rewardDivisor claim/reward divisor
     * @return stakedTime already staked time
     */
    function getDivisorByTime(address user) public view returns (uint256 lpFeeMultiplier, uint256 rewardDivisor, uint256 stakedTime) {
        stakedTime = block.timestamp - userInfo[user].stakeBegin;
        lpFeeMultiplier = lpStandardFee;
        rewardDivisor = period5Divisor;

        if (stakedTime < PERIOD0) {
            lpFeeMultiplier = lpPeriod0Fee;
            rewardDivisor = period0Divisor;
        } else if (stakedTime >= PERIOD0 && stakedTime < PERIOD1) {
            lpFeeMultiplier = lpPeriod1Fee;
            rewardDivisor = period1Divisor;
        } else if (stakedTime >= PERIOD1 && stakedTime < PERIOD2) {
            lpFeeMultiplier = lpPeriod2Fee;
            rewardDivisor = period2Divisor;
        } else if (stakedTime >= PERIOD2 && stakedTime < PERIOD3) {
            lpFeeMultiplier = lpPeriod3Fee;
            rewardDivisor = period3Divisor;
        } else if (stakedTime >= PERIOD3 && stakedTime < PERIOD4) {
            lpFeeMultiplier = lpPeriod4Fee;
            rewardDivisor = period4Divisor;
        }
    }

    /**
     * Stakes the stakeable tokens.
	 *
     * @notice - The amount will be divided by 10**6 to have a better possibility to divide the rewards
	 *         - It is not possible to stake an amount which has a residual of 10**6
	 *
     * @param amount stakeable tokens
     */
    function stake(uint256 amount) external nonReentrant {
        require(isActive == true, "This pool is not active");

        uint256 amountWithoutResidual = amount - (amount % SHARE_DIVISOR);

        require(amountWithoutResidual > 0, "Too small amount");

        IERC20(stakeToken).safeTransferFrom(msg.sender, address(this), amountWithoutResidual);
        _stake(amountWithoutResidual);
    }

    /**
     * After the Transfer of the stakable Tokens happend, the needed flags for the staker are set.
	 *
	 * @param amount stakeable tokens
     */
    function _stake(uint256 amount) internal {
        if (userInfo[msg.sender].share == 0) {
            stakerCount += 1;
        }
        
        updateRewards();

        uint256 shareAmount = amount / SHARE_DIVISOR;

        (uint256 tempUnclaimed, ) = claimableAmount(msg.sender);
        userInfo[msg.sender].unclaimedAmount = tempUnclaimed;
        userInfo[msg.sender].lastRewardsPerShare = _rewardsPerShare;
        userInfo[msg.sender].share += shareAmount;
        userInfo[msg.sender].stakeBegin = block.timestamp;

        totalShares += shareAmount;

        // the emission will be activated only if there is a staker
        _setActivity();
    }

    /**
     * Calculates the actual claimable amount.
     * Counts the rewards per seconds from the last update plus the uncalculated (not updated) rewards minus the last user update.
     * It multiplies them with the share amount of the user.
     * Plus the unclaimed amount of the user which may happen when the user stakes more than one time without redeeming.
     * Divides the possible claimable amount by the claim divisor.
	 *
     * @notice claim:
     *         - 1 Day -> rewards / 6
     *         - <7 Days -> rewards / 5
     *         - <14 Days -> rewards / 4
     *         - <28 Days -> rewards / 3
     *         - <56 Days -> rewards / 2
     *         - >56 Days -> rewards / 1
     *         withdraw:
     *         - 1 Day -> 1%
     *         - <7 Days -> 2%
     *         - <14 Days -> 3%
     *         - <28 Days -> 2%
     *         - <56 Days -> 1%
     *         - >56 Days -> 0.5%
	 *
     * @param user address
     * @return claimable claimable amount without factoring in the claim fee
     * @return claimableAfterFee claimable amount with factoring in the claim fee
     */
    function claimableAmount(address user) public view returns (uint256 claimable, uint256 claimableAfterFee) {
        (uint256 uncalculatedRewardsPerShare, ) = getUncalculated();
        uint256 claimablePerShare = _rewardsPerShare + uncalculatedRewardsPerShare - userInfo[user].lastRewardsPerShare;

        claimable = claimablePerShare * userInfo[user].share;
        claimable += userInfo[user].unclaimedAmount;

        (, uint256 rewardFee, ) = getDivisorByTime(user);
        claimableAfterFee = claimable / rewardFee;
    }

    /**
     * Updates the actual rewards and sends the claimable amount to the caller.
     */
    function claim() external nonReentrant {
        updateRewards();
        _claim();
    }

    /**
     * Sends the claimable amount to the caller.
     */
    function _claim() internal {
        (uint256 claimable, uint256 claimableAfterFee) = claimableAmount(msg.sender);

        myShare.mint(msg.sender, claimableAfterFee, claimable - claimableAfterFee);

        userInfo[msg.sender].lastRewardsPerShare = _rewardsPerShare;
        userInfo[msg.sender].unclaimedAmount = 0;
    }

    /**
     * Sends all staked tokens to the message sender.
     */
    function _withdraw() internal {
        require(userInfo[msg.sender].share > 0, "You are not a staker.");
        
        uint256 wAmount = userInfo[msg.sender].share * SHARE_DIVISOR;
        (uint256 withdrawFee, ,) = getDivisorByTime(msg.sender);

        uint256 fee = (wAmount * withdrawFee) / 1000;
        uint256 roundedAmountAfterFee = wAmount - fee;

        IERC20(stakeToken).safeTransfer(msg.sender, roundedAmountAfterFee);
        IERC20(stakeToken).safeTransfer(address(1), fee);

        totalShares -= userInfo[msg.sender].share;
        userInfo[msg.sender].share = 0;

        stakerCount -= 1;
        _setActivity();
    }

    /**
     * Claims all rewards and unstakes the staked tokens.
     */
    function redeem() public nonReentrant {
        updateRewards();

        _claim();
        _withdraw();
        _setTimer();
    }

    /**
     * Redeems without claiming (if a minter is removed and there are still lp tokens staked)
     */
    function emergencyRedeemWithOutClaim() public nonReentrant {
        _withdraw();
        _setTimer();
    }

    /**
     * Gives the owner the possibility to withdraw tokens which are airdroped or send by mistake to this contract, except the staked tokens.
	 *
     * @param to recipient of the tokens
     * @param tokenAddr token contract
     */
    function daoWithdrawERC(address to, address tokenAddr) external onlyOwner {
        require(tokenAddr != stakeToken,"You cannot withdraw the staked tokens");

        IERC20(tokenAddr).safeTransfer(to, IERC20(tokenAddr).balanceOf(address(this)));
    }

    /**
     * Gives the owner the possibility to withdraw ETH which are airdroped or send by mistake to this contract.
	 *
     * @param to recipient of the tokens
     */
    function daoWithdrawETH(address to) external onlyOwner {
        (bool sent,) = to.call{value: address(this).balance}("");
		
        require(sent, "Failed to send ETH");
    }
}


// File: contracts/token/MyShare.sol
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Context.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";


interface IMyInkMinter {
    function fundByMyShare(uint256 amount) external;
}

/**
 * @title The magical MyShare token contract.
 * @author int(200/0), slidingpanda
 */
contract MyShare is Context, Ownable, IERC20Metadata, ReentrancyGuard {
    mapping(address => uint256) private _balances;

    mapping(address => mapping(address => uint256)) private _allowances;

    mapping(address => bool) public liqPool;
    mapping(address => uint256) public lastTransaction;
    
    uint256 private _totalSupply;
    uint256 public totalBurned;
    uint256 public notRealisedMints;

    address public daoWallet;
    address public oldToken;

    string private _name;
    string private _symbol;

    uint256 private txnFee = 10;
    uint256 private stakeFee = 5;
    uint256 public constant FEE_DIVISOR = 1000;

    struct Minter {
        uint256 lastEmission;
        uint256 maxMintable;
        uint256 alreadyMinted;
        bool isMinter;
        bool isActive;
    }

    mapping(address => Minter) private _minter;
    mapping(address => bool) public isFactory;
    mapping(address => bool) public isWhitelisted;
    mapping(address => bool) public isBlacklisted;

    uint256 public activeMinterCount;
    uint256 public notActiveMinterCount;

    uint256 public startTime;
    uint256 public constant START_EMISSION = 1e24; // 1mio * 10**18
    uint256 public YEAR_PERIOD = 31557600;
    uint256 public emissionPerSecondPerMinter;
    uint256 public lastEmissionCalculation;

    address public myExLiqPool;

    uint8 public lastEpoch = 1;

    address public _myInkMinterAddr;

    event SetMyInkMinter(address oldMinterAddress, address newMinterAddress);
    event SetTxnFee(uint oldTxnFee, uint newTxnFee);
    event SetStakeFee(uint oldStakeFee, uint newStakeFee);
    event SetLiqPool(address liqPoolAddress, bool state);
    event SetIsBlacklisted(address userAddress, bool state);
    event SetIsWhitelisted(address userAddress, bool state);
    event ChangeDaoWallet(address daoWallet);
    event SetMyExLP(address lpAddress);
    event SetFactory(address factoryAddress, bool state);
    event AddMinter(address minter);
    event SetMinterActivity(address minter, bool state);
    event RemoveMinter(address minter);
    

    /**
     * Creates the myShare token and activates the first "staking pool" the minter for the dao.
     * The emission is fixed.
     */
    constructor(
        string memory name_,
        string memory symbol_,
        address mintTo,
        address daoWallet_
    ) public {
        _name = name_;
        _symbol = symbol_;
        startTime = block.timestamp;
        lastEmissionCalculation = startTime;
        _mint(mintTo, 2 * START_EMISSION, 0);
        isWhitelisted[mintTo] = true;
        daoWallet = daoWallet_;
        _minter[daoWallet_].isMinter = true;
        _minter[daoWallet_].isActive = true;
        _minter[daoWallet_].maxMintable = 0;
        _minter[daoWallet_].alreadyMinted = 0;
        _minter[daoWallet_].lastEmission = 1;
        activeMinterCount += 1;
    }

    /**
     * Sets MyInkMinter.
	 *
     * @param myInkMinterAddr Address of MyInkMinter
     */
    function setMyInkMinter(address myInkMinterAddr) external {
        require(msg.sender == daoWallet || msg.sender == owner(), "You are not allowed to change the lp state");

        address oldAddr = _myInkMinterAddr;

        _myInkMinterAddr = myInkMinterAddr;

        emit SetMyInkMinter(oldAddr, _myInkMinterAddr);
    }

    /**
     * Changes the transaction fee.
     * The divisor of the fee calculation is 1000, so 1000 is the maximum and means 100%.
	 *
     * @param fee multiplier of the fee
     */
    function setTxnFee(uint256 fee) external onlyOwner {
        require(fee + stakeFee <= FEE_DIVISOR, "Max fee == 1000 -> 100%");

        uint oldFee = txnFee;

        txnFee = fee;

        emit SetTxnFee(oldFee, txnFee);
    }

    /**
     * Changes the stake fee.
     * The divisor of the fee calculation is 1000, so 1000 is the maximum and means 100%.
	 *
     * @param fee multiplier of the fee
     */
    function setStakeFee(uint256 fee) external onlyOwner {
        require(fee + txnFee <= FEE_DIVISOR, "Max fee == 1000 -> 100%");

        uint oldFee = stakeFee;

        stakeFee = fee;

        emit SetStakeFee(oldFee, stakeFee);
    }

    /**
     * Sets liquidity pool state.
	 *
     * @param liqPoolAddr address of the lp token
     * @param state lp state
     */
    function setLiqPool(address liqPoolAddr, bool state) external {
        require(msg.sender == daoWallet || msg.sender == owner(), "You are not allowed to change the lp state");

        liqPool[liqPoolAddr] = state;

        emit SetLiqPool(liqPoolAddr, state);
    }

    /**
     * Changes isBlacklisted (true = not possible to receive tokens, false = possible to receive tokens).
	 *
     * @param user address of the user
     * @param state blacklisted state
     */
    function setIsBlacklisted(address user, bool state) external {
        require(msg.sender == daoWallet || msg.sender == owner(), "You are not allowed to change the blacklist");

        isBlacklisted[user] = state;

        emit SetIsBlacklisted(user, state);
    }

    /**
     * Changes isWhitelisted (true = no fees, false = fees).
	 *
     * @param user address of the user
     * @param state whitelisted state
     */
    function setIsWhitelisted(address user, bool state) external {
        require(msg.sender == daoWallet || msg.sender == owner(), "You are not allowed to change the whitelist");

        isWhitelisted[user] = state;

        emit SetIsWhitelisted(user, state);
    }

    /**
     * Changes the dao wallet which is allowed to mint depending on the amount of the activated minter and the actual emission.
     * If you want to stop that emission, you can do it by passing the zero address as an owner here or as the contract which is the last dao wallet.
	 *
     * @param newDAOWallet address of the new dao wallet
     */
    function changeDaoWallet(address newDAOWallet) external onlyOwner {
        updateEmission();

        _minter[daoWallet].isMinter = false;
        _minter[daoWallet].isActive = false;
        _minter[daoWallet].lastEmission = emissionPerSecondPerMinter;

        daoWallet = newDAOWallet;

        if (newDAOWallet != address(0)) {
            _minter[daoWallet].isMinter = true;
            _minter[daoWallet].isActive = true;
            _minter[daoWallet].lastEmission = emissionPerSecondPerMinter;

            emit ChangeDaoWallet(daoWallet);
        }
    }

    /**
     * The liquidity pool of myExchange tokens has a special fee and it is only settable once.
     * @param inAddr address of lp tokens
     */
    function setMyExLP(address inAddr) external onlyOwner {
        require(myExLiqPool == address(0), "Already set");

        myExLiqPool = inAddr;
        liqPool[inAddr] = true;

        emit SetMyExLP(inAddr);
    }

    /**
     * Sets a staking factory.
	 *
     * @notice - A factory is capable to add new minters (staking contracts)
     *         - A factory can also be deactivated with this function
	 *
     * @param factoryAddr address of the factory
     * @param state true -> is a factory / false -> is not a factory
     */
    function setFactory(address factoryAddr, bool state) external onlyOwner {
        isFactory[factoryAddr] = state;

        emit SetFactory(factoryAddr, state);
    }

    /**
     * Adds a minter.
	 *
     * @notice - A minter can mint a fragment of the defined emission, so no "overminting" is possible
     *         - A factory or the owner (DAO) can add a minter
     *         - A minter is not activated by default, so it cannot mint by default. -> The minter or the owner has to activate itself
     *         - This is designed so that there is no minting without any stakes
	 *
     * @param minter_ address of the new minter
     */
    function addMinter(address minter_) external {
        require(isFactory[msg.sender] == true || msg.sender == owner(), "Only an authorized factory or owner can add a minter");
        require(_minter[minter_].isMinter == false, "Minter is already set");

        updateEmission();

        _minter[minter_].isMinter = true;
        _minter[minter_].maxMintable = 0;
        _minter[minter_].alreadyMinted = 0;
        _minter[minter_].lastEmission = emissionPerSecondPerMinter;

        notActiveMinterCount += 1;

        emit AddMinter(minter_);
    }

    /**
     * Activates/Deactivates a minter.
	 *
     * @notice - Only the minter or the owner can activate the minter
     *         - If a minter is not active there is no emission from it which happens if the minter/staking contract has no stakers which calls this function
	 *
     * @param activate true -> active / false -> inactive
     */
    function setMinterActivity(address toSetMinter, bool activate) external {
        require(_minter[msg.sender].isMinter == true || msg.sender == owner(), "Only an authorized minter or owner can add a minter");

        if (msg.sender != owner()) {
            toSetMinter = msg.sender;
        }
        
        require(_minter[toSetMinter].isMinter == true, "The address which should be activated is not a minter");

        updateEmission();
        updateMinter(toSetMinter);

        if (activate != _minter[toSetMinter].isActive) {
            _minter[toSetMinter].isActive = activate;

            if (activate) {
                activeMinterCount += 1;
                notActiveMinterCount -= 1;
            } else {
                activeMinterCount -= 1;
                notActiveMinterCount += 1;
            }
        }

        emit SetMinterActivity(toSetMinter, activate);
    }

    /**
     * Removes a minter if the address is a minter.
	 *
     * @notice - Checks if the minter is active
     *         - If a minter is removed, it is losing the possibility to mint and every unminted emission
     *         - If it should not lose unminted emission (old staking pool which has stakers), deactivate the minter and remove it after all stakers left
	 *
     * @param minter_ address of the minter
     */
    function removeMinter(address minter_) external {
        require(isFactory[msg.sender] == true || msg.sender == owner(), "Only an authorized factory or owner can remove a minter");
        require(_minter[minter_].isMinter == true, "The given address is not a minter.");

        updateEmission();
        updateMinter(minter_);

        
        _minter[minter_].isMinter = false;
        if (_minter[minter_].isActive) {
            activeMinterCount -= 1;
            _minter[minter_].isActive = false;
        } else {
            notActiveMinterCount -= 1;
        }

        emit RemoveMinter(minter_);
        
    }

    /**
     * Returns the minter state of an address.
	 *
     * @param toCheck address which is checked
     * @return returnState true -> is a minter / false -> is not a minter
     */
    function isMinter(address toCheck) public view returns (bool returnState) {
        returnState = _minter[toCheck].isMinter;
    }

    /**
     * Returns the minter activity state.
	 *
     * @param toCheck address which is checked
     * @return returnState true -> is active / false -> is not active
     */
    function isActiveMinter(address toCheck) public view returns (bool returnState) {
        returnState = _minter[toCheck].isActive;
    }

    /**
     * Returns the last global emission of a minter which was calculated.
	 *
     * @param toCheck address which is checked
     * @return returnAmount last calculated emission of a minter
     */
    function lastEmissionOfMinter(address toCheck) public view returns (uint256 returnAmount) {
        returnAmount = _minter[toCheck].lastEmission;
    }

    /**
     * Returns the last global emission of a minter per second.
	 *
     * @notice Every minter fragments the emission.
     *         - X = minter
     *         - EPS = Emission per year divided by seconds per year
     *         - returns EPS / X
	 *
     * @return returnAmount actual emission per sencond and minter
     */
    function emissionPerMinterPerSecond() public view returns (uint256 returnAmount) {
        if (activeMinterCount == 0) {
            returnAmount = 0;
        } else {
            uint256 emissionPerSecond = actualEmissionPerSecond();
            returnAmount = emissionPerSecond / activeMinterCount;
        }
    }

    /**
     * Returns the end time of a given epoch.
	 *
     * @notice - Epochs <1 have no endTime (zero)
     *         - After Epoch 4 (>4) the epoch lasts forever (2**256)
	 *
     * @param epoch epoch which is checked
     * @return endTime last second of the epoch (timestamp)
     */
    function endOfEpoch(uint8 epoch) public view returns (uint256 endTime) {
        if (epoch < 1) {
            endTime = 0;
        } else if (epoch > 5) {
            endTime = type(uint256).max;
        } else {
            endTime = startTime + YEAR_PERIOD * epoch;
        }
    }

    /**
     * Checks which epoch is the actual epoch right now.
	 *
     * @notice There are only epochs 1-5 (>= 5 are endless)
	 *
     * @return aEpoch actual epoch
     */
    function actualEpoch() public view returns (uint8 aEpoch) {
        uint256 epoch = block.timestamp - startTime;

        if (epoch / YEAR_PERIOD == 0) {
            aEpoch = 1;
        } else if (epoch / YEAR_PERIOD == 1) {
            aEpoch = 2;
        } else if (epoch / YEAR_PERIOD == 2) {
            aEpoch = 3;
        } else if (epoch / YEAR_PERIOD == 3) {
            aEpoch = 4;
        } else if (epoch / YEAR_PERIOD == 4) {
            aEpoch = 5;
        } else if (epoch / YEAR_PERIOD >= 5) {
            aEpoch = 6;
        }
    }

    /**
     * Returns a divisor for the emission calculation.
	 *
     * @notice The divisor is doubled with each epoch which means the emission is halved until 3.125 % from the beginning emission.
	 *
     * @param cEpoch epoch which is checked
     * @return divisor divisor of the given epoch
     */
    function emissionOfEpoch(uint256 cEpoch) public pure returns (uint8 divisor) {
        require(cEpoch > 0 && cEpoch <= 6, "There are only 1 to 6 epochs");

        if (cEpoch == 1) {
            divisor = 1;
        } else if (cEpoch == 2) {
            divisor = 2;
        } else if (cEpoch == 3) {
            divisor = 4;
        } else if (cEpoch == 4) {
            divisor = 8;
        } else if (cEpoch == 5) {
            divisor = 16;
        } else if (cEpoch == 6) {
            divisor = 32;
        }
    }

    /**
     * Returns the actual emission of the actual epoch.
	 *
     * @notice The divisor is doubled with each epoch which means the emission is halved until 3.125 % from the beginning emission.
	 *
     * @return emissionPerSecond of the given epoch
     */
    function actualEmissionPerSecond() public view returns (uint256 emissionPerSecond) {
        uint8 multiplier = emissionOfEpoch(actualEpoch());

        emissionPerSecond = START_EMISSION / (multiplier * YEAR_PERIOD);
    }

    /**
     * Returns the emission of the given epoch.
	 *
     * @notice The divisor is doubled with each epoch which means the emission is halved until 3.125 % from the beginning emission.
	 *
     * @return emissionPerSecond of the given epoch
     */
    function emissionPerSecondOfEpoch(uint256 cEpoch) public view returns (uint256 emissionPerSecond) {
        uint8 multiplier = emissionOfEpoch(cEpoch);

        emissionPerSecond = START_EMISSION / (multiplier * YEAR_PERIOD);
    }

    /**
     * Calculates the emission per second so far minus the already calculated emission.
	 *
     * @notice Checks if there was a shift in the epochs in the meantime.
	 *
     * @return uncalc uncalculated emission
     */
    function uncalculatedEmission() public view returns (uint256 uncalc) {
        uint256 period0 = 0;
        uint256 period1 = 0;
        uint256 justNow = block.timestamp;
        uint256 actualEmission = emissionPerMinterPerSecond();

        uint8 actEpoch = actualEpoch();

        if (actEpoch != lastEpoch) {
            uint256 tempEndOfEpoch = endOfEpoch(lastEpoch);

            period0 = tempEndOfEpoch - lastEmissionCalculation;
            period1 = justNow - tempEndOfEpoch;

            uncalc = period0 * emissionPerSecondOfEpoch(lastEpoch);
        } else {
            period1 = justNow - lastEmissionCalculation;
        }

        uncalc += period1 * actualEmission;
    }

    /**
     * Calculates the emission since the last calculation and updates the state.
     */
    function updateEmission() public {
        emissionPerSecondPerMinter += uncalculatedEmission();
        lastEmissionCalculation = block.timestamp;

        uint8 actEpoch = actualEpoch();
        lastEpoch = actEpoch;
    }

    /**
     * Calculates the maximal mintable amount for a given minter.
	 *
     * @notice - Uncalculated emission + the already calculated emission
     *         - The real mintable amount is the result from this funtion minus the already minted amount
	 *
	 * @param minterAddr minter address
     * @return maxMintable uncalculated emission
     */
    function uncalculatedMaxEmissionForMinter(address minterAddr) public view returns (uint256 maxMintable) {
        if (_minter[minterAddr].lastEmission != 0) {
            uint256 tempEmissionPerMinter;
            uint256 availableEmission;

            if (_minter[minterAddr].isActive) {
                tempEmissionPerMinter = uncalculatedEmission();
                availableEmission = emissionPerSecondPerMinter + tempEmissionPerMinter - _minter[minterAddr].lastEmission;
            }

            maxMintable = _minter[minterAddr].maxMintable + availableEmission;
        }
    }

    /**
     * Calculates the maximal mintable amount for a given minter minus the already minted amount.
	 *
     * @notice The return is the "real" mintable amount for a minter.
	 *
	 * @param minterAddr minter address
     * @return mintable uncalculated emission
     */
    function maxMintableForMinter(address minterAddr) public view returns (uint256 mintable) {
        uint256 maxMintable = uncalculatedMaxEmissionForMinter(minterAddr);

        mintable = maxMintable - _minter[minterAddr].alreadyMinted;
    }

    /**
     * Changes the state of a minter with the uncalculated amounts.
     */
    function updateMinter(address minterAddr) public {
        if (isMinter(minterAddr)) {
            updateEmission();

            _minter[minterAddr].maxMintable = uncalculatedMaxEmissionForMinter(minterAddr);
            _minter[minterAddr].lastEmission = emissionPerSecondPerMinter;
        }
    }

    /**
     * Returns the name of the token.
     */
    function name() public view virtual override returns (string memory) {
        return _name;
    }

    /**
     * Returns the symbol of the token, usually a shorter version of the name.
     */
    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    /**
     * Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5.05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei. This is the value {ERC20} uses, unless this function is
     * overridden;
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view virtual override returns (uint8) {
        return 18;
    }

    /**
     * See {IERC20-totalSupply}.
     */
    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    /**
     * See {IERC20-balanceOf}.
     */
    function balanceOf(address account)
        public
        view
        virtual
        override
        returns (uint256)
    {
        return _balances[account];
    }

    /**
     * See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address to, uint256 amount)
        public
        virtual
        override
        returns (bool)
    {
        address owner = msg.sender;
        _checkTransfer(owner, to, amount);
        return true;
    }

    /**
     * See {IERC20-allowance}.
     */
    function allowance(address owner, address spender)
        public
        view
        virtual
        override
        returns (uint256)
    {
        return _allowances[owner][spender];
    }

    /**
     * See {IERC20-approve}.
     *
     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on
     * `transferFrom`. This is semantically equivalent to an infinite approval.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 amount)
        public
        virtual
        override
        returns (bool)
    {
        address owner = msg.sender;
        _approve(owner, spender, amount);
        return true;
    }

    /**
     * See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20}.
     *
     * NOTE: Does not update the allowance if the current allowance
     * is the maximum `uint256`.
     *
     * Requirements:
     *
     * - `from` and `to` cannot be the zero address.
     * - `from` must have a balance of at least `amount`.
     * - the caller must have allowance for ``from``'s tokens of at least
     * `amount`.
     */
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public virtual override returns (bool) {
        address spender = msg.sender;
        _spendAllowance(from, spender, amount);
        _checkTransfer(from, to, amount);
        return true;
    }

    /**
     * Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue)
        public
        virtual
        returns (bool)
    {
        address owner = msg.sender;
        _approve(owner, spender, allowance(owner, spender) + addedValue);
        return true;
    }

    /**
     * Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue)
        public
        virtual
        returns (bool)
    {
        address owner = msg.sender;
        uint256 currentAllowance = allowance(owner, spender);
        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
        unchecked {
            _approve(owner, spender, currentAllowance - subtractedValue);
        }

        return true;
    }

    /**
     * Substracts the amount of the from address and adds the burnt amount minus the transaction fees to the recipient address (to).
	 * Funds minter contract.
	 *
     * @notice The liquidity pool of myShare and myExchange has a 50% transaction fee if there are myExchange tokens swapped for myShare tokens.
	 *
	 * @param from from address
	 * @param to to address
	 * @param amount token amount
     */
    function _transfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {
        require(from != address(0), "ERC20: transfer from the zero address");
        require(to != address(0), "ERC20: transfer to the zero address");

        _beforeTokenTransfer(from, to, amount);

        uint256 fromBalance = _balances[from];
        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");

        uint256 tFee = (amount * txnFee) / FEE_DIVISOR;
        uint256 sFee = (amount * stakeFee) / FEE_DIVISOR;

        // by increasing the fee of the MyEx lp, the sell pressure is dramatically taken away
        // myXXX(1.2%) -> MyEx -> MyS(50%) -> BUSD === 51.2% fee
        // myXXX(1.2%) -> MyEx -> myYYY(1.2%) -> BUSD === 2.4% fee
        // this keeps MyEx tokens in the system of myXXX tokens
        if (from == myExLiqPool) {
            tFee = amount / 2;
            tFee = tFee - sFee;
        }

        uint256 afterFee = amount - tFee - sFee;
        _burn(from, tFee);

        unchecked {
            _balances[from] = fromBalance - amount;
        }
		
        _balances[to] += afterFee;
        _balances[_myInkMinterAddr] += sFee;

        IMyInkMinter(_myInkMinterAddr).fundByMyShare(sFee);

        emit Transfer(from, to, afterFee);

        _afterTokenTransfer(from, to, afterFee);
    }

    /**
     * Substracts the amount of the from address and adds the amount without transaction fees to the recipient address (to).
	 *
	 * @param from from address
	 * @param to to address
	 * @param amount token amount
     */
    function _transferFeeless(
        address from,
        address to,
        uint256 amount
    ) internal virtual {
        require(from != address(0), "ERC20: transfer from the zero address");
        require(to != address(0), "ERC20: transfer to the zero address");

        _beforeTokenTransfer(from, to, amount);

        uint256 fromBalance = _balances[from];
        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");

        unchecked {
            _balances[from] = fromBalance - amount;
        }
        _balances[to] += amount;

        emit Transfer(from, to, amount);

        _afterTokenTransfer(from, to, amount);
    }

    /**
     * Checks if a transfer should happen without fees or with fees.
	 *
	 * @param from from address
	 * @param to to address
	 * @param amount token amount
     */
    function _checkTransfer(
        address from,
        address to,
        uint256 amount
    ) internal {
        uint blockNr = block.number;
        require(amount > 0, "Amount need to be greater than zero.");
        require(isBlacklisted[to] == false, "NO");
        require(lastTransaction[to] != blockNr, "Only one transaction per block and recipient allowed");
        require(lastTransaction[from] != blockNr, "Only one transaction per block and sender allowed");

        if (isWhitelisted[from] == true || isWhitelisted[to] == true) {
            _transferFeeless(from, to, amount);
        } else {
            _transfer(from, to, amount);
        }

        lastTransaction[from] = liqPool[from] ? 0 : blockNr;
        lastTransaction[to] = liqPool[to] ? 0 : blockNr;
    }

    /**
     * Mints a specific amount of tokens if the caller is a minter.
	 *
     * @param to recipient address
     * @param amount mint amount
	 * @param notRealised not realised amount
     */
    function mint(
        address to,
        uint256 amount,
        uint256 notRealised
    ) external nonReentrant {
        address minterAddr = msg.sender;

        updateMinter(minterAddr);

        if (isMinter(minterAddr)) {
            if (_minter[minterAddr].maxMintable >= _minter[minterAddr].alreadyMinted + amount) {
                _mint(to, amount, notRealised);
                _minter[minterAddr].alreadyMinted += amount;
            }
        }
    }

    /** Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     */
    function _mint(
        address account,
        uint256 amount,
        uint256 notRealised
    ) internal virtual {
        require(account != address(0), "ERC20: mint to the zero address");

        _beforeTokenTransfer(address(0), account, amount);

        notRealisedMints += notRealised;

        _totalSupply += amount;
        _balances[account] += amount;

        emit Transfer(address(0), account, amount);

        _afterTokenTransfer(address(0), account, amount);
    }

    /**
     * Triggers the global reflow and burns a specific amount of tokens.
	 *
     * @param amount burn amount
     */
    function burn(uint256 amount) external {
        _burn(msg.sender, amount);
    }

    /**
     * Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 amount) internal virtual {
        _beforeTokenTransfer(account, address(0), amount);

        uint256 accountBalance = _balances[account];
        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
        unchecked {
            _balances[account] = accountBalance - amount;
        }
        _totalSupply -= amount;
        totalBurned += amount;

        emit Transfer(account, address(0), amount);

        _afterTokenTransfer(account, address(0), amount);
    }

    /**
     * Sets `amount` as the allowance of `spender` over the `owner` s tokens.
     *
     * This internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(
        address owner,
        address spender,
        uint256 amount
    ) internal virtual {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * Updates `owner` s allowance for `spender` based on spent `amount`.
     *
     * Does not update the allowance amount in case of infinite allowance.
     * Revert if not enough allowance is available.
     *
     * Might emit an {Approval} event.
     */
    function _spendAllowance(
        address owner,
        address spender,
        uint256 amount
    ) internal virtual {
        uint256 currentAllowance = allowance(owner, spender);
        if (currentAllowance != type(uint256).max) {
            require(currentAllowance >= amount, "ERC20: insufficient allowance");
            unchecked {
                _approve(owner, spender, currentAllowance - amount);
            }
        }
    }

    /**
     * Withdraws ERC20 tokens from the contract.
	 * This contract should not be the owner of any other token.
	 *
     * @param tokenAddr address of the IERC20 token
     * @param to address of the recipient
     */
    function withdrawERC(address tokenAddr, address to) external onlyOwner {
        IERC20(tokenAddr).transfer(to, IERC20(tokenAddr).balanceOf(address(this)));
    }

    /**
     * Gives the owner the possibility to withdraw ETH which are airdroped or send by mistake to this contract.
	 *
     * @param to recipient of the tokens
     */
    function daoWithdrawETH(address to) external onlyOwner {

        (bool sent,) = to.call{value: address(this).balance}("");
		
        require(sent, "Failed to send ETH");
    }

    /**
     * Hook that is called before any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * will be transferred to `to`.
     * - when `from` is zero, `amount` tokens will be minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {}

    /**
     * Hook that is called after any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * has been transferred to `to`.
     * - when `from` is zero, `amount` tokens have been minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {}
}

// File: contracts/token/MyToken.sol
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0 <=0.8.6;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "../interfaces/ISync.sol";

import "../wrapper/MyWrapper.sol";


/**
 * @title The magical MyToken token contract.
 * @author int(200/0), slidingpanda
 */
contract MyToken is Context, IERC20, Ownable {
    string private _name;
    string private _symbol;
    uint8 private _decimals;
    uint256 private _totalSupply;
    uint256 private _nettoSupply;
    uint256 private _feeReserve;
    uint256 private _gFeeMultiplier;

    struct Accounts {
        uint256 nettoBalance;
        uint256 feeAccountMultiplier;
    }

    mapping(address => bool) public isWhitelisted;
    mapping(address => bool) public isBlacklisted;

    address payable public wrapper;
    address public daoWallet;
    address public myShareToken;

    address public pegToken;

    uint256 private _fee = 100;
    uint256 private _daoTxnFee = 20;
    uint256 public constant FEE_DIVISOR = 10000;

    uint256 private constant MAX_POOLS = type(uint256).max;
    uint32 public constant REFLOW_PER = 10000;

    address[] public syncAddr;
    mapping(address => bool) public isLP;

    mapping(address => Accounts) private _accounts;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Reflow(uint256 totalSupply, uint256 multiplier, uint256 feeReserve);

    /**
     * Creates a myToken.
	 *
     * @param myName name of the myToken
     * @param mySymbol symbol of the myToken
     * @param myDecimals pegged token decimals
     * @param pegToken_ pegged token
     * @param daoWallet_ dao wallet address
     * @param myShareToken_ dao token address
     */
    constructor(
        string memory myName,
        string memory mySymbol,
        uint8 myDecimals,
        address pegToken_,
        address daoWallet_,
        address myShareToken_
    ) public {
        _name = myName;
        _symbol = mySymbol;
        _decimals = myDecimals;
        pegToken = pegToken_;
        wrapper = payable(msg.sender);
        daoWallet = daoWallet_;
        myShareToken = myShareToken_;
        isWhitelisted[wrapper] = true;
    }

    /**
     * Sets a staking contract for feeless liquidity adding.
	 *
     * @param inAddr address of the staking contract
     * @param toSet whitelist status
     */
    function setWhitelist(address inAddr, bool toSet) external onlyOwner {
        isWhitelisted[inAddr] = toSet;
    }

    /**
     * Rebases liquidity pool.
	 *
     * @param inAddr address of the UniswapV2Pair
     */
    function doSync(address inAddr) public {
        ISync(inAddr).sync();
    }

    /**
     * Synchronizes UniswapV2 pools because they do not do it by themselves with rebase tokens.
     */
    function doAnySync() public {
        _doAnySync();
    }

    /**
     * Returns the number of the sync addresses.
	 *
     * @return uint256 sync address count
     */
    function getSyncAddrLength() public view returns (uint256) {
        return syncAddr.length;
    }

    /**
     * Returns the name of the myToken.
	 *
     * @return string name
     */
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * Returns the symbol of the myToken.
	 *
     * @return string symbol
     */
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * Returns the decimals of the myToken.
	 *
     * @return uint8 decimals
     */
    function decimals() public view returns (uint8) {
        return _decimals;
    }

    /**
     * Returns the total supply of the myToken.
	 *
     * @return uint256 total supply
     */
    function totalSupply() external view override returns (uint256) {
        return _totalSupply;
    }

    /**
     * Returns the netto supply of the myToken.
	 *
     * @return uint256 netto supply
     */
    function nettoSupply() external view returns (uint256) {
        return _nettoSupply;
    }

    /**
     * Returns the myToken balance of a wallet.
	 *
     * @param account account address
     * @return uint256 myToken balance
     */
    function balanceOf(address account) public view override returns (uint256) {
        return _balanceOf(account);
    }

    /**
     * Calculates and returns the myToken balance of a wallet.
	 *
     * @param account account address
     * @return uint256 myToken balance
     */
    function _balanceOf(address account) internal view returns (uint256) {
        uint256 multiplier = _gFeeMultiplier - _accounts[account].feeAccountMultiplier;
        uint256 collectedReflows = (_accounts[account].nettoBalance * multiplier) / REFLOW_PER;

        return _accounts[account].nettoBalance + collectedReflows;
    }

    /**
     * Returns the myToken netto balance of a specific account.
	 *
     * @param account account address
     * @return uint256 myToken netto balance
     */
    function nettoBalanceOf(address account) external view returns (uint256) {
        return _accounts[account].nettoBalance;
    }

    /**
     * Returns the allowance.
	 *
     * @param toAllow toAllow address
     * @param spender spender address
     * @return allowance
     */
    function allowance(address toAllow, address spender) external view override returns (uint256) {
        return _allowances[toAllow][spender];
    }

    /**
     * Approves an amount to be transfered.
	 *
     * @param spender spender address
     * @param amount approve amount
     * @return bool 'true' if not reverted
     */
    function approve(address spender, uint256 amount) external override returns (bool) {
        _approve(_msgSender(), spender, amount);

        return true;
    }

    /**
     * Approves an amount to be transfered.
	 *
     * @param toAllow toAllow address
     * @param spender spender address
     * @param amount approve amount
     */
    function _approve(address toAllow, address spender, uint256 amount) private {
        require(toAllow != address(0), "_approve: approve from the zero address");
        require(spender != address(0), "_approve: approve to the zero address");

        _allowances[toAllow][spender] = amount;

        emit Approval(toAllow, spender, amount);
    }

    /**
     * Increases the allowance.
	 *
     * @param spender spender address
     * @param addedValue added value
     * @return bool 'true' if not reverted
     */
    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {
        _approve(
            _msgSender(),
            spender,
            _allowances[_msgSender()][spender] + addedValue
        );

        return true;
    }

    /**
     * Decreases the allowance.
	 *
     * @param spender spender address
     * @param subtractedValue subtracted value
     * @return bool 'true' if not reverted
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {
        require(_allowances[_msgSender()][spender] >= subtractedValue, "decreaseAllowance: decreased allowance below zero");

        _approve(
            _msgSender(),
            spender,
            _allowances[_msgSender()][spender] - subtractedValue
        );

        return true;
    }

    /**
     * Calls the function which checks which type of transaction should happen.
	 *
     * @param sender spender address
     * @param recipient recipient address
     * @param amount transfer amount
     * @return bool 'true' if not reverted
     */
    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {
        require(_allowances[sender][_msgSender()] >= amount, "transferFrom: transfer amount exceeds allowance");

        _interTransfer(sender, recipient, amount);
        _approve(
            sender,
            _msgSender(),
            _allowances[sender][_msgSender()] - amount
        );

        return true;
    }

    /**
     * Calls the function which checks which type of transaction should happen.

     * @param recipient recipient address
     * @param amount token amount
     * @return bool 'true' if not reverted
     */
    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _interTransfer(_msgSender(), recipient, amount);

        return true;
    }

    /**
     * Checks if the transfer is feeless or with fees.
	 *
     * @param sender spender address
     * @param recipient recipient address
     * @param amount token amount
     */
    function _interTransfer(address sender, address recipient, uint256 amount) internal {
        require(amount > 0, "_interTransfer: Transfer amount must be greater than zero");
        require(_balanceOf(sender) >= amount, "_interTransfer: transfer amount exceeds balance");

        if (isWhitelisted[sender] || isWhitelisted[recipient]) {
            _doTransferFeeless(sender, recipient, amount);
        } else {
            _doTransfer(sender, recipient, amount);
        }
    }

    /**
     * Transfers an amount from a sender to a recipient.
	 *
     * @notice Users can reduce the fee by holding myShare tokens or by paying with myShare tokens.
     *         - fee * 1.0 by doing nothing
     *         - fee * 0.9 by holding myShare tokens
     *         - fee * 0.5 by reducing the fee on the reducer
     * @param sender spender address
     * @param recipient recipient address
     * @param amount transfer amount
     */
    function _doTransfer(address sender, address recipient, uint256 amount) private {
        require(sender != address(0), "_doTransfer: transfer from the zero address");
        require(recipient != address(0), "_doTransfer: transfer to the zero address");
        require(isBlacklisted[recipient] == false, "_doTransfer: This address is blacklisted");
        require(isBlacklisted[sender] == false, "_doTransfer: This address is blacklisted");

        uint256 toReserve = ((amount * _fee) / FEE_DIVISOR);
        uint256 toDao = ((amount * _daoTxnFee) / FEE_DIVISOR);

        uint256 feeMultiplier = 10;

        if (isLP[sender] == false) {
            (feeMultiplier, ) = MyWrapper(wrapper).userFee(sender);
        } else {
            (feeMultiplier, ) = MyWrapper(wrapper).userFee(recipient);
        }

        toReserve = (toReserve * feeMultiplier) / 10;
        toDao = (toDao * feeMultiplier) / 10;

        uint256 afterFee = amount - toReserve - toDao;

        _feeReserve += toReserve;

        _subFromBalance(amount, sender);
        _addToBalance(toDao, daoWallet);
        _addToBalance(afterFee, recipient);

        emit Transfer(sender, daoWallet, toDao);
        emit Transfer(sender, recipient, afterFee);
    }

    /**
     * Transfers an amount from a sender to a recipient with no fees.
	 *
     * @param sender spender address
     * @param recipient recipient address
     * @param amount transfer amount
     */
    function _doTransferFeeless(address sender, address recipient, uint256 amount) private {
        _subFromBalance(amount, sender);
        _addToBalance(amount, recipient);

        emit Transfer(sender, recipient, amount);
    }

    /**
     * Adds an amount to a wallet balance.
	 *
     * @param amount amount
     * @param to wallet address
     */
    function _addToBalance(uint256 amount, address to) internal {
        _nettoSupply -= _accounts[to].nettoBalance / REFLOW_PER;

        _accounts[to].nettoBalance = _balanceOf(to);
        _accounts[to].feeAccountMultiplier = _gFeeMultiplier;
        _accounts[to].nettoBalance += amount;

        _nettoSupply += _accounts[to].nettoBalance / REFLOW_PER;
    }

    /**
     * Adds an amount to a wallet balance.
	 *
     * @param amount amount
     * @param from wallet address
     */
    function _subFromBalance(uint256 amount, address from) internal {
        _nettoSupply -= _accounts[from].nettoBalance / REFLOW_PER;

        _accounts[from].nettoBalance = _balanceOf(from);
        _accounts[from].feeAccountMultiplier = _gFeeMultiplier;

        _accounts[from].nettoBalance -= amount;

        _nettoSupply += _accounts[from].nettoBalance / REFLOW_PER;
    }

    /**
     * Blacklists an account and puts the account balance into the fee reserve to prevent a dead wallet collecting fees.
	 *
     * @param account account address
     * @return bool is blacklisted
     */
    function blacklistAccount(address account) external onlyOwner returns (bool) {
        _addToBalance(0, account);
        uint256 toReserve = balanceOf(account);

        _subFromBalance(toReserve, account);
        _feeReserve += toReserve;

        isBlacklisted[account] = true;

        return isBlacklisted[account];
    }

    /**
     * Returns the fee account multiplier for a specific account.
	 *
     * @param account account address
     * @return uint256 fee account multiplier
     */
    function getMultiplierOf(address account) external view returns (uint256) {
        return _accounts[account].feeAccountMultiplier;
    }

    /**
     * Getter for _gFeeMultiplier.
	 *
     * @return uint256 global fee multiplier
     */
    function globalMultiplier() external view returns (uint256) {
        return _gFeeMultiplier;
    }

    /**
     * Getter for _fee gives back the txn fee excluded daoFee.
	 *
     * @return uint256 fee
     */
    function getReflowTxnFee() external view returns (uint256) {
        return _fee;
    }

    /**
     * Getter for _daoTxnFee gives back the daoFee fee excluded txn fee.
	 *
     * @return uint256 dao transaction fee
     */
    function getDaoTxFee() external view returns (uint256) {
        return _daoTxnFee;
    }

    /**
     * Getter for gives back fee that have to be paid.
	 *
     * @return uint256 fee + dao fee
     */
    function txnFee() external view returns (uint256) {
        return _fee + _daoTxnFee;
    }

    /**
     * Returns the actual fees.
	 *
     * @return uint256 fee divisor
	 * @return uint256 actual fees
     */
    function getActualFees() external view returns (uint256, uint256) {
        return (FEE_DIVISOR, _fee + _daoTxnFee);
    }

    /**
     * Getter for _feeReserve.
	 *
     */
    function feeReserve() external view returns (uint256) {
        return _feeReserve;
    }

    /**
     * Setter for _fee.
	 *
     * @param fee tx fee
     */
    function setReflowFees(uint16 fee) external onlyOwner {
        require(fee <= 100, "Too high fees set (max 10% (uint 100))");

        _fee = fee;
    }

    /**
     * Setter for _daoTxnFee.
	 *
     * @param fee tx dao fee
     */
    function setDaoTxFee(uint16 fee) external onlyOwner {
        require(fee <= 100, "Too high fees set (max 10% (uint 100))");

        _daoTxnFee = fee;
    }

    /**
     * Setter for daoWallet.
	 *
     * @param to dao wallet address
     */
    function setDaoWallet(address to) external onlyOwner {
        daoWallet = to;
    }

    /**
     * Setter for wrapper.
	 *
     * @param newWrapper wrapper address
     * @return bool 'true' if not reverted
     */
    function setWrapper(address newWrapper) external onlyOwner returns (bool) {
        wrapper = payable(newWrapper);

        return true;
    }

    /**
     * Compounds wallet with reflow.
	 *
     * @param account account address
     */
    function compoundWallet(address account) external {
        _reflow();
        _addToBalance(0, account);
    }

    /**
     * Does reflow.
     */
    function doReflow() external {
        _reflow();
    }

    /**
     * Fountains an amount.
	 *
     * @param amount fountain amount
     */
    function fountain(uint256 amount) external {
        require(_balanceOf(msg.sender) >= amount, "Transfer amount exceeds balance");

        _subFromBalance(amount, msg.sender);
        _feeReserve += amount;
    }

    /**
     * Fountains an amount.
	 *
     * @param amount fountain amount
     */
    function fountainWrapper(uint256 amount, address user) external {
        require(msg.sender == wrapper, "Only wrapper can call this function");

        _subFromBalance(amount, user);
        _feeReserve += amount;
    }

    /**
     * Mints a specific amount of tokens.
	 *
     * @param to recipient address
     * @param amount mint amount
     */
    function mint(address to, uint256 amount) external {
        require(amount > 0, "Mint amount must be greater than zero");
        require(wrapper == msg.sender, "Caller is not the wrapper");

        _reflow();
        _mint(to, amount);
    }

    /**
     * Mints tokens, triggers the global reflow and puts fees into the dao wallet.
	 *
     * @param account recipient address
     * @param amount mint amount
     */
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "Mint to the zero address");

        _addToBalance(amount, account);

        _totalSupply += amount;

        emit Transfer(address(0), account, amount);
    }

    /**
     * Triggers the global reflow and burns a specific amount of tokens.
	 *
     * @param to account address
     * @param amount burn amount
	 * @return uint256 burnt amount
     */
    function burn(address to, uint256 amount) external returns (uint256) {
        require(wrapper == msg.sender, "Caller is not the wrapper");
        require(amount > 0, "Burn amount must be greater than zero");

        return _burn(to, amount);
    }

    /**
     * Burns tokens.
	 *
     * @param account account address
     * @param amount burn amount
	 * @return uint256 burnt amount
     */
    function _burn(address account, uint256 amount) private returns (uint256) {
        require(account != address(0), "Burn from the zero address");
        require(balanceOf(account) >= amount,"Burn amount exceeds balance");

        _subFromBalance(amount, account);
        _totalSupply -= amount;

        emit Transfer(account, address(0), amount);

        _reflow();

        return amount;
    }

    /**
     * Does reflow and syncs the liquidity pools.
     */
    function _reflow() private {
        if (_feeReserve > _nettoSupply) {
            uint256 multiplier = _feeReserve / _nettoSupply;
            uint256 modRes = _feeReserve % _nettoSupply;
            _feeReserve = modRes;
            _gFeeMultiplier += multiplier;

            _doAnySync();

            emit Reflow(_totalSupply, multiplier, _feeReserve);
        }
    }

    /**
     * Does sync over all sync addresses.
     */
    function _doAnySync() internal {
        for (uint256 i = 0; i < syncAddr.length; i++) {
            ISync(syncAddr[i]).sync();
        }
    }

    /**
     * Finds an address index with a given address.
	 *
     * @param inAddr account address
     * @return uint256 address index
     */
    function _findAddr(address inAddr) internal view returns (uint256) {
        uint256 addressIndex = MAX_POOLS;

        for (uint256 i = 0; i < syncAddr.length; i++) {
            if (syncAddr[i] == inAddr) {
                addressIndex = i;
            }
        }

        return addressIndex;
    }

    /**
     * Finds an address index with a given address.
	 *
     * @param inAddr account address
     * @return uint256 address index
     */
    function findAddr(address inAddr) external view returns (uint256) {
        uint256 addressIndex = _findAddr(inAddr);

        return addressIndex;
    }

    /**
     * Removes an index of the sync addresses.
	 *
     * @param index index
     * @return bool 'true' if not reverted
     */
    function removeIndex(uint256 index) public onlyOwner returns (bool) {
        require(index <= syncAddr.length, "Index out of range.");
        require(syncAddr.length >= 1, "Array has too few elements.");

        isLP[syncAddr[index]] = false;
        syncAddr[index] = syncAddr[syncAddr.length - 1];
        syncAddr.pop();

        return true;
    }

    /**
     * Removes an address from the sync addresses.
	 *
     * @param inAddr account address
     * @return bool
     */
    function removeAddress(address inAddr) public onlyOwner returns (bool) {
        uint256 index = _findAddr(inAddr);

        if (index != MAX_POOLS) {
            return removeIndex(index);
        } else {
            return false;
        }
    }

    /**
     * Adds a sync address.
	 *
     * @param inAddr account address
     * @return bool
     */
    function addSyncAddr(address inAddr) public returns (bool) {
        require(msg.sender == owner() || msg.sender == wrapper, "You are not allowed to add sync addresses");
        require(syncAddr.length <= MAX_POOLS - 1, "Too many addresses to sync");

        if (syncAddr.length != 0) {
            if (isLP[inAddr] == false) {
                isLP[inAddr] = true;
                syncAddr.push(inAddr);

                return true;
            } else {
                return false;
            }
        } else {
            isLP[inAddr] = true;
            syncAddr.push(inAddr);

            return true;
        }
    }

    /**
     * Withdraws ERC20 tokens from the contract.
	 * This contract should not be the owner of any other token.
	 *
     * @param tokenAddr address of the IERC20 token
     * @param to address of the recipient
     */
    function withdrawERC(address tokenAddr, address to) external onlyOwner {
        IERC20(tokenAddr).transfer(to, IERC20(tokenAddr).balanceOf(address(this)));
    }

    /**
     * Gives the owner the possibility to withdraw ETH which are airdroped or send by mistake to this contract.
	 *
     * @param to recipient of the tokens
     */
    function daoWithdrawETH(address to) external onlyOwner {
        (bool sent,) = to.call{value: address(this).balance}("");
		
        require(sent, "Failed to send ETH");
    }

    /**
     * Hook that is called before any transfer of tokens which includes minting and burning.
	 *
     * @param from from address
     * @param to to address
     * @param amount transfer amount
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {
        // ...
    }
}

// File: contracts/utils/FeeReducer.sol
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0 <=0.8.6;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import "../interfaces/IRouterV2.sol";

import "../token/MyToken.sol";
import "../token/MyShare.sol";


/**
 * @title The magical FeeReducer contract.
 * @author int(200/0), slidingpanda
 */
contract FeeReducer is Ownable, ReentrancyGuard {
    using SafeERC20 for IERC20;

    IERC20 private tenTokenV1 = IERC20(0xAb887Edaf53570dd212E94CecdA38B7c165420b5);
    IERC20 private ten = IERC20(0x25B9d4b9535920194c359d2879dB6a1382c2ff26);
    MyShare private myShareToken;

    address public router;

    bool public isActive = true;

    uint256 public myShareHoldDivisor = 1e6;
    uint256 public myShareBurnDivisor = 1e5;
    uint256 public fixShareBurnAmount;
    uint256 public fixTENSendAmount = 1e20;

    uint256 public constant MONTH_IN_SECOND = 2629800; // 60*60*24*365.25/12
    uint256 public constant YEAR_IN_SECOND = 31557600; // 60*60*24*365.25

    mapping(address => uint256) private reducedUntil;

    /**
     * Creates the feeReducer.
	 *
     * @param owner_ owner of the myToken
     * @param myShareAddr address of the myShare Token
     * @param routerAddr address of the (UniV2 clone) router
     */
    constructor(
        address owner_,
        address myShareAddr,
        address routerAddr
    ) public {
        myShareToken = MyShare(myShareAddr);
        fixShareBurnAmount = myShareToken.totalSupply() / (2 * myShareBurnDivisor);
        transferOwnership(owner_);
        router = routerAddr;
    }

    /**
     * Activates/Deactivates the possiblity to reduce the fees (true = active, false = inactive, default = true).
     *
     * @param toSet status
     */
    function setActivity(bool toSet) external onlyOwner {
        isActive = toSet;
    }

    /**
     * Changes router (UniV2 clone) for the myXXX -> XXX swap.
	 *
     * @notice The liquidity needs to exist or else buyBackAnsBurn fails.
	 *
     * @param newRouter router address
     */
    function setRouter(address newRouter) external onlyOwner {
        router = newRouter;
    }

    /**
     * Sets the divisor of balance<->totalSupply check.
	 * Everyone except liquidity pools who has more than this trigger value gets a fee reduction.
	 *
     * @notice Default: 1e6 (trigger = totalSupply / myShareHoldDivisor)
	 *
     * @param newDivisor new divisor
     */
    function setMyShareHoldDivisor(uint256 newDivisor) external onlyOwner {
        require(newDivisor != 0, "Zero division not possible");
        require(newDivisor <= myShareToken.totalSupply(), "Not more than the totalSupply");
		
        myShareHoldDivisor = newDivisor;
    }

    /**
     * Changes the divisor of the myShare totalSupply.
	 *
     * @param newDivisor new divisor
     */
    function setMyShareBurnDivisor(uint256 newDivisor) external onlyOwner {
        require(newDivisor <= myShareToken.totalSupply(), "Not more than the totalSupply");

        myShareBurnDivisor = newDivisor;
    }

    /**
     * Changes the amount of the myShare burn amount.
	 *
     * @param newAmount new amount
     */
    function setMyShareBurnFixAmount(uint256 newAmount) external onlyOwner {
        require(newAmount <= myShareToken.totalSupply(), "Not more than the totalSupply");

        fixShareBurnAmount = newAmount;
    }

    /**
     * Changes the divisor of the teneo send amount.
	 *
     * @param newAmount new amount
     */
    function setTenBurnFixAmount(uint256 newAmount) external onlyOwner {
        require(newAmount <= tenTokenV1.totalSupply(), "Not more than the totalSupply");

        fixTENSendAmount = newAmount;
    }

    /**
     * Shows if an address has reduced fees.
	 *
     * @param user address
     * @return reduced is reduced
     */
    function isReduced(address user) public view returns (bool reduced) {
        if (reducedUntil[user] >= block.timestamp) {
            reduced = true;
        }
    }

    /**
     * Returns the possible fee multiplicators.
	 *
     * @notice The calculation: "amount * feeMultiX / 10" and feeMultiX can be resolved like this:
	 *			- Wrapper withdraw / LP zap in (base 1%):
     *				Holding     50% fees
     *				FeeReducer  10% fees
     *			- myToken transaction:
     *				Holding     90% fees
     *				FeeReducer  50% fees
	 *
     * @param user address which is checked
     * @return feeMultiToken fee multiplier for the myToken
     * @return feeMultiWrapper fee multiplier for withdrawing
     */
    function feeMultiplier(address user) external view returns (uint256 feeMultiToken, uint256 feeMultiWrapper) {
        if (myShareToken.balanceOf(user) >= myShareToken.totalSupply() / myShareHoldDivisor) {
            feeMultiToken = 9;
            feeMultiWrapper = 5;
        } else {
            feeMultiToken = 10;
            feeMultiWrapper = 10;
        }

        if (isReduced(user)) {
            feeMultiToken = 5;
            feeMultiWrapper = 1;
        }
    }

    /**
     * Burns the balance of the myShare token of this contract.
     */
    function burn() public {
        uint256 daoBalance = myShareToken.balanceOf(address(this));

        if (daoBalance > 0) {
            myShareToken.burn(daoBalance);
        }
    }

    /**
     * Gives back the myShare amount for reducing the fees for one month.
	 *
     * @return amount amount for reducing one month
     */
    function myShareAmountForOneMonth() public view returns (uint256 amount) {
        uint256 supply = myShareToken.totalSupply();

        amount = supply / myShareBurnDivisor + fixShareBurnAmount;
    }

    /**
     * Gives back the TEN/tenTEN amount for reducing the fees for one month.
	 *
     * @return amount amount for reducing one month
     */
    function tenAmountForOneMonth() public view returns (uint256 amount) {
        amount = fixTENSendAmount;
    }

    /**
     * Swaps tenTEN token to TEN token to not any gain reflows. Or other tokens if needed.
	 *
     * @param route route for buying back TEN
     */
    function buyBackBurn(address[] memory route) external {
        uint256 tenTenBalance = tenTokenV1.balanceOf(address(this));

        if (tenTenBalance > 0) {
            tenTokenV1.approve(router, tenTenBalance);

            IRouterV2(router)
                .swapExactTokensForTokensSupportingFeeOnTransferTokens(
                    tenTenBalance,
                    0,
                    route,
                    address(this),
                    block.timestamp + 20
                );
        }

        burn();
    }

    /**
     * Burns myShare tokens or sends tenTEN/TEN tokens for one month of fee reducing.
	 *
     * @notice - The burn amount for reducing depends on the relative supply amount and a fix amount because the myShare supply is changing
     *         - The TEN supply is fixed (also the max tenTEN amount), so the amount which will be send is also fixed
	 *
     * @param user user address
     * @param token token address
     * @return success 'true' - if successfully reduced
     */
    function reduceForMonth(address user, address token) external returns (bool success) {
        require(isActive, "This fee reducer is not active");
        require(token == address(tenTokenV1) || token == address(myShareToken) || token == address(ten), "Need TEN, tenTEN or MyShare to reduce");

        uint256 time = block.timestamp;

        if (time <= reducedUntil[user]) {
            time = reducedUntil[user];
        }

        if (token == address(tenTokenV1)) {
            tenTokenV1.transferFrom(msg.sender, address(this), tenAmountForOneMonth());

            reducedUntil[user] = time + MONTH_IN_SECOND;
            success = true;
        } else if (token == address(myShareToken)) {
            myShareToken.transferFrom(msg.sender, address(this), myShareAmountForOneMonth());

            reducedUntil[user] = time + MONTH_IN_SECOND;
            success = true;
        } else if (token == address(ten)) {
            ten.transferFrom(msg.sender, address(this), tenAmountForOneMonth());

            reducedUntil[user] = time + MONTH_IN_SECOND;
            success = true;
        }

        burn();
    }

    /**
     * Burns myShare tokens or sends tenTEN/TEN tokens for one year of fee reducing.
	 *
     * @notice Same as for a reduceForMonth, but 10x higher amounts (not 12).
	 *
     * @param user user address
     * @param token token address
     * @return success 'true' - if successfully reduced
     */
    function reduceForYear(address user, address token) external returns (bool success) {
        require(isActive, "This fee reducer is not active");
        require(token == address(tenTokenV1) || token == address(myShareToken) || token == address(ten), "Need TEN, tenTEN or MyShare to reduce");

        uint256 time = block.timestamp;

        if (time <= reducedUntil[user]) {
            time = reducedUntil[user];
        }

        if (token == address(tenTokenV1)) {
            tenTokenV1.transferFrom(msg.sender,address(this), 10 * tenAmountForOneMonth());

            reducedUntil[user] = time + YEAR_IN_SECOND;
            success = true;
        } else if (token == address(myShareToken)) {
            myShareToken.transferFrom(msg.sender,address(this), 10 * myShareAmountForOneMonth());

            reducedUntil[user] = time + YEAR_IN_SECOND;
            success = true;
        } else if (token == address(ten)) {
            ten.transferFrom(msg.sender,address(this), 10 * tenAmountForOneMonth());

            reducedUntil[user] = time + YEAR_IN_SECOND;
            success = true;
        }

        burn();
    }

    /**
     * Withdraws ERC20 tokens from the contract.
	 * Also TEN Tokens.
	 *
     * @param tokenAddr address of the IERC20 token
     * @param to address of the recipient
     */
    function withdrawERC(address tokenAddr, address to) external onlyOwner {
        IERC20(tokenAddr).safeTransfer(to, IERC20(tokenAddr).balanceOf(address(this)));
    }

    /**
     * Gives the owner the possibility to withdraw ETH which are airdroped or send by mistake to this contract.
	 *
     * @param to recipient of the tokens
     */
    function daoWithdrawETH(address to) external onlyOwner {
        (bool sent,) = to.call{value: address(this).balance}("");
		
        require(sent, "Failed to send ETH");
    }
}


// File: contracts/utils/StakingFactory.sol
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0 <=0.8.6;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import "../staking/MyStaking.sol";
import "../token/MyShare.sol";
import "../wrapper/MyWrapper.sol";


/**
 * @title The magical StakingFactory contract.
 * @author int(200/0), slidingpanda
 */
contract StakingFactory is Ownable {
    using SafeERC20 for IERC20;

    MyShare myShare;

    mapping(address => address) public pool;

    // bsc mainnet
    address public constant WETH = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;

    // bsc testnet
    // address constant public WETH = 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd;

    constructor(address myShareAddr) {
        myShare = MyShare(myShareAddr);
    }

    /**
     * Creates a new staking pool if there is no "old" pool behind the lp token hash.
	 *
     * @param lpAddr address of the pair token (UniV2/V1)
     * @param owner_ address of the owner of the contract
     * @return stakingContract address of the new staking contract
     */
    function createNewStaking(address lpAddr, address owner_) external onlyOwner returns (address stakingContract) {
        require(pool[lpAddr] == address(0), "LP token already has a staking contract");

        stakingContract = _createStaking(lpAddr, owner_);
    }

    /**
     * Changes an existing staking contract to a new one and removes the old as a staker from the pool hashtable.
	 *
     * @notice - Should never be used because it also removes the possibility for stakers to withdraw claimable amounts (rather just deactivate the minter)
     *         - But if something went wrong at creating and no stakers are there, it possibly is a helpful function
	 *         - Also can be used if there is an old staking contract which is not used anymore
	 *
     * @param newLpAddr address of the old pair token (UniV2/V1)
     * @param oldLpAddr address of the new pair token (UniV2/V1)
     * @param owner_ address of the set owner of the contract
     * @return stakingContract address of the new staking contract
     */
    function changeStaking(address newLpAddr, address oldLpAddr, address owner_) external onlyOwner returns (address stakingContract) {
        myShare.removeMinter(pool[oldLpAddr]);
        _deleteStaking(oldLpAddr);

        stakingContract = _createStaking(newLpAddr, owner_);
    }

    /**
     * Creates a new staking pool.
     */
    function _createStaking(address lpAddr, address owner_) internal returns (address stakingContract) {
        MyStaking newPool = new MyStaking(address(myShare), lpAddr, owner_);

        address newPoolAddr = address(newPool);

        pool[lpAddr] = newPoolAddr;
        myShare.addMinter(newPoolAddr);
        stakingContract = newPoolAddr;
    }

    /**
     * Deletes a pool from the pool hashtable.
	 *
     * @param lpAddr address of the old pair token (UniV2/V1)
     */
    function _deleteStaking(address lpAddr) internal {
        pool[lpAddr] = address(0);
    }

    /**
     * Adds a minter.
	 *
     * @param newMinter address of the new minter (should be a staking contract)
     */
    function addMinter(address newMinter) external onlyOwner {
        myShare.addMinter(newMinter);
    }

    /**
     * Removing a minter.
	 *
     * @notice - If a minter is removed, it is losing the possibility to mint and every unminted emission
     *         - If it should not lose unminted emission (old staking pool which has stakers), deactivate the minter and remove it after all stakers left
	 *
     * @param toRemove address of the minter
     */
    function removeMinter(address toRemove) external onlyOwner {
        myShare.removeMinter(toRemove);
    }

    /**
     * Withdraws ERC20 tokens from the contract.
	 * This contract should not be the owner of any other token.
	 *
     * @param tokenAddr address of the IERC20 token
     * @param to address of the recipient
     */
    function withdrawERC(address tokenAddr, address to) external onlyOwner {
        IERC20(tokenAddr).safeTransfer(to, IERC20(tokenAddr).balanceOf(address(this)));
    }

    /**
     * Gives the owner the possibility to withdraw ETH which are airdroped or send by mistake to this contract.
	 *
     * @param to recipient of the tokens
     */
    function daoWithdrawETH(address to) external onlyOwner {
        (bool sent,) = to.call{value: address(this).balance}("");
		
        require(sent, "Failed to send ETH");
    }

}


// File: contracts/wrapper/MyWrapper.sol
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0 <=0.8.6;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import "../interfaces/ICheckDec.sol";
import "../interfaces/IFactory.sol";
import "../interfaces/IRouterV2.sol";

import "../token/MyToken.sol";
import "../utils/FeeReducer.sol";


/**
 * @title The magical MyWrapper contract.
 * @author int(200/0), slidingpanda
 */
contract MyWrapper is Ownable, ReentrancyGuard {
    event Deposit(address account, uint256 amount);
    event Withdraw(address account, uint256 amount);
    event AddedLiquidity(address LiquidityToken);

    using SafeERC20 for IERC20;

    IERC20 public pegToken;
    MyToken public myToken;

    address public myShareToken;
    address public stakingFactory;

    // bsc mainnet
    address public constant ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
    address public constant FACTORY = 0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73;
    address public constant WETH = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;

    // bsc testnet
    // address constant public ROUTER = 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3;
    // address constant public FACTORY = 0xB7926C0430Afb07AA7DEfDE6DA862aE0Bde767bc;
    // address constant public WETH = 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd;

    FeeReducer public feeReducer;

    bool public isActive;

    mapping(address => bool) public isWhitelisted;

    /**
     * Sets the contract owner and the myToken:Token relation.
	 *
     * @param pegTokenAddr address of the ERC20 token
     * @param myShareTokenAddr address of the myShare Token
     * @param daoWallet_ address of the DAO wallet for the myToken
     * @param myName name of the created myToken
     * @param mySymbol symbol of the created myToken
     * @param owner_ owner of the created myToken
     * @param feeReducerAddr address of the feeReducer
     * @param stakingFactoryAddr address of the stakingFactory
     */
    constructor(
        address pegTokenAddr,
        address myShareTokenAddr,
        address daoWallet_,
        string memory myName,
        string memory mySymbol,
        address owner_,
        address feeReducerAddr,
        address stakingFactoryAddr
    ) public {
        uint8 decimals = CheckDec(pegTokenAddr).decimals();
        myToken = new MyToken(myName, mySymbol, decimals, pegTokenAddr, daoWallet_, myShareTokenAddr);
        myToken.transferOwnership(owner_);
        transferOwnership(owner_);

        myShareToken = myShareTokenAddr;

        pegToken = IERC20(pegTokenAddr);
        feeReducer = FeeReducer(feeReducerAddr);
        stakingFactory = stakingFactoryAddr;
    }

    /**
     * Connects the feeReducer contract with the myWrapper contract.
	 *
     * @notice - When changing the feeReducer contract, it is necessary that the new one has the states of the old one
     *         - Otherwise the user will lose the reduction
	 *
     * @param newAddr address of the new feeReducer contract
     */
    function setFeeReducer(address newAddr) external onlyOwner {
        feeReducer = FeeReducer(newAddr);
    }

    /**
     * Changes the address of the stakingFactory.
	 *
     * @param newAddr address of the new stakingFactory contract
     */
    function setFactory(address newAddr) external onlyOwner {
        stakingFactory = newAddr;
    }

    /**
     * Returns the myToken address.
	 *
     * @return address myToken address
     */
    function myTokenAddr() public view returns (address) {
        return address(myToken);
    }

    /**
     * Whitelists an address for minting.
	 *
     * @param inAddr address
     * @param toSet determines if address should be whitelisted
     */
    function setWhitelist(address inAddr, bool toSet) external onlyOwner {
        isWhitelisted[inAddr] = toSet;
    }

    /**
     * Toggles the possibility to buy over the wrapper.
	 *
     * @return bool isActive after the toggle
     */
    function toggleActivity() external onlyOwner returns (bool) {
        isActive = !isActive;
        return isActive;
    }

    /**
     * Mints new myTokens with the sent ERC20 tokens.
	 *
     * @param tokenAmount buy amount
     * @return bool 'true' if not reverted
     */
    function deposit(uint256 tokenAmount) external nonReentrant returns (bool) {
        require(isWhitelisted[msg.sender] == true, "Only whitelisted addresses can mint myXXX");
        require(isActive == true, "The deposit function is not activated");
        require(address(pegToken) != WETH, "Please use the depositETH() function");

        IERC20(pegToken).safeTransferFrom(msg.sender, address(this), tokenAmount);

        myToken.mint(msg.sender, tokenAmount);
        emit Deposit(msg.sender, tokenAmount);

        return true;
    }

    /**
     * Mints new myTokens for the sent native tokens.
	 *
     * @return bool 'true' if not reverted
     */
    function depositETH() external payable nonReentrant returns (bool) {
        require(isWhitelisted[msg.sender] == true, "Only whitelisted addresses can mint myXXX");
        require(isActive == true, "The deposit function is not activated");
        require(address(pegToken) == WETH, "Please use the deposit() function");

        myToken.mint(msg.sender, msg.value);
        emit Deposit(msg.sender, msg.value);

        return true;
    }

    /**
     * Burns myTokens and sends the corresponding ERC20 or native tokens.
	 *
     * @notice - Addresses which are not reduced in any way will have a fee of 1%
     *         - Addresses which are holding myShare tokens will have a fee of 0.5%
     *         - Users of the feeReducer will have a fee of 0.1%
     *         - Whitelisted addresses can withdraw without any fees
     *         - The fees are added completely to the feeReserve of the myToken
	 *
     * @param tokenAmount withdraw amount
	 * @return bool 'true' if not reverted
     */
    function withdraw(uint256 tokenAmount) external nonReentrant returns (bool) {
        require(myToken.totalSupply() >= tokenAmount, "Amount exceeds myWrapper balance");

        uint256 fee = tokenAmount / 100;
        (, uint256 feeMulti) = userFee(msg.sender);

        feeMulti = isWhitelisted[msg.sender] ? 0 : feeMulti;
        fee = (fee * feeMulti) / 10;

        uint256 afterFee = tokenAmount - fee;

        if (fee > 0) {
            myToken.fountainWrapper(fee, msg.sender);
        }

        myToken.burn(msg.sender, afterFee);

        if (address(pegToken) == WETH) {
            require(address(this).balance >= tokenAmount, "Too few pegged tokens locked");

            (bool sent,) = msg.sender.call{value: afterFee}("");
		
            require(sent, "Failed to send ETH");
        } else {
            require(pegToken.balanceOf(address(this)) >= tokenAmount, "Too few pegged tokens locked");

            IERC20(pegToken).safeTransfer(msg.sender, afterFee);
        }

        emit Withdraw(msg.sender, afterFee);

        return true;
    }

    /**
     * Returns the possible fee multiplicators.
	 *
     * @notice The calculation: "amount * feeMultiX / 10" and feeMultiX can be resolved like this:
	 *			- Wrapper withdraw / LP zap in (base 1%):
     *				Holding     50% fees
     *				FeeReducer  10% fees
     *			- myToken transaction:
     *				Holding     90% fees
     *				FeeReducer  50% fees
	 *
     * @param user address which is checked
     * @return feeMultiToken fee multiplier for the myToken
     * @return feeMultiWrapper fee multiplier for withdrawing
     */
    function userFee(address user) public view returns (uint256 feeMultiToken, uint256 feeMultiWrapper) {
        (feeMultiToken, feeMultiWrapper) = feeReducer.feeMultiplier(user);
    }

    /**
     * Checks which type of liquidity is meant to be added: Only non-native tokens are possible while the pegToken can be the native token, but not the pair token.
	 *
     * @notice - Only the owner() can add "new" liquidity for the first time
     *         - Otherwise users could compromise the sync array length
     *         - To add native tokens the amountB needs to be zero because the message value is taken instead
	 *
     * @param token pair token (not the pegged token or the myToken)
     * @param amountA pair token amount (not the pegged token or the myToken)
     * @param amountB myToken amount and/or pegToken
     * @param slippage in thousandths (1/1000)
     * @return lpTokenAddr address of the lp token
     */
    function addERCLiq(address token, uint256 amountA, uint256 amountB, uint256 slippage) external payable nonReentrant returns (address lpTokenAddr) {
        require(token != WETH, "Please use addETHLiq()");

        address liqPair = IFactory(FACTORY).getPair(token, myTokenAddr());

        if (address(pegToken) == WETH) {
            amountB = msg.value;
        } else {
            require(msg.value == 0, "Do not send ETH if not needed");
        }

        if (liqPair != address(0) && myToken.isLP(liqPair) == true) {
            lpTokenAddr = _addERCLiq(token, amountA, amountB, slippage);

            emit AddedLiquidity(lpTokenAddr);
        } else if (liqPair == address(0)) {
            require(msg.sender == owner(), "Only DAO can add new LPs");

            lpTokenAddr = _addERCLiq(token, amountA, amountB, slippage);
            myToken.addSyncAddr(lpTokenAddr);
            
            emit AddedLiquidity(lpTokenAddr);
        } else if (myToken.isLP(liqPair) == false) {
            require(msg.sender == owner(), "Only DAO can add LPs to sync");

            lpTokenAddr = _addERCLiq(token, amountA, amountB, slippage);
            myToken.addSyncAddr(lpTokenAddr);

            emit AddedLiquidity(lpTokenAddr);
        }
    }

    /**
     * Adds a sync address to the myToken.
	 *
     * @notice - Is also called if the owner creates a new lp token or if the LP already exists, but it is not set so far from addERCLiq/addETHLiq
     *         - Pools need to be synced from reflows
	 *
     * @param newLp lp token to add to the sync array
     */
    function addSync(address newLp) external onlyOwner {
        myToken.addSyncAddr(newLp);
    }

    /**
     * Adds liquidity for a myToken to pancake swap.
	 *
     * @notice - Only the owner() can add "new" liquidity for the first time
     *         - Otherwise users could compromise the sync array length
     *         - To add native tokens the amountB needs to be zero because the message value is taken instead
	 *
     * @param token pair token (not the pegged token or the myToken)
     * @param amountA pair token amount (not the pegged token or the myToken)
     * @param amountB myToken amount and/or pegToken
     * @param slippage in thousandths (1/1000)
     * @return lpTokenAddr address of the lp token
     */
    function _addERCLiq(address token, uint256 amountA, uint256 amountB, uint256 slippage) internal returns (address lpTokenAddr) {
        if (address(pegToken) != WETH) {
            pegToken.safeTransferFrom(msg.sender, address(this), amountB);
        }
		
        IERC20(token).safeTransferFrom(msg.sender, address(this), amountA);
        myToken.mint(address(this), amountB);

        IERC20(token).approve(ROUTER, amountA);
        myToken.approve(ROUTER, amountB);

        uint256 minAmountA = amountA - ((amountA * slippage) / 1000);
        uint256 minAmountB = amountB - ((amountB * slippage) / 1000);

        (
            uint256 addedAmountA,
            uint256 addedAmountB,
            uint256 lpAmount
        ) = IRouterV2(ROUTER).addLiquidity(
                token,
                address(myToken),
                amountA,
                amountB,
                minAmountA,
                minAmountB,
                address(this),
                block.timestamp
            );

        if (amountA > addedAmountA) {
            uint256 sendBackA = amountA - addedAmountA;
            IERC20(token).safeTransfer(msg.sender, sendBackA);
        }

        if (amountB > addedAmountB) {
            uint256 sendBackB = amountB - addedAmountB;
            myToken.burn(address(this), sendBackB);

            if (address(pegToken) != WETH) {
                pegToken.safeTransfer(msg.sender, sendBackB);
            } else {
                (bool sent,) = msg.sender.call{value: sendBackB}("");
		
                require(sent, "Failed to send ETH");
            }
        }

        uint256 fee = lpAmount / 100;
        (, uint256 feeMulti) = userFee(msg.sender);

        fee = (fee * feeMulti) / 10;
        uint256 afterFee = lpAmount - fee;

        lpTokenAddr = IFactory(FACTORY).getPair(token, myTokenAddr());

        IERC20(lpTokenAddr).safeTransfer(msg.sender, afterFee);
        IERC20(lpTokenAddr).safeTransfer(address(1), fee);
    }

    /**
     * Checks which type of liquidity is meant to be added: Only non-native tokens are possible while the pegToken can be the native token, but not the pair token.
	 *
     * @notice - Only the owner() can add "new" liquidity for the first time
     *         - Otherwise users could compromise the sync array length
     *         - To add native tokens the amountB needs to be zero because the message value is taken instead
	 *
     * @param amountA pair token amount (not the pegged token or the myToken)
     * @param amountB myToken amount and/or pegToken
     * @param slippage in thousandths (1/1000)
     * @return lpTokenAddr address of the lp token
     */
    function addETHLiq(uint256 amountA, uint256 amountB, uint256 slippage) external payable nonReentrant returns (address lpTokenAddr) {
        require(msg.value > 0, "Sending ETH it is needed");

        address liqPair = IFactory(FACTORY).getPair(WETH, myTokenAddr());

        if (address(pegToken) == WETH) {
            amountA = msg.value / 2;
            amountB = msg.value - amountA;
        } else {
            require(amountB != 0, "PegToken amount should be > 0");

            amountA = msg.value;
        }

        if (liqPair != address(0) && myToken.isLP(liqPair) == true) {
            lpTokenAddr = _addETHLiq(amountA, amountB, slippage);

            emit AddedLiquidity(lpTokenAddr);
        } else if (liqPair == address(0)) {
            require(msg.sender == owner(), "Only DAO can add new LPs");

            lpTokenAddr = _addETHLiq(amountA, amountB, slippage);
            myToken.addSyncAddr(lpTokenAddr);

            emit AddedLiquidity(lpTokenAddr);
        } else if (myToken.isLP(liqPair) == false) {
            require(msg.sender == owner(), "Only DAO can add LPs to sync");

            lpTokenAddr = _addETHLiq(amountA, amountB, slippage);
            myToken.addSyncAddr(lpTokenAddr);

            emit AddedLiquidity(lpTokenAddr);
        }
    }

    /**
     * Adds liquidity for a myToken to pancake swap.
	 *
     * @notice - Only the owner() can add "new" liquidity for the first time
     *         - Otherwise users could compromise the sync array length
     *         - To add native tokens the amountB needs to be zero because the message value is taken instead
	 *
     * @param amountA pair token amount (not the pegged token or the myToken)
     * @param amountB myToken amount and/or pegToken
     * @param slippage in thousandths (1/1000)
     * @return lpTokenAddr address of the lp token
     */
    function _addETHLiq(uint256 amountA, uint256 amountB, uint256 slippage) internal returns (address lpTokenAddr) {
        if (address(pegToken) != WETH) {
            pegToken.safeTransferFrom(msg.sender, address(this), amountB);
        }

        myToken.mint(address(this), amountB);
        myToken.approve(ROUTER, amountB);

        uint256 minAmountA = amountA - ((amountA * slippage) / 1000);
        uint256 minAmountB = amountB - ((amountB * slippage) / 1000);

        (
            uint256 addedTENAmount,
            uint256 addedETHAmount,
            uint256 lpAmount
        ) = IRouterV2(ROUTER).addLiquidityETH{value: amountA}(
                address(myToken),
                amountB,
                minAmountA,
                minAmountB,
                address(this),
                block.timestamp
            );

        uint256 wethBack;
        if (amountA > addedETHAmount) {
            wethBack = amountA - addedETHAmount;
        }

        if (amountB > addedTENAmount) {
            uint256 sendBackB = amountB - addedTENAmount;
            myToken.burn(address(this), sendBackB);

            if (address(pegToken) == WETH) {
                wethBack += sendBackB;
            } else {
                pegToken.safeTransfer(msg.sender, sendBackB);
            }
        }

        if (wethBack > 0) {
            (bool sent,) = msg.sender.call{value: wethBack}("");
		
            require(sent, "Failed to send ETH");
        }

        uint256 fee = lpAmount / 100;
        (, uint256 feeMulti) = userFee(msg.sender);

        fee = (fee * feeMulti) / 10;

        uint256 afterFee = lpAmount - fee;
        lpTokenAddr = IFactory(FACTORY).getPair(WETH, myTokenAddr());

        IERC20(lpTokenAddr).safeTransfer(msg.sender, afterFee);
        IERC20(lpTokenAddr).safeTransfer(address(1), fee);
    }

    /**
     * Calls the reduced method of the feeReducer except if the address is an LP of the myToken.
	 * Otherwise someone could send myShare tokens to the LP and reduce the fee for everyone who is swapping with the LP.
	 *
     * @param user address which is checked
     * @return reduced 'true' if checking is reduced
     */
    function isReduced(address user) public view returns (bool reduced) {
        if (myToken.isLP(user) == false) {
            reduced = feeReducer.isReduced(user);
        }
    }

    /**
     * Makes it possible to change the wrapper and transfer the pegToken amount to the new contract.
	 *
     * @notice The new wrapper needs to be set on the myToken first for having a small barrier against malicious/wrong useage.
	 *
     * @param newWrapper address which is checked
     */
    function changeWrapper(address newWrapper) external onlyOwner {
        require(myToken.wrapper() == newWrapper, "The new wrapper needs to be set on the myToken first");

        if (address(pegToken) == WETH) {
            (bool sent,) = newWrapper.call{value: address(this).balance}("");
		
            require(sent, "Failed to send ETH");
        } else {
            IERC20(pegToken).safeTransfer(newWrapper, pegToken.balanceOf(address(this)));
        }
    }

    /**
     * Gives the owner the possibility to withdraw tokens which are airdroped or send by mistake to this contract, except the staked tokens.
     *
     * @notice - This contract uses native tokens, so it is possible to withdraw the wrapped version of it (not myToken version)
	 *
     * @param to recipient of the tokens
     * @param tokenAddr token contract
     */
    function daoWithdrawERC(address to, address tokenAddr) external onlyOwner {
        require((   address(pegToken) == tokenAddr && tokenAddr == WETH) ||
                    address(pegToken) != tokenAddr,
                    "You cannot withdraw the staked tokens");

        IERC20(tokenAddr).safeTransfer(to, IERC20(tokenAddr).balanceOf(address(this)));
    }

    /**
     * Gives the owner the possibility to withdraw ETH which are airdroped or send by mistake to this contract.
     *
     * @param to recipient of the tokens
     */
    function daoWithdrawETH(address to) external onlyOwner {
        require(address(pegToken) != WETH, "You cannot withdraw the staked tokens");
        (bool sent,) = to.call{value: address(this).balance}("");
		
        require(sent, "Failed to send ETH");
    }

    /**
     * Receives native token.
     */
    receive() external payable {
        // ...
    }
}
