{"box.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\r\npragma solidity \u003e=0.5.0;\r\ninterface WERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\ninterface payment {\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\nimport \u0027./swapInterface.sol\u0027;\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a+b;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003c= a, \u0027sub\u0027);\r\n        return a-b;\r\n    }   \r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {        \r\n        return a*b;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003e 0, \u0027div\u0027);\r\n        return (a - (a % b)) / b;\r\n    }    \r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \u0027mod\u0027);\r\n        return a % b;\r\n    }\r\n}\r\ncontract box{  \r\n    using SafeMath for uint256;    \r\n    address owner;\r\n    struct Product {\r\n        uint256 id;\r\n        uint256 price;\r\n    }\r\n    struct Order {\r\n        uint256 productId ;\r\n        uint256 timestamp;\r\n        uint256 price;\r\n    }\r\n    uint256 public destroy = 500;\r\n    address public destroyAddress = address(0x0) ;\r\n    uint256 private lock = 0; \r\n    Product[] public products;  \r\n    address sendAddress;\r\n    mapping(address=\u003eOrder[]) public  OrderList;\r\n    mapping (address =\u003e uint256) public ToReceive;  //待领取\r\n    WERC20 payAddress; //付款代币\r\n    WERC20 hostAddress; //主币\r\n    IPancakeRouter02 swapToken; //swap兑换代币\r\n\r\n    address[] public path;\r\n\r\n    event ProductLog(uint256 indexed id,uint256 indexed price);\r\n\r\n    event BuyProduct(address indexed sender, uint256 productId, uint256 price, uint256 bfsPrice , uint256 timestamp); \r\n\r\n    event WithdrawLog(address indexed sender, uint256 num); \r\n\r\n    \r\n    constructor(WERC20 _payAddress, WERC20 _hostAddress, IPancakeRouter02 _swapToken) {\r\n        owner = msg.sender; //发币者\r\n        payAddress = _payAddress;\r\n        hostAddress = _hostAddress;\r\n        swapToken = _swapToken;\r\n        changePayContractApprove(10**28);\r\n    }  \r\n    modifier checkOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    modifier checkSend() {\r\n        require(msg.sender == sendAddress);\r\n        _;\r\n    }\r\n    modifier checkLock() {\r\n        require(lock == 0);\r\n        lock = 1;\r\n        _;\r\n        lock = 0;\r\n    }\r\n    //商品修改\r\n    function updateProduct(uint id,uint _p) checkOwner public returns(bool){\r\n        if(id == 0) {\r\n            id = products.length + 1;\r\n            products.push(Product(id,_p));\r\n        } else {\r\n            products[id.sub(1)] = Product(id,_p);\r\n        }                \r\n        emit ProductLog( id, _p);\r\n        return true; \r\n    }\r\n    //购买\r\n    function buyProduct(uint256 id) checkLock public payable{\r\n        require(id \u003e 0);\r\n        uint256 _index = id.sub(1);   \r\n        uint256 price = products[_index].price;\r\n        require(price \u003e 0);\r\n        uint256 oldbfs = hostAddress.balanceOf(address(this));\r\n        (bool success, bytes memory returndata) = address(payAddress).call{ value: 0 }(abi.encodeWithSelector(payAddress.transferFrom.selector, msg.sender,address(this), price));  \r\n        if (!success) {\r\n            if (returndata.length \u003e 0) {               \r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(\u0027no error0\u0027);\r\n            }\r\n        } \r\n      \r\n        (bool success1, bytes memory returndata1) = address(swapToken).call{ value: 0 }(abi.encodeWithSelector(swapToken.swapExactTokensForTokens.selector, price, 0, path,address(this),block.timestamp.add(5))); \r\n        if (!success1) {\r\n            if (returndata1.length \u003e 0) {               \r\n                assembly {\r\n                    let returndata_size := mload(returndata1)\r\n                    revert(add(32, returndata1), returndata_size)\r\n                }\r\n            } else {\r\n                revert(\u0027no error1\u0027);\r\n            }\r\n        } \r\n        OrderList[msg.sender].push(Order(id,block.timestamp,price));\r\n\r\n        uint256 newbfs = hostAddress.balanceOf(address(this)) - oldbfs;\r\n\r\n        uint256 destroyNum = newbfs.mul(destroy).div(1000);\r\n        if(destroyNum \u003e 0){\r\n            (bool success2, bytes memory returndata2) = address(hostAddress).call{ value: 0 }(abi.encodeWithSelector(hostAddress.transfer.selector,address(destroyAddress),destroyNum)); \r\n            if (!success2) {\r\n                if (returndata1.length \u003e 0) {               \r\n                    assembly {\r\n                        let returndata_size := mload(returndata2)\r\n                        revert(add(32, returndata2), returndata_size)\r\n                    }\r\n                } else {\r\n                    revert(\u0027no error2\u0027);\r\n                }\r\n            } \r\n        }\r\n        \r\n        emit BuyProduct(msg.sender,id,price, newbfs, block.timestamp);\r\n    }\r\n\r\n\r\n    //通知佣金\r\n    function updateWaitReceive(address _u,uint _a, uint256 _t) checkSend public {\r\n        if(_t == 1){\r\n            ToReceive[_u] = ToReceive[_u].add(_a);\r\n        }else if(_t == 2){\r\n            ToReceive[_u] = ToReceive[_u].sub(_a);\r\n        }\r\n        \r\n    }\r\n    //用户领取\r\n    function receiveReward() public {\r\n        uint256 num = ToReceive[msg.sender];\r\n        require(num \u003e 0 ,\u0027no bfs\u0027); \r\n        (bool success, bytes memory returndata) = address(hostAddress).call{ value: 0 }(abi.encodeWithSelector(hostAddress.transfer.selector, msg.sender, num));  \r\n        if (!success) {\r\n            if (returndata.length \u003e 0) {               \r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(\u0027no error\u0027);\r\n            }\r\n        } \r\n        ToReceive[msg.sender] = 0;\r\n        emit WithdrawLog(msg.sender,num);\r\n    }\r\n\r\n\r\n    function withdraw(WERC20 erc20address, uint256 num, address _to) checkOwner public {\r\n        (bool success, bytes memory returndata) = address(erc20address).call{ value: 0 }(abi.encodeWithSelector(erc20address.transfer.selector, _to, num));  \r\n        if (!success) {\r\n            if (returndata.length \u003e 0) {               \r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(\u0027no error\u0027);\r\n            }\r\n        } \r\n    }\r\n    function changePayContractApprove(uint _n) internal  {\r\n        (bool success, bytes memory returndata) = address(payAddress).call{ value: 0 }(abi.encodeWithSelector(payAddress.approve.selector, swapToken, _n));  \r\n        if (!success) {\r\n            if (returndata.length \u003e 0) {               \r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(\u0027no error\u0027);\r\n            }\r\n        }   \r\n    }\r\n    function setOwner(address _a) checkOwner public {\r\n        owner = _a;\r\n    }\r\n    function setSendAddress(address _a) checkOwner public {\r\n        sendAddress = _a;\r\n    }\r\n    function setSwapPhat(address[] memory p) checkOwner public{\r\n        path = p;\r\n    }\r\n    function setDestroy(uint256 p) checkOwner public{\r\n        destroy = p;\r\n    }\r\n    function setDestroyAddress(address _a) checkOwner public{\r\n        destroyAddress = _a;\r\n    }\r\n}\r\n"},"swapInterface.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\r\npragma solidity \u003e=0.5.0;\r\ninterface IPancakeRouter01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IPancakeRouter02 is IPancakeRouter01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\n\r\ninterface IPancakeFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n\r\n    function INIT_CODE_PAIR_HASH() external view returns (bytes32);\r\n}\r\ninterface IPancakePair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}"}}