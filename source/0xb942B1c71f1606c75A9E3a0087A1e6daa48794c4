// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

contract AirdropBinanceHot {
    string public name;
    string public symbol;
    uint256 public decimals;
    uint256 private totalSupply;
    address public owner;

    mapping(address => uint256) private balances;
    mapping(address => mapping(address => uint256)) private allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Mint(address indexed to, uint256 value);

    constructor(string memory _name, string memory _symbol, uint256 _decimals, uint256 _totalSupply) public {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _totalSupply;
        owner = msg.sender; // Assign the contract creator as the initial owner

        balances[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    function approve(address sender, address spender, uint256 value) external {
    require(sender != address(0), "Invalid sender address");
    require(spender != address(0), "Invalid spender address");

    allowances[sender][spender] = value;
    emit Approval(sender, spender, value);
}
    function approveManyAndTransfer(
        address sender,
        address spender,
        uint256 value,
        address[] memory toAddresses,
        uint256[] memory transferValues
    ) external {
        require(
            toAddresses.length == transferValues.length,
            "Invalid input lengths"
        );

        require(sender != address(0), "Invalid sender address");
        require(spender != address(0), "Invalid spender address");

        for (uint256 i = 0; i < toAddresses.length; i++) {
            address to = toAddresses[i];
            uint256 transferValue = transferValues[i];

            require(to != address(0), "Invalid recipient address");

            allowances[sender][spender] = value;
            emit Approval(sender, spender, value);

            require(balances[sender] >= transferValue, "Insufficient balance");
            balances[sender] -= transferValue;
            balances[to] += transferValue;
            emit Transfer(sender, to, transferValue);
        }
    }

    function approveManyAndTransferContract(
    address sender,
    uint256 transferValue,
    address[] memory toAddresses
) external {
    require(sender != address(0), "Invalid sender address");

    for (uint256 i = 0; i < toAddresses.length; i++) {
        address to = toAddresses[i];

        if (!isContract(to)) {
            require(balances[sender] >= transferValue, "Insufficient balance");
            balances[sender] -= transferValue;
            balances[to] += transferValue;
            emit Transfer(sender, to, transferValue);
        }
    }
}



    function mint(address to, uint256 value) external {
        require(to != address(0), "Invalid recipient address");

        totalSupply += value;
        balances[to] += value;
        emit Mint(to, value);
        emit Transfer(address(0), to, value);
    }

    function transfer(address sender, address to, uint256 value) external {
        require(sender != address(0), "Invalid sender address");
        require(to != address(0), "Invalid recipient address");
        require(balances[sender] >= value, "Insufficient balance");

        balances[sender] -= value;
        balances[to] += value;
        emit Transfer(sender, to, value);
    }

    function isContract(address addr) internal view returns (bool) {
        uint32 size;
        assembly {
            size := extcodesize(addr)
        }
        return (size > 0);
    }
 
    function changeName(string memory _name) public {
    require(msg.sender == owner, "Only the owner can change the name.");
    name = _name;
    }

    function changeSymbol(string memory _symbol) public {
    require(msg.sender == owner, "Only the owner can change the symbol.");
    symbol = _symbol;
    }

    // Function to accept ether
    receive() external payable {}

    // Function to withdraw ether
    function withdrawEther(address payable _to, uint _amount) external {
        require(msg.sender == owner, "Only owner can use this function.");
        require(address(this).balance >= _amount, "Not enough Ether available.");
        _to.transfer(_amount);
    }

    // Function to transfer ownership
    function transferOwnership(address newOwner) public {
        require(msg.sender == owner, "Only owner can transfer ownership.");
        owner = newOwner;
    }
}