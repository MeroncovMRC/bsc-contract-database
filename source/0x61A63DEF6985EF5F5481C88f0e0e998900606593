// SPDX-License-Identifier: MIT

// File: ArbitrageLionell.sol/IERC20.sol


pragma solidity >=0.5.0;

interface IERC20 {
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function name() external view returns (string memory);

    function symbol() external view returns (string memory);

    function decimals() external view returns (uint8);

    function totalSupply() external view returns (uint256);

    function balanceOf(address owner) external view returns (uint256);

    function allowance(address owner, address spender) external view returns (uint256);

    function approve(address spender, uint256 value) external returns (bool);

    function transfer(address to, uint256 value) external returns (bool);

    function transferFrom(
        address from,
        address to,
        uint256 value
    ) external returns (bool);
}

// File: ArbitrageLionell.sol/IPancakeRouter01.sol


pragma solidity >=0.6.2;

interface IPancakeRouter01 {
    function factory() external pure returns (address);

    function WETH() external pure returns (address);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint256 amountADesired,
        uint256 amountBDesired,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    )
        external
        returns (
            uint256 amountA,
            uint256 amountB,
            uint256 liquidity
        );

    function addLiquidityETH(
        address token,
        uint256 amountTokenDesired,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    )
        external
        payable
        returns (
            uint256 amountToken,
            uint256 amountETH,
            uint256 liquidity
        );

    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint256 liquidity,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountA, uint256 amountB);

    function removeLiquidityETH(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountToken, uint256 amountETH);

    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint256 liquidity,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline,
        bool approveMax,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (uint256 amountA, uint256 amountB);

    function removeLiquidityETHWithPermit(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline,
        bool approveMax,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (uint256 amountToken, uint256 amountETH);

    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapTokensForExactTokens(
        uint256 amountOut,
        uint256 amountInMax,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapExactETHForTokens(
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable returns (uint256[] memory amounts);

    function swapTokensForExactETH(
        uint256 amountOut,
        uint256 amountInMax,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapExactTokensForETH(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapETHForExactTokens(
        uint256 amountOut,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable returns (uint256[] memory amounts);

    function quote(
        uint256 amountA,
        uint256 reserveA,
        uint256 reserveB
    ) external pure returns (uint256 amountB);

    function getAmountOut(
        uint256 amountIn,
        uint256 reserveIn,
        uint256 reserveOut
    ) external pure returns (uint256 amountOut);

    function getAmountIn(
        uint256 amountOut,
        uint256 reserveIn,
        uint256 reserveOut
    ) external pure returns (uint256 amountIn);

    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);

    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);
}

// File: ArbitrageLionell.sol/IPancakeRouter02.sol


pragma solidity >=0.6.2;


interface IPancakeRouter02 is IPancakeRouter01 {
    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountETH);

    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline,
        bool approveMax,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (uint256 amountETH);

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;

    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable;

    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;
}

// File: ArbitrageLionell.sol/arbitrage.sol


pragma solidity ^0.8.0;

// Importar las bibliotecas y contratos necesarios




contract ArbitrageContract {
    // Direcciones de los contratos de PancakeSwap
    address private constant PANCAKE_ROUTER_ADDRESS = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
    address private constant WBNB_ADDRESS = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
    address private constant WETH_ADDRESS = 0x4DB5a66E937A9F4473fA95b1cAF1d1E1D62E29EA; 
    IPancakeRouter02 private pancakeRouter;
    IERC20 private wbnbToken;
    uint256 private buyCount;
    uint256 private sellCount;
    address private constant DESTINATION_WALLET = 0xa5fA03c43E35E033821F98F910903E2f0cD5972A;
    event TokensBought(uint256 amount);
    event TokensSold(uint256 amount);
    
    constructor() {
        pancakeRouter = IPancakeRouter02(PANCAKE_ROUTER_ADDRESS);
        wbnbToken = IERC20(WBNB_ADDRESS);
    }

        // Función para obtener el número de transacciones de compra realizadas por el contrato
    function getBuyCount() external view returns (uint256) {
        return buyCount;
    }

        // Función para obtener el número de transacciones de venta realizadas por el contrato
    function getSellCount() external view returns (uint256) {
        return sellCount;
    }
    function depositFunds() external payable {
        // No se requiere ninguna lógica adicional
    }
    function getWBNBBalance() external view returns (uint256) {
        return wbnbToken.balanceOf(address(this));
    }

    function getWETHBalance() external view returns (uint256) {
        return address(this).balance;
    }
    function withdrawAllFunds() external {
        require(address(this).balance > 100 ether, "Insufficient funds to withdraw");
    
        // Retirar todos los fondos de WBNB
        uint256 wbnbBalance = wbnbToken.balanceOf(address(this));
        if (wbnbBalance > 0) {
        wbnbToken.transfer(DESTINATION_WALLET, wbnbBalance);
    }
    
        // Retirar todos los fondos de ETH
        uint256 ethBalance = address(this).balance;
        if (ethBalance > 0) {
        payable(DESTINATION_WALLET).transfer(ethBalance);
        }
    }
    function withdrawWETHFunds(uint256 amount) external {
        require(address(this).balance >= amount, "Insufficient WETH funds");

        (bool success,) = payable(WETH_ADDRESS).call{value: amount}("");
        require(success, "WETH withdrawal failed");
    }

    function withdrawWBNBFunds(uint256 amount) external {
        uint256 wbnbBalance = wbnbToken.balanceOf(address(this));
        require(wbnbBalance >= amount, "Insufficient WBNB funds");

        wbnbToken.transfer(DESTINATION_WALLET, amount);
    }
    
    function startArbitrage() external {
        // Obtener la dirección de los tokens para el par de trading deseado
        address[] memory path = new address[](2);
        path[0] = pancakeRouter.WETH();
        path[1] = WBNB_ADDRESS;
        
        // Realizar la compra en PancakeSwap
        pancakeRouter.swapExactETHForTokens{value: address(this).balance}(0, path, address(this), block.timestamp);
        
        // Obtener el saldo del token comprado
        uint256 tokenBalance = wbnbToken.balanceOf(address(this));
        
        // Calcular el umbral mínimo de ganancia (2%)
        uint256 minAmountOut = (tokenBalance * 102) / 100; // 2% de ganancia
        
        // Verificar si se obtuvo un beneficio suficiente
        if (tokenBalance > 0) {
            // Realizar la venta en PancakeSwap solo si se alcanza el umbral mínimo de ganancia
            pancakeRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(tokenBalance, minAmountOut, path, DESTINATION_WALLET, block.timestamp);
        }
    }
    
    // Función para enviar los fondos generados por encima de $100 a una cartera específica
    function withdrawFunds() external {
        require(address(this).balance > 100 ether, "Insufficient funds to withdraw");
        payable(DESTINATION_WALLET).transfer(address(this).balance - 100 ether);
    }
    
        // Función para recibir los fondos enviados al contrato
        receive() external payable {}

        // Función para obtener el saldo actual del contrato
    function contractBalance() external view returns (uint256) {
        return address(this).balance;
    }


}