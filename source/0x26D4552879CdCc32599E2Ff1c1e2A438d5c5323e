// File: node_modules\@openzeppelin\contracts\GSN\Context.sol

pragma solidity >=0.5.0;

/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with GSN meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
contract Context {
    // Empty internal constructor, to prevent people from mistakenly deploying
    // an instance of this contract, which should be used via inheritance.
    constructor () internal { }
    // solhint-disable-previous-line no-empty-blocks

    function _msgSender() internal view returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}

// File: node_modules\@openzeppelin\contracts\token\ERC20\IERC20.sol

pragma solidity >=0.5.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP. Does not include
 * the optional functions; to access them see {ERC20Detailed}.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

// File: node_modules\@openzeppelin\contracts\math\SafeMath.sol

pragma solidity >=0.5.0;

/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     *
     * _Available since v2.4.0._
     */
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     *
     * _Available since v2.4.0._
     */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     *
     * _Available since v2.4.0._
     */
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}

// File: node_modules\@openzeppelin\contracts\token\ERC20\ERC20.sol

pragma solidity >=0.5.0;




/**
 * @dev Implementation of the {IERC20} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 * For a generic mechanism see {ERC20Mintable}.
 *
 * TIP: For a detailed writeup see our guide
 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How
 * to implement supply mechanisms].
 *
 * We have followed general OpenZeppelin guidelines: functions revert instead
 * of returning `false` on failure. This behavior is nonetheless conventional
 * and does not conflict with the expectations of ERC20 applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn't required by the specification.
 *
 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
 * functions have been added to mitigate the well-known issues around setting
 * allowances. See {IERC20-approve}.
 */
contract ERC20 is Context, IERC20 {
    using SafeMath for uint256;

    mapping (address => uint256) private _balances;

    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;

    /**
     * @dev See {IERC20-totalSupply}.
     */
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 amount) public returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20};
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for `sender`'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted
     * from the caller's allowance.
     *
     * See {_burn} and {_approve}.
     */
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "ERC20: burn amount exceeds allowance"));
    }
}

// File: @openzeppelin\contracts\token\ERC20\ERC20Burnable.sol

pragma solidity >=0.5.0;



/**
 * @dev Extension of {ERC20} that allows token holders to destroy both their own
 * tokens and those that they have an allowance for, in a way that can be
 * recognized off-chain (via event analysis).
 */
contract ERC20Burnable is Context, ERC20 {
    /**
     * @dev Destroys `amount` tokens from the caller.
     *
     * See {ERC20-_burn}.
     */
    function burn(uint256 amount) public {
        _burn(_msgSender(), amount);
    }

    /**
     * @dev See {ERC20-_burnFrom}.
     */
    function burnFrom(address account, uint256 amount) public {
        _burnFrom(account, amount);
    }
}

// File: contracts\RCVR_Final.sol

pragma solidity ^0.5.0;

/**
///////////////////////////////

  ____                                _____     _              
 |  _ \ ___  ___ _____   _____ _ __  |_   _|__ | | _____ _ __  
 | |_) / _ \/ __/ _ \ \ / / _ \ '__|   | |/ _ \| |/ / _ \ '_ \ 
 |  _ <  __/ (_| (_) \ V /  __/ |      | | (_) |   <  __/ | | |
 |_| \_\___|\___\___/ \_/ \___|_|      |_|\___/|_|\_\___|_| |_| ver 1.0
                                                               

///////////////////////////////
    ////Recover Token, designed to allow crypto enthusiasts to claim RCVR for scam/rugged coins////
    ////Functions designed to be switched on and off by the owner such as burn percentage/allowance for rewards
    ////Premint of 1 million Tokens at Contract Creation
    ////XX number of Tokens to be locked away if Community wants it and requests it
    ////Safe Return Staking pools which track the current BTC/USD rate (Community Decided////
    ////Riskier Staking pools which are reliant on the price of upcoming coins (Based on Price of RCVR by default)///
    ////The price adjustments will cause the value of rewards to be adjusted and removed. A burn of negeative rebase coins is also available
*/   
////////////////////////////////////////////

    ///Interface to retrieve prices from Price Checkers
interface RCVRPriceFeed {
    function getTokenPrice(address tokenAddress) external view returns (uint);
}
interface ChainlinkPriceFeed {
    function getSafeStakePrice() external view returns (int);
}
   ///////////////////////////////////////////////////
contract RecoverToken is ERC20Burnable{
    constructor() public
        {
        Owner = msg.sender;
       	_mint(Owner, initialSupply);
        burnenabled = false;
        riskytoken = address(this);
        safetoken = address(this);
    }
    using SafeMath for uint;
    
   
    ////////////////////
    uint256 constant private initialSupply = 1000000e18; // 1 Million base supply
    ///////////////////
    //////////////////
    address public Owner;
    uint public safeaccumulatednegetivereabase;
    uint public riskyaccumulatednegetiverebase;
    int public safeoldprice;
    uint256 private riskyoldprice;
    bool public burnenabled;
    string constant public name = "RecoverToken";
    string constant public symbol = "RCVR";
    uint8 constant public decimals = 18;
    uint public safepercentage = 100; // percentage removed/added from safe bet - Default = 1%
    uint public riskypercentage = 100; // percentage removed/added from safe bet - Default = 1%
    uint public riskymultiplier = 1; // Multiplication multiplier for addition/removal of RiskyContract
    uint public forcesafecost = 10000000000000000; //0.01 Eth by default in Wei
    uint public forceriskycost = 20000000000000000; //0.02 Eth in Wei
    uint public safeinterval = 60; //Default interval for safe timer
    uint public riskyinterval = 29; //Default interval for risky timer
    bool public rewarddistribution; ///Enable/Disable Rewards
    bool public safestakingenabled; ///Enable/Disable Safe Staking
    bool public riskystakingenabled; //Enable/Disable Risky Staking
    uint256 public safestakemaxuserlimit = 200;
    uint256 public riskystakemaximumuserlimit = 150;
    bool private lastriskyrebase;
    bool private lastsaferebase;
    bool private usechainlink = true; //Default to use Chainlink for Safe Price Feed
    bool public safetimerenabled;
    bool public riskytimerenabled;
    uint public prevriskyrebase;
    uint public prevsaferebase;
    uint public timergas = 20;
    ///Frictionless staking and minting//////
    bool public frictionless;
    bool public frictionlessmint;
    ///NB Addresses/////////
    address private rcvrpricefeed;
    address private chainlinkfeed;
    address public riskytoken;
    address private migrationcontract;
    address private timeraddress;
    address public safetoken;
    /////////Mappings ///////////////////////
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
    event Transfer(address indexed from, address indexed to, uint tokens);
    event Burn(address indexed from, uint256 value);
    mapping(address => uint256) balances;
    mapping(address => uint256) internal riskyrewards; //Risky Rewards collection
    mapping(address => uint256) internal rewards; //SafeBet Rewards Collection
    mapping(address => uint256) internal stakes; ///Safe Stake Pool
    mapping(address => uint256) internal riskystakes; ///Riksy Stake Pool
    uint256 totalSupply_;
    address[] internal stakeholders; //Dynamic array to keep track of users who are staking RCVR in SafeStakePool
    address[] internal riskystakeholders; //Dynamic array to keep track of users who are staking RCVR in RiskyStakePool
    
    modifier onlyOwner() {
        require(msg.sender == Owner);
        _;
    }
    ///////////////////////////////////////
    //Function to set reward percentages
    function setRewardPercentages(uint pool,uint _rewardpercentage) public onlyOwner{
        if (pool ==1) //Safe pool
        {
            safepercentage = _rewardpercentage;
        }
        if (pool ==2) //Risky percentage
        {
            riskypercentage = _rewardpercentage;
        }
    }
    ///Function to set the allowed address to do rebases
    function setTimerAddress(address _timeraddress) public onlyOwner{
        timeraddress = _timeraddress;
    }
    ///Function to set the gas price to use for the custom timer
    function setGas(uint _gas) public onlyOwner{
        timergas = _gas;
    }
    ///Function to set timer interval
    function setTimerIntervals(uint pool,uint _minutes) public onlyOwner{
        if (pool==1)//Safe pool
        {
            safeinterval = _minutes;
        }
        if (pool==2)//Risky pool
        {
            riskyinterval = _minutes;
        }
    }
    ///Function to enable/disable the timers for each pool
    function onoffTimer(uint _pool,bool _enabled) public onlyOwner{
        if (_pool==1){ ///SafePool
            safetimerenabled = _enabled;
        }
        if (_pool==2) // riskypool
        {
            riskytimerenabled = _enabled;
        }
    }
    ////Function to retrieve last time of a rebase with a "change in"
    function NextRebase(uint pool) public view returns (uint){
        uint temp = 0;
        if (pool==1) // Safe
        {
            temp = prevsaferebase;
        }
        if (pool==2) // Risky
        {
            temp = prevriskyrebase;
        }
        return temp;
    }
    //Function to Set the Migration contract address//
    function setMigrationContractAddress(address _Migration) public onlyOwner{
        migrationcontract = _Migration;
    }
    
    ////Function to burn the accumulated amount of tokens from Negative Rebase/////
    function burnNegativeRebaseTokens(uint pool) public onlyOwner
    {
        require(burnenabled == true, "Burn not enabled");
        if (pool == 1) //Safe pool
        {
            require(address(this).balance > safeaccumulatednegetivereabase,"Burn2large(S)!" ); 
             _burn(address(this),safeaccumulatednegetivereabase);  //Burn the accumulated negative rebase!
             safeaccumulatednegetivereabase = 0;
        }
        if (pool == 2) // Risky pool
        {
            require(address(this).balance  > riskyaccumulatednegetiverebase,"Burn2large(R)!");
            _burn(address(this),riskyaccumulatednegetiverebase);  //Burn the accumulated negative rebase!
            riskyaccumulatednegetiverebase = 0;
        }
        if (pool == 3) //Set values to 0 to ensure they do not grow large via manual housekeeping
        {
            safeaccumulatednegetivereabase = 0;
        }
        if (pool == 4) //Set values to 0 to ensure they do not grow large via manual housekeeping
        {
            riskyaccumulatednegetiverebase = 0;
        }
        
    }
    //////Function to return Current Amount of Tokens to be burned/////
    function getTotalBurnedRebase(uint pool) public view returns(uint)
    {
        uint temp =0;
        if (pool ==1)
        {
            temp = safeaccumulatednegetivereabase; //safe pool
        }
        if (pool ==2)
        {
            temp = riskyaccumulatednegetiverebase; //risky pool
        }
        return temp;
    }
    ////Enable burning of tokens if required/////
    function BurnEnable(bool burntruefalse) public onlyOwner{
        burnenabled = burntruefalse;
    }
    ////High Level Enable/Disable to stop distribution of rewards if needed/////
    function EnableDisableRewards(bool OnOrOff_) public onlyOwner
    {
        rewarddistribution = OnOrOff_;
    }
    ////High Level function to enable each staking pool if required////
    function EnabledDisableStaking(uint pool,bool EnableDisable_) public onlyOwner{
        if (pool ==1) ///safe Pool
        {
            safestakingenabled = EnableDisable_;
        }
        if (pool ==2) //Risky Pool
        {
            riskystakingenabled = EnableDisable_;
        }
    }
    ///Function to set the max user limit of each pool////////
    ///This is done to ensure that the arrays do not get too large
    function setStakeUserLimits(uint pool,uint256 _maxusers) public onlyOwner
    {
        if(pool==1)
        {
            safestakemaxuserlimit == _maxusers;
        }
        else if(pool==2)
        {
            riskystakemaximumuserlimit = _maxusers;
        }
    }
    
//////Function to return the last rebase, either positive or negative/////
    function returnLastRebase(bool _isRisky) public view returns (bool)
    {
        if (_isRisky == true)
        {
            return lastriskyrebase;
        }
        if (_isRisky ==false)
        {
            return lastsaferebase;
        }
    }
    ///////////////////////////
    function SetRCVRPriceFeed(address pricefeedaddress_) public onlyOwner{
        ////Set the pricefeed address for the Riksy Token Stake Pool////
        rcvrpricefeed = pricefeedaddress_;
        ////set the inital old pricefeedaddress_// Should only be done at contract initialization for start price of RCVR or a Token tracking change
        riskyoldprice = RCVRPriceFeed(rcvrpricefeed).getTokenPrice(address(this));  //Sets the base starting price
        
    }
    function SetSafePriceFeed(address pricefeedaddress_,bool _usechainlink) public onlyOwner{
        if (_usechainlink == true) //Use Chainlink for price feed for SafeStakePool
        {
        ////Set the pricefeed address for the Safe Token Stake Pool////
        chainlinkfeed = pricefeedaddress_;
        usechainlink = _usechainlink;
        ////set the inital old pricefeedaddress_// Should only be done at contract initialization for start price of RCVR
        safeoldprice = ChainlinkPriceFeed(chainlinkfeed).getSafeStakePrice();  //Sets the base starting price
        }
        if (_usechainlink == false) //Use Uniswap and a community selected token for price feed
        {
        usechainlink = _usechainlink;
        safetoken = pricefeedaddress_; //Set the Token to be used for price feed for Safe Pool via Uniswap
        safeoldprice = int(RCVRPriceFeed(rcvrpricefeed).getTokenPrice(safetoken));
        }
        
    }
    
     //////Function to set the Cost of the forced "Distribution"//////////////
   /////Convert to Wei first!////////////////////
   function setForceCost(uint costinwei,bool riskypool) public onlyOwner{
       if(riskypool == true){
           forceriskycost = costinwei;
       }
       if(riskypool == false)
       {
           forcesafecost = costinwei;
       }
   }
   //////Function to Withdraw Eth currently in the contract//////
   //////ETH from contract for forced distributions will be used for liquidty on BSC and timer contract costs//////
   //////ETH can only be withdrawn by the Owner/////
   function withdrawEth() public onlyOwner{
    msg.sender.transfer(address(this).balance);
   }
   /////Function to manually burn tokens should the community require it////
   function burnTokens(uint numtokenstoburn) public onlyOwner
   {
       ///Community needs to approve the burning of Tokens////
       require(burnenabled == true);
       ////Send numtokens to Burn Address
       _burn(address(this),numtokenstoburn);
   }
   ///function to create new tokens controlled exclusively by the contract
   ///A secondary mode allows minting and sending ONLY to the Migration address
   function mintToContract(uint amountTokens,bool toMigrationContractOnly) public onlyOwner
   {
     if (toMigrationContractOnly == false){
    _mint(address(this),amountTokens); // Mint Tokens directly to this contract for Staking
     }
     else if(toMigrationContractOnly == true)
     {
    _mint(migrationcontract,amountTokens); //Mint Tokens directly to Migration for token swaps
     }
   }
   ///Function to setup Frictionles staking and Minting for rewards (Frictionless)
   function frictionlessConfig(uint option, bool _onoff) public onlyOwner{
       if (option==1) ///Enabled Frictionless Staking
       {
           frictionless = _onoff;
       }
       if (option==2) //Enable/Disable Reward minting
       {
           frictionlessmint = _onoff;
       }
   }
   
   
   
   
   ////////////STAKING FUNCTIONS//////////
    //Stake pools are community driven and besides the normal safe pools, the riskier pools will be tied to high risk tokens///
    //The users of the high risk pool can decide to trigger a "Rewards Distribution", which costs the user 0.02 ETH and 0.01 ETH (safe), this will then be shared by the people in both pools % of what they have staked//
    //A Distribution causes a burn or decrease in the stake pool at that moment in time and sets the baseline back to 0//
    
    /**
    * @notice A method to check if an address is a stakeholder.
    * @param _address The address to verify.
    * @return bool, uint256 Whether the address is a stakeholder,
    * and if so its position in the stakeholders array.
    */
    
   function isStakeholder(address _address) public view returns(bool, uint256)
   {
       for (uint256 s = 0; s < stakeholders.length; s += 1){
           if (_address == stakeholders[s]) return (true, s);
       }
       return (false, 0);
   }
   function isRiskyStakeholder(address _address) public view returns(bool, uint256)
   {
       for (uint256 s = 0; s < riskystakeholders.length; s += 1){
           if (_address == riskystakeholders[s]) return (true, s);
       }
       return (false, 0);
   }

   /**
    * @notice A method to add a stakeholder.
    * @param _stakeholder The stakeholder to add.
    */
   function addStakeholder(address _stakeholder) private
   {
       (bool _isStakeholder, ) = isStakeholder(_stakeholder);
       if(!_isStakeholder) stakeholders.push(_stakeholder);
   }
   function addRiskyStakeholder(address _stakeholder) private
   {
       (bool _isStakeholder, ) = isRiskyStakeholder(_stakeholder);
       if(!_isStakeholder) riskystakeholders.push(_stakeholder);
   }

   /**
    * @notice A method to remove a stakeholder.
    * @param _stakeholder The stakeholder to remove.
    */
   function removeStakeholder(address _stakeholder) private
   {
       (bool _isStakeholder, uint256 s) = isStakeholder(_stakeholder);
       if(_isStakeholder){
           stakeholders[s] = stakeholders[stakeholders.length - 1];
           stakeholders.pop();
       }
   }
   function removeRiskyStakeholder(address _stakeholder) private
   {
       (bool _isStakeholder, uint256 s) = isRiskyStakeholder(_stakeholder);
       if(_isStakeholder){
           riskystakeholders[s] = riskystakeholders[riskystakeholders.length - 1];
           riskystakeholders.pop();
       }
   }
  
   /**
    * @notice A method to retrieve the stake for a stakeholder.
    * @param _stakeholder The stakeholder to retrieve the stake for.
    * @param pool Pool identifier. 1 for safe pool, 2 for risky pool
    * @return uint256 The amount of RCVR staked.
    */
   function stakeOf(address _stakeholder, uint pool) public view returns(uint256)  ///pool 1 = Safe pool 2 = Risky
   {
       uint256 temp = 0;
       if (pool == 1)
       {
       temp = stakes[_stakeholder];
       }
       if (pool ==2)
       {
       temp = riskystakes[_stakeholder];
       }
       return temp;
   }

   /**
    * @notice A method to the aggregated stakes from all stakeholders.
    * @return uint256 The aggregated stakes from all stakeholders.
    */
   function totalStakes(uint pool) public view returns(uint256){ ///pool 1 = Safe pool 2 = Risky
       uint256 _totalStakes = 0;
       if (pool ==1)
       {
       for (uint256 s = 0; s < stakeholders.length; s += 1){
           _totalStakes = _totalStakes.add(stakes[stakeholders[s]]);
       }
       }
       if (pool ==2)
       {
       for (uint256 s = 0; s < riskystakeholders.length; s += 1){
           _totalStakes = _totalStakes.add(riskystakes[riskystakeholders[s]]);
       }
       }
       return _totalStakes;
   }
   
   /**
    * @notice A method for a stakeholder to create a stake.
    * @param _stake The size of the stake to be created.
    */
   function createSafeStake(uint256 _stake) public
   {
       (bool currentstakeholder,) = isStakeholder(msg.sender);
       require(safestakingenabled == true, "SStakingDisabled");
       require(stakeholders.length < safestakemaxuserlimit, "MaxStakeStakersreached");
       require(balanceOf(msg.sender) >= _stake,"TooLittleRCVRtoCoverStake(S)");
       if (currentstakeholder==true)
       {
       require(_stake + stakes[msg.sender] <= balanceOf(msg.sender),"CompleteStakeTooLarge(s)");
       }
       if(frictionless==false)
       {
       _transfer(msg.sender, address(this), _stake); ///Transfer amount to Contract Address
       }
       if(stakes[msg.sender] == 0) addStakeholder(msg.sender);
       stakes[msg.sender] = stakes[msg.sender].add(_stake);
   }
   
   function createRiskyStake(uint256 _stake) public
   {
       (bool currentstakeholder,) = isStakeholder(msg.sender);
       require(riskystakingenabled == true, "RStakingDisabled");
       require(riskystakeholders.length < riskystakemaximumuserlimit, "MaxRiskyStakersreached");
       require(balanceOf(msg.sender) >= _stake,"TooLittleRCVRtoCoverStake(R)");
       if (currentstakeholder==true)
       {
       require(_stake + riskystakes[msg.sender] <= balanceOf(msg.sender),"CompleteStakeTooLarge(r)");
       }
       if(frictionless==false)
       {
       _transfer(msg.sender, address(this), _stake); ///Transfer amount to Contract Address
       }
       if(riskystakes[msg.sender] == 0) addRiskyStakeholder(msg.sender);
       riskystakes[msg.sender] = riskystakes[msg.sender].add(_stake);
   }

   /**
    * @notice A method for a stakeholder to remove a stake.
    * @param _stake The size of the stake to be removed.
    */
   function removeStake(uint256 _stake) public
   {
       if(frictionless==true)
       {
           ////Perform a check to ensure that balance is equal to original stake
           require (msg.sender.balance >= stakes[msg.sender],"B2lo4R(S)");
       }
       stakes[msg.sender] = stakes[msg.sender].sub(_stake);
       if(stakes[msg.sender] == 0) //Remove entire stake
       {
           removeStakeholder(msg.sender);
           //Frictionless staking///
           if(frictionless==false)
           {
           _stake = _stake.add(rewards[msg.sender]); ///Add the users reward balance to the stake pool;
           }
          if(frictionless==true)
           {
           _stake = rewards[msg.sender]; ///Only do the rewards//
           }
           rewards[msg.sender] = 0; //Clear balance to ensure correct accounting
           
       }
       /////////Use Minting for rewards or notice
       if (frictionlessmint==false)
       {
       this.transfer(msg.sender,_stake);
       }
       if (frictionlessmint==true)
       {
       ///mint tokens for reward
       ///This is to ensure that the tokens do nto run out if needed, however burns can be done to correct tokens
       _mint(msg.sender,_stake);
       }
   }
    function removeRiskyStake(uint256 _stake) public
   {
       if(frictionless==true)
       {
           ////Perform a check to ensure that balance is equal to original stake
           require (balanceOf(msg.sender) >= riskystakes[msg.sender],"B2lo4R(R)");
       }
       riskystakes[msg.sender] = riskystakes[msg.sender].sub(_stake);
       if(riskystakes[msg.sender] == 0) 
       {
           removeRiskyStakeholder(msg.sender);
           //Frictionless staking///
           if(frictionless==false)
           {
           _stake = _stake.add(riskyrewards[msg.sender]); ///Add the users reward balance to the stake pool;
           }
           if(frictionless==true)
           {
           _stake = riskyrewards[msg.sender]; ///Only do the rewards//
           }
           riskyrewards[msg.sender] = 0; //Clear balance to ensure correct accounting
       }
       /////////Use Minting for rewards or notice
       if (frictionlessmint==false)
       {
       this.transfer(msg.sender,_stake);
       }
       if (frictionlessmint==true)
       {
       ///mint tokens for reward
       ///This is to ensure that the tokens do not run out if needed, however burns can be done to correct tokens
       _mint(msg.sender,_stake);
       }
   }
    /**
    * @notice A method to allow a stakeholder to withdraw his rewards.
    */
   function withdrawReward()
       public
   {
       uint256 reward = rewards[msg.sender];
       if(frictionless==true)
       {
           ////Perform a check to ensure that balance is equal to original stake
           require (balanceOf(msg.sender) >= stakes[msg.sender],"B2lo4R(S)");
       }
       rewards[msg.sender] = 0; //Clear balance to ensure correct accounting
       if (frictionlessmint==false)
       {
       this.transfer(msg.sender,reward);
       }
       if (frictionlessmint==true) ///Mint RCVR tokens for rewards
       {
       _mint(msg.sender,reward); 
       }
   }
   function withdrawRiskyReward()
       public
   {
       uint256 reward = riskyrewards[msg.sender];
       if(frictionless==true)
       {
           ////Perform a check to ensure that balance is equal to original stake
           require (balanceOf(msg.sender) >= riskystakes[msg.sender],"B2lo4R(S)");
       }
       riskyrewards[msg.sender] = 0; //Clear balance to ensure correct accounting
       if (frictionlessmint==false)
       {
       this.transfer(msg.sender,reward);
       }
       if (frictionlessmint==true)
       {
       _mint(msg.sender,reward); ///Mint RCVR tokens for rewards   
       }
   }
   
   ///Function for user to check the amount of Staking rewards
    function rewardOf(address _stakeholder) public view returns(uint256)
   {
       return rewards[_stakeholder];
   }
   ///Function for user to check the amount of Risky Staking rewards
    function rewardOfRiskyRewards(address _stakeholder) public view returns(uint256)
   {
       return riskyrewards[_stakeholder];
   }
   /////Functions to Verify total rewards for safe and Risky rewards
   function totalRewards() public view returns(uint256)  ////Safe Staking
   {
       uint256 _totalRewards = 0;
       for (uint256 s = 0; s < stakeholders.length; s += 1){
           _totalRewards = _totalRewards.add(rewards[stakeholders[s]]);
       }
       return _totalRewards;
   }
   function totalRiskyRewards() public view returns(uint256)  ////Risky Staking
   {
       uint256 _totalRewards = 0;
       for (uint256 s = 0; s < riskystakeholders.length; s += 1){
           _totalRewards = _totalRewards.add(riskyrewards[riskystakeholders[s]]);
       }
       return _totalRewards;
   }
   /////////////////////NB Function to calculate rewards//////////////////
   /////////Calculation will be done on an hourly basis via the website/timer//////////////
   /////////Users can FORCE a reward calculation at any given time////////////////////////
   /////////When forced reward calculation is done, funds sent are then distributed//////
   function calculateReward(address _stakeholder)   ////Safe Bet
       public view
       returns(uint256)
   {
       return stakes[_stakeholder].div(safepercentage); // Returns value based at 1% by default
   }
   
   function calculateRiskyReward(address _stakeholder)  ////Risky Bet
       public view
       returns(uint256)
   {
       
       return (riskystakes[_stakeholder].div(riskypercentage)).mul(riskymultiplier); // Returns Value based at x% * multiplier
   }
   function rebase(bool RiskyReward) private {
       bool negrebase = false;
       bool safesame = false;
       bool riskysame = false;
       int safeprice = 0;
       //////////////SafeBet///////////
       if (RiskyReward == false){
           if (usechainlink==true) ///Use Chainlink or Uniswap price feed.
           {
         safeprice = ChainlinkPriceFeed(chainlinkfeed).getSafeStakePrice();
           }
           if (usechainlink==false)
           {
         safeprice = int(RCVRPriceFeed(rcvrpricefeed).getTokenPrice(safetoken));
           }
         if (safeprice < safeoldprice){
             ////Negative rebase
             negrebase = true;
            
         }
         else if (safeprice == safeoldprice ){
             safesame = true;
         }
         ////Set the old price = to the new price
         safeoldprice = safeprice;
       }
       /////////////RiskyBEt//////////
       if (RiskyReward == true){
         uint riskyprice = RCVRPriceFeed(rcvrpricefeed).getTokenPrice(riskytoken);
         if (riskyprice < riskyoldprice){
             ////Negative rebase
             negrebase = true;
         }
         if (riskyprice == riskyoldprice){
             ////Positive rebase
             riskysame = true;
         }
         riskyoldprice = riskyprice;
       }
       /////////////////////Rewards calculation////////
       if (RiskyReward == false)  //////SafeBet Rewards
       {
           if (safesame == false) ///////Only proceed if the price has changed////
           {
            for (uint256 s = 0; s < stakeholders.length; s += 1){
             address stakeholder = stakeholders[s];
             uint256 reward = calculateReward(stakeholder);
           
           
               if (negrebase == true)
               {
                lastsaferebase = true; //Value for feedback to website
                if (rewards[stakeholder] >= reward) { //ensure that the users balance can ammodate the subtraction
                  rewards[stakeholder] = rewards[stakeholder].sub(reward); //subtract for negative rebase
                } else {
                  rewards[stakeholder] = 0;
                }
                safeaccumulatednegetivereabase += reward; ///accumulate the tokens for a manual burn!
               }
               if (negrebase == false)
               {
                    lastsaferebase = false; //Value for feedback to website
               rewards[stakeholder] = rewards[stakeholder].add(reward); //add for positive rebase
               }
           
       }
       prevsaferebase = block.timestamp;
           }
      }
      if (RiskyReward == true)  //////Risky Bet
       {
           if (riskysame == false) ///ensures no actions are done if price remains the same
           {
          for (uint256 s = 0; s < riskystakeholders.length; s += 1){
           address stakeholder = riskystakeholders[s];
           uint256 reward = calculateRiskyReward(stakeholder);
           
               if (negrebase == true)
               {
                   lastriskyrebase = true;
                if (riskyrewards[stakeholder] >= reward) { //ensure that the users balance can ammodate the subtraction
                  riskyrewards[stakeholder] = riskyrewards[stakeholder].sub(reward); //subtract for negative rebase
                } else {
                  riskyrewards[stakeholder] = 0;
                }
                riskyaccumulatednegetiverebase += reward; ///accumulate the tokens for a manual burn!
               }
               if (negrebase == false)
               {
                   lastriskyrebase = false;
               riskyrewards[stakeholder] = riskyrewards[stakeholder].add(reward); //add for positive rebase
               }
           
        } 
        //Set the last Risky rebase timestamp 
        prevriskyrebase = block.timestamp;
       }
       }
    }

  ///Function for Timer to trigger a safe rebase
  function autoTriggerSafeRebase() public{
      require(msg.sender == timeraddress,"NotTimer");
      require(msg.sender != Owner, "OnlyTimer"); ///Extra check for transparecy to ensure the Timer Address and the Owner address cannot be the same;
      rebase(false);
  }
   ///Function for Timer to trigger a risky rebase
  function autoTriggerRiskyRebase() public{
      require(msg.sender == timeraddress,"NotTimer");
      require(msg.sender != Owner, "OnlyTimer"); ///Extra check for transparecy to ensure the Timer Address and the Owner address cannot be the same;
      rebase(true);
  }
  
  //////////Function which user can trigger to force a rebase. This costs xx amount of Ether//////
   /// 0.01 -> SafeStake pool
   /// 0.02 -> RiskyStake pool
   function Forcedistribute(bool RiskyReward) public payable
   {
       require(rewarddistribution == true, "RweardsOff");
       uint ethercost = 0;
       if (RiskyReward == false){
           ethercost = forcesafecost;
       }
       if (RiskyReward == true){
           ethercost = forceriskycost;
       }
       /////Require statement to ensure user can afford it////
       require(msg.value >= ethercost);
       //Perform the rebase
       rebase(RiskyReward);
   }
}///////////////////Contract END//////////////////////