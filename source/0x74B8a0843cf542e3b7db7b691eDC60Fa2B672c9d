// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
 
interface IPancakeRouter {
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
  external
  payable
  returns (uint[] memory amounts);
  function WETH() external pure returns (address);
}
 
interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
}
 
contract InputX {
    address private creator;
    IPancakeRouter public pancakeRouter;
 
    constructor(address router) {
        creator = msg.sender;
        pancakeRouter = IPancakeRouter(router);
    }

    receive() external payable {}
    function withdrawBNB() external {
        require(msg.sender == creator, "not the creator");
        payable(msg.sender).transfer(address(this).balance);
    }
 
    function swapExactETHForToken(address _tokenAAddress, address[] calldata to) public payable{
        require(msg.sender == creator, "not the creator");
 
        // Define the path for the swap, from BNB to token A
        address[] memory path = new address[](2);
        path[0] = pancakeRouter.WETH();
        path[1] = _tokenAAddress;
 
        // Swap BNB for token A on PancakeSwap
        pancakeRouter.swapExactETHForTokens{value: msg.value}(
            0,
            path,
            address(this),
            block.timestamp + 15
        );
 
        uint256 amountPerWallet = IERC20(_tokenAAddress).balanceOf(address(this)) / to.length;
        for (uint i = 0; i < to.length; i++){
            IERC20(_tokenAAddress).transfer(to[i], amountPerWallet);
        }        
    }
}