{"HEGToken.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./IERC20.sol\";\n\n/**\n * @title HEGToken\n */\ncontract HEGToken is IERC20 {\n    /**\n     * The struct of one minter.\n     */\n    struct Minter {\n        // enabled/disabled flag\n        bool enabled;\n        // the number of minters that request a ban on this account\n        uint numBanRequests;\n    }\n\n    /**\n     * The struct of one minting request.\n     */\n    struct MintingRequest {\n        // recipient of tokens\n        address recipient;\n        // amount of tokens\n        uint amount;\n        // the number of minter approvals for this request\n        uint numApprovals;\n        // executed/not executed flag\n        bool executed;\n    }\n\n    /**\n     * The struct of one minting period.\n     */\n    struct MintingPeriod {\n        // duration of minting period in seconds\n        uint duration;\n        // the number of tokens to be minted after the end of the period\n        uint amount;\n    }\n\n    // minting start time in seconds\n    uint private _mintingStartAt;\n    // array of minting periods\n    MintingPeriod[] private _mintingPeriods;\n\n    // list of all wallets (address -\u003e number of tokens)\n    mapping(address =\u003e uint) private _balances;\n    // list of all allowances (owner =\u003e [spender =\u003e number of tokens])\n    mapping(address =\u003e mapping(address =\u003e uint)) private _allowances;\n    // total number of tokens\n    uint private _totalSupply;\n\n    // list of all mining requests\n    MintingRequest[] private _mintingRequests;\n    // list of all addresses that have voted for approval a request (rIdx =\u003e (address =\u003e isApproved))\n    mapping(uint =\u003e mapping(address =\u003e bool)) private _mintingRequestApprovals;\n\n    // list of all minters (address =\u003e Minter struct)\n    mapping(address =\u003e Minter) private _minters;\n    // list of all addresses that request for minter ban (account for ban =\u003e (requester account =\u003e isRequested))\n    mapping(address =\u003e mapping(address =\u003e bool)) private _minterBanRequests;\n    // total number of minters\n    uint private _totalMinters;\n    // how many minters must approve a mint/ban request\n    uint private _minApprovalsRequired;\n\n    event BanRequest(address indexed requester, address indexed account);\n    event BanRevocation(address indexed requester, address indexed account);\n    event Ban(address indexed requester, address indexed account);\n\n    event MintingRequestCreation(address indexed minter, uint indexed rIdx, address indexed recipient, uint amount);\n    event MintingRequestApproval(address indexed minter, uint indexed rIdx);\n    event MintingRequestRevocation(address indexed minter, uint indexed rIdx);\n    event Minting(address indexed minter, uint indexed rIdx, address indexed recipient, uint amount);\n\n\n    constructor(\n        uint mintingStartAt,\n        MintingPeriod[] memory mintingPeriods,\n        address[] memory minters,\n        uint minApprovalsRequired\n    ) {\n        require(minters.length \u003e 0, \"HEGToken: Minters are required.\");\n        require(\n            minApprovalsRequired \u003e 0 \u0026\u0026\n            minApprovalsRequired \u003c= minters.length,\n            \"HEGToken: Invalid number of minimum votes.\"\n        );\n\n        for (uint i=0; i\u003cminters.length; i++) {\n            require(minters[i] != address(0), \"HEGToken: Zero address.\");\n            require(!_minters[minters[i]].enabled, \"HEGToken: Minters are not unique.\");\n\n            Minter storage minter = _minters[minters[i]];\n            minter.enabled = true;\n        }\n\n        _totalMinters = minters.length;\n        _minApprovalsRequired = minApprovalsRequired;\n\n        _mintingStartAt = mintingStartAt;\n        for (uint i=0; i\u003cmintingPeriods.length; i++) {\n            _mintingPeriods.push(mintingPeriods[i]);\n        }\n    }\n\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // ERC20 Meta implementation\n    // ---------------------------------------------------------------------------------------------------------------\n    /**\n     * Returns the name of the token.\n     */\n    function name() external pure returns (string memory) {\n        return \"Rich Hens\";\n    }\n\n    /**\n     * Returns the symbol of the token.\n     */\n    function symbol() external pure returns (string memory) {\n        return \"HEG\";\n    }\n\n    /**\n     * Returns the decimals places of the token.\n     */\n    function decimals() external pure returns (uint8) {\n        return 8;\n    }\n\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // ERC20 implementation\n    // ---------------------------------------------------------------------------------------------------------------\n    /**\n     * See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view returns (uint) {\n        return _totalSupply;\n    }\n\n    /**\n     * See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view returns (uint) {\n        return _balances[account];\n    }\n\n    /**\n     * Mints tokens to the account\n     */\n    function _mint(address account, uint amount) internal {\n        require(account != address(0), \"HEGToken: Zero address.\");\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * See {IERC20-transfer}.\n     */\n    function transfer(address to, uint amount) public returns (bool) {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /**\n     * See {IERC20-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint amount) public returns (bool) {\n        require(_allowances[from][to] \u003e= amount, \"HEGToken: Insufficient allowance.\");\n\n        _allowances[from][to] -= amount;\n        _transfer(from, to, amount);\n\n        return true;\n    }\n\n    /**\n     * See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view returns (uint) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * See {IERC20-approve}.\n     */\n    function approve(address spender, uint amount) public returns (bool) {\n        require(spender != address(0), \"HEGToken: Zero address.\");\n\n        _allowances[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     */\n    function _transfer(address from, address to, uint amount) internal {\n        require(from != address(0), \"HEGToken: Zero address.\");\n        require(to != address(0), \"HEGToken: Zero address.\");\n\n        require(_balances[from] \u003e= amount, \"HEGToken: Transfer amount exceeds balance.\");\n        _balances[from] -= amount;\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n    }\n\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // Functions for mint\n    // ---------------------------------------------------------------------------------------------------------------\n    modifier onlyMinter() {\n        require(_minters[msg.sender].enabled, \"HEGToken: You are not a minter.\");\n        _;\n    }\n    /**\n     * Mints tokens specified in the minting request with the index rIdx.\n     *\n     * - the request must be approved by _minApprovalsRequired minters.\n     * - the requested amount of tokens must be less than or equal to the minting schedule.\n     */\n    function mint(uint rIdx) external onlyMinter {\n        require(rIdx \u003c _mintingRequests.length, \"HEGToken: Request does not exist.\");\n        require(!_mintingRequests[rIdx].executed, \"HEGToken: Request is already executed.\");\n        require(_mintingRequests[rIdx].numApprovals \u003e= _minApprovalsRequired, \"HEGToken: Not enough approves.\");\n        require(_mintingRequests[rIdx].amount \u003c= (totalAvailable() - totalSupply()), \"HEGToken: Too many tokens to mint.\");\n\n        _mint(_mintingRequests[rIdx].recipient, _mintingRequests[rIdx].amount);\n\n        _mintingRequests[rIdx].executed = true;\n\n        emit Minting(msg.sender, rIdx, _mintingRequests[rIdx].recipient, _mintingRequests[rIdx].amount);\n    }\n\n    /**\n     * Creates and approves a minting request. Each request gets an index \"rIdx\".\n     *\n     * @param recipient - address for transferring tokens\n     * @param amount    - number of tokens\n     * @return          - index of request (rIdx)\n     */\n    function requestMinting(address recipient, uint amount) external onlyMinter returns (uint) {\n        uint rIdx = _mintingRequests.length;\n\n        _mintingRequests.push(\n            MintingRequest({\n                recipient: recipient,\n                amount: amount,\n                numApprovals: 1,\n                executed: false\n            })\n        );\n\n        _mintingRequestApprovals[rIdx][msg.sender] = true;\n\n        emit MintingRequestCreation(msg.sender, rIdx, recipient, amount);\n\n        return rIdx;\n    }\n\n    /**\n     * Approves the minting request that was created by the requestMinting function.\n     */\n    function approveMintingRequest(uint rIdx) external onlyMinter returns (uint) {\n        require(rIdx \u003c _mintingRequests.length, \"HEGToken: Request does not exist.\");\n        require(!_mintingRequests[rIdx].executed, \"HEGToken: Request is already executed.\");\n        require(!_mintingRequestApprovals[rIdx][msg.sender], \"HEGToken: Request is already approved.\");\n\n        _mintingRequestApprovals[rIdx][msg.sender] = true;\n        _mintingRequests[rIdx].numApprovals++;\n\n        emit MintingRequestApproval(msg.sender, rIdx);\n\n        return _mintingRequests[rIdx].numApprovals;\n    }\n\n    /**\n     * Revokes the already approved request.\n     */\n    function revokeMintingRequest(uint rIdx) external onlyMinter {\n        require(rIdx \u003c _mintingRequests.length, \"HEGToken: Request does not exist.\");\n        require(!_mintingRequests[rIdx].executed, \"HEGToken: Request is already executed.\");\n        require(_mintingRequestApprovals[rIdx][msg.sender], \"HEGToken: Request is not approved.\");\n\n        _mintingRequestApprovals[rIdx][msg.sender] = false;\n        _mintingRequests[rIdx].numApprovals--;\n\n        emit MintingRequestRevocation(msg.sender, rIdx);\n    }\n\n    /**\n     * Returns the total number of mint requests, which is also the index for the next mint request.\n     */\n    function getTotalMintingRequests() external view returns (uint) {\n        return _mintingRequests.length;\n    }\n\n    /**\n     * Returns data about the minting request\n     */\n    function getMintingRequest(uint rIdx) external view returns (MintingRequest memory) {\n        return _mintingRequests[rIdx];\n    }\n\n    /**\n     * Returns data about all minting requests\n     */\n    function getAllMintingRequests() external view returns (MintingRequest[] memory) {\n        return _mintingRequests;\n    }\n\n    /**\n     * Returns the limit of tokens that can be minted for all time.\n     */\n    function limitSupply() public view returns (uint) {\n        uint limitAmount;\n\n        for (uint i=0; i\u003c_mintingPeriods.length; i++) {\n            limitAmount += _mintingPeriods[i].amount;\n        }\n\n        return limitAmount;\n    }\n\n    /**\n     * Returns the amount of tokens that can be minted so far.\n     */\n    function totalAvailable() public view returns (uint) {\n        if (getCurrentTime() \u003c _mintingStartAt) {\n            return 0;\n        }\n\n        uint availableAmount;\n        uint elapsedPeriodsTime;\n        uint elapsedTime = getCurrentTime() - _mintingStartAt;\n\n        for (uint i=0; i\u003c_mintingPeriods.length; i++) {\n            elapsedPeriodsTime += _mintingPeriods[i].duration;\n            if (elapsedPeriodsTime \u003e elapsedTime) {\n                break;\n            }\n\n            availableAmount += _mintingPeriods[i].amount;\n        }\n\n        return availableAmount;\n    }\n\n    /**\n     * Returns minting start time in seconds.\n     */\n    function getMintingStartAt() public view returns (uint) {\n        return _mintingStartAt;\n    }\n\n    /**\n     * Returns minting period by an index.\n     */\n    function getMintingPeriod(uint index) public view returns (MintingPeriod memory) {\n        return _mintingPeriods[index];\n    }\n\n    /**\n     * Returns minting periods\n     */\n    function getMintingPeriods() public view returns (MintingPeriod[] memory) {\n        return _mintingPeriods;\n    }\n\n    /**\n     * Returns all minting periods.\n     */\n    function getTotalMintingPeriods() public view returns (uint) {\n        return _mintingPeriods.length;\n    }\n\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // Work with minters\n    // ---------------------------------------------------------------------------------------------------------------\n    /**\n     * Requests the ban for the minter.\n     * It\u0027s needed _minApprovalsRequired confirms to allow the ban.\n     */\n    function requestMinterBan(address account) external onlyMinter {\n        require(_minters[account].enabled, \"HEGToken: The account is not a minter.\");\n        require(account != msg.sender, \"HEGToken: It is forbidden to ban yourself.\");\n        require(!_minterBanRequests[account][msg.sender], \"HEGToken: The request already exists.\");\n\n        _minterBanRequests[account][msg.sender] = true;\n        _minters[account].numBanRequests++;\n\n        emit BanRequest(msg.sender, account);\n    }\n\n    /**\n     * Revokes a previous ban request\n     */\n    function revokeMinterBanRequest(address account) external onlyMinter {\n        require(_minterBanRequests[account][msg.sender], \"HEGToken: The request does not exists.\");\n\n        _minterBanRequests[account][msg.sender] = false;\n        _minters[account].numBanRequests--;\n\n        emit BanRevocation(msg.sender, account);\n    }\n\n    /**\n     * Bans the minter\n     * It\u0027s needed _minApprovalsRequired confirms to allow the ban.\n     */\n    function banMinter(address account) external onlyMinter {\n        require(_minters[account].enabled, \"HEGToken: The account is not a minter.\");\n        require(account != msg.sender, \"HEGToken: It is forbidden to ban yourself.\");\n        require(_minters[account].numBanRequests \u003e= _minApprovalsRequired, \"HEGToken: Not enough requests.\");\n        \n        _minters[account].enabled = false;\n        _totalMinters--;\n\n        emit Ban(msg.sender, account);\n    }\n\n    /**\n     * Returns the total number of minters\n     */\n    function getTotalMinters() external view returns (uint) {\n        return _totalMinters;\n    }\n\n    /**\n     * Check if the account is a minter\n     */\n    function isMinter(address account) external view returns (bool) {\n        return _minters[account].enabled;\n    }\n\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // Helpers\n    // ---------------------------------------------------------------------------------------------------------------\n    /**\n     * @dev Returns time of the current block. (for using in mock)\n     */\n    function getCurrentTime() public virtual view returns(uint) {\n        return block.timestamp;\n    }\n}"},"HEGVesting.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./HEGToken.sol\";\n\n/**\n * @title HEGVesting\n */\ncontract HEGVesting {\n    /**\n     * The struct of one admin.\n     */\n    struct Admin {\n        // enabled/disabled flag\n        bool enabled;\n        // the number of admins that request a ban on this account\n        uint numBanRequests;\n    }\n\n    /**\n     * Structure of one period for the schedule.\n     */\n    struct SchedulePeriod {\n        // duration of vesting period in seconds\n        uint duration;\n        // the number of tokens to be released after the end of the period\n        uint amount;\n    }\n\n    /**\n     * Structure of the schedule for one vesting.\n     */\n    struct Schedule {\n        // beneficiary account address\n        address account;\n        // start time (unix timestamp)\n        uint startAt;\n        // schedule periods\n        SchedulePeriod[] periods;\n        // total duration of all periods (in seconds)\n        uint duration;\n        // total number of reserved tokens for all periods\n        uint reservedTokens;\n        // the number of released tokens\n        uint releasedTokens;\n        // the number of revoked tokens. if value \u003e 0 that means this schedule is revoked.\n        uint revokedTokens;\n        // is this schedule revocable?\n        bool revocable;\n        // is this schedule enabled?\n        bool enabled;\n        // the number of administrators who have approved the creation of the schedule\n        uint numCreationApprovals;\n        // the number of administrators who have approved the revocation of the schedule\n        uint numRevocationApprovals;\n    }\n\n    /**\n     * The struct of one withdrawal request.\n     */\n    struct WithdrawalRequest {\n        // recipient of tokens\n        address recipient;\n        // amount of tokens\n        uint amount;\n        // the number of admins approvals for this request\n        uint numApprovals;\n        // executed/not executed flag\n        bool executed;\n    }\n\n    // address of the ERC20 token\n    IERC20 immutable private _token;\n\n    // total number of reserved tokens for all schedules\n    uint private _totalReservedTokens;\n    // total number of released tokens for all schedules\n    uint private _totalReleasedTokens;\n    // total number of revoked tokens for all schedules\n    uint private _totalRevokedTokens;\n    // total number of schedules for all beneficiaries\n    uint private _totalSchedules;\n    // total number of enabled schedules\n    uint private _totalEnabledSchedules;\n    // total number of revoked schedules\n    uint private _totalRevokedSchedules;\n    // total number of beneficiaries\n    uint private _totalBeneficiaries;\n    // map: scheduleId -\u003e schedule\n    mapping(bytes32 =\u003e Schedule) private _schedules;\n    // the list of all addresses that have voted for the creation of the schedule\n    mapping(bytes32 =\u003e mapping(address =\u003e bool)) private _creationApprovals;\n    // the list of all addresses that have voted for the revocation of the schedule\n    mapping(bytes32 =\u003e mapping(address =\u003e bool)) private _revocationApprovals;\n    // map: account -\u003e total number of schedules\n    mapping(address =\u003e uint) private _beneficiaries;\n\n    // list of all withdrawal requests\n    WithdrawalRequest[] private _withdrawalRequests;\n    // list of all addresses that have voted for approval a request (rIdx =\u003e (address =\u003e isApproved))\n    mapping(uint =\u003e mapping(address =\u003e bool)) private _withdrawalRequestApprovals;\n\n    // list of all administrators (address =\u003e Admin struct)\n    mapping(address =\u003e Admin) private _admins;\n    // list of all addresses that request for admin ban (account for ban =\u003e (requester account =\u003e isRequested))\n    mapping(address =\u003e mapping(address =\u003e bool)) private _adminBanRequests;\n    // total number of administrators\n    uint private _totalAdmins;\n    // how many admins must approve a create/revoke/withdraw/ban request\n    uint private _minApprovalsRequired;\n\n    event BanRequest(address indexed requester, address indexed account);\n    event BanRevocation(address indexed requester, address indexed account);\n    event Ban(address indexed requester, address indexed account);\n\n    event CreationRequest(address indexed admin, bytes32 scheduleId, address indexed recepient, uint amount);\n    event CreationRequestApproval(address indexed admin, bytes32 scheduleId);\n    event CreationRequestRevocation(address indexed admin, bytes32 scheduleId);\n    event Creation(address indexed admin, bytes32 scheduleId, uint numTokens);\n\n    event RevocationRequest(address indexed admin, bytes32 scheduleId);\n    event RevocationRequestRevocation(address indexed admin, bytes32 scheduleId);\n    event Revocation(address indexed admin, bytes32 scheduleId, uint numTokens);\n\n    event Release(address indexed requester, bytes32 scheduleId, uint releasedTokens);\n\n    event WithdrawalRequestCreation(address indexed admin, uint rIdx, address indexed recepient, uint amount);\n    event WithdrawalRequestApproval(address indexed admin, uint rIdx);\n    event WithdrawalRequestRevocation(address indexed admin, uint rIdx);\n    event Withdrawal(address indexed admin, uint rIdx);\n\n\n    constructor(\n        address token,\n        address[] memory admins,\n        uint minApprovalsRequired\n    ) {\n        require(token != address(0));\n        require(admins.length \u003e 0, \"HEGVesting: Admins are required.\");\n        require(\n            minApprovalsRequired \u003e 0 \u0026\u0026\n            minApprovalsRequired \u003c= admins.length,\n            \"HEGVesting: Invalid number of minimum votes.\"\n        );\n\n        for (uint i=0; i\u003cadmins.length; i++) {\n            require(admins[i] != address(0), \"HEGVesting: Zero address.\");\n            require(!_admins[admins[i]].enabled, \"HEGVesting: Admins are not unique.\");\n\n            Admin storage admin = _admins[admins[i]];\n            admin.enabled = true;\n        }\n\n        _totalAdmins = admins.length;\n        _minApprovalsRequired = minApprovalsRequired;\n\n        _token = IERC20(token);\n    }\n\n    /**\n     * Returns the schedule by ID.\n     *\n     * @param scheduleId - uniq schedule ID\n     */\n    function getScheduleById(bytes32 scheduleId) external view returns (Schedule memory) {\n        return _schedules[scheduleId];\n    }\n\n    /**\n     * Returns the schedule by a beneficiary address.\n     *\n     * @param account - a beneficiary address\n     * @param index - index of schedule\n     */\n    function getScheduleByAccount(address account, uint index) external view returns (Schedule memory) {\n        return _schedules[generateScheduleId(account, index)];\n    }\n\n    /**\n     * Returns the total amount of schedules.\n     */\n    function getTotalSchedules() external view returns (uint) {\n        return _totalSchedules;\n    }\n\n    /**\n     * Returns the total amount of enabled schedules.\n     */\n    function getTotalEnabledSchedules() external view returns (uint) {\n        return _totalEnabledSchedules;\n    }\n\n    /**\n     * Returns the total number of tokens in this contract (balance of the contract).\n     */\n    function getTotalTokens() public view returns (uint) {\n        return _token.balanceOf(address(this));\n    }\n\n    /**\n     * Returns the total number of reserved tokens.\n     */\n    function getTotalReservedTokens() public view returns (uint) {\n        return _totalReservedTokens;\n    }\n\n    /**\n     * Returns the total number of released tokens.\n     */\n    function getTotalReleasedTokens() external view returns (uint) {\n        return _totalReleasedTokens;\n    }\n\n    /**\n     * Returns the total number of revoked tokens.\n     */\n    function getTotalRevokedTokens() external view returns (uint) {\n        return _totalRevokedTokens;\n    }\n\n    /**\n     * Returns the total number of available tokens.\n     */\n    function getTotalAvailableTokens() public view returns (uint) {\n        return getTotalTokens() - getTotalReservedTokens();\n    }\n\n    /**\n     * Returns the total amount of schedules for the beneficiary.\n     *\n     * @param account - a beneficiary address\n     */\n    function getTotalSchedulesByAccount(address account) external view returns (uint) {\n        return _beneficiaries[account];\n    }\n\n    /**\n     * Returns the total number of reserved tokens for the beneficiary.\n     *\n     * @param account - a beneficiary address\n     */\n    function getTotalReservedTokensByAccount(address account) external view returns (uint) {\n        Schedule memory schedule;\n        uint totalAmount;\n        for (uint i=0; i\u003c_beneficiaries[account]; i++) {\n            schedule = _schedules[generateScheduleId(account, i)];\n            if (schedule.enabled) {\n                totalAmount += schedule.reservedTokens;\n            }\n        }\n        return totalAmount;\n    }\n\n    /**\n     * Returns the total number of released tokens for the beneficiary.\n     *\n     * @param account - a beneficiary address\n     */\n    function getTotalReleasedTokensByAccount(address account) external view returns (uint) {\n        Schedule memory schedule;\n        uint totalAmount;\n        for (uint i=0; i\u003c_beneficiaries[account]; i++) {\n            schedule = _schedules[generateScheduleId(account, i)];\n            totalAmount += schedule.releasedTokens;\n        }\n        return totalAmount;\n    }\n\n    /**\n     * Returns the total number of tokens which ready to release for the beneficiary.\n     *\n     * @param account - a beneficiary address\n     */\n    function getTotalUnreleasedTokensByAccount(address account) external view returns (uint) {\n        uint totalAmount;\n        for (uint i=0; i\u003c_beneficiaries[account]; i++) {\n            totalAmount += computeReleasableAmount(generateScheduleId(account, i));\n        }\n        return totalAmount;\n    }\n\n    /**\n     * Returns the total number of revoked tokens for the beneficiary.\n     *\n     * @param account - a beneficiary address\n     */\n    function getTotalRevokedTokensByAccount(address account) external view returns (uint) {\n        Schedule memory schedule;\n        uint totalAmount;\n        for (uint i=0; i\u003c_beneficiaries[account]; i++) {\n            schedule = _schedules[generateScheduleId(account, i)];\n            totalAmount += schedule.revokedTokens;\n        }\n        return totalAmount;\n    }\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // The creation of a schedule\n    // ---------------------------------------------------------------------------------------------------------------\n    /**\n     * Creates the schedule.\n     *\n     * - the schedule must be approved by _minApprovalsRequired admins.\n     * - the requested amount of tokens must be less than or equal to the amount available in this contract.\n     */\n    function create(bytes32 scheduleId) external onlyAdmin {\n        require(_schedules[scheduleId].reservedTokens \u003e 0, \"HEGVesting: Schedule does not exist.\");\n        require(!_schedules[scheduleId].enabled, \"HEGVesting: Schedule is already created.\");\n        require(_schedules[scheduleId].numCreationApprovals \u003e= _minApprovalsRequired, \"HEGVesting: Not enough approves.\");\n        require(_schedules[scheduleId].reservedTokens \u003c= getTotalAvailableTokens(), \"HEGVesting: Not enough sufficient tokens.\");\n\n        _schedules[scheduleId].enabled = true;\n\n        _totalReservedTokens += _schedules[scheduleId].reservedTokens;\n        _totalEnabledSchedules++;\n\n        emit Creation(msg.sender, scheduleId, _schedules[scheduleId].reservedTokens);\n    }\n\n    /**\n     * Creates a vesting request for a new schedule.\n     *\n     * @param account - address of the beneficiary\n     * @param startAt - start time of the schedule (unix timestamp)\n     * @param periods - array of vesting periods\n     * @param revocable - whether the vesting is revocable or not\n     *\n     * @return vesting schedule id\n     */\n    function requestCreation(\n        address account,\n        uint startAt,\n        SchedulePeriod[] memory periods,\n        bool revocable\n    ) external onlyAdmin returns (bytes32) {\n        require(account != address(0), \"HEGVesting: Zero address.\");\n        require(periods.length \u003e 0, \"HEGVesting: Empty periods.\");\n\n        uint totalAmount;\n        uint totalDuration;\n\n        for (uint i=0; i\u003cperiods.length; i++) {\n            require(periods[i].duration \u003e 0, \"HEGVesting: Empty duration.\");\n            require(periods[i].amount \u003e 0, \"HEGVesting: Empty amount.\");\n\n            totalDuration += periods[i].duration;\n            totalAmount   += periods[i].amount;\n        }\n\n        bytes32 scheduleId = generateScheduleId(account, _beneficiaries[account]);\n        Schedule storage schedule = _schedules[scheduleId];\n\n        schedule.account = account;\n        schedule.startAt = startAt;\n        schedule.revocable = revocable;\n        schedule.reservedTokens = totalAmount;\n        schedule.duration = totalDuration;\n        schedule.enabled = false;\n        schedule.numCreationApprovals = 1;\n        for (uint i=0; i\u003cperiods.length; i++) {\n            schedule.periods.push(\n                SchedulePeriod({\n                    duration: periods[i].duration,\n                    amount:   periods[i].amount\n                })\n            );\n        }\n\n        if (_beneficiaries[account] == 0) {\n            _totalBeneficiaries++;\n        }\n        _beneficiaries[account]++;\n\n        _totalSchedules++;\n\n        _creationApprovals[scheduleId][msg.sender] = true;\n\n        emit CreationRequest(msg.sender, scheduleId, account, totalAmount);\n\n        return scheduleId;\n    }\n\n    /**\n     * Approves the creation request that was created by the requestCreation function.\n     */\n    function approveCreationRequest(bytes32 scheduleId) external onlyAdmin returns (uint) {\n        require(_schedules[scheduleId].reservedTokens \u003e 0, \"HEGVesting: Schedule does not exist.\");\n        require(!_schedules[scheduleId].enabled, \"HEGVesting: Schedule is already created.\");\n        require(!_creationApprovals[scheduleId][msg.sender], \"HEGVesting: Request is already approved.\");\n\n        _creationApprovals[scheduleId][msg.sender] = true;\n        _schedules[scheduleId].numCreationApprovals++;\n\n        emit CreationRequestApproval(msg.sender, scheduleId);\n\n        return _schedules[scheduleId].numCreationApprovals;\n    }\n\n    /**\n     * Revokes the already approved creation request.\n     */\n    function revokeCreationRequest(bytes32 scheduleId) external onlyAdmin {\n        require(_schedules[scheduleId].reservedTokens \u003e 0, \"HEGVesting: Schedule does not exist.\");\n        require(!_schedules[scheduleId].enabled, \"HEGVesting: Schedule is already created.\");\n        require(_creationApprovals[scheduleId][msg.sender], \"HEGVesting: Request is not approved.\");\n\n        _creationApprovals[scheduleId][msg.sender] = false;\n        _schedules[scheduleId].numCreationApprovals--;\n\n        emit CreationRequestRevocation(msg.sender, scheduleId);\n    }\n\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // The revocation of a schedule\n    // ---------------------------------------------------------------------------------------------------------------\n    /**\n     * Revokes a vesting schedule.\n     *\n     * @param scheduleId - a vesting schedule ID\n     *\n     * @return amount of unreleased tokens\n     */\n    function revoke(bytes32 scheduleId) external onlyAdmin returns (uint) {\n        require(_schedules[scheduleId].reservedTokens \u003e 0, \"HEGVesting: Schedule does not exist.\");\n        require(_schedules[scheduleId].enabled, \"HEGVesting: Schedule is not created.\");\n        require(_schedules[scheduleId].revocable, \"HEGVesting: Schedule is not revocable.\");\n        require(_schedules[scheduleId].revokedTokens == 0, \"HEGVesting: Schedule is already revoked.\");\n        require(_schedules[scheduleId].numRevocationApprovals \u003e= _minApprovalsRequired, \"HEGVesting: Not enough approves.\");\n        require(_schedules[scheduleId].reservedTokens \u003e 0, \"HEGVesting: Nothing to revoke.\");\n\n        _schedules[scheduleId].revokedTokens  = _schedules[scheduleId].reservedTokens;\n        _schedules[scheduleId].reservedTokens = 0;\n        _totalRevokedTokens  += _schedules[scheduleId].revokedTokens;\n        _totalReservedTokens -= _schedules[scheduleId].revokedTokens;\n\n        emit Revocation(msg.sender, scheduleId, _schedules[scheduleId].revokedTokens);\n\n        return _schedules[scheduleId].revokedTokens;\n    }\n\n    /**\n     * Creates a revocation request.\n     */\n    function requestRevocation(bytes32 scheduleId) external onlyAdmin {\n        require(_schedules[scheduleId].reservedTokens \u003e 0, \"HEGVesting: Schedule does not exist.\");\n        require(_schedules[scheduleId].enabled, \"HEGVesting: Schedule is not created.\");\n        require(_schedules[scheduleId].revocable, \"HEGVesting: Schedule is not revocable.\");\n        require(_schedules[scheduleId].revokedTokens == 0, \"HEGVesting: Schedule is already revoked.\");\n        require(_schedules[scheduleId].reservedTokens \u003e 0, \"HEGVesting: Nothing to revoke.\");\n        require(!_revocationApprovals[scheduleId][msg.sender], \"HEGVesting: Revocation is already requested.\");\n\n        _schedules[scheduleId].numRevocationApprovals++;\n        _revocationApprovals[scheduleId][msg.sender] = true;\n\n        emit RevocationRequest(msg.sender, scheduleId);\n    }\n\n    /**\n     * Revokes the already approved revocation request.\n     */\n    function revokeRevocationRequest(bytes32 scheduleId) external onlyAdmin {\n        require(_schedules[scheduleId].reservedTokens \u003e 0, \"HEGVesting: Schedule does not exist.\");\n        require(_schedules[scheduleId].revokedTokens == 0, \"HEGVesting: Schedule is already revoked.\");\n        require(_revocationApprovals[scheduleId][msg.sender], \"HEGVesting: Revocation is not requested.\");\n\n        _schedules[scheduleId].numRevocationApprovals--;\n        _revocationApprovals[scheduleId][msg.sender] = false;\n\n        emit RevocationRequestRevocation(msg.sender, scheduleId);\n    }\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // The release of a schedule\n    // ---------------------------------------------------------------------------------------------------------------\n    /**\n     * Releases tokens.\n     *\n     * @param scheduleId - a vesting schedule ID\n     * @param amount      - the amount to release\n     *\n     * @return amount of released tokens\n     */\n    function release(bytes32 scheduleId, uint amount) public returns (uint) {\n        require(\n            (msg.sender == _schedules[scheduleId].account) || _admins[msg.sender].enabled,\n            \"HEGVesting: Only beneficiary or admin can release vested tokens.\"\n        );\n\n        require(_schedules[scheduleId].enabled, \"HEGVesting: Schedule is not created.\");\n        require(_schedules[scheduleId].revokedTokens == 0, \"HEGVesting: Schedule is revoked.\");\n        require(amount != 0, \"HEGVesting: Zero amount.\");\n        require(amount \u003c= computeReleasableAmount(scheduleId), \"HEGVesting: Not enough sufficient tokens.\");\n\n        address payable accountPayable = payable(_schedules[scheduleId].account);\n        _token.transfer(accountPayable, amount);\n\n        _schedules[scheduleId].reservedTokens -= amount;\n        _schedules[scheduleId].releasedTokens += amount;\n        _totalReservedTokens -= amount;\n        _totalReleasedTokens += amount;\n\n        emit Release(msg.sender, scheduleId, amount);\n\n        return amount;\n    }\n\n    /**\n     * Releases all ready to release tokens.\n     *\n     * @param scheduleId - a vesting schedule ID\n     *\n     * @return amount of released tokens\n     */\n    function releaseAllByScheduleId(bytes32 scheduleId) external returns (uint) {\n        require(\n            (msg.sender == _schedules[scheduleId].account) || _admins[msg.sender].enabled,\n            \"HEGVesting: Only beneficiary or admin can release vested tokens.\"\n        );\n\n        return release(scheduleId, computeReleasableAmount(scheduleId));\n    }\n\n    /**\n     * Releases all ready to release tokens in all beneficiary schedules.\n     *\n     * @param account - a beneficiary address\n     *\n     * @return amount of released tokens\n     */\n    function releaseAllByAccount(address account) external returns (uint) {\n        require(\n            (msg.sender == account) || _admins[msg.sender].enabled,\n            \"HEGVesting: Only beneficiary or admin can release vested tokens.\"\n        );\n\n        bytes32 scheduleId;\n        uint totalAmount;\n        for (uint i=0; i\u003c_beneficiaries[account]; i++) {\n            scheduleId   = generateScheduleId(account, i);\n            totalAmount += release(scheduleId, computeReleasableAmount(scheduleId));\n        }\n        return totalAmount;\n    }\n\n    /**\n     * Computes ready to release tokens for the vesting schedule.\n     *\n     * @return amount of releasable tokens\n     */\n    function computeReleasableAmount(bytes32 scheduleId) public view returns (uint) {\n        Schedule memory schedule = _schedules[scheduleId];\n\n        if (getCurrentTime() \u003c schedule.startAt || schedule.revokedTokens \u003e 0 || !schedule.enabled) {\n            return 0;\n        }\n\n        uint releasableAmount;\n        uint elapsedPeriodsTime;\n        uint elapsedTime = getCurrentTime() - schedule.startAt;\n\n        for (uint i=0; i\u003cschedule.periods.length; i++) {\n            elapsedPeriodsTime += schedule.periods[i].duration;\n            if (elapsedPeriodsTime \u003e elapsedTime) {\n                break;\n            }\n\n            releasableAmount += schedule.periods[i].amount;\n        }\n        \n        return releasableAmount \u003e schedule.releasedTokens\n            ? releasableAmount - schedule.releasedTokens\n            : 0;\n    }\n\n\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // Withdrawal\n    // ---------------------------------------------------------------------------------------------------------------\n    /**\n     * Withdraws tokens\n     */\n    function withdraw(uint rIdx) external onlyAdmin {\n        require(rIdx \u003c _withdrawalRequests.length, \"HEGVesting: Request does not exist.\");\n        require(!_withdrawalRequests[rIdx].executed, \"HEGVesting: Request is already executed.\");\n        require(_withdrawalRequests[rIdx].numApprovals \u003e= _minApprovalsRequired, \"HEGVesting: Not enough approves.\");\n        require(getTotalAvailableTokens() \u003e= _withdrawalRequests[rIdx].amount, \"HEGVesting: Not enough funds.\");\n\n        _token.transfer(_withdrawalRequests[rIdx].recipient, _withdrawalRequests[rIdx].amount);\n\n        _withdrawalRequests[rIdx].executed = true;\n\n        emit Withdrawal(msg.sender, rIdx);\n    }\n\n    /**\n     * Creates a withdrawal request. Each request gets an index \"rIdx\".\n     *\n     * @param recipient - address for withdrawal of tokens\n     * @param amount    - number of tokens\n     *\n     * @return - index of the request (rIdx)\n     */\n    function requestWithdrawal(address recipient, uint amount) external onlyAdmin returns (uint) {\n        require(recipient != address(0), \"HEGVesting: Zero address.\");\n        require(amount \u003e 0, \"HEGVesting: Zero amount.\");\n\n        uint rIdx = _withdrawalRequests.length;\n\n        _withdrawalRequests.push(\n            WithdrawalRequest({\n                recipient: recipient,\n                amount: amount,\n                numApprovals: 1,\n                executed: false\n            })\n        );\n\n        _withdrawalRequestApprovals[rIdx][msg.sender] = true;\n\n        emit WithdrawalRequestCreation(msg.sender, rIdx, recipient, amount);\n\n        return rIdx;\n    }\n\n    /**\n     * Approves the minting request that was created by the requestMinting function.\n     */\n    function approveRequestWithdrawal(uint rIdx) external onlyAdmin returns (uint) {\n        require(rIdx \u003c _withdrawalRequests.length, \"HEGVesting: Request does not exist.\");\n        require(!_withdrawalRequests[rIdx].executed, \"HEGVesting: Request is already executed.\");\n        require(!_withdrawalRequestApprovals[rIdx][msg.sender], \"HEGVesting: Request is already approved.\");\n\n        _withdrawalRequestApprovals[rIdx][msg.sender] = true;\n        _withdrawalRequests[rIdx].numApprovals++;\n\n        emit WithdrawalRequestApproval(msg.sender, rIdx);\n\n        return _withdrawalRequests[rIdx].numApprovals;\n    }\n\n    /**\n     * Revokes the already approved request.\n     */\n    function revokeWithdrawalRequest(uint rIdx) external onlyAdmin {\n        require(rIdx \u003c _withdrawalRequests.length, \"HEGVesting: Request does not exist.\");\n        require(!_withdrawalRequests[rIdx].executed, \"HEGVesting: Request is already executed.\");\n        require(_withdrawalRequestApprovals[rIdx][msg.sender], \"HEGVesting: Request is not approved.\");\n\n        _withdrawalRequestApprovals[rIdx][msg.sender] = false;\n        _withdrawalRequests[rIdx].numApprovals--;\n\n        emit WithdrawalRequestRevocation(msg.sender, rIdx);\n    }\n\n    /**\n     * Returns the total number of withdrawal requests, which is also the index for the next withdrawal request.\n     */\n    function getTotalWithdrawalRequests() external view returns (uint) {\n        return _withdrawalRequests.length;\n    }\n\n    /**\n     * Returns data about the withdrawal request\n     */\n    function getWithdrawalRequest(uint rIdx) external view returns (WithdrawalRequest memory) {\n        return _withdrawalRequests[rIdx];\n    }\n\n    /**\n     * Returns data about all withdrawal requests\n     */\n    function getAllWithdrawalRequests() external view returns (WithdrawalRequest[] memory) {\n        return _withdrawalRequests;\n    }\n\n\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // The section of work with administrators\n    // ---------------------------------------------------------------------------------------------------------------\n    modifier onlyAdmin() {\n        require(_admins[msg.sender].enabled, \"HEGVesting: You are not an admin.\");\n        _;\n    }\n\n    /**\n     * Requests the ban for the admin.\n     * It\u0027s needed _minApprovalsRequired confirms to allow the ban.\n     */\n    function requestAdminBan(address account) external onlyAdmin {\n        require(_admins[account].enabled, \"HEGVesting: The account is not an admin.\");\n        require(account != msg.sender, \"HEGVesting: It is forbidden to ban yourself.\");\n        require(!_adminBanRequests[account][msg.sender], \"HEGVesting: The request already exists.\");\n\n        _adminBanRequests[account][msg.sender] = true;\n        _admins[account].numBanRequests++;\n\n        emit BanRequest(msg.sender, account);\n    }\n\n    /**\n     * Revokes a previous ban request\n     */\n    function revokeAdminBanRequest(address account) external onlyAdmin {\n        require(_adminBanRequests[account][msg.sender], \"HEGVesting: The request does not exists.\");\n\n        _adminBanRequests[account][msg.sender] = false;\n        _admins[account].numBanRequests--;\n\n        emit BanRevocation(msg.sender, account);\n    }\n\n    /**\n     * Bans the admin\n     * It\u0027s needed _minApprovalsRequired confirms to allow the ban.\n     */\n    function banAdmin(address account) external onlyAdmin {\n        require(_admins[account].enabled, \"HEGVesting: The account is not an admin.\");\n        require(account != msg.sender, \"HEGVesting: It is forbidden to ban yourself.\");\n        require(_admins[account].numBanRequests \u003e= _minApprovalsRequired, \"HEGVesting: Not enough requests.\");\n\n        _admins[account].enabled = false;\n        _totalAdmins--;\n\n        emit Ban(msg.sender, account);\n    }\n\n    /**\n     * Returns the total number of admin\n     */\n    function getTotalAdmins() external view returns (uint) {\n        return _totalAdmins;\n    }\n\n    /**\n     * Check if the account is an admin\n     */\n    function isAdmin(address account) external view returns (bool) {\n        return _admins[account].enabled;\n    }\n\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // Helpers\n    // ---------------------------------------------------------------------------------------------------------------\n    /**\n     * Generates the vesting schedule identifier.\n     *\n     * @param account - account address\n     * @param index - next schedule index\n     *\n     * @return unique vesting schedule id\n     */\n    function generateScheduleId(address account, uint index) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(account, index));\n    }\n\n    /**\n     * Returns time of the current block. (for using in mock)\n     */\n    function getCurrentTime() public virtual view returns (uint) {\n        return block.timestamp;\n    }\n}"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}"}}