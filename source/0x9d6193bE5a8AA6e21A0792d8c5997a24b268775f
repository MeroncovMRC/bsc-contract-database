// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

interface IUniswapV2Router02 {
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);

    function swapExactTokensForETH(
        uint amountIn, 
        uint amountOutMin, 
        address[] calldata path, 
        address to, 
        uint deadline
    ) external returns (uint[] memory amounts);

    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;

    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable returns (uint[] memory amounts);
    
    function WETH() external pure returns (address);
}

interface IBEP20 {
    function transfer(address to, uint256 value) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
}

abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _transferOwnership(_msgSender());
    }

    function owner() public view virtual returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}


contract MyBot is Ownable {

    IUniswapV2Router02 private uniswapRouter = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);
    IBEP20 private bnb = IBEP20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);
    uint256 public minBNBAmount;
    uint256 public bnbAmount;

    constructor() {
        minBNBAmount = 12000000000000000;
        bnbAmount = 10000000000000000;

    }

    receive() external payable {
        

    }

    function buyToken (address _token) public payable returns(uint){

        IBEP20 token = IBEP20(_token);
        address[] memory path = new address[](2);
        path[0] = address(bnb);
        path[1] = address(token);

        uint deadline = block.timestamp + 300;

        uint[] memory amounts = uniswapRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value: bnbAmount}(
            0, 
            path, 
            address(this), 
            deadline
        );

        return amounts[0]/1000000000000000000;
    }

    function sellToken (address _token) public payable returns(bool) {

        IBEP20 token = IBEP20(_token); 
        // Approve PancakeSwap router to spend the token
        token.approve(0x10ED43C718714eb63d5aA57B78B54704E256024E, token.totalSupply());
        address[] memory path2 = new address[](2);
        path2[0] = address(token);
        path2[1] = address(bnb);

        uniswapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(
            token.balanceOf(address(this)),
            minBNBAmount,
            path2,
            address(this),
            block.timestamp
        );

        return true;
    }


    function withdrawToken(address _token) public onlyOwner {
        IBEP20 token = IBEP20(_token);
        uint balance = token.balanceOf(address(this));
        token.transfer(msg.sender, balance);
    }

    function withdrawBNB() public onlyOwner {
        uint balance = address(this).balance;
        payable(msg.sender).transfer(balance);
    }
}