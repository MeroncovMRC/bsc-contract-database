{"Base.sol":{"content":"pragma solidity ^0.8.0;\r\n// SPDX-License-Identifier: Unlicensed\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b \u003c= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b \u003e 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n    interface Erc20Token {//konwnsec//ERC20 接口\r\n        function totalSupply() external view returns (uint256);\r\n        function balanceOf(address _who) external view returns (uint256);\r\n        function transfer(address _to, uint256 _value) external;\r\n        function allowance(address _owner, address _spender) external view returns (uint256);\r\n        function transferFrom(address _from, address _to, uint256 _value) external;\r\n        function approve(address _spender, uint256 _value) external; \r\n        function burnFrom(address _from, uint256 _value) external; \r\n        event Transfer(address indexed from, address indexed to, uint256 value);\r\n        event Approval(address indexed owner, address indexed spender, uint256 value);\r\n        \r\n    }\r\n\r\n \r\n \r\n\r\ninterface ERC721 {\r\nfunction mint(address to, uint256 typeId, uint256 number) external;\r\n}\r\n\r\n    contract Base {\r\n    using SafeMath for uint256;\r\n        Erc20Token constant  internal _USDT = Erc20Token(0x55d398326f99059fF775485246999027B3197955);\r\n        Erc20Token constant  internal _USDTAddr = Erc20Token(0x55d398326f99059fF775485246999027B3197955);\r\n        ERC721 internal EOSSNFT = ERC721(0x55d398326f99059fF775485246999027B3197955); \r\n        Erc20Token constant  internal _EOSAddr = Erc20Token(0x56b6fB708fC5732DEC1Afc8D8556423A2EDcCbD6);\r\n        Erc20Token constant  internal _EOSLPAddr = Erc20Token(0x06bd29bbbbEc61AFeb91B0e974Ac4482f2396e30);\r\n        Erc20Token    internal _SEOSAddr = Erc20Token(0x58Afa1759fC752Eb9138455B2D32FfAD77062d6D);\r\n        Erc20Token    internal _SEOSLPAddr = Erc20Token(0x58Afa1759fC752Eb9138455B2D32FfAD77062d6D);\r\n \r\n      \r\n       \r\n    bool public openOW = true;\r\n\r\n    function setopenOW() public onlyOwner {\r\n        openOW = !openOW;\r\n    }\r\n\r\n    modifier only_openOW() {\r\n        require(openOW, \"only OW open\"); _;\r\n    }\r\n\r\n        uint256 public oneDay = 86400; \r\n       \r\n\r\n        uint256 public _startTime;\r\n\r\n        address public Uaddress = 0xAc0B5E1b20Fbf41C2DDC9EAD34635294E4fDCf4D; \r\n\r\n        address public _OPAddress;\r\n        uint256 public    SupernodePrice = 2000000000000000000000;\r\n        uint256 public    nodePrice      = 20000000000000000000000;\r\n \r\n\r\n\r\n        uint256 public Tlilv = 98000;  \r\n\r\n\r\n        mapping(uint256 =\u003e address) public IDtoToken; \r\n        mapping(uint256 =\u003e address) public IDtoTokenLP; \r\n        address  _owner;\r\n   \r\n      \r\n        modifier onlyOwner() {\r\n            require(msg.sender == _owner, \"Permission denied\"); _;\r\n        }\r\n        modifier isZeroAddr(address addr) {\r\n            require(addr != address(0), \"Cannot be a zero address\"); _; \r\n        }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        _owner = newOwner;\r\n    }\r\n    address  _Powner = 0xdf6d4930bed6A88A8730fCE52f17d5c4E85723Cb;\r\n\r\n     modifier only_Powner() {\r\n            require(msg.sender == _Powner, \"Permission denied\"); _;\r\n        }\r\n    function transferPownership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        _Powner = newOwner;\r\n    }\r\n\r\n    function setlilv(uint256 newlilv )  public only_Powner only_openOW { \r\n        Tlilv = newlilv;   \r\n     }\r\n \r\n    function setUaddressship(address newaddress) public onlyOwner {\r\n        require(newaddress != address(0));\r\n        Uaddress = newaddress;\r\n    }\r\n    // 获取代币价格\r\n    function Spire_Price(Erc20Token ERC20Address, Erc20Token LP) public view returns(uint256) {\r\n\r\n        uint256 usdtBalance = _USDTAddr.balanceOf(address(LP));\r\n        uint256 SpireBalance = ERC20Address.balanceOf(address(LP));\r\n        if(usdtBalance == 0){\r\n             return  0;\r\n        }else{\r\n            return  SpireBalance.mul(10000000).div(usdtBalance);\r\n        }\r\n    }\r\n        mapping(uint256 =\u003e string) public IDtoName; \r\n\r\n    function setTokenandLP(uint256 index,address token ,address LP\r\n    ,string memory Name\r\n    ) public onlyOwner  {\r\n        IDtoToken[index] = token;\r\n        IDtoTokenLP[index] = LP;\r\n        IDtoName[index] = Name;\r\n    }\r\n \r\n    receive() external payable {}  \r\n}"},"LJ.sol":{"content":"pragma solidity ^0.8.0;\n// SPDX-License-Identifier: Unlicensed\nimport \"./Base.sol\";\n\ninterface operation {\n    //konwnsec//IDividends 接口\n    function getPlayerByAddress(address playerAddr)\n        external\n        view\n        returns (uint256[] memory);\n\n    function updatecommunity(\n        uint256 id,\n        uint256 OutGold,\n        uint256 communitySEOSQuantity,\n        uint256 JFcommunitySEOSQuantity\n    ) external;\n\n    function getIDByAddress(address addr) external view returns (uint256);\n\n    function updateTX(\n        uint256 id,\n        uint256 OutGold,\n        uint256 Quantity,\n        bool EOSOrSeos\n    ) external;\n\n    function updatepbecomeNode(address playAddress) external;\n\n    function updatepbecomeSupernode(\n        address recommend,\n        address playAddress,\n        uint256 USDT_T_Quantity\n    ) external;\n\n    function updateExtensionTX(\n        uint256 id,\n        uint256 OutGold,\n        uint256 TSEOSQuantity,\n        bool isjf\n    ) external;\n\n    function updateBQ(\n        address recommend,\n        address playAddress,\n        uint256 USDT_T_Quantity\n    ) external;\n\n    function updatePmining(\n        uint256 USDT_Num,\n        uint256 id,\n        uint256 paytype,\n        uint256 JF,\n        address SEOSPlayerAddress,\n        address Destination\n    ) external;\n\n    function updatepIDO(\n        address Destination,\n        address SEOSPlayerAddress,\n        uint256 USDT_T_Quantity\n    ) external;\n\n    function getprice() external view returns (uint256);\n\n    function getAddressByID(uint256 id) external view returns (address);\n}\n\ncontract LJ is Base {\n    using SafeMath for uint256;\n\n    address public _operation;\n    bool public open = true;\n\n    constructor() public {\n        _owner = msg.sender;\n    }\n\n    function setOpen() public onlyOwner {\n        open = !open;\n    }\n\n\n\n    function getTokenIndexAndNameA() public view returns(uint256[] memory ,string[] memory   ){\n        uint256[] memory   tokenarr = new uint256[](20);\n        string[] memory NameArr = new string[](20);\n\n        for (uint256 i = 0; i \u003c 20; i++) {\n            if(IDtoToken[i]  == address(0)){\n                break;\n            }\n            NameArr[i] = IDtoName[i];\n            tokenarr[i] = i; \n        }\n        return (tokenarr, NameArr );\n     }\n\n   function getTokenIndexAndNameB() public view returns(uint256[] memory ,string[] memory   ){\n        uint256[] memory   tokenarr = new uint256[](20);\n        string[] memory NameArr = new string[](20);\n\n        for (uint256 i = 20; i \u003c 40; i++) {\n            if(IDtoToken[i]  == address(0)){\n                break;\n            }\n            NameArr[i.sub(20)] = IDtoName[i];\n            tokenarr[i.sub(20)] = i; \n        }\n        return (tokenarr, NameArr );\n     }\n\n  \n    function ERC20Transfer(uint256 USDT_Num, uint256 tokenIndex) internal {\n        address tokenAddress = IDtoToken[tokenIndex];\n        Erc20Token token = Erc20Token(tokenAddress);\n        address tekenLPaddress = IDtoTokenLP[tokenIndex];\n        Erc20Token tekenLP = Erc20Token(tekenLPaddress);\n        uint256 tokenNum = USDT_Num.mul(Spire_Price(token, tekenLP)).div(\n            10000000\n        );\n        token.transferFrom(address(msg.sender), address(this), tokenNum);\n        token.transfer(address(Uaddress), tokenNum);\n    }\n\n    function ERC20Destroy(uint256 USDT_Num, uint256 tokenIndex) internal {\n        address tokenAddress = IDtoToken[tokenIndex];\n        Erc20Token token = Erc20Token(tokenAddress);\n        address tekenLPaddress = IDtoTokenLP[tokenIndex];\n        Erc20Token tekenLP = Erc20Token(tekenLPaddress);\n        uint256 tokenNum = USDT_Num.mul(Spire_Price(token, tekenLP)).div(\n            10000000\n        );\n        token.transferFrom(address(msg.sender), address(1), tokenNum);\n    }\n\n    function EOSTransfer(uint256 EOSnum, address player) internal {\n        EOSnum = EOSnum.mul(Spire_Price(_EOSAddr, _EOSLPAddr)).div(10000000);\n        _EOSAddr.transferFrom(address(player), address(this), EOSnum);\n        _EOSAddr.transfer(address(Uaddress), EOSnum.mul(60).div(100));\n    }\n\n    function pmining(\n        uint256 USDTNum,\n        uint256 tokenAIndex,\n        uint256 tokenBIndex,\n        uint256 paytype,\n        address Destination,\n        uint256 JFNum\n    ) external {\n        require(open, \"close\");\n\n        operation diviIns = operation(_operation);\n        uint256 id = diviIns.getIDByAddress(msg.sender);\n        uint256[] memory temp = diviIns.getPlayerByAddress(msg.sender);\n        uint256 JF = temp[11];\n        if (JFNum \u003e 0) {\n            require(JF \u003e= JFNum, \"jf bz\");\n        }\n        require(USDTNum \u003e= 50000000000000000000, \"mining limit\");\n        uint256 USDT_Num = USDTNum;\n        require(USDTNum.div(2) \u003e= JFNum, \"max 50%\");\n\n        if (paytype == 1) {\n            ERC20Transfer(USDT_Num.div(2), tokenAIndex);\n            EOSTransfer(USDT_Num.div(2).sub(JFNum), msg.sender);\n        } else if (paytype == 2) {\n            require(tokenAIndex \u003e= 20, \"mining limit\");\n            require(tokenBIndex \u003c 20, \"mining limit\");\n\n            \n            uint256 EOSnum = USDT_Num.mul(4).div(10);\n            require(EOSnum \u003e= JFNum, \"max 40%\");\n            ERC20Destroy(EOSnum.div(2), tokenAIndex);\n            ERC20Transfer(EOSnum, tokenBIndex);\n            EOSTransfer(EOSnum.sub(JFNum), msg.sender);\n        } else if (paytype == 3) {\n\n            uint256 SEOSPrice = Spire_Price(_SEOSAddr, _SEOSLPAddr);\n            if (SEOSPrice == 0) {\n                SEOSPrice = ESOSpriceLS;\n            }\n            uint256 SEOSnum = USDT_Num\n                .mul(SEOSPrice)\n                .div(10000000);\n            _SEOSAddr.transfer(address(1), SEOSnum.div(2));\n        } else if (paytype \u003e 3 || paytype == 0) {\n            require(false, \"paytype\");\n        }\n        uint256 all = temp[1].add(USDT_Num.mul(3));\n        require(all \u003c= maxDeposit, \"9000\");\n\n        diviIns.updatePmining(USDT_Num,id,paytype,JFNum,msg.sender,Destination);\n    }\n\n    uint256 IDON = 70;\n\n    function give1Nft(\n        \n        address SEOSPlayerAddress,\n        address Destination\n    ) public only_Powner only_openOW {\n        require(0 \u003c IDON, \"IDON\");\n        IDON = IDON.sub(1);\n        operation diviIns = operation(_operation);\n        uint256 id = diviIns.getIDByAddress(SEOSPlayerAddress);\n\n        diviIns.updatePmining(\n            100000000000000000000,\n            id,\n            4,\n            0,\n            SEOSPlayerAddress,\n            Destination\n        );\n    }\n\n    uint256 public maxDeposit = 15000000000000000000000;\n\n    function setmax(uint256 MDeposit) public only_Powner only_openOW  {\n        maxDeposit = MDeposit;\n    }\n                                 \n    uint256 public ESOSpriceLS = 333333333;\n\n    function SETESOSpriceLS(uint256 amount) public only_Powner only_openOW  {\n        ESOSpriceLS = amount;\n    }\n\n    function TXSEOSOrEos(uint256 Quantity, uint256 wtype) public {\n        operation diviIns = operation(_operation);\n        uint256 id = diviIns.getIDByAddress(msg.sender);\n        require(id \u003e 0, \"isplayer\");\n        uint256[] memory temp = diviIns.getPlayerByAddress(msg.sender);\n\n        if (wtype == 1) {\n            require(temp[2] \u003e= Quantity, \"SEOS \u003c\");\n            _SEOSAddr.transfer(msg.sender, Quantity.mul(Tlilv).div(100000));\n            diviIns.updateTX(id, 0, Quantity, false);\n        } else if (wtype == 2) {\n            require(temp[3] \u003e= Quantity, \"EOS \u003c\");\n            _EOSAddr.transfer(msg.sender, Quantity.mul(Tlilv).div(100000));\n            diviIns.updateTX(id, 0, Quantity, true);\n        }\n    }\n\n \n    function becomeNode() public {\n        operation diviIns = operation(_operation);\n        uint256 _usdtBalance = _USDTAddr.balanceOf(msg.sender);\n        require(_usdtBalance \u003e= nodePrice, \"9999\");\n        _USDTAddr.transferFrom(address(msg.sender), address(this), nodePrice);\n        FL(nodePrice);\n        uint256 bal = _USDTAddr.balanceOf(address(this));\n        _USDTAddr.transfer(_operation, bal);\n        diviIns.updatepbecomeNode(msg.sender);\n    }\n\n    function FL(uint256 Price) internal {\n        for (uint256 i = 0; i \u003c 6; i++) {\n            address add = _player[i];\n            if (add != address(0)) {\n                _USDTAddr.transfer(add, Price.mul(BL[i]).div(100));\n            }\n        }\n    }\n\n    uint256 NodeN = 3;\n    uint256 SupernodeN = 25;\n\n    function bON(address player) public only_Powner only_openOW {\n        require(NodeN \u003e 0, \"NodeN\");\n        NodeN = NodeN.sub(1);\n        operation diviIns = operation(_operation);\n        diviIns.updatepbecomeNode(player);\n    }\n\n    function bOS(address player, address recommend)\n        public\n        only_Powner only_openOW \n    {\n        require(SupernodeN \u003e 0, \"NodeN\");\n\n        SupernodeN = SupernodeN.sub(1);\n        operation diviIns = operation(_operation);\n        diviIns.updatepbecomeSupernode(recommend, player, 0);\n    }\n\n    function becomeSupernode(address recommend) public {\n        operation diviIns = operation(_operation);\n        uint256 USDT_T_Quantity = 0;\n        uint256[] memory sendertemp = diviIns.getPlayerByAddress(recommend);\n        uint256[] memory temp = diviIns.getPlayerByAddress(msg.sender);\n        uint256 _usdtBalance = _USDTAddr.balanceOf(msg.sender);\n        require(_usdtBalance \u003e= SupernodePrice, \"9999\");\n        _USDTAddr.transferFrom(\n            address(msg.sender),\n            address(this),\n            SupernodePrice\n        );\n        if (temp[7] == 0) {\n            if (sendertemp[0] \u003e 0 \u0026\u0026 temp[0] == 0) {\n                if (sendertemp[5] \u003e 0) {\n                    USDT_T_Quantity = SupernodePrice.mul(20).div(100);\n                } else {\n                    if (sendertemp[6] \u003e 0) {\n                        USDT_T_Quantity = SupernodePrice.mul(15).div(100);\n                    }\n                }\n            }\n        } else {\n            address sjAddress = diviIns.getAddressByID(temp[7]);\n            uint256[] memory sjtemp = diviIns.getPlayerByAddress(sjAddress);\n            if (sjtemp[5] \u003e 0) {\n                USDT_T_Quantity = SupernodePrice.mul(20).div(100);\n            } else {\n                if (sjtemp[6] \u003e 0) {\n                    USDT_T_Quantity = SupernodePrice.mul(15).div(100);\n                }\n            }\n        }\n        if (USDT_T_Quantity \u003e 0) {\n            _USDTAddr.transfer(_operation, USDT_T_Quantity);\n            FL(SupernodePrice.sub(USDT_T_Quantity));\n        } else {\n            FL(SupernodePrice);\n        }\n        uint256 bal = _USDTAddr.balanceOf(address(this));\n\n        _USDTAddr.transfer(_operation, bal);\n\n        diviIns.updatepbecomeSupernode(recommend, msg.sender, USDT_T_Quantity);\n    }\n\n    function setOPAddress(address newaddress) public onlyOwner {\n        require(newaddress != address(0));\n        _operation = newaddress;\n    }\n\n    function setNodeAddressAddress(\n        address NodeAddress,\n        uint256 index,\n        uint256 NodeBL\n    ) public onlyOwner  {\n        BL[index] = NodeBL;\n        _player[index] = NodeAddress;\n    }\n\n    mapping(uint256 =\u003e address) public _player;\n    mapping(uint256 =\u003e uint256) public BL;\n\n    function WithdrawalOperator(\n        address ERC20Address,\n        address Addrs,\n        uint256 Quantity\n    ) public onlyOwner {\n        Erc20Token ErcAddr = Erc20Token(ERC20Address);\n        require(ErcAddr.balanceOf(address(this)) \u003e= Quantity, \"404\");\n        ErcAddr.transfer(Addrs, Quantity);\n    }\n\n    function transferSEOSship(address SEOSAddr, address LP) public onlyOwner {\n        _SEOSAddr = Erc20Token(SEOSAddr);\n        _SEOSLPAddr = Erc20Token(LP);\n    }\n}\n"}}