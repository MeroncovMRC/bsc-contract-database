// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

contract Ownable {
    address private owner;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "Only the owner can call this function");
        _;
    }

    function transferOwnership(address newOwner) external onlyOwner {
        require(newOwner != address(0), "Invalid owner");
        owner = newOwner;
    }
}

interface IERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
}

contract MultiSwapContract is Ownable {
    address private routerAddress1;
    address private routerAddress2;

    constructor(address _routerAddress1, address _routerAddress2) {
        require(_routerAddress1 != address(0) && _routerAddress2 != address(0), "Invalid router addresses");
        routerAddress1 = _routerAddress1;
        routerAddress2 = _routerAddress2;
    }

    function changeRouterAddresses(address newRouterAddress1, address newRouterAddress2) external onlyOwner {
        require(newRouterAddress1 != address(0) && newRouterAddress2 != address(0), "Invalid router addresses");
        routerAddress1 = newRouterAddress1;
        routerAddress2 = newRouterAddress2;
    }

    function multiSwapExactTokensForETH(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address payable to,
        uint256 deadline
    ) external {
        require(path.length > 1, "Invalid path");

        for (uint256 i = 0; i < path.length - 1; i++) {
            bool swapSuccess = swapExactTokensForETH(routerAddress1, amountIn, amountOutMin, path[i], path[i+1], to, deadline);

            // Perform the second swap using the second router if the first swap failed
            if (!swapSuccess) {
                swapExactTokensForETH(routerAddress2, amountIn, amountOutMin, path[i], path[i+1], to, deadline);
            }
        }

        // Transfer the received ETH to the specified recipient
        safeTransferETH(to, address(this).balance);
    }

    function multiSwapExactTokensForETHSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address payable to,
        uint256 deadline
    ) external {
        require(path.length > 1, "Invalid path");

        for (uint256 i = 0; i < path.length - 1; i++) {
            bool swapSuccess = swapExactTokensForETHSupportingFeeOnTransferTokens(
                routerAddress1,
                amountIn,
                amountOutMin,
                path[i],
                path[i + 1],
                to,
                deadline
            );

            // Perform the second swap using the second router if the first swap failed
            if (!swapSuccess) {
                swapExactTokensForETHSupportingFeeOnTransferTokens(
                    routerAddress2,
                    amountIn,
                    amountOutMin,
                    path[i],
                    path[i + 1],
                    to,
                    deadline
                );
            }
        }

        // Transfer the received ETH to the specified recipient
        safeTransferETH(to, address(this).balance);
    }

    function multiSwapExactETHForTokensSupportingFeeOnTransferTokens(
        uint256 amountOutMin,
        address[] calldata path,
        address payable to,
        uint256 deadline
    ) external payable {
        require(path.length > 1, "Invalid path");

        for (uint256 i = 0; i < path.length - 1; i++) {
            bool swapSuccess = swapExactETHForTokensSupportingFeeOnTransferTokens(
                routerAddress1,
                amountOutMin,
                path[i],
                path[i + 1],
                to,
                deadline
            );

            // Perform the second swap using the second router if the first swap failed
            if (!swapSuccess) {
                swapExactETHForTokensSupportingFeeOnTransferTokens(
                    routerAddress2,
                    amountOutMin,
                    path[i],
                    path[i + 1],
                    to,
                    deadline
                );
            }
        }
    }

    function multiSwapExactETHForTokens(
        uint256 amountOutMin,
        address[] calldata path,
        address payable to,
        uint256 deadline
    ) external payable {
        require(path.length > 1, "Invalid path");

        for (uint256 i = 0; i < path.length - 1; i++) {
            bool swapSuccess = swapExactETHForTokens(
                routerAddress1,
                amountOutMin,
                path[i],
                path[i + 1],
                to,
                deadline
            );

            // Perform the second swap using the second router if the first swap failed
            if (!swapSuccess) {
                swapExactETHForTokens(
                    routerAddress2,
                    amountOutMin,
                    path[i],
                    path[i + 1],
                    to,
                    deadline
                );
            }
        }
    }

    function multiSwapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external {
        require(path.length > 1, "Invalid path");

        for (uint256 i = 0; i < path.length - 1; i++) {
            bool swapSuccess = swapExactTokensForTokensSupportingFeeOnTransferTokens(
                routerAddress1,
                amountIn,
                amountOutMin,
                path[i],
                path[i + 1],
                to,
                deadline
            );

            // Perform the second swap using the second router if the first swap failed
            if (!swapSuccess) {
                swapExactTokensForTokensSupportingFeeOnTransferTokens(
                    routerAddress2,
                    amountIn,
                    amountOutMin,
                    path[i],
                    path[i + 1],
                    to,
                    deadline
                );
            }
        }
    }

    function multiSwapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external {
        require(path.length > 1, "Invalid path");

        for (uint256 i = 0; i < path.length - 1; i++) {
            bool swapSuccess = swapExactTokensForTokens(
                routerAddress1,
                amountIn,
                amountOutMin,
                path[i],
                path[i + 1],
                to,
                deadline
            );

            // Perform the second swap using the second router if the first swap failed
            if (!swapSuccess) {
                swapExactTokensForTokens(
                    routerAddress2,
                    amountIn,
                    amountOutMin,
                    path[i],
                    path[i + 1],
                    to,
                    deadline
                );
            }
        }
    }

    function swapExactTokensForETH(
        address router,
        uint256 amountIn,
        uint256 amountOutMin,
        address token0,
        address token1,
        address payable to,
        uint256 deadline
    ) internal returns (bool) {
        (bool success, ) = router.call(
            abi.encodeWithSignature(
                "swapExactTokensForETH(uint256,uint256,address[],address,uint256)",
                amountIn,
                amountOutMin,
                [token0, token1],
                to,
                deadline
            )
        );

        return success;
    }

    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        address router,
        uint256 amountIn,
        uint256 amountOutMin,
        address token0,
        address token1,
        address payable to,
        uint256 deadline
    ) internal returns (bool) {
        (bool success, ) = router.call(
            abi.encodeWithSignature(
                "swapExactTokensForETHSupportingFeeOnTransferTokens(uint256,uint256,address[],address,uint256)",
                amountIn,
                amountOutMin,
                [token0, token1],
                to,
                deadline
            )
        );

        return success;
    }

    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        address router,
        uint256 amountOutMin,
        address token0,
        address token1,
        address payable to,
        uint256 deadline
    ) internal returns (bool) {
        (bool success, ) = router.call{value: msg.value}(
            abi.encodeWithSignature(
                "swapExactETHForTokensSupportingFeeOnTransferTokens(uint256,address[],address,uint256)",
                amountOutMin,
                [token0, token1],
                to,
                deadline
            )
        );

        return success;
    }

    function swapExactETHForTokens(
        address router,
        uint256 amountOutMin,
        address token0,
        address token1,
        address payable to,
        uint256 deadline
    ) internal returns (bool) {
        (bool success, ) = router.call{value: msg.value}(
            abi.encodeWithSignature(
                "swapExactETHForTokens(uint256,address[],address,uint256)",
                amountOutMin,
                [token0, token1],
                to,
                deadline
            )
        );

        return success;
    }

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        address router,
        uint256 amountIn,
        uint256 amountOutMin,
        address token0,
        address token1,
        address to,
        uint256 deadline
    ) internal returns (bool) {
        IERC20(token0).approve(router, amountIn);

        (bool success, ) = router.call(
            abi.encodeWithSignature(
                "swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256,uint256,address[],address,uint256)",
                amountIn,
                amountOutMin,
                [token0, token1],
                to,
                deadline
            )
        );

        return success;
    }

    function swapExactTokensForTokens(
        address router,
        uint256 amountIn,
        uint256 amountOutMin,
        address token0,
        address token1,
        address to,
        uint256 deadline
    ) internal returns (bool) {
        IERC20(token0).approve(router, amountIn);

        (bool success, ) = router.call(
            abi.encodeWithSignature(
                "swapExactTokensForTokens(uint256,uint256,address[],address,uint256)",
                amountIn,
                amountOutMin,
                [token0, token1],
                to,
                deadline
            )
        );

        return success;
    }

    function safeTransferETH(address payable to, uint256 amount) internal {
        (bool success, ) = to.call{value: amount}("");
        require(success, "Transfer failed");
    }
}