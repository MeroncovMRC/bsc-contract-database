{"IERC20.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.19;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n}"},"IPancakeRouter.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.19;\n\ninterface IPancakeRouter {\n\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure returns (uint256 amountB);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountOut);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountIn);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\n\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n}"},"RageCoin.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.19;\n\nimport \"./IPancakeRouter.sol\";\nimport \"./IERC20.sol\";\n\ncontract RageCoin {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    bool public paused;\n    address public owner;\n    string private _name;\n    string private _symbol;\n    uint256 private _totalSupply;\n    uint8 private _decimals;\n    address public immutable token;\n    mapping(address =\u003e bool) public whitelist;\n    mapping(address =\u003e mapping(address =\u003e uint256)) private _allowances;\n    mapping(address =\u003e uint256) private _balances;\n    mapping(address =\u003e uint256) private lastSwapWBNBForExactRGCTime;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only the owner can call this function\");\n        _;\n    }\n\n    constructor() {\n        token = address(this);\n        owner = msg.sender;\n        _name = \"RageCoin\";\n        _symbol = \"RGC\";\n        _decimals = 18;\n        uint256 initialSupply = 999_000_000 * (10 ** uint256(_decimals));\n        uint256 ownerAmount = 1_000_000 * (10 ** uint256(_decimals));\n        _mint(address(this), initialSupply);\n        _mint(msg.sender, ownerAmount);\n        whitelist[msg.sender] = true;\n        paused = true;\n    }\n\n    function addLiquidity(uint256 tokenAmount, uint256 wbnbAmount) external {\n        address pancakeRouter = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\n        address wbnbToken = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\n\n        IERC20(address(this)).approve(pancakeRouter, tokenAmount);\n        IERC20(wbnbToken).approve(pancakeRouter, wbnbAmount);\n\n        IPancakeRouter router = IPancakeRouter(pancakeRouter);\n        router.addLiquidity(\n            address(this),\n            wbnbToken,\n            tokenAmount,\n            wbnbAmount,\n            0,\n            0,\n            owner,\n            block.timestamp + 120\n        );\n    }\n\n    function removeLiquidity(address lpTokenAddress, uint256 liquidityAmount) external {\n        address pancakeRouter = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\n        address wbnbToken = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\n\n        IERC20(lpTokenAddress).approve(pancakeRouter, liquidityAmount);\n\n        IPancakeRouter router = IPancakeRouter(pancakeRouter);\n        router.removeLiquidity(\n            address(this),\n            wbnbToken,\n            liquidityAmount,\n            0,\n            0,\n            owner,\n            block.timestamp + 120\n        );\n    }\n\n    function swapWBNBForExactRGC(uint256 RGCamount, uint256 WBNBamountMax) external {\n        address pancakeRouter = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\n        address wbnbToken = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\n\n        IERC20(address(this)).approve(pancakeRouter, RGCamount);\n        IERC20(wbnbToken).approve(pancakeRouter, WBNBamountMax);\n\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = wbnbToken;\n\n        IPancakeRouter router = IPancakeRouter(pancakeRouter);\n        router.swapTokensForExactTokens(\n            RGCamount,\n            WBNBamountMax,\n            path,\n            msg.sender,\n            block.timestamp + 120\n        );\n\n        lastSwapWBNBForExactRGCTime[msg.sender] = block.timestamp;\n    }\n\n    function swapExactRGCForWBNB(uint256 RGCamount, uint256 WBNBamountMin) external {\n        require(\n            lastSwapWBNBForExactRGCTime[msg.sender] \u003e 0 \u0026\u0026 block.timestamp - lastSwapWBNBForExactRGCTime[msg.sender] \u003e 14400,\n            \"Transaction failed\"\n        );\n\n        address pancakeRouter = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\n        address wbnbToken = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\n\n        IERC20(address(this)).approve(pancakeRouter, RGCamount);\n        IERC20(wbnbToken).approve(pancakeRouter, WBNBamountMin);\n\n        address[] memory path = new address[](2);\n        path[0] = wbnbToken;\n        path[1] = address(this);\n\n        IPancakeRouter router = IPancakeRouter(pancakeRouter);\n        router.swapExactTokensForTokens(\n            RGCamount,\n            WBNBamountMin,\n            path,\n            msg.sender,\n            block.timestamp + 120\n        );\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function allowance(address account, address spender) public view returns (uint256) {\n        return _allowances[account][spender];\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        require(recipient != address(0), \"Invalid recipient\");\n        require(!paused || whitelist[msg.sender], \"Token transfers are currently paused\");\n\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        require(recipient != address(0), \"Invalid recipient\");\n        require(!paused || whitelist[msg.sender], \"Token transfers are currently paused\");\n\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);\n        return true;\n    }\n\n    function _transfer(address from, address to, uint256 amount) internal {\n        require(from != address(0), \"BEP20: transfer from the zero address\");\n        require(to != address(0), \"BEP20: transfer to the zero address\");\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance \u003e= amount, \"BEP20: transfer amount exceeds balance\");\n\n        _balances[from] = fromBalance - amount;\n        _balances[to] += amount;\n        emit Transfer(from, to, amount);\n    }\n\n    function _approve(address ownerAddr, address spender, uint256 amount) internal {\n        require(ownerAddr != address(0), \"BEP20: approve from the zero address\");\n        require(spender != address(0), \"BEP20: approve to the zero address\");\n\n        _allowances[ownerAddr][spender] = amount;\n        emit Approval(ownerAddr, spender, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"BEP20: mint to the zero address\");\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function pauseTokenTransfers() public onlyOwner {\n        paused = true;\n    }\n\n    function resumeTokenTransfers() public onlyOwner {\n        paused = false;\n    }\n}"}}