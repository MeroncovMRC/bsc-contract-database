
// File: contracts/contracts/redeploy/TeamRedeploy.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.12;

import "../interfaces/storages/ITeam.sol";
import "../interfaces/ContractOwnerV2.sol";

contract TeamRedeploy is ContractOwnerV2
{
    ITeam oldAddress;
    ITeam newAddress;
    constructor( address _old, address _new)
    {
     oldAddress = ITeam(_old);
     newAddress = ITeam(_new);
    }
    function setGroupUser(uint16 start, uint16 end) public
    {
        for (start; start < end; start++)
        {
            uint firstLineStatusLevelCount = oldAddress.getTeamCountStats(start);
            if (firstLineStatusLevelCount > 0)
            {
                for (uint i = 0; i < firstLineStatusLevelCount; i++)
                {
                    newAddress.addTeameStatus(start);
                }
            }
            for (uint8 lvl = 0; lvl < 8;lvl++)
            {
                uint _teamCountForLevel = oldAddress.getTeamCountLVL(start, lvl);
                if (_teamCountForLevel > 0)
                {
                    for (uint i = 0; i < firstLineStatusLevelCount; i++)
                    {
                        newAddress.addTeamer(start, lvl);
                    }  
                }
            }
        }
    }
}

// File: contracts/contracts/interfaces/ContractOwnerV2.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.12;

import "./OwnableV2.sol";

abstract contract ContractOwnerV2 is OwnableV2
{
    address _contractOwner;

    modifier isContractOwner()
    {
        require(msg.sender == _contractOwner, "no access");
        _;
    }
    function setContractOwner(address contractOwner) onlyOwner public 
    {
        _contractOwner = contractOwner;
    }
}

// File: contracts/contracts/interfaces/storages/ITeam.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.12;

interface ITeam
{
    function getTeamCountLVL(uint id, uint8 lvl) external view returns (uint);
    function getTeamCountStats(uint id) external view returns (uint);
    function addTeamer (uint id, uint8 lvl) external;
    function addTeameStatus (uint id) external;
    function clearTeameStatus (uint id)  external;
}

// File: contracts/contracts/interfaces/OwnableV2.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import "./Context.sol";

abstract contract OwnableV2 is Context
{
    address _owner;
    address public _newOwner;
    constructor()  
    {
        _owner = payable(msg.sender);
    }

    modifier onlyOwner() 
    {
        require(_msgSender() == _owner, "Only owner");
        _;
    }

    function changeOwner(address newOwner) onlyOwner public
    {
        _newOwner = newOwner;
    }
    function confirm() public
    {
        require(_newOwner == msg.sender);
        _owner = _newOwner;
    }
}



// File: contracts/contracts/interfaces/Context.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

abstract contract Context 
{
    function _msgSender() internal view virtual returns (address) 
    {
        return msg.sender;
    }
    function _msgData() internal view virtual returns (bytes calldata) 
    {
        this; 
        return msg.data;
    }
}

