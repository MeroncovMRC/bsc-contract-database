{"Smart_Binance.sol":{"content":"// SPDX-License-Identifier: Unlicensed\r\npragma solidity \u003e=0.4.22 \u003c0.9.0;\r\nimport \"./Smart_Binary.sol\";\r\ncontract Smart_Binance is Context {\r\n    using SafeERC20 for IERC20; struct SEP { uint24 LD; uint24 RD; uint8 TCP; uint16 DP; uint8 CH; uint8 OR; address UPA; address LDA; address RDA;}\r\n    mapping(address =\u003e SEP) private _XB; mapping(uint128 =\u003e address) private JK; mapping(uint16 =\u003e address) private _DUP;\r\n    address[] private EW; address[] private _PY; address[] private _X_N; uint32[] private _RNN; uint256 private LSR;\r\n    uint256 private LRF; uint256 private V_F; uint128 private _U_Z; uint128 private ZA_D; uint64 private _CF; uint64 private _CU_PY;\r\n    uint16 private _DUPId; uint8 private Lk; uint8 private Count_Upload; uint8 C_G; address private R_S; address private _SBT; address private Operator;\r\n    IERC20 private S_Coin; string private Note; string private IPFS; Smart_Binary private NBJ;\r\n    constructor() {R_S = _msgSender(); LSR = block.timestamp;\r\n        S_Coin = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\r\n        _SBT = 0x52B5BD79C5B56B52747d735809177d9ee686E48e;\r\n        Operator = 0xF9B29B8853c98B68c19f53F5b39e69eF6eAF1e2c;\r\n        NBJ = Smart_Binary(0x3164B3841D2b603ddB43C909C7f6Efd787058541);}\r\n    function Reward_12() public {require(Lk == 0, \"Proccesing\");\r\n        require(_XB[_msgSender()].TCP \u003e 0, \"You dont have point\" );\r\n        require(block.timestamp \u003e LSR + 12 hours, \"Reward_12 time has not come\");\r\n        Lk = 1; uint256 ZZ = (PRP() * 90) - (Total_Point() * 10**18); V_F = (PRP() * 10);\r\n        uint256 QA = ((ZZ)) / Total_Point(); uint128 R_C = (Total_Point()) * 10**18;\r\n        for(uint128 i = 0; i \u003c= _U_Z; i = unsafe_inc(i)) {SEP memory T_DE = _XB[JK[i]];\r\n        uint24 Pnt; uint24 RLT = T_DE.LD \u003c= T_DE.RD ? T_DE.LD : T_DE.RD;\r\n        if (RLT \u003e 0) {if (RLT \u003e 25) {Pnt = 25; if (T_DE.LD \u003c RLT) { T_DE.LD = 0; T_DE.RD -= RLT;} \r\n        else if (T_DE.RD \u003c RLT) {T_DE.LD -= RLT; T_DE.RD = 0;} else {T_DE.LD -= RLT; T_DE.RD -= RLT;}} else {Pnt = RLT; \r\n        if (T_DE.LD \u003c Pnt) {T_DE.LD = 0; T_DE.RD -= Pnt;} else if (T_DE.RD \u003c Pnt) { T_DE.LD -= Pnt; T_DE.RD = 0;} \r\n        else {T_DE.LD -= Pnt; T_DE.RD -= Pnt;}} T_DE.TCP = 0; _XB[JK[i]] = T_DE;\r\n        if (Pnt * QA \u003e S_Coin.balanceOf(address(this))) {S_Coin.safeTransfer(JK[i],S_Coin.balanceOf(address(this)));} \r\n        else {S_Coin.safeTransfer( JK[i], Pnt * QA);}_PY.push(JK[i]); _CU_PY++;}} LSR = block.timestamp;\r\n        if (R_C \u003c= S_Coin.balanceOf(address(this))) {S_Coin.safeTransfer(_msgSender(), R_C);} Lk = 0; C_G = 1; LRF = block.timestamp;}\r\n    function Register(address upline) public {require(_XB[upline].CH != 2,\"Upline has two directs!\");\r\n        require(_msgSender() != upline, \"You can not enter your address!\");\r\n        bool UU = false; for(uint128 i = 0; i \u003c= _U_Z; i = unsafe_inc(i)) {if (JK[i] == _msgSender()) {UU = true; break;}} require(UU == false, \"You were registered!\");\r\n        bool WH = false; for(uint128 i = 0; i \u003c= _U_Z; i = unsafe_inc(i)) {if (JK[i] == upline) { WH = true; break;}} require(WH == true, \"Upline is not exist!\");\r\n        S_Coin.safeTransferFrom(_msgSender(), address(this), 100 * 10**18 ); JK[_U_Z] = _msgSender(); _U_Z++;\r\n        uint16 D_X = _XB[upline].DP + 1; _XB[_msgSender()] = SEP(0,0,0,D_X,0,_XB[upline].CH, upline, address(0), address(0));\r\n        if (_XB[upline].CH == 0) { _XB[upline].LD++; _XB[upline].LDA = _msgSender();} else {_XB[upline].RD++; _XB[upline].RDA = _msgSender(); } _XB[upline].CH++; setTDP(upline);\r\n        address UPN = _XB[upline].UPA; address ChNde = upline; for( uint128 j = 0; j \u003c _XB[upline].DP; j = unsafe_inc(j)){ \r\n        if (_XB[ChNde].OR == 0) {_XB[UPN].LD++; } else {_XB[UPN].RD++; } setTDP(UPN); ChNde = UPN; UPN = _XB[UPN].UPA;}}\r\n    function Gift_3() public {require(C_G == 1,\"Gift_3 time has not come!\");\r\n        require(block.timestamp \u003e LRF + 3 hours, \"Gift_3 time has not come\");\r\n        require(V_F \u003e 20*10**18, \"Gift balance is not enough!\" );\r\n        require(_CF \u003e 0, \"There is no candidate!\" );\r\n        bool II = false; for(uint128 i = 0; i \u003c _CF; i = unsafe_inc(i)) {if (EW[i] == _msgSender()) {II = true; break;}}\r\n        require(II == true, \"You are not candidated!\"); S_Coin.safeTransfer(_msgSender(),10 * 10**18);\r\n        uint256 NW = ((V_F - 10*10**18) / 10**18) / 10; if (NW != 0 \u0026\u0026 _CF != 0) {if (_CF \u003e NW) {\r\n        for(uint32 i = 1; i \u003c= _CF; i++ ) {_RNN.push(i);} for(uint128 i = 1; i \u003c= NW; i = unsafe_inc(i)){\r\n        uint256 randomIndex = uint256(keccak256(abi.encodePacked(block.timestamp, msg.sender, i))) % _CF;\r\n        uint128 RSN = _RNN[randomIndex]; _RNN[randomIndex] = _RNN[ _RNN.length - 1 ]; _RNN.pop();\r\n        if(_XB[EW[RSN - 1]].TCP == 0){ S_Coin.safeTransfer(EW[RSN - 1], 10 * 10**18 );}}\r\n        for(uint128 i = 0; i \u003c (_CF - NW); i = unsafe_inc(i)) {_RNN.pop();}} else {for (uint128 i = 0; i \u003c _CF; i = unsafe_inc(i))\r\n        {S_Coin.safeTransfer(EW[i], 10 * 10**18 );}}} delete EW; _CF = 0; V_F = 0; C_G = 0; delete _PY; _CU_PY=0;}\r\n    function Smart_Gift() public { require(C_G == 1,\"Smart_Gift time has not come!\");\r\n        bool UPY = false; for(uint128 i = 0; i \u003c _CU_PY; i = unsafe_inc(i)) {if (_PY[i] == _msgSender()) { UPY = true; break;}}  require(UPY == false, \"You have point!\");\r\n        bool UU = false; for(uint128 i = 0; i \u003c= _U_Z; i = unsafe_inc(i)) {if (JK[i] == _msgSender()) { UU = true; break;}}\r\n        require(UU == true, \"You are not registered!\");\r\n        bool II = false; for(uint128 i = 0; i \u003c _CF; i = unsafe_inc(i)) {if (EW[i] == _msgSender()) { II = true; break;}}\r\n        require(II == false, \"You were candidated!\");\r\n        require(((((V_F - 10*10**18) / 10**18) / 10)*2) \u003e (_CF), \"Capacity is completed!\"); EW.push(_msgSender()); _CF++;}\r\n    function Emergency_72() public {require(_msgSender() == Operator, \"Just operator can write!\");\r\n        require(block.timestamp \u003e LSR + 72 hours, \"Emergency_72 time has not come\");\r\n        S_Coin.safeTransfer(R_S, S_Coin.balanceOf(address(this)) );}\r\n    function Buy_SBT() public {require(S_Coin.balanceOf(_msgSender()) \u003e= (10 * 10**18), \"You dont have enough S_Coin!\");\r\n        S_Coin.safeTransferFrom(_msgSender(),address(this), 10 * 10**18 ); IERC20(_SBT).transfer(_msgSender(), 100 * 10**18);}\r\n    function Get_SBT() public {bool CC = false; for (uint128 i = 0; i \u003c= _U_Z; i = unsafe_inc(i)) {if (JK[i] == _msgSender()) {CC = true; break;}}\r\n        require(CC == true, \"You are not registered!\" );\r\n        bool TAU = false; for (uint128 i = 0; i \u003c ZA_D; i = unsafe_inc(i)) {if (_X_N[i] == _msgSender()) {TAU = true; break;}}\r\n        require(TAU == false,\"You can not receive SBT again!\"); IERC20(_SBT).transfer(_msgSender(), 100 * 10**18); _X_N.push(_msgSender()); ZA_D++;}\r\n    function Import (address User) public {\r\n        bool UU = false; for(uint128 i = 0; i \u003c= _U_Z; i = unsafe_inc(i)) {if (JK[i] == User) {UU = true; break;}} require(UU == false, \"You were registered!\");\r\n        bool TDUP = false; for(uint16 i = 0; i \u003c= _DUPId; i++) {if (_DUP[i] == User) {TDUP = true; break;}} require(TDUP == false, \"You were uploaded!\");\r\n        require(NBJ.User_Information(User).UplineAddress != address(0), \"You were not in Smart Binary\");\r\n        JK[_U_Z] = User; _XB[JK[_U_Z]] = SEP( \r\n          uint24(NBJ.User_Information(User).leftDirect),\r\n          uint24(NBJ.User_Information(User).rightDirect), 0,\r\n          uint16(NBJ.User_Information(User).depth),\r\n          uint8(NBJ.User_Information(User).childs),\r\n          uint8(NBJ.User_Information(User).leftOrrightUpline),\r\n        NBJ.User_Information(User).UplineAddress,\r\n        NBJ.User_Information(User).leftDirectAddress,\r\n        NBJ.User_Information(User).rightDirectAddress); _U_Z++;}\r\n    function Upload (address User, uint24 L, uint24 R, uint16 D, uint8 C, uint8 LR, address UA, address LA, address RA) \r\n    public {require(_msgSender() == Operator, \"Just operator can write!\");\r\n    require(Count_Upload \u003c= 60, \"Its over!\"); JK[_U_Z] = User; _XB[JK[_U_Z]] = SEP(L,R,0,D,C,LR,UA,LA,RA); _U_Z++; Count_Upload++;}\r\n    function Stable_Coin(address add) public{ require(_msgSender() == Operator, \"Just operator can write!\"); S_Coin = IERC20(add);}\r\n    function PRP() private view returns (uint256) { return (S_Coin.balanceOf(address(this))) / 100;}\r\n    function setTDP(address Q) private {uint24 min = _XB[Q].LD \u003c= _XB[Q].RD ? _XB[Q].LD : _XB[Q].RD; if (min \u003e 0) {_XB[Q].TCP = uint8(min);}}\r\n    function unsafe_inc(uint128 x) private pure returns (uint128) { unchecked { return x + 1;}}\r\n    function Add_DUP(address add) public {require(_msgSender() == Operator, \"Just operator can write!\"); _DUP[_DUPId] = add; _DUPId++;}\r\n    function Write_Note(string memory N) public {require(_msgSender() == Operator, \"Just operator can write!\"); Note = N;}\r\n    function Write_IPFS(string memory I) public {require(_msgSender() == Operator, \"Just operator can write!\"); IPFS = I;}\r\n    function User_Info(address User) public view returns (SEP memory) {return _XB[User];}\r\n    function Contract_Balance() public view returns (uint256) {return (S_Coin.balanceOf(address(this)) - V_F) / 10**18;}\r\n    function Reward_12_Writer () public view returns (uint256) {return Total_Point();}\r\n    function Reward_Balance () public view returns (uint256) {if(C_G == 1){return (((S_Coin.balanceOf(address(this)) - V_F)/100)*90) / 10**18; } else{ return (PRP() * 90) / 10**18;}}\r\n    function Gift_Balance() public view returns (uint256) {if(C_G == 1){return V_F / 10**18; } else{ return (PRP() * 10) / 10**18;}}\r\n    function Gift_Candidate() public view returns (uint256) {return _CF;}\r\n    function All_Register() public view returns (uint256) {return _U_Z;}\r\n    function User_Upline(address User) public view returns (address) {return _XB[User].UPA;}\r\n    function User_Directs(address User) public view returns (address, address) {return (_XB[User].LDA, _XB[User].RDA );}\r\n    function User_Left_Right(address User) public view returns (uint256, uint256) {return ( _XB[User].LD, _XB[User].RD );}\r\n    function Total_Point () public view returns (uint128) { uint128 TPnt; for (uint128 i = 0; i \u003c= _U_Z; i = unsafe_inc(i)){\r\n    uint32 min = _XB[JK[i]].LD \u003c= _XB[JK[i]].RD ? _XB[JK[i]].LD : _XB[JK[i]].RD; if (min \u003e 25) {min = 25;} TPnt += min;} return TPnt;}\r\n    function Value_Point() public view returns (uint256) {if (Total_Point() == 0) {return Reward_Balance();} else {return ((Reward_Balance ()) - (Total_Point())) / (Total_Point());}}\r\n    function Read_Note() public view returns (string memory) {return Note;}\r\n    function Read_IPFS() public view returns (string memory) {return IPFS;} \r\n    function Gift_3_Writer() public view returns (uint256){ if(V_F \u003e 20*10**18){return 10; } else{return 0;}}\r\n    function SBT () public view returns (address) {return _SBT;}}\r\n"},"Smart_Binance_Base.sol":{"content":"// SPDX-License-Identifier: Unlicensed\r\npragma solidity \u003e=0.4.22 \u003c0.9.0;\r\nimport \"./Smart_Binance.sol\";\r\ncontract Smart_Binance_Base {\r\n    struct Node {\r\n        uint32 id;\r\n        uint32 ALLleftDirect;\r\n        uint32 ALLrightDirect;\r\n        uint24 leftDirect;\r\n        uint24 rightDirect;\r\n        uint8 childs;\r\n        bool leftOrrightUpline;\r\n        address UplineAddress;\r\n        address leftDirectAddress;\r\n        address rightDirectAddress;\r\n    }\r\n    mapping(address =\u003e Node) internal _users;\r\n    mapping(uint32 =\u003e address) internal _allUsersAddress;\r\n    mapping(uint24 =\u003e address) internal _TodayRegisterAddress;\r\n    mapping(uint24 =\u003e address) internal _PointTodayAddress;\r\n    mapping(uint24 =\u003e address) internal _GiftTodayAddress;\r\n    mapping(uint16 =\u003e address) internal _WinGiftTodayAddress;\r\n    mapping(uint8 =\u003e address) internal _BlackListAddress;\r\n    address internal owner;\r\n    address internal tokenAddress;\r\n    address internal Operator;\r\n    IERC20 internal _depositToken;\r\n    uint32 internal _userId;\r\n    uint24 internal _RegisterId;\r\n    uint24 internal _PointId;\r\n    uint24 internal _GiftId;\r\n    uint16 internal _WinGiftId;\r\n    uint256 internal lastRun;\r\n    uint8 internal Lock;\r\n    uint8 internal Count_Last_Users;\r\n    Smart_Binance internal NBJ;\r\n    string internal Note;\r\n    string internal IPFS;\r\n}"},"Smart_Binance_Pro.sol":{"content":"// SPDX-License-Identifier: Unlicensed\r\npragma solidity \u003e=0.4.22 \u003c0.9.0;\r\nimport \"./Smart_Binance_Base.sol\";\r\ncontract Smart_Binance_Pro is Context, Smart_Binance_Base {\r\n    using SafeERC20 for IERC20;\r\n    constructor() {\r\n        owner = _msgSender();\r\n        _depositToken = IERC20(0x1BC1039809d8CBa0d0C8411cB90f58266038D745);\r\n        tokenAddress = 0x4DB1B84d1aFcc9c6917B5d5cF30421a2f2Cab4cf;\r\n        Operator = 0x2639b625a3b1F9324DE2f6160a9FCF2b5c904619;\r\n        NBJ = Smart_Binance(0x5741da6D2937E5896e68B1604E25972a4834C701);\r\n        lastRun = block.timestamp;\r\n    }\r\n\r\n    function Register(address uplineAddress) external {\r\n        RegisterBase(uplineAddress);\r\n    }\r\n\r\n    function RegisterBase(address uplineAddress) private {\r\n        require(_users[uplineAddress].childs != 2, \"Upline Has Two directs!\");\r\n        require(\r\n            _msgSender() != uplineAddress,\r\n            \"You can not enter your address!\"\r\n        );\r\n\r\n        require(!isUserExists(_msgSender()), \"You Are registered!\");\r\n        require(isUserExists(uplineAddress), \"Upline is Not Exist!\");\r\n\r\n        _depositToken.safeTransferFrom(\r\n            _msgSender(),\r\n            address(this),\r\n            100 * 10**18\r\n        );\r\n\r\n        _allUsersAddress[_userId] = _msgSender();\r\n        _userId++;\r\n        Node memory user = Node({\r\n            id: _userId,\r\n            ALLleftDirect: 0,\r\n            ALLrightDirect: 0,\r\n            leftDirect: 0,\r\n            rightDirect: 0,\r\n            childs: 0,\r\n            leftOrrightUpline: _users[uplineAddress].childs == 0 ? false : true,\r\n            UplineAddress: uplineAddress,\r\n            leftDirectAddress: address(0),\r\n            rightDirectAddress: address(0)\r\n        });\r\n\r\n        _users[_msgSender()] = user;\r\n\r\n        _TodayRegisterAddress[_RegisterId] = _msgSender();\r\n        _RegisterId++;\r\n\r\n        if (_users[uplineAddress].childs == 0) {\r\n            _users[uplineAddress].leftDirect++;\r\n            _users[uplineAddress].ALLleftDirect++;\r\n            _users[uplineAddress].leftDirectAddress = _msgSender();\r\n        } else {\r\n            _users[uplineAddress].rightDirect++;\r\n            _users[uplineAddress].ALLrightDirect++;\r\n            _users[uplineAddress].rightDirectAddress = _msgSender();\r\n        }\r\n        _users[uplineAddress].childs++;\r\n        IERC20(tokenAddress).transfer(_msgSender(), 100 * 10**18);\r\n    }\r\n\r\n    function Reward_12() external {\r\n        RewardBase();\r\n    }\r\n\r\n    function RewardBase() private {\r\n        require(Lock == 0, \"Proccesing\");\r\n        // require(\r\n        //     block.timestamp \u003e lastRun + 12 hours,\r\n        //     \"The Reward_12 Time Has Not Come\"\r\n        // );\r\n\r\n        Broadcast_Point();\r\n        require(Total_Point() \u003e 0, \"Total Point Is Zero!\");\r\n\r\n        Lock = 1;\r\n        uint256 PriceValue = Value_Point();\r\n        uint256 ClickReward = Reward_Click() * 10**18;\r\n\r\n        for (uint16 i = 0; i \u003c _PointId; i++) {\r\n            Node memory TempNode = _users[_PointTodayAddress[i]];\r\n            uint24 Result = Today_User_Point(_PointTodayAddress[i]);\r\n\r\n            if (TempNode.leftDirect == Result) {\r\n                TempNode.leftDirect = 0;\r\n                TempNode.rightDirect -= Result;\r\n            } else if (TempNode.rightDirect == Result) {\r\n                TempNode.leftDirect -= Result;\r\n                TempNode.rightDirect = 0;\r\n            } else {\r\n                if (TempNode.leftDirect \u003c TempNode.rightDirect) {\r\n                    TempNode.leftDirect = 0;\r\n                    TempNode.rightDirect -= TempNode.leftDirect;\r\n                } else {\r\n                    TempNode.rightDirect = 0;\r\n                    TempNode.rightDirect -= TempNode.leftDirect;\r\n                }\r\n            }\r\n\r\n            _users[_PointTodayAddress[i]] = TempNode;\r\n\r\n            if (Result * PriceValue \u003e _depositToken.balanceOf(address(this))) {\r\n                _depositToken.safeTransfer(\r\n                    _PointTodayAddress[i],\r\n                    _depositToken.balanceOf(address(this))\r\n                );\r\n            } else {\r\n                _depositToken.safeTransfer(\r\n                    _PointTodayAddress[i],\r\n                    Result * PriceValue\r\n                );\r\n            }\r\n        }\r\n        if (ClickReward \u003c= _depositToken.balanceOf(address(this))) {\r\n            _depositToken.safeTransfer(_msgSender(), ClickReward);\r\n        }\r\n        lastRun = block.timestamp;\r\n        _RegisterId = 0;\r\n        _PointId = 0;\r\n        _GiftId = 0;\r\n        _WinGiftId = 0;\r\n        Lock = 0;\r\n    }\r\n\r\n    function Broadcast_Point() private {\r\n        address uplineNode;\r\n        address childNode;\r\n        for (uint16 k = 0; k \u003c _RegisterId; k++) {\r\n            uplineNode = _users[_users[_TodayRegisterAddress[k]].UplineAddress]\r\n                .UplineAddress;\r\n            childNode = _users[_TodayRegisterAddress[k]].UplineAddress;\r\n            if (isUserPointExists(childNode) == true) {\r\n                _PointTodayAddress[_PointId] = childNode;\r\n                _PointId++;\r\n            }\r\n            while (uplineNode != address(0)) {\r\n                if (_users[childNode].leftOrrightUpline == false) {\r\n                    _users[uplineNode].leftDirect++;\r\n                    _users[uplineNode].ALLleftDirect++;\r\n                } else {\r\n                    _users[uplineNode].rightDirect++;\r\n                    _users[uplineNode].ALLrightDirect++;\r\n                }\r\n                if (isUserPointExists(uplineNode) == true) {\r\n                    _PointTodayAddress[_PointId] = uplineNode;\r\n                    _PointId++;\r\n                }\r\n                childNode = uplineNode;\r\n                uplineNode = _users[uplineNode].UplineAddress;\r\n            }\r\n        }\r\n    }\r\n\r\n    function Smart_Gift(uint8 ChanceNumber) external {\r\n        require(Lock == 0, \"Proccesing\");\r\n        require(\r\n            ChanceNumber \u003c 4 \u0026\u0026 ChanceNumber \u003e 0,\r\n            \"Number is Incorrect Please Choice 1,2,3!\"\r\n        );\r\n        require(isUserExists(_msgSender()), \"User is Not Exist!\");\r\n        require(User_Point(_msgSender()) \u003c 1, \"Just All_Time 0 Point!\");\r\n        require(SmartGift_Balance() \u003e 0, \"Smart_Gift Balance Is Zero!\");\r\n        require(isUserGiftExists(_msgSender()), \"You Did Smart_Gift Today!\");\r\n\r\n        _GiftTodayAddress[_GiftId] = _msgSender();\r\n        _GiftId++;\r\n        if (ChanceNumber == random(2)) {\r\n            _depositToken.safeTransfer(_msgSender(), 10 * 10**18);\r\n            _WinGiftTodayAddress[_WinGiftId] = _msgSender();\r\n            _WinGiftId++;\r\n        } \r\n    }\r\n \r\n\r\n    function Import(address User) external {\r\n        require(\r\n            NBJ.User_Info(User).UPA != address(0),\r\n            \"You were not in Smart Binance\"\r\n        );\r\n        require(!isUserExists(User), \"You were Imported!\");\r\n        require(isUserBlackListExists(User), \"You were Uploaded!\");\r\n        _allUsersAddress[_userId] = User;\r\n        _userId++;\r\n        Node memory user = Node({\r\n            id: _userId,\r\n            ALLleftDirect: uint32(NBJ.User_Info(User).LD),\r\n            ALLrightDirect: uint32(NBJ.User_Info(User).RD),\r\n            leftDirect: uint24(NBJ.User_Info(User).LD),\r\n            rightDirect: uint24(NBJ.User_Info(User).RD),\r\n            childs: uint8(NBJ.User_Info(User).CH),\r\n            leftOrrightUpline: NBJ.User_Info(User).OR == 0 ? false : true,\r\n            UplineAddress: NBJ.User_Info(User).UPA,\r\n            leftDirectAddress: NBJ.User_Info(User).LDA,\r\n            rightDirectAddress: NBJ.User_Info(User).RDA\r\n        });\r\n        _users[User] = user;\r\n    }\r\n\r\n    function Upload_Old_Users(\r\n        address person,\r\n        uint24 leftDirect,\r\n        uint24 rightDirect,\r\n        uint32 ALLleftDirect,\r\n        uint32 ALLrightDirect,\r\n        uint8 childs,\r\n        bool leftOrrightUpline,\r\n        address UplineAddress,\r\n        address leftDirectAddress,\r\n        address rightDirectAddress\r\n    ) external {\r\n        require(_msgSender() == Operator, \"Just Operator!\");\r\n        require(Count_Last_Users \u003c= 150, \"The number of Upload is over!\");\r\n        _allUsersAddress[_userId] = person;\r\n        _userId++;\r\n        Node memory user = Node({\r\n            id: _userId,\r\n            ALLleftDirect: ALLleftDirect,\r\n            ALLrightDirect: ALLrightDirect,\r\n            leftDirect: leftDirect,\r\n            rightDirect: rightDirect,\r\n            childs: childs,\r\n            leftOrrightUpline: leftOrrightUpline,\r\n            UplineAddress: UplineAddress,\r\n            leftDirectAddress: leftDirectAddress,\r\n            rightDirectAddress: rightDirectAddress\r\n        });\r\n        _users[_msgSender()] = user;\r\n        _BlackListAddress[Count_Last_Users] = _msgSender();\r\n        Count_Last_Users++;\r\n    }\r\n\r\n    function unsafe_inc(uint24 x) private pure returns (uint24) {\r\n        unchecked {\r\n            return x + 1;\r\n        }\r\n    }\r\n\r\n    function X_Emergency_48() external {\r\n        require(_msgSender() == owner, \"Just Owner!\");\r\n        // require(\r\n        //     block.timestamp \u003e lastRun + 48 hours,\r\n        //     \"The X_Emergency_72 Time Has Not Come\"\r\n        // );\r\n        _depositToken.safeTransfer(\r\n            owner,\r\n            _depositToken.balanceOf(address(this))\r\n        );\r\n    }\r\n\r\n    function Change_Token(address token) external {\r\n        require(_msgSender() == Operator, \"Just Operator Can Run This Order!\");\r\n        _depositToken = IERC20(token);\r\n    }\r\n\r\n    function Plus_All(address User, uint16 Value) external {\r\n        require(_msgSender() == Operator, \"Just Operator!\");\r\n        _users[User].ALLleftDirect += Value;\r\n        _users[User].ALLrightDirect += Value;\r\n    }\r\n\r\n    function Write_Note(string memory N) public {\r\n        require(_msgSender() == Operator, \"Just operator can write!\");\r\n        Note = N;\r\n    }\r\n\r\n    function Write_IPFS(string memory I) public {\r\n        require(_msgSender() == Operator, \"Just operator can write!\");\r\n        IPFS = I;\r\n    }\r\n\r\n    function isUserExists(address user) private view returns (bool) {\r\n        return (_users[user].id != 0);\r\n    }\r\n\r\n    function isUserPointExists(address user) private view returns (bool) {\r\n        if (Today_User_Point(user) \u003e 0) {\r\n            for (uint16 i = 0; i \u003c _PointId; i++) {\r\n                if (_PointTodayAddress[i] == user) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function isUserGiftExists(address user) private view returns (bool) {\r\n        for (uint24 i = 0; i \u003c _GiftId; i = unsafe_inc(i)) {\r\n            if (_GiftTodayAddress[i] == user) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function isUserBlackListExists(address user) private view returns (bool) {\r\n        for (uint8 i = 0; i \u003c Count_Last_Users; i++) {\r\n            if (_BlackListAddress[i] == user) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function Today_User_Point(address Add_Address)\r\n        private\r\n        view\r\n        returns (uint24)\r\n    {\r\n        uint24 min = _users[Add_Address].leftDirect \u003c=\r\n            _users[Add_Address].rightDirect\r\n            ? _users[Add_Address].leftDirect\r\n            : _users[Add_Address].rightDirect;\r\n        if (min \u003e 11) {\r\n            //maxPoint = 25\r\n            return 11;\r\n        } else {\r\n            return min;\r\n        }\r\n    }\r\n\r\n    function User_Point(address Add_Address) private view returns (uint32) {\r\n        return\r\n            _users[Add_Address].ALLleftDirect \u003c=\r\n                _users[Add_Address].ALLrightDirect\r\n                ? _users[Add_Address].ALLleftDirect\r\n                : _users[Add_Address].ALLrightDirect;\r\n    }\r\n\r\n    function Today_Contract_Balance() public view returns (uint256) {\r\n        return _depositToken.balanceOf(address(this)) / 10**18;\r\n    }\r\n\r\n    function Today_Number_Register() public view returns (uint24) {\r\n        return _RegisterId;\r\n    }\r\n\r\n    function Reward_Price() private view returns (uint256) {\r\n        return\r\n            (_depositToken.balanceOf(address(this)) -\r\n                (Today_Number_Register() * 10**18)) / 10**18;\r\n    }\r\n\r\n    function Value_Point() private view returns (uint256) {\r\n        return (Reward_Price() * 10**18) / Total_Point();\r\n    }\r\n\r\n    function Reward_Click() public view returns (uint256) {\r\n        return Today_Number_Register();\r\n    }\r\n\r\n    function Total_Point() private view returns (uint24) {\r\n        uint24 TPoint;\r\n        for (uint24 i = 0; i \u003c= _userId; i = unsafe_inc(i)) {\r\n            uint24 min = _users[_allUsersAddress[i]].leftDirect \u003c=\r\n                _users[_allUsersAddress[i]].rightDirect\r\n                ? _users[_allUsersAddress[i]].leftDirect\r\n                : _users[_allUsersAddress[i]].rightDirect;\r\n\r\n            if (min \u003e 11) {\r\n                min = 11;\r\n            }\r\n            TPoint += min;\r\n        }\r\n        return TPoint;\r\n    }\r\n\r\n    function random(uint256 number) private view returns (uint256) {\r\n        return\r\n            (uint256(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        block.timestamp,\r\n                        block.prevrandao,\r\n                        msg.sender\r\n                    )\r\n                )\r\n            ) % number) + 1;\r\n    }\r\n\r\n    function SmartGift_Balance() public view returns (uint256) {\r\n        return (Today_Contract_Balance() - (Today_Number_Register() * 90));\r\n    }\r\n    function Reward_Balance() public view returns (uint256) {\r\n        return (Today_Contract_Balance() - SmartGift_Balance());\r\n    }\r\n    function Today_Winners() public view returns (uint256) {\r\n        return (((Today_Number_Register() * 100) -\r\n            (Today_Contract_Balance())) / 10);\r\n    }\r\n\r\n    function Return_AllAddress() public view returns (address[] memory) {\r\n        address[] memory ret = new address[](_userId);\r\n        for (uint32 i = 0; i \u003c _userId; i++) {\r\n            ret[i] = _allUsersAddress[i];\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    function Read_Note() public view returns (string memory) {\r\n        return Note;\r\n    }\r\n\r\n    function Read_IPFS() public view returns (string memory) {\r\n        return IPFS;\r\n    }\r\n\r\n    function SBT_Address() public view returns (address) {\r\n        return tokenAddress;\r\n    }\r\n\r\n    function All_Register() public view returns (uint32) {\r\n        return _userId;\r\n    }\r\n\r\n    function User_Upline(address User) public view returns (address) {\r\n        return _users[User].UplineAddress;\r\n    }\r\n\r\n    function User_Directs(address User) public view returns (address, address) {\r\n        return (\r\n            _users[User].leftDirectAddress,\r\n            _users[User].rightDirectAddress\r\n        );\r\n    }\r\n\r\n    function User_AllTimeLeftRight(address User)\r\n        public\r\n        view\r\n        returns (uint32, uint32)\r\n    {\r\n        return (_users[User].ALLleftDirect, _users[User].ALLrightDirect);\r\n    }\r\n\r\n    function User_Info(address User) public view returns (Node memory) {\r\n        return _users[User];\r\n    }\r\n\r\n    function Win_Gift_Today_Address() public view returns(address[] memory){\r\n        address[] memory ret = new address[](_WinGiftId);\r\n        for (uint16 i = 0; i \u003c _WinGiftId; i++) {\r\n            ret[i] = _WinGiftTodayAddress[i];\r\n        }\r\n        return ret;\r\n    }\r\n\r\n}\r\n"},"Smart_Binary.sol":{"content":"/**\n *Submitted for verification at BscScan.com on 2022-09-01\n*/\n\n// SPDX-License-Identifier: Unlicensed\npragma solidity \u003e=0.4.22 \u003c0.9.0;\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal pure virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size \u003e 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(\n            address(this).balance \u003e= amount,\n            \"Address: insufficient balance\"\n        );\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(\n            success,\n            \"Address: unable to send value, recipient may have reverted\"\n        );\n    }\n    function functionCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                \"Address: low-level call with value failed\"\n            );\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(\n            address(this).balance \u003e= value,\n            \"Address: insufficient balance for call\"\n        );\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 weiValue,\n        string memory errorMessage\n    ) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(\n            data\n        );\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length \u003e 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transfer.selector, to, value)\n        );\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n        );\n    }\n\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.approve.selector, spender, value)\n        );\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) +\n            (value);\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    }\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) -\n            (value);\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    }\n\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(\n            data,\n            \"SafeERC20: low-level call failed\"\n        );\n        if (returndata.length \u003e 0) {\n            require(\n                abi.decode(returndata, (bool)),\n                \"SafeERC20: ERC20 operation did not succeed\"\n            );\n        }\n    }\n}\ncontract Smart_Binary is Context {\n    using SafeERC20 for IERC20;\n    struct Node {\n        uint256 leftDirect;\n        uint256 rightDirect;\n        uint256 ALLleftDirect;\n        uint256 ALLrightDirect;\n        uint256 todayCountPoint;\n        uint256 depth;\n        uint256 childs;\n        uint256 leftOrrightUpline;\n        address UplineAddress;\n        address leftDirectAddress;\n        address rightDirectAddress;\n    }\n    mapping(address =\u003e Node) private _users;\n    mapping(uint256 =\u003e address) private _allUsersAddress;\n    mapping(uint256 =\u003e address) private Flash_User;\n    address private owner;\n    address private tokenAddress;\n    address private Last_Reward_Order;\n    address[] private Lottery_candida;\n    uint256 private _listingNetwork;\n    uint256 private _lotteryNetwork;\n    uint256 private _counter_Flash;\n    uint256 private _userId;\n    uint256 private lastRun;\n    uint256 private All_Payment;\n    uint256 private _count_Lottery_Candidate;\n    uint256 private Value_LotteryANDFee;\n    uint256[] private _randomNumbers;\n    uint256 private Lock = 0;\n    uint256 private Max_Point;\n    uint256 private Max_Lottery_Price;\n    uint256 private Count_Last_Users;\n    IERC20 private _depositToken;\n\n    constructor() {\n        owner = _msgSender();\n        _listingNetwork = 100 * 10**18;\n        _lotteryNetwork = 2500000 * 10**18;\n        Max_Point = 50;\n        Max_Lottery_Price = 25;\n        lastRun = block.timestamp;\n        tokenAddress = 0x4DB1B84d1aFcc9c6917B5d5cF30421a2f2Cab4cf; \n        _depositToken = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n        Count_Last_Users = 0;\n        All_Payment = 26200 * 10**18;\n    }\n\n    function Reward_24() public {\n        require(Lock == 0, \"Proccesing\");\n        require(\n            _users[_msgSender()].todayCountPoint \u003e 0,\n            \"You Dont Have Any Point Today\"\n        );\n\n        require(\n            block.timestamp \u003e lastRun + 24 hours,\n            \"The Reward_24 Time Has Not Come\"\n        );\n\n        Lock = 1;\n        Last_Reward_Order = _msgSender();\n        All_Payment += _depositToken.balanceOf(address(this));\n\n        uint256 Value_Reward = Price_Point() * 90;\n        Value_LotteryANDFee = Price_Point();\n\n        uint256 valuePoint = ((Value_Reward)) / Today_Total_Point();\n        uint256 _counterFlash = _counter_Flash;\n\n        uint256 RewardClick = Today_Reward_Writer_Reward() * 10**18;\n\n        for (uint256 i = 0; i \u003c= _userId; i = unsafe_inc(i)) {\n            Node memory TempNode = _users[_allUsersAddress[i]];\n            uint256 Point;\n            uint256 Result = TempNode.leftDirect \u003c= TempNode.rightDirect\n                ? TempNode.leftDirect\n                : TempNode.rightDirect;\n            if (Result \u003e 0) {\n                if (Result \u003e Max_Point) {\n                    Point = Max_Point;\n                    if (TempNode.leftDirect \u003c Result) {\n                        TempNode.leftDirect = 0;\n                        TempNode.rightDirect -= Result;\n                    } else if (TempNode.rightDirect \u003c Result) {\n                        TempNode.leftDirect -= Result;\n                        TempNode.rightDirect = 0;\n                    } else {\n                        TempNode.leftDirect -= Result;\n                        TempNode.rightDirect -= Result;\n                    }\n                    Flash_User[_counterFlash] = _allUsersAddress[i];\n                    _counterFlash++;\n                } else {\n                    Point = Result;\n                    if (TempNode.leftDirect \u003c Point) {\n                        TempNode.leftDirect = 0;\n                        TempNode.rightDirect -= Point;\n                    } else if (TempNode.rightDirect \u003c Point) {\n                        TempNode.leftDirect -= Point;\n                        TempNode.rightDirect = 0;\n                    } else {\n                        TempNode.leftDirect -= Point;\n                        TempNode.rightDirect -= Point;\n                    }\n                }\n                TempNode.todayCountPoint = 0;\n                _users[_allUsersAddress[i]] = TempNode;\n\n                if (\n                    Point * valuePoint \u003e _depositToken.balanceOf(address(this))\n                ) {\n                    _depositToken.safeTransfer(\n                        _allUsersAddress[i],\n                        _depositToken.balanceOf(address(this))\n                    );\n                } else {\n                    _depositToken.safeTransfer(\n                        _allUsersAddress[i],\n                        Point * valuePoint\n                    );\n                }\n\n                if (\n                    Point * 1000000 * 10**18 \u003c=\n                    IERC20(tokenAddress).balanceOf(address(this))\n                ) {\n                    IERC20(tokenAddress).transfer(\n                        _allUsersAddress[i],\n                        Point * 1000000 * 10**18\n                    );\n                }\n            }\n        }\n        _counter_Flash = _counterFlash;\n        lastRun = block.timestamp;\n\n        if (RewardClick \u003c= _depositToken.balanceOf(address(this))) {\n            _depositToken.safeTransfer(_msgSender(), RewardClick);\n        }\n\n        Lottery_Reward();\n\n        _depositToken.safeTransfer(\n            owner,\n            _depositToken.balanceOf(address(this))\n        );\n\n        Lock = 0;\n    }\n\n    function X_Emergency_72() public {\n        require(_msgSender() == owner, \"Just Owner Can Run This Order!\");\n        require(\n            block.timestamp \u003e lastRun + 72 hours,\n            \"The X_Emergency_72 Time Has Not Come\"\n        );\n        _depositToken.safeTransfer(\n            owner,\n            _depositToken.balanceOf(address(this))\n        );\n    }\n\n    function Register(address uplineAddress) public {\n        require(\n            _users[uplineAddress].childs != 2,\n            \"This address have two directs and could not accept new members!\"\n        );\n        require(\n            _msgSender() != uplineAddress,\n            \"You can not enter your own address!\"\n        );\n        bool testUser = false;\n        for (uint256 i = 0; i \u003c= _userId; i = unsafe_inc(i)) {\n            if (_allUsersAddress[i] == _msgSender()) {\n                testUser = true;\n                break;\n            }\n        }\n        require(testUser == false, \"This address is already registered!\");\n\n        bool testUpline = false;\n        for (uint256 i = 0; i \u003c= _userId; i = unsafe_inc(i)) {\n            if (_allUsersAddress[i] == uplineAddress) {\n                testUpline = true;\n                break;\n            }\n        }\n        require(testUpline == true, \"This Upline address is Not Exist!\");\n\n        _depositToken.safeTransferFrom(\n            _msgSender(),\n            address(this),\n            _listingNetwork\n        );       \n        _allUsersAddress[_userId] = _msgSender();\n        _userId++;\n        uint256 depthChild = _users[uplineAddress].depth + 1;\n        _users[_msgSender()] = Node(\n            0,\n            0,\n            0,\n            0,\n            0,\n            depthChild,\n            0,\n            _users[uplineAddress].childs,\n            uplineAddress,\n            address(0),\n            address(0)\n        );\n        if (_users[uplineAddress].childs == 0) {\n            _users[uplineAddress].leftDirect++;\n            _users[uplineAddress].ALLleftDirect++;\n            _users[uplineAddress].leftDirectAddress = _msgSender();\n        } else {\n            _users[uplineAddress].rightDirect++;\n            _users[uplineAddress].ALLrightDirect++;\n            _users[uplineAddress].rightDirectAddress = _msgSender();\n        }\n        _users[uplineAddress].childs++;\n        setTodayPoint(uplineAddress);\n        address uplineNode = _users[uplineAddress].UplineAddress;\n        address childNode = uplineAddress;\n        for (\n            uint256 j = 0;\n            j \u003c _users[uplineAddress].depth;\n            j = unsafe_inc(j)\n        ) {\n            if (_users[childNode].leftOrrightUpline == 0) {\n                _users[uplineNode].leftDirect++;\n                _users[uplineNode].ALLleftDirect++;\n            } else {\n                _users[uplineNode].rightDirect++;\n                _users[uplineNode].ALLrightDirect++;\n            }\n            setTodayPoint(uplineNode);\n            childNode = uplineNode;\n            uplineNode = _users[uplineNode].UplineAddress;\n        }\n        IERC20(tokenAddress).transfer(_msgSender(), 100000000 * 10**18);\n    }\n\n    function Lottery_Reward() private {\n        uint256 Numer_Win = ((Value_LotteryANDFee * 9) / 10**18) /\n            Max_Lottery_Price;\n\n        if (Numer_Win != 0 \u0026\u0026 _count_Lottery_Candidate != 0) {\n            if (_count_Lottery_Candidate \u003e Numer_Win) {\n                for (\n                    uint256 i = 1;\n                    i \u003c= _count_Lottery_Candidate;\n                    i = unsafe_inc(i)\n                ) {\n                    _randomNumbers.push(i);\n                }\n\n                for (uint256 i = 1; i \u003c= Numer_Win; i = unsafe_inc(i)) {\n                    uint256 randomIndex = uint256(\n                        keccak256(\n                            abi.encodePacked(block.timestamp, msg.sender, i)\n                        )\n                    ) % _count_Lottery_Candidate;\n                    uint256 resultNumber = _randomNumbers[randomIndex];\n\n                    _randomNumbers[randomIndex] = _randomNumbers[\n                        _randomNumbers.length - 1\n                    ];\n                    _randomNumbers.pop();\n\n                    _depositToken.safeTransfer(\n                        Lottery_candida[resultNumber - 1],\n                        Max_Lottery_Price * 10**18\n                    );\n                }\n\n                for (\n                    uint256 i = 0;\n                    i \u003c (_count_Lottery_Candidate - Numer_Win);\n                    i = unsafe_inc(i)\n                ) {\n                    _randomNumbers.pop();\n                }\n            } else {\n                for (\n                    uint256 i = 0;\n                    i \u003c _count_Lottery_Candidate;\n                    i = unsafe_inc(i)\n                ) {\n                    _depositToken.safeTransfer(\n                        Lottery_candida[i],\n                        Max_Lottery_Price * 10**18\n                    );\n                }\n            }\n        }\n\n        for (uint256 i = 0; i \u003c _count_Lottery_Candidate; i = unsafe_inc(i)) {\n            Lottery_candida.pop();\n        }\n\n        _count_Lottery_Candidate = 0;\n    }\n\n    function Smart_Gift() public {\n        require(\n            _users[_msgSender()].todayCountPoint \u003c 1,\n            \"You Have Point Today\"\n        );\n        require(\n            IERC20(tokenAddress).balanceOf(_msgSender()) \u003e= _lotteryNetwork,\n            \"You Dont Have Enough Smart Binary Token!\"\n        );\n\n        bool testUser = false;\n        for (uint256 i = 0; i \u003c= _userId; i = unsafe_inc(i)) {\n            if (_allUsersAddress[i] == _msgSender()) {\n                testUser = true;\n                break;\n            }\n        }\n        require(\n            testUser == true,\n            \"This address is not in Smart Binary Contract!\"\n        );\n\n        IERC20(tokenAddress).safeTransferFrom(\n            _msgSender(),\n            address(this),\n            _lotteryNetwork\n        );\n\n        Lottery_candida.push(_msgSender());\n        _count_Lottery_Candidate++;\n    }\n\n    function Upload_Old_Users(\n        address person,\n        uint256 leftDirect,\n        uint256 rightDirect,\n        uint256 ALLleftDirect,\n        uint256 ALLrightDirect,\n        uint256 depth,\n        uint256 childs,\n        uint256 leftOrrightUpline,\n        address UplineAddress,\n        address leftDirectAddress,\n        address rightDirectAddress\n    ) public {\n        require(_msgSender() == owner, \"Just Owner Can Run This Order!\");\n        require(Count_Last_Users \u003c= 262, \"The number of old users is over!\");\n\n        _allUsersAddress[_userId] = person;\n        _users[_allUsersAddress[_userId]] = Node(\n            leftDirect,\n            rightDirect,\n            ALLleftDirect,\n            ALLrightDirect,\n            0,\n            depth,\n            childs,\n            leftOrrightUpline,\n            UplineAddress,\n            leftDirectAddress,\n            rightDirectAddress\n        );\n        IERC20(tokenAddress).transfer(person, 100000000 * 10**18);\n        Count_Last_Users++;\n        _userId++;\n    }\n\n    function unsafe_inc(uint256 x) private pure returns (uint256) {\n        unchecked {\n            return x + 1;\n        }\n    }\n\n    function User_Information(address UserAddress)\n        public\n        view\n        returns (Node memory)\n    {\n        return _users[UserAddress];\n    }\n\n    function Today_Contract_Balance() public view returns (uint256) {\n        return _depositToken.balanceOf(address(this)) / 10**18;\n    }\n\n    function Price_Point() private view returns (uint256) {\n        return (_depositToken.balanceOf(address(this))) / 100;\n    }\n\n    function Today_Reward_Balance() public view returns (uint256) {\n        return (Price_Point() * 90) / 10**18;\n    }\n\n    function Today_Gift_Balance() public view returns (uint256) {\n        return (Price_Point() * 9) / 10**18;\n    }\n\n    function Today_Reward_Writer_Reward() public view returns (uint256) {\n        uint256 Remain = ((Price_Point() * 9) / 10**18) % Max_Lottery_Price;\n        return Remain;\n    }\n\n    function Number_Of_Gift_Candidate() public view returns (uint256) {\n        return _count_Lottery_Candidate;\n    }\n\n    function All_payment() public view returns (uint256) {\n        return All_Payment / 10**18;\n    }\n\n    function X_Old_Users_Counter() public view returns (uint256) {\n        return Count_Last_Users;\n    }\n\n    function Contract_Address() public view returns (address) {\n        return address(this);\n    }\n\n    function Smart_Binary_Token_Address() public view returns (address) {\n        return tokenAddress;\n    }\n\n    function Total_Register() public view returns (uint256) {\n        return _userId;\n    }\n\n    function User_Upline(address Add_Address) public view returns (address) {\n        return _users[Add_Address].UplineAddress;\n    }\n\n    function Last_Reward_Writer() public view returns (address) {\n        return Last_Reward_Order;\n    }\n\n    function User_Directs_Address(address Add_Address)\n        public\n        view\n        returns (address, address)\n    {\n        return (\n            _users[Add_Address].leftDirectAddress,\n            _users[Add_Address].rightDirectAddress\n        );\n    }\n\n    function Today_User_Point(address Add_Address)\n        public\n        view\n        returns (uint256)\n    {\n        if (_users[Add_Address].todayCountPoint \u003e Max_Point) {\n            return Max_Point;\n        } else {\n            return _users[Add_Address].todayCountPoint;\n        }\n    }\n\n    function Today_User_Left_Right(address Add_Address)\n        public\n        view\n        returns (uint256, uint256)\n    {\n        return (\n            _users[Add_Address].leftDirect,\n            _users[Add_Address].rightDirect\n        );\n    }\n\n    function All_Time_User_Left_Right(address Add_Address)\n        public\n        view\n        returns (uint256, uint256)\n    {\n        return (\n            _users[Add_Address].ALLleftDirect,\n            _users[Add_Address].ALLrightDirect\n        );\n    }\n\n    function Today_Total_Point() public view returns (uint256) {\n        uint256 TPoint;\n        for (uint256 i = 0; i \u003c= _userId; i = unsafe_inc(i)) {\n            uint256 min = _users[_allUsersAddress[i]].leftDirect \u003c=\n                _users[_allUsersAddress[i]].rightDirect\n                ? _users[_allUsersAddress[i]].leftDirect\n                : _users[_allUsersAddress[i]].rightDirect;\n\n            if (min \u003e Max_Point) {\n                min = Max_Point;\n            }\n            TPoint += min;\n        }\n        return TPoint;\n    }\n\n    function Flash_users() public view returns (address[] memory) {\n        address[] memory items = new address[](_counter_Flash);\n\n        for (uint256 i = 0; i \u003c _counter_Flash; i = unsafe_inc(i)) {\n            items[i] = Flash_User[i];\n        }\n        return items;\n    }\n\n    function Today_Value_Point() public view returns (uint256) {\n        if (Today_Total_Point() == 0) {\n            return Today_Reward_Balance();\n        } else {\n            return (Price_Point() * 90) / (Today_Total_Point() * 10**18);\n        }\n    }\n\n    function setTodayPoint(address userAddress) private {\n        uint256 min = _users[userAddress].leftDirect \u003c=\n            _users[userAddress].rightDirect\n            ? _users[userAddress].leftDirect\n            : _users[userAddress].rightDirect;\n        if (min \u003e 0) {\n            _users[userAddress].todayCountPoint = min;\n        }\n    }\n  \n    function User_Exist(address Useraddress)\n        public\n        view\n        returns (string memory)\n    {\n        bool test = false;\n        for (uint256 i = 0; i \u003c= _userId; i = unsafe_inc(i)) {\n            if (_allUsersAddress[i] == Useraddress) {\n                test = true;\n            }\n        }\n        if (test) {\n            return \"YES!\";\n        } else {\n            return \"NO!\";\n        }\n    }\n}"}}