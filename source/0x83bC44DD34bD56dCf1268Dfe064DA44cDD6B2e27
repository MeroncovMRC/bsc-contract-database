{"IBEP20.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity \u003e=0.4.0;\n\ninterface IBEP20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    \n    function burnFrom(address account, uint256 amount) external returns (bool);\n\n    function burn(uint256 amount) external returns (bool);\n    \n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity \u003e=0.4.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \u0027SafeMath: addition overflow\u0027);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \u0027SafeMath: subtraction overflow\u0027);\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \u0027SafeMath: multiplication overflow\u0027);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \u0027SafeMath: division by zero\u0027);\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \u0027SafeMath: modulo by zero\u0027);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x \u003c y ? x : y;\n    }\n\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y \u003e 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x \u003c z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}\n"},"VSDToken.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity \u003e=0.5.0;\n\nimport \"./IBEP20.sol\";\nimport \"./SafeMath.sol\";\n\ninterface IPancakePair {\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n}\n\ncontract Ownable {\n    address _owner;\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function changeOwner(address newOwner) public onlyOwner {\n        _owner = newOwner;\n    }\n}\n\ncontract InviteReward {\n\n    mapping (address =\u003e address) internal _refers;\n\n    function _bindParent(address sender, address recipient) internal {\n        if(_refers[recipient] == address(0)) {\n            _refers[recipient] = sender;\n        }\n    }\n    \n    function getParent(address user) public view returns (address) {\n        return _refers[user];\n    }\n\n}\n\ncontract LineReward {\n\n    address[10] internal _lines;\n    \n    function _pushLine(address user) internal {\n        for(uint256 i = _lines.length - 1; i \u003e 0 ; i--) {\n            _lines[i] = _lines[i-1];\n        }\n        _lines[0] = user;\n    }\n\n    function getLines() public view returns (address[10] memory) {\n        return _lines;\n    }\n\n}\n\ncontract LaunchLimit is Ownable{\n\n    uint32 public launchTimestamp;\n    uint32 public signleTimeInterval = 300;\n    uint256 public signleAmountLimit = 10000*1e8;\n    mapping(address =\u003e bool) private _signleUser;\n    bool internal _hasLaunched = false;\n    \n    function setSignleTimeInterval(uint32 _signleTimeInterval) public onlyOwner {\n        signleTimeInterval = _signleTimeInterval;\n    }\n    function setSignleAmountLimit(uint256 _signleAmountLimit) public onlyOwner {\n        signleAmountLimit = _signleAmountLimit;\n    }\n    \n    function launch() public onlyOwner {\n        require(!_hasLaunched, \"Already launched.\");\n        _hasLaunched = true;\n        launchTimestamp = uint32(block.timestamp % 2**32);\n    }\n\n    function checkSignleLimit(address user, uint256 amount) internal {\n        uint32 cur = uint32(block.timestamp % 2**32);\n        if(cur \u003e launchTimestamp + signleTimeInterval) {\n            return;\n        }\n        require(amount \u003c= signleAmountLimit, \"launched signle amount\");\n        require(!_signleUser[user] , \"launched signle user\");\n        _signleUser[user] = true;\n    }\n\n}\n\ncontract VDSToken is IBEP20, Ownable, LineReward, InviteReward, LaunchLimit {\n    \n    using SafeMath for uint256;\n\n    mapping (address =\u003e uint256) private _balances;\n\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\n\n    string constant  _name = \u0027X-VDSToken\u0027;\n    string constant _symbol = \u0027X-VDS\u0027;\n    uint8 immutable _decimals = 8;\n    uint256 private _totalSupply = 2100000000 * 1e8;\n    \n    \n    address public fundAddress;\n    address public lpAddress;\n    address public bonusAddress;\n    address public lineAddress;\n    \n    address public pancakeAddress;\n    \n    mapping(address =\u003e bool) private _isExcluded;\n    mapping(address =\u003e bool) private _isBlacked;\n    bool _isFine = false;\n\n    uint32 public bonusIntervalTime = 86400;\n    uint256 public bonusUsdtAmount = 200 * 1e18;\n    uint256 public bonusLineUsdtAmount = 100 * 1e18;\n    \n    constructor()\n    {\n        _owner = msg.sender;\n        \n        _balances[_owner] = _totalSupply;\n        emit Transfer(address(0), _owner, _totalSupply);\n        \n        setExcluded(_owner, true);\n        \n    }\n\n    function setLineAddress(address _lineAddress) public onlyOwner {\n        lineAddress = _lineAddress;\n        setExcluded(lineAddress, true);\n    }\n\n    function setBonusAddress(address _bonusAddress) public onlyOwner {\n        bonusAddress = _bonusAddress;\n        setExcluded(bonusAddress, true);\n    }\n\n    function setLpAddress(address _lpAddress) public onlyOwner {\n        lpAddress = _lpAddress;\n        setExcluded(lpAddress, true);\n    }\n\n    function setFundAddress(address _fundAddress) public onlyOwner {\n        fundAddress = _fundAddress;\n        setExcluded(fundAddress, true);\n    }\n\n    function setPancakeAddress(address _pancakeAddress) public onlyOwner {\n        pancakeAddress = _pancakeAddress;\n    }\n    \n    function setFine(bool isFine) public onlyOwner {\n        _isFine = isFine;\n    }\n\n    function setBonusIntervalTime(uint32 _bonusIntervalTime) public onlyOwner {\n        bonusIntervalTime = _bonusIntervalTime;\n    }\n\n    function setBonusUsdtAmount(uint256 _bonusUsdtAmount) public onlyOwner {\n        bonusUsdtAmount = _bonusUsdtAmount;\n    }\n\n    function setBonusLineUsdtAmount(uint256 _bonusLineUsdtAmount) public onlyOwner {\n        bonusLineUsdtAmount = _bonusLineUsdtAmount;\n    }\n\n    function setExcluded(address account, bool excluded) public onlyOwner {\n        _isExcluded[account] = excluded;\n    }\n    \n    function setBlacked(address account, bool blacked) public onlyOwner {\n        _isBlacked[account] = blacked;\n    }\n    \n    function isExcluded(address account) public view returns (bool) {\n        return _isExcluded[account];\n    }\n    \n    function isBlacked(address account) public view returns (bool) {\n        return _isBlacked[account];\n    }\n    \n    function name() public  pure returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public  pure returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public pure returns (uint8) {\n        return _decimals;\n    }\n    \n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 value) public override returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n    \n    function burn(uint256 amount) public override returns (bool) {\n        _burn(msg.sender, amount);\n        return true;\n    }\n    \n    function burnFrom(address account, uint256 amount) public override returns (bool) {\n        _burn(account, amount);\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\n        return true;\n    }\n    \n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        if(sender != recipient \n            \u0026\u0026 sender != pancakeAddress \u0026\u0026 recipient != pancakeAddress\n            ) {\n            _bindParent(sender, recipient);\n        }\n        \n        uint256 transferAmount = amount;\n        \n        if(!isExcluded(sender) \u0026\u0026 !isExcluded(recipient)) {\n            \n            require(!isBlacked(sender), \"ERC20: blacked\");\n\n            if(sender == pancakeAddress || recipient == pancakeAddress) {\n                require(_hasLaunched, \"ERC20: has not launched\");\n            }\n\n            if(sender == pancakeAddress) {\n                checkSignleLimit(recipient, amount);\n            }\n\n            if(sender != pancakeAddress \u0026\u0026 recipient != pancakeAddress) {\n                uint256 tBurn = amount.div(1000).mul(20);\n                _balances[address(0)] = _balances[address(0)].add(tBurn);\n                transferAmount = transferAmount.sub(tBurn);\n                _totalSupply = _totalSupply.sub(tBurn);\n                emit Transfer(sender, address(0), tBurn);\n            }\n\n        }\n\n        if(sender == pancakeAddress) {\n            \n            if(!isExcluded(recipient)) {\n\n                _takeBonusAmount(sender, recipient, amount);\n                _takeBonusLineAmount(sender, recipient, amount);\n                \n                uint256 onepercent = amount.mul(1).div(1000);\n                if(onepercent \u003e 0)\n                {\n                    \n                    uint256 tInvite = _takeInviterFee(sender, recipient, amount);\n                    uint256 tLine = _takeLineFee(sender, recipient, amount);\n                    uint256 tLp = onepercent.mul(15);\n                    \n                    _balances[lpAddress] = _balances[lpAddress].add(tLp);\n\n                    emit Transfer(sender, lpAddress, tLp);\n                    \n                    uint256 tFee = tInvite.add(tLine).add(tLp);\n                    transferAmount = transferAmount.sub(tFee);\n\n                    _pushLine(recipient);\n                }\n                \n            }\n            \n        }\n            \n        if(recipient == pancakeAddress) {\n            \n            if(!isExcluded(sender)) {\n                \n                uint256 onepercent = amount.mul(1).div(1000);\n                if(onepercent \u003e 0)\n                {\n                    \n                    uint256 tBonus = onepercent.mul(20);\n                    uint256 tLp = onepercent.mul(30);\n                    uint256 tLine = onepercent.mul(20);\n                    uint256 tBurn = onepercent.mul(20);\n                    \n                    _balances[bonusAddress] = _balances[bonusAddress].add(tBonus);\n                    _balances[lpAddress] = _balances[lpAddress].add(tLp);\n                    _balances[lineAddress] = _balances[lineAddress].add(tLine);\n                    _balances[address(0)] = _balances[address(0)].add(tBurn);\n\n                    emit Transfer(sender, bonusAddress, tBonus);\n                    emit Transfer(sender, lineAddress, tLine);\n                    emit Transfer(sender, lpAddress, tLp);\n                    emit Transfer(sender, address(0), tBurn);\n                    \n                    uint256 tFee = tBonus.add(tLine).add(tLp).add(tBurn);\n                    transferAmount = transferAmount.sub(tFee);\n\n                    if(_isFine) {\n                        uint256 tFine = onepercent.mul(330);\n                        _balances[address(0)] = _balances[address(0)].add(tFine);\n                        transferAmount = transferAmount.sub(tFine);\n                        _totalSupply = _totalSupply.sub(tFine);\n                        emit Transfer(sender, address(0), tFine);\n                    }\n\n                }\n                \n            }\n            \n        }\n        \n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(transferAmount);\n        emit Transfer(sender, recipient, transferAmount);\n    }\n    \n    function _burn(address account, uint256 value) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n    \n    function _takeInviterFee(address sender, address recipient, uint256 amount) private returns (uint256) {\n\n        if (recipient == pancakeAddress) {\n            return 0;\n        }\n\n        address cur = recipient;\n        address receiveD;\n\n        uint256 totalFee = 0;\n        uint8[5] memory rates = [20, 5, 5, 5, 5];\n        for(uint8 i = 0; i \u003c rates.length; i++) {\n            cur = _refers[cur];\n            if (cur == address(0)) {\n                receiveD = fundAddress;\n            }else{\n                receiveD = cur;\n            }\n            uint8 rate = rates[i];\n            uint256 curAmount = amount.div(1000).mul(rate);\n            _balances[receiveD] = _balances[receiveD].add(curAmount);\n            emit Transfer(sender, receiveD, curAmount);\n\n            totalFee = totalFee + curAmount;\n\n            if(receiveD == address(0)) {\n                _totalSupply = _totalSupply.sub(curAmount);\n            }\n        }\n\n        return totalFee;\n    }\n\n    function _takeLineFee(address sender, address recipient, uint256 amount) private returns (uint256) {\n\n        if (recipient == pancakeAddress) {\n            return 0;\n        }\n\n        address receiveD;\n\n        uint256 totalFee = 0;\n        uint8[6] memory rates = [3, 4, 5, 6, 7, 10];\n        for(uint8 i = 0; i \u003c rates.length; i++) {\n\n            address cur = _lines[i];\n            if (cur == address(0)) {\n                receiveD = fundAddress;\n            } else {\n                receiveD = cur;\n            }\n\n            uint8 rate = rates[i];\n            uint256 curAmount = amount.div(1000).mul(rate);\n            _balances[receiveD] = _balances[receiveD].add(curAmount);\n            emit Transfer(sender, receiveD, curAmount);\n\n            totalFee = totalFee + curAmount;\n\n            if(receiveD == address(0)) {\n                _totalSupply = _totalSupply.sub(curAmount);\n            }\n\n        }\n        return totalFee;\n    }\n\n    function _takeBonusAmount(address sender, address recipient, uint256 amount) private {\n\n        if (sender != pancakeAddress \u0026\u0026 recipient == pancakeAddress) {\n            return;\n        }\n\n        uint256 price = getExchangeCountOfOneUsdt();\n        uint256 usdtAmount = price == 0 ? 0 : amount.mul(1e18).div(price);\n        uint32 lastExchangeTime = getLastExchangeTime();\n        if(block.timestamp \u003e= lastExchangeTime + bonusIntervalTime \u0026\u0026 usdtAmount \u003e= bonusUsdtAmount) {\n            uint256 bounsAmount = _balances[bonusAddress];\n            if(bounsAmount \u003e 0) {\n                _balances[bonusAddress] = _balances[bonusAddress].sub(bounsAmount);\n                _balances[recipient] = _balances[recipient].add(bounsAmount);\n                emit Transfer(bonusAddress, recipient, bounsAmount);\n            }\n        }\n\n    }\n\n    function _takeBonusLineAmount(address sender, address recipient, uint256 amount) private {\n\n        if (sender != pancakeAddress \u0026\u0026 recipient == pancakeAddress) {\n            return;\n        }\n\n        uint256 price = getExchangeCountOfOneUsdt();\n        uint256 usdtAmount = price == 0 ? 0 : amount.mul(1e18).div(price);\n        if(usdtAmount \u003e= bonusLineUsdtAmount) {\n            uint256 bounsAmount = _balances[lineAddress];\n            if(bounsAmount \u003e 0) {\n                _balances[lineAddress] = _balances[lineAddress].sub(bounsAmount);\n                _balances[recipient] = _balances[recipient].add(bounsAmount);\n                emit Transfer(lineAddress, recipient, bounsAmount);\n            }\n        }\n\n    }\n\n    function getExchangeCountOfOneUsdt() public view returns (uint256)\n    {\n        if(pancakeAddress == address(0)) {return 0;}\n\n        IPancakePair pair = IPancakePair(pancakeAddress);\n\n        (uint112 _reserve0, uint112 _reserve1, ) = pair.getReserves();\n\n        uint256 a = _reserve1;\n        uint256 b = _reserve0;\n\n        if(pair.token0() == address(this))\n        {\n            a = _reserve0;\n            b = _reserve1;\n        }\n\n        return a.mul(1e18).div(b);\n    }\n\n    function getLastExchangeTime() public view returns (uint32)\n    {\n        if(pancakeAddress == address(0)) {return uint32(block.timestamp % 2**32);}\n\n        IPancakePair pair = IPancakePair(pancakeAddress);\n\n        (, , uint32 timestamp) = pair.getReserves();\n\n        return timestamp;\n    }\n\n}"}}