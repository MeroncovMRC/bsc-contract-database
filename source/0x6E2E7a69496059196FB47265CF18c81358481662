{"ReentrancyGuard.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot\u0027s contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler\u0027s defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction\u0027s gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}"},"Web3DebitRouterV2BSC.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity = 0.8.17;\r\n\r\nimport \"./ReentrancyGuard.sol\";\r\n\r\n\r\ninterface IGateway {\r\n\r\n    function payment(\r\n        address _store,\r\n        address _token,\r\n        uint _amount,\r\n        uint _memo,\r\n        address _sender,\r\n        uint _source,\r\n        address _tokenin,\r\n        uint amountIn) external returns (bool);\r\n\r\n}\r\n\r\n\r\ninterface IStargateRouter {\r\n\r\n    struct lzTxObj {\r\n        uint256 dstGasForCall;\r\n        uint256 dstNativeAmount;\r\n        bytes dstNativeAddr;\r\n    }\r\n\r\n\r\n    function swap(\r\n        uint16 _dstChainId,\r\n        uint256 _srcPoolId,\r\n        uint256 _dstPoolId,\r\n        address payable _refundAddress,\r\n        uint256 _amountLD,\r\n        uint256 _minAmountLD,\r\n        lzTxObj memory _lzTxParams,\r\n        bytes calldata _to,\r\n        bytes calldata _payload) external payable;\r\n\r\n}\r\n\r\n\r\ninterface ERC20 {\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n\r\n}\r\n\r\n\r\ninterface ISwapRouterUniswapV2 {\r\n\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline) external returns (uint[] memory amounts);\r\n\r\n\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external payable returns (uint[] memory amounts);\r\n\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n}\r\n\r\n\r\ncontract Web3DebitRouterV2BSC is ReentrancyGuard {\r\n\r\nISwapRouterUniswapV2 public immutable swapRouterUniswapV2;\r\nIStargateRouter public immutable stargateRouter;\r\n\r\nuint public immutable source;\r\n\r\nIGateway public gateway;\r\naddress public owner;\r\nbool public locked;\r\n\r\nstruct DataToStargate {\r\n\r\n    uint16 dstChainId_;\r\n    uint256 srcPoolId_;\r\n    uint256 dstPoolId_;\r\n    uint256 amountLD_;\r\n    uint256 minAmountLD_;\r\n    uint256 gasfee_;\r\n    uint thememo_;    \r\n    address receiverAddress_;\r\n    address tokenincross_;\r\n    address thestore_;\r\n    address tokenoutcross_;\r\n\r\n}\r\n\r\nstruct DataToStargate1 {\r\n\r\n     uint thetimeswap;\r\n     uint theamountInMaximum;\r\n     uint amountLD;\r\n     uint16 dstChainId;\r\n     uint srcPoolId;\r\n     uint dstPoolId;\r\n     uint minAmountLD;\r\n     uint gasfee;\r\n     address receiverAddress;\r\n     address thestore;\r\n     address tokenoutcross;\r\n     uint theamountpay;\r\n     uint thememo;\r\n\r\n}\r\n\r\nstruct DataSwap {\r\n\r\n    address tokenIn;\r\n    address tokenOut;\r\n    uint timeswap;\r\n    uint amountOut;\r\n    uint amountInMaximum;\r\n    address store;\r\n    uint memo;\r\n\r\n}\r\n\r\n\r\nevent Routed(\r\n    address indexed store,\r\n    address indexed sender,\r\n    uint memo,\r\n    address tokenin,\r\n    address tokenout,\r\n    uint amountin,\r\n    uint amountout,\r\n    uint destchain,\r\n    uint srcpool,\r\n    uint dstpool,\r\n    uint amountoutfixed);\r\n\r\n\r\nevent ReceivedFromStargate(\r\n    uint _nonce,\r\n    address _token,                  \r\n    uint256 amountLD,\r\n    address indexed store,\r\n    address indexed sender,\r\n    uint amountout,\r\n    uint memo,\r\n    uint source);\r\n     \r\n\r\nconstructor(\r\n    ISwapRouterUniswapV2 _swapRouterUniswapV2,\r\n    IGateway _gateway,\r\n    IStargateRouter _stargateRouter,\r\n    uint _sourcechain,\r\n    address _owner) {\r\n        \r\n    require(_owner != address(0));\r\n    require(_sourcechain \u003e 0);\r\n\r\n    swapRouterUniswapV2 = _swapRouterUniswapV2;\r\n    gateway = _gateway;\r\n    source = _sourcechain;\r\n    owner = _owner;\r\n    stargateRouter = _stargateRouter;\r\n\r\n}\r\n\r\n\r\nmodifier onlyOwner() {\r\n\r\n    require(msg.sender == owner);\r\n    _;\r\n\r\n}\r\n\r\n\r\nfunction transferOwner(address _newowner) external onlyOwner {\r\n\r\n    require(_newowner != address(0));\r\n    owner = _newowner;\r\n\r\n}\r\n\r\n\r\nfunction lockRouter() external onlyOwner {\r\n\r\n    if (locked) {\r\n        locked = false;\r\n    }\r\n\r\n    if (!locked) {\r\n        locked = true;\r\n    }\r\n\r\n}\r\n\r\n\r\nfunction changeGateway(IGateway _gateway) external onlyOwner {\r\n    \r\n    gateway = _gateway;\r\n\r\n}\r\n\r\n\r\nfunction noSwapPayOnChainSameERC20(address _tokenOut, uint256 _amountOut, address _store, uint _memo) external nonReentrant {\r\n\r\n    require(!locked);\r\n    require(_store != address(0));\r\n    require(_tokenOut != address(0));\r\n    require(_memo \u003e 0);\r\n    require(_amountOut \u003e 0);\r\n\r\n    require(ERC20(_tokenOut).balanceOf(msg.sender) \u003e= _amountOut);\r\n    require(ERC20(_tokenOut).allowance(msg.sender, address(this)) \u003e= _amountOut);\r\n    require(ERC20(_tokenOut).transferFrom(msg.sender, address(this), _amountOut));\r\n    \r\n    require(ERC20(_tokenOut).approve(address(gateway), _amountOut));\r\n    require(gateway.payment(_store, _tokenOut, _amountOut, _memo, msg.sender, source, _tokenOut, _amountOut));\r\n\r\n    emit Routed(\r\n        _store,\r\n        msg.sender,\r\n        _memo,\r\n        _tokenOut,\r\n        _tokenOut,\r\n        _amountOut,\r\n        _amountOut,\r\n        0,\r\n        0,\r\n        0,\r\n        0);\r\n\r\n}\r\n\r\n\r\nfunction swapExactOutputAndPayOnChainERC20(\r\n    address[] memory path,\r\n    uint256 _timeswap,\r\n    uint256 _amountOut,\r\n    uint256 _amountInMaximum,\r\n    address _store,\r\n    uint _memo) external nonReentrant {\r\n\r\n    require(!locked);\r\n    require(_store != address(0));\r\n    require(path[0] != address(0));\r\n    require(path[path.length - 1] != address(0));\r\n    \r\n    require(_timeswap \u003e block.timestamp);\r\n    require(_amountOut \u003e 0);\r\n    require(_amountInMaximum \u003e 0);\r\n    require(_memo \u003e 0);\r\n\r\n    DataSwap memory _dataswap = DataSwap(\r\n        \r\n        path[0],\r\n        path[path.length - 1],\r\n        _timeswap,\r\n        _amountOut,\r\n        _amountInMaximum,\r\n        _store,\r\n        _memo);\r\n\r\n    _swapExactOutputAndPayOnChainERC20(_dataswap, path);\r\n\r\n}\r\n\r\n\r\nfunction _swapExactOutputAndPayOnChainERC20(DataSwap memory _dataswap, address[] memory path) internal {\r\n    \r\n    require(ERC20(_dataswap.tokenIn).balanceOf(msg.sender) \u003e= _dataswap.amountInMaximum);\r\n    require(ERC20(_dataswap.tokenIn).allowance(msg.sender, address(this)) \u003e= _dataswap.amountInMaximum);\r\n    require(ERC20(_dataswap.tokenIn).transferFrom(msg.sender, address(this), _dataswap.amountInMaximum));\r\n    require(ERC20(_dataswap.tokenIn).approve(address(swapRouterUniswapV2), _dataswap.amountInMaximum));\r\n\r\n    uint balancestart = ERC20(_dataswap.tokenOut).balanceOf(address(this));\r\n\r\n    uint[] memory amountIn;\r\n\r\n    amountIn = swapRouterUniswapV2.swapTokensForExactTokens(\r\n        _dataswap.amountOut,\r\n        _dataswap.amountInMaximum,\r\n        path,\r\n        address(this),\r\n        _dataswap.timeswap);\r\n\r\n    require((ERC20(_dataswap.tokenOut).balanceOf(address(this)) - balancestart) == _dataswap.amountOut);\r\n        \r\n    if (amountIn[0] \u003c _dataswap.amountInMaximum) {\r\n        require(ERC20(_dataswap.tokenIn).approve(address(swapRouterUniswapV2), 0));\r\n        require(ERC20(_dataswap.tokenIn).transfer(msg.sender, _dataswap.amountInMaximum - amountIn[0]));\r\n    }\r\n\r\n    require(ERC20(_dataswap.tokenOut).approve(address(gateway), _dataswap.amountOut));\r\n\r\n    require(gateway.payment(\r\n        _dataswap.store,\r\n        _dataswap.tokenOut,\r\n        _dataswap.amountOut,\r\n        _dataswap.memo,\r\n        msg.sender,\r\n        source,\r\n        _dataswap.tokenIn,\r\n        amountIn[0]));\r\n\r\n    emit Routed(\r\n        _dataswap.store,\r\n        msg.sender,\r\n        _dataswap.memo,\r\n        _dataswap.tokenIn,\r\n        _dataswap.tokenOut,\r\n        amountIn[0],\r\n        _dataswap.amountOut,\r\n        0,\r\n        0,\r\n        0,\r\n        0);\r\n\r\n}\r\n\r\n\r\nfunction swapExactOutputAndPayOnChainNATIVE(\r\n    address[] memory path,\r\n    uint256 _timeswap,\r\n    uint256 _amountOut,\r\n    uint256 _amountInMaximum,\r\n    address _store,\r\n    uint _memo) external payable nonReentrant {\r\n\r\n    require(!locked);\r\n    require(_store != address(0));\r\n    require(path[0] != address(0));\r\n    require(path[path.length - 1] != address(0));\r\n\r\n    require(_timeswap \u003e block.timestamp);\r\n    require(_amountOut \u003e 0);\r\n    require(_amountInMaximum \u003e 0);\r\n    require(_memo \u003e 0);\r\n\r\n    require(msg.value == _amountInMaximum);\r\n\r\n    DataSwap memory _dataswap = DataSwap(\r\n        swapRouterUniswapV2.WETH(),\r\n        path[path.length - 1],\r\n        _timeswap,\r\n        _amountOut,\r\n        _amountInMaximum,\r\n        _store,\r\n        _memo);\r\n\r\n    require(path[0] == _dataswap.tokenIn);\r\n\r\n    _swapExactOutputAndPayOnChainNATIVE(_dataswap, path);\r\n\r\n}\r\n\r\n\r\nfunction _swapExactOutputAndPayOnChainNATIVE(DataSwap memory _dataswap, address[] memory path) internal {\r\n\r\n    uint balancestart = ERC20(_dataswap.tokenOut).balanceOf(address(this));\r\n\r\n    uint[] memory amountIn;\r\n\r\n    amountIn = swapRouterUniswapV2.swapETHForExactTokens{value: msg.value}(\r\n    _dataswap.amountOut,\r\n    path,\r\n    address(this),\r\n    _dataswap.timeswap);\r\n\r\n    require((ERC20(_dataswap.tokenOut).balanceOf(address(this)) - balancestart) == _dataswap.amountOut);\r\n                \r\n    if (amountIn[0] \u003c _dataswap.amountInMaximum) {\r\n\r\n        (bool success,) = msg.sender.call{ value: _dataswap.amountInMaximum - amountIn[0] }(\"\");\r\n    }\r\n      \r\n    require(ERC20(_dataswap.tokenOut).approve(address(gateway), _dataswap.amountOut));\r\n \r\n    require(gateway.payment(\r\n        _dataswap.store,\r\n        _dataswap.tokenOut,\r\n        _dataswap.amountOut,\r\n        _dataswap.memo,\r\n        msg.sender,\r\n        source,\r\n        _dataswap.tokenIn,\r\n        amountIn[0]));\r\n        \r\n    emit Routed(\r\n        _dataswap.store,\r\n        msg.sender,\r\n        _dataswap.memo,\r\n        _dataswap.tokenIn,\r\n        _dataswap.tokenOut,\r\n        amountIn[0],\r\n        _dataswap.amountOut,\r\n        0,\r\n        0,\r\n        0,\r\n        0);\r\n\r\n}\r\n\r\n\r\nfunction withdrawEther() external payable onlyOwner nonReentrant {\r\n  \r\n    (bool sent,) = owner.call{value: address(this).balance}(\"\");\r\n    require(sent, \"Failed to send Ether\");\r\n\r\n}\r\n\r\n\r\nfunction balanceEther() external view returns (uint) {\r\n \r\n    return address(this).balance;\r\n\r\n}\r\n\r\n\r\nfunction swapToStargate(\r\n    uint16 dstChainId,\r\n    uint256 srcPoolId,\r\n    uint256 dstPoolId,\r\n    uint256 amountLD,\r\n    uint256 minAmountLD,\r\n    uint256 gasfee,\r\n    address receiverAddress,\r\n    address tokenincross,\r\n    address thestore,\r\n    uint thememo,    \r\n    address tokenoutcross,\r\n    uint theamountpay) external payable nonReentrant {\r\n\r\n    require(!locked);\r\n    require(msg.value \u003e 0);\r\n\r\n    require(amountLD \u003e 0);\r\n    require(minAmountLD \u003e 0);\r\n    require(dstChainId \u003e 0);\r\n    require(srcPoolId \u003e 0);\r\n    require(dstPoolId \u003e 0);\r\n    require(gasfee \u003e 0);\r\n    require(receiverAddress != address(0));\r\n    require(tokenincross != address(0));\r\n    require(thestore != address(0));\r\n    require(tokenoutcross != address(0));\r\n    require(thememo \u003e 0);\r\n    require(theamountpay \u003e 0);\r\n\r\n    DataToStargate memory _datastargate = DataToStargate(\r\n        dstChainId,\r\n        srcPoolId,\r\n        dstPoolId,\r\n        amountLD,\r\n        minAmountLD,\r\n        gasfee,\r\n        thememo,    \r\n        receiverAddress,\r\n        tokenincross,\r\n        thestore,\r\n        tokenoutcross);\r\n\r\n    _swapToStargate(_datastargate, theamountpay);\r\n    \r\n}\r\n\r\n\r\nfunction _swapToStargate(DataToStargate memory _datastargate, uint theamountpay) internal {\r\n    \r\n    require(ERC20(_datastargate.tokenincross_).balanceOf(msg.sender) \u003e= _datastargate.amountLD_);\r\n    require(ERC20(_datastargate.tokenincross_).allowance(msg.sender, address(this)) \u003e= _datastargate.amountLD_);\r\n    require(ERC20(_datastargate.tokenincross_).transferFrom(msg.sender, address(this), _datastargate.amountLD_));\r\n\r\n    require(ERC20(_datastargate.tokenincross_).approve(address(stargateRouter), _datastargate.amountLD_));\r\n\r\n    bytes memory data = abi.encode(\r\n        _datastargate.thestore_,\r\n        _datastargate.tokenoutcross_,\r\n        theamountpay,\r\n        _datastargate.thememo_,\r\n        msg.sender,\r\n        source,\r\n        _datastargate.tokenincross_,\r\n        _datastargate.amountLD_);\r\n\r\n\r\n    stargateRouter.swap{value:msg.value}(\r\n        _datastargate.dstChainId_,                           \r\n        _datastargate.srcPoolId_,                            \r\n        _datastargate.dstPoolId_,                            \r\n        payable(msg.sender),                      \r\n        _datastargate.amountLD_,                  \r\n        _datastargate.minAmountLD_,                \r\n        IStargateRouter.lzTxObj(_datastargate.gasfee_, 0, \"0x\"), \r\n        abi.encodePacked(_datastargate.receiverAddress_), \r\n        data);                     \r\n    \r\n\r\n    emit Routed(\r\n        _datastargate.thestore_,\r\n        msg.sender,\r\n        _datastargate.thememo_,\r\n        _datastargate.tokenincross_,\r\n        _datastargate.tokenoutcross_,\r\n        _datastargate.amountLD_,\r\n        theamountpay,\r\n        _datastargate.dstChainId_,\r\n        _datastargate.srcPoolId_,\r\n        _datastargate.dstPoolId_,\r\n        _datastargate.minAmountLD_);\r\n\r\n}\r\n\r\n\r\nfunction swapExactOutputAndPayCrossChainERC20(\r\n    address[] memory path,\r\n    DataToStargate1 memory datastruct) external payable nonReentrant {\r\n        \r\n    require(!locked);\r\n    require(msg.value \u003e 0);\r\n\r\n    DataToStargate1 memory data = datastruct;\r\n\r\n     require(data.thetimeswap \u003e block.timestamp);\r\n     require(data.theamountInMaximum \u003e 0);\r\n     require(data.amountLD \u003e 0);\r\n     require(data.dstChainId \u003e 0);\r\n     require(data.srcPoolId \u003e 0);\r\n     require(data.dstPoolId \u003e 0);\r\n     require(data.minAmountLD \u003e 0);\r\n     require(data.gasfee \u003e 0);\r\n     require(data.receiverAddress != address(0));\r\n     require(data.thestore != address(0));\r\n     require(data.tokenoutcross != address(0));\r\n     require(data.theamountpay \u003e 0);\r\n     require(data.thememo \u003e 0);\r\n\r\n    require(path[0] != address(0));\r\n    require(path[path.length - 1] != address(0));\r\n\r\n    _swapExactOutputAndPayCrossChainERC20(data, path);\r\n\r\n}\r\n\r\n\r\nfunction _swapExactOutputAndPayCrossChainERC20(\r\n    DataToStargate1 memory data,\r\n    address[] memory path) internal {\r\n\r\n    require(ERC20(path[0]).balanceOf(msg.sender) \u003e= data.theamountInMaximum);\r\n    require(ERC20(path[0]).allowance(msg.sender, address(this)) \u003e= data.theamountInMaximum);\r\n    require(ERC20(path[0]).transferFrom(msg.sender, address(this), data.theamountInMaximum));\r\n    require(ERC20(path[0]).approve(address(swapRouterUniswapV2), data.theamountInMaximum));\r\n\r\n    uint balancestart = ERC20(path[path.length - 1]).balanceOf(address(this));\r\n\r\n    uint[] memory amountIn;\r\n\r\n    amountIn = swapRouterUniswapV2.swapTokensForExactTokens(\r\n        data.amountLD,\r\n        data.theamountInMaximum,\r\n        path,\r\n        address(this),\r\n        data.thetimeswap);\r\n\r\n    require((ERC20(path[path.length - 1]).balanceOf(address(this)) - balancestart) == data.amountLD);\r\n        \r\n    if (amountIn[0] \u003c data.theamountInMaximum) {\r\n        require(ERC20(path[0]).approve(address(swapRouterUniswapV2), 0));\r\n        require(ERC20(path[0]).transfer(msg.sender, data.theamountInMaximum - amountIn[0]));\r\n    }\r\n    \r\n    require(ERC20(path[path.length - 1]).approve(address(stargateRouter), data.amountLD));\r\n    \r\n    _swapToStargateFromERC20(data, amountIn[0], path[0]);\r\n\r\n}\r\n\r\n\r\nfunction _swapToStargateFromERC20(\r\n    DataToStargate1 memory data,\r\n    uint amountIn,\r\n    address thetokenIn) internal {\r\n\r\n    bytes memory datapayload = abi.encode(\r\n        data.thestore,\r\n        data.tokenoutcross,\r\n        data.theamountpay,\r\n        data.thememo,\r\n        msg.sender,\r\n        source,\r\n        thetokenIn,\r\n        amountIn);\r\n\r\n    stargateRouter.swap{value: msg.value}(\r\n        data.dstChainId,                          \r\n        data.srcPoolId,                           \r\n        data.dstPoolId,                           \r\n        payable(msg.sender),                      \r\n        data.amountLD,                  \r\n        data.minAmountLD,               \r\n        IStargateRouter.lzTxObj(data.gasfee, 0, \"0x\"),  \r\n        abi.encodePacked(data.receiverAddress),    \r\n        datapayload);                      \r\n\r\n    emit Routed(\r\n        data.thestore,\r\n        msg.sender,\r\n        data.thememo,\r\n        thetokenIn,\r\n        data.tokenoutcross,\r\n        amountIn,\r\n        data.theamountpay,\r\n        data.dstChainId,\r\n        data.srcPoolId,\r\n        data.dstPoolId,\r\n        data.minAmountLD);\r\n\r\n}\r\n\r\n\r\nfunction swapExactOutputAndPayCrossChainNATIVE(\r\n    address[] memory path,\r\n    DataToStargate1 memory datastruct) external payable nonReentrant {\r\n            \r\n    require(!locked);\r\n    require(msg.value \u003e 0);\r\n\r\n    DataToStargate1 memory data = datastruct;\r\n\r\n    require(swapRouterUniswapV2.WETH() == path[0]);\r\n\r\n     require(data.thetimeswap \u003e block.timestamp);\r\n     require(data.theamountInMaximum \u003e 0);\r\n     require(data.amountLD \u003e 0);\r\n     require(data.dstChainId \u003e 0);\r\n     require(data.srcPoolId \u003e 0);\r\n     require(data.dstPoolId \u003e 0);\r\n     require(data.minAmountLD \u003e 0);\r\n     require(data.gasfee \u003e 0);\r\n     require(data.receiverAddress != address(0));\r\n     require(data.thestore != address(0));\r\n     require(data.tokenoutcross != address(0));\r\n     require(data.theamountpay \u003e 0);\r\n     require(data.thememo \u003e 0);\r\n\r\n    require(path[0] != address(0));\r\n    require(path[path.length - 1] != address(0));\r\n\r\n    _swapExactOutputAndPayCrossChainNATIVE(data, path);\r\n\r\n}\r\n\r\n\r\nfunction _swapExactOutputAndPayCrossChainNATIVE(\r\n    DataToStargate1 memory data,\r\n    address[] memory path) internal {\r\n\r\n    uint balancestart = ERC20(path[path.length - 1]).balanceOf(address(this));\r\n\r\n    uint[] memory amountIn;\r\n\r\n    amountIn = swapRouterUniswapV2.swapETHForExactTokens{value: data.theamountInMaximum}(\r\n    data.amountLD,\r\n    path,\r\n    address(this),\r\n    data.thetimeswap);\r\n\r\n    require((ERC20(path[path.length - 1]).balanceOf(address(this)) - balancestart) == data.amountLD);\r\n\r\n    if (amountIn[0] \u003c data.theamountInMaximum) {\r\n                        \r\n        (bool success,) = msg.sender.call{ value: data.theamountInMaximum - amountIn[0] }(\"\");\r\n    }\r\n    \r\n    require(ERC20(path[path.length - 1]).approve(address(stargateRouter), data.amountLD));\r\n    \r\n    _swapToStargateFromNATIVE(data, amountIn[0], path[0]);\r\n\r\n}\r\n\r\n\r\nfunction _swapToStargateFromNATIVE(\r\n    DataToStargate1 memory data,\r\n    uint amountIn,\r\n    address thetokenIn) internal {\r\n \r\n    bytes memory datapayload = abi.encode(\r\n        data.thestore,\r\n        data.tokenoutcross,\r\n        data.theamountpay,\r\n        data.thememo,\r\n        msg.sender,\r\n        source,\r\n        thetokenIn,\r\n        amountIn);\r\n\r\n    stargateRouter.swap{value: msg.value - data.theamountInMaximum}(\r\n        data.dstChainId,                          \r\n        data.srcPoolId,                           \r\n        data.dstPoolId,                           \r\n        payable(msg.sender),                      \r\n        data.amountLD,                  \r\n        data.minAmountLD,                  \r\n        IStargateRouter.lzTxObj(data.gasfee, 0, \"0x\"), \r\n        abi.encodePacked(data.receiverAddress),    \r\n        datapayload);                     \r\n\r\n    emit Routed(\r\n        data.thestore,\r\n        msg.sender,\r\n        data.thememo,\r\n        thetokenIn,\r\n        data.tokenoutcross,\r\n        amountIn,\r\n        data.theamountpay,\r\n        data.dstChainId,\r\n        data.srcPoolId,\r\n        data.dstPoolId,\r\n        data.minAmountLD);\r\n\r\n}\r\n\r\n\r\nfunction sgReceive(\r\n    uint16 /*_srcChainId*/,            \r\n    bytes memory /*_srcAddress*/,      \r\n    uint256 _nonce,                  \r\n    address _token,                \r\n    uint256 amountLD,              \r\n    bytes memory payload) external nonReentrant {\r\n\r\n    require(msg.sender == address(stargateRouter)); \r\n\r\n    (address thestore,\r\n     address thetoken,\r\n     uint theamount,\r\n     uint thememo,\r\n     address thesender,\r\n     uint thesource,\r\n     address thetokenin,\r\n     uint theamountin) = abi.decode(payload, (address, address, uint, uint, address, uint, address, uint));\r\n\r\n\r\n    if (amountLD \u003e theamount) {\r\n        require(ERC20(thetoken).transfer(thesender, amountLD - theamount));\r\n    }\r\n\r\n    require(ERC20(thetoken).approve(address(gateway), theamount));\r\n\r\n    require(gateway.payment(thestore, thetoken, theamount, thememo, thesender, thesource, thetokenin, theamountin));\r\n\r\n    emit ReceivedFromStargate(\r\n        _nonce,\r\n        _token,\r\n        amountLD,\r\n        thestore,\r\n        thesender,\r\n        theamount,\r\n        thememo,\r\n        thesource);\r\n    \r\n}    \r\n\r\n\r\nreceive() payable external {}\r\n\r\n}"}}