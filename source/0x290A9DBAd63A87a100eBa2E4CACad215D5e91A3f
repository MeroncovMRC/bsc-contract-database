
// File: @openzeppelin/contracts/token/ERC20/IERC20.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `from` to `to` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
}


// File: @openzeppelin/contracts/utils/math/SafeMath.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)

pragma solidity ^0.8.0;

// CAUTION
// This version of SafeMath should only be used with Solidity 0.8 or later,
// because it relies on the compiler's built in overflow checks.

/**
 * @dev Wrappers over Solidity's arithmetic operations.
 *
 * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler
 * now has built in overflow checking.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            uint256 c = a + b;
            if (c < a) return (false, 0);
            return (true, c);
        }
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b > a) return (false, 0);
            return (true, a - b);
        }
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
            // benefit is lost if 'b' is also tested.
            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
            if (a == 0) return (true, 0);
            uint256 c = a * b;
            if (c / a != b) return (false, 0);
            return (true, c);
        }
    }

    /**
     * @dev Returns the division of two unsigned integers, with a division by zero flag.
     *
     * _Available since v3.4._
     */
    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a / b);
        }
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.
     *
     * _Available since v3.4._
     */
    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a % b);
        }
    }

    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return a - b;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        return a * b;
    }

    /**
     * @dev Returns the integer division of two unsigned integers, reverting on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator.
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * reverting when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return a % b;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {trySub}.
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b <= a, errorMessage);
            return a - b;
        }
    }

    /**
     * @dev Returns the integer division of two unsigned integers, reverting with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a / b;
        }
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * reverting with custom message when dividing by zero.
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {tryMod}.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a % b;
        }
    }
}


// File: contracts/IInvestmentEarnings.sol
// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.9;

interface IInvestmentEarnings {
    event NotedCancelReinvest(string orderId);
    event NotedWithdraw(uint64[] recordIds);
    event Liquidated(string orderId);
    event Processed(string orderId);

    function noteCancelReinvest(string calldata orderId) external;

    function noteWithdrawal(uint64[] calldata recordIds) external;

    function liquidatedAssets(string calldata orderId) external;

    function processBorrowing(string calldata orderId) external;
}


// File: contracts/IPool.sol
// SPDX-License-Identifier: AGPL-3.0
pragma solidity ^0.8.9;

/**
 * @title IPool
 *
 * @notice Defines the basic interface for an Wealth Pool.
 **/
interface IPool {

    // An event sent when a redemption is triggered to the given address.
    event Redeemed(
        address from,
        address to,
        address erc20contract,
        uint256 transfer
    );

    // An event sent when a mint is triggered to the given address.
    event Mint(
        address from,
        address to,
        uint256 value
    );

    /**
    * @notice Use matching pool tokens to exchange for the source token
   * @param destination: the token receiver address.
   * @param value: the token value, in token minimum unit.
   */
    function redemption(
        address destination,
        uint256 value
    ) external;

    /**
     * @notice Mint matching pool tokens to destination, at the same time need to deduct the caller's source token
   * @param destination The address for receive the token
   * @param value The amount of token to mint
   */
    function mint(
        address destination,
        uint256 value
    ) external payable;

    function cancelReinvest(
        string calldata orderId
    ) external;

    function withdrawalIncome(
        uint64[] calldata recordIds
    ) external;

}


// File: contracts/WealthPool.sol
// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.9;

import {IInvestmentEarnings} from "./IInvestmentEarnings.sol";
import {IPool} from "./IPool.sol";
import {WTHToken} from "./WTHToken.sol";


/**
 * @title WealthPool contract
 *
 * @notice Main point of interaction with an Wealth protocol's market
 * - Users can:
 *   # Supply
 *   # Withdraw
 *   # Borrow
 *   # Repay
 *   # Swap their loans between variable and stable rate
 *   # Enable/disable their supplied assets as collateral rebalance stable rate borrow positions
 *   # Liquidate positions
 *   # Execute Flash Loans
 * @dev To be covered by a proxy contract, owned by the PoolAddressesProvider of the specific market
 * @dev All admin functions are callable by the PoolConfigurator contract defined also in the
 *   PoolAddressesProvider
 **/
contract WealthPool is WTHToken, IPool {
    uint256 public constant POOL_REVISION = 0x2;
    IInvestmentEarnings public immutable INVESTMENT_EARNINGS_CONTRACT;
    address public immutable SRC_TOKEN; // 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE stands for ETH

    uint256 public constant MAX_OWNER_COUNT = 9;

    // The N addresses which control the funds in this contract. The
    // owners of M of these addresses will need to both sign a message
    // allowing the funds in this contract to be spent.
    mapping(address => bool) private isOwner;
    address[] private owners;
    uint256 private immutable required;

    // The contract nonce is not accessible to the contract so we
    // implement a nonce-like variable for replay protection.
    uint256 private spendNonce = 0;
    uint256 public allowInternalCall = 1;

    bytes4 private constant TRANSFER_SELECTOR =
        bytes4(keccak256(bytes("transfer(address,uint256)")));
    bytes4 private constant TRANSFER_FROM_SELECTOR =
        bytes4(keccak256(bytes("transferFrom(address,address,uint256)")));

    address private constant ETH_CONTRACT =
        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    // An event sent when funds are received.
    event Funded(address from, uint256 value);

    // An event sent when a setAllowInternalCall is triggered.
    event AllowInternalCallUpdated(uint256 value);

    // An event sent when a spend is triggered to the given address.
    event Spent(address to, uint256 transfer);

    // An event sent when a spendERC20 is triggered to the given address.
    event SpentERC20(address erc20contract, address to, uint256 transfer);

    modifier validRequirement(uint256 ownerCount, uint256 _required) {
        require(
            ownerCount <= MAX_OWNER_COUNT &&
                _required <= ownerCount &&
                _required >= 1
        );
        _;
    }

    /**
     * @dev Constructor.
     * @param _owners List of initial owners.
     * @param _required Number of required confirmations.
     */
    constructor(
        IInvestmentEarnings investmentEarnings,
        address srcToken,
        address[] memory _owners,
        uint256 _required
    ) validRequirement(_owners.length, _required) {
        INVESTMENT_EARNINGS_CONTRACT = investmentEarnings;
        SRC_TOKEN = srcToken;
        for (uint256 i = 0; i < _owners.length; i++) {
            //onwer should be distinct, and non-zero
            if (isOwner[_owners[i]] || _owners[i] == address(0x0)) {
                revert();
            }
            isOwner[_owners[i]] = true;
        }
        owners = _owners;
        required = _required;
    }

    /**
     * @dev Leaves the contract without owners. It will not be possible to call
     * with signature check anymore. Can only be called by the current owners.
     *
     * NOTE: Renouncing ownership will leave the contract without owners,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership(
        uint8[] calldata vs,
        bytes32[] calldata rs,
        bytes32[] calldata ss
    ) external {
        bytes32 renounceOwnershipTypeHash = keccak256(
            "RenounceOwnership(uint256 spendNonce)"
        );
        bytes32 digest = keccak256(
            abi.encodePacked(
                "\x19\x01",
                DOMAIN_SEPARATOR,
                keccak256(abi.encode(renounceOwnershipTypeHash, spendNonce))
            )
        );
        require(_validMsgSignature(digest, vs, rs, ss), "invalid signatures");
        for (uint256 i = 0; i < owners.length; i++) {
            isOwner[owners[i]] = false;
        }
        delete owners;
    }

    // The receive function for this contract.
    receive() external payable {
        if (msg.value > 0) {
            emit Funded(msg.sender, msg.value);
        }
    }

    // @dev Returns list of owners.
    // @return List of owner addresses.
    function getOwners() external view returns (address[] memory) {
        return owners;
    }

    function getSpendNonce() external view returns (uint256) {
        return spendNonce;
    }

    function getRequired() external view returns (uint256) {
        return required;
    }

    function _safeTransfer(address token, address to, uint256 value) private {
        (bool success, bytes memory data) = token.call(
            abi.encodeWithSelector(TRANSFER_SELECTOR, to, value)
        );
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            "WealthPool: TRANSFER_FAILED"
        );
    }

    function _safeTransferFrom(
        address token,
        address from,
        address to,
        uint256 value
    ) private {
        (bool success, bytes memory data) = token.call(
            abi.encodeWithSelector(TRANSFER_FROM_SELECTOR, from, to, value)
        );
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            "WealthPool: TRANSFER_FROM_FAILED"
        );
    }

    // Generates the message to sign given the output destination address and amount.
    // includes this contract's address and a nonce for replay protection.
    // One option to independently verify: https://leventozturk.com/engineering/sha3/ and select keccak
    function generateMessageToSign(
        address erc20Contract,
        address destination,
        uint256 value
    ) private view returns (bytes32) {
        require(destination != address(this));
        //the sequence should match generateMultiSigV2 in JS
        bytes32 message = keccak256(
            abi.encodePacked(
                address(this),
                erc20Contract,
                destination,
                value,
                spendNonce
            )
        );
        return message;
    }

    function _messageToRecover(
        address erc20Contract,
        address destination,
        uint256 value
    ) private view returns (bytes32) {
        bytes32 hashedUnsignedMessage = generateMessageToSign(
            erc20Contract,
            destination,
            value
        );
        bytes memory prefix = "\x19Ethereum Signed Message:\n32";
        return keccak256(abi.encodePacked(prefix, hashedUnsignedMessage));
    }

    /**
     * @param _allowInternalCall: the new allowInternalCall value.
     * @param vs, rs, ss: the signatures
     */
    function setAllowInternalCall(
        uint256 _allowInternalCall,
        uint8[] calldata vs,
        bytes32[] calldata rs,
        bytes32[] calldata ss
    ) external {
        require(
            _validSignature(
                address(this),
                msg.sender,
                _allowInternalCall,
                vs,
                rs,
                ss
            ),
            "invalid signatures"
        );
        spendNonce = spendNonce + 1;
        allowInternalCall = _allowInternalCall;
        emit AllowInternalCallUpdated(allowInternalCall);
    }

    /**
     * @param destination: the ether receiver address.
     * @param value: the ether value, in wei.
     * @param vs, rs, ss: the signatures
     */
    function spend(
        address destination,
        uint256 value,
        uint8[] calldata vs,
        bytes32[] calldata rs,
        bytes32[] calldata ss
    ) external {
        require(destination != address(this), "Not allow sending to yourself");
        require(
            address(this).balance >= value && value > 0,
            "balance or spend value invalid"
        );
        require(
            _validSignature(address(0x0), destination, value, vs, rs, ss),
            "invalid signatures"
        );
        spendNonce = spendNonce + 1;
        (bool success, ) = destination.call{value: value}("");
        require(success, "transfer fail");
        emit Spent(destination, value);
    }

    /**
     * @param erc20contract: the erc20 contract address.
     * @param destination: the token receiver address.
     * @param value: the token value, in token minimum unit.
     * @param vs, rs, ss: the signatures
     */
    function spendERC20(
        address destination,
        address erc20contract,
        uint256 value,
        uint8[] calldata vs,
        bytes32[] calldata rs,
        bytes32[] calldata ss
    ) external {
        require(destination != address(this), "Not allow sending to yourself");
        //transfer erc20 token
        require(value > 0, "Erc20 spend value invalid");
        require(
            _validSignature(erc20contract, destination, value, vs, rs, ss),
            "invalid signatures"
        );
        spendNonce = spendNonce + 1;
        // transfer tokens from this contract to the destination address
        _safeTransfer(erc20contract, destination, value);
        emit SpentERC20(erc20contract, destination, value);
    }

    /**
     * @param destination: the token receiver address.
     * @param value: the token value, in token minimum unit.
     */
    function redemption(address destination, uint256 value) external {
        require(destination != address(this), "Not allow sending to yourself");
        //transfer erc20 token
        require(value > 0, "withdraw value invalid");
        _burn(msg.sender, value);
        if (SRC_TOKEN == ETH_CONTRACT) {
            // transfer ETH
            (bool success, ) = destination.call{value: value}("");
            require(success, "transfer fail");
        } else {
            // transfer erc20 token
            _safeTransfer(SRC_TOKEN, destination, value);
        }
        emit Redeemed(msg.sender, destination, SRC_TOKEN, value);
    }

    function mint(address destination, uint256 value) external payable {
        require(destination != address(0), "ERC20: mint to the zero address");
        uint256 mintAmount = msg.value;
        if (SRC_TOKEN != ETH_CONTRACT) {
            // transfer erc20 token
            mintAmount = value;
            _safeTransferFrom(SRC_TOKEN, msg.sender, address(this), mintAmount);
        }
        _mint(destination, mintAmount);
        emit Mint(msg.sender, destination, mintAmount);
    }

    function mint(
        address destination,
        uint256 value,
        uint8[] calldata vs,
        bytes32[] calldata rs,
        bytes32[] calldata ss
    ) external {
        require(destination != address(this), "Not allow sending to yourself");
        //transfer erc20 token
        require(value > 0, "Erc20 spend value invalid");
        require(
            _validSignature(address(this), destination, value, vs, rs, ss),
            "invalid signatures"
        );
        spendNonce = spendNonce + 1;
        // transfer tokens from this contract to the destination address
        // _safeTransfer(erc20contract, destination, value);

        _mint(destination, value);
        emit Mint(msg.sender, destination, value);
    }

    function cancelReinvest(string calldata orderId) external {
        uint256 size;
        address callerAddress = msg.sender;
        assembly {
            size := extcodesize(callerAddress)
        }
        require(size == 0 || allowInternalCall == 1, "forbidden");
        INVESTMENT_EARNINGS_CONTRACT.noteCancelReinvest(orderId);
    }

    function withdrawalIncome(uint64[] calldata recordIds) external {
        uint256 size;
        address callerAddress = msg.sender;
        assembly {
            size := extcodesize(callerAddress)
        }
        require(size == 0 || allowInternalCall == 1, "forbidden");
        for (uint256 i = 0; i < recordIds.length; i++) {
            require(recordIds[i] > 0, "invalid record id");
            for (uint256 j = 0; j < i; j++) {
                if (recordIds[i] == recordIds[j]) {
                    revert("duplicate record id");
                }
            }
        }
        INVESTMENT_EARNINGS_CONTRACT.noteWithdrawal(recordIds);
    }

    // Confirm that the signature triplets (v1, r1, s1) (v2, r2, s2) ...
    // authorize a spend of this contract's funds to the given destination address.
    function _validMsgSignature(
        bytes32 message,
        uint8[] calldata vs,
        bytes32[] calldata rs,
        bytes32[] calldata ss
    ) private view returns (bool) {
        require(vs.length == rs.length);
        require(rs.length == ss.length);
        require(vs.length <= owners.length);
        require(vs.length >= required);
        address[] memory addrs = new address[](vs.length);
        for (uint256 i = 0; i < vs.length; i++) {
            //recover the address associated with the public key from elliptic curve signature or return zero on error
            addrs[i] = ecrecover(message, vs[i] + 27, rs[i], ss[i]);
        }
        require(_distinctOwners(addrs));
        return true;
    }

    // Confirm that the signature triplets (v1, r1, s1) (v2, r2, s2) ...
    // authorize a spend of this contract's funds to the given destination address.
    function _validSignature(
        address erc20Contract,
        address destination,
        uint256 value,
        uint8[] calldata vs,
        bytes32[] calldata rs,
        bytes32[] calldata ss
    ) private view returns (bool) {
        bytes32 message = _messageToRecover(erc20Contract, destination, value);
        return _validMsgSignature(message, vs, rs, ss);
    }

    // Confirm the addresses as distinct owners of this contract.
    function _distinctOwners(
        address[] memory addrs
    ) private view returns (bool) {
        if (addrs.length > owners.length) {
            return false;
        }
        for (uint256 i = 0; i < addrs.length; i++) {
            if (!isOwner[addrs[i]]) {
                return false;
            }
            //address should be distinct
            for (uint256 j = 0; j < i; j++) {
                if (addrs[i] == addrs[j]) {
                    return false;
                }
            }
        }
        return true;
    }
}


// File: contracts/WTHToken.sol
// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.9;

import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract WTHToken is IERC20 {
    using SafeMath for uint256;

    string public constant name = "Wealth EX";
    string public constant symbol = "WTH-EX";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    bytes32 public immutable DOMAIN_SEPARATOR;

    constructor() {
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                keccak256(
                    "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
                ),
                keccak256(bytes(name)),
                keccak256(bytes("1")),
                block.chainid,
                address(this)
            )
        );
    }

    function _mint(address to, uint256 value) internal {
        totalSupply = totalSupply.add(value);
        balanceOf[to] = balanceOf[to].add(value);
        emit Transfer(address(0), to, value);
    }

    function _burn(address from, uint256 value) internal {
        balanceOf[from] = balanceOf[from].sub(value);
        totalSupply = totalSupply.sub(value);
        emit Transfer(from, address(0), value);
    }

    function _approve(
        address owner,
        address spender,
        uint256 value
    ) private {
        allowance[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    function _transfer(
        address from,
        address to,
        uint256 value
    ) private {
        balanceOf[from] = balanceOf[from].sub(value);
        balanceOf[to] = balanceOf[to].add(value);
        emit Transfer(from, to, value);
    }

    function approve(address spender, uint256 value) external returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    function transfer(address to, uint256 value) external returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    function transferFrom(
        address from,
        address to,
        uint256 value
    ) external returns (bool) {
        allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);
        _transfer(from, to, value);
        return true;
    }
}

