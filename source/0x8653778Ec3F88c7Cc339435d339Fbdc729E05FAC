
// File: /contracts/TokenV5.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "./Distributor.sol";
import "./DistributorV2.sol";
import "./ArtikDistributorV1.sol";
import "./DistributorContract.sol";
import "./ArtikDistributor.sol";
import "./DistributorV1.sol";
import "./ArtikDistributorV2.sol";

import "./interfaces/DexRouter.sol";
import "./libraries/ABDKMathQuad.sol";
import "./ArtikTreasury.sol";
import "./ArtikTreasuryV2.sol";
import "./ArtikTreasuryV1.sol";

import "./TreasuryV1.sol";
import "./TreasuryV0.sol";
import "./TreasuryManagerV0.sol";

contract TokenV5 is IERC20, Initializable {
    using SafeMath for uint256;

    // Pancakeswap 0x10ED43C718714eb63d5aA57B78B54704E256024E (testnet: 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3)
    address private constant ROUTER =
        0x10ED43C718714eb63d5aA57B78B54704E256024E;
    // WBNB 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c (testnet: 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd)
    address private constant WETH = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;

    uint256 private constant TEAM_FEE = 20;
    uint256 private constant TAX_FEE = 10;
    uint256 private constant ANTI_WHALE_AMOUNT = 5000000000000000000000000;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    uint256 private _totalSupply;
    string private _name;
    string private _symbol;

    mapping(address => bool) private excludedFromTax;
    address private _owner;

    // To remove
    Distributor private distributor;
    address payable public distributorAddress;
    DexRouter private dexRouter;
    uint256 public dateFeesAccumulation;
    DistributorContract private distributorContract;
    ArtikDistributor private artikDistributor;
    ArtikDistributorV1 private artikDistributorV1;
    DistributorV1 private distributorV1;
    ArtikDistributorV2 private artikDistributorV2;
    DistributorV2 private distributorV2;
    // End to remove

    ArtikTreasury private treasury;
    ArtikTreasuryV2 private artikTreasury;
    ArtikTreasuryV1 private artikTreasuryV1;
    TreasuryV1 private treasuryV1;
    TreasuryV0 private treasuryV0;
    TreasuryManagerV0 private treasuryManagerV0;

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    function initialize(uint256 _supply) public initializer {
        _name = "Artik";
        _symbol = "ARTK";

        _transferOwnership(msg.sender);

        _totalSupply += _supply * (10 ** decimals());
        _balances[_owner] += _supply * (10 ** decimals());

        excludedFromTax[_owner] = true;
        excludedFromTax[ROUTER] = true;

        dexRouter = DexRouter(ROUTER);
        _approve(address(this), ROUTER, totalSupply());
    }

    modifier onlyOwner() {
        require(_owner == msg.sender, "Ownable: caller is not the owner");
        _;
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(
            newOwner != address(0),
            "Ownable: new owner is the zero address"
        );
        _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }

    function owner() public view virtual returns (address) {
        return _owner;
    }

    function name() public view virtual returns (string memory) {
        return _name;
    }

    function symbol() public view virtual returns (string memory) {
        return _symbol;
    }

    function decimals() public view virtual returns (uint8) {
        return 18;
    }

    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(
        address account
    ) public view virtual override returns (uint256) {
        return _balances[account];
    }

    function allowance(
        address the_owner,
        address spender
    ) public view virtual override returns (uint256) {
        return _allowances[the_owner][spender];
    }

    function approve(
        address spender,
        uint256 amount
    ) public virtual override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function increaseAllowance(
        address spender,
        uint256 addedValue
    ) public virtual returns (bool) {
        _approve(
            msg.sender,
            spender,
            _allowances[msg.sender][spender] + addedValue
        );
        return true;
    }

    function decreaseAllowance(
        address spender,
        uint256 subtractedValue
    ) public virtual returns (bool) {
        uint256 currentAllowance = _allowances[msg.sender][spender];
        require(
            currentAllowance >= subtractedValue,
            "ERC20: decreased allowance below zero"
        );
        unchecked {
            _approve(msg.sender, spender, currentAllowance - subtractedValue);
        }

        return true;
    }

    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: burn from the zero address");

        uint256 accountBalance = _balances[account];
        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
        unchecked {
            _balances[account] = accountBalance - amount;
        }
        _totalSupply -= amount;

        emit Transfer(account, address(0), amount);
    }

    function _approve(
        address the_owner,
        address spender,
        uint256 amount
    ) internal virtual {
        require(
            the_owner != address(0),
            "ERC20: approve from the zero address"
        );
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[the_owner][spender] = amount;
        emit Approval(the_owner, spender, amount);
    }

    function _transfer(
        address sender,
        address recipient,
        uint256 amount
    ) internal virtual {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        uint256 senderBalance = _balances[sender];
        require(
            senderBalance >= amount,
            "ERC20: transfer amount exceeds balance"
        );
        unchecked {
            _balances[sender] = senderBalance - amount;
        }
        _balances[recipient] += amount;

        emit Transfer(sender, recipient, amount);
    }

    function transfer(
        address _recipient,
        uint256 _amount
    ) public override returns (bool) {
        _transfer(msg.sender, _recipient, _amount);

        return true;
    }

    function transferFrom(
        address the_owner,
        address _recipient,
        uint256 _amount
    ) public override returns (bool) {
        _transfer(the_owner, _recipient, _amount);

        uint256 currentAllowance = allowance(the_owner, msg.sender);
        require(
            currentAllowance >= _amount,
            "ERC20: transfer amount exceeds allowance"
        );
        unchecked {
            _approve(the_owner, msg.sender, currentAllowance.sub(_amount));
        }

        return true;
    }
}


// File: /contracts/libraries/ABDKMathQuad.sol
// SPDX-License-Identifier: BSD-4-Clause
/*
 * ABDK Math Quad Smart Contract Library.  Copyright Â© 2019 by ABDK Consulting.
 * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>
 */
pragma solidity ^0.8.0;

/**
 * Smart contract library of mathematical functions operating with IEEE 754
 * quadruple-precision binary floating-point numbers (quadruple precision
 * numbers).  As long as quadruple precision numbers are 16-bytes long, they are
 * represented by bytes16 type.
 */
library ABDKMathQuad {
    /*
     * 0.
     */
    bytes16 private constant POSITIVE_ZERO = 0x00000000000000000000000000000000;

    /*
     * -0.
     */
    bytes16 private constant NEGATIVE_ZERO = 0x80000000000000000000000000000000;

    /*
     * +Infinity.
     */
    bytes16 private constant POSITIVE_INFINITY =
        0x7FFF0000000000000000000000000000;

    /*
     * -Infinity.
     */
    bytes16 private constant NEGATIVE_INFINITY =
        0xFFFF0000000000000000000000000000;

    /*
     * Canonical NaN value.
     */
    bytes16 private constant NaN = 0x7FFF8000000000000000000000000000;

    /**
     * Convert signed 256-bit integer number into quadruple precision number.
     *
     * @param x signed 256-bit integer number
     * @return quadruple precision number
     */
    function fromInt(int256 x) internal pure returns (bytes16) {
        unchecked {
            if (x == 0) return bytes16(0);
            else {
                // We rely on overflow behavior here
                uint256 result = uint256(x > 0 ? x : -x);

                uint256 msb = mostSignificantBit(result);
                if (msb < 112) result <<= 112 - msb;
                else if (msb > 112) result >>= msb - 112;

                result =
                    (result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |
                    ((16383 + msb) << 112);
                if (x < 0) result |= 0x80000000000000000000000000000000;

                return bytes16(uint128(result));
            }
        }
    }

    /**
     * Convert quadruple precision number into signed 256-bit integer number
     * rounding towards zero.  Revert on overflow.
     *
     * @param x quadruple precision number
     * @return signed 256-bit integer number
     */
    function toInt(bytes16 x) internal pure returns (int256) {
        unchecked {
            uint256 exponent = (uint128(x) >> 112) & 0x7FFF;

            require(exponent <= 16638); // Overflow
            if (exponent < 16383) return 0; // Underflow

            uint256 result = (uint256(uint128(x)) &
                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |
                0x10000000000000000000000000000;

            if (exponent < 16495) result >>= 16495 - exponent;
            else if (exponent > 16495) result <<= exponent - 16495;

            if (uint128(x) >= 0x80000000000000000000000000000000) {
                // Negative
                require(
                    result <=
                        0x8000000000000000000000000000000000000000000000000000000000000000
                );
                return -int256(result); // We rely on overflow behavior here
            } else {
                require(
                    result <=
                        0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
                );
                return int256(result);
            }
        }
    }

    /**
     * Convert unsigned 256-bit integer number into quadruple precision number.
     *
     * @param x unsigned 256-bit integer number
     * @return quadruple precision number
     */
    function fromUInt(uint256 x) internal pure returns (bytes16) {
        unchecked {
            if (x == 0) return bytes16(0);
            else {
                uint256 result = x;

                uint256 msb = mostSignificantBit(result);
                if (msb < 112) result <<= 112 - msb;
                else if (msb > 112) result >>= msb - 112;

                result =
                    (result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |
                    ((16383 + msb) << 112);

                return bytes16(uint128(result));
            }
        }
    }

    /**
     * Convert quadruple precision number into unsigned 256-bit integer number
     * rounding towards zero.  Revert on underflow.  Note, that negative floating
     * point numbers in range (-1.0 .. 0.0) may be converted to unsigned integer
     * without error, because they are rounded to zero.
     *
     * @param x quadruple precision number
     * @return unsigned 256-bit integer number
     */
    function toUInt(bytes16 x) internal pure returns (uint256) {
        unchecked {
            uint256 exponent = (uint128(x) >> 112) & 0x7FFF;

            if (exponent < 16383) return 0; // Underflow

            require(uint128(x) < 0x80000000000000000000000000000000); // Negative

            require(exponent <= 16638); // Overflow
            uint256 result = (uint256(uint128(x)) &
                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |
                0x10000000000000000000000000000;

            if (exponent < 16495) result >>= 16495 - exponent;
            else if (exponent > 16495) result <<= exponent - 16495;

            return result;
        }
    }

    /**
     * Convert signed 128.128 bit fixed point number into quadruple precision
     * number.
     *
     * @param x signed 128.128 bit fixed point number
     * @return quadruple precision number
     */
    function from128x128(int256 x) internal pure returns (bytes16) {
        unchecked {
            if (x == 0) return bytes16(0);
            else {
                // We rely on overflow behavior here
                uint256 result = uint256(x > 0 ? x : -x);

                uint256 msb = mostSignificantBit(result);
                if (msb < 112) result <<= 112 - msb;
                else if (msb > 112) result >>= msb - 112;

                result =
                    (result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |
                    ((16255 + msb) << 112);
                if (x < 0) result |= 0x80000000000000000000000000000000;

                return bytes16(uint128(result));
            }
        }
    }

    /**
     * Convert quadruple precision number into signed 128.128 bit fixed point
     * number.  Revert on overflow.
     *
     * @param x quadruple precision number
     * @return signed 128.128 bit fixed point number
     */
    function to128x128(bytes16 x) internal pure returns (int256) {
        unchecked {
            uint256 exponent = (uint128(x) >> 112) & 0x7FFF;

            require(exponent <= 16510); // Overflow
            if (exponent < 16255) return 0; // Underflow

            uint256 result = (uint256(uint128(x)) &
                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |
                0x10000000000000000000000000000;

            if (exponent < 16367) result >>= 16367 - exponent;
            else if (exponent > 16367) result <<= exponent - 16367;

            if (uint128(x) >= 0x80000000000000000000000000000000) {
                // Negative
                require(
                    result <=
                        0x8000000000000000000000000000000000000000000000000000000000000000
                );
                return -int256(result); // We rely on overflow behavior here
            } else {
                require(
                    result <=
                        0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
                );
                return int256(result);
            }
        }
    }

    /**
     * Convert signed 64.64 bit fixed point number into quadruple precision
     * number.
     *
     * @param x signed 64.64 bit fixed point number
     * @return quadruple precision number
     */
    function from64x64(int128 x) internal pure returns (bytes16) {
        unchecked {
            if (x == 0) return bytes16(0);
            else {
                // We rely on overflow behavior here
                uint256 result = uint128(x > 0 ? x : -x);

                uint256 msb = mostSignificantBit(result);
                if (msb < 112) result <<= 112 - msb;
                else if (msb > 112) result >>= msb - 112;

                result =
                    (result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |
                    ((16319 + msb) << 112);
                if (x < 0) result |= 0x80000000000000000000000000000000;

                return bytes16(uint128(result));
            }
        }
    }

    /**
     * Convert quadruple precision number into signed 64.64 bit fixed point
     * number.  Revert on overflow.
     *
     * @param x quadruple precision number
     * @return signed 64.64 bit fixed point number
     */
    function to64x64(bytes16 x) internal pure returns (int128) {
        unchecked {
            uint256 exponent = (uint128(x) >> 112) & 0x7FFF;

            require(exponent <= 16446); // Overflow
            if (exponent < 16319) return 0; // Underflow

            uint256 result = (uint256(uint128(x)) &
                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |
                0x10000000000000000000000000000;

            if (exponent < 16431) result >>= 16431 - exponent;
            else if (exponent > 16431) result <<= exponent - 16431;

            if (uint128(x) >= 0x80000000000000000000000000000000) {
                // Negative
                require(result <= 0x80000000000000000000000000000000);
                return -int128(int256(result)); // We rely on overflow behavior here
            } else {
                require(result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);
                return int128(int256(result));
            }
        }
    }

    /**
     * Convert octuple precision number into quadruple precision number.
     *
     * @param x octuple precision number
     * @return quadruple precision number
     */
    function fromOctuple(bytes32 x) internal pure returns (bytes16) {
        unchecked {
            bool negative = x &
                0x8000000000000000000000000000000000000000000000000000000000000000 >
                0;

            uint256 exponent = (uint256(x) >> 236) & 0x7FFFF;
            uint256 significand = uint256(x) &
                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;

            if (exponent == 0x7FFFF) {
                if (significand > 0) return NaN;
                else return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;
            }

            if (exponent > 278526)
                return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;
            else if (exponent < 245649)
                return negative ? NEGATIVE_ZERO : POSITIVE_ZERO;
            else if (exponent < 245761) {
                significand =
                    (significand |
                        0x100000000000000000000000000000000000000000000000000000000000) >>
                    (245885 - exponent);
                exponent = 0;
            } else {
                significand >>= 124;
                exponent -= 245760;
            }

            uint128 result = uint128(significand | (exponent << 112));
            if (negative) result |= 0x80000000000000000000000000000000;

            return bytes16(result);
        }
    }

    /**
     * Convert quadruple precision number into octuple precision number.
     *
     * @param x quadruple precision number
     * @return octuple precision number
     */
    function toOctuple(bytes16 x) internal pure returns (bytes32) {
        unchecked {
            uint256 exponent = (uint128(x) >> 112) & 0x7FFF;

            uint256 result = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;

            if (exponent == 0x7FFF)
                exponent = 0x7FFFF; // Infinity or NaN
            else if (exponent == 0) {
                if (result > 0) {
                    uint256 msb = mostSignificantBit(result);
                    result =
                        (result << (236 - msb)) &
                        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
                    exponent = 245649 + msb;
                }
            } else {
                result <<= 124;
                exponent += 245760;
            }

            result |= exponent << 236;
            if (uint128(x) >= 0x80000000000000000000000000000000)
                result |= 0x8000000000000000000000000000000000000000000000000000000000000000;

            return bytes32(result);
        }
    }

    /**
     * Convert double precision number into quadruple precision number.
     *
     * @param x double precision number
     * @return quadruple precision number
     */
    function fromDouble(bytes8 x) internal pure returns (bytes16) {
        unchecked {
            uint256 exponent = (uint64(x) >> 52) & 0x7FF;

            uint256 result = uint64(x) & 0xFFFFFFFFFFFFF;

            if (exponent == 0x7FF)
                exponent = 0x7FFF; // Infinity or NaN
            else if (exponent == 0) {
                if (result > 0) {
                    uint256 msb = mostSignificantBit(result);
                    result =
                        (result << (112 - msb)) &
                        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
                    exponent = 15309 + msb;
                }
            } else {
                result <<= 60;
                exponent += 15360;
            }

            result |= exponent << 112;
            if (x & 0x8000000000000000 > 0)
                result |= 0x80000000000000000000000000000000;

            return bytes16(uint128(result));
        }
    }

    /**
     * Convert quadruple precision number into double precision number.
     *
     * @param x quadruple precision number
     * @return double precision number
     */
    function toDouble(bytes16 x) internal pure returns (bytes8) {
        unchecked {
            bool negative = uint128(x) >= 0x80000000000000000000000000000000;

            uint256 exponent = (uint128(x) >> 112) & 0x7FFF;
            uint256 significand = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;

            if (exponent == 0x7FFF) {
                if (significand > 0) return 0x7FF8000000000000;
                // NaN
                else
                    return
                        negative
                            ? bytes8(0xFFF0000000000000) // -Infinity
                            : bytes8(0x7FF0000000000000); // Infinity
            }

            if (exponent > 17406)
                return
                    negative
                        ? bytes8(0xFFF0000000000000) // -Infinity
                        : bytes8(0x7FF0000000000000);
            // Infinity
            else if (exponent < 15309)
                return
                    negative
                        ? bytes8(0x8000000000000000) // -0
                        : bytes8(0x0000000000000000);
            // 0
            else if (exponent < 15361) {
                significand =
                    (significand | 0x10000000000000000000000000000) >>
                    (15421 - exponent);
                exponent = 0;
            } else {
                significand >>= 60;
                exponent -= 15360;
            }

            uint64 result = uint64(significand | (exponent << 52));
            if (negative) result |= 0x8000000000000000;

            return bytes8(result);
        }
    }

    /**
     * Test whether given quadruple precision number is NaN.
     *
     * @param x quadruple precision number
     * @return true if x is NaN, false otherwise
     */
    function isNaN(bytes16 x) internal pure returns (bool) {
        unchecked {
            return
                uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF >
                0x7FFF0000000000000000000000000000;
        }
    }

    /**
     * Test whether given quadruple precision number is positive or negative
     * infinity.
     *
     * @param x quadruple precision number
     * @return true if x is positive or negative infinity, false otherwise
     */
    function isInfinity(bytes16 x) internal pure returns (bool) {
        unchecked {
            return
                uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ==
                0x7FFF0000000000000000000000000000;
        }
    }

    /**
     * Calculate sign of x, i.e. -1 if x is negative, 0 if x if zero, and 1 if x
     * is positive.  Note that sign (-0) is zero.  Revert if x is NaN.
     *
     * @param x quadruple precision number
     * @return sign of x
     */
    function sign(bytes16 x) internal pure returns (int8) {
        unchecked {
            uint128 absoluteX = uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;

            require(absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN

            if (absoluteX == 0) return 0;
            else if (uint128(x) >= 0x80000000000000000000000000000000)
                return -1;
            else return 1;
        }
    }

    /**
     * Calculate sign (x - y).  Revert if either argument is NaN, or both
     * arguments are infinities of the same sign.
     *
     * @param x quadruple precision number
     * @param y quadruple precision number
     * @return sign (x - y)
     */
    function cmp(bytes16 x, bytes16 y) internal pure returns (int8) {
        unchecked {
            uint128 absoluteX = uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;

            require(absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN

            uint128 absoluteY = uint128(y) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;

            require(absoluteY <= 0x7FFF0000000000000000000000000000); // Not NaN

            // Not infinities of the same sign
            require(x != y || absoluteX < 0x7FFF0000000000000000000000000000);

            if (x == y) return 0;
            else {
                bool negativeX = uint128(x) >=
                    0x80000000000000000000000000000000;
                bool negativeY = uint128(y) >=
                    0x80000000000000000000000000000000;

                if (negativeX) {
                    if (negativeY) return absoluteX > absoluteY ? -1 : int8(1);
                    else return -1;
                } else {
                    if (negativeY) return 1;
                    else return absoluteX > absoluteY ? int8(1) : -1;
                }
            }
        }
    }

    /**
     * Test whether x equals y.  NaN, infinity, and -infinity are not equal to
     * anything.
     *
     * @param x quadruple precision number
     * @param y quadruple precision number
     * @return true if x equals to y, false otherwise
     */
    function eq(bytes16 x, bytes16 y) internal pure returns (bool) {
        unchecked {
            if (x == y) {
                return
                    uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF <
                    0x7FFF0000000000000000000000000000;
            } else return false;
        }
    }

    /**
     * Calculate x + y.  Special values behave in the following way:
     *
     * NaN + x = NaN for any x.
     * Infinity + x = Infinity for any finite x.
     * -Infinity + x = -Infinity for any finite x.
     * Infinity + Infinity = Infinity.
     * -Infinity + -Infinity = -Infinity.
     * Infinity + -Infinity = -Infinity + Infinity = NaN.
     *
     * @param x quadruple precision number
     * @param y quadruple precision number
     * @return quadruple precision number
     */
    function add(bytes16 x, bytes16 y) internal pure returns (bytes16) {
        unchecked {
            uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;
            uint256 yExponent = (uint128(y) >> 112) & 0x7FFF;

            if (xExponent == 0x7FFF) {
                if (yExponent == 0x7FFF) {
                    if (x == y) return x;
                    else return NaN;
                } else return x;
            } else if (yExponent == 0x7FFF) return y;
            else {
                bool xSign = uint128(x) >= 0x80000000000000000000000000000000;
                uint256 xSignifier = uint128(x) &
                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
                if (xExponent == 0) xExponent = 1;
                else xSignifier |= 0x10000000000000000000000000000;

                bool ySign = uint128(y) >= 0x80000000000000000000000000000000;
                uint256 ySignifier = uint128(y) &
                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
                if (yExponent == 0) yExponent = 1;
                else ySignifier |= 0x10000000000000000000000000000;

                if (xSignifier == 0)
                    return y == NEGATIVE_ZERO ? POSITIVE_ZERO : y;
                else if (ySignifier == 0)
                    return x == NEGATIVE_ZERO ? POSITIVE_ZERO : x;
                else {
                    int256 delta = int256(xExponent) - int256(yExponent);

                    if (xSign == ySign) {
                        if (delta > 112) return x;
                        else if (delta > 0) ySignifier >>= uint256(delta);
                        else if (delta < -112) return y;
                        else if (delta < 0) {
                            xSignifier >>= uint256(-delta);
                            xExponent = yExponent;
                        }

                        xSignifier += ySignifier;

                        if (xSignifier >= 0x20000000000000000000000000000) {
                            xSignifier >>= 1;
                            xExponent += 1;
                        }

                        if (xExponent == 0x7FFF)
                            return
                                xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;
                        else {
                            if (xSignifier < 0x10000000000000000000000000000)
                                xExponent = 0;
                            else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;

                            return
                                bytes16(
                                    uint128(
                                        (
                                            xSign
                                                ? 0x80000000000000000000000000000000
                                                : 0
                                        ) |
                                            (xExponent << 112) |
                                            xSignifier
                                    )
                                );
                        }
                    } else {
                        if (delta > 0) {
                            xSignifier <<= 1;
                            xExponent -= 1;
                        } else if (delta < 0) {
                            ySignifier <<= 1;
                            xExponent = yExponent - 1;
                        }

                        if (delta > 112) ySignifier = 1;
                        else if (delta > 1)
                            ySignifier =
                                ((ySignifier - 1) >> uint256(delta - 1)) +
                                1;
                        else if (delta < -112) xSignifier = 1;
                        else if (delta < -1)
                            xSignifier =
                                ((xSignifier - 1) >> uint256(-delta - 1)) +
                                1;

                        if (xSignifier >= ySignifier) xSignifier -= ySignifier;
                        else {
                            xSignifier = ySignifier - xSignifier;
                            xSign = ySign;
                        }

                        if (xSignifier == 0) return POSITIVE_ZERO;

                        uint256 msb = mostSignificantBit(xSignifier);

                        if (msb == 113) {
                            xSignifier =
                                (xSignifier >> 1) &
                                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
                            xExponent += 1;
                        } else if (msb < 112) {
                            uint256 shift = 112 - msb;
                            if (xExponent > shift) {
                                xSignifier =
                                    (xSignifier << shift) &
                                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
                                xExponent -= shift;
                            } else {
                                xSignifier <<= xExponent - 1;
                                xExponent = 0;
                            }
                        } else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;

                        if (xExponent == 0x7FFF)
                            return
                                xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;
                        else
                            return
                                bytes16(
                                    uint128(
                                        (
                                            xSign
                                                ? 0x80000000000000000000000000000000
                                                : 0
                                        ) |
                                            (xExponent << 112) |
                                            xSignifier
                                    )
                                );
                    }
                }
            }
        }
    }

    /**
     * Calculate x - y.  Special values behave in the following way:
     *
     * NaN - x = NaN for any x.
     * Infinity - x = Infinity for any finite x.
     * -Infinity - x = -Infinity for any finite x.
     * Infinity - -Infinity = Infinity.
     * -Infinity - Infinity = -Infinity.
     * Infinity - Infinity = -Infinity - -Infinity = NaN.
     *
     * @param x quadruple precision number
     * @param y quadruple precision number
     * @return quadruple precision number
     */
    function sub(bytes16 x, bytes16 y) internal pure returns (bytes16) {
        unchecked {
            return add(x, y ^ 0x80000000000000000000000000000000);
        }
    }

    /**
     * Calculate x * y.  Special values behave in the following way:
     *
     * NaN * x = NaN for any x.
     * Infinity * x = Infinity for any finite positive x.
     * Infinity * x = -Infinity for any finite negative x.
     * -Infinity * x = -Infinity for any finite positive x.
     * -Infinity * x = Infinity for any finite negative x.
     * Infinity * 0 = NaN.
     * -Infinity * 0 = NaN.
     * Infinity * Infinity = Infinity.
     * Infinity * -Infinity = -Infinity.
     * -Infinity * Infinity = -Infinity.
     * -Infinity * -Infinity = Infinity.
     *
     * @param x quadruple precision number
     * @param y quadruple precision number
     * @return quadruple precision number
     */
    function mul(bytes16 x, bytes16 y) internal pure returns (bytes16) {
        unchecked {
            uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;
            uint256 yExponent = (uint128(y) >> 112) & 0x7FFF;

            if (xExponent == 0x7FFF) {
                if (yExponent == 0x7FFF) {
                    if (x == y)
                        return x ^ (y & 0x80000000000000000000000000000000);
                    else if (x ^ y == 0x80000000000000000000000000000000)
                        return x | y;
                    else return NaN;
                } else {
                    if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;
                    else return x ^ (y & 0x80000000000000000000000000000000);
                }
            } else if (yExponent == 0x7FFF) {
                if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;
                else return y ^ (x & 0x80000000000000000000000000000000);
            } else {
                uint256 xSignifier = uint128(x) &
                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
                if (xExponent == 0) xExponent = 1;
                else xSignifier |= 0x10000000000000000000000000000;

                uint256 ySignifier = uint128(y) &
                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
                if (yExponent == 0) yExponent = 1;
                else ySignifier |= 0x10000000000000000000000000000;

                xSignifier *= ySignifier;
                if (xSignifier == 0)
                    return
                        (x ^ y) & 0x80000000000000000000000000000000 > 0
                            ? NEGATIVE_ZERO
                            : POSITIVE_ZERO;

                xExponent += yExponent;

                uint256 msb = xSignifier >=
                    0x200000000000000000000000000000000000000000000000000000000
                    ? 225
                    : xSignifier >=
                        0x100000000000000000000000000000000000000000000000000000000
                    ? 224
                    : mostSignificantBit(xSignifier);

                if (xExponent + msb < 16496) {
                    // Underflow
                    xExponent = 0;
                    xSignifier = 0;
                } else if (xExponent + msb < 16608) {
                    // Subnormal
                    if (xExponent < 16496) xSignifier >>= 16496 - xExponent;
                    else if (xExponent > 16496)
                        xSignifier <<= xExponent - 16496;
                    xExponent = 0;
                } else if (xExponent + msb > 49373) {
                    xExponent = 0x7FFF;
                    xSignifier = 0;
                } else {
                    if (msb > 112) xSignifier >>= msb - 112;
                    else if (msb < 112) xSignifier <<= 112 - msb;

                    xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;

                    xExponent = xExponent + msb - 16607;
                }

                return
                    bytes16(
                        uint128(
                            uint128(
                                (x ^ y) & 0x80000000000000000000000000000000
                            ) |
                                (xExponent << 112) |
                                xSignifier
                        )
                    );
            }
        }
    }

    /**
     * Calculate x / y.  Special values behave in the following way:
     *
     * NaN / x = NaN for any x.
     * x / NaN = NaN for any x.
     * Infinity / x = Infinity for any finite non-negative x.
     * Infinity / x = -Infinity for any finite negative x including -0.
     * -Infinity / x = -Infinity for any finite non-negative x.
     * -Infinity / x = Infinity for any finite negative x including -0.
     * x / Infinity = 0 for any finite non-negative x.
     * x / -Infinity = -0 for any finite non-negative x.
     * x / Infinity = -0 for any finite non-negative x including -0.
     * x / -Infinity = 0 for any finite non-negative x including -0.
     *
     * Infinity / Infinity = NaN.
     * Infinity / -Infinity = -NaN.
     * -Infinity / Infinity = -NaN.
     * -Infinity / -Infinity = NaN.
     *
     * Division by zero behaves in the following way:
     *
     * x / 0 = Infinity for any finite positive x.
     * x / -0 = -Infinity for any finite positive x.
     * x / 0 = -Infinity for any finite negative x.
     * x / -0 = Infinity for any finite negative x.
     * 0 / 0 = NaN.
     * 0 / -0 = NaN.
     * -0 / 0 = NaN.
     * -0 / -0 = NaN.
     *
     * @param x quadruple precision number
     * @param y quadruple precision number
     * @return quadruple precision number
     */
    function div(bytes16 x, bytes16 y) internal pure returns (bytes16) {
        unchecked {
            uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;
            uint256 yExponent = (uint128(y) >> 112) & 0x7FFF;

            if (xExponent == 0x7FFF) {
                if (yExponent == 0x7FFF) return NaN;
                else return x ^ (y & 0x80000000000000000000000000000000);
            } else if (yExponent == 0x7FFF) {
                if (y & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF != 0) return NaN;
                else
                    return
                        POSITIVE_ZERO |
                        ((x ^ y) & 0x80000000000000000000000000000000);
            } else if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) {
                if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;
                else
                    return
                        POSITIVE_INFINITY |
                        ((x ^ y) & 0x80000000000000000000000000000000);
            } else {
                uint256 ySignifier = uint128(y) &
                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
                if (yExponent == 0) yExponent = 1;
                else ySignifier |= 0x10000000000000000000000000000;

                uint256 xSignifier = uint128(x) &
                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
                if (xExponent == 0) {
                    if (xSignifier != 0) {
                        uint256 shift = 226 - mostSignificantBit(xSignifier);

                        xSignifier <<= shift;

                        xExponent = 1;
                        yExponent += shift - 114;
                    }
                } else {
                    xSignifier =
                        (xSignifier | 0x10000000000000000000000000000) <<
                        114;
                }

                xSignifier = xSignifier / ySignifier;
                if (xSignifier == 0)
                    return
                        (x ^ y) & 0x80000000000000000000000000000000 > 0
                            ? NEGATIVE_ZERO
                            : POSITIVE_ZERO;

                assert(xSignifier >= 0x1000000000000000000000000000);

                uint256 msb = xSignifier >= 0x80000000000000000000000000000
                    ? mostSignificantBit(xSignifier)
                    : xSignifier >= 0x40000000000000000000000000000
                    ? 114
                    : xSignifier >= 0x20000000000000000000000000000
                    ? 113
                    : 112;

                if (xExponent + msb > yExponent + 16497) {
                    // Overflow
                    xExponent = 0x7FFF;
                    xSignifier = 0;
                } else if (xExponent + msb + 16380 < yExponent) {
                    // Underflow
                    xExponent = 0;
                    xSignifier = 0;
                } else if (xExponent + msb + 16268 < yExponent) {
                    // Subnormal
                    if (xExponent + 16380 > yExponent)
                        xSignifier <<= xExponent + 16380 - yExponent;
                    else if (xExponent + 16380 < yExponent)
                        xSignifier >>= yExponent - xExponent - 16380;

                    xExponent = 0;
                } else {
                    // Normal
                    if (msb > 112) xSignifier >>= msb - 112;

                    xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;

                    xExponent = xExponent + msb + 16269 - yExponent;
                }

                return
                    bytes16(
                        uint128(
                            uint128(
                                (x ^ y) & 0x80000000000000000000000000000000
                            ) |
                                (xExponent << 112) |
                                xSignifier
                        )
                    );
            }
        }
    }

    /**
     * Calculate -x.
     *
     * @param x quadruple precision number
     * @return quadruple precision number
     */
    function neg(bytes16 x) internal pure returns (bytes16) {
        unchecked {
            return x ^ 0x80000000000000000000000000000000;
        }
    }

    /**
     * Calculate |x|.
     *
     * @param x quadruple precision number
     * @return quadruple precision number
     */
    function abs(bytes16 x) internal pure returns (bytes16) {
        unchecked {
            return x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
        }
    }

    /**
     * Calculate square root of x.  Return NaN on negative x excluding -0.
     *
     * @param x quadruple precision number
     * @return quadruple precision number
     */
    function sqrt(bytes16 x) internal pure returns (bytes16) {
        unchecked {
            if (uint128(x) > 0x80000000000000000000000000000000) return NaN;
            else {
                uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;
                if (xExponent == 0x7FFF) return x;
                else {
                    uint256 xSignifier = uint128(x) &
                        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
                    if (xExponent == 0) xExponent = 1;
                    else xSignifier |= 0x10000000000000000000000000000;

                    if (xSignifier == 0) return POSITIVE_ZERO;

                    bool oddExponent = xExponent & 0x1 == 0;
                    xExponent = (xExponent + 16383) >> 1;

                    if (oddExponent) {
                        if (xSignifier >= 0x10000000000000000000000000000)
                            xSignifier <<= 113;
                        else {
                            uint256 msb = mostSignificantBit(xSignifier);
                            uint256 shift = (226 - msb) & 0xFE;
                            xSignifier <<= shift;
                            xExponent -= (shift - 112) >> 1;
                        }
                    } else {
                        if (xSignifier >= 0x10000000000000000000000000000)
                            xSignifier <<= 112;
                        else {
                            uint256 msb = mostSignificantBit(xSignifier);
                            uint256 shift = (225 - msb) & 0xFE;
                            xSignifier <<= shift;
                            xExponent -= (shift - 112) >> 1;
                        }
                    }

                    uint256 r = 0x10000000000000000000000000000;
                    r = (r + xSignifier / r) >> 1;
                    r = (r + xSignifier / r) >> 1;
                    r = (r + xSignifier / r) >> 1;
                    r = (r + xSignifier / r) >> 1;
                    r = (r + xSignifier / r) >> 1;
                    r = (r + xSignifier / r) >> 1;
                    r = (r + xSignifier / r) >> 1; // Seven iterations should be enough
                    uint256 r1 = xSignifier / r;
                    if (r1 < r) r = r1;

                    return
                        bytes16(
                            uint128(
                                (xExponent << 112) |
                                    (r & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF)
                            )
                        );
                }
            }
        }
    }

    /**
     * Calculate binary logarithm of x.  Return NaN on negative x excluding -0.
     *
     * @param x quadruple precision number
     * @return quadruple precision number
     */
    function log_2(bytes16 x) internal pure returns (bytes16) {
        unchecked {
            if (uint128(x) > 0x80000000000000000000000000000000) return NaN;
            else if (x == 0x3FFF0000000000000000000000000000)
                return POSITIVE_ZERO;
            else {
                uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;
                if (xExponent == 0x7FFF) return x;
                else {
                    uint256 xSignifier = uint128(x) &
                        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
                    if (xExponent == 0) xExponent = 1;
                    else xSignifier |= 0x10000000000000000000000000000;

                    if (xSignifier == 0) return NEGATIVE_INFINITY;

                    bool resultNegative;
                    uint256 resultExponent = 16495;
                    uint256 resultSignifier;

                    if (xExponent >= 0x3FFF) {
                        resultNegative = false;
                        resultSignifier = xExponent - 0x3FFF;
                        xSignifier <<= 15;
                    } else {
                        resultNegative = true;
                        if (xSignifier >= 0x10000000000000000000000000000) {
                            resultSignifier = 0x3FFE - xExponent;
                            xSignifier <<= 15;
                        } else {
                            uint256 msb = mostSignificantBit(xSignifier);
                            resultSignifier = 16493 - msb;
                            xSignifier <<= 127 - msb;
                        }
                    }

                    if (xSignifier == 0x80000000000000000000000000000000) {
                        if (resultNegative) resultSignifier += 1;
                        uint256 shift = 112 -
                            mostSignificantBit(resultSignifier);
                        resultSignifier <<= shift;
                        resultExponent -= shift;
                    } else {
                        uint256 bb = resultNegative ? 1 : 0;
                        while (
                            resultSignifier < 0x10000000000000000000000000000
                        ) {
                            resultSignifier <<= 1;
                            resultExponent -= 1;

                            xSignifier *= xSignifier;
                            uint256 b = xSignifier >> 255;
                            resultSignifier += b ^ bb;
                            xSignifier >>= 127 + b;
                        }
                    }

                    return
                        bytes16(
                            uint128(
                                (
                                    resultNegative
                                        ? 0x80000000000000000000000000000000
                                        : 0
                                ) |
                                    (resultExponent << 112) |
                                    (resultSignifier &
                                        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF)
                            )
                        );
                }
            }
        }
    }

    /**
     * Calculate natural logarithm of x.  Return NaN on negative x excluding -0.
     *
     * @param x quadruple precision number
     * @return quadruple precision number
     */
    function ln(bytes16 x) internal pure returns (bytes16) {
        unchecked {
            return mul(log_2(x), 0x3FFE62E42FEFA39EF35793C7673007E5);
        }
    }

    /**
     * Calculate 2^x.
     *
     * @param x quadruple precision number
     * @return quadruple precision number
     */
    function pow_2(bytes16 x) internal pure returns (bytes16) {
        unchecked {
            bool xNegative = uint128(x) > 0x80000000000000000000000000000000;
            uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;
            uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;

            if (xExponent == 0x7FFF && xSignifier != 0) return NaN;
            else if (xExponent > 16397)
                return xNegative ? POSITIVE_ZERO : POSITIVE_INFINITY;
            else if (xExponent < 16255)
                return 0x3FFF0000000000000000000000000000;
            else {
                if (xExponent == 0) xExponent = 1;
                else xSignifier |= 0x10000000000000000000000000000;

                if (xExponent > 16367) xSignifier <<= xExponent - 16367;
                else if (xExponent < 16367) xSignifier >>= 16367 - xExponent;

                if (
                    xNegative &&
                    xSignifier > 0x406E00000000000000000000000000000000
                ) return POSITIVE_ZERO;

                if (
                    !xNegative &&
                    xSignifier > 0x3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
                ) return POSITIVE_INFINITY;

                uint256 resultExponent = xSignifier >> 128;
                xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
                if (xNegative && xSignifier != 0) {
                    xSignifier = ~xSignifier;
                    resultExponent += 1;
                }

                uint256 resultSignifier = 0x80000000000000000000000000000000;
                if (xSignifier & 0x80000000000000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x16A09E667F3BCC908B2FB1366EA957D3E) >>
                        128;
                if (xSignifier & 0x40000000000000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1306FE0A31B7152DE8D5A46305C85EDEC) >>
                        128;
                if (xSignifier & 0x20000000000000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1172B83C7D517ADCDF7C8C50EB14A791F) >>
                        128;
                if (xSignifier & 0x10000000000000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10B5586CF9890F6298B92B71842A98363) >>
                        128;
                if (xSignifier & 0x8000000000000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1059B0D31585743AE7C548EB68CA417FD) >>
                        128;
                if (xSignifier & 0x4000000000000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x102C9A3E778060EE6F7CACA4F7A29BDE8) >>
                        128;
                if (xSignifier & 0x2000000000000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10163DA9FB33356D84A66AE336DCDFA3F) >>
                        128;
                if (xSignifier & 0x1000000000000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100B1AFA5ABCBED6129AB13EC11DC9543) >>
                        128;
                if (xSignifier & 0x800000000000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10058C86DA1C09EA1FF19D294CF2F679B) >>
                        128;
                if (xSignifier & 0x400000000000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1002C605E2E8CEC506D21BFC89A23A00F) >>
                        128;
                if (xSignifier & 0x200000000000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100162F3904051FA128BCA9C55C31E5DF) >>
                        128;
                if (xSignifier & 0x100000000000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1000B175EFFDC76BA38E31671CA939725) >>
                        128;
                if (xSignifier & 0x80000000000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100058BA01FB9F96D6CACD4B180917C3D) >>
                        128;
                if (xSignifier & 0x40000000000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10002C5CC37DA9491D0985C348C68E7B3) >>
                        128;
                if (xSignifier & 0x20000000000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1000162E525EE054754457D5995292026) >>
                        128;
                if (xSignifier & 0x10000000000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10000B17255775C040618BF4A4ADE83FC) >>
                        128;
                if (xSignifier & 0x8000000000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1000058B91B5BC9AE2EED81E9B7D4CFAB) >>
                        128;
                if (xSignifier & 0x4000000000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100002C5C89D5EC6CA4D7C8ACC017B7C9) >>
                        128;
                if (xSignifier & 0x2000000000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10000162E43F4F831060E02D839A9D16D) >>
                        128;
                if (xSignifier & 0x1000000000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100000B1721BCFC99D9F890EA06911763) >>
                        128;
                if (xSignifier & 0x800000000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10000058B90CF1E6D97F9CA14DBCC1628) >>
                        128;
                if (xSignifier & 0x400000000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1000002C5C863B73F016468F6BAC5CA2B) >>
                        128;
                if (xSignifier & 0x200000000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100000162E430E5A18F6119E3C02282A5) >>
                        128;
                if (xSignifier & 0x100000000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1000000B1721835514B86E6D96EFD1BFE) >>
                        128;
                if (xSignifier & 0x80000000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100000058B90C0B48C6BE5DF846C5B2EF) >>
                        128;
                if (xSignifier & 0x40000000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10000002C5C8601CC6B9E94213C72737A) >>
                        128;
                if (xSignifier & 0x20000000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1000000162E42FFF037DF38AA2B219F06) >>
                        128;
                if (xSignifier & 0x10000000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10000000B17217FBA9C739AA5819F44F9) >>
                        128;
                if (xSignifier & 0x8000000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1000000058B90BFCDEE5ACD3C1CEDC823) >>
                        128;
                if (xSignifier & 0x4000000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100000002C5C85FE31F35A6A30DA1BE50) >>
                        128;
                if (xSignifier & 0x2000000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10000000162E42FF0999CE3541B9FFFCF) >>
                        128;
                if (xSignifier & 0x1000000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100000000B17217F80F4EF5AADDA45554) >>
                        128;
                if (xSignifier & 0x800000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10000000058B90BFBF8479BD5A81B51AD) >>
                        128;
                if (xSignifier & 0x400000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1000000002C5C85FDF84BD62AE30A74CC) >>
                        128;
                if (xSignifier & 0x200000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100000000162E42FEFB2FED257559BDAA) >>
                        128;
                if (xSignifier & 0x100000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1000000000B17217F7D5A7716BBA4A9AE) >>
                        128;
                if (xSignifier & 0x80000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100000000058B90BFBE9DDBAC5E109CCE) >>
                        128;
                if (xSignifier & 0x40000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10000000002C5C85FDF4B15DE6F17EB0D) >>
                        128;
                if (xSignifier & 0x20000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1000000000162E42FEFA494F1478FDE05) >>
                        128;
                if (xSignifier & 0x10000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10000000000B17217F7D20CF927C8E94C) >>
                        128;
                if (xSignifier & 0x8000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1000000000058B90BFBE8F71CB4E4B33D) >>
                        128;
                if (xSignifier & 0x4000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100000000002C5C85FDF477B662B26945) >>
                        128;
                if (xSignifier & 0x2000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10000000000162E42FEFA3AE53369388C) >>
                        128;
                if (xSignifier & 0x1000000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100000000000B17217F7D1D351A389D40) >>
                        128;
                if (xSignifier & 0x800000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10000000000058B90BFBE8E8B2D3D4EDE) >>
                        128;
                if (xSignifier & 0x400000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1000000000002C5C85FDF4741BEA6E77E) >>
                        128;
                if (xSignifier & 0x200000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100000000000162E42FEFA39FE95583C2) >>
                        128;
                if (xSignifier & 0x100000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1000000000000B17217F7D1CFB72B45E1) >>
                        128;
                if (xSignifier & 0x80000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100000000000058B90BFBE8E7CC35C3F0) >>
                        128;
                if (xSignifier & 0x40000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10000000000002C5C85FDF473E242EA38) >>
                        128;
                if (xSignifier & 0x20000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1000000000000162E42FEFA39F02B772C) >>
                        128;
                if (xSignifier & 0x10000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10000000000000B17217F7D1CF7D83C1A) >>
                        128;
                if (xSignifier & 0x8000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1000000000000058B90BFBE8E7BDCBE2E) >>
                        128;
                if (xSignifier & 0x4000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100000000000002C5C85FDF473DEA871F) >>
                        128;
                if (xSignifier & 0x2000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10000000000000162E42FEFA39EF44D91) >>
                        128;
                if (xSignifier & 0x1000000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100000000000000B17217F7D1CF79E949) >>
                        128;
                if (xSignifier & 0x800000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10000000000000058B90BFBE8E7BCE544) >>
                        128;
                if (xSignifier & 0x400000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1000000000000002C5C85FDF473DE6ECA) >>
                        128;
                if (xSignifier & 0x200000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100000000000000162E42FEFA39EF366F) >>
                        128;
                if (xSignifier & 0x100000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1000000000000000B17217F7D1CF79AFA) >>
                        128;
                if (xSignifier & 0x80000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100000000000000058B90BFBE8E7BCD6D) >>
                        128;
                if (xSignifier & 0x40000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10000000000000002C5C85FDF473DE6B2) >>
                        128;
                if (xSignifier & 0x20000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1000000000000000162E42FEFA39EF358) >>
                        128;
                if (xSignifier & 0x10000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10000000000000000B17217F7D1CF79AB) >>
                        128;
                if (xSignifier & 0x8000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1000000000000000058B90BFBE8E7BCD5) >>
                        128;
                if (xSignifier & 0x4000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100000000000000002C5C85FDF473DE6A) >>
                        128;
                if (xSignifier & 0x2000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10000000000000000162E42FEFA39EF34) >>
                        128;
                if (xSignifier & 0x1000000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100000000000000000B17217F7D1CF799) >>
                        128;
                if (xSignifier & 0x800000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10000000000000000058B90BFBE8E7BCC) >>
                        128;
                if (xSignifier & 0x400000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1000000000000000002C5C85FDF473DE5) >>
                        128;
                if (xSignifier & 0x200000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100000000000000000162E42FEFA39EF2) >>
                        128;
                if (xSignifier & 0x100000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1000000000000000000B17217F7D1CF78) >>
                        128;
                if (xSignifier & 0x80000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100000000000000000058B90BFBE8E7BB) >>
                        128;
                if (xSignifier & 0x40000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10000000000000000002C5C85FDF473DD) >>
                        128;
                if (xSignifier & 0x20000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1000000000000000000162E42FEFA39EE) >>
                        128;
                if (xSignifier & 0x10000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10000000000000000000B17217F7D1CF6) >>
                        128;
                if (xSignifier & 0x8000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1000000000000000000058B90BFBE8E7A) >>
                        128;
                if (xSignifier & 0x4000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100000000000000000002C5C85FDF473C) >>
                        128;
                if (xSignifier & 0x2000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10000000000000000000162E42FEFA39D) >>
                        128;
                if (xSignifier & 0x1000000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100000000000000000000B17217F7D1CE) >>
                        128;
                if (xSignifier & 0x800000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10000000000000000000058B90BFBE8E6) >>
                        128;
                if (xSignifier & 0x400000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1000000000000000000002C5C85FDF472) >>
                        128;
                if (xSignifier & 0x200000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100000000000000000000162E42FEFA38) >>
                        128;
                if (xSignifier & 0x100000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1000000000000000000000B17217F7D1B) >>
                        128;
                if (xSignifier & 0x80000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100000000000000000000058B90BFBE8D) >>
                        128;
                if (xSignifier & 0x40000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10000000000000000000002C5C85FDF46) >>
                        128;
                if (xSignifier & 0x20000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1000000000000000000000162E42FEFA2) >>
                        128;
                if (xSignifier & 0x10000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10000000000000000000000B17217F7D0) >>
                        128;
                if (xSignifier & 0x8000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1000000000000000000000058B90BFBE7) >>
                        128;
                if (xSignifier & 0x4000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100000000000000000000002C5C85FDF3) >>
                        128;
                if (xSignifier & 0x2000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10000000000000000000000162E42FEF9) >>
                        128;
                if (xSignifier & 0x1000000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100000000000000000000000B17217F7C) >>
                        128;
                if (xSignifier & 0x800000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10000000000000000000000058B90BFBD) >>
                        128;
                if (xSignifier & 0x400000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1000000000000000000000002C5C85FDE) >>
                        128;
                if (xSignifier & 0x200000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100000000000000000000000162E42FEE) >>
                        128;
                if (xSignifier & 0x100000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1000000000000000000000000B17217F6) >>
                        128;
                if (xSignifier & 0x80000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100000000000000000000000058B90BFA) >>
                        128;
                if (xSignifier & 0x40000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10000000000000000000000002C5C85FC) >>
                        128;
                if (xSignifier & 0x20000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1000000000000000000000000162E42FD) >>
                        128;
                if (xSignifier & 0x10000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10000000000000000000000000B17217E) >>
                        128;
                if (xSignifier & 0x8000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1000000000000000000000000058B90BE) >>
                        128;
                if (xSignifier & 0x4000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100000000000000000000000002C5C85E) >>
                        128;
                if (xSignifier & 0x2000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10000000000000000000000000162E42E) >>
                        128;
                if (xSignifier & 0x1000000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100000000000000000000000000B17216) >>
                        128;
                if (xSignifier & 0x800000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10000000000000000000000000058B90A) >>
                        128;
                if (xSignifier & 0x400000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1000000000000000000000000002C5C84) >>
                        128;
                if (xSignifier & 0x200000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100000000000000000000000000162E41) >>
                        128;
                if (xSignifier & 0x100000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1000000000000000000000000000B1720) >>
                        128;
                if (xSignifier & 0x80000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100000000000000000000000000058B8F) >>
                        128;
                if (xSignifier & 0x40000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10000000000000000000000000002C5C7) >>
                        128;
                if (xSignifier & 0x20000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1000000000000000000000000000162E3) >>
                        128;
                if (xSignifier & 0x10000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10000000000000000000000000000B171) >>
                        128;
                if (xSignifier & 0x8000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1000000000000000000000000000058B8) >>
                        128;
                if (xSignifier & 0x4000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100000000000000000000000000002C5B) >>
                        128;
                if (xSignifier & 0x2000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10000000000000000000000000000162D) >>
                        128;
                if (xSignifier & 0x1000 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100000000000000000000000000000B16) >>
                        128;
                if (xSignifier & 0x800 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10000000000000000000000000000058A) >>
                        128;
                if (xSignifier & 0x400 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1000000000000000000000000000002C4) >>
                        128;
                if (xSignifier & 0x200 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100000000000000000000000000000161) >>
                        128;
                if (xSignifier & 0x100 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x1000000000000000000000000000000B0) >>
                        128;
                if (xSignifier & 0x80 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100000000000000000000000000000057) >>
                        128;
                if (xSignifier & 0x40 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10000000000000000000000000000002B) >>
                        128;
                if (xSignifier & 0x20 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100000000000000000000000000000015) >>
                        128;
                if (xSignifier & 0x10 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x10000000000000000000000000000000A) >>
                        128;
                if (xSignifier & 0x8 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100000000000000000000000000000004) >>
                        128;
                if (xSignifier & 0x4 > 0)
                    resultSignifier =
                        (resultSignifier *
                            0x100000000000000000000000000000001) >>
                        128;

                if (!xNegative) {
                    resultSignifier =
                        (resultSignifier >> 15) &
                        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
                    resultExponent += 0x3FFF;
                } else if (resultExponent <= 0x3FFE) {
                    resultSignifier =
                        (resultSignifier >> 15) &
                        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
                    resultExponent = 0x3FFF - resultExponent;
                } else {
                    resultSignifier =
                        resultSignifier >>
                        (resultExponent - 16367);
                    resultExponent = 0;
                }

                return
                    bytes16(uint128((resultExponent << 112) | resultSignifier));
            }
        }
    }

    /**
     * Calculate e^x.
     *
     * @param x quadruple precision number
     * @return quadruple precision number
     */
    function exp(bytes16 x) internal pure returns (bytes16) {
        unchecked {
            return pow_2(mul(x, 0x3FFF71547652B82FE1777D0FFDA0D23A));
        }
    }

    /**
     * Get index of the most significant non-zero bit in binary representation of
     * x.  Reverts if x is zero.
     *
     * @return index of the most significant non-zero bit in binary representation
     *         of x
     */
    function mostSignificantBit(uint256 x) private pure returns (uint256) {
        unchecked {
            require(x > 0);

            uint256 result = 0;

            if (x >= 0x100000000000000000000000000000000) {
                x >>= 128;
                result += 128;
            }
            if (x >= 0x10000000000000000) {
                x >>= 64;
                result += 64;
            }
            if (x >= 0x100000000) {
                x >>= 32;
                result += 32;
            }
            if (x >= 0x10000) {
                x >>= 16;
                result += 16;
            }
            if (x >= 0x100) {
                x >>= 8;
                result += 8;
            }
            if (x >= 0x10) {
                x >>= 4;
                result += 4;
            }
            if (x >= 0x4) {
                x >>= 2;
                result += 2;
            }
            if (x >= 0x2) result += 1; // No need to shift x anymore

            return result;
        }
    }
}


// File: /contracts/interfaces/DexRouter.sol
pragma solidity >=0.6.2;

interface DexRouter {
    function WETH() external pure returns (address);

    function getAmountsOut(uint256 amountIn, address[] calldata path)
        external
        view
        returns (uint256[] memory amounts);

    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;

    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable;

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;
}


// File: /contracts/TreasuryV1.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "./interfaces/DexRouter.sol";

import "./libraries/ABDKMathQuad.sol";
import "./ProjectManager.sol";
import "./ArtikProjectManager.sol";
import "./ArtikStakeManager.sol";
import "./ArtikProjectManagerV2.sol";
import "./ArtikStakeManagerV2.sol";
import "./ArtikStakeManagerV1.sol";
import "./ArtikProjectManagerV1.sol";

import "./StakeManagerV1.sol";
import "./ProjectManagerV1.sol";

contract TreasuryV1 is Initializable {
    using SafeMath for uint256;

    // Pancakeswap 0x10ED43C718714eb63d5aA57B78B54704E256024E (testnet: 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3)
    address constant ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
    // WBNB 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c (testnet: 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd)
    address constant WETH = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
    // BUSD 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56 (testnet: 0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7)
    address constant STABLE_COIN = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;

    uint256 private constant BUY_BACK_FEE = 25; //(2% of total fee)
    uint256 private accumulatedEthForAirdrop;

    DexRouter private dexRouter;

    address private artikToken;
    address payable private admin;

    address[] public shareholders;
    uint256 private shareholderCount;
    mapping(address => uint256) private shareholderIndexes;

    mapping(address => mapping(uint256 => bool)) private userClaimedProject;
    uint256 public totalAmountAirdropped;
    mapping(address => uint256) public amountClaimed;

    uint256 public airdropBalance;
    uint256 public totalHoldersBalance;
    uint256 public airdropDate;

    mapping(address => mapping(uint256 => mapping(uint256 => bool)))
        private userHasClaimedProject;

    mapping(uint256 => uint256) private airdropSnapshot;
    uint256 private stableCoinBalance;

    ProjectManager private projectManager; // to remove
    address private projectManagerAddress;

    mapping(address => uint256) public holderSellingDays;
    uint256 private holdingDays;

    ArtikProjectManager private artikProjectManager;
    ArtikStakeManager private artikStakeManager;
    mapping(uint256 => uint256) public airdropDates;

    ArtikProjectManagerV2 private artikProjectManagerV2;
    ArtikStakeManagerV2 private artikStakeManagerV2;
    ArtikStakeManagerV1 private artikStakeManagerV1;
    ArtikProjectManagerV1 private artikProjectManagerV1;

    StakeManagerV1 private stakeManagerV1;
    ProjectManagerV1 private projectManagerV1;

    modifier onlyAdmin() {
        require(
            msg.sender == admin ||
                msg.sender == artikToken ||
                msg.sender == projectManagerAddress
        );
        _;
    }

    function initialize(address _tokenAddress) public initializer {
        dexRouter = DexRouter(ROUTER);
        artikToken = _tokenAddress;
        admin = payable(msg.sender);
        shareholderCount = 0;
        totalAmountAirdropped = 0;
        accumulatedEthForAirdrop = 0;
        totalHoldersBalance = 0;
        airdropBalance = 0;
        stableCoinBalance = 0;
    }

    function configureManagers(
        address _projectManagerAddr,
        address _stakeManagerAddr
    ) external onlyAdmin {
        require(_projectManagerAddr != address(0x0));
        require(_stakeManagerAddr != address(0x0));
        projectManagerAddress = _projectManagerAddr;
        projectManagerV1 = ProjectManagerV1(_projectManagerAddr);
        stakeManagerV1 = StakeManagerV1(_stakeManagerAddr);
    }

    function getAirdropDate(
        uint256 _roundNumber
    ) external view returns (uint256) {
        require(_roundNumber > 0);
        return airdropDates[_roundNumber];
    }

    function setAirdropDate(uint256 _days) public onlyAdmin {
        require(_days > 0);
        airdropDates[projectManagerV1.roundNumber()] =
            block.timestamp +
            (1 days * _days);
    }

    // Initialize airdrop
    // 1) approveAirdrop
    // 2) buyBack
    // 3) buyAirdropTokens
    // 4) initializeNextRound
    function approveAirdrop() external onlyAdmin {
        uint256 stableBalance = IERC20(STABLE_COIN).balanceOf(address(this));
        require(stableBalance > 0);

        IERC20(STABLE_COIN).approve(ROUTER, stableBalance);
        (uint256 amountWethMin, ) = getAmountOutMin(
            stableBalance,
            STABLE_COIN,
            WETH
        );
        IERC20(WETH).approve(ROUTER, amountWethMin);
    }

    function buyBack() external onlyAdmin {
        uint256 stableBalance = IERC20(STABLE_COIN).balanceOf(address(this));
        require(stableBalance > 0);

        swapTokensForETH(mulDiv(stableBalance, BUY_BACK_FEE, 100), STABLE_COIN);
        swapETHForTokens(address(this).balance, artikToken);
        IERC20(artikToken).transfer(
            address(0x0),
            IERC20(artikToken).balanceOf(address(this))
        );
    }

    function buyAirdropTokens(
        uint256 _amount,
        address _token1,
        address _token2
    ) external onlyAdmin {
        require(_amount > 0);
        require(_token1 != address(0x0));
        require(_token2 != address(0x0));
        require(
            IERC20(_token1).balanceOf(address(this)) >= _amount,
            "balance less than _amount"
        );

        address[] memory path = new address[](2);
        path[0] = _token1;
        path[1] = _token2;

        dexRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            _amount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

    function initializeNextRound(uint256 _days) external onlyAdmin {
        require(_days > 0);

        projectManagerV1.nextRound();
        setAirdropDate(_days);
        airdropBalance = IERC20(projectManagerV1.getBestProject().tokenAddress)
            .balanceOf(address(this));
    }

    // End Airdrop

    function claimAirdrop() public {
        uint256 airdrop = calculateAirdropAmount(msg.sender);

        IERC20(projectManagerV1.getBestProject().tokenAddress).transfer(
            msg.sender,
            airdrop
        );

        projectManagerV1.setVoter(msg.sender, false);
        userHasClaimedProject[msg.sender][projectManagerV1.roundNumber()][
            projectManagerV1.getBestProject().id
        ] = true;
    }

    function calculateTVL(uint256 _roundNumber) public view returns (uint256) {
        uint256 currentBalance = 0;
        address[] memory stakeholders = stakeManagerV1.getShareHolders();
        for (uint256 i = 0; i < stakeholders.length; i++) {
            currentBalance = currentBalance.add(
                stakeManagerV1.getStakedBalance(stakeholders[i], _roundNumber)
            );
        }
        return currentBalance;
    }

    function calculateAirdropAmount(
        address _shareholder
    ) public view returns (uint256) {
        uint256 _previousRoundNumber = projectManagerV1.roundNumber() - 1;
        uint256 _currentRoundNumber = projectManagerV1.roundNumber();
        uint256 tvl = calculateTVL(_previousRoundNumber);

        require(
            projectManagerV1.isShareholderVoter(_shareholder),
            "not a voter"
        );
        require(
            _shareholder != address(0x0),
            "shareholder cannot be address of 0"
        );

        require(tvl > 0, "tvl less than 0");
        require(
            userHasClaimedProject[_shareholder][_currentRoundNumber][
                projectManagerV1.getBestProject().id
            ] != true,
            "shareholder has already claimed this airdrop"
        );

        return
            calculateAirdrop(
                _shareholder,
                tvl,
                airdropBalance,
                projectManagerV1.getBestProject().tokenAddress,
                _previousRoundNumber
            );
    }

    function calculateHolderPercentage(
        address _shareholder,
        uint256 _tvl,
        uint256 _roundNumber
    ) private view returns (uint256) {
        // 100 : x = tvl : holderBalance
        uint256 holderBalance = stakeManagerV1.getStakedBalance(
            _shareholder,
            _roundNumber
        );
        return mulDiv(holderBalance, 1000000, _tvl);
    }

    function calculateExpectedAirdrop(
        address _shareholder
    ) external view returns (uint256) {
        require(
            _shareholder != address(0x0),
            "shareholder address cannot be 0"
        );

        uint256 currentRoundNumber = projectManagerV1.roundNumber();
        uint256 holderBalance = stakeManagerV1.getStakedBalance(
            _shareholder,
            currentRoundNumber
        );
        require(
            holderBalance > 0,
            "shareholder balance must be greater than 0"
        );

        uint256 treasuryForAirdrop = mulDiv(
            IERC20(STABLE_COIN).balanceOf(address(this)),
            75,
            100
        );

        return
            calculateAirdrop(
                _shareholder,
                calculateTVL(currentRoundNumber),
                treasuryForAirdrop,
                STABLE_COIN,
                currentRoundNumber
            );
    }

    function calculateAirdrop(
        address _shareholder,
        uint256 _tvl,
        uint256 _airdropBalance,
        address _tokenToAirdrop,
        uint256 _roundNumber
    ) private view returns (uint256) {
        require(
            _shareholder != address(0x0),
            "shareholder address cannot be 0"
        );
        require(_tvl > 0, "tvl must be greater than 0");
        require(_airdropBalance > 0, "airdrop balance must be greater than 0");
        require(_tokenToAirdrop != address(0x0), "token address cannot be 0");
        require(_roundNumber > 0, "round number must be greater than 0");

        uint256 holderPercentage = calculateHolderPercentage(
            _shareholder,
            _tvl,
            _roundNumber
        );

        uint256 airdropBasedOnHoldingAmount = mulDiv(
            _airdropBalance,
            holderPercentage,
            1000000
        );

        uint256 stakingPercentageTime = stakeManagerV1
            .calculateStakingPercentageTime(_shareholder, _roundNumber);

        return
            mulDiv(airdropBasedOnHoldingAmount, stakingPercentageTime, 1000000);
    }

    function swapETHForTokens(uint256 _amount, address _token) private {
        require(_amount > 0, "amount less than 0");
        require(_token != address(0x0), "address is not valid");
        require(address(this).balance >= _amount, "balance less than _amount");

        address[] memory path = new address[](2);
        path[0] = WETH;
        path[1] = _token;

        dexRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{
            value: _amount
        }(0, path, address(this), block.timestamp);
    }

    function swapTokensForETH(uint256 _amount, address _token) private {
        require(_amount > 0);
        require(_token != address(0x0));
        require(
            IERC20(_token).balanceOf(address(this)) >= _amount,
            "balance less than _amount"
        );

        address[] memory path = new address[](2);
        path[0] = _token;
        path[1] = WETH;

        dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(
            _amount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

    function getAmountOutMin(
        uint256 _amount,
        address _tokenIn,
        address _tokenOut
    ) private view returns (uint256, address[] memory) {
        address[] memory path = new address[](2);
        path[0] = _tokenIn;
        path[1] = _tokenOut;

        uint256[] memory amountOutMins = dexRouter.getAmountsOut(_amount, path);
        return (amountOutMins[1], path);
    }

    function swapTokens() external onlyAdmin {
        IERC20(WETH).approve(ROUTER, address(this).balance);
        swapETHForTokens(address(this).balance, STABLE_COIN);
    }

    function withdraw(address _token) external onlyAdmin {
        require(_token != address(0x0));
        uint256 remainingBalance = IERC20(_token).balanceOf(address(this));
        require(remainingBalance > 0);
        IERC20(_token).transfer(admin, remainingBalance);
    }

    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 z
    ) public pure returns (uint256) {
        return
            ABDKMathQuad.toUInt(
                ABDKMathQuad.div(
                    ABDKMathQuad.mul(
                        ABDKMathQuad.fromUInt(x),
                        ABDKMathQuad.fromUInt(y)
                    ),
                    ABDKMathQuad.fromUInt(z)
                )
            );
    }

    receive() external payable {}
}


// File: /contracts/TreasuryV0.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "./interfaces/DexRouter.sol";

import "./libraries/ABDKMathQuad.sol";
import "./ProjectManager.sol";
import "./ArtikProjectManager.sol";
import "./ArtikStakeManager.sol";
import "./ArtikProjectManagerV2.sol";
import "./ArtikStakeManagerV2.sol";
import "./ArtikStakeManagerV1.sol";
import "./ArtikProjectManagerV1.sol";

import "./StakeManagerV1.sol";
import "./ProjectManagerV1.sol";
import "./StakeManagerV0.sol";
import "./ProjectManagerV0.sol";

contract TreasuryV0 is Initializable {
    using SafeMath for uint256;

    // Pancakeswap 0x10ED43C718714eb63d5aA57B78B54704E256024E (testnet: 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3)
    address constant ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
    // WBNB 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c (testnet: 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd)
    address constant WETH = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
    // BUSD 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56 (testnet: 0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7)
    address constant STABLE_COIN = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;

    uint256 private constant BUY_BACK_FEE = 25; //(2% of total fee)
    uint256 private accumulatedEthForAirdrop;

    DexRouter private dexRouter;

    address private artikToken;
    address payable private admin;

    address[] public shareholders;
    uint256 private shareholderCount;
    mapping(address => uint256) private shareholderIndexes;

    mapping(address => mapping(uint256 => bool)) private userClaimedProject;
    uint256 public totalAmountAirdropped;
    mapping(address => uint256) public amountClaimed;

    uint256 public airdropBalance;
    uint256 public totalHoldersBalance;
    uint256 public airdropDate;

    mapping(address => mapping(uint256 => mapping(uint256 => bool)))
        private userHasClaimedProject;

    mapping(uint256 => uint256) private airdropSnapshot;
    uint256 private stableCoinBalance;

    ProjectManager private projectManager; // to remove
    address private projectManagerAddress;

    mapping(address => uint256) public holderSellingDays;
    uint256 private holdingDays;

    ArtikProjectManager private artikProjectManager;
    ArtikStakeManager private artikStakeManager;
    mapping(uint256 => uint256) public airdropDates;

    ArtikProjectManagerV2 private artikProjectManagerV2;
    ArtikStakeManagerV2 private artikStakeManagerV2;
    ArtikStakeManagerV1 private artikStakeManagerV1;
    ArtikProjectManagerV1 private artikProjectManagerV1;

    StakeManagerV1 private stakeManagerV1;
    ProjectManagerV1 private projectManagerV1;
    StakeManagerV0 private stakeManagerV0;
    ProjectManagerV0 private projectManagerV0;

    modifier onlyAdmin() {
        require(
            msg.sender == admin ||
                msg.sender == artikToken ||
                msg.sender == projectManagerAddress
        );
        _;
    }

    function initialize(address _tokenAddress) public initializer {
        dexRouter = DexRouter(ROUTER);
        artikToken = _tokenAddress;
        admin = payable(msg.sender);
        shareholderCount = 0;
        totalAmountAirdropped = 0;
        accumulatedEthForAirdrop = 0;
        totalHoldersBalance = 0;
        airdropBalance = 0;
        stableCoinBalance = 0;
    }

    function configureManagers(
        address _projectManagerAddr,
        address _stakeManagerAddr
    ) external onlyAdmin {
        require(_projectManagerAddr != address(0x0));
        require(_stakeManagerAddr != address(0x0));
        projectManagerAddress = _projectManagerAddr;
        projectManagerV0 = ProjectManagerV0(_projectManagerAddr);
        stakeManagerV0 = StakeManagerV0(_stakeManagerAddr);
    }

    function getAirdropDate(
        uint256 _roundNumber
    ) external view returns (uint256) {
        require(_roundNumber > 0);
        return airdropDates[_roundNumber];
    }

    function setAirdropDate(uint256 _days) public onlyAdmin {
        require(_days > 0);
        airdropDates[projectManagerV0.roundNumber()] =
            block.timestamp +
            (1 days * _days);
    }

    // Initialize airdrop
    // 1) approveAirdrop
    // 2) buyBack
    // 3) buyAirdropTokens
    // 4) initializeNextRound
    function approveAirdrop() external onlyAdmin {
        uint256 stableBalance = IERC20(STABLE_COIN).balanceOf(address(this));
        require(stableBalance > 0);

        IERC20(STABLE_COIN).approve(ROUTER, stableBalance);
        (uint256 amountWethMin, ) = getAmountOutMin(
            stableBalance,
            STABLE_COIN,
            WETH
        );
        IERC20(WETH).approve(ROUTER, amountWethMin);
    }

    function buyBack() external onlyAdmin {
        uint256 stableBalance = IERC20(STABLE_COIN).balanceOf(address(this));
        require(stableBalance > 0);

        swapTokensForETH(mulDiv(stableBalance, BUY_BACK_FEE, 100), STABLE_COIN);
        swapETHForTokens(address(this).balance, artikToken);
        IERC20(artikToken).transfer(
            address(0x0),
            IERC20(artikToken).balanceOf(address(this))
        );
    }

    function buyAirdropTokens(
        uint256 _amount,
        address _token1,
        address _token2
    ) external onlyAdmin {
        require(_amount > 0);
        require(_token1 != address(0x0));
        require(_token2 != address(0x0));
        require(
            IERC20(_token1).balanceOf(address(this)) >= _amount,
            "balance less than _amount"
        );

        address[] memory path = new address[](2);
        path[0] = _token1;
        path[1] = _token2;

        dexRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            _amount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

    function initializeNextRound(uint256 _days) external onlyAdmin {
        require(_days > 0);

        totalHoldersBalance = calculateTVL(projectManagerV0.roundNumber());
        projectManagerV0.nextRound();
        setAirdropDate(_days);
        airdropBalance = IERC20(projectManagerV0.getBestProject().tokenAddress)
            .balanceOf(address(this));
    }

    // End Airdrop

    function claimAirdrop() public {
        uint256 airdrop = calculateAirdropAmount(msg.sender);

        IERC20(projectManagerV0.getBestProject().tokenAddress).transfer(
            msg.sender,
            airdrop
        );

        projectManagerV0.setVoter(msg.sender, false);
        userHasClaimedProject[msg.sender][projectManagerV0.roundNumber()][
            projectManagerV0.getBestProject().id
        ] = true;
    }

    function calculateTVL(uint256 _roundNumber) public view returns (uint256) {
        uint256 currentBalance = 0;
        address[] memory stakeholders = stakeManagerV0.getShareHolders();
        for (uint256 i = 0; i < stakeholders.length; i++) {
            currentBalance = currentBalance.add(
                stakeManagerV0.getStakedBalance(stakeholders[i], _roundNumber)
            );
        }
        return currentBalance;
    }

    function calculateAirdropAmount(
        address _shareholder
    ) public view returns (uint256) {
        uint256 _previousRoundNumber = projectManagerV0.roundNumber() - 1;
        uint256 _currentRoundNumber = projectManagerV0.roundNumber();

        require(
            projectManagerV0.isShareholderVoter(_shareholder),
            "not a voter"
        );
        require(
            _shareholder != address(0x0),
            "shareholder cannot be address of 0"
        );

        require(totalHoldersBalance > 0, "tvl less than 0");
        require(
            userHasClaimedProject[_shareholder][_currentRoundNumber][
                projectManagerV0.getBestProject().id
            ] != true,
            "shareholder has already claimed this airdrop"
        );

        return
            calculateAirdrop(
                _shareholder,
                totalHoldersBalance,
                airdropBalance,
                projectManagerV0.getBestProject().tokenAddress,
                _previousRoundNumber
            );
    }

    function calculateHolderPercentage(
        address _shareholder,
        uint256 _tvl,
        uint256 _roundNumber
    ) private view returns (uint256) {
        // 100 : x = tvl : holderBalance
        uint256 holderBalance = stakeManagerV0.getStakedBalance(
            _shareholder,
            _roundNumber
        );
        return mulDiv(holderBalance, 1000000, _tvl);
    }

    function calculateExpectedAirdrop(
        address _shareholder
    ) external view returns (uint256) {
        require(
            _shareholder != address(0x0),
            "shareholder address cannot be 0"
        );

        uint256 currentRoundNumber = projectManagerV0.roundNumber();
        uint256 holderBalance = stakeManagerV0.getStakedBalance(
            _shareholder,
            currentRoundNumber
        );
        require(
            holderBalance > 0,
            "shareholder balance must be greater than 0"
        );

        uint256 treasuryForAirdrop = mulDiv(
            IERC20(STABLE_COIN).balanceOf(address(this)),
            75,
            100
        );

        return
            calculateAirdrop(
                _shareholder,
                calculateTVL(currentRoundNumber),
                treasuryForAirdrop,
                STABLE_COIN,
                currentRoundNumber
            );
    }

    function calculateAirdrop(
        address _shareholder,
        uint256 _tvl,
        uint256 _airdropBalance,
        address _tokenToAirdrop,
        uint256 _roundNumber
    ) private view returns (uint256) {
        require(
            _shareholder != address(0x0),
            "shareholder address cannot be 0"
        );
        require(_tvl > 0, "tvl must be greater than 0");
        require(_airdropBalance > 0, "airdrop balance must be greater than 0");
        require(_tokenToAirdrop != address(0x0), "token address cannot be 0");
        require(_roundNumber > 0, "round number must be greater than 0");

        uint256 holderPercentage = calculateHolderPercentage(
            _shareholder,
            _tvl,
            _roundNumber
        );

        uint256 airdropBasedOnHoldingAmount = mulDiv(
            _airdropBalance,
            holderPercentage,
            1000000
        );

        uint256 stakingPercentageTime = stakeManagerV0
            .calculateStakingPercentageTime(_shareholder, _roundNumber);

        return
            mulDiv(airdropBasedOnHoldingAmount, stakingPercentageTime, 1000000);
    }

    function swapETHForTokens(uint256 _amount, address _token) private {
        require(_amount > 0, "amount less than 0");
        require(_token != address(0x0), "address is not valid");
        require(address(this).balance >= _amount, "balance less than _amount");

        address[] memory path = new address[](2);
        path[0] = WETH;
        path[1] = _token;

        dexRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{
            value: _amount
        }(0, path, address(this), block.timestamp);
    }

    function swapTokensForETH(uint256 _amount, address _token) private {
        require(_amount > 0);
        require(_token != address(0x0));
        require(
            IERC20(_token).balanceOf(address(this)) >= _amount,
            "balance less than _amount"
        );

        address[] memory path = new address[](2);
        path[0] = _token;
        path[1] = WETH;

        dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(
            _amount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

    function getAmountOutMin(
        uint256 _amount,
        address _tokenIn,
        address _tokenOut
    ) private view returns (uint256, address[] memory) {
        address[] memory path = new address[](2);
        path[0] = _tokenIn;
        path[1] = _tokenOut;

        uint256[] memory amountOutMins = dexRouter.getAmountsOut(_amount, path);
        return (amountOutMins[1], path);
    }

    function swapTokens() external onlyAdmin {
        IERC20(WETH).approve(ROUTER, address(this).balance);
        swapETHForTokens(address(this).balance, STABLE_COIN);
    }

    function withdraw(address _token) external onlyAdmin {
        require(_token != address(0x0));
        uint256 remainingBalance = IERC20(_token).balanceOf(address(this));
        require(remainingBalance > 0);
        IERC20(_token).transfer(admin, remainingBalance);
    }

    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 z
    ) public pure returns (uint256) {
        return
            ABDKMathQuad.toUInt(
                ABDKMathQuad.div(
                    ABDKMathQuad.mul(
                        ABDKMathQuad.fromUInt(x),
                        ABDKMathQuad.fromUInt(y)
                    ),
                    ABDKMathQuad.fromUInt(z)
                )
            );
    }

    receive() external payable {}
}


// File: /contracts/TreasuryManagerV0.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "./interfaces/DexRouter.sol";

import "./libraries/ABDKMathQuad.sol";
import "./ProjectManager.sol";
import "./ArtikProjectManager.sol";
import "./ArtikStakeManager.sol";
import "./ArtikProjectManagerV2.sol";
import "./ArtikStakeManagerV2.sol";
import "./ArtikStakeManagerV1.sol";
import "./ArtikProjectManagerV1.sol";

import "./StakeManagerV1.sol";
import "./ProjectManagerV1.sol";
import "./StakeManagerV0.sol";
import "./ProjectManagerV0.sol";

import "./StakesManagerV0.sol";
import "./ProjectsManagerV0.sol";

contract TreasuryManagerV0 is Initializable {
    using SafeMath for uint256;

    // Pancakeswap 0x10ED43C718714eb63d5aA57B78B54704E256024E (testnet: 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3)
    address constant ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
    // WBNB 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c (testnet: 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd)
    address constant WETH = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
    // BUSD 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56 (testnet: 0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7)
    address constant STABLE_COIN = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;

    uint256 private constant BUY_BACK_FEE = 25; //(2% of total fee)
    uint256 private accumulatedEthForAirdrop;

    DexRouter private dexRouter;

    address private artikToken;
    address payable private admin;

    address[] public shareholders;
    uint256 private shareholderCount;
    mapping(address => uint256) private shareholderIndexes;

    mapping(address => mapping(uint256 => bool)) private userClaimedProject;
    uint256 public totalAmountAirdropped;
    mapping(address => uint256) public amountClaimed;

    uint256 public airdropBalance;
    uint256 public totalHoldersBalance;
    uint256 public airdropDate;

    mapping(address => mapping(uint256 => mapping(uint256 => bool)))
        private userHasClaimedProject;

    mapping(uint256 => uint256) private airdropSnapshot;
    uint256 private stableCoinBalance;

    ProjectManager private projectManager; // to remove
    address private projectManagerAddress;

    mapping(address => uint256) public holderSellingDays;
    uint256 private holdingDays;

    ArtikProjectManager private artikProjectManager;
    ArtikStakeManager private artikStakeManager;
    mapping(uint256 => uint256) public airdropDates;

    ArtikProjectManagerV2 private artikProjectManagerV2;
    ArtikStakeManagerV2 private artikStakeManagerV2;
    ArtikStakeManagerV1 private artikStakeManagerV1;
    ArtikProjectManagerV1 private artikProjectManagerV1;

    StakeManagerV1 private stakeManagerV1;
    ProjectManagerV1 private projectManagerV1;
    StakeManagerV0 private stakeManagerV0;
    ProjectManagerV0 private projectManagerV0;

    StakesManagerV0 private stakesManagerV0;
    ProjectsManagerV0 private projectsManagerV0;

    modifier onlyAdmin() {
        require(
            msg.sender == admin ||
                msg.sender == artikToken ||
                msg.sender == projectManagerAddress
        );
        _;
    }

    function initialize(address _tokenAddress) public initializer {
        dexRouter = DexRouter(ROUTER);
        artikToken = _tokenAddress;
        admin = payable(msg.sender);
        shareholderCount = 0;
        totalAmountAirdropped = 0;
        accumulatedEthForAirdrop = 0;
        totalHoldersBalance = 0;
        airdropBalance = 0;
        stableCoinBalance = 0;
    }

    function configureManagers(
        address _projectManagerAddr,
        address _stakeManagerAddr
    ) external onlyAdmin {
        require(_projectManagerAddr != address(0x0));
        require(_stakeManagerAddr != address(0x0));
        projectManagerAddress = _projectManagerAddr;
        projectsManagerV0 = ProjectsManagerV0(_projectManagerAddr);
        stakesManagerV0 = StakesManagerV0(_stakeManagerAddr);
    }

    function getAirdropDate(
        uint256 _roundNumber
    ) external view returns (uint256) {
        require(_roundNumber > 0);
        return airdropDates[_roundNumber];
    }

    function setAirdropDate(uint256 _days) public onlyAdmin {
        require(_days > 0);
        airdropDates[projectsManagerV0.roundNumber()] =
            block.timestamp +
            (1 days * _days);
    }

    // Initialize airdrop
    // 1) approveAirdrop
    // 2) buyBack
    // 3) buyAirdropTokens
    // 4) initializeNextRound
    function approveAirdrop() external onlyAdmin {
        uint256 stableBalance = IERC20(STABLE_COIN).balanceOf(address(this));
        require(stableBalance > 0);

        IERC20(STABLE_COIN).approve(ROUTER, stableBalance);
        (uint256 amountWethMin, ) = getAmountOutMin(
            stableBalance,
            STABLE_COIN,
            WETH
        );
        IERC20(WETH).approve(ROUTER, amountWethMin);
    }

    function buyBack() external onlyAdmin {
        uint256 stableBalance = IERC20(STABLE_COIN).balanceOf(address(this));
        require(stableBalance > 0);

        swapTokensForETH(mulDiv(stableBalance, BUY_BACK_FEE, 100), STABLE_COIN);
        swapETHForTokens(address(this).balance, artikToken);
        IERC20(artikToken).transfer(
            address(0x0),
            IERC20(artikToken).balanceOf(address(this))
        );
    }

    function buyAirdropTokens(
        uint256 _amount,
        address _token1,
        address _token2
    ) external onlyAdmin {
        require(_amount > 0);
        require(_token1 != address(0x0));
        require(_token2 != address(0x0));
        require(
            IERC20(_token1).balanceOf(address(this)) >= _amount,
            "balance less than _amount"
        );

        IERC20(_token1).approve(address(this), _amount);

        address[] memory path = new address[](2);
        path[0] = _token1;
        path[1] = _token2;

        dexRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            _amount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

    function initializeNextRound(uint256 _days) external onlyAdmin {
        require(_days > 0);

        totalHoldersBalance = calculateTVL(projectsManagerV0.roundNumber());
        projectsManagerV0.nextRound();
        setAirdropDate(_days);
        airdropBalance = IERC20(projectsManagerV0.getBestProject().tokenAddress)
            .balanceOf(address(this));
    }

    // End Airdrop

    function claimAirdrop() public {
        uint256 airdrop = calculateAirdropAmount(msg.sender);

        IERC20(projectsManagerV0.getBestProject().tokenAddress).transfer(
            msg.sender,
            airdrop
        );

        projectsManagerV0.setVoter(msg.sender, false);
        userHasClaimedProject[msg.sender][projectsManagerV0.roundNumber()][
            projectsManagerV0.getBestProject().id
        ] = true;
    }

    function calculateTVL(uint256 _roundNumber) public view returns (uint256) {
        uint256 currentBalance = 0;
        address[] memory stakeholders = stakesManagerV0.getShareHolders();
        for (uint256 i = 0; i < stakeholders.length; i++) {
            currentBalance = currentBalance.add(
                stakesManagerV0.getStakedBalance(stakeholders[i], _roundNumber)
            );
        }
        return currentBalance;
    }

    function calculateAirdropAmount(
        address _shareholder
    ) public view returns (uint256) {
        uint256 _previousRoundNumber = projectsManagerV0.roundNumber() - 1;
        uint256 _currentRoundNumber = projectsManagerV0.roundNumber();

        require(
            projectsManagerV0.isShareholderVoter(_shareholder),
            "not a voter"
        );
        require(
            _shareholder != address(0x0),
            "shareholder cannot be address of 0"
        );

        require(totalHoldersBalance > 0, "tvl less than 0");
        require(
            userHasClaimedProject[_shareholder][_currentRoundNumber][
                projectsManagerV0.getBestProject().id
            ] != true,
            "shareholder has already claimed this airdrop"
        );

        return
            calculateAirdrop(
                _shareholder,
                totalHoldersBalance,
                airdropBalance,
                projectsManagerV0.getBestProject().tokenAddress,
                _previousRoundNumber
            );
    }

    function calculateHolderPercentage(
        address _shareholder,
        uint256 _tvl,
        uint256 _roundNumber
    ) private view returns (uint256) {
        // 100 : x = tvl : holderBalance
        uint256 holderBalance = stakesManagerV0.getStakedBalance(
            _shareholder,
            _roundNumber
        );
        return mulDiv(holderBalance, 1000000, _tvl);
    }

    function calculateExpectedAirdrop(
        address _shareholder
    ) external view returns (uint256) {
        require(
            _shareholder != address(0x0),
            "shareholder address cannot be 0"
        );

        uint256 currentRoundNumber = projectsManagerV0.roundNumber();
        uint256 holderBalance = stakesManagerV0.getStakedBalance(
            _shareholder,
            currentRoundNumber
        );
        require(
            holderBalance > 0,
            "shareholder balance must be greater than 0"
        );

        uint256 treasuryForAirdrop = mulDiv(
            IERC20(STABLE_COIN).balanceOf(address(this)),
            75,
            100
        );

        return
            calculateAirdrop(
                _shareholder,
                calculateTVL(currentRoundNumber),
                treasuryForAirdrop,
                STABLE_COIN,
                currentRoundNumber
            );
    }

    function calculateAirdrop(
        address _shareholder,
        uint256 _tvl,
        uint256 _airdropBalance,
        address _tokenToAirdrop,
        uint256 _roundNumber
    ) private view returns (uint256) {
        require(
            _shareholder != address(0x0),
            "shareholder address cannot be 0"
        );
        require(_tvl > 0, "tvl must be greater than 0");
        require(_airdropBalance > 0, "airdrop balance must be greater than 0");
        require(_tokenToAirdrop != address(0x0), "token address cannot be 0");
        require(_roundNumber > 0, "round number must be greater than 0");

        uint256 holderPercentage = calculateHolderPercentage(
            _shareholder,
            _tvl,
            _roundNumber
        );

        uint256 airdropBasedOnHoldingAmount = mulDiv(
            _airdropBalance,
            holderPercentage,
            1000000
        );

        uint256 stakingPercentageTime = stakesManagerV0
            .calculateStakingPercentageTime(_shareholder, _roundNumber);

        return
            mulDiv(airdropBasedOnHoldingAmount, stakingPercentageTime, 1000000);
    }

    function swapETHForTokens(uint256 _amount, address _token) private {
        require(_amount > 0, "amount less than 0");
        require(_token != address(0x0), "address is not valid");
        require(address(this).balance >= _amount, "balance less than _amount");

        address[] memory path = new address[](2);
        path[0] = WETH;
        path[1] = _token;

        dexRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{
            value: _amount
        }(0, path, address(this), block.timestamp);
    }

    function swapTokensForETH(uint256 _amount, address _token) private {
        require(_amount > 0);
        require(_token != address(0x0));
        require(
            IERC20(_token).balanceOf(address(this)) >= _amount,
            "balance less than _amount"
        );

        address[] memory path = new address[](2);
        path[0] = _token;
        path[1] = WETH;

        dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(
            _amount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

    function getAmountOutMin(
        uint256 _amount,
        address _tokenIn,
        address _tokenOut
    ) private view returns (uint256, address[] memory) {
        address[] memory path = new address[](2);
        path[0] = _tokenIn;
        path[1] = _tokenOut;

        uint256[] memory amountOutMins = dexRouter.getAmountsOut(_amount, path);
        return (amountOutMins[1], path);
    }

    function swapTokens() external onlyAdmin {
        IERC20(WETH).approve(ROUTER, address(this).balance);
        swapETHForTokens(address(this).balance, STABLE_COIN);
    }

    function withdraw(address _token) external onlyAdmin {
        require(_token != address(0x0));
        uint256 remainingBalance = IERC20(_token).balanceOf(address(this));
        require(remainingBalance > 0);
        IERC20(_token).transfer(admin, remainingBalance);
    }

    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 z
    ) public pure returns (uint256) {
        return
            ABDKMathQuad.toUInt(
                ABDKMathQuad.div(
                    ABDKMathQuad.mul(
                        ABDKMathQuad.fromUInt(x),
                        ABDKMathQuad.fromUInt(y)
                    ),
                    ABDKMathQuad.fromUInt(z)
                )
            );
    }

    receive() external payable {}
}


// File: /contracts/StakesManagerV0.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "./libraries/ABDKMathQuad.sol";

import "./ArtikTreasury.sol";
import "./ArtikProjectManager.sol";
import "./ArtikProjectManagerV2.sol";
import "./ArtikTreasuryV2.sol";
import "./ArtikTreasuryV1.sol";
import "./ArtikProjectManagerV1.sol";

import "./TreasuryV1.sol";
import "./ProjectManagerV1.sol";
import "./TreasuryV0.sol";
import "./ProjectManagerV0.sol";

import "./TreasuryManagerV0.sol";
import "./ProjectsManagerV0.sol";

contract StakesManagerV0 is Initializable {
    using SafeMath for uint256;

    address private artikToken;
    address payable private admin;

    ArtikTreasury private treasury;
    ArtikProjectManager private artikProjectManager;

    mapping(address => mapping(uint256 => Stake)) private stakedBalance;
    struct Stake {
        uint256 balance;
        uint256 time;
        bool staked;
    }

    address[] public shareholders;
    mapping(address => uint256) private shareholderIndexes;
    uint256 private shareholderCount;

    bool public penaltyIsActive;
    ArtikProjectManagerV2 private artikProjectManagerV2;
    ArtikTreasuryV2 private artikTreasuryV2;
    ArtikTreasuryV1 private artikTreasuryV1;
    ArtikProjectManagerV1 private artikProjectManagerV1;

    TreasuryV1 private treasuryV1;
    ProjectManagerV1 private projectManagerV1;
    TreasuryV0 private treasuryV0;
    ProjectManagerV0 private projectManagerV0;

    TreasuryManagerV0 private treasuryManagerV0;
    ProjectsManagerV0 private projectsManagerV0;

    function initialize(
        address _tokenAddress,
        address _treasuryAddress,
        address _projectManagerAddr
    ) public initializer {
        artikToken = _tokenAddress;
        treasuryManagerV0 = TreasuryManagerV0(payable(_treasuryAddress));
        projectsManagerV0 = ProjectsManagerV0(_projectManagerAddr);

        shareholderCount = 0;
        admin = payable(msg.sender);

        penaltyIsActive = true;
    }

    function configureManagers(
        address _projectManagerAddr,
        address _treasuryAddr
    ) external {
        require(msg.sender == admin);
        projectsManagerV0 = ProjectsManagerV0(_projectManagerAddr);
        treasuryManagerV0 = TreasuryManagerV0(payable(_treasuryAddr));
    }

    function managePenalty(bool _active) external {
        require(msg.sender == admin);
        penaltyIsActive = _active;
    }

    function getStakedBalance(
        address _shareholder,
        uint256 _roundNumber
    ) external view returns (uint256) {
        require(_shareholder != address(0x0));
        require(_roundNumber > 0);
        return stakedBalance[_shareholder][_roundNumber].balance;
    }

    function calculateStakingPercentageTime(
        address _shareholder,
        uint256 _roundNumber
    ) external view returns (uint256) {
        require(_shareholder != address(0x0));
        require(_roundNumber > 0);

        uint256 diff = (treasuryManagerV0.getAirdropDate(_roundNumber) -
            /*stakedBalance[_shareholder].time) /
            60 /
            60 /
            24;*/
            stakedBalance[_shareholder][_roundNumber].time);

        uint256 percentage = 1000000;
        if (penaltyIsActive && diff < 7 * 60 * 60 * 24) {
            percentage = mulDiv(diff, 1000000, 7 * 60 * 60 * 24);
        }
        return percentage;
    }

    function movePreviousStakes() external {
        require(shareholderIndexes[msg.sender] > 0, "not a stakeholder");

        uint256 currentRoundNumber = projectsManagerV0.roundNumber();

        for (uint256 i = 1; i <= currentRoundNumber - 1; i++) {
            if (stakedBalance[msg.sender][i].balance > 0) {
                addStakeHolder(
                    msg.sender,
                    stakedBalance[msg.sender][i].balance,
                    stakedBalance[msg.sender][i].time
                );
                stakedBalance[msg.sender][i].balance = 0;
            }
        }
    }

    function unstakeTokens(uint256 _amount) external {
        require(_amount > 0);

        uint256 currentRoundNumber = projectsManagerV0.roundNumber();
        require(
            _amount <= stakedBalance[msg.sender][currentRoundNumber].balance
        );
        require(stakedBalance[msg.sender][currentRoundNumber].balance > 0);

        stakedBalance[msg.sender][currentRoundNumber].balance = stakedBalance[
            msg.sender
        ][currentRoundNumber].balance.sub(_amount);

        stakedBalance[msg.sender][currentRoundNumber].time = block.timestamp;

        uint256 totalStakedAmount = 0;
        for (uint256 i = 1; i <= currentRoundNumber; i++) {
            totalStakedAmount = totalStakedAmount.add(
                stakedBalance[msg.sender][i].balance
            );
        }

        if (totalStakedAmount <= 0) {
            removeShareHolder(msg.sender);
        }

        IERC20(artikToken).transfer(msg.sender, _amount);
    }

    function addStakeHolder(
        address _stakeholder,
        uint256 _amount,
        uint256 _timestamp
    ) private {
        require(_amount > 0, "amount less than 0");
        require(_stakeholder != address(0x0));

        uint256 currentRoundNumber = projectsManagerV0.roundNumber();
        if (!stakedBalance[_stakeholder][currentRoundNumber].staked) {
            stakedBalance[_stakeholder][currentRoundNumber] = Stake(
                _amount,
                _timestamp,
                true
            );
        } else {
            stakedBalance[_stakeholder][currentRoundNumber]
                .balance = stakedBalance[_stakeholder][currentRoundNumber]
                .balance
                .add(_amount);
            stakedBalance[_stakeholder][currentRoundNumber].time = _timestamp;
        }

        addShareHolder(_stakeholder);
    }

    function stakeTokens(uint256 _amount) external {
        require(
            _amount <= IERC20(artikToken).balanceOf(msg.sender),
            "amount greater than balance"
        );
        addStakeHolder(msg.sender, _amount, block.timestamp);
        IERC20(artikToken).transferFrom(msg.sender, address(this), _amount);
    }

    function addShareHolder(address _shareholder) private {
        require(_shareholder != address(0x0));

        if (shareholderIndexes[_shareholder] <= 0) {
            shareholders.push(_shareholder);
            shareholderCount = shareholderCount.add(1);
            shareholderIndexes[_shareholder] = shareholderCount;
        }
    }

    function removeShareHolder(address _shareholder) private {
        require(_shareholder != address(0x0));

        if (shareholderIndexes[_shareholder] > 0) {
            shareholders[shareholderIndexes[_shareholder] - 1] = shareholders[
                shareholders.length - 1
            ];
            shareholders.pop();
            shareholderCount = shareholderCount.sub(1);
            shareholderIndexes[_shareholder] = 0;
        }
    }

    function getShareHolders() external view returns (address[] memory) {
        return shareholders;
    }

    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 z
    ) public pure returns (uint256) {
        return
            ABDKMathQuad.toUInt(
                ABDKMathQuad.div(
                    ABDKMathQuad.mul(
                        ABDKMathQuad.fromUInt(x),
                        ABDKMathQuad.fromUInt(y)
                    ),
                    ABDKMathQuad.fromUInt(z)
                )
            );
    }
}


// File: /contracts/StakeManagerV1.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "./libraries/ABDKMathQuad.sol";

import "./ArtikTreasury.sol";
import "./ArtikProjectManager.sol";
import "./ArtikProjectManagerV2.sol";
import "./ArtikTreasuryV2.sol";
import "./ArtikTreasuryV1.sol";
import "./ArtikProjectManagerV1.sol";

import "./TreasuryV1.sol";
import "./ProjectManagerV1.sol";

contract StakeManagerV1 is Initializable {
    using SafeMath for uint256;

    address private artikToken;
    address payable private admin;

    ArtikTreasury private treasury;
    ArtikProjectManager private artikProjectManager;

    mapping(address => mapping(uint256 => Stake)) private stakedBalance;
    struct Stake {
        uint256 balance;
        uint256 time;
        bool staked;
    }

    address[] public shareholders;
    mapping(address => uint256) private shareholderIndexes;
    uint256 private shareholderCount;

    bool public penaltyIsActive;
    ArtikProjectManagerV2 private artikProjectManagerV2;
    ArtikTreasuryV2 private artikTreasuryV2;
    ArtikTreasuryV1 private artikTreasuryV1;
    ArtikProjectManagerV1 private artikProjectManagerV1;

    TreasuryV1 private treasuryV1;
    ProjectManagerV1 private projectManagerV1;

    function initialize(
        address _tokenAddress,
        address _treasuryAddress,
        address _projectManagerAddr
    ) public initializer {
        artikToken = _tokenAddress;
        treasuryV1 = TreasuryV1(payable(_treasuryAddress));
        projectManagerV1 = ProjectManagerV1(_projectManagerAddr);

        shareholderCount = 0;
        admin = payable(msg.sender);

        penaltyIsActive = true;
    }

    function configureManagers(
        address _projectManagerAddr,
        address _treasuryAddr
    ) external {
        require(msg.sender == admin);
        projectManagerV1 = ProjectManagerV1(_projectManagerAddr);
        treasuryV1 = TreasuryV1(payable(_treasuryAddr));
    }

    function managePenalty(bool _active) external {
        require(msg.sender == admin);
        penaltyIsActive = _active;
    }

    function getStakedBalance(
        address _shareholder,
        uint256 _roundNumber
    ) external view returns (uint256) {
        require(_shareholder != address(0x0));
        require(_roundNumber > 0);
        return stakedBalance[_shareholder][_roundNumber].balance;
    }

    function calculateStakingPercentageTime(
        address _shareholder,
        uint256 _roundNumber
    ) external view returns (uint256) {
        require(_shareholder != address(0x0));
        require(_roundNumber > 0);

        uint256 diff = (treasuryV1.getAirdropDate(_roundNumber) -
            /*stakedBalance[_shareholder].time) /
            60 /
            60 /
            24;*/
            stakedBalance[_shareholder][_roundNumber].time);

        uint256 percentage = 1000000;
        if (penaltyIsActive && diff < 7 * 60 * 60 * 24) {
            percentage = mulDiv(diff, 1000000, 7 * 60 * 60 * 24);
        }
        return percentage;
    }

    function movePreviousStakes() external {
        require(shareholderIndexes[msg.sender] > 0, "not a stakeholder");

        uint256 currentRoundNumber = projectManagerV1.roundNumber();

        for (uint256 i = 1; i <= currentRoundNumber - 1; i++) {
            if (stakedBalance[msg.sender][i].balance > 0) {
                addStakeHolder(
                    msg.sender,
                    stakedBalance[msg.sender][i].balance,
                    stakedBalance[msg.sender][i].time
                );
                stakedBalance[msg.sender][i].balance = 0;
            }
        }
    }

    function unstakeTokens(uint256 _amount) external {
        require(_amount > 0);

        uint256 currentRoundNumber = projectManagerV1.roundNumber();
        require(
            _amount <= stakedBalance[msg.sender][currentRoundNumber].balance
        );
        require(stakedBalance[msg.sender][currentRoundNumber].balance > 0);

        stakedBalance[msg.sender][currentRoundNumber].balance = stakedBalance[
            msg.sender
        ][currentRoundNumber].balance.sub(_amount);

        stakedBalance[msg.sender][currentRoundNumber].time = block.timestamp;

        uint256 totalStakedAmount = 0;
        for (uint256 i = 1; i < currentRoundNumber; i++) {
            totalStakedAmount = totalStakedAmount.add(
                stakedBalance[msg.sender][i].balance
            );
        }

        if (totalStakedAmount <= 0) {
            removeShareHolder(msg.sender);
        }

        IERC20(artikToken).transfer(msg.sender, _amount);
    }

    function addStakeHolder(
        address _stakeholder,
        uint256 _amount,
        uint256 _timestamp
    ) private {
        require(_amount > 0, "amount less than 0");
        require(_stakeholder != address(0x0));

        uint256 currentRoundNumber = projectManagerV1.roundNumber();
        if (!stakedBalance[_stakeholder][currentRoundNumber].staked) {
            stakedBalance[_stakeholder][currentRoundNumber] = Stake(
                _amount,
                _timestamp,
                true
            );
        } else {
            stakedBalance[_stakeholder][currentRoundNumber]
                .balance = stakedBalance[_stakeholder][currentRoundNumber]
                .balance
                .add(_amount);
            stakedBalance[_stakeholder][currentRoundNumber].time = _timestamp;
        }

        addShareHolder(_stakeholder);
    }

    function stakeTokens(uint256 _amount) external {
        require(
            _amount <= IERC20(artikToken).balanceOf(msg.sender),
            "amount greater than balance"
        );
        addStakeHolder(msg.sender, _amount, block.timestamp);
        IERC20(artikToken).transferFrom(msg.sender, address(this), _amount);
    }

    function addShareHolder(address _shareholder) private {
        require(_shareholder != address(0x0));

        if (shareholderIndexes[_shareholder] <= 0) {
            shareholders.push(_shareholder);
            shareholderCount = shareholderCount.add(1);
            shareholderIndexes[_shareholder] = shareholderCount;
        }
    }

    function removeShareHolder(address _shareholder) private {
        require(_shareholder != address(0x0));

        if (shareholderIndexes[_shareholder] > 0) {
            shareholders[shareholderIndexes[_shareholder] - 1] = shareholders[
                shareholders.length - 1
            ];
            shareholders.pop();
            shareholderCount = shareholderCount.sub(1);
            shareholderIndexes[_shareholder] = 0;
        }
    }

    function getShareHolders() external view returns (address[] memory) {
        return shareholders;
    }

    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 z
    ) public pure returns (uint256) {
        return
            ABDKMathQuad.toUInt(
                ABDKMathQuad.div(
                    ABDKMathQuad.mul(
                        ABDKMathQuad.fromUInt(x),
                        ABDKMathQuad.fromUInt(y)
                    ),
                    ABDKMathQuad.fromUInt(z)
                )
            );
    }
}


// File: /contracts/StakeManagerV0.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "./libraries/ABDKMathQuad.sol";

import "./ArtikTreasury.sol";
import "./ArtikProjectManager.sol";
import "./ArtikProjectManagerV2.sol";
import "./ArtikTreasuryV2.sol";
import "./ArtikTreasuryV1.sol";
import "./ArtikProjectManagerV1.sol";

import "./TreasuryV1.sol";
import "./ProjectManagerV1.sol";
import "./TreasuryV0.sol";
import "./ProjectManagerV0.sol";

contract StakeManagerV0 is Initializable {
    using SafeMath for uint256;

    address private artikToken;
    address payable private admin;

    ArtikTreasury private treasury;
    ArtikProjectManager private artikProjectManager;

    mapping(address => mapping(uint256 => Stake)) private stakedBalance;
    struct Stake {
        uint256 balance;
        uint256 time;
        bool staked;
    }

    address[] public shareholders;
    mapping(address => uint256) private shareholderIndexes;
    uint256 private shareholderCount;

    bool public penaltyIsActive;
    ArtikProjectManagerV2 private artikProjectManagerV2;
    ArtikTreasuryV2 private artikTreasuryV2;
    ArtikTreasuryV1 private artikTreasuryV1;
    ArtikProjectManagerV1 private artikProjectManagerV1;

    TreasuryV1 private treasuryV1;
    ProjectManagerV1 private projectManagerV1;
    TreasuryV0 private treasuryV0;
    ProjectManagerV0 private projectManagerV0;

    function initialize(
        address _tokenAddress,
        address _treasuryAddress,
        address _projectManagerAddr
    ) public initializer {
        artikToken = _tokenAddress;
        treasuryV0 = TreasuryV0(payable(_treasuryAddress));
        projectManagerV0 = ProjectManagerV0(_projectManagerAddr);

        shareholderCount = 0;
        admin = payable(msg.sender);

        penaltyIsActive = true;
    }

    function configureManagers(
        address _projectManagerAddr,
        address _treasuryAddr
    ) external {
        require(msg.sender == admin);
        projectManagerV0 = ProjectManagerV0(_projectManagerAddr);
        treasuryV0 = TreasuryV0(payable(_treasuryAddr));
    }

    function managePenalty(bool _active) external {
        require(msg.sender == admin);
        penaltyIsActive = _active;
    }

    function getStakedBalance(
        address _shareholder,
        uint256 _roundNumber
    ) external view returns (uint256) {
        require(_shareholder != address(0x0));
        require(_roundNumber > 0);
        return stakedBalance[_shareholder][_roundNumber].balance;
    }

    function calculateStakingPercentageTime(
        address _shareholder,
        uint256 _roundNumber
    ) external view returns (uint256) {
        require(_shareholder != address(0x0));
        require(_roundNumber > 0);

        uint256 diff = (treasuryV0.getAirdropDate(_roundNumber) -
            /*stakedBalance[_shareholder].time) /
            60 /
            60 /
            24;*/
            stakedBalance[_shareholder][_roundNumber].time);

        uint256 percentage = 1000000;
        if (penaltyIsActive && diff < 7 * 60 * 60 * 24) {
            percentage = mulDiv(diff, 1000000, 7 * 60 * 60 * 24);
        }
        return percentage;
    }

    function movePreviousStakes() external {
        require(shareholderIndexes[msg.sender] > 0, "not a stakeholder");

        uint256 currentRoundNumber = projectManagerV0.roundNumber();

        for (uint256 i = 1; i <= currentRoundNumber - 1; i++) {
            if (stakedBalance[msg.sender][i].balance > 0) {
                addStakeHolder(
                    msg.sender,
                    stakedBalance[msg.sender][i].balance,
                    stakedBalance[msg.sender][i].time
                );
                stakedBalance[msg.sender][i].balance = 0;
            }
        }
    }

    function unstakeTokens(uint256 _amount) external {
        require(_amount > 0);

        uint256 currentRoundNumber = projectManagerV0.roundNumber();
        require(
            _amount <= stakedBalance[msg.sender][currentRoundNumber].balance
        );
        require(stakedBalance[msg.sender][currentRoundNumber].balance > 0);

        stakedBalance[msg.sender][currentRoundNumber].balance = stakedBalance[
            msg.sender
        ][currentRoundNumber].balance.sub(_amount);

        stakedBalance[msg.sender][currentRoundNumber].time = block.timestamp;

        uint256 totalStakedAmount = 0;
        for (uint256 i = 1; i < currentRoundNumber; i++) {
            totalStakedAmount = totalStakedAmount.add(
                stakedBalance[msg.sender][i].balance
            );
        }

        if (totalStakedAmount <= 0) {
            removeShareHolder(msg.sender);
        }

        IERC20(artikToken).transfer(msg.sender, _amount);
    }

    function addStakeHolder(
        address _stakeholder,
        uint256 _amount,
        uint256 _timestamp
    ) private {
        require(_amount > 0, "amount less than 0");
        require(_stakeholder != address(0x0));

        uint256 currentRoundNumber = projectManagerV0.roundNumber();
        if (!stakedBalance[_stakeholder][currentRoundNumber].staked) {
            stakedBalance[_stakeholder][currentRoundNumber] = Stake(
                _amount,
                _timestamp,
                true
            );
        } else {
            stakedBalance[_stakeholder][currentRoundNumber]
                .balance = stakedBalance[_stakeholder][currentRoundNumber]
                .balance
                .add(_amount);
            stakedBalance[_stakeholder][currentRoundNumber].time = _timestamp;
        }

        addShareHolder(_stakeholder);
    }

    function stakeTokens(uint256 _amount) external {
        require(
            _amount <= IERC20(artikToken).balanceOf(msg.sender),
            "amount greater than balance"
        );
        addStakeHolder(msg.sender, _amount, block.timestamp);
        IERC20(artikToken).transferFrom(msg.sender, address(this), _amount);
    }

    function addShareHolder(address _shareholder) private {
        require(_shareholder != address(0x0));

        if (shareholderIndexes[_shareholder] <= 0) {
            shareholders.push(_shareholder);
            shareholderCount = shareholderCount.add(1);
            shareholderIndexes[_shareholder] = shareholderCount;
        }
    }

    function removeShareHolder(address _shareholder) private {
        require(_shareholder != address(0x0));

        if (shareholderIndexes[_shareholder] > 0) {
            shareholders[shareholderIndexes[_shareholder] - 1] = shareholders[
                shareholders.length - 1
            ];
            shareholders.pop();
            shareholderCount = shareholderCount.sub(1);
            shareholderIndexes[_shareholder] = 0;
        }
    }

    function getShareHolders() external view returns (address[] memory) {
        return shareholders;
    }

    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 z
    ) public pure returns (uint256) {
        return
            ABDKMathQuad.toUInt(
                ABDKMathQuad.div(
                    ABDKMathQuad.mul(
                        ABDKMathQuad.fromUInt(x),
                        ABDKMathQuad.fromUInt(y)
                    ),
                    ABDKMathQuad.fromUInt(z)
                )
            );
    }
}


// File: /contracts/ProjectsManagerV0.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "./interfaces/DexRouter.sol";

import "./libraries/ABDKMathQuad.sol";

import "./ArtikTreasury.sol";
import "./ArtikStakeManager.sol";
import "./DistributorV2.sol";
import "./ArtikTreasuryV2.sol";
import "./ArtikStakeManagerV2.sol";
import "./ArtikStakeManagerV1.sol";
import "./ArtikTreasuryV1.sol";

import "./StakeManagerV1.sol";
import "./TreasuryV1.sol";
import "./StakeManagerV0.sol";
import "./TreasuryV0.sol";

import "./StakesManagerV0.sol";
import "./TreasuryManagerV0.sol";

contract ProjectsManagerV0 is Initializable {
    using SafeMath for uint256;

    // Pancakeswap 0x10ED43C718714eb63d5aA57B78B54704E256024E (testnet: 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3)
    address constant ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
    // WBNB 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c (testnet: 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd)
    address constant WETH = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
    // BUSD 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56 (testnet: 0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7)
    address constant STABLE_COIN = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;

    uint256 private constant TEAM_FEE = 30;

    DexRouter private dexRouter;

    address private artikToken;
    address payable private admin;

    uint256 public roundNumber;
    mapping(address => mapping(uint256 => uint256)) private voters;
    mapping(address => bool) private isVoter;
    mapping(uint256 => ProjectVotes) private projectVotes;

    Project public bestProject;

    uint256 public projectCount;
    uint256 public votesCount;
    mapping(uint256 => Project) public projects;
    mapping(uint256 => ProjectVotes[]) private projectsLeaderboard;

    DistributorV2 private distributor;
    address payable public distributorAddress;

    uint256 public priceToVote;
    uint256 public minBalanceToVote;

    struct ProjectVotes {
        uint256 id;
        uint256 votes;
    }

    struct Project {
        uint256 id;
        string img;
        string name;
        string description;
        string category;
        string url;
        string twitter;
        address tokenAddress;
        string tokenSymbol;
        uint256 tokenDecimals;
        bool active;
        bool pitchWinner;
    }

    ArtikTreasury private treasury;
    ArtikStakeManager private artikStakeManager;
    ArtikTreasuryV2 private artikTreasuryV2;
    ArtikStakeManagerV2 private artikStakeManagerV2;
    ArtikStakeManagerV1 private artikStakeManagerV1;
    ArtikTreasuryV1 private artikTreasuryV1;

    StakeManagerV1 private stakeManagerV1;
    TreasuryV1 private treasuryV1;
    StakeManagerV0 private stakeManagerV0;
    TreasuryV0 private treasuryV0;

    StakesManagerV0 private stakesManagerV0;
    TreasuryManagerV0 private treasuryManagerV0;

    modifier onlyAdmin() {
        require(msg.sender == admin || msg.sender == distributorAddress);
        _;
    }

    function initialize(
        address _tokenAddress,
        address _distributorAddress
    ) public initializer {
        dexRouter = DexRouter(ROUTER);
        artikToken = _tokenAddress;
        treasuryManagerV0 = TreasuryManagerV0(payable(_distributorAddress));
        distributorAddress = payable(_distributorAddress);
        admin = payable(msg.sender);
        roundNumber = 1;
        projectCount = 0;
        votesCount = 0;
    }

    function configureManagers(
        address _stakeManagerAddr,
        address _treasuryAddr
    ) external onlyAdmin {
        require(_stakeManagerAddr != address(0x0));
        require(_treasuryAddr != address(0x0));
        stakesManagerV0 = StakesManagerV0(_stakeManagerAddr);
        treasuryManagerV0 = TreasuryManagerV0(payable(_treasuryAddr));
    }

    function configureMinBalanceToVote(uint256 _balance) external onlyAdmin {
        require(_balance >= 0, "balance is less than 0");
        (uint256 balanceInEth, ) = getAmountOutMin(_balance, STABLE_COIN, WETH);
        (minBalanceToVote, ) = getAmountOutMin(balanceInEth, WETH, artikToken);
    }

    function uploadProject(
        string memory _img,
        string memory _name,
        string memory _description,
        string memory _category,
        string memory _url,
        string memory _twitter,
        bytes20 _tokenAddress,
        string memory _tokenSymbol,
        uint256 _tokenDecimals
    ) external onlyAdmin {
        require(msg.sender != address(0));
        require(bytes(_img).length > 0);
        require(bytes(_name).length > 0);
        require(bytes(_description).length > 0);
        require(bytes(_category).length > 0);
        require(bytes(_url).length > 0);
        require(address(_tokenAddress) != address(0x0));
        require(bytes(_tokenSymbol).length > 0);
        require(_tokenDecimals > 0);

        projectCount = projectCount.add(1);
        projects[projectCount] = Project(
            projectCount,
            _img,
            _name,
            _description,
            _category,
            _url,
            _twitter,
            address(_tokenAddress),
            _tokenSymbol,
            _tokenDecimals,
            true,
            false
        );

        projectVotes[projectCount] = ProjectVotes(projectCount, 0);
    }

    function changeProjectDescription(
        uint256 _projectId,
        string memory _description
    ) external onlyAdmin {
        require(_projectId > 0);
        require(bytes(_description).length > 0);
        projects[_projectId].description = _description;
    }

    function getLeaderBoard() external view returns (ProjectVotes[] memory) {
        return projectsLeaderboard[roundNumber - 1];
    }

    function saveProjectToLeaderboard(uint256 _projectId) external onlyAdmin {
        require(_projectId > 0);
        projectsLeaderboard[roundNumber - 1].push(
            ProjectVotes(_projectId, projectVotes[_projectId].votes)
        );
    }

    function managePitchWinner(
        uint256 _projectId,
        bool _isWinner
    ) external onlyAdmin {
        require(_projectId > 0);
        require(_isWinner == true || _isWinner == false);
        projects[_projectId].pitchWinner = _isWinner;
    }

    function changeProjectState(
        uint256 _projectId,
        bool _active
    ) external onlyAdmin {
        require(_projectId > 0);
        require(_active == true || _active == false);
        projects[_projectId].active = _active;
    }

    function voteProject(uint256 _projectId) external {
        require(
            voters[msg.sender][_projectId] != roundNumber,
            "voters can vote the same project only 1 time"
        );
        require(_projectId != 0, "projectId canno be 0");

        if (minBalanceToVote > 0) {
            require(
                stakesManagerV0.getStakedBalance(msg.sender, roundNumber) >=
                    minBalanceToVote,
                "not enough balance to vote"
            );
        }

        projectVotes[_projectId].votes = projectVotes[_projectId].votes.add(1);
        voters[msg.sender][_projectId] = roundNumber;
        isVoter[msg.sender] = true;
        votesCount = votesCount.add(1);
    }

    function setVoter(address _shareholder, bool _isVoter) external onlyAdmin {
        require(_shareholder != address(0x0));
        require(_isVoter == true || _isVoter == false);
        isVoter[_shareholder] = _isVoter;
    }

    function isShareholderVoter(
        address _shareholder
    ) external view returns (bool) {
        require(_shareholder != address(0x0));
        return isVoter[_shareholder];
    }

    function resetProjectVotes(uint256 _projectId) external onlyAdmin {
        require(_projectId > 0);
        projectVotes[_projectId].votes = 0;
    }

    function setBestProject(uint256 _projectId) external onlyAdmin {
        require(_projectId > 0);
        bestProject = projects[_projectId];
    }

    function getProjectVotes(
        uint256 _projectId
    ) external view onlyAdmin returns (ProjectVotes memory) {
        require(_projectId > 0);
        return projectVotes[_projectId];
    }

    function getBestProject() external view returns (Project memory) {
        return bestProject;
    }

    function getAmountOutMin(
        uint256 _amount,
        address _tokenIn,
        address _tokenOut
    ) private view returns (uint256, address[] memory) {
        address[] memory path = new address[](2);
        path[0] = _tokenIn;
        path[1] = _tokenOut;

        uint256[] memory amountOutMins = dexRouter.getAmountsOut(_amount, path);
        return (amountOutMins[1], path);
    }

    function setRound(uint256 _round) public onlyAdmin {
        require(_round > 0);
        roundNumber = _round;
    }

    function nextRound() public onlyAdmin {
        roundNumber = roundNumber.add(1);
    }

    function hasVotedProject(uint256 _projectId) external view returns (bool) {
        if (voters[msg.sender][_projectId] == roundNumber) {
            return true;
        } else {
            return false;
        }
    }

    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 z
    ) public pure returns (uint256) {
        return
            ABDKMathQuad.toUInt(
                ABDKMathQuad.div(
                    ABDKMathQuad.mul(
                        ABDKMathQuad.fromUInt(x),
                        ABDKMathQuad.fromUInt(y)
                    ),
                    ABDKMathQuad.fromUInt(z)
                )
            );
    }
}


// File: /contracts/ProjectManagerV1.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "./interfaces/DexRouter.sol";

import "./libraries/ABDKMathQuad.sol";

import "./ArtikTreasury.sol";
import "./ArtikStakeManager.sol";
import "./DistributorV2.sol";
import "./ArtikTreasuryV2.sol";
import "./ArtikStakeManagerV2.sol";
import "./ArtikStakeManagerV1.sol";
import "./ArtikTreasuryV1.sol";

import "./StakeManagerV1.sol";
import "./TreasuryV1.sol";

contract ProjectManagerV1 is Initializable {
    using SafeMath for uint256;

    // Pancakeswap 0x10ED43C718714eb63d5aA57B78B54704E256024E (testnet: 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3)
    address constant ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
    // WBNB 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c (testnet: 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd)
    address constant WETH = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
    // BUSD 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56 (testnet: 0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7)
    address constant STABLE_COIN = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;

    uint256 private constant TEAM_FEE = 30;

    DexRouter private dexRouter;

    address private artikToken;
    address payable private admin;

    uint256 public roundNumber;
    mapping(address => mapping(uint256 => uint256)) private voters;
    mapping(address => bool) private isVoter;
    mapping(uint256 => ProjectVotes) private projectVotes;

    Project public bestProject;

    uint256 public projectCount;
    uint256 public votesCount;
    mapping(uint256 => Project) public projects;
    mapping(uint256 => ProjectVotes[]) private projectsLeaderboard;

    DistributorV2 private distributor;
    address payable public distributorAddress;

    uint256 public priceToVote;
    uint256 public minBalanceToVote;

    struct ProjectVotes {
        uint256 id;
        uint256 votes;
    }

    struct Project {
        uint256 id;
        string img;
        string name;
        string description;
        string category;
        string url;
        string twitter;
        address tokenAddress;
        string tokenSymbol;
        uint256 tokenDecimals;
        bool active;
        bool pitchWinner;
    }

    ArtikTreasury private treasury;
    ArtikStakeManager private artikStakeManager;
    ArtikTreasuryV2 private artikTreasuryV2;
    ArtikStakeManagerV2 private artikStakeManagerV2;
    ArtikStakeManagerV1 private artikStakeManagerV1;
    ArtikTreasuryV1 private artikTreasuryV1;

    StakeManagerV1 private stakeManagerV1;
    TreasuryV1 private treasuryV1;

    modifier onlyAdmin() {
        require(msg.sender == admin || msg.sender == distributorAddress);
        _;
    }

    function initialize(
        address _tokenAddress,
        address _distributorAddress
    ) public initializer {
        dexRouter = DexRouter(ROUTER);
        artikToken = _tokenAddress;
        treasuryV1 = TreasuryV1(payable(_distributorAddress));
        distributorAddress = payable(_distributorAddress);
        admin = payable(msg.sender);
        roundNumber = 1;
        projectCount = 0;
        votesCount = 0;
    }

    function configureManagers(
        address _stakeManagerAddr,
        address _treasuryAddr
    ) external onlyAdmin {
        require(_stakeManagerAddr != address(0x0));
        require(_treasuryAddr != address(0x0));
        stakeManagerV1 = StakeManagerV1(_stakeManagerAddr);
        treasuryV1 = TreasuryV1(payable(_treasuryAddr));
    }

    function configurePriceToVote(uint256 _price) external onlyAdmin {
        require(_price >= 0, "price is less than 0");
        priceToVote = _price;
    }

    function configureMinBalanceToVote(uint256 _balance) external onlyAdmin {
        require(_balance >= 0, "balance is less than 0");
        (uint256 balanceInEth, ) = getAmountOutMin(_balance, STABLE_COIN, WETH);
        (minBalanceToVote, ) = getAmountOutMin(balanceInEth, WETH, artikToken);
    }

    function uploadProject(
        string memory _img,
        string memory _name,
        string memory _description,
        string memory _category,
        string memory _url,
        string memory _twitter,
        bytes20 _tokenAddress,
        string memory _tokenSymbol,
        uint256 _tokenDecimals
    ) external onlyAdmin {
        require(msg.sender != address(0));
        require(bytes(_img).length > 0);
        require(bytes(_name).length > 0);
        require(bytes(_description).length > 0);
        require(bytes(_category).length > 0);
        require(bytes(_url).length > 0);
        require(address(_tokenAddress) != address(0x0));
        require(bytes(_tokenSymbol).length > 0);
        require(_tokenDecimals > 0);

        projectCount = projectCount.add(1);
        projects[projectCount] = Project(
            projectCount,
            _img,
            _name,
            _description,
            _category,
            _url,
            _twitter,
            address(_tokenAddress),
            _tokenSymbol,
            _tokenDecimals,
            true,
            false
        );

        projectVotes[projectCount] = ProjectVotes(projectCount, 0);
    }

    function changeProjectDescription(
        uint256 _projectId,
        string memory _description
    ) external onlyAdmin {
        require(_projectId > 0);
        require(bytes(_description).length > 0);
        projects[_projectId].description = _description;
    }

    function getLeaderBoard() external view returns (ProjectVotes[] memory) {
        return projectsLeaderboard[roundNumber - 1];
    }

    function saveProjectToLeaderboard(uint256 _projectId) external onlyAdmin {
        require(_projectId > 0);
        projectsLeaderboard[roundNumber - 1].push(
            ProjectVotes(_projectId, projectVotes[_projectId].votes)
        );
    }

    function managePitchWinner(
        uint256 _projectId,
        bool _isWinner
    ) external onlyAdmin {
        require(_projectId > 0);
        require(_isWinner == true || _isWinner == false);
        projects[_projectId].pitchWinner = _isWinner;
    }

    function changeProjectState(
        uint256 _projectId,
        bool _active
    ) external onlyAdmin {
        require(_projectId > 0);
        require(_active == true || _active == false);
        projects[_projectId].active = _active;
    }

    function voteProject(uint256 _projectId) external payable {
        require(
            voters[msg.sender][_projectId] != roundNumber,
            "voters can vote the same project only 1 time"
        );

        require(_projectId != 0, "projectId canno be 0");
        require(msg.value >= 0, "value less than 0");

        (uint256 priceInBusd, ) = getAmountOutMin(msg.value, WETH, STABLE_COIN);

        if (priceToVote > 0) {
            require(priceInBusd >= priceToVote, "voting has a cost!");
            uint256 amount = msg.value.div(2);

            (bool sentToTeam, ) = admin.call{value: amount}("");
            (bool sentToDistributor, ) = distributorAddress.call{
                value: address(this).balance
            }("");
            require(sentToTeam, "Failed to send to team");
            require(sentToDistributor, "Failed to send to distributor");

            treasuryV1.swapTokens();
        }

        if (minBalanceToVote > 0) {
            require(
                stakeManagerV1.getStakedBalance(msg.sender, roundNumber) >=
                    minBalanceToVote,
                "not enough balance to vote"
            );
        }

        projectVotes[_projectId].votes = projectVotes[_projectId].votes.add(1);
        voters[msg.sender][_projectId] = roundNumber;
        isVoter[msg.sender] = true;
        votesCount = votesCount.add(1);
    }

    function setVoter(address _shareholder, bool _isVoter) external onlyAdmin {
        require(_shareholder != address(0x0));
        require(_isVoter == true || _isVoter == false);
        isVoter[_shareholder] = _isVoter;
    }

    function isShareholderVoter(
        address _shareholder
    ) external view returns (bool) {
        require(_shareholder != address(0x0));
        return isVoter[_shareholder];
    }

    function resetProjectVotes(uint256 _projectId) external onlyAdmin {
        require(_projectId > 0);
        projectVotes[_projectId].votes = 0;
    }

    function setBestProject(uint256 _projectId) external onlyAdmin {
        require(_projectId > 0);
        bestProject = projects[_projectId];
    }

    function getProjectVotes(
        uint256 _projectId
    ) external view onlyAdmin returns (ProjectVotes memory) {
        require(_projectId > 0);
        return projectVotes[_projectId];
    }

    function getBestProject() external view returns (Project memory) {
        return bestProject;
    }

    function getAmountOutMin(
        uint256 _amount,
        address _tokenIn,
        address _tokenOut
    ) private view returns (uint256, address[] memory) {
        address[] memory path = new address[](2);
        path[0] = _tokenIn;
        path[1] = _tokenOut;

        uint256[] memory amountOutMins = dexRouter.getAmountsOut(_amount, path);
        return (amountOutMins[1], path);
    }

    function setRound(uint256 _round) public onlyAdmin {
        require(_round > 0);
        roundNumber = _round;
    }

    function nextRound() public onlyAdmin {
        roundNumber = roundNumber.add(1);
    }

    function hasVotedProject(uint256 _projectId) external view returns (bool) {
        if (voters[msg.sender][_projectId] == roundNumber) {
            return true;
        } else {
            return false;
        }
    }

    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 z
    ) public pure returns (uint256) {
        return
            ABDKMathQuad.toUInt(
                ABDKMathQuad.div(
                    ABDKMathQuad.mul(
                        ABDKMathQuad.fromUInt(x),
                        ABDKMathQuad.fromUInt(y)
                    ),
                    ABDKMathQuad.fromUInt(z)
                )
            );
    }
}


// File: /contracts/ProjectManagerV0.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "./interfaces/DexRouter.sol";

import "./libraries/ABDKMathQuad.sol";

import "./ArtikTreasury.sol";
import "./ArtikStakeManager.sol";
import "./DistributorV2.sol";
import "./ArtikTreasuryV2.sol";
import "./ArtikStakeManagerV2.sol";
import "./ArtikStakeManagerV1.sol";
import "./ArtikTreasuryV1.sol";

import "./StakeManagerV1.sol";
import "./TreasuryV1.sol";
import "./StakeManagerV0.sol";
import "./TreasuryV0.sol";

contract ProjectManagerV0 is Initializable {
    using SafeMath for uint256;

    // Pancakeswap 0x10ED43C718714eb63d5aA57B78B54704E256024E (testnet: 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3)
    address constant ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
    // WBNB 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c (testnet: 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd)
    address constant WETH = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
    // BUSD 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56 (testnet: 0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7)
    address constant STABLE_COIN = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;

    uint256 private constant TEAM_FEE = 30;

    DexRouter private dexRouter;

    address private artikToken;
    address payable private admin;

    uint256 public roundNumber;
    mapping(address => mapping(uint256 => uint256)) private voters;
    mapping(address => bool) private isVoter;
    mapping(uint256 => ProjectVotes) private projectVotes;

    Project public bestProject;

    uint256 public projectCount;
    uint256 public votesCount;
    mapping(uint256 => Project) public projects;
    mapping(uint256 => ProjectVotes[]) private projectsLeaderboard;

    DistributorV2 private distributor;
    address payable public distributorAddress;

    uint256 public priceToVote;
    uint256 public minBalanceToVote;

    struct ProjectVotes {
        uint256 id;
        uint256 votes;
    }

    struct Project {
        uint256 id;
        string img;
        string name;
        string description;
        string category;
        string url;
        string twitter;
        address tokenAddress;
        string tokenSymbol;
        uint256 tokenDecimals;
        bool active;
        bool pitchWinner;
    }

    ArtikTreasury private treasury;
    ArtikStakeManager private artikStakeManager;
    ArtikTreasuryV2 private artikTreasuryV2;
    ArtikStakeManagerV2 private artikStakeManagerV2;
    ArtikStakeManagerV1 private artikStakeManagerV1;
    ArtikTreasuryV1 private artikTreasuryV1;

    StakeManagerV1 private stakeManagerV1;
    TreasuryV1 private treasuryV1;
    StakeManagerV0 private stakeManagerV0;
    TreasuryV0 private treasuryV0;

    modifier onlyAdmin() {
        require(msg.sender == admin || msg.sender == distributorAddress);
        _;
    }

    function initialize(
        address _tokenAddress,
        address _distributorAddress
    ) public initializer {
        dexRouter = DexRouter(ROUTER);
        artikToken = _tokenAddress;
        treasuryV0 = TreasuryV0(payable(_distributorAddress));
        distributorAddress = payable(_distributorAddress);
        admin = payable(msg.sender);
        roundNumber = 1;
        projectCount = 0;
        votesCount = 0;
    }

    function configureManagers(
        address _stakeManagerAddr,
        address _treasuryAddr
    ) external onlyAdmin {
        require(_stakeManagerAddr != address(0x0));
        require(_treasuryAddr != address(0x0));
        stakeManagerV0 = StakeManagerV0(_stakeManagerAddr);
        treasuryV0 = TreasuryV0(payable(_treasuryAddr));
    }

    function configurePriceToVote(uint256 _price) external onlyAdmin {
        require(_price >= 0, "price is less than 0");
        priceToVote = _price;
    }

    function configureMinBalanceToVote(uint256 _balance) external onlyAdmin {
        require(_balance >= 0, "balance is less than 0");
        (uint256 balanceInEth, ) = getAmountOutMin(_balance, STABLE_COIN, WETH);
        (minBalanceToVote, ) = getAmountOutMin(balanceInEth, WETH, artikToken);
    }

    function uploadProject(
        string memory _img,
        string memory _name,
        string memory _description,
        string memory _category,
        string memory _url,
        string memory _twitter,
        bytes20 _tokenAddress,
        string memory _tokenSymbol,
        uint256 _tokenDecimals
    ) external onlyAdmin {
        require(msg.sender != address(0));
        require(bytes(_img).length > 0);
        require(bytes(_name).length > 0);
        require(bytes(_description).length > 0);
        require(bytes(_category).length > 0);
        require(bytes(_url).length > 0);
        require(address(_tokenAddress) != address(0x0));
        require(bytes(_tokenSymbol).length > 0);
        require(_tokenDecimals > 0);

        projectCount = projectCount.add(1);
        projects[projectCount] = Project(
            projectCount,
            _img,
            _name,
            _description,
            _category,
            _url,
            _twitter,
            address(_tokenAddress),
            _tokenSymbol,
            _tokenDecimals,
            true,
            false
        );

        projectVotes[projectCount] = ProjectVotes(projectCount, 0);
    }

    function changeProjectDescription(
        uint256 _projectId,
        string memory _description
    ) external onlyAdmin {
        require(_projectId > 0);
        require(bytes(_description).length > 0);
        projects[_projectId].description = _description;
    }

    function getLeaderBoard() external view returns (ProjectVotes[] memory) {
        return projectsLeaderboard[roundNumber - 1];
    }

    function saveProjectToLeaderboard(uint256 _projectId) external onlyAdmin {
        require(_projectId > 0);
        projectsLeaderboard[roundNumber - 1].push(
            ProjectVotes(_projectId, projectVotes[_projectId].votes)
        );
    }

    function managePitchWinner(
        uint256 _projectId,
        bool _isWinner
    ) external onlyAdmin {
        require(_projectId > 0);
        require(_isWinner == true || _isWinner == false);
        projects[_projectId].pitchWinner = _isWinner;
    }

    function changeProjectState(
        uint256 _projectId,
        bool _active
    ) external onlyAdmin {
        require(_projectId > 0);
        require(_active == true || _active == false);
        projects[_projectId].active = _active;
    }

    function voteProject(uint256 _projectId) external payable {
        require(
            voters[msg.sender][_projectId] != roundNumber,
            "voters can vote the same project only 1 time"
        );

        require(_projectId != 0, "projectId canno be 0");
        require(msg.value >= 0, "value less than 0");

        (uint256 priceInBusd, ) = getAmountOutMin(msg.value, WETH, STABLE_COIN);

        if (priceToVote > 0) {
            require(priceInBusd >= priceToVote, "voting has a cost!");
            uint256 amount = msg.value.div(2);

            (bool sentToTeam, ) = admin.call{value: amount}("");
            (bool sentToDistributor, ) = distributorAddress.call{
                value: address(this).balance
            }("");
            require(sentToTeam, "Failed to send to team");
            require(sentToDistributor, "Failed to send to distributor");

            treasuryV0.swapTokens();
        }

        if (minBalanceToVote > 0) {
            require(
                stakeManagerV0.getStakedBalance(msg.sender, roundNumber) >=
                    minBalanceToVote,
                "not enough balance to vote"
            );
        }

        projectVotes[_projectId].votes = projectVotes[_projectId].votes.add(1);
        voters[msg.sender][_projectId] = roundNumber;
        isVoter[msg.sender] = true;
        votesCount = votesCount.add(1);
    }

    function setVoter(address _shareholder, bool _isVoter) external onlyAdmin {
        require(_shareholder != address(0x0));
        require(_isVoter == true || _isVoter == false);
        isVoter[_shareholder] = _isVoter;
    }

    function isShareholderVoter(
        address _shareholder
    ) external view returns (bool) {
        require(_shareholder != address(0x0));
        return isVoter[_shareholder];
    }

    function resetProjectVotes(uint256 _projectId) external onlyAdmin {
        require(_projectId > 0);
        projectVotes[_projectId].votes = 0;
    }

    function setBestProject(uint256 _projectId) external onlyAdmin {
        require(_projectId > 0);
        bestProject = projects[_projectId];
    }

    function getProjectVotes(
        uint256 _projectId
    ) external view onlyAdmin returns (ProjectVotes memory) {
        require(_projectId > 0);
        return projectVotes[_projectId];
    }

    function getBestProject() external view returns (Project memory) {
        return bestProject;
    }

    function getAmountOutMin(
        uint256 _amount,
        address _tokenIn,
        address _tokenOut
    ) private view returns (uint256, address[] memory) {
        address[] memory path = new address[](2);
        path[0] = _tokenIn;
        path[1] = _tokenOut;

        uint256[] memory amountOutMins = dexRouter.getAmountsOut(_amount, path);
        return (amountOutMins[1], path);
    }

    function setRound(uint256 _round) public onlyAdmin {
        require(_round > 0);
        roundNumber = _round;
    }

    function nextRound() public onlyAdmin {
        roundNumber = roundNumber.add(1);
    }

    function hasVotedProject(uint256 _projectId) external view returns (bool) {
        if (voters[msg.sender][_projectId] == roundNumber) {
            return true;
        } else {
            return false;
        }
    }

    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 z
    ) public pure returns (uint256) {
        return
            ABDKMathQuad.toUInt(
                ABDKMathQuad.div(
                    ABDKMathQuad.mul(
                        ABDKMathQuad.fromUInt(x),
                        ABDKMathQuad.fromUInt(y)
                    ),
                    ABDKMathQuad.fromUInt(z)
                )
            );
    }
}


// File: /contracts/ProjectManager.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "./interfaces/DexRouter.sol";

import "./DistributorV2.sol";
import "./libraries/ABDKMathQuad.sol";

contract ProjectManager is Initializable {
    using SafeMath for uint256;

    // Pancakeswap 0x10ED43C718714eb63d5aA57B78B54704E256024E (testnet: 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3)
    address constant ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
    // WBNB 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c (testnet: 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd)
    address constant WETH = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
    // BUSD 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56 (testnet: 0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7)
    address constant STABLE_COIN = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;

    uint256 private constant TEAM_FEE = 30;

    DexRouter private dexRouter;

    address private artikToken;
    address payable private admin;

    uint256 public roundNumber;
    mapping(address => mapping(uint256 => uint256)) private voters;
    mapping(address => bool) private isVoter;
    mapping(uint256 => ProjectVotes) private projectVotes;

    Project public bestProject;

    uint256 public projectCount;
    uint256 public votesCount;
    mapping(uint256 => Project) public projects;
    mapping(uint256 => ProjectVotes[]) private projectsLeaderboard;

    DistributorV2 private distributor;
    address payable public distributorAddress;

    uint256 public priceToVote;
    uint256 public minBalanceToVote;

    struct ProjectVotes {
        uint256 id;
        uint256 votes;
    }

    struct Project {
        uint256 id;
        string img;
        string name;
        string description;
        string category;
        string url;
        string twitter;
        address tokenAddress;
        string tokenSymbol;
        uint256 tokenDecimals;
        bool active;
        bool pitchWinner;
    }

    modifier onlyAdmin() {
        require(msg.sender == admin || msg.sender == distributorAddress);
        _;
    }

    function initialize(
        address _tokenAddress,
        address _distributorAddress
    ) public initializer {
        dexRouter = DexRouter(ROUTER);
        artikToken = _tokenAddress;
        distributor = DistributorV2(payable(_distributorAddress));
        distributorAddress = payable(_distributorAddress);
        admin = payable(msg.sender);
        roundNumber = 1;
        projectCount = 0;
        votesCount = 0;
    }

    function configurePriceToVote(uint256 _price) external onlyAdmin {
        require(_price >= 0, "price is less than 0");
        priceToVote = _price;
    }

    function configureMinBalanceToVote(uint256 _balance) external onlyAdmin {
        require(_balance >= 0, "balance is less than 0");
        (uint256 balanceInEth, ) = getAmountOutMin(_balance, STABLE_COIN, WETH);
        (minBalanceToVote, ) = getAmountOutMin(balanceInEth, WETH, artikToken);
    }

    function uploadProject(
        string memory _img,
        string memory _name,
        string memory _description,
        string memory _category,
        string memory _url,
        string memory _twitter,
        bytes20 _tokenAddress,
        string memory _tokenSymbol,
        uint256 _tokenDecimals
    ) external onlyAdmin {
        require(msg.sender != address(0));
        require(bytes(_img).length > 0);
        require(bytes(_name).length > 0);
        require(bytes(_description).length > 0);
        require(bytes(_category).length > 0);
        require(bytes(_url).length > 0);
        require(address(_tokenAddress) != address(0x0));
        require(bytes(_tokenSymbol).length > 0);
        require(_tokenDecimals > 0);

        projectCount = projectCount.add(1);
        projects[projectCount] = Project(
            projectCount,
            _img,
            _name,
            _description,
            _category,
            _url,
            _twitter,
            address(_tokenAddress),
            _tokenSymbol,
            _tokenDecimals,
            true,
            false
        );

        projectVotes[projectCount] = ProjectVotes(projectCount, 0);
    }

    function changeProjectDescription(
        uint256 _projectId,
        string memory _description
    ) external onlyAdmin {
        require(_projectId > 0);
        require(bytes(_description).length > 0);
        projects[_projectId].description = _description;
    }

    function getLeaderBoard() external view returns (ProjectVotes[] memory) {
        return projectsLeaderboard[roundNumber - 1];
    }

    function saveProjectToLeaderboard(
        uint256 _projectId,
        uint256 _roundNumber
    ) external onlyAdmin {
        require(_projectId > 0);
        require(_roundNumber > 0);
        projectsLeaderboard[_roundNumber].push(
            ProjectVotes(_projectId, projectVotes[_projectId].votes)
        );
    }

    function managePitchWinner(
        uint256 _projectId,
        bool _isWinner
    ) external onlyAdmin {
        require(_projectId > 0);
        require(_isWinner == true || _isWinner == false);
        projects[_projectId].pitchWinner = _isWinner;
    }

    function changeProjectState(
        uint256 _projectId,
        bool _active
    ) external onlyAdmin {
        require(_projectId > 0);
        require(_active == true || _active == false);
        projects[_projectId].active = _active;
    }

    function voteProject(uint256 _projectId) external payable {
        require(
            voters[msg.sender][_projectId] != roundNumber,
            "voters can vote the same project only 1 time"
        );
        require(
            distributor.getShareholderIndex(msg.sender) > 0,
            "voters must be token holders"
        );
        require(_projectId != 0, "projectId canno be 0");
        require(msg.value > 0);

        (uint256 priceInBusd, ) = getAmountOutMin(msg.value, WETH, STABLE_COIN);

        if (priceToVote > 0) {
            require(priceInBusd >= priceToVote, "voting has a cost!");
            uint256 amount = msg.value.div(2);

            (bool sentToTeam, ) = admin.call{value: amount}("");
            (bool sentToDistributor, ) = distributorAddress.call{
                value: address(this).balance
            }("");
            require(sentToTeam, "Failed to send to team");
            require(sentToDistributor, "Failed to send to distributor");

            distributor.swapTokens();
        }

        if (minBalanceToVote > 0) {
            require(
                IERC20(artikToken).balanceOf(msg.sender) >= minBalanceToVote,
                "not enough balance to vote"
            );
        }

        projectVotes[_projectId].votes = projectVotes[_projectId].votes.add(1);
        voters[msg.sender][_projectId] = roundNumber;
        isVoter[msg.sender] = true;
        votesCount = votesCount.add(1);
    }

    function setVoter(address _shareholder, bool _isVoter) external onlyAdmin {
        require(_shareholder != address(0x0));
        require(_isVoter == true || _isVoter == false);
        isVoter[_shareholder] = _isVoter;
    }

    function isShareholderVoter(
        address _shareholder
    ) external view returns (bool) {
        require(_shareholder != address(0x0));
        return isVoter[_shareholder];
    }

    function resetProjectVotes(uint256 _projectId) external onlyAdmin {
        require(_projectId > 0);
        projectVotes[_projectId].votes = 0;
    }

    function setBestProject(uint256 _projectId) external onlyAdmin {
        require(_projectId > 0);
        bestProject = projects[_projectId];
    }

    function getProjectVotes(
        uint256 _projectId
    ) external view onlyAdmin returns (ProjectVotes memory) {
        require(_projectId > 0);
        return projectVotes[_projectId];
    }

    function getBestProject() external view returns (Project memory) {
        return bestProject;
    }

    function getAmountOutMin(
        uint256 _amount,
        address _tokenIn,
        address _tokenOut
    ) private view returns (uint256, address[] memory) {
        address[] memory path = new address[](2);
        path[0] = _tokenIn;
        path[1] = _tokenOut;

        uint256[] memory amountOutMins = dexRouter.getAmountsOut(_amount, path);
        return (amountOutMins[1], path);
    }

    function setRound(uint256 _round) public onlyAdmin {
        require(_round > 0);
        roundNumber = _round;
    }

    function nextRound() public onlyAdmin {
        roundNumber = roundNumber.add(1);
    }

    function hasVotedProject(uint256 _projectId) external view returns (bool) {
        if (voters[msg.sender][_projectId] == roundNumber) {
            return true;
        } else {
            return false;
        }
    }

    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 z
    ) public pure returns (uint256) {
        return
            ABDKMathQuad.toUInt(
                ABDKMathQuad.div(
                    ABDKMathQuad.mul(
                        ABDKMathQuad.fromUInt(x),
                        ABDKMathQuad.fromUInt(y)
                    ),
                    ABDKMathQuad.fromUInt(z)
                )
            );
    }
}


// File: /contracts/DistributorV2.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "./interfaces/DexRouter.sol";

import "./libraries/ABDKMathQuad.sol";

import "./ProjectManager.sol";

contract DistributorV2 is Initializable {
    using SafeMath for uint256;

    // Pancakeswap 0x10ED43C718714eb63d5aA57B78B54704E256024E (testnet: 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3)
    address constant ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
    // WBNB 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c (testnet: 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd)
    address constant WETH = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
    // BUSD 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56 (testnet: 0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7)
    address constant STABLE_COIN = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;

    uint256 private constant BUY_BACK_FEE = 25; //(2% of total fee)
    uint256 private accumulatedEthForAirdrop;

    DexRouter private dexRouter;

    address private artikToken;
    address payable private admin;

    address[] public shareholders;
    uint256 private shareholderCount;
    mapping(address => uint256) private shareholderIndexes;

    mapping(address => mapping(uint256 => bool)) private userClaimedProject;
    uint256 public totalAmountAirdropped;
    mapping(address => uint256) public amountClaimed;

    uint256 public airdropBalance;
    uint256 public totalHoldersBalance;
    uint256 public airdropDate;

    mapping(address => mapping(uint256 => mapping(uint256 => bool)))
        private userHasClaimedProject;

    mapping(uint256 => uint256) private airdropSnapshot;
    uint256 private stableCoinBalance;

    ProjectManager private projectManager;
    address private projectManagerAddress;

    mapping(address => uint256) public holderSellingDays;
    uint256 private holdingDays;

    modifier onlyAdmin() {
        require(
            msg.sender == admin ||
                msg.sender == artikToken ||
                msg.sender == projectManagerAddress
        );
        _;
    }

    function initialize(address _tokenAddress) public initializer {
        dexRouter = DexRouter(ROUTER);
        artikToken = _tokenAddress;
        admin = payable(msg.sender);
        shareholderCount = 0;
        totalAmountAirdropped = 0;
        accumulatedEthForAirdrop = 0;
        totalHoldersBalance = 0;
        airdropBalance = 0;
        stableCoinBalance = 0;
    }

    function configureProjectManager(address _address) external onlyAdmin {
        require(_address != address(0x0));
        projectManagerAddress = _address;
        projectManager = ProjectManager(_address);
    }

    function setAirdropDate(uint256 _days) public onlyAdmin {
        require(_days > 0);
        airdropDate = block.timestamp + (1 days * _days);
    }

    // Initialize airdrop
    // 1) approveAirdrop
    // 2) buyBack
    // 3) buyAirdropTokens
    // 4) initializeNextRound
    function approveAirdrop() external onlyAdmin {
        airdropSnapshot[projectManager.roundNumber()] = calculateTVL();

        stableCoinBalance = IERC20(STABLE_COIN).balanceOf(address(this));
        require(stableCoinBalance > 0);

        IERC20(STABLE_COIN).approve(ROUTER, stableCoinBalance);
        (uint256 amountWethMin, ) = getAmountOutMin(
            stableCoinBalance,
            STABLE_COIN,
            WETH
        );
        IERC20(WETH).approve(ROUTER, amountWethMin);
    }

    function buyBack() external onlyAdmin {
        swapTokensForETH(
            mulDiv(stableCoinBalance, BUY_BACK_FEE, 100),
            STABLE_COIN
        );
        swapETHForTokens(address(this).balance, artikToken);
        IERC20(artikToken).transfer(
            address(0x0),
            IERC20(artikToken).balanceOf(address(this))
        );
    }

    function buyAirdropTokens(uint256 _amount) external onlyAdmin {
        require(_amount > 0);
        swapTokensForETH(_amount, STABLE_COIN);
        swapETHForTokens(
            address(this).balance,
            projectManager.getBestProject().tokenAddress
        );
    }

    function initializeNextRound(uint256 _days) external onlyAdmin {
        require(_days > 0);

        projectManager.nextRound();
        airdropSnapshot[projectManager.roundNumber()] = 0;
        setAirdropDate(_days);
        airdropBalance = IERC20(projectManager.getBestProject().tokenAddress)
            .balanceOf(address(this));
    }

    // End Airdrop

    function claimAirdrop() public {
        uint256 airdrop = calculateAirdropAmount(msg.sender);
        IERC20(projectManager.getBestProject().tokenAddress).transfer(
            msg.sender,
            airdrop
        );

        projectManager.setVoter(msg.sender, false);
        userHasClaimedProject[msg.sender][projectManager.roundNumber()][
            projectManager.getBestProject().id
        ] = true;

        (uint256 amountWethMin, ) = getAmountOutMin(
            airdrop,
            projectManager.getBestProject().tokenAddress,
            WETH
        );
        (uint256 amountStableMin, ) = getAmountOutMin(
            amountWethMin,
            WETH,
            STABLE_COIN
        );

        amountClaimed[msg.sender] = amountClaimed[msg.sender].add(
            amountStableMin
        );
        totalAmountAirdropped = totalAmountAirdropped.add(amountStableMin);
    }

    function calculateTVL() public view returns (uint256) {
        uint256 currentBalance = 0;
        for (uint256 i = 0; i < shareholders.length; i++) {
            if (projectManager.isShareholderVoter(shareholders[i])) {
                currentBalance = currentBalance.add(
                    IERC20(artikToken).balanceOf(shareholders[i])
                );
            }
        }
        return currentBalance;
    }

    function calculateAirdropAmount(
        address _shareholder
    ) public view returns (uint256) {
        require(shareholderIndexes[_shareholder] > 0, "not a shareholder");
        require(projectManager.isShareholderVoter(_shareholder), "not a voter");
        require(
            _shareholder != address(0x0),
            "shareholder cannot be address of 0"
        );
        require(
            airdropSnapshot[projectManager.roundNumber() - 1] > 0,
            "total holders balance less than 0"
        );

        require(
            userHasClaimedProject[_shareholder][projectManager.roundNumber()][
                projectManager.getBestProject().id
            ] != true,
            "shareholder has already claimed this airdrop"
        );

        uint256 holderPercentage = calculateHolderPercentage(
            _shareholder,
            airdropSnapshot[projectManager.roundNumber() - 1]
        );

        uint256 airdropBasedOnHoldingAmount = mulDiv(
            airdropBalance.div(2),
            holderPercentage,
            1000000
        );

        uint256 holderPercentageBasedOnDays = calculateHolderPercentageBasedOnDays(
                _shareholder
            );

        uint256 airdropBasedOnHoldingDays = mulDiv(
            airdropBalance.div(2),
            holderPercentageBasedOnDays,
            1000000
        );

        return
            airdropBasedOnHoldingAmount.add(airdropBasedOnHoldingDays).div(
                1000000
            );
    }

    function calculateHolderPercentage(
        address _shareholder,
        uint256 _totalHoldersBalance
    ) private view returns (uint256) {
        // 100 : x = totalHoldersBalance : holderBalance
        uint256 holderBalance = IERC20(artikToken).balanceOf(_shareholder);
        uint256 holderPercentage = mulDiv(
            holderBalance,
            1000000,
            _totalHoldersBalance
        );
        return holderPercentage;
    }

    function increaseHoldingDays() external onlyAdmin {
        holdingDays = holdingDays.add(1);
    }

    function removeHoldingDay(address _shareholder) external onlyAdmin {
        require(_shareholder != address(0x0));

        if (holderSellingDays[_shareholder] > 0) {
            holderSellingDays[_shareholder] = holderSellingDays[_shareholder]
                .sub(1);
        }
    }

    function calculateHolderPercentageBasedOnDays(
        address _shareholder
    ) private view returns (uint256) {
        // 100 : x = : total holders days : holder days
        uint256 holderDays = holdingDays.sub(holderSellingDays[_shareholder]);
        uint256 holderPercentage = mulDiv(holderDays, 1000000, holdingDays);
        return holderPercentage;
    }

    function calculateExpectedAirdrop(
        address _shareholder
    ) external view returns (uint256) {
        require(
            _shareholder != address(0x0),
            "shareholder address cannot be 0"
        );
        require(shareholderIndexes[_shareholder] > 0, "not a shareholder");

        uint256 holderBalance = IERC20(artikToken).balanceOf(_shareholder);
        require(
            holderBalance > 0,
            "shareholder balance must be greater than 0"
        );

        uint256 holders_balance = 0;
        if (airdropSnapshot[projectManager.roundNumber()] > 0) {
            holders_balance = airdropSnapshot[projectManager.roundNumber()];
        } else {
            holders_balance = calculateTVL();
        }

        uint256 holderPercentage = calculateHolderPercentage(
            _shareholder,
            holders_balance
        );

        uint256 treasuryForAirdrop = mulDiv(
            IERC20(STABLE_COIN).balanceOf(address(this)),
            75,
            100
        );

        uint256 airdropBasedOnHoldingAmount = mulDiv(
            (treasuryForAirdrop.div(2)),
            holderPercentage,
            1000000
        );

        uint256 holderPercentageBasedOnDays = calculateHolderPercentageBasedOnDays(
                _shareholder
            );

        uint256 airdropBasedOnHoldingDays = mulDiv(
            (treasuryForAirdrop.div(2)),
            holderPercentageBasedOnDays,
            1000000
        );

        return
            airdropBasedOnHoldingAmount.add(airdropBasedOnHoldingDays).div(
                1000000
            );
    }

    function getShareholderIndex(
        address _shareholder
    ) external view returns (uint256) {
        require(_shareholder != address(0x0));
        return shareholderIndexes[_shareholder];
    }

    function addShareHolder(address _shareholder) external onlyAdmin {
        require(_shareholder != address(0x0));

        if (shareholderIndexes[_shareholder] <= 0) {
            shareholders.push(_shareholder);
            shareholderCount = shareholderCount.add(1);
            shareholderIndexes[_shareholder] = shareholderCount;
        }
    }

    function removeShareHolder(address _shareholder) external onlyAdmin {
        require(_shareholder != address(0x0));

        if (shareholderIndexes[_shareholder] > 0) {
            shareholders[shareholderIndexes[_shareholder] - 1] = shareholders[
                shareholders.length - 1
            ];
            shareholders.pop();
            shareholderCount = shareholderCount.sub(1);
            shareholderIndexes[_shareholder] = 0;
        }
    }

    function swapETHForTokens(uint256 _amount, address _token) private {
        require(_amount > 0, "amount less than 0");
        require(_token != address(0x0), "address is not valid");
        require(address(this).balance >= _amount, "balance less than _amount");

        address[] memory path = new address[](2);
        path[0] = WETH;
        path[1] = _token;

        dexRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{
            value: _amount
        }(0, path, address(this), block.timestamp);
    }

    function swapTokensForETH(uint256 _amount, address _token) private {
        require(_amount > 0);
        require(_token != address(0x0));
        require(
            IERC20(_token).balanceOf(address(this)) >= _amount,
            "balance less than _amount"
        );

        address[] memory path = new address[](2);
        path[0] = _token;
        path[1] = WETH;

        dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(
            _amount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

    function getAmountOutMin(
        uint256 _amount,
        address _tokenIn,
        address _tokenOut
    ) private view returns (uint256, address[] memory) {
        address[] memory path = new address[](2);
        path[0] = _tokenIn;
        path[1] = _tokenOut;

        uint256[] memory amountOutMins = dexRouter.getAmountsOut(_amount, path);
        return (amountOutMins[1], path);
    }

    function swapTokens() external onlyAdmin {
        IERC20(WETH).approve(ROUTER, address(this).balance);
        swapETHForTokens(address(this).balance, STABLE_COIN);
    }

    function withdrawRemainingAirdrop(address _token) external onlyAdmin {
        require(_token != address(0x0));
        uint256 remainingBalance = IERC20(_token).balanceOf(address(this));
        totalAmountAirdropped = totalAmountAirdropped.add(remainingBalance);
        require(remainingBalance > 0);
        IERC20(_token).transfer(admin, remainingBalance);
    }

    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 z
    ) public pure returns (uint256) {
        return
            ABDKMathQuad.toUInt(
                ABDKMathQuad.div(
                    ABDKMathQuad.mul(
                        ABDKMathQuad.fromUInt(x),
                        ABDKMathQuad.fromUInt(y)
                    ),
                    ABDKMathQuad.fromUInt(z)
                )
            );
    }

    receive() external payable {}
}


// File: /contracts/DistributorV1.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "./interfaces/DexRouter.sol";

import "./libraries/ABDKMathQuad.sol";

contract DistributorV1 is Initializable {
    using SafeMath for uint256;

    // Pancakeswap 0x10ED43C718714eb63d5aA57B78B54704E256024E (testnet: 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3)
    address constant ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
    // WBNB 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c (testnet: 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd)
    address constant WETH = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
    // BUSD 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56 (testnet: 0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7)
    address constant STABLE_COIN = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;

    uint256 private constant BUY_BACK_FEE = 25; //(2% of total fee)
    uint256 private accumulatedEthForAirdrop;

    DexRouter private dexRouter;

    address private artikToken;
    address payable private admin;

    address[] public shareholders;
    uint256 private shareholderCount;
    mapping(address => uint256) private shareholderIndexes;

    uint256 public roundNumber;
    mapping(address => mapping(uint256 => uint256)) private voters;
    mapping(address => bool) private isVoter;

    mapping(address => mapping(uint256 => bool)) private userClaimedProject;
    uint256 public totalAmountAirdropped;
    mapping(address => uint256) public amountClaimed;

    Project public bestProject;

    uint256 public airdropBalance;
    uint256 public totalHoldersBalance;
    uint256 public airdropDate;

    uint256 public projectCount;
    uint256 public votesCount;
    mapping(uint256 => Project) public projects;

    mapping(address => mapping(uint256 => mapping(uint256 => bool)))
        private userHasClaimedProject;

    mapping(uint256 => uint256) private airdropSnapshot;

    struct Project {
        uint256 id;
        string img;
        string name;
        string description;
        string category;
        string url;
        string twitter;
        uint256 votes;
        address tokenAddress;
        string tokenSymbol;
        uint256 tokenDecimals;
        bool active;
    }

    function initialize(address _tokenAddress) public initializer {
        dexRouter = DexRouter(ROUTER);
        artikToken = _tokenAddress;
        admin = payable(msg.sender);
        shareholderCount = 0;
        roundNumber = 1;
        totalAmountAirdropped = 0;
        projectCount = 0;
        votesCount = 0;
        accumulatedEthForAirdrop = 0;
        totalHoldersBalance = 0;
        airdropBalance = 0;
    }

    modifier onlyToken() {
        require(msg.sender == artikToken, "sender is not the token");
        _;
    }

    modifier onlyAdmin() {
        require(msg.sender == admin);
        _;
    }

    function uploadProject(
        string memory _img,
        string memory _name,
        string memory _description,
        string memory _category,
        string memory _url,
        string memory _twitter,
        bytes20 _tokenAddress,
        string memory _tokenSymbol,
        uint256 _tokenDecimals
    ) external onlyAdmin {
        require(msg.sender != address(0));
        require(bytes(_img).length > 0);
        require(bytes(_name).length > 0);
        require(bytes(_description).length > 0);
        require(bytes(_category).length > 0);
        require(bytes(_url).length > 0);
        require(address(_tokenAddress) != address(0x0));
        require(bytes(_tokenSymbol).length > 0);
        require(_tokenDecimals > 0);

        projectCount = projectCount.add(1);
        projects[projectCount] = Project(
            projectCount,
            _img,
            _name,
            _description,
            _category,
            _url,
            _twitter,
            0,
            address(_tokenAddress),
            _tokenSymbol,
            _tokenDecimals,
            true
        );
    }

    function changeProjectState(
        uint256 _projectId,
        bool _active
    ) external onlyAdmin {
        projects[_projectId].active = _active;
    }

    function voteProject(uint256 _projectId) external {
        require(
            voters[msg.sender][_projectId] != roundNumber,
            "voters can vote the same project only 1 time"
        );
        require(
            shareholderIndexes[msg.sender] > 0,
            "voters must be token holders"
        );
        require(_projectId != 0, "projectId canno be 0");

        projects[_projectId].votes = projects[_projectId].votes.add(1);
        voters[msg.sender][_projectId] = roundNumber;
        isVoter[msg.sender] = true;
        votesCount = votesCount.add(1);
    }

    function resetProjectVotes(uint256 _projectId) external onlyAdmin {
        projects[_projectId].votes = 0;
    }

    function setBestProject(uint256 _projectId) external onlyAdmin {
        bestProject = projects[_projectId];
    }

    function setAirdropDate(uint256 _days) public onlyAdmin {
        airdropDate = block.timestamp + (1 days * _days);
    }

    function takeSnapshot() external onlyAdmin {
        airdropSnapshot[roundNumber] = calculateTVL(true);
    }

    function initializeAirdrop(uint256 _days) external onlyAdmin {
        require(block.timestamp >= airdropDate);

        uint256 STABLE_COINBalance = IERC20(STABLE_COIN).balanceOf(
            address(this)
        );

        require(STABLE_COINBalance > 0);
        require(bestProject.id != 0);

        nextRound();
        airdropSnapshot[roundNumber] = 0;

        IERC20(STABLE_COIN).approve(ROUTER, STABLE_COINBalance);
        (uint256 amountWethMin, ) = getAmountOutMin(
            STABLE_COINBalance,
            STABLE_COIN,
            WETH
        );
        IERC20(WETH).approve(ROUTER, amountWethMin);

        uint256 buyBackFee = mulDiv(STABLE_COINBalance, BUY_BACK_FEE, 100);
        uint256 amountToSwap = STABLE_COINBalance.sub(buyBackFee);

        // Buy back mechanism
        buyBack(buyBackFee);

        // Swap BUSD -> BNB -> Airdrop Token
        buyAirdropTokens(amountToSwap, bestProject.tokenAddress);
        setAirdropDate(_days);

        airdropBalance = IERC20(bestProject.tokenAddress).balanceOf(
            address(this)
        );
    }

    function buyAirdropTokens(uint256 _amount, address _project) private {
        swapTokensForETH(_amount, STABLE_COIN);
        swapETHForTokens(address(this).balance, _project);
    }

    function buyBack(uint256 _fee) private {
        swapTokensForETH(_fee, STABLE_COIN);
        swapETHForTokens(address(this).balance, artikToken);
        IERC20(artikToken).transfer(
            address(0x0),
            IERC20(artikToken).balanceOf(address(this))
        );
    }

    function claimAirdrop() public {
        uint256 airdrop = calculateAirdropAmount(msg.sender);
        IERC20(bestProject.tokenAddress).transfer(msg.sender, airdrop);

        isVoter[msg.sender] = false;
        userHasClaimedProject[msg.sender][roundNumber][bestProject.id] = true;

        (uint256 amountWethMin, ) = getAmountOutMin(
            airdrop,
            bestProject.tokenAddress,
            WETH
        );
        (uint256 amountStableMin, ) = getAmountOutMin(
            amountWethMin,
            WETH,
            STABLE_COIN
        );

        amountClaimed[msg.sender] = amountClaimed[msg.sender].add(
            amountStableMin
        );
        totalAmountAirdropped = totalAmountAirdropped.add(amountStableMin);
    }

    function calculateTVL(bool _onlyVoters) public view returns (uint256) {
        uint256 currentBalance = 0;
        for (uint256 i = 0; i < shareholders.length; i++) {
            if ((_onlyVoters && isVoter[shareholders[i]]) || !_onlyVoters) {
                currentBalance = currentBalance.add(
                    IERC20(artikToken).balanceOf(shareholders[i])
                );
            }
        }
        return currentBalance;
    }

    function calculateAirdropAmount(
        address _shareholder
    ) public view returns (uint256) {
        require(shareholderIndexes[_shareholder] > 0, "not a shareholder");
        require(isVoter[_shareholder] == true, "not a voter");
        require(
            _shareholder != address(0x0),
            "shareholder cannot be address of 0"
        );
        require(
            airdropSnapshot[roundNumber - 1] > 0,
            "total holders balance less than 0"
        );

        require(
            userHasClaimedProject[_shareholder][roundNumber][bestProject.id] !=
                true,
            "shareholder has already claimed this airdrop"
        );

        uint256 holderPercentage = calculateHolderPercentage(
            _shareholder,
            airdropSnapshot[roundNumber - 1]
        );

        uint256 airdrop = mulDiv(airdropBalance, holderPercentage, 1000000);

        return airdrop;
    }

    function calculateHolderPercentage(
        address _shareholder,
        uint256 _totalHoldersBalance
    ) private view returns (uint256) {
        // 100 : x = totalHoldersBalance : holderBalance
        uint256 holderBalance = IERC20(artikToken).balanceOf(_shareholder);
        uint256 holderPercentage = mulDiv(
            holderBalance,
            1000000,
            _totalHoldersBalance
        );
        return holderPercentage;
    }

    function calculateExpectedAirdrop(
        address _shareholder
    ) external view returns (uint256) {
        require(
            _shareholder != address(0x0),
            "shareholder address cannot be 0"
        );
        require(shareholderIndexes[_shareholder] > 0, "not a shareholder");

        uint256 holderBalance = IERC20(artikToken).balanceOf(_shareholder);
        require(
            holderBalance > 0,
            "shareholder balance must be greater than 0"
        );

        uint256 holders_balance = 0;
        if (airdropSnapshot[roundNumber] > 0) {
            holders_balance = airdropSnapshot[roundNumber];
        } else {
            holders_balance = calculateTVL(true);
        }

        uint256 holderPercentage = calculateHolderPercentage(
            _shareholder,
            holders_balance
        );

        uint256 treasuryForAirdrop = mulDiv(
            IERC20(STABLE_COIN).balanceOf(address(this)),
            75,
            100
        );

        return mulDiv(treasuryForAirdrop, holderPercentage, 1000000);
    }

    function addShareHolder(address _shareholder) external onlyToken {
        require(_shareholder != address(0x0));

        if (shareholderIndexes[_shareholder] <= 0) {
            shareholders.push(_shareholder);
            shareholderCount = shareholderCount.add(1);
            shareholderIndexes[_shareholder] = shareholderCount;
        }
    }

    function removeShareHolder(address _shareholder) external onlyToken {
        require(_shareholder != address(0x0));

        if (shareholderIndexes[_shareholder] > 0) {
            shareholders[shareholderIndexes[_shareholder] - 1] = shareholders[
                shareholders.length - 1
            ];
            shareholders.pop();
            shareholderCount = shareholderCount.sub(1);
            shareholderIndexes[_shareholder] = 0;
        }
    }

    function swapETHForTokens(uint256 _amount, address _token) private {
        require(_amount > 0);
        require(_token != address(0x0));
        require(address(this).balance >= _amount, "balance less than _amount");

        address[] memory path = new address[](2);
        path[0] = WETH;
        path[1] = _token;

        dexRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{
            value: _amount
        }(0, path, address(this), block.timestamp);
    }

    function swapTokensForETH(uint256 _amount, address _token) private {
        require(_amount > 0);
        require(_token != address(0x0));
        require(
            IERC20(_token).balanceOf(address(this)) >= _amount,
            "balance less than _amount"
        );

        address[] memory path = new address[](2);
        path[0] = _token;
        path[1] = WETH;

        dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(
            _amount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

    function getAmountOutMin(
        uint256 _amount,
        address _tokenIn,
        address _tokenOut
    ) private view returns (uint256, address[] memory) {
        address[] memory path = new address[](2);
        path[0] = _tokenIn;
        path[1] = _tokenOut;

        uint256[] memory amountOutMins = dexRouter.getAmountsOut(_amount, path);
        return (amountOutMins[1], path);
    }

    function swapTokens() external onlyToken {
        IERC20(WETH).approve(ROUTER, address(this).balance);
        swapETHForTokens(address(this).balance, STABLE_COIN);
    }

    function nextRound() public onlyAdmin {
        roundNumber = roundNumber.add(1);
    }

    function withdrawRemainingAirdrop(address _token) external onlyAdmin {
        require(_token != address(0x0));
        uint256 remainingBalance = IERC20(_token).balanceOf(address(this));
        require(remainingBalance > 0);
        IERC20(_token).transfer(admin, remainingBalance);
    }

    function hasVotedProject(uint256 _projectId) external view returns (bool) {
        if (voters[msg.sender][_projectId] == roundNumber) {
            return true;
        } else {
            return false;
        }
    }

    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 z
    ) public pure returns (uint256) {
        return
            ABDKMathQuad.toUInt(
                ABDKMathQuad.div(
                    ABDKMathQuad.mul(
                        ABDKMathQuad.fromUInt(x),
                        ABDKMathQuad.fromUInt(y)
                    ),
                    ABDKMathQuad.fromUInt(z)
                )
            );
    }

    receive() external payable {}
}


// File: /contracts/DistributorContract.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "./interfaces/DexRouter.sol";

contract DistributorContract is Initializable {
    using SafeMath for uint256;

    // Pancakeswap 0x10ED43C718714eb63d5aA57B78B54704E256024E (testnet: 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3)
    address constant ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
    // WBNB 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c (testnet: 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd)
    address constant WETH = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
    // BUSD 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56 (testnet: 0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7)
    address constant STABLE_COIN = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;

    uint256 private constant BUY_BACK_FEE = 25; //(2% of total fee)
    uint256 private accumulatedEthForAirdrop;

    DexRouter private dexRouter;

    address private artikToken;
    address payable private admin;

    address[] public shareholders;
    uint256 private shareholderCount;
    mapping(address => uint256) private shareholderIndexes;

    uint256 public roundNumber;
    mapping(address => mapping(uint256 => uint256)) private voters;
    mapping(address => bool) private isVoter;

    mapping(address => mapping(uint256 => bool)) private userClaimedProject;
    uint256 public totalAmountAirdropped;
    mapping(address => uint256) public amountClaimed;

    Project public bestProject;

    uint256 public airdropBalance;
    uint256 public totalHoldersBalance;
    uint256 public airdropDate;

    uint256 public projectCount;
    uint256 public votesCount;
    mapping(uint256 => Project) public projects;

    mapping(address => mapping(uint256 => mapping(uint256 => bool)))
        private userHasClaimedProject;

    event ProjectUploaded(
        uint256 id,
        string img,
        string name,
        string description,
        string category,
        string url,
        string twitter,
        uint256 votes,
        address tokenAddress,
        string tokenSymbol,
        uint256 tokenDecimals,
        bool active
    );

    struct Project {
        uint256 id;
        string img;
        string name;
        string description;
        string category;
        string url;
        string twitter;
        uint256 votes;
        address tokenAddress;
        string tokenSymbol;
        uint256 tokenDecimals;
        bool active;
    }

    function initialize(address _tokenAddress) public initializer {
        dexRouter = DexRouter(ROUTER);
        artikToken = _tokenAddress;
        admin = payable(msg.sender);
        shareholderCount = 0;
        roundNumber = 1;
        totalAmountAirdropped = 0;
        projectCount = 0;
        votesCount = 0;
        accumulatedEthForAirdrop = 0;
        totalHoldersBalance = 0;
        airdropBalance = 0;
    }

    modifier onlyToken() {
        require(msg.sender == artikToken, "sender is not the token");
        _;
    }

    modifier onlyAdmin() {
        require(msg.sender == admin);
        _;
    }

    function uploadProject(
        string memory _img,
        string memory _name,
        string memory _description,
        string memory _category,
        string memory _url,
        string memory _twitter,
        bytes20 _tokenAddress,
        string memory _tokenSymbol,
        uint256 _tokenDecimals
    ) external onlyAdmin {
        require(msg.sender != address(0));
        require(bytes(_img).length > 0);
        require(bytes(_name).length > 0);
        require(bytes(_description).length > 0);
        require(bytes(_category).length > 0);
        require(bytes(_url).length > 0);
        require(address(_tokenAddress) != address(0x0));
        require(bytes(_tokenSymbol).length > 0);
        require(_tokenDecimals > 0);

        projectCount = projectCount.add(1);
        projects[projectCount] = Project(
            projectCount,
            _img,
            _name,
            _description,
            _category,
            _url,
            _twitter,
            0,
            address(_tokenAddress),
            _tokenSymbol,
            _tokenDecimals,
            true
        );

        emit ProjectUploaded(
            projectCount,
            _img,
            _name,
            _description,
            _category,
            _url,
            _twitter,
            0,
            address(_tokenAddress),
            _tokenSymbol,
            _tokenDecimals,
            true
        );
    }

    function changeProjectState(
        uint256 _projectId,
        bool _active
    ) external onlyAdmin {
        projects[_projectId].active = _active;
    }

    function voteProject(uint256 _projectId) external {
        require(
            voters[msg.sender][_projectId] != roundNumber,
            "voters can vote the same project only 1 time"
        );
        require(
            shareholderIndexes[msg.sender] > 0,
            "voters must be token holders"
        );
        require(_projectId != 0, "projectId canno be 0");

        projects[_projectId].votes = projects[_projectId].votes.add(1);
        voters[msg.sender][_projectId] = roundNumber;
        isVoter[msg.sender] = true;
        votesCount = votesCount.add(1);
    }

    function resetProjectVotes(uint256 _projectId) external onlyAdmin {
        projects[_projectId].votes = 0;
    }

    function setBestProject(uint256 _projectId) external onlyAdmin {
        bestProject = projects[_projectId];
    }

    function setAirdropDate(uint256 _days) public onlyAdmin {
        airdropDate = block.timestamp + (1 days * _days);
    }

    function initializeAirdrop(uint256 _days) external onlyAdmin {
        require(block.timestamp >= airdropDate);

        uint256 STABLE_COINBalance = IERC20(STABLE_COIN).balanceOf(
            address(this)
        );

        require(STABLE_COINBalance > 0);
        require(bestProject.id != 0);

        totalHoldersBalance = calculateTVL(true);
        nextRound();

        IERC20(STABLE_COIN).approve(ROUTER, STABLE_COINBalance);
        (uint256 amountWethMin, ) = getAmountOutMin(
            STABLE_COINBalance,
            STABLE_COIN,
            WETH
        );
        IERC20(WETH).approve(ROUTER, amountWethMin);

        uint256 buyBackFee = STABLE_COINBalance.mul(BUY_BACK_FEE).div(100);
        uint256 amountToSwap = STABLE_COINBalance.sub(buyBackFee);

        // Buy back mechanism
        buyBack(buyBackFee);

        // Swap BUSD -> BNB -> Airdrop Token
        buyAirdropTokens(amountToSwap, bestProject.tokenAddress);
        setAirdropDate(_days);

        airdropBalance = IERC20(bestProject.tokenAddress).balanceOf(
            address(this)
        );

        //accumulatedEthForAirdrop = airdropBalance;
        (accumulatedEthForAirdrop, ) = getAmountOutMin(
            airdropBalance,
            bestProject.tokenAddress,
            WETH
        );
    }

    function buyAirdropTokens(uint256 _amount, address _project) private {
        swapTokensForETH(_amount, STABLE_COIN);
        swapETHForTokens(address(this).balance, _project);
    }

    function buyBack(uint256 _fee) private {
        swapTokensForETH(_fee, STABLE_COIN);
        swapETHForTokens(address(this).balance, artikToken);
        IERC20(artikToken).transfer(
            address(0x0),
            IERC20(artikToken).balanceOf(address(this))
        );
    }

    function claimAirdrop() public {
        uint256 airdrop = calculateAirdropAmount(msg.sender);
        IERC20(bestProject.tokenAddress).transfer(msg.sender, airdrop);

        isVoter[msg.sender] == false;
        userHasClaimedProject[msg.sender][roundNumber][bestProject.id] = true;

        (uint256 amountWethMin, ) = getAmountOutMin(
            airdrop,
            bestProject.tokenAddress,
            WETH
        );
        (uint256 amountStableMin, ) = getAmountOutMin(
            amountWethMin,
            WETH,
            STABLE_COIN
        );

        amountClaimed[msg.sender] = amountClaimed[msg.sender].add(
            amountStableMin
        );
        totalAmountAirdropped = totalAmountAirdropped.add(amountStableMin);
    }

    function calculateTVL(bool _onlyVoters) public view returns (uint256) {
        uint256 currentBalance = 0;
        for (uint256 i = 0; i < shareholders.length; i++) {
            if ((_onlyVoters && isVoter[shareholders[i]]) || !_onlyVoters) {
                currentBalance = currentBalance.add(
                    IERC20(artikToken).balanceOf(shareholders[i])
                );
            }
        }
        return currentBalance;
    }

    function calculateAirdropAmount(
        address _shareholder
    ) public view returns (uint256) {
        require(shareholderIndexes[_shareholder] > 0, "not a shareholder");
        require(isVoter[_shareholder] == true, "not a voter");
        require(
            _shareholder != address(0x0),
            "shareholder cannot be address of 0"
        );
        require(totalHoldersBalance > 0, "total holders balance less than 0");

        require(
            userHasClaimedProject[_shareholder][roundNumber][bestProject.id] !=
                true,
            "shareholder has already claimed this airdrop"
        );

        uint256 holderPercentage = calculateHolderPercentage(
            _shareholder,
            totalHoldersBalance
        );
        uint256 airdrop = airdropBalance.mul(holderPercentage).div(100);

        return airdrop;
    }

    function calculateHolderPercentage(
        address _shareholder,
        uint256 _totalHoldersBalance
    ) private view returns (uint256) {
        // 100 : x = totalHoldersBalance : holderBalance
        uint256 holderBalance = IERC20(artikToken).balanceOf(_shareholder);
        uint256 holderPercentage = holderBalance.mul(100).div(
            _totalHoldersBalance
        );
        return holderPercentage;
    }

    function calculateAirdropPercentage(
        address _shareholder
    ) external view returns (uint256) {
        require(
            _shareholder != address(0x0),
            "shareholder address cannot be 0"
        );
        require(shareholderIndexes[_shareholder] > 0, "not a shareholder");

        uint256 holderBalance = IERC20(artikToken).balanceOf(_shareholder);
        require(
            holderBalance > 0,
            "shareholder balance must be greater than 0"
        );

        uint256 holders_balance = 0;
        if (totalHoldersBalance > 0) {
            holders_balance = totalHoldersBalance;
        } else {
            holders_balance = calculateTVL(true);
        }

        uint256 holderPercentage = calculateHolderPercentage(
            _shareholder,
            holders_balance
        );
        uint256 airdrop = accumulatedEthForAirdrop.mul(holderPercentage).div(
            100
        );

        require(airdrop > 0, "airdrop amount must be greater than 0");
        (uint256 airdropInArtik, ) = getAmountOutMin(airdrop, WETH, artikToken);

        // 100 : x = artik balance : airdrop in artik
        return airdropInArtik.mul(100).div(holderBalance);
    }

    function addShareHolder(address _shareholder) external onlyToken {
        require(_shareholder != address(0x0));

        if (shareholderIndexes[_shareholder] <= 0) {
            shareholders.push(_shareholder);
            shareholderCount = shareholderCount.add(1);
            shareholderIndexes[_shareholder] = shareholderCount;
        }
    }

    function removeShareHolder(address _shareholder) external onlyToken {
        require(_shareholder != address(0x0));

        if (shareholderIndexes[_shareholder] > 0) {
            shareholders[shareholderIndexes[_shareholder] - 1] = shareholders[
                shareholders.length - 1
            ];
            shareholders.pop();
            shareholderCount = shareholderCount.sub(1);
            shareholderIndexes[_shareholder] = 0;
        }
    }

    function swapETHForTokens(uint256 _amount, address _token) private {
        require(_amount > 0);
        require(_token != address(0x0));
        require(address(this).balance >= _amount, "balance less than _amount");

        address[] memory path = new address[](2);
        path[0] = WETH;
        path[1] = _token;

        dexRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{
            value: _amount
        }(0, path, address(this), block.timestamp);
    }

    function swapTokensForETH(uint256 _amount, address _token) private {
        require(_amount > 0);
        require(_token != address(0x0));
        require(
            IERC20(_token).balanceOf(address(this)) >= _amount,
            "balance less than _amount"
        );

        address[] memory path = new address[](2);
        path[0] = _token;
        path[1] = WETH;

        dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(
            _amount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

    function getAmountOutMin(
        uint256 _amount,
        address _tokenIn,
        address _tokenOut
    ) private view returns (uint256, address[] memory) {
        address[] memory path = new address[](2);
        path[0] = _tokenIn;
        path[1] = _tokenOut;

        uint256[] memory amountOutMins = dexRouter.getAmountsOut(_amount, path);
        return (amountOutMins[1], path);
    }

    function swapTokens() external onlyToken {
        uint256 buyBackFee = address(this).balance.mul(BUY_BACK_FEE).div(100);
        accumulatedEthForAirdrop = accumulatedEthForAirdrop
            .add(address(this).balance)
            .sub(buyBackFee);

        IERC20(WETH).approve(ROUTER, address(this).balance);
        swapETHForTokens(address(this).balance, STABLE_COIN);
    }

    function nextRound() public onlyAdmin {
        roundNumber = roundNumber.add(1);
    }

    function withdrawRemainingAirdrop(address _token) external onlyAdmin {
        require(_token != address(0x0));
        uint256 remainingBalance = IERC20(_token).balanceOf(address(this));
        require(remainingBalance > 0);
        IERC20(_token).transfer(admin, remainingBalance);
    }

    function hasVotedProject(uint256 _projectId) external view returns (bool) {
        if (voters[msg.sender][_projectId] == roundNumber) {
            return true;
        } else {
            return false;
        }
    }

    receive() external payable {}
}


// File: /contracts/Distributor.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "./interfaces/DexRouter.sol";

contract Distributor is Initializable {
    using SafeMath for uint256;

    // Pancakeswap 0x10ED43C718714eb63d5aA57B78B54704E256024E (testnet: 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3)
    address constant ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
    // WBNB 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c (testnet: 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd)
    address constant BNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
    // BUSD 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56 (testnet: 0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7)
    address constant STABLE_COIN = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;

    uint256 private constant BUY_BACK_FEE = 25; //(2% of total fee)
    uint256 private accumulatedEthForAirdrop;

    DexRouter private dexRouter;

    address private artikToken;
    address payable private admin;

    address[] public shareholders;
    uint256 private shareholderCount;
    mapping(address => uint256) private shareholderIndexes;

    uint256 public roundNumber;
    mapping(address => mapping(uint256 => uint256)) private voters;
    mapping(address => bool) private isVoter;

    mapping(address => mapping(uint256 => bool)) private userClaimedProject;
    uint256 public totalAmountAirdropped;
    mapping(address => uint256) public amountClaimed;

    Project public bestProject;

    uint256 public airdropBalance;
    uint256 public totalHoldersBalance;
    uint256 public airdropDate;

    uint256 public projectCount;
    uint256 public votesCount;
    mapping(uint256 => Project) public projects;

    event WithdrawAirdropTokens(uint256 amount, address token);

    event ProjectUploaded(
        uint256 id,
        string img,
        string name,
        string description,
        string category,
        string url,
        string twitter,
        uint256 votes,
        address tokenAddress,
        string tokenSymbol,
        uint256 tokenDecimals,
        bool active
    );

    struct Project {
        uint256 id;
        string img;
        string name;
        string description;
        string category;
        string url;
        string twitter;
        uint256 votes;
        address tokenAddress;
        string tokenSymbol;
        uint256 tokenDecimals;
        bool active;
    }

    function initialize(address _tokenAddress) public initializer {
        dexRouter = DexRouter(ROUTER);
        artikToken = _tokenAddress;
        admin = payable(msg.sender);
        shareholderCount = 0;
        roundNumber = 1;
        totalAmountAirdropped = 0;
        projectCount = 0;
        votesCount = 0;
        accumulatedEthForAirdrop = 0;
        totalHoldersBalance = 0;
        airdropBalance = 0;
    }

    modifier onlyToken() {
        require(msg.sender == artikToken, "sender is not the token");
        _;
    }

    modifier onlyAdmin() {
        require(msg.sender == admin);
        _;
    }

    function uploadProject(
        string memory _img,
        string memory _name,
        string memory _description,
        string memory _category,
        string memory _url,
        string memory _twitter,
        bytes20 _tokenAddress,
        string memory _tokenSymbol,
        uint256 _tokenDecimals
    ) external onlyAdmin {
        require(msg.sender != address(0));
        require(bytes(_img).length > 0);
        require(bytes(_name).length > 0);
        require(bytes(_description).length > 0);
        require(bytes(_category).length > 0);
        require(bytes(_url).length > 0);
        require(address(_tokenAddress) != address(0x0));
        require(bytes(_tokenSymbol).length > 0);
        require(_tokenDecimals > 0);

        projectCount = projectCount.add(1);
        projects[projectCount] = Project(
            projectCount,
            _img,
            _name,
            _description,
            _category,
            _url,
            _twitter,
            0,
            address(_tokenAddress),
            _tokenSymbol,
            _tokenDecimals,
            true
        );

        emit ProjectUploaded(
            projectCount,
            _img,
            _name,
            _description,
            _category,
            _url,
            _twitter,
            0,
            address(_tokenAddress),
            _tokenSymbol,
            _tokenDecimals,
            true
        );
    }

    function changeProjectState(
        uint256 _projectId,
        bool _active
    ) external onlyAdmin {
        projects[_projectId].active = _active;
    }

    function voteProject(uint256 _projectId) external {
        require(
            voters[msg.sender][_projectId] != roundNumber,
            "voters can vote the same project only 1 time"
        );
        require(
            shareholderIndexes[msg.sender] > 0,
            "voters must be token holders"
        );
        require(_projectId != 0, "projectId canno be 0");

        projects[_projectId].votes = projects[_projectId].votes.add(1);
        voters[msg.sender][_projectId] = roundNumber;
        isVoter[msg.sender] = true;
        votesCount = votesCount.add(1);
    }

    function resetProjectVotes(uint256 _projectId) external onlyAdmin {
        projects[_projectId].votes = 0;
    }

    function setBestProject(uint256 _projectId) external onlyAdmin {
        bestProject = projects[_projectId];
    }

    function setAirdropDate(uint256 _days) public onlyAdmin {
        airdropDate = block.timestamp + (1 days * _days);
    }

    function initializeAirdrop(uint256 _days) external onlyAdmin {
        require(block.timestamp >= airdropDate);

        uint256 STABLE_COINBalance = IERC20(STABLE_COIN).balanceOf(
            address(this)
        );

        require(STABLE_COINBalance > 0);
        require(bestProject.id != 0);

        totalHoldersBalance = calculateTVL(true);
        nextRound();

        IERC20(STABLE_COIN).approve(ROUTER, STABLE_COINBalance);
        (uint256 amountWethMin, ) = getAmountOutMin(
            STABLE_COINBalance,
            STABLE_COIN,
            BNB
        );
        IERC20(BNB).approve(ROUTER, amountWethMin);

        uint256 buyBackFee = STABLE_COINBalance.mul(BUY_BACK_FEE).div(100);
        uint256 amountToSwap = STABLE_COINBalance.sub(buyBackFee);

        // Buy back mechanism
        buyBack(buyBackFee);

        // Swap BUSD -> BNB -> Airdrop Token
        buyAirdropTokens(amountToSwap, bestProject.tokenAddress);
        setAirdropDate(_days);

        airdropBalance = IERC20(bestProject.tokenAddress).balanceOf(
            address(this)
        );

        //accumulatedEthForAirdrop = airdropBalance;
        (accumulatedEthForAirdrop, ) = getAmountOutMin(
            airdropBalance,
            bestProject.tokenAddress,
            BNB
        );
    }

    function buyAirdropTokens(uint256 _amount, address _project) private {
        swapTokensForETH(_amount, STABLE_COIN);
        swapETHForTokens(address(this).balance, _project);
    }

    function buyBack(uint256 _fee) private {
        swapTokensForETH(_fee, STABLE_COIN);
        swapETHForTokens(address(this).balance, artikToken);
        IERC20(artikToken).transfer(
            address(0x0),
            IERC20(artikToken).balanceOf(address(this))
        );
    }

    function claimAirdrop() public {
        uint256 airdrop = calculateAirdropAmount(msg.sender);
        IERC20(bestProject.tokenAddress).transfer(msg.sender, airdrop);

        isVoter[msg.sender] == false;
        userClaimedProject[msg.sender][bestProject.id] = true;

        (uint256 amountWethMin, ) = getAmountOutMin(
            airdrop,
            bestProject.tokenAddress,
            BNB
        );
        (uint256 amountStableMin, ) = getAmountOutMin(
            amountWethMin,
            BNB,
            STABLE_COIN
        );

        amountClaimed[msg.sender] = amountClaimed[msg.sender].add(
            amountStableMin
        );
        totalAmountAirdropped = totalAmountAirdropped.add(amountStableMin);
    }

    function calculateTVL(bool _onlyVoters) public view returns (uint256) {
        uint256 currentBalance = 0;
        for (uint256 i = 0; i < shareholders.length; i++) {
            if ((_onlyVoters && isVoter[shareholders[i]]) || !_onlyVoters) {
                currentBalance = currentBalance.add(
                    IERC20(artikToken).balanceOf(shareholders[i])
                );
            }
        }
        return currentBalance;
    }

    function calculateAirdropAmount(
        address _shareholder
    ) public view returns (uint256) {
        require(shareholderIndexes[_shareholder] > 0, "not a shareholder");
        require(isVoter[_shareholder] == true, "not a voter");
        require(
            _shareholder != address(0x0),
            "shareholder cannot be address of 0"
        );
        require(
            userClaimedProject[_shareholder][bestProject.id] != true,
            "shareholder has already claimed this airdrop"
        );
        require(totalHoldersBalance > 0, "total holders balance less than 0");

        uint256 holderPercentage = calculateHolderPercentage(
            _shareholder,
            totalHoldersBalance
        );
        uint256 airdrop = airdropBalance.mul(holderPercentage).div(100);

        return airdrop;
    }

    function calculateHolderPercentage(
        address _shareholder,
        uint256 _totalHoldersBalance
    ) private view returns (uint256) {
        // 100 : x = totalHoldersBalance : holderBalance
        uint256 holderBalance = IERC20(artikToken).balanceOf(_shareholder);
        uint256 holderPercentage = holderBalance.mul(100).div(
            _totalHoldersBalance
        );
        return holderPercentage;
    }

    function calculateAirdropPercentage(
        address _shareholder
    ) external view returns (uint256) {
        require(
            _shareholder != address(0x0),
            "shareholder address cannot be 0"
        );
        require(shareholderIndexes[_shareholder] > 0, "not a shareholder");

        uint256 holderBalance = IERC20(artikToken).balanceOf(_shareholder);
        require(
            holderBalance > 0,
            "shareholder balance must be greater than 0"
        );

        uint256 holders_balance = 0;
        if (totalHoldersBalance > 0) {
            holders_balance = totalHoldersBalance;
        } else {
            holders_balance = calculateTVL(true);
        }

        uint256 holderPercentage = calculateHolderPercentage(
            _shareholder,
            holders_balance
        );
        uint256 airdrop = accumulatedEthForAirdrop.mul(holderPercentage).div(
            100
        );

        require(airdrop > 0, "airdrop amount must be greater than 0");
        (uint256 airdropInArtik, ) = getAmountOutMin(airdrop, BNB, artikToken);

        // 100 : x = artik balance : airdrop in artik
        return airdropInArtik.mul(100).div(holderBalance);
    }

    function addShareHolder(address _shareholder) external onlyToken {
        require(_shareholder != address(0x0));

        if (shareholderIndexes[_shareholder] <= 0) {
            shareholders.push(_shareholder);
            shareholderCount = shareholderCount.add(1);
            shareholderIndexes[_shareholder] = shareholderCount;
        }
    }

    function removeShareHolder(address _shareholder) external onlyToken {
        require(_shareholder != address(0x0));

        if (shareholderIndexes[_shareholder] > 0) {
            shareholders[shareholderIndexes[_shareholder] - 1] = shareholders[
                shareholders.length - 1
            ];
            shareholders.pop();
            shareholderCount = shareholderCount.sub(1);
            shareholderIndexes[_shareholder] = 0;
        }
    }

    function swapETHForTokens(uint256 _amount, address _token) private {
        require(_amount > 0);
        require(_token != address(0x0));
        require(address(this).balance >= _amount, "balance less than _amount");

        address[] memory path = new address[](2);
        path[0] = BNB;
        path[1] = _token;

        dexRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{
            value: _amount
        }(0, path, address(this), block.timestamp);
    }

    function swapTokensForETH(uint256 _amount, address _token) private {
        require(_amount > 0);
        require(_token != address(0x0));
        require(
            IERC20(_token).balanceOf(address(this)) >= _amount,
            "balance less than _amount"
        );

        address[] memory path = new address[](2);
        path[0] = _token;
        path[1] = BNB;

        dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(
            _amount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

    function getAmountOutMin(
        uint256 _amount,
        address _tokenIn,
        address _tokenOut
    ) private view returns (uint256, address[] memory) {
        address[] memory path = new address[](2);
        path[0] = _tokenIn;
        path[1] = _tokenOut;

        uint256[] memory amountOutMins = dexRouter.getAmountsOut(_amount, path);
        return (amountOutMins[1], path);
    }

    function swapTokens() external onlyToken {
        uint256 buyBackFee = address(this).balance.mul(BUY_BACK_FEE).div(100);
        accumulatedEthForAirdrop = accumulatedEthForAirdrop
            .add(address(this).balance)
            .sub(buyBackFee);

        IERC20(BNB).approve(ROUTER, address(this).balance);
        swapETHForTokens(address(this).balance, STABLE_COIN);
    }

    function nextRound() public onlyAdmin {
        roundNumber = roundNumber.add(1);
    }

    function withdrawRemainingAirdrop(address _token) external onlyAdmin {
        require(_token != address(0x0));
        uint256 remainingBalance = IERC20(_token).balanceOf(address(this));
        require(remainingBalance > 0);
        IERC20(_token).transfer(admin, remainingBalance);
        emit WithdrawAirdropTokens(remainingBalance, _token);
    }

    function hasVotedProject(uint256 _projectId) external view returns (bool) {
        if (voters[msg.sender][_projectId] == roundNumber) {
            return true;
        } else {
            return false;
        }
    }

    receive() external payable {}
}


// File: /contracts/ArtikTreasuryV2.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "./interfaces/DexRouter.sol";

import "./libraries/ABDKMathQuad.sol";
import "./ProjectManager.sol";
import "./ArtikProjectManager.sol";
import "./ArtikStakeManager.sol";
import "./ArtikProjectManagerV2.sol";
import "./ArtikStakeManagerV2.sol";

contract ArtikTreasuryV2 is Initializable {
    using SafeMath for uint256;

    // Pancakeswap 0x10ED43C718714eb63d5aA57B78B54704E256024E (testnet: 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3)
    address constant ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
    // WBNB 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c (testnet: 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd)
    address constant WETH = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
    // BUSD 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56 (testnet: 0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7)
    address constant STABLE_COIN = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;

    uint256 private constant BUY_BACK_FEE = 25; //(2% of total fee)
    uint256 private accumulatedEthForAirdrop;

    DexRouter private dexRouter;

    address private artikToken;
    address payable private admin;

    address[] public shareholders;
    uint256 private shareholderCount;
    mapping(address => uint256) private shareholderIndexes;

    mapping(address => mapping(uint256 => bool)) private userClaimedProject;
    uint256 public totalAmountAirdropped;
    mapping(address => uint256) public amountClaimed;

    uint256 public airdropBalance;
    uint256 public totalHoldersBalance;
    uint256 public airdropDate;

    mapping(address => mapping(uint256 => mapping(uint256 => bool)))
        private userHasClaimedProject;

    mapping(uint256 => uint256) private airdropSnapshot;
    uint256 private stableCoinBalance;

    ProjectManager private projectManager; // to remove
    address private projectManagerAddress;

    mapping(address => uint256) public holderSellingDays;
    uint256 private holdingDays;

    ArtikProjectManager private artikProjectManager;
    ArtikStakeManager private artikStakeManager;
    mapping(uint256 => uint256) public airdropDates;

    ArtikProjectManagerV2 private artikProjectManagerV2;
    ArtikStakeManagerV2 private artikStakeManagerV2;

    modifier onlyAdmin() {
        require(
            msg.sender == admin ||
                msg.sender == artikToken ||
                msg.sender == projectManagerAddress
        );
        _;
    }

    function initialize(address _tokenAddress) public initializer {
        dexRouter = DexRouter(ROUTER);
        artikToken = _tokenAddress;
        admin = payable(msg.sender);
        shareholderCount = 0;
        totalAmountAirdropped = 0;
        accumulatedEthForAirdrop = 0;
        totalHoldersBalance = 0;
        airdropBalance = 0;
        stableCoinBalance = 0;
    }

    function configureManagers(
        address _projectManagerAddr,
        address _stakeManagerAddr
    ) external onlyAdmin {
        require(_projectManagerAddr != address(0x0));
        require(_stakeManagerAddr != address(0x0));
        projectManagerAddress = _projectManagerAddr;
        artikProjectManagerV2 = ArtikProjectManagerV2(_projectManagerAddr);
        artikStakeManagerV2 = ArtikStakeManagerV2(_stakeManagerAddr);
    }

    function getAirdropDate(
        uint256 _roundNumber
    ) external view returns (uint256) {
        require(_roundNumber > 0);
        return airdropDates[_roundNumber];
    }

    function setAirdropDate(uint256 _days) public onlyAdmin {
        require(_days > 0);
        airdropDates[artikProjectManagerV2.roundNumber()] =
            block.timestamp +
            (1 days * _days);
    }

    // Initialize airdrop
    // 1) approveAirdrop
    // 2) buyBack
    // 3) buyAirdropTokens
    // 4) initializeNextRound
    function approveAirdrop() external onlyAdmin {
        uint256 stableBalance = IERC20(STABLE_COIN).balanceOf(address(this));
        require(stableBalance > 0);

        IERC20(STABLE_COIN).approve(ROUTER, stableBalance);
        (uint256 amountWethMin, ) = getAmountOutMin(
            stableBalance,
            STABLE_COIN,
            WETH
        );
        IERC20(WETH).approve(ROUTER, amountWethMin);
    }

    function buyBack() external onlyAdmin {
        uint256 stableBalance = IERC20(STABLE_COIN).balanceOf(address(this));
        require(stableBalance > 0);

        swapTokensForETH(mulDiv(stableBalance, BUY_BACK_FEE, 100), STABLE_COIN);
        swapETHForTokens(address(this).balance, artikToken);
        IERC20(artikToken).transfer(
            address(0x0),
            IERC20(artikToken).balanceOf(address(this))
        );
    }

    function buyAirdropTokens(uint256 _amount) external onlyAdmin {
        require(_amount > 0);
        swapTokensForETH(_amount, STABLE_COIN);
        swapETHForTokens(
            address(this).balance,
            artikProjectManagerV2.getBestProject().tokenAddress
        );
    }

    function initializeNextRound(uint256 _days) external onlyAdmin {
        require(_days > 0);

        artikProjectManagerV2.nextRound();
        setAirdropDate(_days);
        airdropBalance = IERC20(
            artikProjectManagerV2.getBestProject().tokenAddress
        ).balanceOf(address(this));
    }

    // End Airdrop

    function claimAirdrop() public {
        uint256 airdrop = calculateAirdropAmount(msg.sender);

        IERC20(artikProjectManagerV2.getBestProject().tokenAddress).transfer(
            msg.sender,
            airdrop
        );

        artikProjectManagerV2.setVoter(msg.sender, false);
        userHasClaimedProject[msg.sender][artikProjectManagerV2.roundNumber()][
            artikProjectManagerV2.getBestProject().id
        ] = true;

        (uint256 amountWethMin, ) = getAmountOutMin(
            airdrop,
            artikProjectManagerV2.getBestProject().tokenAddress,
            WETH
        );
        (uint256 amountStableMin, ) = getAmountOutMin(
            amountWethMin,
            WETH,
            STABLE_COIN
        );

        amountClaimed[msg.sender] = amountClaimed[msg.sender].add(
            amountStableMin
        );
        totalAmountAirdropped = totalAmountAirdropped.add(amountStableMin);
    }

    function calculateTVL(uint256 _roundNumber) public view returns (uint256) {
        uint256 currentBalance = 0;
        address[] memory stakeholders = artikStakeManagerV2.getShareHolders();
        for (uint256 i = 0; i < stakeholders.length; i++) {
            currentBalance = currentBalance.add(
                artikStakeManagerV2.getStakedBalance(
                    stakeholders[i],
                    _roundNumber
                )
            );
        }
        return currentBalance;
    }

    function calculateAirdropAmount(
        address _shareholder
    ) public view returns (uint256) {
        uint256 _previousRoundNumber = artikProjectManagerV2.roundNumber() - 1;
        uint256 _currentRoundNumber = artikProjectManagerV2.roundNumber();

        require(
            artikProjectManagerV2.isShareholderVoter(_shareholder),
            "not a voter"
        );
        require(
            _shareholder != address(0x0),
            "shareholder cannot be address of 0"
        );

        require(calculateTVL(_previousRoundNumber) > 0, "tvl less than 0");
        require(
            userHasClaimedProject[_shareholder][_currentRoundNumber][
                artikProjectManagerV2.getBestProject().id
            ] != true,
            "shareholder has already claimed this airdrop"
        );

        uint256 airdropAmount = calculateAirdrop(
            _shareholder,
            calculateTVL(_previousRoundNumber),
            airdropBalance,
            artikProjectManagerV2.getBestProject().tokenAddress,
            _previousRoundNumber
        );

        (uint256 artkBestProjectBalance, ) = getAmountOutMin(
            airdropAmount,
            WETH,
            artikProjectManagerV2.getBestProject().tokenAddress
        );

        return artkBestProjectBalance;
    }

    function calculateHolderPercentage(
        address _shareholder,
        uint256 _tvl,
        uint256 _roundNumber
    ) private view returns (uint256) {
        // 100 : x = tvl : holderBalance
        uint256 holderBalance = artikStakeManagerV2.getStakedBalance(
            _shareholder,
            _roundNumber
        );
        return mulDiv(holderBalance, 1000000, _tvl);
    }

    function calculateExpectedAirdrop(
        address _shareholder
    ) external view returns (uint256) {
        require(
            _shareholder != address(0x0),
            "shareholder address cannot be 0"
        );

        uint256 currentRoundNumber = artikProjectManagerV2.roundNumber();
        uint256 holderBalance = artikStakeManagerV2.getStakedBalance(
            _shareholder,
            currentRoundNumber
        );
        require(
            holderBalance > 0,
            "shareholder balance must be greater than 0"
        );

        uint256 treasuryForAirdrop = mulDiv(
            IERC20(STABLE_COIN).balanceOf(address(this)),
            75,
            100
        );

        uint256 airdropAmount = calculateAirdrop(
            _shareholder,
            calculateTVL(currentRoundNumber),
            treasuryForAirdrop,
            STABLE_COIN,
            currentRoundNumber
        );

        (uint256 airdropBasedOnHoldingDays, ) = getAmountOutMin(
            airdropAmount,
            WETH,
            STABLE_COIN
        );
        return airdropBasedOnHoldingDays;
    }

    function calculateAirdrop(
        address _shareholder,
        uint256 _tvl,
        uint256 _airdropBalance,
        address _tokenToAirdrop,
        uint256 _roundNumber
    ) private view returns (uint256) {
        require(
            _shareholder != address(0x0),
            "shareholder address cannot be 0"
        );
        require(_tvl > 0, "tvl must be greater than 0");
        require(_airdropBalance > 0, "airdrop balance must be greater than 0");
        require(_tokenToAirdrop != address(0x0), "token address cannot be 0");
        require(_roundNumber > 0, "round number must be greater than 0");

        uint256 holderPercentage = calculateHolderPercentage(
            _shareholder,
            _tvl,
            _roundNumber
        );

        (uint256 wethAirdropBalance, ) = getAmountOutMin(
            _airdropBalance,
            _tokenToAirdrop,
            WETH
        );

        uint256 airdropBasedOnHoldingAmount = mulDiv(
            wethAirdropBalance,
            holderPercentage,
            1000000
        );

        uint256 stakingPercentageTime = artikStakeManagerV2
            .calculateStakingPercentageTime(_shareholder, _roundNumber);

        if (stakingPercentageTime > 0) {
            uint256 penality = mulDiv(
                airdropBasedOnHoldingAmount,
                stakingPercentageTime,
                1000000
            );

            airdropBasedOnHoldingAmount = airdropBasedOnHoldingAmount.sub(
                penality
            );
        }

        return airdropBasedOnHoldingAmount;
    }

    function swapETHForTokens(uint256 _amount, address _token) private {
        require(_amount > 0, "amount less than 0");
        require(_token != address(0x0), "address is not valid");
        require(address(this).balance >= _amount, "balance less than _amount");

        address[] memory path = new address[](2);
        path[0] = WETH;
        path[1] = _token;

        dexRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{
            value: _amount
        }(0, path, address(this), block.timestamp);
    }

    function swapTokensForETH(uint256 _amount, address _token) private {
        require(_amount > 0);
        require(_token != address(0x0));
        require(
            IERC20(_token).balanceOf(address(this)) >= _amount,
            "balance less than _amount"
        );

        address[] memory path = new address[](2);
        path[0] = _token;
        path[1] = WETH;

        dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(
            _amount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

    function getAmountOutMin(
        uint256 _amount,
        address _tokenIn,
        address _tokenOut
    ) private view returns (uint256, address[] memory) {
        address[] memory path = new address[](2);
        path[0] = _tokenIn;
        path[1] = _tokenOut;

        uint256[] memory amountOutMins = dexRouter.getAmountsOut(_amount, path);
        return (amountOutMins[1], path);
    }

    function swapTokens() external onlyAdmin {
        IERC20(WETH).approve(ROUTER, address(this).balance);
        swapETHForTokens(address(this).balance, STABLE_COIN);
    }

    function withdrawRemainingAirdrop(address _token) external onlyAdmin {
        require(_token != address(0x0));
        uint256 remainingBalance = IERC20(_token).balanceOf(address(this));
        totalAmountAirdropped = totalAmountAirdropped.add(remainingBalance);
        require(remainingBalance > 0);
        IERC20(_token).transfer(admin, remainingBalance);
    }

    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 z
    ) public pure returns (uint256) {
        return
            ABDKMathQuad.toUInt(
                ABDKMathQuad.div(
                    ABDKMathQuad.mul(
                        ABDKMathQuad.fromUInt(x),
                        ABDKMathQuad.fromUInt(y)
                    ),
                    ABDKMathQuad.fromUInt(z)
                )
            );
    }

    receive() external payable {}
}


// File: /contracts/ArtikTreasuryV1.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "./interfaces/DexRouter.sol";

import "./libraries/ABDKMathQuad.sol";
import "./ProjectManager.sol";
import "./ArtikProjectManager.sol";
import "./ArtikStakeManager.sol";
import "./ArtikProjectManagerV2.sol";
import "./ArtikStakeManagerV2.sol";
import "./ArtikStakeManagerV1.sol";
import "./ArtikProjectManagerV1.sol";

contract ArtikTreasuryV1 is Initializable {
    using SafeMath for uint256;

    // Pancakeswap 0x10ED43C718714eb63d5aA57B78B54704E256024E (testnet: 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3)
    address constant ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
    // WBNB 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c (testnet: 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd)
    address constant WETH = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
    // BUSD 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56 (testnet: 0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7)
    address constant STABLE_COIN = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;

    uint256 private constant BUY_BACK_FEE = 25; //(2% of total fee)
    uint256 private accumulatedEthForAirdrop;

    DexRouter private dexRouter;

    address private artikToken;
    address payable private admin;

    address[] public shareholders;
    uint256 private shareholderCount;
    mapping(address => uint256) private shareholderIndexes;

    mapping(address => mapping(uint256 => bool)) private userClaimedProject;
    uint256 public totalAmountAirdropped;
    mapping(address => uint256) public amountClaimed;

    uint256 public airdropBalance;
    uint256 public totalHoldersBalance;
    uint256 public airdropDate;

    mapping(address => mapping(uint256 => mapping(uint256 => bool)))
        private userHasClaimedProject;

    mapping(uint256 => uint256) private airdropSnapshot;
    uint256 private stableCoinBalance;

    ProjectManager private projectManager; // to remove
    address private projectManagerAddress;

    mapping(address => uint256) public holderSellingDays;
    uint256 private holdingDays;

    ArtikProjectManager private artikProjectManager;
    ArtikStakeManager private artikStakeManager;
    mapping(uint256 => uint256) public airdropDates;

    ArtikProjectManagerV2 private artikProjectManagerV2;
    ArtikStakeManagerV2 private artikStakeManagerV2;
    ArtikStakeManagerV1 private artikStakeManagerV1;
    ArtikProjectManagerV1 private artikProjectManagerV1;

    modifier onlyAdmin() {
        require(
            msg.sender == admin ||
                msg.sender == artikToken ||
                msg.sender == projectManagerAddress
        );
        _;
    }

    function initialize(address _tokenAddress) public initializer {
        dexRouter = DexRouter(ROUTER);
        artikToken = _tokenAddress;
        admin = payable(msg.sender);
        shareholderCount = 0;
        totalAmountAirdropped = 0;
        accumulatedEthForAirdrop = 0;
        totalHoldersBalance = 0;
        airdropBalance = 0;
        stableCoinBalance = 0;
    }

    function configureManagers(
        address _projectManagerAddr,
        address _stakeManagerAddr
    ) external onlyAdmin {
        require(_projectManagerAddr != address(0x0));
        require(_stakeManagerAddr != address(0x0));
        projectManagerAddress = _projectManagerAddr;
        artikProjectManagerV1 = ArtikProjectManagerV1(_projectManagerAddr);
        artikStakeManagerV1 = ArtikStakeManagerV1(_stakeManagerAddr);
    }

    function getAirdropDate(
        uint256 _roundNumber
    ) external view returns (uint256) {
        require(_roundNumber > 0);
        return airdropDates[_roundNumber];
    }

    function setAirdropDate(uint256 _days) public onlyAdmin {
        require(_days > 0);
        airdropDates[artikProjectManagerV1.roundNumber()] =
            block.timestamp +
            (1 days * _days);
    }

    // Initialize airdrop
    // 1) approveAirdrop
    // 2) buyBack
    // 3) buyAirdropTokens
    // 4) initializeNextRound
    function approveAirdrop() external onlyAdmin {
        uint256 stableBalance = IERC20(STABLE_COIN).balanceOf(address(this));
        require(stableBalance > 0);

        IERC20(STABLE_COIN).approve(ROUTER, stableBalance);
        (uint256 amountWethMin, ) = getAmountOutMin(
            stableBalance,
            STABLE_COIN,
            WETH
        );
        IERC20(WETH).approve(ROUTER, amountWethMin);
    }

    function buyBack() external onlyAdmin {
        uint256 stableBalance = IERC20(STABLE_COIN).balanceOf(address(this));
        require(stableBalance > 0);

        swapTokensForETH(mulDiv(stableBalance, BUY_BACK_FEE, 100), STABLE_COIN);
        swapETHForTokens(address(this).balance, artikToken);
        IERC20(artikToken).transfer(
            address(0x0),
            IERC20(artikToken).balanceOf(address(this))
        );
    }

    function buyAirdropTokens(
        uint256 _amount,
        address _token1,
        address _token2
    ) external onlyAdmin {
        require(_amount > 0);
        require(_token1 != address(0x0));
        require(_token2 != address(0x0));
        require(
            IERC20(_token1).balanceOf(address(this)) >= _amount,
            "balance less than _amount"
        );

        address[] memory path = new address[](2);
        path[0] = _token1;
        path[1] = _token2;

        dexRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            _amount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

    function initializeNextRound(uint256 _days) external onlyAdmin {
        require(_days > 0);

        artikProjectManagerV1.nextRound();
        setAirdropDate(_days);
        airdropBalance = IERC20(
            artikProjectManagerV1.getBestProject().tokenAddress
        ).balanceOf(address(this));
    }

    // End Airdrop

    function claimAirdrop() public {
        uint256 airdrop = calculateAirdropAmount(msg.sender);

        IERC20(artikProjectManagerV1.getBestProject().tokenAddress).transfer(
            msg.sender,
            airdrop
        );

        artikProjectManagerV1.setVoter(msg.sender, false);
        userHasClaimedProject[msg.sender][artikProjectManagerV1.roundNumber()][
            artikProjectManagerV1.getBestProject().id
        ] = true;
    }

    function calculateTVL(uint256 _roundNumber) public view returns (uint256) {
        uint256 currentBalance = 0;
        address[] memory stakeholders = artikStakeManagerV1.getShareHolders();
        for (uint256 i = 0; i < stakeholders.length; i++) {
            currentBalance = currentBalance.add(
                artikStakeManagerV1.getStakedBalance(
                    stakeholders[i],
                    _roundNumber
                )
            );
        }
        return currentBalance;
    }

    function calculateAirdropAmount(
        address _shareholder
    ) public view returns (uint256) {
        uint256 _previousRoundNumber = artikProjectManagerV1.roundNumber() - 1;
        uint256 _currentRoundNumber = artikProjectManagerV1.roundNumber();
        uint256 tvl = calculateTVL(_previousRoundNumber);

        require(
            artikProjectManagerV1.isShareholderVoter(_shareholder),
            "not a voter"
        );
        require(
            _shareholder != address(0x0),
            "shareholder cannot be address of 0"
        );

        require(tvl > 0, "tvl less than 0");
        require(
            userHasClaimedProject[_shareholder][_currentRoundNumber][
                artikProjectManagerV1.getBestProject().id
            ] != true,
            "shareholder has already claimed this airdrop"
        );

        return
            calculateAirdrop(
                _shareholder,
                tvl,
                airdropBalance,
                artikProjectManagerV1.getBestProject().tokenAddress,
                _previousRoundNumber
            );
    }

    function calculateHolderPercentage(
        address _shareholder,
        uint256 _tvl,
        uint256 _roundNumber
    ) private view returns (uint256) {
        // 100 : x = tvl : holderBalance
        uint256 holderBalance = artikStakeManagerV1.getStakedBalance(
            _shareholder,
            _roundNumber
        );
        return mulDiv(holderBalance, 1000000, _tvl);
    }

    function calculateExpectedAirdrop(
        address _shareholder
    ) external view returns (uint256) {
        require(
            _shareholder != address(0x0),
            "shareholder address cannot be 0"
        );

        uint256 currentRoundNumber = artikProjectManagerV1.roundNumber();
        uint256 holderBalance = artikStakeManagerV1.getStakedBalance(
            _shareholder,
            currentRoundNumber
        );
        require(
            holderBalance > 0,
            "shareholder balance must be greater than 0"
        );

        uint256 treasuryForAirdrop = mulDiv(
            IERC20(STABLE_COIN).balanceOf(address(this)),
            75,
            100
        );

        return
            calculateAirdrop(
                _shareholder,
                calculateTVL(currentRoundNumber),
                treasuryForAirdrop,
                STABLE_COIN,
                currentRoundNumber
            );
    }

    function calculateAirdrop(
        address _shareholder,
        uint256 _tvl,
        uint256 _airdropBalance,
        address _tokenToAirdrop,
        uint256 _roundNumber
    ) private view returns (uint256) {
        require(
            _shareholder != address(0x0),
            "shareholder address cannot be 0"
        );
        require(_tvl > 0, "tvl must be greater than 0");
        require(_airdropBalance > 0, "airdrop balance must be greater than 0");
        require(_tokenToAirdrop != address(0x0), "token address cannot be 0");
        require(_roundNumber > 0, "round number must be greater than 0");

        uint256 holderPercentage = calculateHolderPercentage(
            _shareholder,
            _tvl,
            _roundNumber
        );

        uint256 airdropBasedOnHoldingAmount = mulDiv(
            _airdropBalance,
            holderPercentage,
            1000000
        );

        uint256 stakingPercentageTime = artikStakeManagerV1
            .calculateStakingPercentageTime(_shareholder, _roundNumber);

        return
            mulDiv(airdropBasedOnHoldingAmount, stakingPercentageTime, 1000000);
    }

    function swapETHForTokens(uint256 _amount, address _token) private {
        require(_amount > 0, "amount less than 0");
        require(_token != address(0x0), "address is not valid");
        require(address(this).balance >= _amount, "balance less than _amount");

        address[] memory path = new address[](2);
        path[0] = WETH;
        path[1] = _token;

        dexRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{
            value: _amount
        }(0, path, address(this), block.timestamp);
    }

    function swapTokensForETH(uint256 _amount, address _token) private {
        require(_amount > 0);
        require(_token != address(0x0));
        require(
            IERC20(_token).balanceOf(address(this)) >= _amount,
            "balance less than _amount"
        );

        address[] memory path = new address[](2);
        path[0] = _token;
        path[1] = WETH;

        dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(
            _amount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

    function getAmountOutMin(
        uint256 _amount,
        address _tokenIn,
        address _tokenOut
    ) private view returns (uint256, address[] memory) {
        address[] memory path = new address[](2);
        path[0] = _tokenIn;
        path[1] = _tokenOut;

        uint256[] memory amountOutMins = dexRouter.getAmountsOut(_amount, path);
        return (amountOutMins[1], path);
    }

    function swapTokens() external onlyAdmin {
        IERC20(WETH).approve(ROUTER, address(this).balance);
        swapETHForTokens(address(this).balance, STABLE_COIN);
    }

    function withdraw(address _token) external onlyAdmin {
        require(_token != address(0x0));
        uint256 remainingBalance = IERC20(_token).balanceOf(address(this));
        require(remainingBalance > 0);
        IERC20(_token).transfer(admin, remainingBalance);
    }

    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 z
    ) public pure returns (uint256) {
        return
            ABDKMathQuad.toUInt(
                ABDKMathQuad.div(
                    ABDKMathQuad.mul(
                        ABDKMathQuad.fromUInt(x),
                        ABDKMathQuad.fromUInt(y)
                    ),
                    ABDKMathQuad.fromUInt(z)
                )
            );
    }

    receive() external payable {}
}


// File: /contracts/ArtikTreasury.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "./interfaces/DexRouter.sol";

import "./libraries/ABDKMathQuad.sol";
import "./ProjectManager.sol";
import "./ArtikProjectManager.sol";
import "./ArtikStakeManager.sol";

contract ArtikTreasury is Initializable {
    using SafeMath for uint256;

    // Pancakeswap 0x10ED43C718714eb63d5aA57B78B54704E256024E (testnet: 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3)
    address constant ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
    // WBNB 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c (testnet: 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd)
    address constant WETH = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
    // BUSD 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56 (testnet: 0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7)
    address constant STABLE_COIN = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;

    uint256 private constant BUY_BACK_FEE = 25; //(2% of total fee)
    uint256 private accumulatedEthForAirdrop;

    DexRouter private dexRouter;

    address private artikToken;
    address payable private admin;

    address[] public shareholders;
    uint256 private shareholderCount;
    mapping(address => uint256) private shareholderIndexes;

    mapping(address => mapping(uint256 => bool)) private userClaimedProject;
    uint256 public totalAmountAirdropped;
    mapping(address => uint256) public amountClaimed;

    uint256 public airdropBalance;
    uint256 public totalHoldersBalance;
    uint256 public airdropDate;

    mapping(address => mapping(uint256 => mapping(uint256 => bool)))
        private userHasClaimedProject;

    mapping(uint256 => uint256) private airdropSnapshot;
    uint256 private stableCoinBalance;

    ProjectManager private projectManager; // to remove
    address private projectManagerAddress;

    mapping(address => uint256) public holderSellingDays;
    uint256 private holdingDays;

    ArtikProjectManager private artikProjectManager;
    ArtikStakeManager private artikStakeManager;
    mapping(uint256 => uint256) public airdropDates;

    modifier onlyAdmin() {
        require(
            msg.sender == admin ||
                msg.sender == artikToken ||
                msg.sender == projectManagerAddress
        );
        _;
    }

    function initialize(address _tokenAddress) public initializer {
        dexRouter = DexRouter(ROUTER);
        artikToken = _tokenAddress;
        admin = payable(msg.sender);
        shareholderCount = 0;
        totalAmountAirdropped = 0;
        accumulatedEthForAirdrop = 0;
        totalHoldersBalance = 0;
        airdropBalance = 0;
        stableCoinBalance = 0;
    }

    function configureManagers(
        address _projectManagerAddr,
        address _stakeManagerAddr
    ) external onlyAdmin {
        require(_projectManagerAddr != address(0x0));
        require(_stakeManagerAddr != address(0x0));
        projectManagerAddress = _projectManagerAddr;
        artikProjectManager = ArtikProjectManager(_projectManagerAddr);
        artikStakeManager = ArtikStakeManager(_stakeManagerAddr);
    }

    function getAirdropDate(
        uint256 _roundNumber
    ) external view returns (uint256) {
        require(_roundNumber > 0);
        return airdropDates[_roundNumber];
    }

    function setAirdropDate(uint256 _days) public onlyAdmin {
        require(_days > 0);
        airdropDates[artikProjectManager.roundNumber()] =
            block.timestamp +
            (1 days * _days);
    }

    // Initialize airdrop
    // 1) approveAirdrop
    // 2) buyBack
    // 3) buyAirdropTokens
    // 4) initializeNextRound
    function approveAirdrop() external onlyAdmin {
        uint256 stableBalance = IERC20(STABLE_COIN).balanceOf(address(this));
        require(stableBalance > 0);

        IERC20(STABLE_COIN).approve(ROUTER, stableBalance);
        (uint256 amountWethMin, ) = getAmountOutMin(
            stableBalance,
            STABLE_COIN,
            WETH
        );
        IERC20(WETH).approve(ROUTER, amountWethMin);
    }

    function buyBack() external onlyAdmin {
        uint256 stableBalance = IERC20(STABLE_COIN).balanceOf(address(this));
        require(stableBalance > 0);

        swapTokensForETH(mulDiv(stableBalance, BUY_BACK_FEE, 100), STABLE_COIN);
        swapETHForTokens(address(this).balance, artikToken);
        IERC20(artikToken).transfer(
            address(0x0),
            IERC20(artikToken).balanceOf(address(this))
        );
    }

    function buyAirdropTokens(uint256 _amount) external onlyAdmin {
        require(_amount > 0);
        swapTokensForETH(_amount, STABLE_COIN);
        swapETHForTokens(
            address(this).balance,
            artikProjectManager.getBestProject().tokenAddress
        );
    }

    function initializeNextRound(uint256 _days) external onlyAdmin {
        require(_days > 0);

        artikProjectManager.nextRound();
        setAirdropDate(_days);
        airdropBalance = IERC20(
            artikProjectManager.getBestProject().tokenAddress
        ).balanceOf(address(this));
    }

    // End Airdrop

    function claimAirdrop() public {
        uint256 airdrop = calculateAirdropAmount(msg.sender);

        IERC20(artikProjectManager.getBestProject().tokenAddress).transfer(
            msg.sender,
            airdrop
        );

        artikProjectManager.setVoter(msg.sender, false);
        userHasClaimedProject[msg.sender][artikProjectManager.roundNumber()][
            artikProjectManager.getBestProject().id
        ] = true;

        (uint256 amountWethMin, ) = getAmountOutMin(
            airdrop,
            artikProjectManager.getBestProject().tokenAddress,
            WETH
        );
        (uint256 amountStableMin, ) = getAmountOutMin(
            amountWethMin,
            WETH,
            STABLE_COIN
        );

        amountClaimed[msg.sender] = amountClaimed[msg.sender].add(
            amountStableMin
        );
        totalAmountAirdropped = totalAmountAirdropped.add(amountStableMin);
    }

    function calculateTVL(uint256 _roundNumber) public view returns (uint256) {
        uint256 currentBalance = 0;
        address[] memory stakeholders = artikStakeManager.getShareHolders();
        for (uint256 i = 0; i < stakeholders.length; i++) {
            currentBalance = currentBalance.add(
                artikStakeManager.getStakedBalance(
                    stakeholders[i],
                    _roundNumber
                )
            );
        }
        return currentBalance;
    }

    function calculateAirdropAmount(
        address _shareholder
    ) public view returns (uint256) {
        uint256 _previousRoundNumber = artikProjectManager.roundNumber() - 1;
        uint256 _currentRoundNumber = artikProjectManager.roundNumber();

        require(
            artikProjectManager.isShareholderVoter(_shareholder),
            "not a voter"
        );
        require(
            _shareholder != address(0x0),
            "shareholder cannot be address of 0"
        );

        require(calculateTVL(_previousRoundNumber) > 0, "tvl less than 0");
        require(
            userHasClaimedProject[_shareholder][_currentRoundNumber][
                artikProjectManager.getBestProject().id
            ] != true,
            "shareholder has already claimed this airdrop"
        );

        uint256 airdropAmount = calculateAirdrop(
            _shareholder,
            calculateTVL(_previousRoundNumber),
            airdropBalance,
            artikProjectManager.getBestProject().tokenAddress,
            _previousRoundNumber
        );

        (uint256 artkBestProjectBalance, ) = getAmountOutMin(
            airdropAmount,
            WETH,
            artikProjectManager.getBestProject().tokenAddress
        );

        return artkBestProjectBalance;
    }

    function calculateHolderPercentage(
        address _shareholder,
        uint256 _tvl,
        uint256 _roundNumber
    ) private view returns (uint256) {
        // 100 : x = tvl : holderBalance
        uint256 holderBalance = artikStakeManager.getStakedBalance(
            _shareholder,
            _roundNumber
        );
        return mulDiv(holderBalance, 1000000, _tvl);
    }

    function calculateExpectedAirdrop(
        address _shareholder
    ) external view returns (uint256) {
        require(
            _shareholder != address(0x0),
            "shareholder address cannot be 0"
        );

        uint256 currentRoundNumber = artikProjectManager.roundNumber();
        uint256 holderBalance = artikStakeManager.getStakedBalance(
            _shareholder,
            currentRoundNumber
        );
        require(
            holderBalance > 0,
            "shareholder balance must be greater than 0"
        );

        uint256 treasuryForAirdrop = mulDiv(
            IERC20(STABLE_COIN).balanceOf(address(this)),
            75,
            100
        );

        uint256 airdropAmount = calculateAirdrop(
            _shareholder,
            calculateTVL(currentRoundNumber),
            treasuryForAirdrop,
            STABLE_COIN,
            currentRoundNumber
        );

        (uint256 airdropBasedOnHoldingDays, ) = getAmountOutMin(
            airdropAmount,
            WETH,
            STABLE_COIN
        );
        return airdropBasedOnHoldingDays;
    }

    function calculateAirdrop(
        address _shareholder,
        uint256 _tvl,
        uint256 _airdropBalance,
        address _tokenToAirdrop,
        uint256 _roundNumber
    ) private view returns (uint256) {
        require(
            _shareholder != address(0x0),
            "shareholder address cannot be 0"
        );
        require(_tvl > 0, "tvl must be greater than 0");
        require(_airdropBalance > 0, "airdrop balance must be greater than 0");
        require(_tokenToAirdrop != address(0x0), "token address cannot be 0");
        require(_roundNumber > 0, "round number must be greater than 0");

        uint256 holderPercentage = calculateHolderPercentage(
            _shareholder,
            _tvl,
            _roundNumber
        );

        (uint256 wethAirdropBalance, ) = getAmountOutMin(
            _airdropBalance,
            _tokenToAirdrop,
            WETH
        );

        uint256 airdropBasedOnHoldingAmount = mulDiv(
            wethAirdropBalance,
            holderPercentage,
            1000000
        );

        uint256 stakingPercentageTime = artikStakeManager
            .calculateStakingPercentageTime(_shareholder, _roundNumber);

        if (stakingPercentageTime > 0) {
            uint256 penality = mulDiv(
                airdropBasedOnHoldingAmount,
                stakingPercentageTime,
                1000000
            );

            airdropBasedOnHoldingAmount = airdropBasedOnHoldingAmount.sub(
                penality
            );
        }

        return airdropBasedOnHoldingAmount;
    }

    function swapETHForTokens(uint256 _amount, address _token) private {
        require(_amount > 0, "amount less than 0");
        require(_token != address(0x0), "address is not valid");
        require(address(this).balance >= _amount, "balance less than _amount");

        address[] memory path = new address[](2);
        path[0] = WETH;
        path[1] = _token;

        dexRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{
            value: _amount
        }(0, path, address(this), block.timestamp);
    }

    function swapTokensForETH(uint256 _amount, address _token) private {
        require(_amount > 0);
        require(_token != address(0x0));
        require(
            IERC20(_token).balanceOf(address(this)) >= _amount,
            "balance less than _amount"
        );

        address[] memory path = new address[](2);
        path[0] = _token;
        path[1] = WETH;

        dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(
            _amount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

    function getAmountOutMin(
        uint256 _amount,
        address _tokenIn,
        address _tokenOut
    ) private view returns (uint256, address[] memory) {
        address[] memory path = new address[](2);
        path[0] = _tokenIn;
        path[1] = _tokenOut;

        uint256[] memory amountOutMins = dexRouter.getAmountsOut(_amount, path);
        return (amountOutMins[1], path);
    }

    function swapTokens() external onlyAdmin {
        IERC20(WETH).approve(ROUTER, address(this).balance);
        swapETHForTokens(address(this).balance, STABLE_COIN);
    }

    function withdrawRemainingAirdrop(address _token) external onlyAdmin {
        require(_token != address(0x0));
        uint256 remainingBalance = IERC20(_token).balanceOf(address(this));
        totalAmountAirdropped = totalAmountAirdropped.add(remainingBalance);
        require(remainingBalance > 0);
        IERC20(_token).transfer(admin, remainingBalance);
    }

    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 z
    ) public pure returns (uint256) {
        return
            ABDKMathQuad.toUInt(
                ABDKMathQuad.div(
                    ABDKMathQuad.mul(
                        ABDKMathQuad.fromUInt(x),
                        ABDKMathQuad.fromUInt(y)
                    ),
                    ABDKMathQuad.fromUInt(z)
                )
            );
    }

    receive() external payable {}
}


// File: /contracts/ArtikStakeManagerV2.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "./libraries/ABDKMathQuad.sol";

import "./ArtikTreasury.sol";
import "./ArtikProjectManager.sol";
import "./ArtikProjectManagerV2.sol";
import "./ArtikTreasuryV2.sol";

contract ArtikStakeManagerV2 is Initializable {
    using SafeMath for uint256;

    address private artikToken;
    address payable private admin;

    ArtikTreasury private treasury;
    ArtikProjectManager private artikProjectManager;

    mapping(address => mapping(uint256 => Stake)) private stakedBalance;
    struct Stake {
        uint256 balance;
        uint256 time;
        bool staked;
    }

    address[] public shareholders;
    mapping(address => uint256) private shareholderIndexes;
    uint256 private shareholderCount;

    bool public penaltyIsActive;
    ArtikProjectManagerV2 private artikProjectManagerV2;
    ArtikTreasuryV2 private artikTreasuryV2;

    function initialize(
        address _tokenAddress,
        address _treasuryAddress,
        address _projectManagerAddr
    ) public initializer {
        artikToken = _tokenAddress;
        artikTreasuryV2 = ArtikTreasuryV2(payable(_treasuryAddress));
        artikProjectManagerV2 = ArtikProjectManagerV2(_projectManagerAddr);

        shareholderCount = 0;
        admin = payable(msg.sender);

        penaltyIsActive = true;
    }

    function configureManagers(
        address _projectManagerAddr,
        address _treasuryAddr
    ) external {
        require(msg.sender == admin);
        artikProjectManagerV2 = ArtikProjectManagerV2(_projectManagerAddr);
        artikTreasuryV2 = ArtikTreasuryV2(payable(_treasuryAddr));
    }

    function managePenalty(bool _active) external {
        require(msg.sender == admin);
        penaltyIsActive = _active;
    }

    function getStakedBalance(
        address _shareholder,
        uint256 _roundNumber
    ) external view returns (uint256) {
        require(_shareholder != address(0x0));
        require(_roundNumber > 0);
        return stakedBalance[_shareholder][_roundNumber].balance;
    }

    function calculateStakingPercentageTime(
        address _shareholder,
        uint256 _roundNumber
    ) external view returns (uint256) {
        require(_shareholder != address(0x0));
        require(_roundNumber > 0);

        uint256 diff = (artikTreasuryV2.getAirdropDate(_roundNumber) -
            /*stakedBalance[_shareholder].time) /
            60 /
            60 /
            24;*/
            stakedBalance[_shareholder][_roundNumber].time);

        uint256 percentage = 0;
        if (diff > 0 && penaltyIsActive) {
            percentage = mulDiv(diff, 1000000, 7 * 60 * 60 * 24);
        }
        return percentage;
    }

    function movePreviousStakes() external {
        require(shareholderIndexes[msg.sender] > 0, "not a stakeholder");

        uint256 currentRoundNumber = artikProjectManagerV2.roundNumber();

        for (uint256 i = 1; i <= currentRoundNumber - 1; i++) {
            if (stakedBalance[msg.sender][i].balance > 0) {
                addStakeHolder(
                    msg.sender,
                    stakedBalance[msg.sender][i].balance
                );
                stakedBalance[msg.sender][i].balance = 0;
            }
        }
    }

    function unstakeTokens(uint256 _amount) external {
        require(_amount > 0);

        uint256 currentRoundNumber = artikProjectManagerV2.roundNumber();
        require(
            _amount <= stakedBalance[msg.sender][currentRoundNumber].balance
        );
        require(stakedBalance[msg.sender][currentRoundNumber].balance > 0);

        stakedBalance[msg.sender][currentRoundNumber].balance = stakedBalance[
            msg.sender
        ][currentRoundNumber].balance.sub(_amount);

        stakedBalance[msg.sender][currentRoundNumber].time = block.timestamp;

        uint256 totalStakedAmount = 0;
        for (uint256 i = 1; i < currentRoundNumber; i++) {
            totalStakedAmount = totalStakedAmount.add(
                stakedBalance[msg.sender][i].balance
            );
        }

        if (totalStakedAmount <= 0) {
            removeShareHolder(msg.sender);
        }

        IERC20(artikToken).transfer(msg.sender, _amount);
    }

    function addStakeHolder(address _stakeholder, uint256 _amount) private {
        require(_amount > 0, "amount less than 0");
        require(_stakeholder != address(0x0));

        uint256 currentRoundNumber = artikProjectManagerV2.roundNumber();
        if (!stakedBalance[_stakeholder][currentRoundNumber].staked) {
            stakedBalance[_stakeholder][currentRoundNumber] = Stake(
                _amount,
                block.timestamp,
                true
            );
        } else {
            stakedBalance[_stakeholder][currentRoundNumber]
                .balance = stakedBalance[_stakeholder][currentRoundNumber]
                .balance
                .add(_amount);
            stakedBalance[_stakeholder][currentRoundNumber].time = block
                .timestamp;
        }

        addShareHolder(_stakeholder);
    }

    function stakeTokens(uint256 _amount) external {
        require(
            _amount <= IERC20(artikToken).balanceOf(msg.sender),
            "amount greater than balance"
        );
        addStakeHolder(msg.sender, _amount);
        IERC20(artikToken).transferFrom(msg.sender, address(this), _amount);
    }

    function addShareHolder(address _shareholder) private {
        require(_shareholder != address(0x0));

        if (shareholderIndexes[_shareholder] <= 0) {
            shareholders.push(_shareholder);
            shareholderCount = shareholderCount.add(1);
            shareholderIndexes[_shareholder] = shareholderCount;
        }
    }

    function removeShareHolder(address _shareholder) private {
        require(_shareholder != address(0x0));

        if (shareholderIndexes[_shareholder] > 0) {
            shareholders[shareholderIndexes[_shareholder] - 1] = shareholders[
                shareholders.length - 1
            ];
            shareholders.pop();
            shareholderCount = shareholderCount.sub(1);
            shareholderIndexes[_shareholder] = 0;
        }
    }

    function getShareHolders() external view returns (address[] memory) {
        return shareholders;
    }

    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 z
    ) public pure returns (uint256) {
        return
            ABDKMathQuad.toUInt(
                ABDKMathQuad.div(
                    ABDKMathQuad.mul(
                        ABDKMathQuad.fromUInt(x),
                        ABDKMathQuad.fromUInt(y)
                    ),
                    ABDKMathQuad.fromUInt(z)
                )
            );
    }
}


// File: /contracts/ArtikStakeManagerV1.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "./libraries/ABDKMathQuad.sol";

import "./ArtikTreasury.sol";
import "./ArtikProjectManager.sol";
import "./ArtikProjectManagerV2.sol";
import "./ArtikTreasuryV2.sol";
import "./ArtikTreasuryV1.sol";
import "./ArtikProjectManagerV1.sol";

contract ArtikStakeManagerV1 is Initializable {
    using SafeMath for uint256;

    address private artikToken;
    address payable private admin;

    ArtikTreasury private treasury;
    ArtikProjectManager private artikProjectManager;

    mapping(address => mapping(uint256 => Stake)) private stakedBalance;
    struct Stake {
        uint256 balance;
        uint256 time;
        bool staked;
    }

    address[] public shareholders;
    mapping(address => uint256) private shareholderIndexes;
    uint256 private shareholderCount;

    bool public penaltyIsActive;
    ArtikProjectManagerV2 private artikProjectManagerV2;
    ArtikTreasuryV2 private artikTreasuryV2;
    ArtikTreasuryV1 private artikTreasuryV1;
    ArtikProjectManagerV1 private artikProjectManagerV1;

    function initialize(
        address _tokenAddress,
        address _treasuryAddress,
        address _projectManagerAddr
    ) public initializer {
        artikToken = _tokenAddress;
        artikTreasuryV1 = ArtikTreasuryV1(payable(_treasuryAddress));
        artikProjectManagerV1 = ArtikProjectManagerV1(_projectManagerAddr);

        shareholderCount = 0;
        admin = payable(msg.sender);

        penaltyIsActive = true;
    }

    function configureManagers(
        address _projectManagerAddr,
        address _treasuryAddr
    ) external {
        require(msg.sender == admin);
        artikProjectManagerV1 = ArtikProjectManagerV1(_projectManagerAddr);
        artikTreasuryV1 = ArtikTreasuryV1(payable(_treasuryAddr));
    }

    function managePenalty(bool _active) external {
        require(msg.sender == admin);
        penaltyIsActive = _active;
    }

    function getStakedBalance(
        address _shareholder,
        uint256 _roundNumber
    ) external view returns (uint256) {
        require(_shareholder != address(0x0));
        require(_roundNumber > 0);
        return stakedBalance[_shareholder][_roundNumber].balance;
    }

    function calculateStakingPercentageTime(
        address _shareholder,
        uint256 _roundNumber
    ) external view returns (uint256) {
        require(_shareholder != address(0x0));
        require(_roundNumber > 0);

        uint256 diff = (artikTreasuryV1.getAirdropDate(_roundNumber) -
            /*stakedBalance[_shareholder].time) /
            60 /
            60 /
            24;*/
            stakedBalance[_shareholder][_roundNumber].time);

        uint256 percentage = 100;
        if (penaltyIsActive) {
            if (diff >= 7 * 60 * 60 * 24) {
                percentage = 100;
            } else {
                percentage = mulDiv(diff, 1000000, 7 * 60 * 60 * 24);
            }
        }
        return percentage;
    }

    function movePreviousStakes() external {
        require(shareholderIndexes[msg.sender] > 0, "not a stakeholder");

        uint256 currentRoundNumber = artikProjectManagerV1.roundNumber();

        for (uint256 i = 1; i <= currentRoundNumber - 1; i++) {
            if (stakedBalance[msg.sender][i].balance > 0) {
                addStakeHolder(
                    msg.sender,
                    stakedBalance[msg.sender][i].balance,
                    stakedBalance[msg.sender][i].time
                );
                stakedBalance[msg.sender][i].balance = 0;
            }
        }
    }

    function unstakeTokens(uint256 _amount) external {
        require(_amount > 0);

        uint256 currentRoundNumber = artikProjectManagerV1.roundNumber();
        require(
            _amount <= stakedBalance[msg.sender][currentRoundNumber].balance
        );
        require(stakedBalance[msg.sender][currentRoundNumber].balance > 0);

        stakedBalance[msg.sender][currentRoundNumber].balance = stakedBalance[
            msg.sender
        ][currentRoundNumber].balance.sub(_amount);

        stakedBalance[msg.sender][currentRoundNumber].time = block.timestamp;

        uint256 totalStakedAmount = 0;
        for (uint256 i = 1; i < currentRoundNumber; i++) {
            totalStakedAmount = totalStakedAmount.add(
                stakedBalance[msg.sender][i].balance
            );
        }

        if (totalStakedAmount <= 0) {
            removeShareHolder(msg.sender);
        }

        IERC20(artikToken).transfer(msg.sender, _amount);
    }

    function addStakeHolder(
        address _stakeholder,
        uint256 _amount,
        uint256 _timestamp
    ) private {
        require(_amount > 0, "amount less than 0");
        require(_stakeholder != address(0x0));

        uint256 currentRoundNumber = artikProjectManagerV1.roundNumber();
        if (!stakedBalance[_stakeholder][currentRoundNumber].staked) {
            stakedBalance[_stakeholder][currentRoundNumber] = Stake(
                _amount,
                _timestamp,
                true
            );
        } else {
            stakedBalance[_stakeholder][currentRoundNumber]
                .balance = stakedBalance[_stakeholder][currentRoundNumber]
                .balance
                .add(_amount);
            stakedBalance[_stakeholder][currentRoundNumber].time = _timestamp;
        }

        addShareHolder(_stakeholder);
    }

    function stakeTokens(uint256 _amount) external {
        require(
            _amount <= IERC20(artikToken).balanceOf(msg.sender),
            "amount greater than balance"
        );
        addStakeHolder(msg.sender, _amount, block.timestamp);
        IERC20(artikToken).transferFrom(msg.sender, address(this), _amount);
    }

    function addShareHolder(address _shareholder) private {
        require(_shareholder != address(0x0));

        if (shareholderIndexes[_shareholder] <= 0) {
            shareholders.push(_shareholder);
            shareholderCount = shareholderCount.add(1);
            shareholderIndexes[_shareholder] = shareholderCount;
        }
    }

    function removeShareHolder(address _shareholder) private {
        require(_shareholder != address(0x0));

        if (shareholderIndexes[_shareholder] > 0) {
            shareholders[shareholderIndexes[_shareholder] - 1] = shareholders[
                shareholders.length - 1
            ];
            shareholders.pop();
            shareholderCount = shareholderCount.sub(1);
            shareholderIndexes[_shareholder] = 0;
        }
    }

    function getShareHolders() external view returns (address[] memory) {
        return shareholders;
    }

    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 z
    ) public pure returns (uint256) {
        return
            ABDKMathQuad.toUInt(
                ABDKMathQuad.div(
                    ABDKMathQuad.mul(
                        ABDKMathQuad.fromUInt(x),
                        ABDKMathQuad.fromUInt(y)
                    ),
                    ABDKMathQuad.fromUInt(z)
                )
            );
    }
}


// File: /contracts/ArtikStakeManager.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "./libraries/ABDKMathQuad.sol";

import "./ArtikTreasury.sol";
import "./ArtikProjectManager.sol";

contract ArtikStakeManager is Initializable {
    using SafeMath for uint256;

    address private artikToken;
    address payable private admin;

    ArtikTreasury private treasury;
    ArtikProjectManager private artikProjectManager;

    mapping(address => mapping(uint256 => Stake)) private stakedBalance;
    struct Stake {
        uint256 balance;
        uint256 time;
        bool staked;
    }

    address[] public shareholders;
    mapping(address => uint256) private shareholderIndexes;
    uint256 private shareholderCount;

    bool public penaltyIsActive;

    function initialize(
        address _tokenAddress,
        address _treasuryAddress,
        address _projectManagerAddr
    ) public initializer {
        artikToken = _tokenAddress;
        treasury = ArtikTreasury(payable(_treasuryAddress));
        artikProjectManager = ArtikProjectManager(_projectManagerAddr);

        shareholderCount = 0;
        admin = payable(msg.sender);

        penaltyIsActive = true;
    }

    function managePenalty(bool _active) external {
        require(msg.sender == admin);
        penaltyIsActive = _active;
    }

    function getStakedBalance(
        address _shareholder,
        uint256 _roundNumber
    ) external view returns (uint256) {
        require(_shareholder != address(0x0));
        require(_roundNumber > 0);
        return stakedBalance[_shareholder][_roundNumber].balance;
    }

    function calculateStakingPercentageTime(
        address _shareholder,
        uint256 _roundNumber
    ) external view returns (uint256) {
        require(_shareholder != address(0x0));
        require(_roundNumber > 0);

        uint256 diff = (treasury.getAirdropDate(_roundNumber) -
            /*stakedBalance[_shareholder].time) /
            60 /
            60 /
            24;*/
            stakedBalance[_shareholder][_roundNumber].time);

        uint256 percentage = 0;
        if (diff > 0 && penaltyIsActive) {
            percentage = mulDiv(diff, 1000000, 7 * 60 * 60 * 24);
        }
        return percentage;
    }

    function movePreviousStakes() external {
        require(shareholderIndexes[msg.sender] > 0, "not a stakeholder");

        uint256 currentRoundNumber = artikProjectManager.roundNumber();

        for (uint256 i = 1; i <= currentRoundNumber - 1; i++) {
            if (stakedBalance[msg.sender][i].balance > 0) {
                addStakeHolder(
                    msg.sender,
                    stakedBalance[msg.sender][i].balance
                );
                stakedBalance[msg.sender][i].balance = 0;
            }
        }
    }

    function unstakeTokens(uint256 _amount) external {
        require(_amount > 0);

        uint256 currentRoundNumber = artikProjectManager.roundNumber();
        require(
            _amount <= stakedBalance[msg.sender][currentRoundNumber].balance
        );
        require(stakedBalance[msg.sender][currentRoundNumber].balance > 0);

        stakedBalance[msg.sender][currentRoundNumber].balance = stakedBalance[
            msg.sender
        ][currentRoundNumber].balance.sub(_amount);

        stakedBalance[msg.sender][currentRoundNumber].time = block.timestamp;

        uint256 totalStakedAmount = 0;
        for (uint256 i = 1; i < currentRoundNumber; i++) {
            totalStakedAmount = totalStakedAmount.add(
                stakedBalance[msg.sender][i].balance
            );
        }

        if (totalStakedAmount <= 0) {
            removeShareHolder(msg.sender);
        }

        IERC20(artikToken).transfer(msg.sender, _amount);
    }

    function addStakeHolder(address _stakeholder, uint256 _amount) private {
        require(_amount > 0, "amount less than 0");
        require(_stakeholder != address(0x0));

        uint256 currentRoundNumber = artikProjectManager.roundNumber();
        if (!stakedBalance[_stakeholder][currentRoundNumber].staked) {
            stakedBalance[_stakeholder][currentRoundNumber] = Stake(
                _amount,
                block.timestamp,
                true
            );
        } else {
            stakedBalance[_stakeholder][currentRoundNumber]
                .balance = stakedBalance[_stakeholder][currentRoundNumber]
                .balance
                .add(_amount);
            stakedBalance[_stakeholder][currentRoundNumber].time = block
                .timestamp;
        }

        addShareHolder(_stakeholder);
    }

    function stakeTokens(uint256 _amount) external {
        require(
            _amount <= IERC20(artikToken).balanceOf(msg.sender),
            "amount greater than balance"
        );
        addStakeHolder(msg.sender, _amount);
        IERC20(artikToken).transferFrom(msg.sender, address(this), _amount);
    }

    function addShareHolder(address _shareholder) private {
        require(_shareholder != address(0x0));

        if (shareholderIndexes[_shareholder] <= 0) {
            shareholders.push(_shareholder);
            shareholderCount = shareholderCount.add(1);
            shareholderIndexes[_shareholder] = shareholderCount;
        }
    }

    function removeShareHolder(address _shareholder) private {
        require(_shareholder != address(0x0));

        if (shareholderIndexes[_shareholder] > 0) {
            shareholders[shareholderIndexes[_shareholder] - 1] = shareholders[
                shareholders.length - 1
            ];
            shareholders.pop();
            shareholderCount = shareholderCount.sub(1);
            shareholderIndexes[_shareholder] = 0;
        }
    }

    function getShareHolders() external view returns (address[] memory) {
        return shareholders;
    }

    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 z
    ) public pure returns (uint256) {
        return
            ABDKMathQuad.toUInt(
                ABDKMathQuad.div(
                    ABDKMathQuad.mul(
                        ABDKMathQuad.fromUInt(x),
                        ABDKMathQuad.fromUInt(y)
                    ),
                    ABDKMathQuad.fromUInt(z)
                )
            );
    }
}


// File: /contracts/ArtikProjectManagerV2.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "./interfaces/DexRouter.sol";

import "./libraries/ABDKMathQuad.sol";

import "./ArtikTreasury.sol";
import "./ArtikStakeManager.sol";
import "./DistributorV2.sol";
import "./ArtikTreasuryV2.sol";
import "./ArtikStakeManagerV2.sol";

contract ArtikProjectManagerV2 is Initializable {
    using SafeMath for uint256;

    // Pancakeswap 0x10ED43C718714eb63d5aA57B78B54704E256024E (testnet: 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3)
    address constant ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
    // WBNB 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c (testnet: 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd)
    address constant WETH = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
    // BUSD 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56 (testnet: 0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7)
    address constant STABLE_COIN = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;

    uint256 private constant TEAM_FEE = 30;

    DexRouter private dexRouter;

    address private artikToken;
    address payable private admin;

    uint256 public roundNumber;
    mapping(address => mapping(uint256 => uint256)) private voters;
    mapping(address => bool) private isVoter;
    mapping(uint256 => ProjectVotes) private projectVotes;

    Project public bestProject;

    uint256 public projectCount;
    uint256 public votesCount;
    mapping(uint256 => Project) public projects;
    mapping(uint256 => ProjectVotes[]) private projectsLeaderboard;

    DistributorV2 private distributor;
    address payable public distributorAddress;

    uint256 public priceToVote;
    uint256 public minBalanceToVote;

    struct ProjectVotes {
        uint256 id;
        uint256 votes;
    }

    struct Project {
        uint256 id;
        string img;
        string name;
        string description;
        string category;
        string url;
        string twitter;
        address tokenAddress;
        string tokenSymbol;
        uint256 tokenDecimals;
        bool active;
        bool pitchWinner;
    }

    ArtikTreasury private treasury;
    ArtikStakeManager private artikStakeManager;
    ArtikTreasuryV2 private artikTreasuryV2;
    ArtikStakeManagerV2 private artikStakeManagerV2;

    modifier onlyAdmin() {
        require(msg.sender == admin || msg.sender == distributorAddress);
        _;
    }

    function initialize(
        address _tokenAddress,
        address _distributorAddress
    ) public initializer {
        dexRouter = DexRouter(ROUTER);
        artikToken = _tokenAddress;
        artikTreasuryV2 = ArtikTreasuryV2(payable(_distributorAddress));
        distributorAddress = payable(_distributorAddress);
        admin = payable(msg.sender);
        roundNumber = 1;
        projectCount = 0;
        votesCount = 0;
    }

    function configureManagers(
        address _stakeManagerAddr,
        address _treasuryAddr
    ) external onlyAdmin {
        require(_stakeManagerAddr != address(0x0));
        require(_treasuryAddr != address(0x0));
        artikStakeManagerV2 = ArtikStakeManagerV2(_stakeManagerAddr);
        artikTreasuryV2 = ArtikTreasuryV2(payable(_treasuryAddr));
    }

    function configurePriceToVote(uint256 _price) external onlyAdmin {
        require(_price >= 0, "price is less than 0");
        priceToVote = _price;
    }

    function configureMinBalanceToVote(uint256 _balance) external onlyAdmin {
        require(_balance >= 0, "balance is less than 0");
        (uint256 balanceInEth, ) = getAmountOutMin(_balance, STABLE_COIN, WETH);
        (minBalanceToVote, ) = getAmountOutMin(balanceInEth, WETH, artikToken);
    }

    function uploadProject(
        string memory _img,
        string memory _name,
        string memory _description,
        string memory _category,
        string memory _url,
        string memory _twitter,
        bytes20 _tokenAddress,
        string memory _tokenSymbol,
        uint256 _tokenDecimals
    ) external onlyAdmin {
        require(msg.sender != address(0));
        require(bytes(_img).length > 0);
        require(bytes(_name).length > 0);
        require(bytes(_description).length > 0);
        require(bytes(_category).length > 0);
        require(bytes(_url).length > 0);
        require(address(_tokenAddress) != address(0x0));
        require(bytes(_tokenSymbol).length > 0);
        require(_tokenDecimals > 0);

        projectCount = projectCount.add(1);
        projects[projectCount] = Project(
            projectCount,
            _img,
            _name,
            _description,
            _category,
            _url,
            _twitter,
            address(_tokenAddress),
            _tokenSymbol,
            _tokenDecimals,
            true,
            false
        );

        projectVotes[projectCount] = ProjectVotes(projectCount, 0);
    }

    function changeProjectDescription(
        uint256 _projectId,
        string memory _description
    ) external onlyAdmin {
        require(_projectId > 0);
        require(bytes(_description).length > 0);
        projects[_projectId].description = _description;
    }

    function getLeaderBoard() external view returns (ProjectVotes[] memory) {
        return projectsLeaderboard[roundNumber - 1];
    }

    function saveProjectToLeaderboard(uint256 _projectId) external onlyAdmin {
        require(_projectId > 0);
        projectsLeaderboard[roundNumber - 1].push(
            ProjectVotes(_projectId, projectVotes[_projectId].votes)
        );
    }

    function managePitchWinner(
        uint256 _projectId,
        bool _isWinner
    ) external onlyAdmin {
        require(_projectId > 0);
        require(_isWinner == true || _isWinner == false);
        projects[_projectId].pitchWinner = _isWinner;
    }

    function changeProjectState(
        uint256 _projectId,
        bool _active
    ) external onlyAdmin {
        require(_projectId > 0);
        require(_active == true || _active == false);
        projects[_projectId].active = _active;
    }

    function voteProject(uint256 _projectId) external payable {
        require(
            voters[msg.sender][_projectId] != roundNumber,
            "voters can vote the same project only 1 time"
        );

        require(_projectId != 0, "projectId canno be 0");
        require(msg.value > 0, "value less than 0");

        (uint256 priceInBusd, ) = getAmountOutMin(msg.value, WETH, STABLE_COIN);

        if (priceToVote > 0) {
            require(priceInBusd >= priceToVote, "voting has a cost!");
            uint256 amount = msg.value.div(2);

            (bool sentToTeam, ) = admin.call{value: amount}("");
            (bool sentToDistributor, ) = distributorAddress.call{
                value: address(this).balance
            }("");
            require(sentToTeam, "Failed to send to team");
            require(sentToDistributor, "Failed to send to distributor");

            artikTreasuryV2.swapTokens();
        }

        if (minBalanceToVote > 0) {
            require(
                artikStakeManagerV2.getStakedBalance(msg.sender, roundNumber) >=
                    minBalanceToVote,
                "not enough balance to vote"
            );
        }

        projectVotes[_projectId].votes = projectVotes[_projectId].votes.add(1);
        voters[msg.sender][_projectId] = roundNumber;
        isVoter[msg.sender] = true;
        votesCount = votesCount.add(1);
    }

    function setVoter(address _shareholder, bool _isVoter) external onlyAdmin {
        require(_shareholder != address(0x0));
        require(_isVoter == true || _isVoter == false);
        isVoter[_shareholder] = _isVoter;
    }

    function isShareholderVoter(
        address _shareholder
    ) external view returns (bool) {
        require(_shareholder != address(0x0));
        return isVoter[_shareholder];
    }

    function resetProjectVotes(uint256 _projectId) external onlyAdmin {
        require(_projectId > 0);
        projectVotes[_projectId].votes = 0;
    }

    function setBestProject(uint256 _projectId) external onlyAdmin {
        require(_projectId > 0);
        bestProject = projects[_projectId];
    }

    function getProjectVotes(
        uint256 _projectId
    ) external view onlyAdmin returns (ProjectVotes memory) {
        require(_projectId > 0);
        return projectVotes[_projectId];
    }

    function getBestProject() external view returns (Project memory) {
        return bestProject;
    }

    function getAmountOutMin(
        uint256 _amount,
        address _tokenIn,
        address _tokenOut
    ) private view returns (uint256, address[] memory) {
        address[] memory path = new address[](2);
        path[0] = _tokenIn;
        path[1] = _tokenOut;

        uint256[] memory amountOutMins = dexRouter.getAmountsOut(_amount, path);
        return (amountOutMins[1], path);
    }

    function setRound(uint256 _round) public onlyAdmin {
        require(_round > 0);
        roundNumber = _round;
    }

    function nextRound() public onlyAdmin {
        roundNumber = roundNumber.add(1);
    }

    function hasVotedProject(uint256 _projectId) external view returns (bool) {
        if (voters[msg.sender][_projectId] == roundNumber) {
            return true;
        } else {
            return false;
        }
    }

    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 z
    ) public pure returns (uint256) {
        return
            ABDKMathQuad.toUInt(
                ABDKMathQuad.div(
                    ABDKMathQuad.mul(
                        ABDKMathQuad.fromUInt(x),
                        ABDKMathQuad.fromUInt(y)
                    ),
                    ABDKMathQuad.fromUInt(z)
                )
            );
    }
}


// File: /contracts/ArtikProjectManagerV1.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "./interfaces/DexRouter.sol";

import "./libraries/ABDKMathQuad.sol";

import "./ArtikTreasury.sol";
import "./ArtikStakeManager.sol";
import "./DistributorV2.sol";
import "./ArtikTreasuryV2.sol";
import "./ArtikStakeManagerV2.sol";
import "./ArtikStakeManagerV1.sol";
import "./ArtikTreasuryV1.sol";

contract ArtikProjectManagerV1 is Initializable {
    using SafeMath for uint256;

    // Pancakeswap 0x10ED43C718714eb63d5aA57B78B54704E256024E (testnet: 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3)
    address constant ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
    // WBNB 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c (testnet: 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd)
    address constant WETH = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
    // BUSD 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56 (testnet: 0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7)
    address constant STABLE_COIN = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;

    uint256 private constant TEAM_FEE = 30;

    DexRouter private dexRouter;

    address private artikToken;
    address payable private admin;

    uint256 public roundNumber;
    mapping(address => mapping(uint256 => uint256)) private voters;
    mapping(address => bool) private isVoter;
    mapping(uint256 => ProjectVotes) private projectVotes;

    Project public bestProject;

    uint256 public projectCount;
    uint256 public votesCount;
    mapping(uint256 => Project) public projects;
    mapping(uint256 => ProjectVotes[]) private projectsLeaderboard;

    DistributorV2 private distributor;
    address payable public distributorAddress;

    uint256 public priceToVote;
    uint256 public minBalanceToVote;

    struct ProjectVotes {
        uint256 id;
        uint256 votes;
    }

    struct Project {
        uint256 id;
        string img;
        string name;
        string description;
        string category;
        string url;
        string twitter;
        address tokenAddress;
        string tokenSymbol;
        uint256 tokenDecimals;
        bool active;
        bool pitchWinner;
    }

    ArtikTreasury private treasury;
    ArtikStakeManager private artikStakeManager;
    ArtikTreasuryV2 private artikTreasuryV2;
    ArtikStakeManagerV2 private artikStakeManagerV2;
    ArtikStakeManagerV1 private artikStakeManagerV1;
    ArtikTreasuryV1 private artikTreasuryV1;

    modifier onlyAdmin() {
        require(msg.sender == admin || msg.sender == distributorAddress);
        _;
    }

    function initialize(
        address _tokenAddress,
        address _distributorAddress
    ) public initializer {
        dexRouter = DexRouter(ROUTER);
        artikToken = _tokenAddress;
        artikTreasuryV1 = ArtikTreasuryV1(payable(_distributorAddress));
        distributorAddress = payable(_distributorAddress);
        admin = payable(msg.sender);
        roundNumber = 1;
        projectCount = 0;
        votesCount = 0;
    }

    function configureManagers(
        address _stakeManagerAddr,
        address _treasuryAddr
    ) external onlyAdmin {
        require(_stakeManagerAddr != address(0x0));
        require(_treasuryAddr != address(0x0));
        artikStakeManagerV1 = ArtikStakeManagerV1(_stakeManagerAddr);
        artikTreasuryV1 = ArtikTreasuryV1(payable(_treasuryAddr));
    }

    function configurePriceToVote(uint256 _price) external onlyAdmin {
        require(_price >= 0, "price is less than 0");
        priceToVote = _price;
    }

    function configureMinBalanceToVote(uint256 _balance) external onlyAdmin {
        require(_balance >= 0, "balance is less than 0");
        (uint256 balanceInEth, ) = getAmountOutMin(_balance, STABLE_COIN, WETH);
        (minBalanceToVote, ) = getAmountOutMin(balanceInEth, WETH, artikToken);
    }

    function uploadProject(
        string memory _img,
        string memory _name,
        string memory _description,
        string memory _category,
        string memory _url,
        string memory _twitter,
        bytes20 _tokenAddress,
        string memory _tokenSymbol,
        uint256 _tokenDecimals
    ) external onlyAdmin {
        require(msg.sender != address(0));
        require(bytes(_img).length > 0);
        require(bytes(_name).length > 0);
        require(bytes(_description).length > 0);
        require(bytes(_category).length > 0);
        require(bytes(_url).length > 0);
        require(address(_tokenAddress) != address(0x0));
        require(bytes(_tokenSymbol).length > 0);
        require(_tokenDecimals > 0);

        projectCount = projectCount.add(1);
        projects[projectCount] = Project(
            projectCount,
            _img,
            _name,
            _description,
            _category,
            _url,
            _twitter,
            address(_tokenAddress),
            _tokenSymbol,
            _tokenDecimals,
            true,
            false
        );

        projectVotes[projectCount] = ProjectVotes(projectCount, 0);
    }

    function changeProjectDescription(
        uint256 _projectId,
        string memory _description
    ) external onlyAdmin {
        require(_projectId > 0);
        require(bytes(_description).length > 0);
        projects[_projectId].description = _description;
    }

    function getLeaderBoard() external view returns (ProjectVotes[] memory) {
        return projectsLeaderboard[roundNumber - 1];
    }

    function saveProjectToLeaderboard(uint256 _projectId) external onlyAdmin {
        require(_projectId > 0);
        projectsLeaderboard[roundNumber - 1].push(
            ProjectVotes(_projectId, projectVotes[_projectId].votes)
        );
    }

    function managePitchWinner(
        uint256 _projectId,
        bool _isWinner
    ) external onlyAdmin {
        require(_projectId > 0);
        require(_isWinner == true || _isWinner == false);
        projects[_projectId].pitchWinner = _isWinner;
    }

    function changeProjectState(
        uint256 _projectId,
        bool _active
    ) external onlyAdmin {
        require(_projectId > 0);
        require(_active == true || _active == false);
        projects[_projectId].active = _active;
    }

    function voteProject(uint256 _projectId) external payable {
        require(
            voters[msg.sender][_projectId] != roundNumber,
            "voters can vote the same project only 1 time"
        );

        require(_projectId != 0, "projectId canno be 0");
        require(msg.value > 0, "value less than 0");

        (uint256 priceInBusd, ) = getAmountOutMin(msg.value, WETH, STABLE_COIN);

        if (priceToVote > 0) {
            require(priceInBusd >= priceToVote, "voting has a cost!");
            uint256 amount = msg.value.div(2);

            (bool sentToTeam, ) = admin.call{value: amount}("");
            (bool sentToDistributor, ) = distributorAddress.call{
                value: address(this).balance
            }("");
            require(sentToTeam, "Failed to send to team");
            require(sentToDistributor, "Failed to send to distributor");

            artikTreasuryV1.swapTokens();
        }

        if (minBalanceToVote > 0) {
            require(
                artikStakeManagerV1.getStakedBalance(msg.sender, roundNumber) >=
                    minBalanceToVote,
                "not enough balance to vote"
            );
        }

        projectVotes[_projectId].votes = projectVotes[_projectId].votes.add(1);
        voters[msg.sender][_projectId] = roundNumber;
        isVoter[msg.sender] = true;
        votesCount = votesCount.add(1);
    }

    function setVoter(address _shareholder, bool _isVoter) external onlyAdmin {
        require(_shareholder != address(0x0));
        require(_isVoter == true || _isVoter == false);
        isVoter[_shareholder] = _isVoter;
    }

    function isShareholderVoter(
        address _shareholder
    ) external view returns (bool) {
        require(_shareholder != address(0x0));
        return isVoter[_shareholder];
    }

    function resetProjectVotes(uint256 _projectId) external onlyAdmin {
        require(_projectId > 0);
        projectVotes[_projectId].votes = 0;
    }

    function setBestProject(uint256 _projectId) external onlyAdmin {
        require(_projectId > 0);
        bestProject = projects[_projectId];
    }

    function getProjectVotes(
        uint256 _projectId
    ) external view onlyAdmin returns (ProjectVotes memory) {
        require(_projectId > 0);
        return projectVotes[_projectId];
    }

    function getBestProject() external view returns (Project memory) {
        return bestProject;
    }

    function getAmountOutMin(
        uint256 _amount,
        address _tokenIn,
        address _tokenOut
    ) private view returns (uint256, address[] memory) {
        address[] memory path = new address[](2);
        path[0] = _tokenIn;
        path[1] = _tokenOut;

        uint256[] memory amountOutMins = dexRouter.getAmountsOut(_amount, path);
        return (amountOutMins[1], path);
    }

    function setRound(uint256 _round) public onlyAdmin {
        require(_round > 0);
        roundNumber = _round;
    }

    function nextRound() public onlyAdmin {
        roundNumber = roundNumber.add(1);
    }

    function hasVotedProject(uint256 _projectId) external view returns (bool) {
        if (voters[msg.sender][_projectId] == roundNumber) {
            return true;
        } else {
            return false;
        }
    }

    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 z
    ) public pure returns (uint256) {
        return
            ABDKMathQuad.toUInt(
                ABDKMathQuad.div(
                    ABDKMathQuad.mul(
                        ABDKMathQuad.fromUInt(x),
                        ABDKMathQuad.fromUInt(y)
                    ),
                    ABDKMathQuad.fromUInt(z)
                )
            );
    }
}


// File: /contracts/ArtikProjectManager.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "./interfaces/DexRouter.sol";

import "./libraries/ABDKMathQuad.sol";

import "./ArtikTreasury.sol";
import "./ArtikStakeManager.sol";
import "./DistributorV2.sol";

contract ArtikProjectManager is Initializable {
    using SafeMath for uint256;

    // Pancakeswap 0x10ED43C718714eb63d5aA57B78B54704E256024E (testnet: 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3)
    address constant ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
    // WBNB 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c (testnet: 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd)
    address constant WETH = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
    // BUSD 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56 (testnet: 0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7)
    address constant STABLE_COIN = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;

    uint256 private constant TEAM_FEE = 30;

    DexRouter private dexRouter;

    address private artikToken;
    address payable private admin;

    uint256 public roundNumber;
    mapping(address => mapping(uint256 => uint256)) private voters;
    mapping(address => bool) private isVoter;
    mapping(uint256 => ProjectVotes) private projectVotes;

    Project public bestProject;

    uint256 public projectCount;
    uint256 public votesCount;
    mapping(uint256 => Project) public projects;
    mapping(uint256 => ProjectVotes[]) private projectsLeaderboard;

    DistributorV2 private distributor;
    address payable public distributorAddress;

    uint256 public priceToVote;
    uint256 public minBalanceToVote;

    struct ProjectVotes {
        uint256 id;
        uint256 votes;
    }

    struct Project {
        uint256 id;
        string img;
        string name;
        string description;
        string category;
        string url;
        string twitter;
        address tokenAddress;
        string tokenSymbol;
        uint256 tokenDecimals;
        bool active;
        bool pitchWinner;
    }

    ArtikTreasury private treasury;
    ArtikStakeManager private artikStakeManager;

    modifier onlyAdmin() {
        require(msg.sender == admin || msg.sender == distributorAddress);
        _;
    }

    function initialize(
        address _tokenAddress,
        address _distributorAddress
    ) public initializer {
        dexRouter = DexRouter(ROUTER);
        artikToken = _tokenAddress;
        treasury = ArtikTreasury(payable(_distributorAddress));
        distributorAddress = payable(_distributorAddress);
        admin = payable(msg.sender);
        roundNumber = 1;
        projectCount = 0;
        votesCount = 0;
    }

    function configureStakeManager(
        address _stakeManagerAddr
    ) external onlyAdmin {
        require(_stakeManagerAddr != address(0x0));
        artikStakeManager = ArtikStakeManager(_stakeManagerAddr);
    }

    function configurePriceToVote(uint256 _price) external onlyAdmin {
        require(_price >= 0, "price is less than 0");
        priceToVote = _price;
    }

    function configureMinBalanceToVote(uint256 _balance) external onlyAdmin {
        require(_balance >= 0, "balance is less than 0");
        (uint256 balanceInEth, ) = getAmountOutMin(_balance, STABLE_COIN, WETH);
        (minBalanceToVote, ) = getAmountOutMin(balanceInEth, WETH, artikToken);
    }

    function uploadProject(
        string memory _img,
        string memory _name,
        string memory _description,
        string memory _category,
        string memory _url,
        string memory _twitter,
        bytes20 _tokenAddress,
        string memory _tokenSymbol,
        uint256 _tokenDecimals
    ) external onlyAdmin {
        require(msg.sender != address(0));
        require(bytes(_img).length > 0);
        require(bytes(_name).length > 0);
        require(bytes(_description).length > 0);
        require(bytes(_category).length > 0);
        require(bytes(_url).length > 0);
        require(address(_tokenAddress) != address(0x0));
        require(bytes(_tokenSymbol).length > 0);
        require(_tokenDecimals > 0);

        projectCount = projectCount.add(1);
        projects[projectCount] = Project(
            projectCount,
            _img,
            _name,
            _description,
            _category,
            _url,
            _twitter,
            address(_tokenAddress),
            _tokenSymbol,
            _tokenDecimals,
            true,
            false
        );

        projectVotes[projectCount] = ProjectVotes(projectCount, 0);
    }

    function changeProjectDescription(
        uint256 _projectId,
        string memory _description
    ) external onlyAdmin {
        require(_projectId > 0);
        require(bytes(_description).length > 0);
        projects[_projectId].description = _description;
    }

    function getLeaderBoard() external view returns (ProjectVotes[] memory) {
        return projectsLeaderboard[roundNumber - 1];
    }

    function saveProjectToLeaderboard(uint256 _projectId) external onlyAdmin {
        require(_projectId > 0);
        projectsLeaderboard[roundNumber - 1].push(
            ProjectVotes(_projectId, projectVotes[_projectId].votes)
        );
    }

    function managePitchWinner(
        uint256 _projectId,
        bool _isWinner
    ) external onlyAdmin {
        require(_projectId > 0);
        require(_isWinner == true || _isWinner == false);
        projects[_projectId].pitchWinner = _isWinner;
    }

    function changeProjectState(
        uint256 _projectId,
        bool _active
    ) external onlyAdmin {
        require(_projectId > 0);
        require(_active == true || _active == false);
        projects[_projectId].active = _active;
    }

    function voteProject(uint256 _projectId) external payable {
        require(
            voters[msg.sender][_projectId] != roundNumber,
            "voters can vote the same project only 1 time"
        );

        require(_projectId != 0, "projectId canno be 0");
        require(msg.value > 0, "value less than 0");

        (uint256 priceInBusd, ) = getAmountOutMin(msg.value, WETH, STABLE_COIN);

        if (priceToVote > 0) {
            require(priceInBusd >= priceToVote, "voting has a cost!");
            uint256 amount = msg.value.div(2);

            (bool sentToTeam, ) = admin.call{value: amount}("");
            (bool sentToDistributor, ) = distributorAddress.call{
                value: address(this).balance
            }("");
            require(sentToTeam, "Failed to send to team");
            require(sentToDistributor, "Failed to send to distributor");

            treasury.swapTokens();
        }

        if (minBalanceToVote > 0) {
            require(
                artikStakeManager.getStakedBalance(msg.sender, roundNumber) >=
                    minBalanceToVote,
                "not enough balance to vote"
            );
        }

        projectVotes[_projectId].votes = projectVotes[_projectId].votes.add(1);
        voters[msg.sender][_projectId] = roundNumber;
        isVoter[msg.sender] = true;
        votesCount = votesCount.add(1);
    }

    function setVoter(address _shareholder, bool _isVoter) external onlyAdmin {
        require(_shareholder != address(0x0));
        require(_isVoter == true || _isVoter == false);
        isVoter[_shareholder] = _isVoter;
    }

    function isShareholderVoter(
        address _shareholder
    ) external view returns (bool) {
        require(_shareholder != address(0x0));
        return isVoter[_shareholder];
    }

    function resetProjectVotes(uint256 _projectId) external onlyAdmin {
        require(_projectId > 0);
        projectVotes[_projectId].votes = 0;
    }

    function setBestProject(uint256 _projectId) external onlyAdmin {
        require(_projectId > 0);
        bestProject = projects[_projectId];
    }

    function getProjectVotes(
        uint256 _projectId
    ) external view onlyAdmin returns (ProjectVotes memory) {
        require(_projectId > 0);
        return projectVotes[_projectId];
    }

    function getBestProject() external view returns (Project memory) {
        return bestProject;
    }

    function getAmountOutMin(
        uint256 _amount,
        address _tokenIn,
        address _tokenOut
    ) private view returns (uint256, address[] memory) {
        address[] memory path = new address[](2);
        path[0] = _tokenIn;
        path[1] = _tokenOut;

        uint256[] memory amountOutMins = dexRouter.getAmountsOut(_amount, path);
        return (amountOutMins[1], path);
    }

    function setRound(uint256 _round) public onlyAdmin {
        require(_round > 0);
        roundNumber = _round;
    }

    function nextRound() public onlyAdmin {
        roundNumber = roundNumber.add(1);
    }

    function hasVotedProject(uint256 _projectId) external view returns (bool) {
        if (voters[msg.sender][_projectId] == roundNumber) {
            return true;
        } else {
            return false;
        }
    }

    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 z
    ) public pure returns (uint256) {
        return
            ABDKMathQuad.toUInt(
                ABDKMathQuad.div(
                    ABDKMathQuad.mul(
                        ABDKMathQuad.fromUInt(x),
                        ABDKMathQuad.fromUInt(y)
                    ),
                    ABDKMathQuad.fromUInt(z)
                )
            );
    }
}


// File: /contracts/ArtikDistributorV2.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "./interfaces/DexRouter.sol";

import "./libraries/ABDKMathQuad.sol";

contract ArtikDistributorV2 is Initializable {
    using SafeMath for uint256;

    // Pancakeswap 0x10ED43C718714eb63d5aA57B78B54704E256024E (testnet: 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3)
    address constant ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
    // WBNB 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c (testnet: 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd)
    address constant WETH = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
    // BUSD 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56 (testnet: 0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7)
    address constant STABLE_COIN = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;

    uint256 private constant BUY_BACK_FEE = 25; //(2% of total fee)
    uint256 private accumulatedEthForAirdrop;

    DexRouter private dexRouter;

    address private artikToken;
    address payable private admin;

    address[] public shareholders;
    uint256 private shareholderCount;
    mapping(address => uint256) private shareholderIndexes;

    uint256 public roundNumber;
    mapping(address => mapping(uint256 => uint256)) private voters;
    mapping(address => bool) private isVoter;

    mapping(address => mapping(uint256 => bool)) private userClaimedProject;
    uint256 public totalAmountAirdropped;
    mapping(address => uint256) public amountClaimed;

    Project public bestProject;

    uint256 public airdropBalance;
    uint256 public totalHoldersBalance;
    uint256 public airdropDate;

    uint256 public projectCount;
    uint256 public votesCount;
    mapping(uint256 => Project) public projects;

    mapping(address => mapping(uint256 => mapping(uint256 => bool)))
        private userHasClaimedProject;

    mapping(uint256 => uint256) private airdropSnapshot;
    uint256 private stableCoinBalance;

    struct Project {
        uint256 id;
        string img;
        string name;
        string description;
        string category;
        string url;
        string twitter;
        uint256 votes;
        address tokenAddress;
        string tokenSymbol;
        uint256 tokenDecimals;
        bool active;
    }

    function initialize(address _tokenAddress) public initializer {
        dexRouter = DexRouter(ROUTER);
        artikToken = _tokenAddress;
        admin = payable(msg.sender);
        shareholderCount = 0;
        roundNumber = 1;
        totalAmountAirdropped = 0;
        projectCount = 0;
        votesCount = 0;
        accumulatedEthForAirdrop = 0;
        totalHoldersBalance = 0;
        airdropBalance = 0;
        stableCoinBalance = 0;
    }

    modifier onlyToken() {
        require(msg.sender == artikToken, "sender is not the token");
        _;
    }

    modifier onlyAdmin() {
        require(msg.sender == admin);
        _;
    }

    function uploadProject(
        string memory _img,
        string memory _name,
        string memory _description,
        string memory _category,
        string memory _url,
        string memory _twitter,
        bytes20 _tokenAddress,
        string memory _tokenSymbol,
        uint256 _tokenDecimals
    ) external onlyAdmin {
        require(msg.sender != address(0));
        require(bytes(_img).length > 0);
        require(bytes(_name).length > 0);
        require(bytes(_description).length > 0);
        require(bytes(_category).length > 0);
        require(bytes(_url).length > 0);
        require(address(_tokenAddress) != address(0x0));
        require(bytes(_tokenSymbol).length > 0);
        require(_tokenDecimals > 0);

        projectCount = projectCount.add(1);
        projects[projectCount] = Project(
            projectCount,
            _img,
            _name,
            _description,
            _category,
            _url,
            _twitter,
            0,
            address(_tokenAddress),
            _tokenSymbol,
            _tokenDecimals,
            true
        );
    }

    function changeProjectState(
        uint256 _projectId,
        bool _active
    ) external onlyAdmin {
        projects[_projectId].active = _active;
    }

    function voteProject(uint256 _projectId) external {
        require(
            voters[msg.sender][_projectId] != roundNumber,
            "voters can vote the same project only 1 time"
        );
        require(
            shareholderIndexes[msg.sender] > 0,
            "voters must be token holders"
        );
        require(_projectId != 0, "projectId canno be 0");

        projects[_projectId].votes = projects[_projectId].votes.add(1);
        voters[msg.sender][_projectId] = roundNumber;
        isVoter[msg.sender] = true;
        votesCount = votesCount.add(1);
    }

    function resetProjectVotes(uint256 _projectId) external onlyAdmin {
        projects[_projectId].votes = 0;
    }

    function setBestProject(uint256 _projectId) external onlyAdmin {
        bestProject = projects[_projectId];
    }

    function setAirdropDate(uint256 _days) public onlyAdmin {
        airdropDate = block.timestamp + (1 days * _days);
    }

    function takeSnapshot() external onlyAdmin {
        airdropSnapshot[roundNumber] = calculateTVL();
    }

    // Initialize airdrop
    // 1) approveAirdrop
    // 2) buyBack
    // 3) buyAirdropTokens
    // 4) initializeNextRound

    function approveAirdrop() external onlyAdmin {
        stableCoinBalance = IERC20(STABLE_COIN).balanceOf(address(this));
        require(stableCoinBalance > 0);

        IERC20(STABLE_COIN).approve(ROUTER, stableCoinBalance);
        (uint256 amountWethMin, ) = getAmountOutMin(
            stableCoinBalance,
            STABLE_COIN,
            WETH
        );
        IERC20(WETH).approve(ROUTER, amountWethMin);
    }

    function buyBack() external onlyAdmin {
        swapTokensForETH(
            mulDiv(stableCoinBalance, BUY_BACK_FEE, 100),
            STABLE_COIN
        );
        swapETHForTokens(address(this).balance, artikToken);
        IERC20(artikToken).transfer(
            address(0x0),
            IERC20(artikToken).balanceOf(address(this))
        );
    }

    function buyAirdropTokens(uint256 _amount) external onlyAdmin {
        require(_amount > 0);
        swapTokensForETH(_amount, STABLE_COIN);
        swapETHForTokens(address(this).balance, bestProject.tokenAddress);
    }

    function initializeNextRound(uint256 _days) external onlyAdmin {
        require(_days > 0);

        nextRound();
        airdropSnapshot[roundNumber] = 0;
        setAirdropDate(_days);
        airdropBalance = IERC20(bestProject.tokenAddress).balanceOf(
            address(this)
        );
    }

    // End Airdrop

    function claimAirdrop() public {
        uint256 airdrop = calculateAirdropAmount(msg.sender);
        IERC20(bestProject.tokenAddress).transfer(msg.sender, airdrop);

        isVoter[msg.sender] = false;
        userHasClaimedProject[msg.sender][roundNumber][bestProject.id] = true;

        (uint256 amountWethMin, ) = getAmountOutMin(
            airdrop,
            bestProject.tokenAddress,
            WETH
        );
        (uint256 amountStableMin, ) = getAmountOutMin(
            amountWethMin,
            WETH,
            STABLE_COIN
        );

        amountClaimed[msg.sender] = amountClaimed[msg.sender].add(
            amountStableMin
        );
        totalAmountAirdropped = totalAmountAirdropped.add(amountStableMin);
    }

    function calculateTVL() public view returns (uint256) {
        uint256 currentBalance = 0;
        for (uint256 i = 0; i < shareholders.length; i++) {
            if (isVoter[shareholders[i]]) {
                currentBalance = currentBalance.add(
                    IERC20(artikToken).balanceOf(shareholders[i])
                );
            }
        }
        return currentBalance;
    }

    function calculateAirdropAmount(
        address _shareholder
    ) public view returns (uint256) {
        require(shareholderIndexes[_shareholder] > 0, "not a shareholder");
        require(isVoter[_shareholder] == true, "not a voter");
        require(
            _shareholder != address(0x0),
            "shareholder cannot be address of 0"
        );
        require(
            airdropSnapshot[roundNumber - 1] > 0,
            "total holders balance less than 0"
        );

        require(
            userHasClaimedProject[_shareholder][roundNumber][bestProject.id] !=
                true,
            "shareholder has already claimed this airdrop"
        );

        uint256 holderPercentage = calculateHolderPercentage(
            _shareholder,
            airdropSnapshot[roundNumber - 1]
        );

        uint256 airdrop = mulDiv(airdropBalance, holderPercentage, 1000000);

        return airdrop;
    }

    function calculateHolderPercentage(
        address _shareholder,
        uint256 _totalHoldersBalance
    ) private view returns (uint256) {
        // 100 : x = totalHoldersBalance : holderBalance
        uint256 holderBalance = IERC20(artikToken).balanceOf(_shareholder);
        uint256 holderPercentage = mulDiv(
            holderBalance,
            1000000,
            _totalHoldersBalance
        );
        return holderPercentage;
    }

    function calculateExpectedAirdrop(
        address _shareholder
    ) external view returns (uint256) {
        require(
            _shareholder != address(0x0),
            "shareholder address cannot be 0"
        );
        require(shareholderIndexes[_shareholder] > 0, "not a shareholder");

        uint256 holderBalance = IERC20(artikToken).balanceOf(_shareholder);
        require(
            holderBalance > 0,
            "shareholder balance must be greater than 0"
        );

        uint256 holders_balance = 0;
        if (airdropSnapshot[roundNumber] > 0) {
            holders_balance = airdropSnapshot[roundNumber];
        } else {
            holders_balance = calculateTVL();
        }

        uint256 holderPercentage = calculateHolderPercentage(
            _shareholder,
            holders_balance
        );

        uint256 treasuryForAirdrop = mulDiv(
            IERC20(STABLE_COIN).balanceOf(address(this)),
            75,
            100
        );

        return mulDiv(treasuryForAirdrop, holderPercentage, 1000000);
    }

    function addShareHolder(address _shareholder) external onlyToken {
        require(_shareholder != address(0x0));

        if (shareholderIndexes[_shareholder] <= 0) {
            shareholders.push(_shareholder);
            shareholderCount = shareholderCount.add(1);
            shareholderIndexes[_shareholder] = shareholderCount;
        }
    }

    function removeShareHolder(address _shareholder) external onlyToken {
        require(_shareholder != address(0x0));

        if (shareholderIndexes[_shareholder] > 0) {
            shareholders[shareholderIndexes[_shareholder] - 1] = shareholders[
                shareholders.length - 1
            ];
            shareholders.pop();
            shareholderCount = shareholderCount.sub(1);
            shareholderIndexes[_shareholder] = 0;
        }
    }

    function swapETHForTokens(uint256 _amount, address _token) private {
        require(_amount > 0);
        require(_token != address(0x0));
        require(address(this).balance >= _amount, "balance less than _amount");

        address[] memory path = new address[](2);
        path[0] = WETH;
        path[1] = _token;

        dexRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{
            value: _amount
        }(0, path, address(this), block.timestamp);
    }

    function swapTokensForETH(uint256 _amount, address _token) private {
        require(_amount > 0);
        require(_token != address(0x0));
        require(
            IERC20(_token).balanceOf(address(this)) >= _amount,
            "balance less than _amount"
        );

        address[] memory path = new address[](2);
        path[0] = _token;
        path[1] = WETH;

        dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(
            _amount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

    function getAmountOutMin(
        uint256 _amount,
        address _tokenIn,
        address _tokenOut
    ) private view returns (uint256, address[] memory) {
        address[] memory path = new address[](2);
        path[0] = _tokenIn;
        path[1] = _tokenOut;

        uint256[] memory amountOutMins = dexRouter.getAmountsOut(_amount, path);
        return (amountOutMins[1], path);
    }

    function swapTokens() external onlyToken {
        IERC20(WETH).approve(ROUTER, address(this).balance);
        swapETHForTokens(address(this).balance, STABLE_COIN);
    }

    function nextRound() public onlyAdmin {
        roundNumber = roundNumber.add(1);
    }

    function withdrawRemainingAirdrop(address _token) external onlyAdmin {
        require(_token != address(0x0));
        uint256 remainingBalance = IERC20(_token).balanceOf(address(this));
        require(remainingBalance > 0);
        IERC20(_token).transfer(admin, remainingBalance);
    }

    function hasVotedProject(uint256 _projectId) external view returns (bool) {
        if (voters[msg.sender][_projectId] == roundNumber) {
            return true;
        } else {
            return false;
        }
    }

    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 z
    ) public pure returns (uint256) {
        return
            ABDKMathQuad.toUInt(
                ABDKMathQuad.div(
                    ABDKMathQuad.mul(
                        ABDKMathQuad.fromUInt(x),
                        ABDKMathQuad.fromUInt(y)
                    ),
                    ABDKMathQuad.fromUInt(z)
                )
            );
    }

    receive() external payable {}
}


// File: /contracts/ArtikDistributorV1.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "./interfaces/DexRouter.sol";

import "./libraries/ABDKMathQuad.sol";

contract ArtikDistributorV1 is Initializable {
    using SafeMath for uint256;

    // Pancakeswap 0x10ED43C718714eb63d5aA57B78B54704E256024E (testnet: 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3)
    address constant ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
    // WBNB 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c (testnet: 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd)
    address constant WETH = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
    // BUSD 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56 (testnet: 0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7)
    address constant STABLE_COIN = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;

    uint256 private constant BUY_BACK_FEE = 25; //(2% of total fee)
    uint256 private accumulatedEthForAirdrop;

    DexRouter private dexRouter;

    address private artikToken;
    address payable private admin;

    address[] public shareholders;
    uint256 private shareholderCount;
    mapping(address => uint256) private shareholderIndexes;

    uint256 public roundNumber;
    mapping(address => mapping(uint256 => uint256)) private voters;
    mapping(address => bool) private isVoter;

    mapping(address => mapping(uint256 => bool)) private userClaimedProject;
    uint256 public totalAmountAirdropped;
    mapping(address => uint256) public amountClaimed;

    Project public bestProject;

    uint256 public airdropBalance;
    uint256 public totalHoldersBalance;
    uint256 public airdropDate;

    uint256 public projectCount;
    uint256 public votesCount;
    mapping(uint256 => Project) public projects;

    mapping(address => mapping(uint256 => mapping(uint256 => bool)))
        private userHasClaimedProject;

    mapping(uint256 => uint256) private airdropSnapshot;

    struct Project {
        uint256 id;
        string img;
        string name;
        string description;
        string category;
        string url;
        string twitter;
        uint256 votes;
        address tokenAddress;
        string tokenSymbol;
        uint256 tokenDecimals;
        bool active;
    }

    function initialize(address _tokenAddress) public initializer {
        dexRouter = DexRouter(ROUTER);
        artikToken = _tokenAddress;
        admin = payable(msg.sender);
        shareholderCount = 0;
        roundNumber = 1;
        totalAmountAirdropped = 0;
        projectCount = 0;
        votesCount = 0;
        accumulatedEthForAirdrop = 0;
        totalHoldersBalance = 0;
        airdropBalance = 0;
    }

    modifier onlyToken() {
        require(msg.sender == artikToken, "sender is not the token");
        _;
    }

    modifier onlyAdmin() {
        require(msg.sender == admin);
        _;
    }

    function uploadProject(
        string memory _img,
        string memory _name,
        string memory _description,
        string memory _category,
        string memory _url,
        string memory _twitter,
        bytes20 _tokenAddress,
        string memory _tokenSymbol,
        uint256 _tokenDecimals
    ) external onlyAdmin {
        require(msg.sender != address(0));
        require(bytes(_img).length > 0);
        require(bytes(_name).length > 0);
        require(bytes(_description).length > 0);
        require(bytes(_category).length > 0);
        require(bytes(_url).length > 0);
        require(address(_tokenAddress) != address(0x0));
        require(bytes(_tokenSymbol).length > 0);
        require(_tokenDecimals > 0);

        projectCount = projectCount.add(1);
        projects[projectCount] = Project(
            projectCount,
            _img,
            _name,
            _description,
            _category,
            _url,
            _twitter,
            0,
            address(_tokenAddress),
            _tokenSymbol,
            _tokenDecimals,
            true
        );
    }

    function changeProjectState(
        uint256 _projectId,
        bool _active
    ) external onlyAdmin {
        projects[_projectId].active = _active;
    }

    function voteProject(uint256 _projectId) external {
        require(
            voters[msg.sender][_projectId] != roundNumber,
            "voters can vote the same project only 1 time"
        );
        require(
            shareholderIndexes[msg.sender] > 0,
            "voters must be token holders"
        );
        require(_projectId != 0, "projectId canno be 0");

        projects[_projectId].votes = projects[_projectId].votes.add(1);
        voters[msg.sender][_projectId] = roundNumber;
        isVoter[msg.sender] = true;
        votesCount = votesCount.add(1);
    }

    function resetProjectVotes(uint256 _projectId) external onlyAdmin {
        projects[_projectId].votes = 0;
    }

    function setBestProject(uint256 _projectId) external onlyAdmin {
        bestProject = projects[_projectId];
    }

    function setAirdropDate(uint256 _days) public onlyAdmin {
        airdropDate = block.timestamp + (1 days * _days);
    }

    function takeSnapshot() external onlyAdmin {
        airdropSnapshot[roundNumber] = calculateTVL(true);
    }

    function initializeAirdrop(uint256 _days) external onlyAdmin {
        require(block.timestamp >= airdropDate);

        uint256 STABLE_COINBalance = IERC20(STABLE_COIN).balanceOf(
            address(this)
        );

        require(STABLE_COINBalance > 0);
        require(bestProject.id != 0);

        nextRound();
        airdropSnapshot[roundNumber] = 0;

        IERC20(STABLE_COIN).approve(ROUTER, STABLE_COINBalance);
        (uint256 amountWethMin, ) = getAmountOutMin(
            STABLE_COINBalance,
            STABLE_COIN,
            WETH
        );
        IERC20(WETH).approve(ROUTER, amountWethMin);

        uint256 buyBackFee = mulDiv(STABLE_COINBalance, BUY_BACK_FEE, 100);
        uint256 amountToSwap = STABLE_COINBalance.sub(buyBackFee);

        // Buy back mechanism
        buyBack(buyBackFee);

        // Swap BUSD -> BNB -> Airdrop Token
        buyAirdropTokens(amountToSwap, bestProject.tokenAddress);
        setAirdropDate(_days);

        airdropBalance = IERC20(bestProject.tokenAddress).balanceOf(
            address(this)
        );
    }

    function buyAirdropTokens(uint256 _amount, address _project) private {
        swapTokensForETH(_amount, STABLE_COIN);
        swapETHForTokens(address(this).balance, _project);
    }

    function buyBack(uint256 _fee) private {
        swapTokensForETH(_fee, STABLE_COIN);
        swapETHForTokens(address(this).balance, artikToken);
        IERC20(artikToken).transfer(
            address(0x0),
            IERC20(artikToken).balanceOf(address(this))
        );
    }

    function claimAirdrop() public {
        uint256 airdrop = calculateAirdropAmount(msg.sender);
        IERC20(bestProject.tokenAddress).transfer(msg.sender, airdrop);

        isVoter[msg.sender] = false;
        userHasClaimedProject[msg.sender][roundNumber][bestProject.id] = true;

        (uint256 amountWethMin, ) = getAmountOutMin(
            airdrop,
            bestProject.tokenAddress,
            WETH
        );
        (uint256 amountStableMin, ) = getAmountOutMin(
            amountWethMin,
            WETH,
            STABLE_COIN
        );

        amountClaimed[msg.sender] = amountClaimed[msg.sender].add(
            amountStableMin
        );
        totalAmountAirdropped = totalAmountAirdropped.add(amountStableMin);
    }

    function calculateTVL(bool _onlyVoters) public view returns (uint256) {
        uint256 currentBalance = 0;
        for (uint256 i = 0; i < shareholders.length; i++) {
            if ((_onlyVoters && isVoter[shareholders[i]]) || !_onlyVoters) {
                currentBalance = currentBalance.add(
                    IERC20(artikToken).balanceOf(shareholders[i])
                );
            }
        }
        return currentBalance;
    }

    function calculateAirdropAmount(
        address _shareholder
    ) public view returns (uint256) {
        require(shareholderIndexes[_shareholder] > 0, "not a shareholder");
        require(isVoter[_shareholder] == true, "not a voter");
        require(
            _shareholder != address(0x0),
            "shareholder cannot be address of 0"
        );
        require(
            airdropSnapshot[roundNumber - 1] > 0,
            "total holders balance less than 0"
        );

        require(
            userHasClaimedProject[_shareholder][roundNumber][bestProject.id] !=
                true,
            "shareholder has already claimed this airdrop"
        );

        uint256 holderPercentage = calculateHolderPercentage(
            _shareholder,
            airdropSnapshot[roundNumber - 1]
        );

        uint256 airdrop = mulDiv(airdropBalance, holderPercentage, 1000000);

        return airdrop;
    }

    function calculateHolderPercentage(
        address _shareholder,
        uint256 _totalHoldersBalance
    ) private view returns (uint256) {
        // 100 : x = totalHoldersBalance : holderBalance
        uint256 holderBalance = IERC20(artikToken).balanceOf(_shareholder);
        uint256 holderPercentage = mulDiv(
            holderBalance,
            100,
            _totalHoldersBalance.mul(10000)
        );
        return holderPercentage;
    }

    function calculateExpectedAirdrop(
        address _shareholder
    ) external view returns (uint256) {
        require(
            _shareholder != address(0x0),
            "shareholder address cannot be 0"
        );
        require(shareholderIndexes[_shareholder] > 0, "not a shareholder");

        uint256 holderBalance = IERC20(artikToken).balanceOf(_shareholder);
        require(
            holderBalance > 0,
            "shareholder balance must be greater than 0"
        );

        uint256 holders_balance = 0;
        if (airdropSnapshot[roundNumber] > 0) {
            holders_balance = airdropSnapshot[roundNumber];
        } else {
            holders_balance = calculateTVL(true);
        }

        uint256 holderPercentage = calculateHolderPercentage(
            _shareholder,
            holders_balance
        );

        uint256 treasuryForAirdrop = mulDiv(
            IERC20(STABLE_COIN).balanceOf(address(this)),
            75,
            100
        );

        return mulDiv(treasuryForAirdrop, holderPercentage, 1000000);
    }

    function addShareHolder(address _shareholder) external onlyToken {
        require(_shareholder != address(0x0));

        if (shareholderIndexes[_shareholder] <= 0) {
            shareholders.push(_shareholder);
            shareholderCount = shareholderCount.add(1);
            shareholderIndexes[_shareholder] = shareholderCount;
        }
    }

    function removeShareHolder(address _shareholder) external onlyToken {
        require(_shareholder != address(0x0));

        if (shareholderIndexes[_shareholder] > 0) {
            shareholders[shareholderIndexes[_shareholder] - 1] = shareholders[
                shareholders.length - 1
            ];
            shareholders.pop();
            shareholderCount = shareholderCount.sub(1);
            shareholderIndexes[_shareholder] = 0;
        }
    }

    function swapETHForTokens(uint256 _amount, address _token) private {
        require(_amount > 0);
        require(_token != address(0x0));
        require(address(this).balance >= _amount, "balance less than _amount");

        address[] memory path = new address[](2);
        path[0] = WETH;
        path[1] = _token;

        dexRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{
            value: _amount
        }(0, path, address(this), block.timestamp);
    }

    function swapTokensForETH(uint256 _amount, address _token) private {
        require(_amount > 0);
        require(_token != address(0x0));
        require(
            IERC20(_token).balanceOf(address(this)) >= _amount,
            "balance less than _amount"
        );

        address[] memory path = new address[](2);
        path[0] = _token;
        path[1] = WETH;

        dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(
            _amount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

    function getAmountOutMin(
        uint256 _amount,
        address _tokenIn,
        address _tokenOut
    ) private view returns (uint256, address[] memory) {
        address[] memory path = new address[](2);
        path[0] = _tokenIn;
        path[1] = _tokenOut;

        uint256[] memory amountOutMins = dexRouter.getAmountsOut(_amount, path);
        return (amountOutMins[1], path);
    }

    function swapTokens() external onlyToken {
        IERC20(WETH).approve(ROUTER, address(this).balance);
        swapETHForTokens(address(this).balance, STABLE_COIN);
    }

    function nextRound() public onlyAdmin {
        roundNumber = roundNumber.add(1);
    }

    function withdrawRemainingAirdrop(address _token) external onlyAdmin {
        require(_token != address(0x0));
        uint256 remainingBalance = IERC20(_token).balanceOf(address(this));
        require(remainingBalance > 0);
        IERC20(_token).transfer(admin, remainingBalance);
    }

    function hasVotedProject(uint256 _projectId) external view returns (bool) {
        if (voters[msg.sender][_projectId] == roundNumber) {
            return true;
        } else {
            return false;
        }
    }

    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 z
    ) public pure returns (uint256) {
        return
            ABDKMathQuad.toUInt(
                ABDKMathQuad.div(
                    ABDKMathQuad.mul(
                        ABDKMathQuad.fromUInt(x),
                        ABDKMathQuad.fromUInt(y.mul(100))
                    ),
                    ABDKMathQuad.fromUInt(z)
                )
            );
    }

    receive() external payable {}
}


// File: /contracts/ArtikDistributor.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "./interfaces/DexRouter.sol";

contract ArtikDistributor is Initializable {
    using SafeMath for uint256;

    // Pancakeswap 0x10ED43C718714eb63d5aA57B78B54704E256024E (testnet: 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3)
    address constant ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
    // WBNB 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c (testnet: 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd)
    address constant WETH = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
    // BUSD 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56 (testnet: 0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7)
    address constant STABLE_COIN = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;

    uint256 private constant BUY_BACK_FEE = 25; //(2% of total fee)
    uint256 private accumulatedEthForAirdrop;

    DexRouter private dexRouter;

    address private artikToken;
    address payable private admin;

    address[] public shareholders;
    uint256 private shareholderCount;
    mapping(address => uint256) private shareholderIndexes;

    uint256 public roundNumber;
    mapping(address => mapping(uint256 => uint256)) private voters;
    mapping(address => bool) private isVoter;

    mapping(address => mapping(uint256 => bool)) private userClaimedProject;
    uint256 public totalAmountAirdropped;
    mapping(address => uint256) public amountClaimed;

    Project public bestProject;

    uint256 public airdropBalance;
    uint256 public totalHoldersBalance;
    uint256 public airdropDate;

    uint256 public projectCount;
    uint256 public votesCount;
    mapping(uint256 => Project) public projects;

    mapping(address => mapping(uint256 => mapping(uint256 => bool)))
        private userHasClaimedProject;

    event ProjectUploaded(
        uint256 id,
        string img,
        string name,
        string description,
        string category,
        string url,
        string twitter,
        uint256 votes,
        address tokenAddress,
        string tokenSymbol,
        uint256 tokenDecimals,
        bool active
    );

    struct Project {
        uint256 id;
        string img;
        string name;
        string description;
        string category;
        string url;
        string twitter;
        uint256 votes;
        address tokenAddress;
        string tokenSymbol;
        uint256 tokenDecimals;
        bool active;
    }

    function initialize(address _tokenAddress) public initializer {
        dexRouter = DexRouter(ROUTER);
        artikToken = _tokenAddress;
        admin = payable(msg.sender);
        shareholderCount = 0;
        roundNumber = 1;
        totalAmountAirdropped = 0;
        projectCount = 0;
        votesCount = 0;
        accumulatedEthForAirdrop = 0;
        totalHoldersBalance = 0;
        airdropBalance = 0;
    }

    modifier onlyToken() {
        require(msg.sender == artikToken, "sender is not the token");
        _;
    }

    modifier onlyAdmin() {
        require(msg.sender == admin);
        _;
    }

    function uploadProject(
        string memory _img,
        string memory _name,
        string memory _description,
        string memory _category,
        string memory _url,
        string memory _twitter,
        bytes20 _tokenAddress,
        string memory _tokenSymbol,
        uint256 _tokenDecimals
    ) external onlyAdmin {
        require(msg.sender != address(0));
        require(bytes(_img).length > 0);
        require(bytes(_name).length > 0);
        require(bytes(_description).length > 0);
        require(bytes(_category).length > 0);
        require(bytes(_url).length > 0);
        require(address(_tokenAddress) != address(0x0));
        require(bytes(_tokenSymbol).length > 0);
        require(_tokenDecimals > 0);

        projectCount = projectCount.add(1);
        projects[projectCount] = Project(
            projectCount,
            _img,
            _name,
            _description,
            _category,
            _url,
            _twitter,
            0,
            address(_tokenAddress),
            _tokenSymbol,
            _tokenDecimals,
            true
        );

        emit ProjectUploaded(
            projectCount,
            _img,
            _name,
            _description,
            _category,
            _url,
            _twitter,
            0,
            address(_tokenAddress),
            _tokenSymbol,
            _tokenDecimals,
            true
        );
    }

    function changeProjectState(
        uint256 _projectId,
        bool _active
    ) external onlyAdmin {
        projects[_projectId].active = _active;
    }

    function voteProject(uint256 _projectId) external {
        require(
            voters[msg.sender][_projectId] != roundNumber,
            "voters can vote the same project only 1 time"
        );
        require(
            shareholderIndexes[msg.sender] > 0,
            "voters must be token holders"
        );
        require(_projectId != 0, "projectId canno be 0");

        projects[_projectId].votes = projects[_projectId].votes.add(1);
        voters[msg.sender][_projectId] = roundNumber;
        isVoter[msg.sender] = true;
        votesCount = votesCount.add(1);
    }

    function resetProjectVotes(uint256 _projectId) external onlyAdmin {
        projects[_projectId].votes = 0;
    }

    function setBestProject(uint256 _projectId) external onlyAdmin {
        bestProject = projects[_projectId];
    }

    function setAirdropDate(uint256 _days) public onlyAdmin {
        airdropDate = block.timestamp + (1 days * _days);
    }

    function initializeAirdrop(uint256 _days) external onlyAdmin {
        require(block.timestamp >= airdropDate);

        uint256 STABLE_COINBalance = IERC20(STABLE_COIN).balanceOf(
            address(this)
        );

        require(STABLE_COINBalance > 0);
        require(bestProject.id != 0);

        totalHoldersBalance = calculateTVL(true);
        nextRound();

        IERC20(STABLE_COIN).approve(ROUTER, STABLE_COINBalance);
        (uint256 amountWethMin, ) = getAmountOutMin(
            STABLE_COINBalance,
            STABLE_COIN,
            WETH
        );
        IERC20(WETH).approve(ROUTER, amountWethMin);

        uint256 buyBackFee = STABLE_COINBalance.mul(BUY_BACK_FEE).div(100);
        uint256 amountToSwap = STABLE_COINBalance.sub(buyBackFee);

        // Buy back mechanism
        buyBack(buyBackFee);

        // Swap BUSD -> BNB -> Airdrop Token
        buyAirdropTokens(amountToSwap, bestProject.tokenAddress);
        setAirdropDate(_days);

        airdropBalance = IERC20(bestProject.tokenAddress).balanceOf(
            address(this)
        );

        //accumulatedEthForAirdrop = airdropBalance;
        (accumulatedEthForAirdrop, ) = getAmountOutMin(
            airdropBalance,
            bestProject.tokenAddress,
            WETH
        );
    }

    function buyAirdropTokens(uint256 _amount, address _project) private {
        swapTokensForETH(_amount, STABLE_COIN);
        swapETHForTokens(address(this).balance, _project);
    }

    function buyBack(uint256 _fee) private {
        swapTokensForETH(_fee, STABLE_COIN);
        swapETHForTokens(address(this).balance, artikToken);
        IERC20(artikToken).transfer(
            address(0x0),
            IERC20(artikToken).balanceOf(address(this))
        );
    }

    function claimAirdrop() public {
        uint256 airdrop = calculateAirdropAmount(msg.sender);
        IERC20(bestProject.tokenAddress).transfer(msg.sender, airdrop);

        isVoter[msg.sender] = false;
        userHasClaimedProject[msg.sender][roundNumber][bestProject.id] = true;

        (uint256 amountWethMin, ) = getAmountOutMin(
            airdrop,
            bestProject.tokenAddress,
            WETH
        );
        (uint256 amountStableMin, ) = getAmountOutMin(
            amountWethMin,
            WETH,
            STABLE_COIN
        );

        amountClaimed[msg.sender] = amountClaimed[msg.sender].add(
            amountStableMin
        );
        totalAmountAirdropped = totalAmountAirdropped.add(amountStableMin);
    }

    function calculateTVL(bool _onlyVoters) public view returns (uint256) {
        uint256 currentBalance = 0;
        for (uint256 i = 0; i < shareholders.length; i++) {
            if ((_onlyVoters && isVoter[shareholders[i]]) || !_onlyVoters) {
                currentBalance = currentBalance.add(
                    IERC20(artikToken).balanceOf(shareholders[i])
                );
            }
        }
        return currentBalance;
    }

    function calculateAirdropAmount(
        address _shareholder
    ) public view returns (uint256) {
        require(shareholderIndexes[_shareholder] > 0, "not a shareholder");
        require(isVoter[_shareholder] == true, "not a voter");
        require(
            _shareholder != address(0x0),
            "shareholder cannot be address of 0"
        );
        require(totalHoldersBalance > 0, "total holders balance less than 0");

        require(
            userHasClaimedProject[_shareholder][roundNumber][bestProject.id] !=
                true,
            "shareholder has already claimed this airdrop"
        );

        uint256 holderPercentage = calculateHolderPercentage(
            _shareholder,
            totalHoldersBalance
        );
        uint256 airdrop = airdropBalance.mul(holderPercentage).div(100);

        return airdrop;
    }

    function calculateHolderPercentage(
        address _shareholder,
        uint256 _totalHoldersBalance
    ) private view returns (uint256) {
        // 100 : x = totalHoldersBalance : holderBalance
        uint256 holderBalance = IERC20(artikToken).balanceOf(_shareholder);
        uint256 holderPercentage = holderBalance.mul(100).div(
            _totalHoldersBalance
        );
        return holderPercentage;
    }

    function calculateAirdropPercentage(
        address _shareholder
    ) external view returns (uint256) {
        require(
            _shareholder != address(0x0),
            "shareholder address cannot be 0"
        );
        require(shareholderIndexes[_shareholder] > 0, "not a shareholder");

        uint256 holderBalance = IERC20(artikToken).balanceOf(_shareholder);
        require(
            holderBalance > 0,
            "shareholder balance must be greater than 0"
        );

        uint256 holders_balance = 0;
        if (totalHoldersBalance > 0) {
            holders_balance = totalHoldersBalance;
        } else {
            holders_balance = calculateTVL(true);
        }

        uint256 holderPercentage = calculateHolderPercentage(
            _shareholder,
            holders_balance
        );
        uint256 airdrop = accumulatedEthForAirdrop.mul(holderPercentage).div(
            100
        );

        require(airdrop > 0, "airdrop amount must be greater than 0");
        (uint256 airdropInArtik, ) = getAmountOutMin(airdrop, WETH, artikToken);

        // 100 : x = artik balance : airdrop in artik
        return airdropInArtik.mul(100).div(holderBalance);
    }

    function addShareHolder(address _shareholder) external onlyToken {
        require(_shareholder != address(0x0));

        if (shareholderIndexes[_shareholder] <= 0) {
            shareholders.push(_shareholder);
            shareholderCount = shareholderCount.add(1);
            shareholderIndexes[_shareholder] = shareholderCount;
        }
    }

    function removeShareHolder(address _shareholder) external onlyToken {
        require(_shareholder != address(0x0));

        if (shareholderIndexes[_shareholder] > 0) {
            shareholders[shareholderIndexes[_shareholder] - 1] = shareholders[
                shareholders.length - 1
            ];
            shareholders.pop();
            shareholderCount = shareholderCount.sub(1);
            shareholderIndexes[_shareholder] = 0;
        }
    }

    function swapETHForTokens(uint256 _amount, address _token) private {
        require(_amount > 0);
        require(_token != address(0x0));
        require(address(this).balance >= _amount, "balance less than _amount");

        address[] memory path = new address[](2);
        path[0] = WETH;
        path[1] = _token;

        dexRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{
            value: _amount
        }(0, path, address(this), block.timestamp);
    }

    function swapTokensForETH(uint256 _amount, address _token) private {
        require(_amount > 0);
        require(_token != address(0x0));
        require(
            IERC20(_token).balanceOf(address(this)) >= _amount,
            "balance less than _amount"
        );

        address[] memory path = new address[](2);
        path[0] = _token;
        path[1] = WETH;

        dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(
            _amount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

    function getAmountOutMin(
        uint256 _amount,
        address _tokenIn,
        address _tokenOut
    ) private view returns (uint256, address[] memory) {
        address[] memory path = new address[](2);
        path[0] = _tokenIn;
        path[1] = _tokenOut;

        uint256[] memory amountOutMins = dexRouter.getAmountsOut(_amount, path);
        return (amountOutMins[1], path);
    }

    function swapTokens() external onlyToken {
        uint256 buyBackFee = address(this).balance.mul(BUY_BACK_FEE).div(100);
        accumulatedEthForAirdrop = accumulatedEthForAirdrop
            .add(address(this).balance)
            .sub(buyBackFee);

        IERC20(WETH).approve(ROUTER, address(this).balance);
        swapETHForTokens(address(this).balance, STABLE_COIN);
    }

    function nextRound() public onlyAdmin {
        roundNumber = roundNumber.add(1);
    }

    function withdrawRemainingAirdrop(address _token) external onlyAdmin {
        require(_token != address(0x0));
        uint256 remainingBalance = IERC20(_token).balanceOf(address(this));
        require(remainingBalance > 0);
        IERC20(_token).transfer(admin, remainingBalance);
    }

    function hasVotedProject(uint256 _projectId) external view returns (bool) {
        if (voters[msg.sender][_projectId] == roundNumber) {
            return true;
        } else {
            return false;
        }
    }

    receive() external payable {}
}


// File: @openzeppelin/contracts/utils/math/SafeMath.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)

pragma solidity ^0.8.0;

// CAUTION
// This version of SafeMath should only be used with Solidity 0.8 or later,
// because it relies on the compiler's built in overflow checks.

/**
 * @dev Wrappers over Solidity's arithmetic operations.
 *
 * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler
 * now has built in overflow checking.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            uint256 c = a + b;
            if (c < a) return (false, 0);
            return (true, c);
        }
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b > a) return (false, 0);
            return (true, a - b);
        }
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
            // benefit is lost if 'b' is also tested.
            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
            if (a == 0) return (true, 0);
            uint256 c = a * b;
            if (c / a != b) return (false, 0);
            return (true, c);
        }
    }

    /**
     * @dev Returns the division of two unsigned integers, with a division by zero flag.
     *
     * _Available since v3.4._
     */
    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a / b);
        }
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.
     *
     * _Available since v3.4._
     */
    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a % b);
        }
    }

    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return a - b;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        return a * b;
    }

    /**
     * @dev Returns the integer division of two unsigned integers, reverting on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator.
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * reverting when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return a % b;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {trySub}.
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b <= a, errorMessage);
            return a - b;
        }
    }

    /**
     * @dev Returns the integer division of two unsigned integers, reverting with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a / b;
        }
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * reverting with custom message when dividing by zero.
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {tryMod}.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a % b;
        }
    }
}


// File: @openzeppelin/contracts/token/ERC20/IERC20.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `from` to `to` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
}


// File: @openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)

pragma solidity ^0.8.1;

/**
 * @dev Collection of functions related to the address type
 */
library AddressUpgradeable {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     *
     * [IMPORTANT]
     * ====
     * You shouldn't rely on `isContract` to protect against flash loan attacks!
     *
     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
     * constructor.
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize/address.code.length, which returns 0
        // for contracts in construction, since the code is only stored at the end
        // of the constructor execution.

        return account.code.length > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain `call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCall(target, data, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");

        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");

        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the
     * revert reason using the provided one.
     *
     * _Available since v4.3._
     */
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length > 0) {
                // The easiest way to bubble the revert reason is using memory via assembly
                /// @solidity memory-safe-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}


// File: @openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)

pragma solidity ^0.8.2;

import "../../utils/AddressUpgradeable.sol";

/**
 * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed
 * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an
 * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer
 * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.
 *
 * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be
 * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in
 * case an upgrade adds a module that needs to be initialized.
 *
 * For example:
 *
 * [.hljs-theme-light.nopadding]
 * ```
 * contract MyToken is ERC20Upgradeable {
 *     function initialize() initializer public {
 *         __ERC20_init("MyToken", "MTK");
 *     }
 * }
 * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {
 *     function initializeV2() reinitializer(2) public {
 *         __ERC20Permit_init("MyToken");
 *     }
 * }
 * ```
 *
 * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as
 * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.
 *
 * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure
 * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.
 *
 * [CAUTION]
 * ====
 * Avoid leaving a contract uninitialized.
 *
 * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation
 * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke
 * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:
 *
 * [.hljs-theme-light.nopadding]
 * ```
 * /// @custom:oz-upgrades-unsafe-allow constructor
 * constructor() {
 *     _disableInitializers();
 * }
 * ```
 * ====
 */
abstract contract Initializable {
    /**
     * @dev Indicates that the contract has been initialized.
     * @custom:oz-retyped-from bool
     */
    uint8 private _initialized;

    /**
     * @dev Indicates that the contract is in the process of being initialized.
     */
    bool private _initializing;

    /**
     * @dev Triggered when the contract has been initialized or reinitialized.
     */
    event Initialized(uint8 version);

    /**
     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,
     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.
     */
    modifier initializer() {
        bool isTopLevelCall = !_initializing;
        require(
            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),
            "Initializable: contract is already initialized"
        );
        _initialized = 1;
        if (isTopLevelCall) {
            _initializing = true;
        }
        _;
        if (isTopLevelCall) {
            _initializing = false;
            emit Initialized(1);
        }
    }

    /**
     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the
     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be
     * used to initialize parent contracts.
     *
     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original
     * initialization step. This is essential to configure modules that are added through upgrades and that require
     * initialization.
     *
     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in
     * a contract, executing them in the right order is up to the developer or operator.
     */
    modifier reinitializer(uint8 version) {
        require(!_initializing && _initialized < version, "Initializable: contract is already initialized");
        _initialized = version;
        _initializing = true;
        _;
        _initializing = false;
        emit Initialized(version);
    }

    /**
     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the
     * {initializer} and {reinitializer} modifiers, directly or indirectly.
     */
    modifier onlyInitializing() {
        require(_initializing, "Initializable: contract is not initializing");
        _;
    }

    /**
     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.
     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized
     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called
     * through proxies.
     */
    function _disableInitializers() internal virtual {
        require(!_initializing, "Initializable: contract is initializing");
        if (_initialized < type(uint8).max) {
            _initialized = type(uint8).max;
            emit Initialized(type(uint8).max);
        }
    }
}

