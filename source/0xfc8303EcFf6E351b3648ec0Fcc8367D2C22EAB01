// SPDX-License-Identifier: MIT
pragma solidity ^0.8.12;

interface IWalletStorage
{
    function getBalance(address acc) external view returns(uint);
    function getAllow(address acc, address spender) external view returns (uint);
    function addBalance(address acc, uint amount) external;
    function subBalance(address acc, uint amount) external;
    function allow(address acc, address rec, uint amount) external;
}
interface IUserStorage
{
    function isUserExistByAddress(address user) external view returns(bool);
    function isUserExistById(uint id) external view returns(bool);
    function getReferalByAddress(address userAddress) external view returns(uint);
    function getReferalById(uint id) external view returns(uint);
    function getUserByAddress(address userAddress) external view returns(uint,uint,uint,uint8,uint);
    function getUserById(uint id) external view returns(address,uint,uint,uint8,uint);
    function getUserIdByAddress(address acc) external view returns(uint);
    function getUserAddressById(uint id) external view returns(address);
    function getUserDepositeTeam(uint id) external view returns(uint);
    function getUserStatusLVL(uint id) external view returns(uint8);
    function addUser(address user, uint referalId) external;
    function addReferal (uint referalId) external;
    function updateUserDepositeTeam(uint userId,uint depositeTeam) external;
    function updateUserStatus(uint userId) external;
    function updateUserTeamCount(uint userId,uint team) external;
}
interface ITermsStorage
{
    function getTermsLength() external view returns(uint);
    function getDepositePercent(uint8 lvl) external view returns(uint8);
    function getFullReferalPercent() external view returns(uint);
    function getOpenedLevel(uint lvl) external view returns(uint8);
    function getReferalPercent(uint lvl) external view returns(uint);
    function getFirstLineCount(uint lvl) external view returns(uint);
    function getPersonalStacking(uint lvl) external view returns(uint);
    function getTeamStacking(uint lvl) external view returns(uint);
    function getFirstLineStatusLevelCount(uint lvl) external view returns(uint);
}
interface IDepositeStorage
{
    function getDeposite(address acc) external view returns (uint);
    function getDepDate (address acc) external view returns(uint);
    function addDep(address acc, uint amount) external;
    function subDep(address acc, uint amount) external;
    function setDepDate(address acc, uint date) external;
}
interface IFrozenStorage
{
    function getFrozenDate(uint id) external view returns(uint);
    function getFrozenTokens(uint id) external view returns (uint);
    function setFrozenDate(uint id,uint date) external;
    function setFrozenTokens(uint id, uint tokens) external;
}
interface ISupplyStorage
{
    function getSupply() external view returns(uint, uint);
    function subTokenSupply(uint amount)  external;
    function addTokenSupply(uint amount)  external;
}
interface ITeam
{
    function getTeamCountLVL(uint id, uint8 lvl) external view returns (uint);
    function getTeamCountStats(uint id) external view returns (uint);
    function addTeamer (uint id, uint8 lvl) external;
    function addTeameStatus (uint id) external;
    function clearTeameStatus (uint id)  external;
}
interface IReferalFirstLine
{
    function getReferalsCount(uint id) external view returns (uint);
    function getReferals(uint id) external view returns(uint[] memory);
    function addReferal(uint id, uint refId ) external;    
}
interface IUnfrozen
{
    function getCount() external view returns (uint);
    function getUnfrozenById(uint userId) external view returns (address);
    function getUnfrozenByAddress(address acc) external view returns (bool);
    function getExtra(uint balance) external view returns (uint8);
    function setUnfrozen (address acc) external;
}
interface IBanStorage
{
    function ban(address user, uint toDay) external;
    function unBan(address user) external;
    function isBanned(address user) external view returns (bool); 
} 
interface IController 
{
    function transfer(address owner, address recipient, uint amount) external returns (bool);
    function approve(address owner,address spender, uint amount) external returns (bool);
    function register(address user, uint referlaId) external;
    function updateStatus(address acc)  external;
    function deposite (address user,uint amount)external returns(bool);
    function withdrawProfit(address user) external;
    function withdrawAll(address user) external;
    function reinvest(address user) external;
    function setUnfrozenUser(address user) external;
    function destroyToken(address acc, uint amount) external ;
    function addTokenforCoin(address acc, uint amount) external;
    function burn(uint amount) external;
    function pay(address acc, uint amount) external returns(bool, uint,uint);
}
interface IView 
{
    function isUserExist(address acc) external view returns(bool);
    function isUserExistById(uint id) external view returns(bool);
    function getReferalIdById(uint id) external view returns(uint);
    function getAddressById(uint id) external view returns (address);
    function getIdByAddress(address acc)external view returns(uint);
    function getUser(uint id)external view returns(address,uint,uint,uint8,uint);
    function getRefCount(uint id, uint8 lvl) external view returns (uint);
    function getStatsCount(uint id) external view returns (uint);
    function checkUpdate(uint id) external view returns(bool);
    function getLine (uint id) external view returns (uint[] memory);
    function totalSupply() external view returns (uint);
    function getEmission() external view returns(uint);
    function balanceOf(address account) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);
    function getFrozenToken(address acc) external view returns(uint);
    function getFrozenDate(address acc) external view returns(uint);
    function balanceWithFrozen(address acc) external view returns(uint);
    function getDeposite(address acc) external view returns(uint);
    function getDepositeDate(address acc) external view returns(uint);
    function getDepositeProfit(address acc) external view returns(uint);
}
interface IViewV2 is IView
{
    function rewardPass(uint userId, uint8 lvl)external view returns(bool);
    function findReferalReward(uint amount, uint8 line) external view returns (uint);
    function getClearPercent(uint amount) external view returns(uint);
    function getCount() external  view returns (uint);
    function getUnfrozenById(uint userId) external  view returns (address);
    function getUnfrozenByAddress(address acc) external  view returns (bool);
    function getExtra(uint balance) external  view returns (uint8);
}
abstract contract Context 
{
    function _msgSender() internal view virtual returns (address) 
    {
        return msg.sender;
    }
    function _msgData() internal view virtual returns (bytes calldata) 
    {
        this; 
        return msg.data;
    }
}
abstract contract OwnableV2 is Context
{
    address _owner;
    address public _newOwner;
    constructor()  
    {
        _owner = payable(msg.sender);
    }

    modifier onlyOwner() 
    {
        require(_msgSender() == _owner, "Only owner");
        _;
    }

    function changeOwner(address newOwner) onlyOwner public
    {
        _newOwner = newOwner;
    }
    function confirm() public
    {
        require(_newOwner == msg.sender);
        _owner = _newOwner;
    }
}
abstract contract ContractOwnerV2 is OwnableV2
{
    address _contractOwner;

    modifier isContractOwner()
    {
        require(msg.sender == _contractOwner, "no access");
        _;
    }
    function setContractOwner(address contractOwner) onlyOwner public 
    {
        _contractOwner = contractOwner;
    }
}


contract ControllerV3 is IController, ContractOwnerV2 
{
    /// OLD
    IWalletStorage walletStorage = IWalletStorage(0x49B423C4dda814D12dBe56101aAE76d2F3517F1e); 
    IUserStorage userStorage = IUserStorage(0xEec6B20c9298fBCF787Bbc6aEDEe1028BB0D06D5);
    IViewV2 V; 
    IDepositeStorage depositeStorage = IDepositeStorage(0x682a45E21f9F781f5090EacFE9797383E1FBDD6F);
    IUnfrozen unfrozen = IUnfrozen(0xa651268e502252b7471a89F7409a5A1Fc5836c83);
    IFrozenStorage frozenStorage = IFrozenStorage(0x921A21547b394C2FA696BE8f81AE7CFf8c288e09);
    ISupplyStorage supplyStorage = ISupplyStorage(0xb268C21642c455f2BA3C2B3c6A2692f28fa205CE);
    ITeam team = ITeam(0xa316b11DEf2f93aDfD3C9CB404c88794c1704430);
    IReferalFirstLine firstLine = IReferalFirstLine(0x512646bEef87433ab7F275f2bB62d1A6E62698fF);
    ITermsStorage terms = ITermsStorage(0x75f1e7da1375bc77499314DE7971aC50d63320c4);
    IBanStorage banStorage = IBanStorage(0x0E66dB1e34eCC82D3C822735B646ed2AB822db37);

    uint private _twoWeek = 1209600;
 
    address EVOMG = 0x6eC49a22F6EA8b271d188A92AA6BFd23E5DE5F8f;
    address _proxy = 0x8089e55d71e7E27B57C388990D4E8B7bbFA28799;
    
    constructor (address _view) 
    {
        V = IViewV2(_view);
    }


    modifier isEMG () 
    {
        require(msg.sender == EVOMG, "no app");
        _;
    }
    modifier isRegister(address userAddress)
    {
       require(V.isUserExist(userAddress), "User not registered");
       _;
    }
    modifier isProxy() 
    {
        require(msg.sender == _proxy, "no proxy");
        _;
    }
    modifier isBanned(address userCheck)
    {
        require( !banStorage.isBanned(userCheck), "User banned");
       _;
    }



/// TOKEN           
    function transfer(address owner, address recipient, uint amount) isContractOwner isBanned(owner) public returns (bool)
    {
        uint balance = V.balanceWithFrozen(owner);
        require(balance >= amount, "not enougth token");
        _trasfer(owner, recipient, amount);
        return true;
    }
    function approve(address owner, address spender, uint amount)isContractOwner isBanned(owner) public returns (bool)
    {
        walletStorage.allow(owner, spender, amount);
        return true;
    } 
    function burn(uint amount) isContractOwner public
    {
        require(V.balanceWithFrozen(msg.sender) >= amount,"much to burn");
        _trasfer(msg.sender, payable(address(0x000000000000000000000000000000000000dEaD)), amount);
    }
///

/// USER
    function register(address user, uint refId) isEMG() isEMG public
    {
        require(!V.isUserExist(user), "Alredy register");
        if(!V.isUserExistById(refId))
        {
            refId = 1;
        }
        userStorage.addUser(user, refId);
        uint id = V.getIdByAddress(user);
        firstLine.addReferal(id, refId);
        uint8 rewardLine = 0;
        bool isOwner = false;
        while(rewardLine < terms.getTermsLength() && !isOwner)
        {
            team.addTeamer(refId, rewardLine); 
            userStorage.addReferal(refId);     
            if (refId == 1)
            {
                isOwner = true;
            }
            refId = V.getReferalIdById(refId);
            rewardLine++;
        }
    }
    function updateStatus(address acc) public
    {
        uint id = V.getIdByAddress(acc);
        require(V.checkUpdate(id));
        userStorage.updateUserStatus(id);
    }
///
   


/// Deposite
    function deposite (address user, uint amount) isEMG isRegister(user)  public returns(bool)
    {
        require(V.balanceOf(user) >= amount, "Not enought tokens");
        uint profit = V.getDepositeProfit(user);
        walletStorage.subBalance(user, amount);
        uint userId = V.getIdByAddress(user);
        supplyStorage.addTokenSupply(profit);     
        depositeStorage.setDepDate(user, block.timestamp);
        depositeStorage.addDep(user, amount + profit);
        addDepositeTeamAll(userId, amount + profit);   
        return true;
    }
    function withdrawProfit(address user) isEMG isRegister(user) isBanned(user) public 
    {
        _withdrawProfit(user);
    }
    function withdrawAll(address user) isEMG isRegister(user) isBanned(user) public 
    {
        require(!V.getUnfrozenByAddress(user), "User unfrozened");
        uint userId = V.getIdByAddress(user);    
        uint frozenDate = frozenStorage.getFrozenDate(userId);
        if (frozenDate != 0)
        { 
            require(block.timestamp >= frozenDate + _twoWeek , "wait two week");
        }
        uint userDeposite = V.getDeposite(user);
        require(userDeposite > 0, "Not enought tokens");
        uint profit = V.getDepositeProfit(user);
        if (profit > V.getEmission())
        {
            profit = V.getEmission();
        }
        supplyStorage.addTokenSupply(profit);          
        walletStorage.addBalance(user, userDeposite + profit);
        depositeStorage.setDepDate(user, block.timestamp);
        depositeStorage.subDep(user, userDeposite);
        frozenStorage.setFrozenDate(userId, block.timestamp);
        frozenStorage.setFrozenTokens(userId, userDeposite);
        subDepositeTeamAll(userId, userDeposite);
    }
    function reinvest(address user) isEMG isRegister(user) isBanned(user) public 
    {
        uint id = V.getIdByAddress(user);
        uint profit = V.getDepositeProfit(user);
        require(profit <= V.getEmission(), "not enought emission");
        depositeStorage.addDep(user, profit);
        depositeStorage.setDepDate(user, block.timestamp);
        addDepositeTeamAll(id, profit);
        supplyStorage.addTokenSupply(profit); 
    }
///


/// UNFROZEN
    function setUnfrozenUser(address user) isEMG isRegister(user) public 
    {
        require(!V.getUnfrozenByAddress(user));
        _withdrawProfit(user);
        unfrozen.setUnfrozen(user);
    }
///

    
/// OLD API
    function pay(address acc, uint amount) public override returns(bool, uint,uint) 
    {
        return (false, 0,amount);
    }
    function destroyToken(address acc, uint amount) isProxy isBanned(acc) public
    {
        require(amount <= V.balanceOf(acc), "Not enought tokens");
        walletStorage.subBalance(acc, amount);
        supplyStorage.subTokenSupply(amount);
    }
    function addTokenforCoin(address acc, uint amount) isProxy isBanned(acc) public
    {
        walletStorage.addBalance(acc, amount);
        supplyStorage.addTokenSupply(amount);
    }
///



/// PRIVATE
    function _trasfer(address owner, address repicient, uint amount) private
    {
        walletStorage.subBalance(owner, amount);
        walletStorage.addBalance(repicient, amount);
    }
    function addDepositeTeamAll(uint id, uint amount) private 
    {
        uint refId = userStorage.getReferalById(id);
        uint8 lvl = 0;
        bool isOwner = false;
        while (lvl < terms.getTermsLength() && !isOwner)
        {
            uint depositeTeam = userStorage.getUserDepositeTeam(refId);
            userStorage.updateUserDepositeTeam(refId, depositeTeam+amount);
            if (refId == 1)
            {
                isOwner = true;
            }
            refId = userStorage.getReferalById(refId);
            lvl++;
        }
    }
    function subDepositeTeamAll(uint id, uint amount) private 
    {
        uint refId = userStorage.getReferalById(id);
        uint lvl = 0;
        bool isOwner = false;
        while (lvl < terms.getTermsLength() && !isOwner)
        {
            uint depositeTeam = userStorage.getUserDepositeTeam(refId);
            if (depositeTeam >= amount)
            {
                userStorage.updateUserDepositeTeam(refId, depositeTeam - amount);
            } 
            else 
            {
                userStorage.updateUserDepositeTeam(refId, 0);
            }
            
            if (refId == 1)
            {
                isOwner = true;
            }
            refId = userStorage.getReferalById(refId);
            lvl++;
        }
    }
    function _withdrawProfit(address acc) private
    {
        uint profit = V.getDepositeProfit(acc);
        require(profit > 0, "No profit");
        require (profit <= V.getEmission(), "Not enought supply");
        uint clearProfit = V.getClearPercent(profit);
        uint userId = userStorage.getUserIdByAddress(acc);
        uint NextReferalId = userStorage.getReferalById(userId);
        walletStorage.addBalance(acc, clearProfit);
        depositeStorage.setDepDate(acc, block.timestamp);
        for (uint8 rewardLine = 0; rewardLine < terms.getTermsLength(); rewardLine++ )
        {
            address rewardAddress; 
            if (V.rewardPass(NextReferalId, rewardLine))
            {
                rewardAddress =  userStorage.getUserAddressById(NextReferalId);
            }
            else
            {
                rewardAddress =  userStorage.getUserAddressById(1);
            }
            uint reward = V.findReferalReward(profit,rewardLine);
            walletStorage.addBalance(rewardAddress, reward);
            NextReferalId = userStorage.getReferalById(NextReferalId);
        }
        supplyStorage.addTokenSupply(profit);
    }
///

/// ADMIN
    function setView (address newAdr)onlyOwner public
    {
        V = IViewV2(newAdr);
    }
    function setTerms(address termsAdr) onlyOwner public 
    {
        terms = ITermsStorage(termsAdr);
    }
    function setUnfrozen(address newAdr) onlyOwner public
    {
        unfrozen = IUnfrozen(newAdr);
    }
    function setEVO(address evo) onlyOwner public
    {
        EVOMG = evo;
    }
    function setBan (address ban) onlyOwner public
    {
        banStorage = IBanStorage(ban);
    }
///
}