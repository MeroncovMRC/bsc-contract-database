{"Consortium.sol":{"content":"pragma experimental ABIEncoderV2;\r\npragma solidity ^0.6.12;\r\n// SPDX-License-Identifier: MIT\r\n\r\n// BNB Smart Chain Testnet: 0x43995D3CFcaD6feD4e42ff5A1FABe1fe3C860637\r\n// BNB Smart Chain Mainnet: 0xa45CA777a570576b9449ae71D20B3cE7e86A20F0\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./Utils.sol\";\r\nimport \"./iDistributor.sol\";\r\nimport \"./ConsortiumData.sol\";\r\nimport \"./Proxy.sol\";\r\n\r\n// This contract is used for IoVGC (Internet of Vehicles Global Consortium)\r\n// This consortium owns the initial IoVT tokens.\r\n// All payments and another operations in this consortium must be decided between consortium members.\r\n// First of decision a consortium member propose this decision to the contract and another members can approve or reject this proposal.\r\n// If at least 2/3 of all members approve the proposal, it finally will be approved.\r\n// If more than 1/3 of all members reject the proposal, it finally will be rejected.\r\n// If more than 30 days passes from the proposal time, it finally will be expired.\r\n// Before the final approval or rejection of the proposal at most during the 30 days after the proposal time,\r\n//   members can accept or reject the proposal, or change their votes.\r\n// Members also propose to add a new member, remove a current member or change the IoVGC consortium contract.\r\ncontract IoVGC is ConsortiumData, Proxy {\r\n    using Strings for string;\r\n    using SafeMath for uint;\r\n\r\n    //****************************************************************************\r\n    //* Events\r\n    //****************************************************************************\r\n    event ProposalSubmitted(uint indexed _proposalId);\r\n    event ProposalVoted(uint indexed _proposalId, address indexed _memberAddress);\r\n    event ProposalApproved(uint indexed _proposalId);\r\n    event ProposalRejected(uint indexed _proposalId);\r\n    event ProposalExpired(uint indexed _proposalId);\r\n    event NewMemberAdded(uint indexed _proposalId, address indexed _newMember);\r\n    event MemberRemoved(uint indexed _proposalId, address indexed _removedMember);\r\n    event ConsortiunChanged(uint indexed _proposalId, address indexed _newConsortium);\r\n    event FreeVotingApproved(uint indexed _proposalId, string _description);\r\n    event SendDataApproved(uint indexed _proposalId, string _description);\r\n\r\n    //****************************************************************************\r\n    //* Modifiers\r\n    //****************************************************************************\r\n    modifier isConsortium {\r\n        require(IoVT.getOwner() == address(this), \"This contract is not consortium.\");\r\n        _;\r\n    }\r\n    \r\n    modifier isMember {\r\n        require(members[msg.sender].isMember, \"You are not member of IoVGC.\");\r\n        _;\r\n    }\r\n\r\n    modifier isProposalIdValid(uint _proposalId) {\r\n        require(_proposalId \u003c proposals.length, message6);\r\n        _;\r\n    }\r\n\r\n    modifier isDescriptionValid(string memory _description) {\r\n        require(! _description.compare(\"\"), \"Invalid description.\");\r\n        _;\r\n    }\r\n\r\n    modifier isNameValid(string memory _name) {\r\n        require(! _name.compare(\"\"), \"Invalid name.\");\r\n        _;\r\n    }\r\n\r\n    modifier isAddressValid(address _member) {\r\n        require(_member != address(0), \"Invalid member address\");\r\n        _;\r\n    }\r\n\r\n    modifier isValueValid(uint _value) {\r\n        require(_value \u003e 0, \"Invalid value.\");\r\n        _;\r\n    }\r\n\r\n    modifier isIoVTSet {\r\n        require(IoVTAddress != address(0), \"IoVT Address is not set.\");\r\n        _;\r\n    }\r\n\r\n    //****************************************************************************\r\n    //* Main Functions\r\n    //****************************************************************************\r\n    constructor() public {\r\n        memberAddresses.push(msg.sender);\r\n        membersCount = 1;\r\n        members[msg.sender] = Member({\r\n            name: \"Creator\",\r\n            isMember: true,\r\n            id: 0\r\n        });\r\n    }\r\n\r\n// Use this function after deploying the contract. This function sets the IoVT token address.\r\n// Only IoVGC consortium members can send this function.\r\n// Input(s):\r\n//     _IoVTAddress: The address of IoVT token.\r\n    function setIoVTAddress(address _IoVTAddress) public isMember isAddressValid(_IoVTAddress) {\r\n        require(IoVTAddress == address(0), \"You set IoVT address before.\");\r\n        IoVTAddress = _IoVTAddress;\r\n        IoVT = iERC20(IoVTAddress);\r\n    }\r\n\r\n// Use this function to propose adding a new member to the consortium.\r\n// Only IoVGC consortium members can send this function.\r\n// Input(s):\r\n//     _dscription: The description about this proposal.\r\n//     _member: The account address of the proposed new member.\r\n//     _name: The name of the proposed new member.\r\n    function proposeAddMember(string memory _description, string memory _name, address payable _member) public isMember isConsortium isNameValid(_name) isAddressValid(_member) {\r\n        require(! members[_member].isMember, message4);\r\n        _registerProposal(1, _description, _member, address(0), 0, _name, \"\");\r\n    }\r\n\r\n// Use this function to propose removing a current member of the consortium.\r\n// Only IoVGC consortium members can send this function.\r\n//     _dscription: The description about this proposal.\r\n//     _member: The account of the proposed member to be removed.\r\n    function proposeRemoveMember(string memory _description, address payable _member) public isMember isConsortium isAddressValid(_member) {\r\n        require(members[_member].isMember, message7);\r\n        require(membersCount \u003e 1, message13);\r\n        _registerProposal(2, _description, _member, address(0), 0, members[_member].name, \"\");\r\n    }\r\n\r\n// Use this function to propose paying IoVT token (set in IoVTAddress() ) to a specified account or smart contract.\r\n// In executing this proposal, if the receiver account will be a distributor contract, then the function registerReceivedValue() \r\n//   of distributor contract would be run automatically.\r\n// Only IoVGC consortium members can send this function.\r\n// Input(s):\r\n//     _dscription: The description about this proposal.\r\n//     _account: the account or smart contract address you want to pay IoVT token pay to.\r\n//     _value: the amount of IoVT token you want to pay. (trailing zeros for the token decimals)\r\n    function proposePayIoVT(string memory _description, address payable _account, uint _value) public isMember isConsortium isIoVTSet isAddressValid(_account) isValueValid(_value) {\r\n        require(_value \u003c= IoVT.balanceOf(address(this)), message1);\r\n        _registerProposal(3, _description, _account, address(0), _value, \"\", \"\");\r\n    }\r\n\r\n// Use this function to propose paying any ERC-20 (BEP-20) token to a specified account or smart contract.\r\n// Only IoVGC consortium members can send this function.\r\n// Input(s):\r\n//     _dscription: The description about this proposal.\r\n//     _tokenAddress: The address of the specified ERC-20 (BEP-20) token.\r\n//     _account: the account or smart contract address you want to pay the specified token pay to.\r\n//     _value: the amount of the specified token you want to pay. (trailing zeros for the token decimals)\r\n    function proposePayToken(string memory _description, address _tokenAddress, address payable _account, uint _value) public isMember isConsortium isAddressValid(_account) isValueValid(_value) {\r\n        require(_tokenAddress != address(0), message8);\r\n        try iERC20(_tokenAddress).balanceOf(address(this)) returns(uint _balance) {\r\n            require(_value \u003c= _balance, message1);\r\n        }\r\n        catch {\r\n            revert(message8);\r\n        }\r\n        _registerProposal(4, _description, _account, _tokenAddress, _value, \"\", \"\");\r\n    }\r\n\r\n// Use this function to propose paying BNB token to a specified account or smart contract.\r\n// Only IoVGC consortium members can send this function.\r\n// Input(s):\r\n//     _dscription: The description about this proposal.\r\n//     _account: the account or smart contract address you want to pay BNB token pay to.\r\n//     _value: the amount of BNB token you want to pay. (trailing zeros for BNB decimals)\r\n    function proposePayBNB(string memory _description, address payable _account, uint _value) public isMember isConsortium isAddressValid(_account) isValueValid(_value) {\r\n        require(_value \u003c= address(this).balance, message1);\r\n        _registerProposal(5, _description, _account, address(0), _value, \"\", \"\");\r\n    }\r\n\r\n// Use this function to propose delegating to an account or smart contract to pay the specified IoVT token amount from the IoVGC consortium contract.\r\n// Only IoVGC consortium members can send this function.\r\n// Input(s):\r\n//     _dscription: The description about this proposal.\r\n//     _spender: the account or smart contract you want to delegate to.\r\n//     _value: the amount of IoVT token you want to delegate to spend. (trailing zeros for the token decimals)\r\n    function proposeApprovePayIoVT(string memory _description, address payable _spender, uint _value) public isMember isConsortium isIoVTSet isAddressValid(_spender) isValueValid(_value) {\r\n        require(_value \u003c= IoVT.balanceOf(address(this)), message1);\r\n        _registerProposal(6, _description, _spender, address(0), _value, \"\", \"\");\r\n    }\r\n\r\n// Use this function to propose paying the specified amount of IoVT token on behalf of an account or smart contract the delegates IoVGC consortium to pay.\r\n// Only IoVGC consortium members can send this function.\r\n// Input(s):\r\n//     _dscription: The description about this proposal.\r\n//     _sender: The account or smart contract that delegated IoVGC consortium to pay IoVT token.\r\n//     _account: The account or smart contract that you want to pay IoVT token to pay to on behalf of the _sender.\r\n//     _value: The amount of IoVT token you want to pay to the _account on behalf of the _sender.\r\n    function proposePayDelegatedIoVT(string memory _description, address payable _sender, address payable _account, uint _value) public isMember isConsortium isIoVTSet {\r\n        require(_value \u003c= IoVT.balanceOf(_sender), message1);\r\n        _registerProposal(7, _description, _account, _sender, _value, \"\", \"\");\r\n    }\r\n    \r\n// Use this function to propose changing the IoVGC consortium smart contract. \r\n// Executing this proposal:\r\n//     1: Copies all of current consortium members to the new contract.\r\n//     2: Transfer all of the IoVT token amount from this cotract to the new contract.\r\n//     3: Change the owner of IoVT token contract to the new contract.\r\n//     4: So the new contract will be IoVGC consortium contract.\r\n// After executing this proposal, this contract will not any rights and abilities to the IoVT token and none of this contract members can propose or vote.\r\n// Only IoVGC consortium members can send this function.\r\n// Input(s):\r\n//     _dscription: The description about this proposal.\r\n//     _consortium: The new IoVGC consortium smart contract.\r\n    function proposeChangeCosortium(string memory _description, address payable _consortium) public isMember isConsortium isIoVTSet isAddressValid(_consortium) {\r\n        _checkNewConsortium(_consortium);\r\n        _registerProposal(11, _description, _consortium, address(0), 0, \"\", \"\");\r\n    }\r\n\r\n// Use this function to propose changing the IoVGC consortium smart contract. \r\n// Executing this proposal:\r\n//     1: Copies all of current consortium members to the new contract.\r\n//     2: Change the owner of IoVT token contract to the new contract.\r\n//     3: So the new contract will be IoVGC consortium contract.\r\n// Note that executing this proposal will not copy the current consortium members to the new contract.\r\n// After executing this proposal, this contract will not any rights and abilities to the IoVT token and none of this contract members can propose or vote.\r\n// Only IoVGC consortium members can send this function.\r\n// Input(s):\r\n//     _dscription: The description about this proposal.\r\n//     _consortium: The new IoVGC consortium smart contract.\r\n    function proposeChangeCosortiumWithoutMembers(string memory _description, address payable _consortium) public isMember isConsortium isIoVTSet isAddressValid(_consortium) {\r\n        _checkNewConsortium(_consortium);\r\n        _registerProposal(12, _description, _consortium, address(0), 0, \"\", \"\");\r\n    }\r\n\r\n// Use this function to propose blocking a specified account in the IoVT token contract.\r\n// A blocked account cannot send IoVT tokens directly or by a delegated account.\r\n// Only IoVGC consortium members can send this function.\r\n// Input(s):\r\n//     _dscription: The description about this proposal.\r\n//     _account: The account you want to be blocked.\r\n    function proposeBlockAccount(string memory _description, address payable _account) public isMember isConsortium isAddressValid(_account) {\r\n        require(! IoVT.isAccountBlocked(_account), message5);\r\n        _registerProposal(13, _description, _account, address(0), 0, \"\", \"\");\r\n    }\r\n\r\n// Use this function to propose unblocking a specified account in the IoVT token contract.\r\n// Unblocking an account will free it from blocked state. A blocked account cannot send IoVT tokens directly or by a delegated account.\r\n// Only IoVGC consortium members can send this function.\r\n// Input(s):\r\n//     _dscription: The description about this proposal.\r\n//     _account: The account you want to be unblocked.\r\n    function proposeUnlockAccount(string memory _description, address payable _account) public isMember isConsortium isAddressValid(_account) {\r\n        require(IoVT.isAccountBlocked(_account), message9);\r\n        _registerProposal(14, _description, _account, address(0), 0, \"\", \"\");\r\n    }\r\n\r\n// Use this function to propose a free voting.\r\n// Free voting only operate a voting without any operation in blockchain. You can see only the result of voting an its voters.\r\n// Only IoVGC consortium members can send this function.\r\n// Input(s):\r\n//     _dscription: The description about this proposal.\r\n    function proposeFreeVoting(string memory _description) public isMember isConsortium {\r\n        _registerProposal(15, _description, address(0), address(0), 0, \"\", \"\");\r\n    }\r\n\r\n// Use this function to propose sending data to smart contract.\r\n// By executing this proposal you can run any function from another smart contracts if they permitted.\r\n// Only IoVGC consortium members can send this function.\r\n// Note that in executing this proposal all of the outputs will be omitted.\r\n// Input(s):\r\n//     _dscription: The description about this proposal.\r\n//     _smartContractAddress: Address of the specified smart contract that you want to send its function request.\r\n//     _data: The data can you send to the _smartContractAddress. This data must be equivalent to the output of abi.encodeWithSignature() function.\r\n    function proposeSendData(string memory _description, address payable _smartContractAddress, bytes memory _data, uint _value) public isMember isConsortium isAddressValid(_smartContractAddress) {\r\n        _registerProposal(16, _description, _smartContractAddress, address(0), _value, \"\", _data);\r\n    }\r\n\r\n// Use this function to propose changing of one of the target addresses in distributor smart contract.\r\n// A distributor smart contract is a contract that you can pay IoVT token to it and it will pay it to target addresses after its release time.\r\n// Distributor smart contract consists of some portions. Each portion is consist of:\r\n//     1: Portion Id: An ordinal number starting with 0.\r\n//     2: Payment Value: The total payment of this portion.\r\n//     3: Target Address: An address that the share will pay to.\r\n//     4: Release Time: The time that the portion share will release. At first of after release time, the target address will \r\n//        receive the its first share.\r\n//     5: Number of Quarters: All of the payment value will be divided into the number of quarters, the result will be paid to the\r\n//        target address after each quarter next to the release time.\r\n// By executing this proposal you can change one of its target addresses, so the new address can receive the payments.\r\n// Note that you may have multiple distributor smart contracts simultaneously.\r\n// Only IoVGC consortium members can send this function.\r\n// Input(s):\r\n//     _dscription: The description about this proposal.\r\n//     _distributorContract: Address of the distributor smart contract.\r\n//     _portionId: The target address portion id.\r\n//     _targetAccount: The new address for target address.\r\n    function proposeChangeDistributorTargetAddress(string memory _description, address payable _distributorContract, uint _portionId, address payable _targetAccount) public isMember isConsortium isAddressValid(_distributorContract) isAddressValid(_targetAccount) {\r\n        try iDistributor(_distributorContract).getOwner() returns(address _owner) {\r\n            require(_owner == address(this), message14);\r\n        }\r\n        catch {\r\n            revert(message15);\r\n        }\r\n        try iDistributor(_distributorContract).getPortionsCount() returns(uint _portionsCount) {\r\n            require(_portionId \u003c _portionsCount, message2);\r\n        }\r\n        catch {\r\n            revert(message15);\r\n        }\r\n        _registerProposal(17, _description, _targetAccount, _distributorContract, _portionId, \"\", \"\");\r\n    }\r\n    \r\n// Use this function to propose changing of distributor contract owner.\r\n// This operation is used just before changing the IoVGC consortium contract and sets the new consortium contract address as the distributor owner.\r\n// Only IoVGC consortium members can send this function.\r\n// Input(s):\r\n//     _dscription: The description about this proposal.\r\n//     _distributorContract: The address of the distributor smart contract.\r\n//     _newConsortium: The address of new IoGC consortium.\r\n    function proposeChangeDistributorOwner(string memory _description, address payable _distributorContract, address payable _newConsortium) public isMember isConsortium isAddressValid(_distributorContract) isAddressValid(_newConsortium) {\r\n        try iDistributor(_distributorContract).getOwner() returns(address _owner) {\r\n            require(_owner == address(this), message14);\r\n        }\r\n        catch {\r\n            revert(message15);\r\n        }\r\n        _registerProposal(18, _description, _newConsortium, _distributorContract, 0, \"\", \"\");\r\n    }\r\n\r\n// Use this function to vote approval to a specified proposal.\r\n// Before final approving or rejecting this proposal voters can also change their votes.\r\n// All votes are transparent and all people can see each vote.\r\n// A proposal will be finally approved, if and only if at least two third (2/3) of consortium members vote to approve it.\r\n// A proposal will be finally rejected, if and only if more than one third (1/3) of consortium members vote to reject it.\r\n// A proposal will be finally expired, if and only if after 30 days of the proposed time, it cannot be approved or rejected.\r\n// Only IoVGC consortium members can send this function.\r\n// Input(s):\r\n//     _proposalId: The proposal id that you want to approve it. Proposal id is an ordinal number starting with 0.\r\n    function voteApprove(uint _proposalId) public isMember isConsortium isProposalIdValid(_proposalId) {\r\n        Proposal storage _proposal = proposals[_proposalId];\r\n        require(_proposal.approved == 1, message3);\r\n        if (_proposal.offerTime+maxVotingDuration \u003c uint40(block.timestamp) \u0026\u0026 _proposal.approved == 1) {\r\n            _proposal.approved = 4;\r\n            Utils.deleteArrayElement(openProposals, _proposalId);\r\n        } else {\r\n            uint8 _vote = _proposal.votes[msg.sender];\r\n            require(_vote != 2, \"You approved this proposal before.\");\r\n            _proposal.approversCount++;\r\n            if (_vote == 3)\r\n                _proposal.rejectorsCount--;\r\n            _proposal.votes[msg.sender] = 2;\r\n            emit ProposalVoted(_proposalId, msg.sender);\r\n            _checkProposalApproval(_proposalId);\r\n        }\r\n    }\r\n\r\n// Use this function to vote rejection to a specified proposal.\r\n// Before final approving or rejecting this proposal voters can also change their votes.\r\n// All votes are transparent and all people can see each vote.\r\n// A proposal will be finally approved, if and only if at least two third (2/3) of consortium members vote to approve it.\r\n// A proposal will be finally rejected, if and only if more than one third (1/3) of consortium members vote to reject it.\r\n// A proposal will be finally expired, if and only if after 30 days of the proposed time, it cannot be approved or rejected.\r\n// Only IoVGC consortium members can send this function.\r\n// Input(s):\r\n//     _proposalId: The proposal id that you want to reject it. Proposal id is an ordinal number starting with 0.\r\n    function voteReject(uint _proposalId) public isMember isConsortium isProposalIdValid(_proposalId) {\r\n        Proposal storage _proposal = proposals[_proposalId];\r\n        require(_proposal.approved == 1, message3);\r\n        if (_proposal.offerTime+maxVotingDuration \u003c uint40(block.timestamp) \u0026\u0026 _proposal.approved == 1) {\r\n            _proposal.approved = 4;\r\n            emit ProposalExpired(_proposalId);\r\n            Utils.deleteArrayElement(openProposals, _proposalId);\r\n        } else {\r\n            uint8 _vote = _proposal.votes[msg.sender];\r\n            require(_vote != 3, \"You rejected this proposal before.\");\r\n            _proposal.rejectorsCount++;\r\n            if (_vote == 2)\r\n                _proposal.approversCount--;\r\n            _proposal.votes[msg.sender] = 3;\r\n            emit ProposalVoted(_proposalId, msg.sender);\r\n            _checkProposalApproval(_proposalId);\r\n        }\r\n    }\r\n\r\n// You cannot use this function. When changing the consortium contract, this function will be sent automatically from the \r\n//   new IoVGC consortium by the old one to copy members from the old consortium to the new one.\r\n    function pullMembers(string[] memory _names, address[] memory _addresses, uint24[] memory _ids) public {\r\n        require(msg.sender == IoVT.getOwner(), \"You are not authorized to call this function.\");\r\n        uint _currentMembersCount = memberAddresses.length;\r\n        uint _newMembersCount = _names.length;\r\n        membersCount = uint24(_newMembersCount);\r\n        uint i;\r\n        address _memberAddress;\r\n        for (i = 0; i \u003c _currentMembersCount; i++) {\r\n            _memberAddress = memberAddresses[i];\r\n            if (_memberAddress != address(0)) {\r\n                members[_memberAddress].isMember = false;\r\n                memberAddresses[i] = address(0);\r\n            }\r\n        }\r\n        uint j = 0;\r\n        uint _id;\r\n        for (i = 0; i \u003c _newMembersCount; i++) {\r\n            _id = _ids[i];\r\n            while (j \u003c _id) {\r\n                if (j \u003e= _currentMembersCount)\r\n                    memberAddresses.push(address(0));\r\n                j++;\r\n            }\r\n            memberAddresses.push(_addresses[i]);\r\n            members[_addresses[i]] = Member({\r\n                name: _names[i],\r\n                isMember: true,\r\n                id: uint24(_id)\r\n            });\r\n        }\r\n    }\r\n\r\n    //****************************************************************************\r\n    //* Internal Functions\r\n    //****************************************************************************\r\n    function _checkProposalApproval(uint _proposalId) internal {\r\n        Proposal storage _proposal = proposals[_proposalId];\r\n        if (uint(_proposal.approversCount) \u003e= uint(membersCount).mul(quorumCoefficient).sub(1).div(quorumDivisor).add(1)) {\r\n            _proposal.approved = 2;\r\n            _executeProposal(_proposalId);\r\n            emit ProposalApproved(_proposalId);\r\n            Utils.deleteArrayElement(openProposals, _proposalId);\r\n        }\r\n        else if (_proposal.rejectorsCount \u003e uint(membersCount).mul(quorumDivisor-quorumCoefficient).div(quorumDivisor)) {\r\n            _proposal.approved = 3;\r\n            emit ProposalRejected(_proposalId);\r\n            Utils.deleteArrayElement(openProposals, _proposalId);\r\n        }\r\n    }\r\n\r\n    function _executeProposal(uint _proposalId) internal {\r\n        Proposal memory _proposal = proposals[_proposalId];\r\n        if (_proposal.pType == 1) { // Add Member\r\n            require(! members[_proposal.account].isMember, message4);\r\n            memberAddresses.push(_proposal.account);\r\n            membersCount++;\r\n            members[_proposal.account] = Member({\r\n                name: _proposal.name,\r\n                isMember: true,\r\n                id: uint24(memberAddresses.length - 1)\r\n            });\r\n            emit NewMemberAdded(_proposalId, _proposal.account);\r\n        }\r\n        else if (_proposal.pType == 2) { // Remove Member\r\n            require(members[_proposal.account].isMember, message7);\r\n            require(membersCount \u003e 1, message13);\r\n            delete memberAddresses[members[_proposal.account].id];\r\n            membersCount--;\r\n            members[_proposal.account].isMember = false;\r\n            emit MemberRemoved(_proposalId, _proposal.account);\r\n        }\r\n        else if (_proposal.pType == 3) { // Pay IoVT\r\n            require(_proposal.value \u003c= IoVT.balanceOf(address(this)), message1);\r\n            IoVT.transfer(_proposal.account, _proposal.value);\r\n            try iDistributor(_proposal.account).registerReceivedValue() {}\r\n            catch {}\r\n        }\r\n        else if (_proposal.pType == 4) { // Pay Token\r\n            iERC20 _token = iERC20(_proposal.token);\r\n            try _token.balanceOf(address(this)) returns(uint _balance) {\r\n                require(_proposal.value \u003c= _balance, message1);\r\n            }\r\n            catch {\r\n                revert(message8);\r\n            }\r\n            _token.transfer(_proposal.account, _proposal.value);\r\n        }\r\n        else if (_proposal.pType == 5) { // Pay BNB\r\n            require(_proposal.value \u003c= address(this).balance, message1);\r\n            _proposal.account.transfer(_proposal.value);\r\n        }\r\n        else if (_proposal.pType == 6) { // Approve Pay IoVT\r\n            require(_proposal.value \u003c= IoVT.balanceOf(address(this)), message1);\r\n            IoVT.approve(_proposal.account, _proposal.value);\r\n        }\r\n        else if (_proposal.pType == 7) { // Pay Delegated IoVT\r\n            require(_proposal.value \u003c= IoVT.balanceOf(_proposal.token), message1);\r\n            IoVT.transferFrom(_proposal.token, _proposal.account, _proposal.value);\r\n        }\r\n        else if (_proposal.pType == 11) { // Change Consortium\r\n            _transferAssets(_proposal.account);\r\n            _pushMembers(_proposal.account);\r\n            IoVT.changeOwner(_proposal.account);\r\n            emit ConsortiunChanged(_proposalId, _proposal.account);\r\n        }\r\n        else if (_proposal.pType == 12) { // Change Consortium Without Members\r\n            _transferAssets(_proposal.account);\r\n            IoVT.changeOwner(_proposal.account);\r\n            emit ConsortiunChanged(_proposalId, _proposal.account);\r\n        }\r\n        else if (_proposal.pType == 13) { // Block Account\r\n            require(! IoVT.isAccountBlocked(_proposal.account), message5);\r\n            IoVT.blockAccount(_proposal.account);\r\n        }\r\n        else if (_proposal.pType == 14) { // Unblock Account\r\n            require(IoVT.isAccountBlocked(_proposal.account), message9);\r\n           IoVT.unblockAccount(_proposal.account);\r\n        }\r\n        else if (_proposal.pType == 15) { // Free Voting\r\n            emit FreeVotingApproved(_proposalId, _proposal.description);\r\n        }\r\n        else if (_proposal.pType == 16) { // Send Data\r\n            (bool _success, /*bytes memory _returnData*/) = _proposal.account.call{value: _proposal.value}(_proposal.data);\r\n            require(_success);\r\n            emit SendDataApproved(_proposalId, _proposal.description);\r\n        }\r\n        else if (_proposal.pType == 17) { // Change Distributor Target Address\r\n            iDistributor(_proposal.token).setReceiverAccount(uint8(_proposal.value), _proposal.account);\r\n        }\r\n        else if (_proposal.pType == 18) { // Change Distributor Owner\r\n            iDistributor(_proposal.token).changeOwner(_proposal.account);\r\n        }\r\n    }\r\n\r\n    function _registerProposal(\r\n        uint8 _pType, \r\n        string memory _description, \r\n        address payable _account, \r\n        address _token, \r\n        uint _value, \r\n        string memory _name, \r\n        bytes memory _data\r\n        ) internal isDescriptionValid(_description) {\r\n        proposals.push(Proposal({\r\n            approved: 1,\r\n            approversCount: 1,\r\n            rejectorsCount: 0,\r\n            pType: _pType,\r\n            description: _description,\r\n            account: _account,\r\n            token: _token,\r\n            value: _value,\r\n            name: _name,\r\n            data: _data,\r\n            offerTime: uint40(block.timestamp)\r\n        }));\r\n        uint _proposalId = proposals.length-1;\r\n        openProposals.push(_proposalId);\r\n        proposals[_proposalId].votes[msg.sender] = 2;\r\n        emit ProposalSubmitted(_proposalId);\r\n        _checkProposalApproval(_proposalId);\r\n    }\r\n\r\n    function _pushMembers(address _newConsortium) internal {\r\n        (string[] memory _names, address[] memory _addresses, uint24[] memory _ids) = getMembers();\r\n        IoVGC(_newConsortium).pullMembers(_names, _addresses, _ids);\r\n    }\r\n\r\n    function _checkNewConsortium(address _consortium) internal {\r\n        require(IoVGC(_consortium).IoVTAddress() == IoVTAddress, message10);\r\n        require(_consortium != address(this), \"New consortium contract required.\");\r\n        try IoVGC(_consortium).name() returns(string memory _name) {\r\n            require(_name.compare(name), message11);\r\n        }\r\n        catch {\r\n            revert(message11);\r\n        }\r\n        try IoVGC(_consortium).version() returns(string memory _version) {\r\n            require(Utils.compareVersion(version, _version), \"Consortium contract version is old.\");\r\n        }\r\n        catch {\r\n            revert(message11);\r\n        }\r\n        string[] memory _names;\r\n        address[] memory _addresses;\r\n        uint24[] memory _ids;\r\n        try IoVGC(_consortium).pullMembers(_names, _addresses, _ids) {\r\n\r\n        } catch {\r\n            revert(\"Invalid or not configured consortium contract.\");\r\n        }\r\n    }\r\n\r\n    function _transferAssets(address payable _account) internal {\r\n        require(IoVGC(_account).IoVTAddress() == IoVTAddress, message10);\r\n        uint _IoVTBalance = IoVT.balanceOf(address(this));\r\n        if (_IoVTBalance \u003e 0)\r\n            IoVT.transfer(_account, _IoVTBalance);\r\n        if (address(this).balance \u003e 0)\r\n            _account.transfer(address(this).balance);\r\n    }\r\n\r\n    //****************************************************************************\r\n    //* Getter Functions\r\n    //****************************************************************************\r\n// Call this function to get the consortium members specifications in the output.\r\n// Output(s):\r\n//     _names: The array of the names of the consortium members.\r\n//     _addresses: The array of the addresses of the consortium members.\r\n//     _ids: The array of the ids of the consortium members.\r\n    function getMembers() public view returns(string[] memory _names, address[] memory _addresses, uint24[] memory _ids) {\r\n        membersCount;\r\n        _names = new string[](membersCount);\r\n        _addresses = new address[](membersCount);\r\n        _ids = new uint24[](membersCount);\r\n        uint j = 0;\r\n        for (uint i = 0; i \u003c memberAddresses.length; i++) {\r\n            address _memberAddress = memberAddresses[i];\r\n            if (_memberAddress != address(0) \u0026\u0026 members[_memberAddress].isMember) {\r\n                Member memory _member = members[_memberAddress];\r\n                _names[j] = _member.name;\r\n                _addresses[j] = _memberAddress;\r\n                _ids[j] = _member.id;\r\n                j++;\r\n            }\r\n        }\r\n    }\r\n\r\n// These functions are executables from the delegated smart contract.\r\n// If you want to use this function from web3 interfaces, you should omit starting and ending comment signs below (/* \u0026 */) \r\n//   and compile it for using abi json code in web3 interfaces.\r\n/*\r\n\r\n// Call this function to get the number of the consortium members.\r\n// Output(s):\r\n//     -Returns the number of the consortium members.\r\n    function getMembersCount() public view returns(uint24) {\r\n    }\r\n\r\n// Call this function to determine if the caller account is member of the IoVGC consortium.\r\n// Output(s):\r\n//     -Returns true if the caller account is member of the consortium, otherwise false.\r\n    function AmIMember() public view returns(bool) {\r\n    }\r\n\r\n// Call this function to get an IoVGC consortium member specifications by giving the specified member id.\r\n// Input(s):\r\n//     _memberId: The member id. Member id is an ordinal number starting with 0.\r\n// Output(s):\r\n//     _name: The name of the specified member.\r\n//     _memberAddress: The address of the specified member.\r\n    function getMemberById(uint _memberId) public view returns(string memory _name, address _memberAddress) {\r\n    }\r\n\r\n// Call this function to get an IoVGC consortium member specifications by giving the specified member address.\r\n// Input(s):\r\n//     _memberId: The member id. Member id is an ordinal number starting with 0.\r\n// Output(s):\r\n//     _name: The name of the specified member.\r\n//     _memberId: The id of the specified member.\r\n    function getMemberByAddress(address _memberAddress) public view returns(string memory _name, uint24 _memberId) {\r\n    }\r\n\r\n// Call this function to get the number of the offered proposals.\r\n// Note that if you get n as the output of this function, then you can use 0 to n-1 as the proposal id in another functions.\r\n// Output(s):\r\n//     -Returns the number of the offered proposals.\r\n    function getProposalsCount() public view returns(uint) {\r\n    }\r\n\r\n// Call this function to get a specified proposal specifications give its id.\r\n// Input(s):\r\n//     _proposalId: The propsal id: an ordinal number starting with 0.\r\n// Output(s):\r\n//     _approved: The state of theproposal approval: \r\n//         1: Voting state, 2: Approved, 3: Rejected, 4: Expired\r\n//     _approversCount: The number of approvers member.\r\n//     _rejectorsCount: The number of rejectors member.\r\n//     _pType: The type of the proposal:\r\n//         1: Add Member, 2: Remove Member, 3: Pay IoVT, 4: Pay Token, 5: Pay BNB, 6: Approve Pay IoVT, 7: Pay Delegated IoVT,\r\n//         11: Change Consortium (Transfer Members), 12: Only Change Consortium, 13: Block Account, 14: Unblock Account, \r\n//         15: Free Voting, 16: Send Data, 17: Change Distributor Target Address, 18: Change DistributorOwner\r\n//     _dscription: The description about the proposal.\r\n// Based of each proposal type another outputs may be reflect these information:\r\n//     1: Add Member\r\n//         _name: The name of the proposed new member.\r\n//         _account: The account address of the proposed new member.\r\n//     2: Remove Member\r\n//         _account: The account address of the proposed member to be removed.\r\n//     3: Pay IoVT\r\n//         _account: the account or smart contract address you want to pay IoVT token pay to.\r\n//         _value: the amount of IoVT token you want to pay. (trailing zeros for the token decimals)\r\n//     4: Pay Token\r\n//         _token: The address of the specified ERC-20 (BEP-20) token.\r\n//         _account: the account or smart contract address you want to pay the specified token pay to.\r\n//         _value: the amount of the specified token you want to pay. (trailing zeros for the token decimals)\r\n//     5: Pay BNB\r\n//         _account: the account or smart contract address you want to pay BNB token pay to.\r\n//         _value: the amount of BNB token you want to pay. (trailing zeros for BNB decimals)\r\n//     6: Approve Pay IoVT\r\n//         _account: the account or smart contract you want to delegate to.\r\n//         _value: the amount of IoVT token you want to delegate to spend. (trailing zeros for the token decimals)\r\n//     7: Pay Delegated IoVT\r\n//         _account: The account or smart contract that you want to pay IoVT token to pay to on behalf of the _sender.\r\n//         _token: The account or smart contract that delegated IoVGC consortium to pay IoVT token.\r\n//         _value: The amount of IoVT token you want to pay to the _account on behalf of the _sender.\r\n//     11: Change Consortium (Transfer Members)\r\n//         _account: The new IoVGC consortium smart contract.\r\n//     12: Only Change Consortium\r\n//         _account: The new IoVGC consortium smart contract.\r\n//     13: Block Account\r\n//         _account: The account you want to be blocked.\r\n//     14: Unblock Account \r\n//         _account: The account you want to be unblocked.\r\n//     15: Free Voting\r\n//         n/a\r\n//     16: Send Data\r\n//         _account: Address of the specified smart contract that you want to send its function request.\r\n//     17: Change Distributor Target Address\r\n//         _account: The new address for target address.\r\n//         _token: Address of the distributor smart contract.\r\n//         _value: The target address portion id.\r\n//     18: Change DistributorOwner\r\n//         _account: The address of new IoGC consortium.\r\n//         _token: The address of the distributor smart contract.\r\n    function getProposal(uint _proposalId) public view returns(\r\n        uint8 _approved,\r\n        uint24 _approversCount,\r\n        uint24 _rejectorsCount,\r\n        uint8 _pType,\r\n        string memory _description,\r\n        address payable _account,\r\n        address _token,\r\n        uint _value,\r\n        string memory _name\r\n    ) {\r\n    }\r\n\r\n// Call this function to get the members and their votes to the specified proposal.\r\n// Input(s):\r\n//     _proposalId: The propsal id: an ordinal number starting with 0.\r\n// Output(s):\r\n//     _votersNames: The array of members name.\r\n//     _votersAddresses: The array of members address.\r\n//     _votes: The array of the members votes:\r\n//         0: Not voted\r\n//         2: Approved\r\n//         3: Rejected\r\n    function getProposalVoters(uint _proposalId) public view returns(\r\n        string[] memory _votersNames,\r\n        address[] memory _votersAddresses,\r\n        uint8[] memory _votes\r\n    ) {\r\n    }\r\n\r\n// Call this function to get open proposal ids.\r\n// Open proposals is proposals that is ready for voting. So it cannot be finally approved, rejected or expired.\r\n// Output(s):\r\n//     _openProposals: The array of open proposal ids.\r\n    function getOpenProposalIds() public view returns(uint[] memory _openProposals) {\r\n    }\r\n*/\r\n\r\n}"},"ConsortiumData.sol":{"content":"pragma solidity ^0.6.12;\r\n// SPDX-License-Identifier: MIT\r\n\r\nimport \"./iERC20.sol\";\r\n\r\n// This contract contains the data for IoVGC contract and must be inherited by it and its delegated contract.\r\ncontract ConsortiumData {\r\n    //****************************************************************************\r\n    //* Data\r\n    //****************************************************************************\r\n    string public version = \"0.1.0\";\r\n    string public name = \"IoVGC: Internet of Vehicles Global Consortium\";\r\n    struct Proposal {\r\n        uint8 approved; // 1: Voting state, 2: Approved, 3: Rejected, 4: Expired\r\n        uint24 approversCount;\r\n        uint24 rejectorsCount;\r\n        uint40 offerTime;\r\n        uint8 pType;\r\n            // 1: Add Member, 2: Remove Member, 3: Pay IoVT, 4: Pay Token, 5: Pay BNB, 6: Approve Pay IoVT, 7: Pay Delegated IoVT,\r\n            // 11: Change Consortium (Transfer Members), 12: Only Change Consortium, 13: Block Account, 14: Unblock Account, \r\n            // 15: Free Voting, 16: Send Data, 17: Change Distributor Target Address, 18: Change DistributorOwner\r\n        string description;\r\n        address payable account;\r\n        address token;\r\n        uint value;\r\n        string name;\r\n        mapping(address =\u003e uint8) votes; // 2: Approved, 3: Rejected\r\n        bytes data;\r\n    }\r\n    Proposal[] proposals;\r\n    uint[] openProposals;\r\n    struct Member {\r\n        string name;\r\n        bool isMember;\r\n        uint24 id;\r\n//        uint16 role;\r\n    }\r\n    mapping (address =\u003e Member) members;\r\n    uint24 membersCount;\r\n    address[] memberAddresses;\r\n    uint8 quorumCoefficient = 2;\r\n    uint8 quorumDivisor = 3;\r\n    uint40 maxVotingDuration = 30 days;\r\n    address public IoVTAddress;\r\n    iERC20 IoVT;\r\n// Messages in require statements.\r\n    string message1 = \"Insufficient balance.\";\r\n    string message2 = \"Invalid portion id.\";\r\n    string message3 = \"This proposal is not in voting mode.\";\r\n    string message4 = \"The address is member of the consortium.\";\r\n    string message5 = \"Account is blocked before.\";\r\n    string message6 = \"Invalid Proposal id.\";\r\n    string message7 = \"The address is not member of the consortium.\";\r\n    string message8 = \"Invalid token address.\";\r\n    string message9 = \"Account is not blocked.\";\r\n    string message10 = \"IoVT address is not set in the new consortium contract.\";\r\n    string message11 = \"Invalid consortium contract.\";\r\n    string message12 = \"Invalid member id.\";\r\n    string message13 = \"You are the only member.\";\r\n    string message14 = \"Consortium is not the owner of distributor contract.\";\r\n    string message15 = \"Invalid distributor contract.\";\r\n\r\n}"},"iDistributor.sol":{"content":"pragma solidity ^0.6.12;\r\n// SPDX-License-Identifier: MIT\r\n\r\ninterface iDistributor {\r\n\r\n    function payMyCurrentShare() external;\r\n\r\n    function registerReceivedValue() external;\r\n\r\n    function setReceiverAccount(uint8 _portionId, address payable _account) external;\r\n\r\n    function getPortionsCount() external view returns(uint);\r\n    \r\n    function changeOwner(address payable _owner) external;\r\n\r\n    function getOwner() external view returns(address);\r\n\r\n}"},"iERC20.sol":{"content":"pragma solidity ^0.6.12;\n// SPDX-License-Identifier: MIT\n\n// This interface gives the virtual methods for IoVT and another ERC-20 (BP-20) functions.\ninterface iERC20 {\n    function name() external view returns(string memory);\n    \n    function symbol() external view returns(string memory);\n    \n    function decimals() external view returns(uint8);\n    \n    function totalSupply() external view returns(uint256);\n\n    function balanceOf(address account) external view returns(uint256);\n\n    function transfer(address recipient, uint256 amount) external returns(bool);\n\n    function allowance(address owner, address spender) external view returns(uint256);\n\n    function approve(address spender, uint256 amount) external returns(bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns(bool);\n\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns(bool);\n\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns(bool);\n\n    function changeOwner(address payable _owner) external;\n\n    function getOwner() external view returns(address);\n\n    function blockAccount(address _account) external;\n\n    function unblockAccount(address _account) external;\n\n    function isAccountBlocked(address _account) external view returns(bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n}\n"},"ownable.sol":{"content":"pragma solidity ^0.6.12;\r\n// SPDX-License-Identifier: MIT\r\n\r\n// This contract is used to determine owner of other contracts.\r\n// At the deploy time, the owner is set to the account that deploys the contract.\r\ncontract ownable {\r\n    address payable owner;\r\n\r\n    modifier isOwner {\r\n        require(owner == msg.sender,\"You should be owner to call this function.\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n// This function is used to change the owner of the contract.\r\n    function changeOwner(address payable _owner) public isOwner {\r\n        require(owner != _owner,\"You must enter a new value.\");\r\n        owner = _owner;\r\n    }\r\n\r\n// This function returns the owner address of the contract.\r\n    function getOwner() public view returns(address) {\r\n        return(owner);\r\n    }\r\n\r\n}"},"Proxy.sol":{"content":"pragma solidity 0.6.12;\n// SPDX-License-Identifier: MIT\n\nimport \"./ownable.sol\";\n\n// This contract is used to set a delegated contract, so that the functions of delegated contract would be callable from the main contract.\ncontract Proxy is ownable {\n// Logic layer variable:\n    address delegatedAddress;\n\n// Sets the delegated contract address.\n// This function can only send once.\n    function setDelegatedAddress(address _delegatedAddress) public isOwner {\n        require(delegatedAddress == address(0),\"Delegated address is set before.\");\n        require(_delegatedAddress != address(0),\"Invalid new address.\");\n        delegatedAddress = _delegatedAddress;\n    }\n\n// This function gets the delegated contract address.\n    function getDelegatedAddress() public view returns(address) {\n        return(delegatedAddress);\n    }\n\n    fallback() external {\n        address target = delegatedAddress;\n        assembly {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, 0, calldatasize())\n            let result := delegatecall(gas(), target, ptr, calldatasize(), 0, 0)\n            let size := returndatasize()\n            returndatacopy(ptr, 0, size)\n            switch result\n            case 0 { revert(ptr, size) }\n            case 1 { return(ptr, size) }\n        }\n    }\n}"},"SafeMath.sol":{"content":"pragma solidity ^0.6.12;\r\n// SPDX-License-Identifier: MIT\r\n\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a, \"Addition overflow error.\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        require(b \u003c= a, \"Subtraction overflow error.\");\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function inc(uint a) internal pure returns(uint) {\r\n        return(add(a, 1));\r\n    }\r\n\r\n    function dec(uint a) internal pure returns(uint) {\r\n        return(sub(a, 1));\r\n    }\r\n\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint a, uint b) internal pure returns(uint) {\r\n        require(b != 0,\"Divide by zero.\");\r\n        return(a/b);\r\n    }\r\n\r\n    function mod(uint a, uint b) internal pure returns(uint) {\r\n        require(b != 0,\"Divide by zero.\");\r\n        return(a % b);\r\n    }\r\n\r\n    function min(uint a, uint b) internal pure returns (uint) {\r\n        if (a \u003e b)\r\n            return(b);\r\n        return(a);\r\n    }\r\n\r\n    function max(uint a, uint b) internal pure returns (uint) {\r\n        if (a \u003c b)\r\n            return(b);\r\n        return(a);\r\n    }\r\n\r\n    function addPercent(uint a, uint p, uint r) internal pure returns(uint) {\r\n        return(div(mul(a,add(r,p)),r));\r\n    }\r\n}\r\n"},"Strings.sol":{"content":"pragma solidity ^0.6.12;\r\n// SPDX-License-Identifier: MIT\r\n\r\nlibrary Strings {\r\n    function len(string memory str) internal pure returns(uint) {\r\n        return(bytes(str).length);\r\n    }\r\n\r\n    function concat(string memory str1, string memory str2) internal pure returns(string memory) {\r\n        return(string(abi.encodePacked(str1, str2)));\r\n    }\r\n\r\n    function compare(string memory str1, string memory str2) internal pure returns(bool) {\r\n        return(memCompare(bytes(str1), bytes(str2)));\r\n    }\r\n\r\n    function substr(string memory str, uint startIndex, uint length) internal pure returns( string memory s) {\r\n        bytes memory strBytes = bytes(str);\r\n        bytes memory result = new bytes(length);\r\n        uint _len = strBytes.length;\r\n        for(uint i = startIndex; i \u003c startIndex+length; i++) {\r\n            if (i \u003e= _len)\r\n                break;\r\n            result[i-startIndex] = strBytes[i];\r\n        }\r\n        return string(result);\r\n    }\r\n\r\n    function strPos(string memory str, string memory needle) internal pure returns(bool found, uint pos) {\r\n        bytes memory strBytes = bytes(str);\r\n        bytes memory needleBytes = bytes(needle);\r\n        pos = 0;\r\n        found = false;\r\n        for(uint i = 0; i \u003c strBytes.length; i++) {\r\n            for (uint j = 0; j \u003c needleBytes.length; j++) {\r\n                if (strBytes[i + j] == needleBytes[j]) {\r\n                    found = true;\r\n                } else {\r\n                    found = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (found) {\r\n                pos = i;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function strPos(string memory str, string memory needle, uint offset) internal pure returns(bool found, uint pos) {\r\n        bytes memory strBytes = bytes(str);\r\n        bytes memory needleBytes = bytes(needle);\r\n        pos = 0;\r\n        found = false;\r\n        if (offset == 0)\r\n            return(found, pos);\r\n        uint offsetCount = 0;\r\n        for(uint i = 0; i \u003c strBytes.length; i++) {\r\n            for (uint j = 0; j \u003c needleBytes.length; j++) {\r\n                if (strBytes[i + j] == needleBytes[j]) {\r\n                    found = true;\r\n                } else {\r\n                    found = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (found) {\r\n                offsetCount++;\r\n                if (offsetCount == offset) {\r\n                    pos = i;\r\n                    break;\r\n                }\r\n            else\r\n                found = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    function appendUint(string memory str, uint value) internal pure returns(string memory) {\r\n        if (value == 0) {\r\n            return(\"0\");\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory result = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            result[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return(concat(str, string(result)));\r\n    }\r\n\r\n    function strToUint(string memory str) internal pure returns(uint result) {\r\n        bytes memory bStr = bytes(str);\r\n        result = 0;\r\n        for (uint i = 0; i \u003c bStr.length; i++) {\r\n            uint8 char = uint8(bStr[i]);\r\n            if (char \u003e= 48 \u0026\u0026 char \u003c= 57)\r\n                result = result * 10 + (char - 48);\r\n            else\r\n                break;\r\n        }\r\n    }\r\n\r\n    function appendSpace(string memory str) internal pure returns(string memory) {\r\n        return(concat(str,\" \"));\r\n    } \r\n    \r\n    function appendNewLine(string memory str) internal pure returns(string memory) {\r\n        return(concat(str,\"\\n\"));\r\n    } \r\n    \r\n    function stringToByte(string memory str) internal pure returns(byte) {\r\n        byte bStrN;\r\n        assembly {\r\n            bStrN := mload(add(str, 32))\r\n        }\r\n        return(bStrN);\r\n    }\r\n\r\n//****************************************************************************\r\n//* Internal Functions\r\n//****************************************************************************\r\n    function memCompare(bytes memory a, bytes memory b) internal pure returns(bool){\r\n        return (a.length == b.length) \u0026\u0026 (keccak256(a) == keccak256(b));\r\n    }\r\n\r\n}"},"Utils.sol":{"content":"pragma solidity ^0.6.12;\r\n// SPDX-License-Identifier: MIT\r\n\r\nimport \"./Strings.sol\";\r\n\r\nlibrary Utils {\r\n    using Strings for string;\r\n    function getPayable2(address _account) internal pure returns(address payable) {\r\n        return(address(uint160(_account)));\r\n    }\r\n\r\n    function getVersionElements(string memory _version) internal pure returns(uint[] memory) {\r\n        uint[] memory _result = new uint[](3);\r\n        bool _found;\r\n        uint _pos1;\r\n        uint _pos2;\r\n        (_found, _pos1) = _version.strPos(\".\", 1);\r\n        if (_found) {\r\n            _found = false;\r\n            _result[0] = _version.substr(0,_pos1).strToUint();\r\n            (_found, _pos2) = _version.strPos(\".\", 2);\r\n            if (_found) {\r\n                _result[1] = _version.substr(_pos1+1, _pos2-_pos1-1).strToUint();\r\n                _result[2] = _version.substr(_pos2+1, _version.len()).strToUint();\r\n            }\r\n            else\r\n                _result[1] = _version.substr(_pos1+1, _version.len()).strToUint();\r\n        }\r\n        else \r\n            _result[0] = _version.strToUint();\r\n        return(_result);\r\n    }\r\n\r\n    function compareVersion(string memory _v1, string memory _v2) internal pure returns(bool) {\r\n        uint[] memory _vv1 = getVersionElements(_v1);\r\n        uint[] memory _vv2 = getVersionElements(_v2);\r\n        return(_vv2[0] \u003e= _vv1[0] \u0026\u0026 _vv2[1] \u003e= _vv1[1] \u0026\u0026 _vv2[2] \u003e _vv1[2] );\r\n    }\r\n\r\n    function deleteArrayElement(uint[] storage _array, uint _content) internal returns(bool) {\r\n        bool found = false;\r\n        for (uint i = 0; i \u003c _array.length; i++) {\r\n            if (_array[i] == _content) {\r\n                deleteArrayElementByIndex(_array, i);\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n        return(found);\r\n    }\r\n\r\n    function deleteArrayElementByIndex(uint[] storage _array, uint _index) internal {\r\n        require(_index \u003c _array.length);\r\n        for (uint i = _index; i \u003c _array.length-1; i++) \r\n            _array[i] = _array[i+1];\r\n        _array.pop();\r\n    }\r\n\r\n}"}}