// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.7;

contract Callable {

    address payable private _context;
    address private _creator;

    constructor() { 
        _context = payable(address(this));
        _creator = msg.sender;
        emit CreateContext(_context, _creator);
    }

    function _contextAddress() internal view returns (address payable) {
        return _context;
    }

    function _contextCreator() internal view returns (address) {
        return _creator;
    }

    function _msgSender() internal view returns (address payable) {
        return payable(msg.sender);
    }

    function _msgData() internal view returns (bytes memory) {
        this;
        return msg.data;
    }

    function _msgTimestamp() internal view returns (uint256) {
        this;
        return block.timestamp;
    }

    receive() external payable { }

    event CreateContext(address contextAddress, address contextCreator);
}

contract Manageable is Callable {
    address private _executiveManager;
    mapping(address => bool) private _isManager;
    address[] private _managers;

    bool private _managementIsLocked = false;
    uint256 private _managementUnlockTime = 0;
    uint256 private _maxNumberOfManagers = 10;

    constructor () {
        _executiveManager = _contextCreator();
        _isManager[_executiveManager] = true;
        _managers.push(_executiveManager);

        emit ManagerAdded(_executiveManager);
        emit ExecutiveManagerChanged(address(0), _executiveManager);
    }

    function executiveManager() public view returns (address) {
        return _executiveManager;
    }

    function isManager(address account) public view returns (bool) {
        return _isManager[account];
    }

    function managementIsLocked() public view returns (bool) {
        return _managementIsLocked;
    }

    function timeToManagementUnlock() public view returns (uint256) {
        return block.timestamp >= _managementUnlockTime ? 0 : _managementUnlockTime - block.timestamp;
    }
    
    function addManager(address newManager) public onlyExecutive() returns (bool) {
        require(!_isManager[newManager], "Account is already a manager");
        require(newManager != address(0), "0 address cannot be made manager");
        require(_managers.length <= _maxNumberOfManagers, "max number of managers reached");

        _isManager[newManager] = true;
        _managers.push(newManager);

        emit ManagerAdded(newManager);

        return true;
    }

    function removeManager(address managerToRemove) public onlyExecutive() returns (bool) {
        require(_isManager[managerToRemove], "Account is already not a manager");
        require(managerToRemove != _executiveManager, "Executive manager cannot be removed");

        _isManager[managerToRemove] = false;
        for(uint256 i = 0; i < _managers.length; i++) {
            if(_managers[i] == managerToRemove){
                _managers[i] = _managers[_managers.length - 1];
                _managers.pop();
                break;
            }
        }

        emit ManagerRemoved(managerToRemove);

        return true;
    }

    function changeExecutiveManager(address newExecutiveManager) public onlyExecutive() returns (bool) {
        require(newExecutiveManager != _executiveManager, "Manager is already the executive");

        if(!_isManager[newExecutiveManager]){
            _isManager[newExecutiveManager] = true;
            emit ManagerAdded(newExecutiveManager);
        }
        _executiveManager = newExecutiveManager;

        emit ExecutiveManagerChanged(_executiveManager, newExecutiveManager);

        return true;
    }

    function lockManagement(uint256 lockDuration) public onlyExecutive() returns (bool) {
        _managementIsLocked = true;
        _managementUnlockTime = block.timestamp + lockDuration;

        emit ManagementLocked(lockDuration);

        return true;
    }

    function unlockManagement() public onlyExecutive() returns (bool) {
        _managementIsLocked = false;
        _managementUnlockTime = 0;

        emit ManagementUnlocked();

        return true;
    }

    function renounceManagement() public onlyExecutive() returns (bool) {
        while(_managers.length > 0) {
            _isManager[_managers[_managers.length - 1]] = false;

            emit ManagerRemoved(_managers[_managers.length - 1]);

            if(_managers[_managers.length - 1] == _executiveManager){
                emit ExecutiveManagerChanged(_executiveManager, address(0));
                _executiveManager = address(0);
            }

            _managers.pop();
        }

        emit ManagementRenounced();

        return true;
    }

    event ManagerAdded(address addedManager);
    event ManagerRemoved(address removedManager);
    event ExecutiveManagerChanged(address indexed previousExecutiveManager, address indexed newExecutiveManager);
    event ManagementLocked(uint256 lockDuration);
    event ManagementUnlocked();
    event ManagementRenounced();

    modifier onlyExecutive() {
        require(_msgSender() == _executiveManager, "Caller is not the executive manager");
        require(!_managementIsLocked || block.timestamp >= _managementUnlockTime, "Management is locked");
        _;
    }

    modifier onlyManagement() {
        require(_isManager[_msgSender()], "Caller is not a manager");
        require(!_managementIsLocked, "Management is locked");
        _;
    }
}

interface IBEP20 {
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint8);
    function totalSupply() external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);
    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);

    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);
}

library SackMath {

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "addition overflow");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        if(b >= a){
            return 0;
        }
        uint256 c = a - b;
        return c;
    }

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0 || b == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, "multiplication overflow");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "division by zero");
        uint256 c = a / b;
        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "modulo by zero");
        return a % b;
    }

}

contract AjaxCoin is IBEP20, Manageable {
    using SackMath for uint256;

    uint256 private constant MAX = ~uint256(0);

    string private _name = "Ajax Coin";
    string private _symbol = "AJAX";
    uint8 private _decimals = 18;
    uint256 private _totalSupply = 2000000000000 * 10**_decimals;

    uint256 private _burnTotal = 0;

    mapping (address => uint256) private _owned;
    mapping (address => mapping (address => uint256)) private _allowances;

    bool public _areLimitsEnabled = false;
    mapping (address => bool) private _isExcludedFromLimits;
    uint256 public _maxTransferAmount = _totalSupply.mul(3).div(1000);

    bool public _areFeesEnabled = true;
    mapping (address => bool) private _isExcludedFromFees;
    uint256 public _managementFeePercentage = 5;

    address[] private _managementFeesReceivers;
    mapping (address => bool) private _isManagementFeesReceiver;
    uint256 private _maxNumberManagementFeesReceivers = 5;

    bool public _isAutoManagementFeeDistributionEnabled = true;
    uint256 private _minPendingFeesForDistribution = 50000 * 10**_decimals;
    uint256 private _autoDistributeFactor = 1000;
    uint256 private _managementFeesPendingDistribution = 0;

    address public _deadAddress = 0x000000000000000000000000000000000000dEaD;

    bool private _isDistributingFees = false;
    
    constructor() {
        _isExcludedFromFees[_contextAddress()] = true;
        _isExcludedFromLimits[_contextAddress()] = true;

        _isExcludedFromFees[_deadAddress] = true;
        _isExcludedFromLimits[_deadAddress] = true;

        _isExcludedFromFees[_msgSender()] = true;
        _isExcludedFromLimits[_msgSender()] = true;

        _owned[_msgSender()] = _totalSupply;

        _managementFeesReceivers.push(_msgSender());
        _isManagementFeesReceiver[_msgSender()] = true;

        emit Mint(_totalSupply);
        emit Transfer(address(0), _msgSender(), _totalSupply);
    }

    function name() public override view returns (string memory) {
        return _name;
    }

    function symbol() public override view returns (string memory) {
        return _symbol;
    }

    function decimals() public override view returns (uint8) {
        return _decimals;
    }

    function totalSupply() public override view returns (uint256) {
        return _totalSupply;
    }

    function totalBurned() public view returns (uint256) {
        return _burnTotal;
    }

    function getOwner() public view returns (address) {
        return executiveManager();
    }

    function balanceOf(address account) public override view returns (uint256) {
        return _owned[account];
    }

    function transfer(address to, uint256 amount) public override returns (bool) {
        _transfer(_msgSender(), to, amount);
        return true;
    }

    function allowance(address owner, address spender) public override view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address owner, address to, uint256 amount) public override returns (bool) {
        _transfer(owner, to, amount);
        _approve(owner, _msgSender(), _allowances[owner][_msgSender()].sub(amount, "transfer amount exceeds spender's allowance"));
        return true;
    }

    function increaseAllowance(address spender, uint256 amount) public returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(amount));
        return true;
    }

    function decreaseAllowance(address spender, uint256 amount) public returns (bool) {
        if(amount <= _allowances[_msgSender()][spender]){
            _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(amount));
        } else {
            _approve(_msgSender(), spender, 0);
        }
        return true;
    }

    function isExcludedFromFees(address account) public view returns (bool) {
        return _isExcludedFromFees[account];
    }

    function isExcludedFromLimits(address account) public view returns (bool) {
        return _isExcludedFromLimits[account];
    }

    function _approve(address owner, address spender, uint256 amount) private {
        require(owner != address(0), "cannot approve allowance from the zero address");
        require(spender != address(0), "cannot approve allowance to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _transfer(address from, address to, uint256 amount) private {
        require(from != address(0) && to != address(0), "cannot transfer tokens from or to the zero address");
        require(to != _deadAddress, "Cannot transfer to dead address. Use Burn function instead.");
        require(amount <= _maxTransferAmount || !_areLimitsEnabled || _isExcludedFromLimits[from] || _isExcludedFromLimits[to], "transfer amount exceeds transaction limit");
        require(amount > 0, "Transfer amount must be bigger than 0");

        uint256 fromAccountBalance = balanceOf(from);
        require(fromAccountBalance >= amount, "insufficent from account token balance");

        uint256 managementFeeAmount = _calculateManagementFees(from, to, amount);

        uint256 transferAmount = amount.sub(managementFeeAmount);

        require (transferAmount > 0, "Amount of transfer is to small");

        _transferManagementFeesIfNecessary(from, to, managementFeeAmount);

        _distributeFeesIfNecessary();
        
        _owned[from] = _owned[from].sub(amount);
        _owned[to] = _owned[to].add(transferAmount);

        emit Transfer(from, to, transferAmount);
    }

    function _calculateManagementFees(address from, address to, uint256 amount) private view returns (uint256){
        uint256 managementFeeAmount = 0;
        if(_areFeesEnabled && !(_isExcludedFromFees[from] || _isExcludedFromFees[to])) {
            managementFeeAmount = amount.mul(_managementFeePercentage).div(1000);
        }

        return managementFeeAmount;
    }

    function _distributeFeesIfNecessary() private {
        if (!_isDistributingFees) {
            if(_isAutoManagementFeeDistributionEnabled && _managementFeesPendingDistribution >= _minPendingFeesForDistribution) {
                _distributeFees(_autoDistributeFactor);
            }
        }
    }

    function _transferManagementFeesIfNecessary(address from, address to, uint256 managementFeeAmount) private {
        if(_areFeesEnabled && !(_isExcludedFromFees[to] || _isExcludedFromFees[from])){
            _owned[_contextAddress()] = _owned[_contextAddress()].add(managementFeeAmount);
            
            emit Transfer(from, _contextAddress(), managementFeeAmount);
            
            _managementFeesPendingDistribution = _managementFeesPendingDistribution.add(managementFeeAmount);
        }
    }

    function _distributeFees(uint256 liquifyFactor) private internalSwapLock() {
        require(liquifyFactor <= 1000, "liquify factor cannot exceed 100 percent");
        require(_managementFeesReceivers.length > 0, "no managers to distribute fees");

        uint256 feesToDistribute = _managementFeesPendingDistribution.mul(liquifyFactor).div(1000);
        
        _managementFeesPendingDistribution = _managementFeesPendingDistribution.sub(feesToDistribute);

        uint256 individualFeesAmount = feesToDistribute.div(_managementFeesReceivers.length);

        _owned[_contextAddress()] = _owned[_contextAddress()].sub(feesToDistribute);

        for(uint256 i = 0; i < _managementFeesReceivers.length; i++){
            _owned[_managementFeesReceivers[i]] = _owned[_managementFeesReceivers[i]].add(individualFeesAmount);
        }
    }

    function excludeFromFees(address account) public onlyManagement() returns (bool) {
        _isExcludedFromFees[account] = true;
        return true;
    }

    function includeInFees(address account) public onlyManagement() returns (bool) {
        require(account != _contextAddress(), "cannot include token address in fees");
        require(account != _deadAddress, "cannot include dead address in fees");
        _isExcludedFromFees[account] = false;
        return true;
    }

    function excludeFromLimits(address account) public onlyManagement() returns (bool) {
        _isExcludedFromLimits[account] = true;
        return true;
    }

    function includeInLimits(address account) public onlyManagement() returns (bool) {
        require(account != _contextAddress(), "cannot include token address in limits");
        require(account != _deadAddress, "cannot include dead address in limits");
        _isExcludedFromLimits[account] = false;
        return true;
    }

    function addManagementFeesReciever(address managementFeesReciever) public onlyManagement() returns (bool) {
        require(!_isManagementFeesReceiver[managementFeesReciever], "address is already a management fees reciever");
        require(_managementFeesReceivers.length <= _maxNumberManagementFeesReceivers, "max number of management fees recievers already reached");
        _managementFeesReceivers.push(managementFeesReciever);
        _isManagementFeesReceiver[managementFeesReciever] = true;
        return true;
    }

    function isManagementFeesReceiver(address userAddress) public view onlyManagement() returns (bool) {
        return _isManagementFeesReceiver[userAddress];
    }

    function getManagementFeesPendingDistribution() public view onlyManagement() returns (uint256) {
        return _managementFeesPendingDistribution;
    }

    function removeManagementFeesReciever(address managementFeesReciever) public onlyManagement() returns (bool) {
        require(_isManagementFeesReceiver[managementFeesReciever], "address is already not a management fees reciever");
        require(_managementFeesReceivers.length > 1, "can't have no managers");
        for(uint256 i = 0; i < _managementFeesReceivers.length; i++) {
            if(_managementFeesReceivers[i] == managementFeesReciever){
                _managementFeesReceivers[i] = _managementFeesReceivers[_managementFeesReceivers.length - 1];
                _isManagementFeesReceiver[managementFeesReciever] = false;
                _managementFeesReceivers.pop();
                break;
            }
        }
        return true;
    }

    function setFeesEnabled(bool areFeesEnabled) public onlyManagement() returns (bool) {
        _areFeesEnabled = areFeesEnabled;
        if(!areFeesEnabled){
            _isAutoManagementFeeDistributionEnabled = false;
        }
        return true;
    }

    function setFeesEnabled(bool areFeesEnabled, bool isAutoFeeDistributeEnabled) public onlyManagement() returns (bool) {
        _areFeesEnabled = areFeesEnabled;
        if(!areFeesEnabled){
            _isAutoManagementFeeDistributionEnabled = false;
        } else {
            _isAutoManagementFeeDistributionEnabled = isAutoFeeDistributeEnabled;
        }
        return true;
    }

    function setManagementFee(uint256 managementFee) public onlyManagement() returns (bool) {
        require(managementFee <= 200, "total fees cannot exceed 20 percent");
        _managementFeePercentage = managementFee;
        return true;
    }

    function setAutoManagementFeeDistributionEnabled(bool isAutoFeeDistributionEnabled) public onlyManagement() returns (bool) {
        require(_areFeesEnabled || !isAutoFeeDistributionEnabled, "fees must be enabled to enable auto fee liquify");
        _isAutoManagementFeeDistributionEnabled = isAutoFeeDistributionEnabled;
        return true;
    }

    function setFeeDistributeFactor(uint256 autoDistributeFactor) public onlyManagement() returns (bool) {
        require(autoDistributeFactor <= 1000, "auto liquify factor cannot eceed 100 percent");
        _autoDistributeFactor = autoDistributeFactor;
        return true;
    }

    function setMinPendingFeesForDistribution(uint256 minPendingFeesForDistrbution) public onlyManagement() returns (bool) {
        _minPendingFeesForDistribution = minPendingFeesForDistrbution;
        return true;
    }

    function setLimitsEnabled(bool areLimitsEnabled) public onlyManagement() returns (bool) {
        _areLimitsEnabled = areLimitsEnabled;
        return true;
    }

    function setMaxTransferAmount(uint256 maxTransferAmount) public onlyManagement() returns (bool) {
        require(maxTransferAmount <= _totalSupply, "max transfer amount cannot exceed token supply");
        _maxTransferAmount = maxTransferAmount;
        return true;
    }

    function performManualFeeDistribution(uint256 distributeFactor) external onlyManagement() returns (bool) {
        _distributeFees(distributeFactor);
        return true;
    }

    function burn(uint256 amount) external {
        _burn(_msgSender(), amount);
    }

    function _burn(address account, uint256 amount) internal {
        require(account != address(0), "Burn from the zero address");
        require(account != _deadAddress, "Burn from the dead address");
        require(amount > 0, "Amount must be bigger than zero.");

        _owned[account] = _owned[account].sub(amount);
        _totalSupply = _totalSupply.sub(amount);
        _burnTotal = _burnTotal.add(amount);
        emit Transfer(account, _deadAddress, amount);
    }

    function rescueBNB() external onlyExecutive() {
        require(_contextAddress().balance > 0, "Contract's balance is zero.");

        uint256 balance = _contextAddress().balance;
        payable(msg.sender).transfer(balance);
    }

    function rescueCoin(address tokenContractAddress) external onlyExecutive() {
        IBEP20 coinInstance = IBEP20(tokenContractAddress);
        uint256 contractBalance = coinInstance.balanceOf(address(this));
        if (contractBalance == 0) {
            revert();
        }
        if (!coinInstance.transfer(msg.sender, contractBalance)) {
            revert();
        }
    }

    modifier internalSwapLock() {
        _isDistributingFees = true;
        _;
        _isDistributingFees = false;
    }

    event Mint(uint256 amountTokens);
}