{"HEGToken.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./IERC20.sol\";\n\n/**\n * @title HEGToken\n */\ncontract HEGToken is IERC20 {\n    /**\n     * The struct of one minter.\n     */\n    struct Minter {\n        // enabled/disabled flag\n        bool enabled;\n        // the number of minters that request a ban on this account\n        uint numBanRequests;\n    }\n\n    /**\n     * The struct of one minting request.\n     */\n    struct MintingRequest {\n        // recipient of tokens\n        address recipient;\n        // amount of tokens\n        uint amount;\n        // the number of minter approvals for this request\n        uint numApprovals;\n        // executed/not executed flag\n        bool executed;\n    }\n\n    /**\n     * The struct of one minting period.\n     */\n    struct MintingPeriod {\n        // duration of minting period in seconds\n        uint duration;\n        // the number of tokens to be minted after the end of the period\n        uint amount;\n    }\n\n    // minting start time in seconds\n    uint private _mintingStartAt;\n    // array of minting periods\n    MintingPeriod[] private _mintingPeriods;\n\n    // list of all wallets (address -\u003e number of tokens)\n    mapping(address =\u003e uint) private _balances;\n    // list of all allowances (owner =\u003e [spender =\u003e number of tokens])\n    mapping(address =\u003e mapping(address =\u003e uint)) private _allowances;\n    // total number of tokens\n    uint private _totalSupply;\n\n    // list of all mining requests\n    MintingRequest[] private _mintingRequests;\n    // list of all addresses that have voted for approval a request (rIdx =\u003e (address =\u003e isApproved))\n    mapping(uint =\u003e mapping(address =\u003e bool)) private _mintingRequestApprovals;\n\n    // list of all minters (address =\u003e Minter struct)\n    mapping(address =\u003e Minter) private _minters;\n    // list of all addresses that request for minter ban (account for ban =\u003e (requester account =\u003e isRequested))\n    mapping(address =\u003e mapping(address =\u003e bool)) private _minterBanRequests;\n    // total number of minters\n    uint private _totalMinters;\n    // how many minters must approve a mint/ban request\n    uint private _minApprovalsRequired;\n\n    event BanRequest(address indexed requester, address indexed account);\n    event BanRevocation(address indexed requester, address indexed account);\n    event Ban(address indexed requester, address indexed account);\n\n    event MintingRequestCreation(address indexed minter, uint indexed rIdx, address indexed recipient, uint amount);\n    event MintingRequestApproval(address indexed minter, uint indexed rIdx);\n    event MintingRequestRevocation(address indexed minter, uint indexed rIdx);\n    event Minting(address indexed minter, uint indexed rIdx, address indexed recipient, uint amount);\n\n\n    constructor(\n        uint mintingStartAt,\n        MintingPeriod[] memory mintingPeriods,\n        address[] memory minters,\n        uint minApprovalsRequired\n    ) {\n        require(minters.length \u003e 0, \"HEGToken: Minters are required.\");\n        require(\n            minApprovalsRequired \u003e 0 \u0026\u0026\n            minApprovalsRequired \u003c= minters.length,\n            \"HEGToken: Invalid number of minimum votes.\"\n        );\n\n        for (uint i=0; i\u003cminters.length; i++) {\n            require(minters[i] != address(0), \"HEGToken: Zero address.\");\n            require(!_minters[minters[i]].enabled, \"HEGToken: Minters are not unique.\");\n\n            Minter storage minter = _minters[minters[i]];\n            minter.enabled = true;\n        }\n\n        _totalMinters = minters.length;\n        _minApprovalsRequired = minApprovalsRequired;\n\n        _mintingStartAt = mintingStartAt;\n        for (uint i=0; i\u003cmintingPeriods.length; i++) {\n            _mintingPeriods.push(mintingPeriods[i]);\n        }\n    }\n\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // ERC20 Meta implementation\n    // ---------------------------------------------------------------------------------------------------------------\n    /**\n     * Returns the name of the token.\n     */\n    function name() external pure returns (string memory) {\n        return \"Rich Hens\";\n    }\n\n    /**\n     * Returns the symbol of the token.\n     */\n    function symbol() external pure returns (string memory) {\n        return \"HEG\";\n    }\n\n    /**\n     * Returns the decimals places of the token.\n     */\n    function decimals() external pure returns (uint8) {\n        return 8;\n    }\n\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // ERC20 implementation\n    // ---------------------------------------------------------------------------------------------------------------\n    /**\n     * See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view returns (uint) {\n        return _totalSupply;\n    }\n\n    /**\n     * See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view returns (uint) {\n        return _balances[account];\n    }\n\n    /**\n     * Mints tokens to the account\n     */\n    function _mint(address account, uint amount) internal {\n        require(account != address(0), \"HEGToken: Zero address.\");\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * See {IERC20-transfer}.\n     */\n    function transfer(address to, uint amount) public returns (bool) {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /**\n     * See {IERC20-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint amount) public returns (bool) {\n        require(_allowances[from][to] \u003e= amount, \"HEGToken: Insufficient allowance.\");\n\n        _allowances[from][to] -= amount;\n        _transfer(from, to, amount);\n\n        return true;\n    }\n\n    /**\n     * See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view returns (uint) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * See {IERC20-approve}.\n     */\n    function approve(address spender, uint amount) public returns (bool) {\n        require(spender != address(0), \"HEGToken: Zero address.\");\n\n        _allowances[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     */\n    function _transfer(address from, address to, uint amount) internal {\n        require(from != address(0), \"HEGToken: Zero address.\");\n        require(to != address(0), \"HEGToken: Zero address.\");\n\n        require(_balances[from] \u003e= amount, \"HEGToken: Transfer amount exceeds balance.\");\n        _balances[from] -= amount;\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n    }\n\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // Functions for mint\n    // ---------------------------------------------------------------------------------------------------------------\n    modifier onlyMinter() {\n        require(_minters[msg.sender].enabled, \"HEGToken: You are not a minter.\");\n        _;\n    }\n    /**\n     * Mints tokens specified in the minting request with the index rIdx.\n     *\n     * - the request must be approved by _minApprovalsRequired minters.\n     * - the requested amount of tokens must be less than or equal to the minting schedule.\n     */\n    function mint(uint rIdx) external onlyMinter {\n        require(rIdx \u003c _mintingRequests.length, \"HEGToken: Request does not exist.\");\n        require(!_mintingRequests[rIdx].executed, \"HEGToken: Request is already executed.\");\n        require(_mintingRequests[rIdx].numApprovals \u003e= _minApprovalsRequired, \"HEGToken: Not enough approves.\");\n        require(_mintingRequests[rIdx].amount \u003c= (totalAvailable() - totalSupply()), \"HEGToken: Too many tokens to mint.\");\n\n        _mint(_mintingRequests[rIdx].recipient, _mintingRequests[rIdx].amount);\n\n        _mintingRequests[rIdx].executed = true;\n\n        emit Minting(msg.sender, rIdx, _mintingRequests[rIdx].recipient, _mintingRequests[rIdx].amount);\n    }\n\n    /**\n     * Creates and approves a minting request. Each request gets an index \"rIdx\".\n     *\n     * @param recipient - address for transferring tokens\n     * @param amount    - number of tokens\n     * @return          - index of request (rIdx)\n     */\n    function requestMinting(address recipient, uint amount) external onlyMinter returns (uint) {\n        uint rIdx = _mintingRequests.length;\n\n        _mintingRequests.push(\n            MintingRequest({\n                recipient: recipient,\n                amount: amount,\n                numApprovals: 1,\n                executed: false\n            })\n        );\n\n        _mintingRequestApprovals[rIdx][msg.sender] = true;\n\n        emit MintingRequestCreation(msg.sender, rIdx, recipient, amount);\n\n        return rIdx;\n    }\n\n    /**\n     * Approves the minting request that was created by the requestMinting function.\n     */\n    function approveMintingRequest(uint rIdx) external onlyMinter returns (uint) {\n        require(rIdx \u003c _mintingRequests.length, \"HEGToken: Request does not exist.\");\n        require(!_mintingRequests[rIdx].executed, \"HEGToken: Request is already executed.\");\n        require(!_mintingRequestApprovals[rIdx][msg.sender], \"HEGToken: Request is already approved.\");\n\n        _mintingRequestApprovals[rIdx][msg.sender] = true;\n        _mintingRequests[rIdx].numApprovals++;\n\n        emit MintingRequestApproval(msg.sender, rIdx);\n\n        return _mintingRequests[rIdx].numApprovals;\n    }\n\n    /**\n     * Revokes the already approved request.\n     */\n    function revokeMintingRequest(uint rIdx) external onlyMinter {\n        require(rIdx \u003c _mintingRequests.length, \"HEGToken: Request does not exist.\");\n        require(!_mintingRequests[rIdx].executed, \"HEGToken: Request is already executed.\");\n        require(_mintingRequestApprovals[rIdx][msg.sender], \"HEGToken: Request is not approved.\");\n\n        _mintingRequestApprovals[rIdx][msg.sender] = false;\n        _mintingRequests[rIdx].numApprovals--;\n\n        emit MintingRequestRevocation(msg.sender, rIdx);\n    }\n\n    /**\n     * Returns the total number of mint requests, which is also the index for the next mint request.\n     */\n    function getTotalMintingRequests() external view returns (uint) {\n        return _mintingRequests.length;\n    }\n\n    /**\n     * Returns data about the minting request\n     */\n    function getMintingRequest(uint rIdx) external view returns (MintingRequest memory) {\n        return _mintingRequests[rIdx];\n    }\n\n    /**\n     * Returns data about all minting requests\n     */\n    function getAllMintingRequests() external view returns (MintingRequest[] memory) {\n        return _mintingRequests;\n    }\n\n    /**\n     * Returns the limit of tokens that can be minted for all time.\n     */\n    function limitSupply() public view returns (uint) {\n        uint limitAmount;\n\n        for (uint i=0; i\u003c_mintingPeriods.length; i++) {\n            limitAmount += _mintingPeriods[i].amount;\n        }\n\n        return limitAmount;\n    }\n\n    /**\n     * Returns the amount of tokens that can be minted so far.\n     */\n    function totalAvailable() public view returns (uint) {\n        if (getCurrentTime() \u003c _mintingStartAt) {\n            return 0;\n        }\n\n        uint availableAmount;\n        uint elapsedPeriodsTime;\n        uint elapsedTime = getCurrentTime() - _mintingStartAt;\n\n        for (uint i=0; i\u003c_mintingPeriods.length; i++) {\n            elapsedPeriodsTime += _mintingPeriods[i].duration;\n            if (elapsedPeriodsTime \u003e elapsedTime) {\n                break;\n            }\n\n            availableAmount += _mintingPeriods[i].amount;\n        }\n\n        return availableAmount;\n    }\n\n    /**\n     * Returns minting start time in seconds.\n     */\n    function getMintingStartAt() public view returns (uint) {\n        return _mintingStartAt;\n    }\n\n    /**\n     * Returns minting period by an index.\n     */\n    function getMintingPeriod(uint index) public view returns (MintingPeriod memory) {\n        return _mintingPeriods[index];\n    }\n\n    /**\n     * Returns minting periods\n     */\n    function getMintingPeriods() public view returns (MintingPeriod[] memory) {\n        return _mintingPeriods;\n    }\n\n    /**\n     * Returns all minting periods.\n     */\n    function getTotalMintingPeriods() public view returns (uint) {\n        return _mintingPeriods.length;\n    }\n\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // Work with minters\n    // ---------------------------------------------------------------------------------------------------------------\n    /**\n     * Requests the ban for the minter.\n     * It\u0027s needed _minApprovalsRequired confirms to allow the ban.\n     */\n    function requestMinterBan(address account) external onlyMinter {\n        require(_minters[account].enabled, \"HEGToken: The account is not a minter.\");\n        require(account != msg.sender, \"HEGToken: It is forbidden to ban yourself.\");\n        require(!_minterBanRequests[account][msg.sender], \"HEGToken: The request already exists.\");\n\n        _minterBanRequests[account][msg.sender] = true;\n        _minters[account].numBanRequests++;\n\n        emit BanRequest(msg.sender, account);\n    }\n\n    /**\n     * Revokes a previous ban request\n     */\n    function revokeMinterBanRequest(address account) external onlyMinter {\n        require(_minterBanRequests[account][msg.sender], \"HEGToken: The request does not exists.\");\n\n        _minterBanRequests[account][msg.sender] = false;\n        _minters[account].numBanRequests--;\n\n        emit BanRevocation(msg.sender, account);\n    }\n\n    /**\n     * Bans the minter\n     * It\u0027s needed _minApprovalsRequired confirms to allow the ban.\n     */\n    function banMinter(address account) external onlyMinter {\n        require(_minters[account].enabled, \"HEGToken: The account is not a minter.\");\n        require(account != msg.sender, \"HEGToken: It is forbidden to ban yourself.\");\n        require(_minters[account].numBanRequests \u003e= _minApprovalsRequired, \"HEGToken: Not enough requests.\");\n        \n        _minters[account].enabled = false;\n        _totalMinters--;\n\n        emit Ban(msg.sender, account);\n    }\n\n    /**\n     * Returns the total number of minters\n     */\n    function getTotalMinters() external view returns (uint) {\n        return _totalMinters;\n    }\n\n    /**\n     * Check if the account is a minter\n     */\n    function isMinter(address account) external view returns (bool) {\n        return _minters[account].enabled;\n    }\n\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // Helpers\n    // ---------------------------------------------------------------------------------------------------------------\n    /**\n     * @dev Returns time of the current block. (for using in mock)\n     */\n    function getCurrentTime() public virtual view returns(uint) {\n        return block.timestamp;\n    }\n}"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}"}}