{"Address.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\u0027s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call.value(value)(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"},"Context.sol":{"content":"pragma solidity ^0.5.16;\n\n// via https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/GSN/Context.sol\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}"},"ERC1155.sol":{"content":"pragma solidity ^0.5.12;\n\nimport \"./IERC165.sol\";\nimport \"./SafeMath.sol\";\nimport \"./IERC1155TokenReceiver.sol\";\nimport \"./IERC1155.sol\";\nimport \"./Address.sol\";\n\n\n/**\n * @dev Implementation of Multi-Token Standard contract\n */\ncontract ERC1155 is IERC165 {\n  using SafeMath for uint256;\n  using Address for address;\n\n\n  /***********************************|\n  |        Variables and Events       |\n  |__________________________________*/\n\n  // onReceive function signatures\n  bytes4 constant internal ERC1155_RECEIVED_VALUE = 0xf23a6e61;\n  bytes4 constant internal ERC1155_BATCH_RECEIVED_VALUE = 0xbc197c81;\n\n  // Objects balances\n  mapping (address =\u003e mapping(uint256 =\u003e uint256)) internal balances;\n\n  // Operator Functions\n  mapping (address =\u003e mapping(address =\u003e bool)) internal operators;\n\n  // Events\n  event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _amount);\n  event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _amounts);\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n  event URI(string _uri, uint256 indexed _id);\n\n\n  /***********************************|\n  |     Public Transfer Functions     |\n  |__________________________________*/\n\n  /**\n   * @notice Transfers amount amount of an _id from the _from address to the _to address specified\n   * @param _from    Source address\n   * @param _to      Target address\n   * @param _id      ID of the token type\n   * @param _amount  Transfered amount\n   * @param _data    Additional data with no specified format, sent in call to `_to`\n   */\n  function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes memory _data)\n    public\n  {\n    require((msg.sender == _from) || isApprovedForAll(_from, msg.sender), \"ERC1155#safeTransferFrom: INVALID_OPERATOR\");\n    require(_to != address(0),\"ERC1155#safeTransferFrom: INVALID_RECIPIENT\");\n    // require(_amount \u003e= balances[_from][_id]) is not necessary since checked with safemath operations\n\n    _safeTransferFrom(_from, _to, _id, _amount);\n    _callonERC1155Received(_from, _to, _id, _amount, _data);\n  }\n\n  /**\n   * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\n   * @param _from     Source addresses\n   * @param _to       Target addresses\n   * @param _ids      IDs of each token type\n   * @param _amounts  Transfer amounts per token type\n   * @param _data     Additional data with no specified format, sent in call to `_to`\n   */\n  function safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data)\n    public\n  {\n    // Requirements\n    require((msg.sender == _from) || isApprovedForAll(_from, msg.sender), \"ERC1155#safeBatchTransferFrom: INVALID_OPERATOR\");\n    require(_to != address(0), \"ERC1155#safeBatchTransferFrom: INVALID_RECIPIENT\");\n\n    _safeBatchTransferFrom(_from, _to, _ids, _amounts);\n    _callonERC1155BatchReceived(_from, _to, _ids, _amounts, _data);\n  }\n\n\n  /***********************************|\n  |    Internal Transfer Functions    |\n  |__________________________________*/\n\n  /**\n   * @notice Transfers amount amount of an _id from the _from address to the _to address specified\n   * @param _from    Source address\n   * @param _to      Target address\n   * @param _id      ID of the token type\n   * @param _amount  Transfered amount\n   */\n  function _safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount)\n    internal\n  {\n    // Update balances\n    balances[_from][_id] = balances[_from][_id].sub(_amount); // Subtract amount\n    balances[_to][_id] = balances[_to][_id].add(_amount);     // Add amount\n\n    // Emit event\n    emit TransferSingle(msg.sender, _from, _to, _id, _amount);\n  }\n\n  /**\n   * @notice Verifies if receiver is contract and if so, calls (_to).onERC1155Received(...)\n   */\n  function _callonERC1155Received(address _from, address _to, uint256 _id, uint256 _amount, bytes memory _data)\n    internal\n  {\n    // Check if recipient is contract\n    if (_to.isContract()) {\n      bytes4 retval = IERC1155TokenReceiver(_to).onERC1155Received(msg.sender, _from, _id, _amount, _data);\n      require(retval == ERC1155_RECEIVED_VALUE, \"ERC1155#_callonERC1155Received: INVALID_ON_RECEIVE_MESSAGE\");\n    }\n  }\n\n  /**\n   * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\n   * @param _from     Source addresses\n   * @param _to       Target addresses\n   * @param _ids      IDs of each token type\n   * @param _amounts  Transfer amounts per token type\n   */\n  function _safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts)\n    internal\n  {\n    require(_ids.length == _amounts.length, \"ERC1155#_safeBatchTransferFrom: INVALID_ARRAYS_LENGTH\");\n\n    // Number of transfer to execute\n    uint256 nTransfer = _ids.length;\n\n    // Executing all transfers\n    for (uint256 i = 0; i \u003c nTransfer; i++) {\n      // Update storage balance of previous bin\n      balances[_from][_ids[i]] = balances[_from][_ids[i]].sub(_amounts[i]);\n      balances[_to][_ids[i]] = balances[_to][_ids[i]].add(_amounts[i]);\n    }\n\n    // Emit event\n    emit TransferBatch(msg.sender, _from, _to, _ids, _amounts);\n  }\n\n  /**\n   * @notice Verifies if receiver is contract and if so, calls (_to).onERC1155BatchReceived(...)\n   */\n  function _callonERC1155BatchReceived(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data)\n    internal\n  {\n    // Pass data if recipient is contract\n    if (_to.isContract()) {\n      bytes4 retval = IERC1155TokenReceiver(_to).onERC1155BatchReceived(msg.sender, _from, _ids, _amounts, _data);\n      require(retval == ERC1155_BATCH_RECEIVED_VALUE, \"ERC1155#_callonERC1155BatchReceived: INVALID_ON_RECEIVE_MESSAGE\");\n    }\n  }\n\n\n  /***********************************|\n  |         Operator Functions        |\n  |__________________________________*/\n\n  /**\n   * @notice Enable or disable approval for a third party (\"operator\") to manage all of caller\u0027s tokens\n   * @param _operator  Address to add to the set of authorized operators\n   * @param _approved  True if the operator is approved, false to revoke approval\n   */\n  function setApprovalForAll(address _operator, bool _approved)\n    external\n  {\n    // Update operator status\n    operators[msg.sender][_operator] = _approved;\n    emit ApprovalForAll(msg.sender, _operator, _approved);\n  }\n\n  /**\n   * @notice Queries the approval status of an operator for a given owner\n   * @param _owner     The owner of the Tokens\n   * @param _operator  Address of authorized operator\n   * @return True if the operator is approved, false if not\n   */\n  function isApprovedForAll(address _owner, address _operator)\n    public view returns (bool isOperator)\n  {\n    return operators[_owner][_operator];\n  }\n\n\n  /***********************************|\n  |         Balance Functions         |\n  |__________________________________*/\n\n  /**\n   * @notice Get the balance of an account\u0027s Tokens\n   * @param _owner  The address of the token holder\n   * @param _id     ID of the Token\n   * @return The _owner\u0027s balance of the Token type requested\n   */\n  function balanceOf(address _owner, uint256 _id)\n    public view returns (uint256)\n  {\n    return balances[_owner][_id];\n  }\n\n  /**\n   * @notice Get the balance of multiple account/token pairs\n   * @param _owners The addresses of the token holders\n   * @param _ids    ID of the Tokens\n   * @return        The _owner\u0027s balance of the Token types requested (i.e. balance for each (owner, id) pair)\n   */\n  function balanceOfBatch(address[] memory _owners, uint256[] memory _ids)\n    public view returns (uint256[] memory)\n  {\n    require(_owners.length == _ids.length, \"ERC1155#balanceOfBatch: INVALID_ARRAY_LENGTH\");\n\n    // Variables\n    uint256[] memory batchBalances = new uint256[](_owners.length);\n\n    // Iterate over each owner and token ID\n    for (uint256 i = 0; i \u003c _owners.length; i++) {\n      batchBalances[i] = balances[_owners[i]][_ids[i]];\n    }\n\n    return batchBalances;\n  }\n\n\n  /***********************************|\n  |          ERC165 Functions         |\n  |__________________________________*/\n\n  /**\n   * INTERFACE_SIGNATURE_ERC165 = bytes4(keccak256(\"supportsInterface(bytes4)\"));\n   */\n  bytes4 constant private INTERFACE_SIGNATURE_ERC165 = 0x01ffc9a7;\n\n  /**\n   * INTERFACE_SIGNATURE_ERC1155 =\n   * bytes4(keccak256(\"safeTransferFrom(address,address,uint256,uint256,bytes)\")) ^\n   * bytes4(keccak256(\"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\")) ^\n   * bytes4(keccak256(\"balanceOf(address,uint256)\")) ^\n   * bytes4(keccak256(\"balanceOfBatch(address[],uint256[])\")) ^\n   * bytes4(keccak256(\"setApprovalForAll(address,bool)\")) ^\n   * bytes4(keccak256(\"isApprovedForAll(address,address)\"));\n   */\n  bytes4 constant private INTERFACE_SIGNATURE_ERC1155 = 0xd9b67a26;\n\n  /**\n   * @notice Query if a contract implements an interface\n   * @param _interfaceID  The interface identifier, as specified in ERC-165\n   * @return `true` if the contract implements `_interfaceID` and\n   */\n  function supportsInterface(bytes4 _interfaceID) external view returns (bool) {\n    if (_interfaceID == INTERFACE_SIGNATURE_ERC165 ||\n        _interfaceID == INTERFACE_SIGNATURE_ERC1155) {\n      return true;\n    }\n    return false;\n  }\n\n}"},"ERC1155Metadata.sol":{"content":"pragma solidity ^0.5.11;\nimport \"./IERC1155.sol\";\n\n\n/**\n * @notice Contract that handles metadata related methods.\n * @dev Methods assume a deterministic generation of URI based on token IDs.\n *      Methods also assume that URI uses hex representation of token IDs.\n */\ncontract ERC1155Metadata {\n\n  // URI\u0027s default URI prefix\n  string internal baseMetadataURI;\n  event URI(string _uri, uint256 indexed _id);\n\n\n  /***********************************|\n  |     Metadata Public Function s    |\n  |__________________________________*/\n\n  /**\n   * @notice A distinct Uniform Resource Identifier (URI) for a given token.\n   * @dev URIs are defined in RFC 3986.\n   *      URIs are assumed to be deterministically generated based on token ID\n   *      Token IDs are assumed to be represented in their hex format in URIs\n   * @return URI string\n   */\n  function uri(uint256 _id) public view returns (string memory) {\n    return string(abi.encodePacked(baseMetadataURI, _uint2str(_id), \".json\"));\n  }\n\n\n  /***********************************|\n  |    Metadata Internal Functions    |\n  |__________________________________*/\n\n  /**\n   * @notice Will emit default URI log event for corresponding token _id\n   * @param _tokenIDs Array of IDs of tokens to log default URI\n   */\n  function _logURIs(uint256[] memory _tokenIDs) internal {\n    string memory baseURL = baseMetadataURI;\n    string memory tokenURI;\n\n    for (uint256 i = 0; i \u003c _tokenIDs.length; i++) {\n      tokenURI = string(abi.encodePacked(baseURL, _uint2str(_tokenIDs[i]), \".json\"));\n      emit URI(tokenURI, _tokenIDs[i]);\n    }\n  }\n\n  /**\n   * @notice Will emit a specific URI log event for corresponding token\n   * @param _tokenIDs IDs of the token corresponding to the _uris logged\n   * @param _URIs    The URIs of the specified _tokenIDs\n   */\n  function _logURIs(uint256[] memory _tokenIDs, string[] memory _URIs) internal {\n    require(_tokenIDs.length == _URIs.length, \"ERC1155Metadata#_logURIs: INVALID_ARRAYS_LENGTH\");\n    for (uint256 i = 0; i \u003c _tokenIDs.length; i++) {\n      emit URI(_URIs[i], _tokenIDs[i]);\n    }\n  }\n\n  /**\n   * @notice Will update the base URL of token\u0027s URI\n   * @param _newBaseMetadataURI New base URL of token\u0027s URI\n   */\n  function _setBaseMetadataURI(string memory _newBaseMetadataURI) internal {\n    baseMetadataURI = _newBaseMetadataURI;\n  }\n\n\n  /***********************************|\n  |    Utility Internal Functions     |\n  |__________________________________*/\n\n  /**\n   * @notice Convert uint256 to string\n   * @param _i Unsigned integer to convert to string\n   */\n  function _uint2str(uint256 _i) internal pure returns (string memory _uintAsString) {\n    if (_i == 0) {\n      return \"0\";\n    }\n\n    uint256 j = _i;\n    uint256 ii = _i;\n    uint256 len;\n\n    // Get number of bytes\n    while (j != 0) {\n      len++;\n      j /= 10;\n    }\n\n    bytes memory bstr = new bytes(len);\n    uint256 k = len - 1;\n\n    // Get each individual ASCII\n    while (ii != 0) {\n      bstr[k--] = byte(uint8(48 + ii % 10));\n      ii /= 10;\n    }\n\n    // Convert to string\n    return string(bstr);\n  }\n\n}"},"ERC1155MintBurn.sol":{"content":"pragma solidity ^0.5.16;\n\nimport \"./ERC1155.sol\";\n\n\n/**\n * @dev Multi-Fungible Tokens with minting and burning methods. These methods assume\n *      a parent contract to be executed as they are `internal` functions\n */\ncontract ERC1155MintBurn is ERC1155 {\n\n\n  /****************************************|\n  |            Minting Functions           |\n  |_______________________________________*/\n\n  /**\n   * @notice Mint _amount of tokens of a given id\n   * @param _to      The address to mint tokens to\n   * @param _id      Token id to mint\n   * @param _amount  The amount to be minted\n   * @param _data    Data to pass if receiver is contract\n   */\n  function _mint(address _to, uint256 _id, uint256 _amount, bytes memory _data)\n    internal\n  {\n    // Add _amount\n    balances[_to][_id] = balances[_to][_id].add(_amount);\n\n    // Emit event\n    emit TransferSingle(msg.sender, address(0x0), _to, _id, _amount);\n\n    // Calling onReceive method if recipient is contract\n    _callonERC1155Received(address(0x0), _to, _id, _amount, _data);\n  }\n\n  /**\n   * @notice Mint tokens for each ids in _ids\n   * @param _to       The address to mint tokens to\n   * @param _ids      Array of ids to mint\n   * @param _amounts  Array of amount of tokens to mint per id\n   * @param _data    Data to pass if receiver is contract\n   */\n  function _batchMint(address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data)\n    internal\n  {\n    require(_ids.length == _amounts.length, \"ERC1155MintBurn#batchMint: INVALID_ARRAYS_LENGTH\");\n\n    // Number of mints to execute\n    uint256 nMint = _ids.length;\n\n     // Executing all minting\n    for (uint256 i = 0; i \u003c nMint; i++) {\n      // Update storage balance\n      balances[_to][_ids[i]] = balances[_to][_ids[i]].add(_amounts[i]);\n    }\n\n    // Emit batch mint event\n    emit TransferBatch(msg.sender, address(0x0), _to, _ids, _amounts);\n\n    // Calling onReceive method if recipient is contract\n    _callonERC1155BatchReceived(address(0x0), _to, _ids, _amounts, _data);\n  }\n\n\n  /****************************************|\n  |            Burning Functions           |\n  |_______________________________________*/\n\n  /**\n   * @notice Burn _amount of tokens of a given token id\n   * @param _from    The address to burn tokens from\n   * @param _id      Token id to burn\n   * @param _amount  The amount to be burned\n   */\n  function _burn(address _from, uint256 _id, uint256 _amount)\n    internal\n  {\n    //Substract _amount\n    balances[_from][_id] = balances[_from][_id].sub(_amount);\n\n    // Emit event\n    emit TransferSingle(msg.sender, _from, address(0x0), _id, _amount);\n  }\n\n  /**\n   * @notice Burn tokens of given token id for each (_ids[i], _amounts[i]) pair\n   * @param _from     The address to burn tokens from\n   * @param _ids      Array of token ids to burn\n   * @param _amounts  Array of the amount to be burned\n   */\n  function _batchBurn(address _from, uint256[] memory _ids, uint256[] memory _amounts)\n    internal\n  {\n    require(_ids.length == _amounts.length, \"ERC1155MintBurn#batchBurn: INVALID_ARRAYS_LENGTH\");\n\n    // Number of mints to execute\n    uint256 nBurn = _ids.length;\n\n     // Executing all minting\n    for (uint256 i = 0; i \u003c nBurn; i++) {\n      // Update storage balance\n      balances[_from][_ids[i]] = balances[_from][_ids[i]].sub(_amounts[i]);\n    }\n\n    // Emit batch mint event\n    emit TransferBatch(msg.sender, _from, address(0x0), _ids, _amounts);\n  }\n\n}"},"FCards.sol":{"content":"pragma solidity ^0.5.12;\n\nimport \"./Ownable.sol\";\nimport \u0027./ERC1155.sol\u0027;\nimport \u0027./ERC1155Metadata.sol\u0027;\nimport \u0027./ERC1155MintBurn.sol\u0027;\nimport \"./Strings.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Math.sol\";\nimport \"./SafeERC20.sol\";\nimport \"./IERC20.sol\";\n\n\ncontract fmanCards is ERC1155, ERC1155MintBurn, ERC1155Metadata, Ownable {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n  using Strings for string;\n\n  mapping (uint256 =\u003e uint256) public tokenSupply;\n  mapping (uint256 =\u003e bool) public isMintDrop;\n  mapping (uint256 =\u003e bool) public validSeason;\n  mapping (uint256 =\u003e bool) public validCard;\n\n  struct Card {\n    uint256 id;\n    uint256 price;\n    uint256 maxSupply;\n    uint256 maxOwned;\n    uint256 rank;\n  }\n\n  struct Season {\n    uint256 id;\n    uint256 rankOneProb;\n    uint256 rankTwoProb;\n    uint256 rankThreeProb;\n    uint256 rankFourProb;\n    uint256 rankFiveProb;\n    uint256 priceOf1;\n    uint256 priceOf5;\n    uint256 priceOf10;\n    uint256[] cIds;\n    mapping (uint256 =\u003e bool)  rakMintable;\n    uint256[]  ranks;\n  }\n\n  mapping (uint256 =\u003e Card) public cardById;\n  mapping (uint256 =\u003e Season) public seasonById;\n\n  // Contract name\n  string public name;\n  // Contract symbol\n  string public symbol;\n\n  // Define if sale is active\n  bool public saleIsActive = false;\n\n  // FMAN Token Contract Addy\n  address public fmanAddy = 0xC2aEbbBc596261D0bE3b41812820dad54508575b;\n\n  // Address of owner wallet\n  address payable private ownerAddress;\n\n  // Address of NFT dev\n  address payable private devAddress;\n\n  // Modifiers\n  modifier onlyDev() {\n      require(devAddress == msg.sender, \"dev: only dev can change their address.\");\n      _;\n  }\n\n  constructor(\n    string memory _name,\n    string memory _symbol,\n    address payable _devAddress\n  ) public {\n    name = _name;\n    symbol = _symbol;\n    ownerAddress = msg.sender;\n    devAddress = _devAddress;\n  }\n\n  function uri(\n    uint256 _id\n  ) public view returns (string memory) {\n    return Strings.strConcat(\n      baseMetadataURI,\n      Strings.uint2str(_id)\n    );\n  }\n\n  /**\n    * @dev Returns the total quantity for a token ID\n    * @param _id uint256 ID of the token to query\n    * @return amount of token in existence\n    */\n  function totalSupply(\n    uint256 _id\n  ) public view returns (uint256) {\n    return tokenSupply[_id];\n  }\n\n  /**\n   * @dev Will update the base URL of token\u0027s URI\n   * @param _newBaseMetadataURI New base URL of token\u0027s URI\n   */\n  function setBaseMetadataURI(\n    string memory _newBaseMetadataURI\n  ) public onlyOwner {\n    _setBaseMetadataURI(_newBaseMetadataURI);\n  }\n\n  /**\n   * Withdraws FMAN from contract address\n   */\n  function withdraw() public onlyOwner {\n      uint256 balance = IERC20(fmanAddy).balanceOf(address(this));\n      // 5% goes to NFT dev\n      uint256 balanceForDev = balance.div(10).div(2);\n      uint256 deltaBalance = balance.sub(balanceForDev);\n      IERC20(fmanAddy).transfer(devAddress, balanceForDev);\n      IERC20(fmanAddy).transfer(ownerAddress, deltaBalance);\n\n  }\n\n  function setFMANAddy(address tokenaddy) public onlyOwner {\n      fmanAddy = tokenaddy;\n  }\n\n  function withdrawToken(address tokenAddy) public onlyOwner {\n      uint256 balance = IERC20(tokenAddy).balanceOf(address(this));\n      // 5% goes to NFT dev\n      uint256 balanceForDev = balance.div(10).div(2);\n      uint256 deltaBalance = balance.sub(balanceForDev);\n      IERC20(tokenAddy).transfer(devAddress, balanceForDev);\n      IERC20(tokenAddy).transfer(ownerAddress, deltaBalance);\n  }\n\n  /**\n   * Withdraws BNB from contract address\n   */\n  function WithdrawBeans() public onlyOwner {\n      uint256 balance = address(this).balance;\n      // 5% goes to NFT dev\n      uint256 balanceForDev = balance.div(10).div(2);\n      uint256 deltaBalance = balance.sub(balanceForDev);\n      devAddress.transfer(balanceForDev);\n      ownerAddress.transfer(deltaBalance);\n  }\n\n  /*\n   * Set owner address\n   */\n  function setOwnerAddress(address payable newOwnerAddress) public onlyOwner {\n      ownerAddress = newOwnerAddress;\n      transferOwnership(newOwnerAddress);\n  }\n\n  /*\n   * Set dev address\n   */\n  function setDevAddress(address payable newDevAddress) public onlyDev {\n      devAddress = newDevAddress;\n  }\n\n  function setSaleState(bool newState) public onlyOwner {\n      saleIsActive = newState;\n  }\n\n  function createCard(\n    uint256 _id,\n    uint256 _price,\n    uint256 _maxSupply,\n    uint256 _maxOwned,\n    uint256 _rank\n\n  ) public onlyOwner {\n    require(!validCard[_id], \"Card already exists\");\n    require(_maxSupply \u003e= 1, \"Above 0 max supply\");\n    require(_maxOwned \u003e= 1, \"Above 0 max owned\");\n    require(_rank \u003e= 1 \u0026\u0026 _rank \u003c=5, \"rank [1,5]\");\n\n    Card memory card = Card(_id, _price, _maxSupply, _maxOwned, _rank);\n    cardById[_id] = card;\n    validCard[_id] = true;\n  }\n\n  function getCardPrice(uint256 _id) public view returns(uint256){\n    require(validCard[_id], \"invalid card\");\n    return cardById[_id].price;\n  }\n\n  function getCardMaxSupply(uint256 _id) public view returns(uint256){\n    require(validCard[_id], \"invalid card\");\n    return cardById[_id].maxSupply;\n  }\n\n  function getCardMaxRank(uint256 _id) public view returns(uint256){\n    require(validCard[_id], \"invalid card\");\n    return cardById[_id].rank;\n  }\n\n  function getSeasonCards(uint256 _id) public view returns(uint256[] memory){\n    require(validSeason[_id], \"invalid season\");\n    return seasonById[_id].cIds;\n  }\n\n  function getSeasonPrice1(uint256 _id) public view returns(uint256){\n    require(validSeason[_id], \"invalid season\");\n    return seasonById[_id].priceOf1;\n  }\n\n  function getSeasonPrice5(uint256 _id) public view returns(uint256){\n    require(validSeason[_id], \"invalid season\");\n    return seasonById[_id].priceOf5;\n  }\n\n  function getSeasonPrice10(uint256 _id) public view returns(uint256){\n    require(validSeason[_id], \"invalid season\");\n    return seasonById[_id].priceOf10;\n  }\n\n  function setSeasonData(\n    uint256 _id,\n    uint256 _prob1,\n    uint256 _prob2,\n    uint256 _prob3,\n    uint256 _prob4,\n    uint256 _prob5,\n    uint256 _priceOf1,\n    uint256 _priceOf5,\n    uint256 _priceOf10\n  ) public onlyOwner {\n    require(validSeason[_id], \"Season doesnt exists\");\n    seasonById[_id].rankOneProb = _prob1;\n    seasonById[_id].rankTwoProb = _prob2;\n    seasonById[_id].rankThreeProb = _prob3;\n    seasonById[_id].rankFourProb = _prob4;\n    seasonById[_id].rankFiveProb = _prob5;\n    seasonById[_id].priceOf1 = _priceOf1;\n    seasonById[_id].priceOf5 = _priceOf5;\n    seasonById[_id].priceOf10 = _priceOf10;\n  }\n\n\n  function setCardData(\n    uint256 _id,\n    uint256 _price,\n    uint256 _maxSupply,\n    uint256 _maxOwned,\n    uint256 _rank\n\n\n  ) public onlyOwner {\n    require(validCard[_id], \"Card doesnt exists\");\n    cardById[_id].price = _price;\n    cardById[_id].maxOwned = _maxOwned;\n    cardById[_id].maxSupply = _maxSupply;\n    cardById[_id].rank = _rank;\n  }\n\n  function createSeason(\n    uint256[] memory _tokenIds,\n    uint256 _seasonId,\n    uint256 _rankOneProb,\n    uint256 _rankTwoProb,\n    uint256 _rankThreeProb,\n    uint256 _rankFourProb,\n    uint256 _rankFiveProb,\n    uint256 _priceOf1,\n    uint256 _priceOf5,\n    uint256 _priceOf10\n\n  ) public onlyOwner {\n    require(!validSeason[_seasonId], \"season already exists\");\n    require(_rankOneProb+_rankTwoProb+_rankThreeProb+_rankFourProb+_rankFiveProb==100, \"Need probabilities to equal 100\");\n    // TODO: check if the card ids passed in are all valid and have data\n    Season storage season = seasonById[_seasonId];\n    season.id = _seasonId;\n    for (uint i=0; i\u003c_tokenIds.length; i++) {\n      uint256 tokenId = _tokenIds[i];\n      require(validCard[tokenId],\"Card invalid make sure all card Ids are created\");\n      Card storage card = cardById[tokenId];\n      season.cIds.push(tokenId);\n      if(!season.rakMintable[card.rank]){\n        season.ranks.push(card.rank);\n        season.rakMintable[card.rank] = true;\n      }\n    }\n    season.rankOneProb = _rankOneProb;\n    season.rankTwoProb = _rankTwoProb;\n    season.rankThreeProb = _rankThreeProb;\n    season.rankFourProb = _rankFourProb;\n    season.rankFiveProb = _rankFiveProb;\n    season.priceOf1 = _priceOf1;\n    season.priceOf10 = _priceOf10;\n    season.priceOf5 = _priceOf5;\n\n\n    validSeason[_seasonId] = true;\n  }\n\n\n  function updateCardsInSeason(\n    uint256[] memory _tokenIds,\n    uint256 _seasonId\n  ) public onlyOwner {\n    require(validSeason[_seasonId], \"Invalid season ID\");\n    Season storage season = seasonById[_seasonId];\n    uint256[] memory cIds = new uint256[](_tokenIds.length);\n    uint256[] memory ranks = new uint256[](_tokenIds.length);\n    uint256 ranksLen = 0;\n    uint256 cIdLen = 0;\n    // clear rankMintable map 1-5\n    for (uint i=1; i\u003c6; i++) {\n      season.rakMintable[i] = false;\n    }\n    for (uint i=0; i\u003c_tokenIds.length; i++) {\n      uint256 tokenId = _tokenIds[i];\n      require(validCard[tokenId],\"Card invalid make sure all card Ids are created\");\n      Card storage card = cardById[tokenId];\n      require(tokenSupply[tokenId]\u003ccard.maxSupply,\"Card is already past its supply, update the card\u0027s maxSupply to add it\");\n      cIds[cIdLen]=tokenId;\n      cIdLen++;\n      if(!season.rakMintable[card.rank]){\n        ranks[ranksLen]=card.rank;\n        ranksLen++;\n        season.rakMintable[card.rank] = true;\n      }\n    }\n    season.ranks = ranks;\n    season.cIds = cIds;\n  }\n\n  function syncSeasonRanks(\n    uint256 seasonId\n  ) private {\n    require(validSeason[seasonId],\"Invalid season id\");\n    Season storage season = seasonById[seasonId];\n    uint256[] memory cIds = new uint256[](season.cIds.length);\n    uint256[] memory ranks = new uint256[](season.cIds.length);\n    uint256 ranksLen = 0;\n    uint256 cIdLen = 0;\n    // clear rankMintable map 1-5\n    for (uint i=1; i\u003c6; i++) {\n      season.rakMintable[i] = false;\n    }\n    for (uint i=0; i\u003cseason.cIds.length; i++) {\n      Card storage card = cardById[season.cIds[i]];\n      if(tokenSupply[card.id] \u003c card.maxSupply){\n        cIds[cIdLen] = card.id;\n        cIdLen++;\n        if(!season.rakMintable[card.rank]){\n          ranks[ranksLen]=card.rank;\n          ranksLen++;\n          season.rakMintable[card.rank] = true;\n        }\n      }\n\n    }\n    season.cIds = cIds;\n    season.ranks = ranks;\n  }\n\n\n  function setMintDrop(\n    uint256 _id,\n    bool _state\n  ) public onlyOwner{\n    require(validCard[_id],\"Card invalid make sure card with provided ID is created first.\");\n    isMintDrop[_id] = _state;\n  }\n\n  function mintDrop(\n    address _to,\n    uint256 _id,\n    uint256 _quantity,\n    bytes memory _data\n  ) public {\n    require(saleIsActive, \"Minting is currently disabled\");\n    require(isMintDrop[_id], \"Not a Mintdrop NFT\");\n    require(validCard[_id], \"Not a valid card ID\");\n    require(\n        _quantity \u003e= 1,\n        \"Must mint at least one token at a time\"\n    );\n    Card memory card = cardById[_id];\n    uint256 payableTokens = card.price.mul(_quantity) * 10**18;\n    require(\n        balanceOf(_to, _id).add(_quantity) \u003c= card.maxOwned,\n        \"The amount you are trying to mint puts you above maximum per wallet.\"\n    );\n    require(\n        tokenSupply[_id].add(_quantity) \u003c= card.maxSupply,\n        \"Mint would exceed max supply of token.\"\n    );\n    require(\n        IERC20(fmanAddy).balanceOf(msg.sender) \u003e= payableTokens,\n        \"Get your money up, not your funny up.\"\n    );\n\n    IERC20(fmanAddy).transferFrom(msg.sender, address(this), payableTokens);\n\n    _mint(_to, _id, _quantity, _data);\n    tokenSupply[_id] = tokenSupply[_id].add(_quantity);\n  }\n\n\n  function random() private view returns (uint256) {\n      return uint256(keccak256(abi.encodePacked(block.difficulty, block.timestamp)));\n  }\n\n  function getMintableCards(uint256[] memory _cards) private view returns (uint256[] memory) {\n    uint256[] memory mintableCards = new uint256[](_cards.length);\n    uint256 mintableCount = 0;\n\n    for (uint i=0; i\u003c_cards.length; i++) {\n      Card storage card = cardById[_cards[i]];\n      if(tokenSupply[card.id] \u003c card.maxSupply \u0026\u0026 balanceOf(msg.sender, card.id) \u003c card.maxOwned){\n        mintableCards[mintableCount]=card.id;\n        mintableCount++;\n      }\n    }\n\n    return mintableCards;\n  }\n\n  function getWinningRank(uint256 seasonId, uint256 randomness) private view returns (uint256) {\n    // random between 1-100\n    uint256 rank;\n    Season storage season = seasonById[seasonId];\n    uint256 randoMando = randomness.mod(100).add(1);\n    uint256 rankCount = 0;\n    for (uint i=1; i\u003c6; i++) {\n      if(season.rakMintable[i]){\n        rankCount++;\n      }\n    }\n    // if randoMando between (1 - rankFiveProb) then rank is 5\n    if(randoMando \u003e= 1 \u0026\u0026 randoMando \u003c= season.rankFiveProb \u0026\u0026 season.rakMintable[5]){\n      rank = 5;\n      // if randoMando between (rankFiveProb+1 - rankFiveProb+rankFourProb) then rank is 4\n    } else if(randoMando \u003e= season.rankFiveProb+1 \u0026\u0026 randoMando \u003c= season.rankFiveProb+season.rankFourProb \u0026\u0026 season.rakMintable[4]){\n      rank = 4;\n    } else if(randoMando \u003e= season.rankFiveProb+season.rankFourProb+1 \u0026\u0026 randoMando \u003c= season.rankFiveProb+season.rankFourProb+season.rankThreeProb \u0026\u0026 season.rakMintable[3]){\n      rank = 3;\n    } else if(randoMando \u003e= season.rankFiveProb+season.rankFourProb+season.rankThreeProb+1 \u0026\u0026 randoMando \u003c= season.rankFiveProb+season.rankFourProb+season.rankThreeProb+season.rankTwoProb \u0026\u0026 season.rakMintable[2]){\n      rank = 2;\n    } else if(randoMando \u003e= season.rankFiveProb+season.rankFourProb+season.rankThreeProb+season.rankTwoProb+1 \u0026\u0026 randoMando \u003c= season.rankFiveProb+season.rankFourProb+season.rankThreeProb+season.rankTwoProb+season.rankOneProb \u0026\u0026 season.rakMintable[1]){\n      rank = 1;\n    } else {\n      rank = season.ranks[random().mod(rankCount)];\n    }\n    return rank;\n  }\n\n  function getWinningCard(uint256 seasonId, uint256 randomness) private view returns (uint256) {\n    Season memory season = seasonById[seasonId];\n    uint256 rank = getWinningRank(season.id, randomness);\n    uint256[] memory cardCandidates = new uint256[](season.cIds.length);\n    uint256 candidateCount = 0;\n    uint256[] memory mintableCards = getMintableCards(season.cIds);\n    for (uint i=0; i\u003cmintableCards.length; i++) {\n      Card storage card = cardById[mintableCards[i]];\n      if(card.rank == rank){\n        cardCandidates[candidateCount] = card.id;\n        candidateCount++;\n      }\n    }\n    return cardCandidates[randomness.mod(candidateCount)];\n  }\n\n\n  function expand(uint256 randomValue, uint256 n) private pure returns (uint256[] memory expandedValues) {\n    expandedValues = new uint256[](n);\n    for (uint256 i = 0; i \u003c n; i++) {\n        expandedValues[i] = uint256(keccak256(abi.encode(randomValue, i)));\n    }\n    return expandedValues;\n  }\n\n  function mintSeason(\n    address _to,\n    uint256 _quantity,\n    uint256 _seasonId,\n    bytes memory _data\n  ) public {\n    require(saleIsActive, \"Minting is currently disabled\");\n    require(validSeason[_seasonId], \"Not a valid season ID\");\n    require(\n        _quantity == 1 || _quantity == 5 || _quantity == 10,\n        \"Must mint 1,5, or 10\"\n    );\n\n    Season memory season = seasonById[_seasonId];\n    require(season.ranks[0] \u003e 0, \"Season has no more cards/ranks to mint\");\n\n    uint256 payableTokens;\n    if(_quantity == 1){\n      payableTokens = season.priceOf1 * 10**18;\n    } else if(_quantity == 5){\n      payableTokens = season.priceOf5 * 10**18;\n    } else if(_quantity == 10){\n      payableTokens = season.priceOf10 * 10**18;\n    }\n    require(\n        IERC20(fmanAddy).balanceOf(msg.sender) \u003e= payableTokens,\n        \"Get your money up, not your funny up.\"\n    );\n    IERC20(fmanAddy).transferFrom(msg.sender, address(this), payableTokens);\n    uint256[] memory randomNumbers = expand(random(), _quantity);\n    for (uint i=0; i\u003c_quantity; i++) {\n      uint256 winnerCardId = getWinningCard(season.id, randomNumbers[i]);\n      _mint(_to, winnerCardId, 1, _data);\n      tokenSupply[winnerCardId] = tokenSupply[winnerCardId].add(1);\n      syncSeasonRanks(season.id);\n    }\n  }\n\n\n  /**\n   *\n   */\n  function isApprovedForAll(\n    address _owner,\n    address _operator\n  ) public view returns (bool isOperator) {\n\n    return ERC1155.isApprovedForAll(_owner, _operator);\n  }\n\n\n}"},"IERC1155.sol":{"content":"pragma solidity ^0.5.16;\n\n// via https://github.com/arcadeum/multi-token-standard/blob/master/contracts/interfaces/IERC1155.sol\n\ninterface IERC1155 {\n\n  /****************************************|\n  |                 Events                 |\n  |_______________________________________*/\n\n  /**\n   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\n   *   Operator MUST be msg.sender\n   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\n   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\n   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the \"circulating supply\" for a given token ID\n   *   To broadcast the existence of a token ID with no initial balance, the contract SHOULD emit the TransferSingle event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\n   */\n  event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _amount);\n\n  /**\n   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\n   *   Operator MUST be msg.sender\n   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\n   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\n   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the \"circulating supply\" for a given token ID\n   *   To broadcast the existence of multiple token IDs with no initial balance, this SHOULD emit the TransferBatch event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\n   */\n  event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _amounts);\n\n  /**\n   * @dev MUST emit when an approval is updated\n   */\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n  /**\n   * @dev MUST emit when the URI is updated for a token ID\n   *   URIs are defined in RFC 3986\n   *   The URI MUST point a JSON file that conforms to the \"ERC-1155 Metadata JSON Schema\"\n   */\n  event URI(string _amount, uint256 indexed _id);\n\n\n  /****************************************|\n  |                Functions               |\n  |_______________________________________*/\n\n  /**\n    * @notice Transfers amount of an _id from the _from address to the _to address specified\n    * @dev MUST emit TransferSingle event on success\n    * Caller must be approved to manage the _from account\u0027s tokens (see isApprovedForAll)\n    * MUST throw if `_to` is the zero address\n    * MUST throw if balance of sender for token `_id` is lower than the `_amount` sent\n    * MUST throw on any other error\n    * When transfer is complete, this function MUST check if `_to` is a smart contract (code size \u003e 0). If so, it MUST call `onERC1155Received` on `_to` and revert if the return amount is not `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n    * @param _from    Source address\n    * @param _to      Target address\n    * @param _id      ID of the token type\n    * @param _amount  Transfered amount\n    * @param _data    Additional data with no specified format, sent in call to `_to`\n    */\n  function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes calldata _data) external;\n\n  /**\n    * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\n    * @dev MUST emit TransferBatch event on success\n    * Caller must be approved to manage the _from account\u0027s tokens (see isApprovedForAll)\n    * MUST throw if `_to` is the zero address\n    * MUST throw if length of `_ids` is not the same as length of `_amounts`\n    * MUST throw if any of the balance of sender for token `_ids` is lower than the respective `_amounts` sent\n    * MUST throw on any other error\n    * When transfer is complete, this function MUST check if `_to` is a smart contract (code size \u003e 0). If so, it MUST call `onERC1155BatchReceived` on `_to` and revert if the return amount is not `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n    * Transfers and events MUST occur in the array order they were submitted (_ids[0] before _ids[1], etc)\n    * @param _from     Source addresses\n    * @param _to       Target addresses\n    * @param _ids      IDs of each token type\n    * @param _amounts  Transfer amounts per token type\n    * @param _data     Additional data with no specified format, sent in call to `_to`\n  */\n  function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external;\n\n  /**\n   * @notice Get the balance of an account\u0027s Tokens\n   * @param _owner  The address of the token holder\n   * @param _id     ID of the Token\n   * @return        The _owner\u0027s balance of the Token type requested\n   */\n  function balanceOf(address _owner, uint256 _id) external view returns (uint256);\n\n  /**\n   * @notice Get the balance of multiple account/token pairs\n   * @param _owners The addresses of the token holders\n   * @param _ids    ID of the Tokens\n   * @return        The _owner\u0027s balance of the Token types requested (i.e. balance for each (owner, id) pair)\n   */\n  function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);\n\n  /**\n   * @notice Enable or disable approval for a third party (\"operator\") to manage all of caller\u0027s tokens\n   * @dev MUST emit the ApprovalForAll event on success\n   * @param _operator  Address to add to the set of authorized operators\n   * @param _approved  True if the operator is approved, false to revoke approval\n   */\n  function setApprovalForAll(address _operator, bool _approved) external;\n\n  /**\n   * @notice Queries the approval status of an operator for a given owner\n   * @param _owner     The owner of the Tokens\n   * @param _operator  Address of authorized operator\n   * @return           True if the operator is approved, false if not\n   */\n  function isApprovedForAll(address _owner, address _operator) external view returns (bool isOperator);\n}"},"IERC1155TokenReceiver.sol":{"content":"pragma solidity ^0.5.16;\n\n// via https://github.com/arcadeum/multi-token-standard/blob/master/contracts/interfaces/IERC1155TokenReceiver.sol\n\n/**\n * @dev ERC-1155 interface for accepting safe transfers.\n */\ninterface IERC1155TokenReceiver {\n\n  /**\n   * @notice Handle the receipt of a single ERC1155 token type\n   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated\n   * This function MAY throw to revert and reject the transfer\n   * Return of other amount than the magic value MUST result in the transaction being reverted\n   * Note: The token contract address is always the message sender\n   * @param _operator  The address which called the `safeTransferFrom` function\n   * @param _from      The address which previously owned the token\n   * @param _id        The id of the token being transferred\n   * @param _amount    The amount of tokens being transferred\n   * @param _data      Additional data with no specified format\n   * @return           `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n   */\n  function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _amount, bytes calldata _data) external returns(bytes4);\n\n  /**\n   * @notice Handle the receipt of multiple ERC1155 token types\n   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated\n   * This function MAY throw to revert and reject the transfer\n   * Return of other amount than the magic value WILL result in the transaction being reverted\n   * Note: The token contract address is always the message sender\n   * @param _operator  The address which called the `safeBatchTransferFrom` function\n   * @param _from      The address which previously owned the token\n   * @param _ids       An array containing ids of each token being transferred\n   * @param _amounts   An array containing amounts of each token being transferred\n   * @param _data      Additional data with no specified format\n   * @return           `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n   */\n  function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external returns(bytes4);\n\n  /**\n   * @notice Indicates whether a contract implements the `ERC1155TokenReceiver` functions and so can accept ERC1155 token types.\n   * @param  interfaceID The ERC-165 interface ID that is queried for support.s\n   * @dev This function MUST return true if it implements the ERC1155TokenReceiver interface and ERC-165 interface.\n   *      This function MUST NOT consume more than 5,000 gas.\n   * @return Whether ERC-165 or ERC1155TokenReceiver interfaces are supported.\n   */\n  function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}"},"IERC165.sol":{"content":"pragma solidity ^0.5.16;\n\n// via https://github.com/arcadeum/multi-token-standard/blob/master/contracts/interfaces/IERC165.sol\n\n/**\n * @title ERC165\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n */\ninterface IERC165 {\n\n    /**\n     * @notice Query if a contract implements an interface\n     * @dev Interface identification is specified in ERC-165. This function\n     * uses less than 30,000 gas\n     * @param _interfaceId The interface identifier, as specified in ERC-165\n     */\n    function supportsInterface(bytes4 _interfaceId)\n    external\n    view\n    returns (bool);\n}"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.5.16;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    \n    \n    \n   \n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    \n    \n}\n"},"Math.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003e= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute.\n        return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"},"Ownable.sol":{"content":"pragma solidity ^0.5.16;\n\n// via https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/ownership/Ownable.sol\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public  onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public  onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal  {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}"},"SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.5.16;\n\nimport \"./IERC20.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) external {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \u0027safeIncreaseAllowance\u0027 and \u0027safeDecreaseAllowance\u0027\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n    \n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        \n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\u0027s return data size checking mechanism, since\n        // we\u0027re implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"},"SafeMath.sol":{"content":"pragma solidity ^0.5.11;\n\n// via https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}"},"Strings.sol":{"content":"pragma solidity ^0.5.16;\n\n// via https://github.com/ProjectOpenSea/opensea-erc1155/blob/master/contracts/Strings.sol\n\nlibrary Strings {\n  // via https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol\n  function strConcat(string memory _a, string memory _b, string memory _c, string memory _d, string memory _e) internal pure returns (string memory) {\n      bytes memory _ba = bytes(_a);\n      bytes memory _bb = bytes(_b);\n      bytes memory _bc = bytes(_c);\n      bytes memory _bd = bytes(_d);\n      bytes memory _be = bytes(_e);\n      string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n      bytes memory babcde = bytes(abcde);\n      uint k = 0;\n      for (uint i = 0; i \u003c _ba.length; i++) babcde[k++] = _ba[i];\n      for (uint i = 0; i \u003c _bb.length; i++) babcde[k++] = _bb[i];\n      for (uint i = 0; i \u003c _bc.length; i++) babcde[k++] = _bc[i];\n      for (uint i = 0; i \u003c _bd.length; i++) babcde[k++] = _bd[i];\n      for (uint i = 0; i \u003c _be.length; i++) babcde[k++] = _be[i];\n      return string(babcde);\n    }\n\n    function strConcat(string memory _a, string memory _b, string memory _c, string memory _d) internal pure returns (string memory) {\n        return strConcat(_a, _b, _c, _d, \"\");\n    }\n\n    function strConcat(string memory _a, string memory _b, string memory _c) internal pure returns (string memory) {\n        return strConcat(_a, _b, _c, \"\", \"\");\n    }\n\n    function strConcat(string memory _a, string memory _b) internal pure returns (string memory) {\n        return strConcat(_a, _b, \"\", \"\", \"\");\n    }\n\n    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint j = _i;\n        uint len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint k = len - 1;\n        while (_i != 0) {\n            bstr[k--] = byte(uint8(48 + _i % 10));\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n}"}}