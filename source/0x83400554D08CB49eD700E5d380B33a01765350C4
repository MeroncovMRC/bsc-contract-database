pragma solidity ^0.8.7;
// SPDX-License-Identifier: Unlicensed


abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return payable(msg.sender);
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}



contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor () {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    function owner() public view returns (address) {
        return _owner;
    }   
    
    modifier onlyOwner() {
        require(_owner == _msgSender(), "Ownable: caller is not the owner");
        _;
    }


    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }

}


abstract contract ReentrancyGuard {
   
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

   
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface BABT {
  function balanceOf(address account) external view returns (uint256);
}

contract Distributor is ReentrancyGuard, Context, Ownable {
    uint256 seed = 1;
    mapping(address=>bool) public isMint;
    mapping(address=>uint256) public refamount;
    address babt = 0x2B09d47D550061f995A3b5C6F0Fd58005215D7c8;
    address tokenAddress = 0x38E6B2e6C9DBEf6A8086e1e5c35c56E4D13C8789;
    uint256 refpercent = 10;
    uint256 tamount = 1000*10**18;
    bool mintStart = false;
    mapping(uint256=>address) public leader;
    event AddressAddition(address indexed _address);
    event AddressRemoval(address indexed _address);


    function leardboard() public view returns (address[] memory) {
        address [] memory a =new address[](10); 
        for (uint i=0;i<10;i++) {
            a[i] = leader[i];
        }
        return a;
    }

    function leardboardscore() public view returns (uint256[] memory) {
        uint256 [] memory a =new uint256[](10); 
        for (uint i=0;i<10;i++) {
            a[i] = refamount[leader[i]];
        }
        return a;
    }


    function mint(address _address) public {
        require(mintStart,"need mint start");
        require(BABT(babt).balanceOf(msg.sender)>0 , "need have babt");
        require(!isMint[msg.sender],"need not mint");
        isMint[msg.sender] = true;
        IERC20(tokenAddress).transfer(msg.sender, tamount);
        if(_address!= 0x0000000000000000000000000000000000000000){
            IERC20(tokenAddress).transfer(_address, tamount*refpercent/100); 
            refamount[_address] =  refamount[_address] + tamount*refpercent/100;
            updateRankings(_address);
        }
    }


    function checkMint(address addr) public view returns(bool){
        if(isMint[addr]){
            return false;
        }
        else if(BABT(babt).balanceOf(addr) == 0){
             return false;
        }
        else{
            return true;
        }
    }

    function updateRankings(address _address) private {
        for (uint i=0;i<10;i++) {
            if (refamount[_address] > refamount[leader[i]]){
                leader[i] = _address;
                break;
            }
        }
    }

    function setTokenAddress(address _value) public onlyOwner{
        tokenAddress = _value;
    }

    function setbabt(address _value) public onlyOwner{
        babt = _value;
    }

    function setMintStart(bool _value) public onlyOwner{
        mintStart = _value;
    }

    function setRefpercent(uint256 _value) public onlyOwner{
        refpercent = _value;
    }
    function setRefamount(address _address,uint256 _value) public onlyOwner{
        refamount[_address] = _value;
    }

    function setisMint(address _address,bool _value) public onlyOwner{
        isMint[_address] = _value;
    }

    function setTamount(uint256 _value) public onlyOwner{
        tamount = _value;
    }
    function takeTokens(IERC20 _tokenAddress,uint256 _tamount) public onlyOwner{
        IERC20(_tokenAddress).transfer(msg.sender, _tamount);
    }

    function withdraw() external onlyOwner{
        payable(msg.sender).transfer(address(this).balance);    
    }
}