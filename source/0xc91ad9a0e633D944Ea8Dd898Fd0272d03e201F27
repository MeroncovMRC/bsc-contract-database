pragma solidity ^ 0.6.2;

 interface IERC20 {
 	function totalSupply() external pure returns(uint256);
    function decimals() external view returns (uint8);
 	function balanceOf(address account) external view returns(uint256);
 	function transfer(address recipient, uint256 amount) external returns(bool);
 	function allowance(address owner, address spender) external view returns(uint256);
 	function approve(address spender, uint256 amount) external returns(bool);
 	function transferFrom(address sender, address recipient, uint256 amount) external returns(bool);
 	event Transfer(address indexed from, address indexed to, uint256 value);
 	event Approval(address indexed owner, address indexed spender, uint256 value);
 }

 library SafeMath {
 	function add(uint256 a, uint256 b) internal pure returns(uint256) {
 		uint256 c = a + b;
 		require(c >= a, "SafeMath: addition overflow");
 		return c;
 	}

 	function sub(uint256 a, uint256 b) internal pure returns(uint256) {
 		return sub(a, b, "SafeMath: subtraction overflow");
 	}

 	function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {
 		require(b <= a, errorMessage);
 		uint256 c = a - b;
 		return c;
 	}

 	function mul(uint256 a, uint256 b) internal pure returns(uint256) {
 		// benefit is lost if 'b' is also tested.
 		if (a == 0) {
 			return 0;
 		}
 		uint256 c = a * b;
 		require(c / a == b, "SafeMath: multiplication overflow");
 		return c;
 	}

 	function div(uint256 a, uint256 b) internal pure returns(uint256) {
 		return div(a, b, "SafeMath: division by zero");
 	}

 	function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {
 		require(b > 0, errorMessage);
 		uint256 c = a / b;
 		return c;
 	}

 	function mod(uint256 a, uint256 b) internal pure returns(uint256) {
 		return mod(a, b, "SafeMath: modulo by zero");
 	}

 	function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {
 		require(b != 0, errorMessage);
 		return a % b;
 	}
 }

 library Address {
 	function isContract(address account) internal view returns(bool) {
 		bytes32 codehash;
 		bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
 		assembly {
 			codehash:= extcodehash(account)
 		}
 		return (codehash != accountHash && codehash != 0x0);
 	}

 	function sendValue(address payable recipient, uint256 amount) internal {
 		require(address(this).balance >= amount, "Address: insufficient balance");
 		(bool success, ) = recipient.call {
 			value: amount
 		}("");
 		require(success, "Address: unable to send value, recipient may have reverted");
 	}

 	function functionCall(address target, bytes memory data) internal returns(bytes memory) {
 		return functionCall(target, data, "Address: low-level call failed");
 	}

 	function functionCall(address target, bytes memory data, string memory errorMessage) internal returns(bytes memory) {
 		return _functionCallWithValue(target, data, 0, errorMessage);
 	}

 	function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns(bytes memory) {
 		return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
 	}

 	function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns(bytes memory) {
 		require(address(this).balance >= value, "Address: insufficient balance for call");
 		return _functionCallWithValue(target, data, value, errorMessage);
 	}

 	function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns(bytes memory) {
 		require(isContract(target), "Address: call to non-contract");
 		(bool success, bytes memory returndata) = target.call {
 			value: weiValue
 		}(data);
 		if (success) {
 			return returndata;
 		} else {
 			if (returndata.length > 0) {

 				assembly {
 					let returndata_size:= mload(returndata)
 					revert(add(32, returndata), returndata_size)
 				}
 			} else {
 				revert(errorMessage);
 			}
 		}
 	}
 }



 abstract contract Context {
 	function _msgSender() internal view virtual returns(address payable) {
 		return msg.sender;
 	}

 	function _msgData() internal view virtual returns(bytes memory) {
 		this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
 		return msg.data;
 	}
 }


 contract Ownable is Context {
 	address private _owner;
 	event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
 	constructor() internal {
 		address msgSender = _msgSender();
 		_owner = msgSender;
 		emit OwnershipTransferred(address(0), msgSender);
 	}

 	function owner() public view returns(address) {
 		return _owner;
 	}
 	modifier onlyOwner() {
 		require(_owner == _msgSender(), "Ownable: caller is not the owner");
 		_;
 	}

 	function renounceOwnership() public virtual onlyOwner {
 		emit OwnershipTransferred(_owner, address(0));
 		_owner = address(0);
 	}

 	function transferOwnership(address newOwner) public virtual onlyOwner {
 		require(newOwner != address(0), "Ownable: new owner is the zero address");
 		emit OwnershipTransferred(_owner, newOwner);
 		_owner = newOwner;
 	}
 }



 contract BUSDCAPITAL is Ownable {
 	using SafeMath
 	for uint256;

  struct UserData {
           uint256 userid;
           uint256 amountdp;
           uint256 amountwd;
           uint256 uplineid;
           uint256 limit;
           address addr;
           uint256 blockdeposit;
       }

   struct HistoryDp 
        {
           address addr ;
           uint256 userid;
           uint256 amount;
           uint  time;
		   uint256 blockdeposit;
        }

    struct HistoryWd {
          address addr;
          uint256 userid;
          uint256 amount;
          uint  time;
        } 

     struct HistoryWdB {
          address addr;
          uint256 userid;
          uint256 amount;
          uint  time;
        } 


	mapping(address => uint256) public UseridByAddr;
    mapping(uint256 => address) public AddrByUserid;
    mapping(uint256 => bool) public UserIdExist;
    
   
 	mapping(address => UserData) public userInfo;
	mapping(uint256 => HistoryDp) public userDeposit;
	mapping(uint256 => HistoryWd) public userWithdraw;
    mapping(uint256 => HistoryWdB) public userWithdrawB;

	mapping(uint256 => uint256) public UplineIdById;
    address[] public UserList;

	uint256 public DepositLength;
	uint256 public WithdrawLength;
    uint256 public WithdrawbLength;
    uint256 public TotalDeposit;
    uint256 public TotalWithdraw;


	address BUSD = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;
    address SERVER;
    address NETWORK;
	 

	constructor() public {
		SERVER =  address(msg.sender); 
        NETWORK =  address(msg.sender); 
 	}

    function updateserver(address server,address network) public onlyOwner {
        if(server!=address(0))SERVER = server;
        if(network!=address(0))NETWORK = network;
    }

    function deposit(uint256 amount) public {
        if(amount>0){} else return;
		address useraddress = address(msg.sender);
		if(UseridByAddr[useraddress] == 0)return;
        UserData storage user = userInfo[useraddress];
		HistoryDp storage dp = userDeposit[DepositLength];
        if(user.amountdp.sub(user.amountwd).add(amount)>user.limit) return;

		IERC20(BUSD).transferFrom(address(msg.sender), SERVER, amount);
	 
		//update data deposit
		dp.addr = useraddress;
        dp.userid = user.userid;
        dp.amount = amount;
        dp.time= now;
		dp.blockdeposit =block.number;

	    //add to user data
		user.amountdp = user.amountdp.add(amount);
        user.blockdeposit =block.number;
	 
		//data
		TotalDeposit = TotalDeposit.add(amount);
		DepositLength++;

	}

    function withdraw(uint256 amount) public {
		address useraddress = address(msg.sender);
		if(UseridByAddr[useraddress] == 0)return;
		UserData storage user = userInfo[useraddress];
		HistoryWd storage wd = userWithdraw[WithdrawLength];
		if(user.addr != useraddress) return;//not your
		uint256 withdrawable = user.amountdp.sub(user.amountwd);
        if(withdrawable<amount) return;
		 
        uint256 amountsend  = amount;
        if(user.blockdeposit>block.number.sub(862590))amountsend = amount.mul(95).div(100);
        wd.addr = useraddress;
        wd.userid = user.userid;
        wd.amount = amountsend;
        wd.time = now;
		
		//data
		user.amountwd = user.amountwd.add(amount);
        TotalWithdraw = TotalWithdraw.add(amount);
        WithdrawLength++;
	 	
	}

    function withdrawb() public {
		address useraddress = address(msg.sender);
		if(UseridByAddr[useraddress] == 0)return;
		UserData storage user = userInfo[useraddress];
		HistoryWdB storage wd = userWithdrawB[WithdrawbLength];
		 
        wd.addr   = useraddress;
        wd.userid = user.userid;
        wd.time = now;
		 
        WithdrawbLength++;
	 	
	}

    function register(uint256 userid,uint256 upline,uint256 package) public {
        address useraddress = address(msg.sender);
		if(userid==1)AddrByUserid[upline]=useraddress;
        if(UseridByAddr[useraddress]>0)return;
        UserData storage user = userInfo[useraddress];
		if(UserIdExist[upline] == false && upline > 1)return;
        if(UserIdExist[userid] == false)
        if(user.userid==0){
            uint256 amount = 10e18;
            if(package==2)amount =  25e18;
            if(package==3)amount =  50e18;
            if(package==4)amount =  100e18;
            if(package==5)amount =  500e18;
            if(package==6)amount =  1000e18;
            if(package>6)return;
            
            IERC20(BUSD).transferFrom(address(msg.sender), NETWORK, amount);

            user.userid = userid;
            user.amountdp = 0;
            user.uplineid = upline;
            user.limit = amount.mul(10);

            UplineIdById[userid] = upline;
            UserList.push(useraddress);
            UseridByAddr[useraddress] = userid;
            AddrByUserid[userid]=useraddress;
            UserIdExist[userid] = true;
        }
    }

 
 }