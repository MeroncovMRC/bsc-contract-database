{"BscSwapper.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./IBEP20.sol\";\r\nimport \"./ExpxRouter.sol\";\r\nimport \"./UniswapRouter.sol\";\r\n\r\ncontract BscSwapper {\r\n\r\n    address private constant EMPTY_ADDRESS =\r\n        0x0000000000000000000000000000000000000000;\r\n\r\n    address private _owner;\r\n\r\n    constructor() {\r\n        _owner = msg.sender;\r\n    }\r\n\r\n    function getBalance(\r\n        address token\r\n    ) external view returns(uint256) {\r\n        return IBEP20(token).balanceOf(address(this));\r\n    }\r\n\r\n    function extractFunds(\r\n        address token,\r\n        uint256 amount\r\n    ) external {\r\n        IBEP20(token).transfer(_owner, amount);\r\n    }\r\n\r\n    function getAmounts(\r\n        uint256 amountIn,\r\n        address[] memory pools,\r\n        address[] memory pairs,\r\n        uint256[] memory mults,\r\n        address[] memory route\r\n    )  internal view returns (\r\n        uint256[] memory amounts\r\n    ) {\r\n        amounts = new uint256[](route.length);\r\n        amounts[0] = amountIn;\r\n\r\n        for (uint256 i = 0; i \u003c pairs.length; i++) {\r\n            if (isEmpty(pools[i])) {\r\n                amounts[i+1] = UniswapRouter.getAmountOut(pairs[i],\r\n                    route[i], route[i+1], mults[i], amounts[i]);\r\n            } else {\r\n                amounts[i+1] = ExpxRouter.getAmountOut(pools[i],\r\n                    route[i], route[i+1], amounts[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    function swap(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] memory pools,\r\n        address[] memory pairs,\r\n        uint256[] memory mults,\r\n        address[] memory route\r\n    ) external {\r\n        uint256[] memory amounts = getAmounts(amountIn, pools, pairs, mults, route);\r\n        require(amounts[amounts.length - 1] \u003e= amountOutMin, \"BscSwapper: output error\");\r\n\r\n        for (uint256 i = 0; i \u003c pairs.length; i++) {\r\n            if (isEmpty(pools[i])) {\r\n                if (needUniswapTransfer(i, pairs)) {\r\n                    IBEP20(route[i]).transfer(pairs[i], amounts[i]);\r\n                }\r\n\r\n                address recipient = getUniswapRecipient(i, pairs);\r\n                UniswapRouter.swap(pairs[i], route[i],\r\n                    route[i+1], amounts[i+1], recipient);\r\n            } else {\r\n                ExpxRouter.swap(pools[i], route[i],\r\n                    route[i+1], amounts[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    function needUniswapTransfer(\r\n        uint256 i,\r\n        address[] memory pairs\r\n    ) private pure returns(bool) {\r\n        return i == 0 || isEmpty(pairs[i-1]);\r\n    }\r\n\r\n    function getUniswapRecipient(\r\n        uint256 i,\r\n        address[] memory pairs\r\n    ) private view returns(\r\n        address recipient\r\n    ) {\r\n        if (i+1 == pairs.length) {\r\n            recipient = address(this);\r\n        } else if (isEmpty(pairs[i+1])) {\r\n            recipient = address(this);\r\n        } else {\r\n            recipient = pairs[i+1];\r\n        }\r\n    }\r\n\r\n    function isEmpty(\r\n        address addr\r\n    ) private pure returns(bool) {\r\n        return addr == EMPTY_ADDRESS;\r\n    }\r\n}"},"ExpxRouter.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./IBEP20.sol\";\r\nimport \"./IExpxPool.sol\";\r\n\r\nlibrary ExpxRouter {\r\n\r\n    function swap(\r\n        address pool,\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 amountIn\r\n    ) internal {\r\n        IBEP20(tokenIn).approve(pool, amountIn);\r\n        IExpxPool(pool).swapExactAmountIn(tokenIn,\r\n            amountIn, tokenOut, 0, type(uint256).max);\r\n    }\r\n\r\n    function getAmountOut(\r\n        address pool,\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 amountIn\r\n    ) internal view returns (\r\n        uint256 amountOut\r\n    ) {\r\n        IExpxPool instance = IExpxPool(pool);\r\n\r\n        amountOut = instance.calcOutGivenIn(\r\n            instance.getBalance(tokenIn),\r\n            instance.getDenormalizedWeight(tokenIn),\r\n            instance.getBalance(tokenOut),\r\n            instance.getDenormalizedWeight(tokenOut),\r\n            amountIn, instance.getSwapFee());\r\n    }\r\n}"},"IBEP20.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IBEP20 {\r\n\r\n    function balanceOf(\r\n        address whom\r\n    ) external view returns (uint256);\r\n\r\n    function approve(\r\n        address spender,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function transfer(\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}"},"IExpxPool.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IExpxPool {\r\n\r\n    function swapExactAmountIn(\r\n        address tokenIn,\r\n        uint256 amountIn,\r\n        address tokenOut,\r\n        uint256 minAmountOut,\r\n        uint256 maxPrice\r\n    ) external returns (\r\n        uint256 amountOut,\r\n        uint256 spotPriceAfter\r\n    );\r\n\r\n    function calcOutGivenIn(\r\n        uint256 balanceIn,\r\n        uint256 weightIn,\r\n        uint256 balanceOut,\r\n        uint256 weightOut,\r\n        uint256 amountIn,\r\n        uint256 swapFee\r\n    ) external pure returns (\r\n        uint256 amountOut\r\n    );\r\n\r\n    function getBalance(address token)\r\n    external view returns (uint256);\r\n\r\n    function getDenormalizedWeight(address token)\r\n    external view returns (uint256);\r\n\r\n    function getSwapFee()\r\n    external view returns (uint256);\r\n}"},"IPancakePair.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IPancakePair {\r\n\r\n    function swap(\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address recipient,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function getReserves() external view\r\n    returns (uint256, uint256, uint256);\r\n\r\n    function swapFee() external view\r\n    returns (uint256);\r\n}"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint x, uint y)\r\n    internal pure returns (uint z) {\r\n        require((z = x + y) \u003e= x,\r\n            \"SafeMath: add overflow\");\r\n    }\r\n\r\n    function mul(uint x, uint y)\r\n    internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x,\r\n            \"SafeMath: mul overflow\");\r\n    }\r\n}"},"UniswapRouter.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./IBEP20.sol\";\r\nimport \"./IPancakePair.sol\";\r\nimport \"./SafeMath.sol\";\r\n\r\nlibrary UniswapRouter {\r\n\r\n    using SafeMath for uint256;\r\n    uint256 private constant BASE_MULT = 10000;\r\n\r\n    function swap(\r\n        address pair,\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 amountOut,\r\n        address recipient\r\n    ) internal {\r\n        address token0 = tokenIn \u003c tokenOut ? tokenIn : tokenOut;\r\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ?\r\n            (uint256(0), amountOut) : (amountOut, uint256(0));\r\n\r\n        IPancakePair(pair).swap(amount0Out,\r\n            amount1Out, recipient, new bytes(0));\r\n    }\r\n\r\n    function getAmountOut(\r\n        address pair,\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 feeMult,\r\n        uint256 amountIn\r\n    ) internal view returns (\r\n        uint256 amountOut\r\n    ) {\r\n        (uint256 reserveIn, uint256 reserveOut) =\r\n        getReserves(pair, tokenIn, tokenOut);\r\n\r\n        uint256 amountInWithFee = amountIn.mul(feeMult);\r\n        uint256 numerator = amountInWithFee.mul(reserveOut);\r\n        uint256 denominator = reserveIn.mul(BASE_MULT).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    function getReserves(\r\n        address pair,\r\n        address tokenIn,\r\n        address tokenOut\r\n    ) internal view returns (\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) {\r\n        address token0 = tokenIn \u003c tokenOut ? tokenIn : tokenOut;\r\n        (uint256 r0, uint256 r1, ) = IPancakePair(pair).getReserves();\r\n        (reserveIn, reserveOut) = tokenIn == token0 ? (r0, r1) : (r1, r0);\r\n    }\r\n}"}}