//▄▀█ █ █▀█ █▀▄ █▀█ █▀█ █▀█   █▀▀ █▀█ █▀▀ ▀█ █▀█
//█▀█ █ █▀▄ █▄▀ █▀▄ █▄█ █▀▀   ██▄ █▀▄ █▄▄ █▄ █▄█
pragma solidity 0.8.19;

interface IERC20{
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
}

contract AirdropERC20{

    mapping(address => Roles) public roles;
    address public owner;

    enum Roles{
        RESTRICTED,
        OWNER,
        AIRDROPPER
    }

    struct AirdropUser{
        address user;
        uint256 amount;
    }

    modifier onlyOwner {
      require(roles[msg.sender] == Roles.OWNER, "You are not owner!!");
        _;
    }

    constructor(address _owner, address[] memory airdroppers){
        roles[_owner] = Roles.OWNER;
        owner=_owner;
        for(uint256 i=0; i < airdroppers.length; i++){
            roles[airdroppers[i]] = Roles.AIRDROPPER;
        }
    }

    function batchTransfer(
        address token,
        address from,
        AirdropUser[] memory airdropUsers
    ) external {
        require(roles[msg.sender] > Roles.RESTRICTED, "Not owner or airdropper!");

        for (uint256 i = 0; i < airdropUsers.length; i++) {
            IERC20(token).transferFrom(from, airdropUsers[i].user, airdropUsers[i].amount);
        }
    }

    function batchTransfer2(
        address token,
        address from,
        AirdropUser[] memory airdropUsers
    ) external {
        require(roles[msg.sender] > Roles.RESTRICTED, "Not owner or airdropper!");
        uint256 length = airdropUsers.length;

        for (uint256 i = 0; i < length; i++) {
            IERC20(token).transferFrom(from, airdropUsers[i].user, airdropUsers[i].amount);
        }
    }

    function addAirdropper(address newAirdropper) external onlyOwner {
        roles[newAirdropper] = Roles.AIRDROPPER;
    }

    function removeAirdropper(address newAirdropper) external onlyOwner {
        roles[newAirdropper] = Roles.RESTRICTED;
    }

    function changeOwner(address newOwner, Roles prevOwnerRole) external onlyOwner {
        roles[msg.sender] = prevOwnerRole;
        roles[newOwner] = Roles.OWNER;
        owner= msg.sender;
    }
}