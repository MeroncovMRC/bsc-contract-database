{"IERC20.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\ninterface IERC20 {\n\n    function totalSupply() external view returns (uint256);\n    \n    function symbol() external view returns(string memory);\n    \n    function name() external view returns(string memory);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n    \n    /**\n     * @dev Returns the number of decimal places\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"},"PUSDVault.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\nimport \"./IERC20.sol\";\nimport \"./SafeMath.sol\";\n\ninterface IToken {\n    function sellFor(uint256 amount, address recipient) external returns (bool);\n    function setShare(address user, uint256 newShare) external;\n    function getOwner() external view returns (address);\n}\n\ninterface IDistributor {\n    function setShare(address user, uint256 newShare) external;\n}\n\n/**\n    Reflectionary Token Wrapper With Dual Reflections And Rebasing\n    Created By DeFi Mark\n */\ncontract EPTX is IERC20 {\n\n    using SafeMath for uint256;\n\n    // Staking Token\n    IERC20 public constant token = IERC20(0x988ce53ca8d210430d4a9af0DF4b7dD107A50Db6);\n\n    // Staking Protocol Token Info\n    string private constant _name = \u0027PTX MAXI\u0027;\n    string private constant _symbol = \u0027ePTX\u0027;\n    uint8 private constant _decimals = 18;\n\n    // Trackable User Info\n    struct UserInfo {\n        uint256 balance;\n        uint256 unlockBlock;\n        uint256 totalStaked;\n        uint256 totalWithdrawn;\n    }\n    // User -\u003e UserInfo\n    mapping ( address =\u003e UserInfo ) public userInfo;\n\n    // Unstake Early Fee\n    uint256 public leaveEarlyFee = 100;\n\n    // Timer For Leave Early Fee\n    uint256 public leaveEarlyFeeTimer = 201600;\n\n    // Tracker For Leave Early Fees\n    uint256 public totalLeaveEarlyFeesTaken;\n\n    // total supply of MAXI\n    uint256 private _totalSupply;\n\n    // Swapper To Purchase Token From BNB\n    address public tokenSwapper = 0xf3D1b4329d4E9ab5Ba3C02C527ADb2DE9d6D6034;\n\n    // Reward Distributor\n    address public distributor;\n\n    // precision factor\n    uint256 private constant precision = 10**18;\n\n    // Reentrancy Guard\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private _status;\n    modifier nonReentrant() {\n        require(_status != _ENTERED, \"Reentrancy Guard call\");\n        _status = _ENTERED;\n        _;\n        _status = _NOT_ENTERED;\n    }\n\n    // Ownership\n    modifier onlyOwner() {\n        require(\n            msg.sender == IToken(address(token)).getOwner(),\n            \u0027Only Token Owner\u0027\n        );\n        _;\n    }\n\n    // Events\n    event Deposit(address depositor, uint256 amountToken);\n    event Withdraw(address withdrawer, uint256 amountToken);\n    event FeeTaken(uint256 fee);\n\n    constructor() {\n\n        // set reentrancy\n        _status = _NOT_ENTERED;\n        \n        // emit transfer so bscscan registers contract as token\n        emit Transfer(address(0), msg.sender, 0);\n    }\n\n\n    /////////////////////////////////\n    /////    ERC20 FUNCTIONS    /////\n    /////////////////////////////////\n\n    function name() external pure override returns (string memory) {\n        return _name;\n    }\n    function symbol() external pure override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() external pure override returns (uint8) {\n        return _decimals;\n    }\n    function totalSupply() external view override returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    /** Shows The Value Of Users\u0027 Staked Token */\n    function balanceOf(address account) public view override returns (uint256) {\n        return ReflectionsFromContractBalance(userInfo[account].balance);\n    }\n\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\n        if (recipient == msg.sender) {\n            withdraw(amount, true);\n        }\n        return true;\n    }\n    function transferFrom(address, address recipient, uint256 amount) external override returns (bool) {\n        if (recipient == msg.sender) {\n            withdraw(amount, true);\n        }        \n        return true;\n    }\n\n\n    /////////////////////////////////\n    /////    OWNER FUNCTIONS    /////\n    /////////////////////////////////\n\n    function setLeaveEarlyFee(uint256 newLeaveEarlyFee) external onlyOwner {\n        require(\n            newLeaveEarlyFee \u003c= 800,\n            \u0027Early Fee Too High\u0027\n        );\n        leaveEarlyFee = newLeaveEarlyFee;\n    }\n    function setLeaveEarlyFeeTimer(uint256 newLeaveEarlyFeeTimer) external onlyOwner {\n        require(\n            newLeaveEarlyFeeTimer \u003c= 10**8,\n            \u0027Fee Timer Too High\u0027\n        );\n        leaveEarlyFeeTimer = newLeaveEarlyFeeTimer;\n    }\n    function setTokenSwapper(address newTokenSwapper) external onlyOwner {\n        require(\n            newTokenSwapper != address(0),\n            \u0027Zero Address\u0027\n        );\n        tokenSwapper = newTokenSwapper;\n    }\n    function setRewardDistributor(address newDistributor) external onlyOwner {\n        require(\n            newDistributor != address(0),\n            \u0027Zero Address\u0027\n        );\n        distributor = newDistributor;\n    }\n\n    function withdrawBNB() external onlyOwner {\n        (bool s,) = payable(msg.sender).call{value: address(this).balance}(\"\");\n        require(s, \u0027Error On BNB Withdrawal\u0027);\n    }\n\n    function recoverForeignToken(IERC20 _token) external onlyOwner {\n        require(\n            address(_token) != address(token),\n            \u0027Cannot Withdraw Staking Tokens\u0027\n        );\n        require(\n            _token.transfer(msg.sender, _token.balanceOf(address(this))),\n            \u0027Error Withdrawing Foreign Token\u0027\n        );\n    }\n\n\n    /////////////////////////////////\n    /////   PUBLIC FUNCTIONS    /////\n    /////////////////////////////////\n\n    /** Native Sent To Contract Will Buy And Stake Token\n        Standard Token Purchase Rates Still Apply\n     */\n    receive() external payable {\n        require(msg.value \u003e 0, \u0027Zero Value\u0027);\n        require(_status != _ENTERED, \"Reentrancy Guard call\");\n\n        // enable reentrancy lock\n        _status = _ENTERED;\n\n        // Track Balance Before Deposit\n        uint previousBalance = token.balanceOf(address(this));\n\n        // Purchase Staking Token\n        uint received = _buyToken(msg.value);\n\n        // mint appropriate balance to recipient\n        if (_totalSupply == 0 || previousBalance == 0) {\n            _registerFirstPurchase(msg.sender, received);\n        } else {\n            _mintTo(msg.sender, received, previousBalance);\n        }\n\n        // set share for user\n        IDistributor(distributor).setShare(msg.sender, userInfo[msg.sender].balance);\n\n        // disable reetrancy lock\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n        Transfers in `amount` of Token From Sender\n        And Locks In Contract, Minting MAXI Tokens\n     */\n    function deposit(uint256 amount) external nonReentrant {\n\n        // get user balance\n        uint balance = token.balanceOf(msg.sender);\n        if (balance \u003c= amount) {\n            amount = balance - 1;\n        }\n\n        // Track Balance Before Deposit\n        uint previousBalance = token.balanceOf(address(this));\n\n        // Transfer In Token\n        uint received = _transferIn(amount);\n\n        if (_totalSupply == 0 || previousBalance == 0) {\n            _registerFirstPurchase(msg.sender, received);\n        } else {\n            _mintTo(msg.sender, received, previousBalance);\n        }\n\n        // set share for user\n        IDistributor(distributor).setShare(msg.sender, userInfo[msg.sender].balance);\n    }\n\n    /**\n        Redeems `amount` of Underlying Tokens, As Seen From BalanceOf()\n     */\n    function withdraw(uint256 amount, bool forETH) public nonReentrant returns (uint256) {\n\n        // Token Amount Into Contract Balance Amount\n        uint MAXI_Amount = amount == balanceOf(msg.sender) ? userInfo[msg.sender].balance : TokenToContractBalance(amount);\n        return _withdraw(amount, MAXI_Amount, forETH);\n    }\n\n    /**\n        Redeems everything for user\n     */\n    function withdrawAll(bool forETH) public nonReentrant returns (uint256) {\n        return _withdraw(balanceOf(msg.sender), userInfo[msg.sender].balance, forETH);\n    }\n\n    function donate() external payable nonReentrant {\n        // buy staking token\n        _buyToken(address(this).balance);\n    }\n\n\n\n    //////////////////////////////////\n    /////   INTERNAL FUNCTIONS   /////\n    //////////////////////////////////\n\n    function _withdraw(uint256 amount, uint256 MAXI_Amount, bool forETH) internal returns (uint256) {\n        require(\n            userInfo[msg.sender].balance \u003e 0 \u0026\u0026\n            userInfo[msg.sender].balance \u003e= MAXI_Amount \u0026\u0026\n            balanceOf(msg.sender) \u003e= amount \u0026\u0026\n            amount \u003e 0 \u0026\u0026\n            MAXI_Amount \u003e 0,\n            \u0027Insufficient Funds\u0027\n        );\n\n        // burn MAXI Tokens From Sender\n        _burn(msg.sender, MAXI_Amount, amount);\n\n        // increment total withdrawn\n        userInfo[msg.sender].totalWithdrawn += amount;\n\n        // Take Fee If Withdrawn Before Timer\n        uint fee = remainingLockTime(msg.sender) == 0 ? 0 : _takeFee(amount.mul(leaveEarlyFee).div(1000));\n\n        // send amount less fee\n        uint256 sendAmount = amount.sub(fee);\n        uint256 balance = token.balanceOf(address(this));\n        if (sendAmount \u003e balance) {\n            sendAmount = balance;\n        }\n\n        // emit withdrawn event\n        emit Withdraw(msg.sender, sendAmount);\n\n        // set share for user\n        IDistributor(distributor).setShare(msg.sender, userInfo[msg.sender].balance); \n        \n        // transfer token to sender\n        if (forETH) {\n            require(\n                IToken(address(token)).sellFor(sendAmount, msg.sender),\n                \u0027Error Selling Tokens For Sender\u0027\n            );\n        } else {\n            require(\n                token.transfer(msg.sender, sendAmount),\n                \u0027Error On Token Transfer\u0027\n            );\n        }\n        return sendAmount;\n    }\n\n    /**\n        Registers the First Stake\n     */\n    function _registerFirstPurchase(address user, uint received) internal {\n        \n        // increment total staked\n        userInfo[user].totalStaked += received;\n\n        // mint MAXI Tokens To Sender\n        _mint(user, received, received);\n\n        emit Deposit(user, received);\n    }\n\n\n    function _takeFee(uint256 fee) internal returns (uint256) {\n        emit FeeTaken(fee);\n        unchecked {\n            totalLeaveEarlyFeesTaken += fee;\n        }\n        return fee;\n    }\n\n    function _mintTo(address sender, uint256 received, uint256 previousBalance) internal {\n        // Number Of Maxi Tokens To Mint\n        uint nToMint = (_totalSupply.mul(received).div(previousBalance));\n        require(\n            nToMint \u003e 0,\n            \u0027Zero To Mint\u0027\n        );\n\n        // increment total staked\n        userInfo[sender].totalStaked += received;\n\n        // mint MAXI Tokens To Sender\n        _mint(sender, nToMint, received);\n\n        emit Deposit(sender, received);\n    }\n\n    function _buyToken(uint amount) internal returns (uint256) {\n        require(\n            amount \u003e 0,\n            \u0027Zero Amount\u0027\n        );\n        uint before = token.balanceOf(address(this));\n        (bool s,) = payable(tokenSwapper).call{value: amount}(\"\");\n        require(s, \u0027Failure On Token Purchase\u0027);\n        uint received = token.balanceOf(address(this)).sub(before);\n        require(received \u003e 0, \u0027Zero Received\u0027);\n        return received;\n    }\n\n    function _transferIn(uint256 amount) internal returns (uint256) {\n        uint before = token.balanceOf(address(this));\n        require(\n            token.transferFrom(msg.sender, address(this), amount),\n            \u0027Failure On TransferFrom\u0027\n        );\n        uint received = token.balanceOf(address(this)).sub(before);\n        require(\n            received \u003c= amount \u0026\u0026 received \u003e 0,\n            \u0027Error On Transfer In\u0027\n        );\n        return received;\n    }\n\n    /**\n     * Burns `amount` of Contract Balance Token\n     */\n    function _burn(address from, uint256 amount, uint256 amountToken) private {\n        userInfo[from].balance = userInfo[from].balance.sub(amount);\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(from, address(0), amountToken);\n    }\n\n    /**\n     * Mints `amount` of Contract Balance Token\n     */\n    function _mint(address to, uint256 amount, uint256 stablesWorth) private {\n        // allocate\n        userInfo[to].balance = userInfo[to].balance.add(amount);\n        _totalSupply = _totalSupply.add(amount);\n        // update locker info\n        userInfo[to].unlockBlock = block.number + leaveEarlyFeeTimer;\n        emit Transfer(address(0), to, stablesWorth);\n    }\n\n\n\n    /////////////////////////////////\n    /////    READ FUNCTIONS    //////\n    /////////////////////////////////\n\n    /**\n        Converts A Staking Token Amount Into A MAXI Amount\n     */\n    function TokenToContractBalance(uint256 amount) public view returns (uint256) {\n        return amount.mul(precision).div(_calculatePrice());\n    }\n\n    /**\n        Converts A MAXI Amount Into An Token Amount\n     */\n    function ReflectionsFromContractBalance(uint256 amount) public view returns (uint256) {\n        return amount.mul(_calculatePrice()).div(precision);\n    }\n\n    /** Conversion Ratio For MAXI -\u003e Token */\n    function calculatePrice() external view returns (uint256) {\n        return _calculatePrice();\n    }\n\n    /**\n        Lock Time Remaining For Stakers\n     */\n    function remainingLockTime(address user) public view returns (uint256) {\n        return userInfo[user].unlockBlock \u003c block.number ? 0 : userInfo[user].unlockBlock - block.number;\n    }\n\n    /** Returns Total Profit for User In Token From MAXI */\n    function getTotalProfits(address user) external view returns (uint256) {\n        uint top = balanceOf(user) + userInfo[user].totalWithdrawn;\n        return top \u003c= userInfo[user].totalStaked ? 0 : top - userInfo[user].totalStaked;\n    }\n    \n    /** Conversion Ratio For MAXI -\u003e Token */\n    function _calculatePrice() internal view returns (uint256) {\n        uint256 backingValue = token.balanceOf(address(this));\n        return (backingValue.mul(precision)).div(_totalSupply);\n    }\n\n    /** function has no use in contract */\n    function allowance(address, address) external pure override returns (uint256) { \n        return 0;\n    }\n    /** function has no use in contract */\n    function approve(address spender, uint256) public override returns (bool) {\n        emit Approval(msg.sender, spender, 0);\n        return true;\n    }\n}"},"SafeMath.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"}}