
// File: contracts/interface/IERC20.sol
interface IERC20{
    function balanceOf(address) external view returns(uint256);
    function transfer(address, uint256) external;
    function transferFrom(address, address, uint256) external;
    function approve(address, uint256) external;
    function totalSupply() external view returns(uint256);
    function decimals() external view returns(uint256);
    function symbol() external view returns(string memory);

    function withdraw(uint256) external;
    function deposit() external payable;
}


// File: contracts/interface/storage/ITokenStorage.sol
interface ITokenStorage{
    function getTokens() external view returns(address[] memory);
    function getTokens(uint256) external view returns(address[] memory);
    function getTokenLength() external view returns(uint256);
    function WBNB() external view returns(address);
    function BUSD() external view returns(address);
    function name() external view returns(string memory);
}

// File: contracts/interface/swapper/IBiswap.sol
interface IBiswapFactory {
    function getPair(address tokenA, address tokenB) external view returns (IBiswapPair pair);
    function allPairs(uint) external view returns (IBiswapPair pair);
    function allPairsLength() external view returns (uint);
}
interface IBiswapPair{
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
    function swapFee() external view returns (uint32);
}

interface IBiswapRouter{
    function factory() external view returns(IBiswapFactory);
}

// File: contracts/interface/swapper/IDex.sol

interface IDexFactory {
    function isPair(address pair) external view returns (bool);
    function getPair(address tokenA, address token) external view returns (IDexPair);
    function createPair(address tokenA, address tokenB, bool stable) external returns (address pair);
    function allPairs(uint256) external view returns(IDexPair);
    function allPairsLength() external view returns (uint);
}

interface IDexPair {
    function transferFrom(address src, address dst, uint amount) external returns (bool);
    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
    function burn(address to) external returns (uint amount0, uint amount1);
    function mint(address to) external returns (uint liquidity);
    function getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);
    function getAmountOut(uint, address) external view returns (uint);
    function token0() external view returns(address);
    function token1() external view returns(address);
    function factory() external view returns(IDexFactory);
}

// File: contracts/interface/swapper/IDODO.sol
import "../IERC20.sol";
interface IDODOFactory{
    function getDODOPool(address baseToken, address quoteToken) external view returns (address[] memory pools);
    function getDODOPoolBidirection(address token0, address token1) external view returns (address[] memory baseToken0Pool, address[] memory baseToken1Pool);
    function _OWNER_() external view returns(IDODOAdmin);
}

interface IDODOPair {
    function querySellBase(address trader, uint256 payBaseAmount) external view returns (uint256 receiveQuoteAmount, uint256 mtFee, RState newRState, uint256 newBaseTarget);
    function querySellQuote(address trader, uint256 payQuoteAmount) external view returns (uint256 receiveBaseAmount, uint256 mtFee, RState newRState, uint256 newQuoteTarget);
    enum RState {ONE, ABOVE_ONE, BELOW_ONE}
    struct PMMState {
        uint256 i;
        uint256 K;
        uint256 B;
        uint256 Q;
        uint256 B0;
        uint256 Q0;
        RState R;
    }
    function _OWNER_() external view returns(IDODOAdmin);
    function _BASE_TOKEN_() external view returns(IERC20);
    function _QUOTE_TOKEN_() external view returns(IERC20);
    function version() external view returns(string memory);
    function flashLoan(uint256 baseAmount, uint256 quoteAmount, address assetTo, bytes calldata data) external;
    function getUserFeeRate(address user) external view returns (uint256 lpFeeRate, uint256 mtFeeRate);
}

interface IDODOAdmin{
    function _OWNER_() external view returns(address);
    function _DPP_() external view returns(IDODOPair);
}

// File: contracts/interface/swapper/IPancake.sol

interface IPancakeFactoryV2{
    function isPair(address pair) external view returns (bool);
    function getPair(address tokenA, address tokenB) external view returns (IPancakePairV2);
    function createPair(address tokenA, address tokenB, bool stable) external returns (address pair);
    function allPairs(uint256) external view returns(IPancakePairV2);
    function allPairsLength() external view returns (uint);
}

interface IPancakePairV2{
    function name() external view returns(string memory);
    function symbol() external view returns(string memory);
    function transferFrom(address src, address dst, uint amount) external returns (bool);
    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
    function burn(address to) external returns (uint amount0, uint amount1);
    function mint(address to) external returns (uint liquidity);
    function getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);
    function getAmountOut(uint, address) external view returns (uint);
    function token0() external view returns (address);
    function token1() external view returns (address);
    function factory() external view returns(IPancakeFactoryV2);
}

// File: contracts/interface/swapper/IThena.sol
import "./IDex.sol";
interface IThenaFactory is IDexFactory{
    function getPair(address tokenA, address token, bool stable) external view returns (IThenaPair);
    function getFee(bool) external view returns(uint256);
    function pairCodeHash() external view returns (bytes32);
    function isPaused() external view returns(bool);
}

interface IThenaPair is IDexPair{
    function isStable() external view returns(bool);
    function stable() external view returns(bool);
}

interface IThenaRouter{
    function factory() external view returns(IThenaFactory);
    function getPairFor(address, address, bool) external view returns(IThenaPair);
    function getAmountOut(uint amountIn, address tokenIn, address tokenOut) external view returns (uint amount, bool stable);
}

// File: contracts/storage/dexStorage.sol
import "../interface/swapper/IPancake.sol";
import "../interface/swapper/IDODO.sol";
import "../interface/swapper/IBiswap.sol";
import "../interface/swapper/IThena.sol";

import "../interface/storage/ITokenStorage.sol";

contract dexStorage{
   constructor(){
        owner = msg.sender;
        original = address(this);
    }
    // fallback() external{}
    address public owner;
    address public original;
    string public name = "dexStorage";
    ITokenStorage public tokenStorage;
    IPancakeFactoryV2 constant pancakeFactoryV2 = IPancakeFactoryV2(0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73);
    uint256 public constant pancakeFee = 25;

    IBiswapFactory constant biswapFactory = IBiswapFactory(0x858E3312ed3A876947EA49d572A7C42DE08af7EE);
    IThenaFactory constant thenaFactory = IThenaFactory(0xAFD89d21BdB66d00817d4153E055830B1c2B3970);
    // IDODOFactory constant dodoFactoryPrivate = IDODOFactory(0xd9CAc3D964327e47399aebd8e1e6dCC4c251DaAE);

    modifier onlyOwner(){
        require(owner == msg.sender, "access denied. owner ONLY.");
        _;
    }

    modifier delegatecallOnly(){
        require(address(this) != original, "delegatecall ONLY");
        _;
    }

    function setTokenStorage(address _tokenStorage) external onlyOwner{
        require(_isTokenStorage(_tokenStorage) == true, "It's not tokenStorage");
        _setTokenStorage(_tokenStorage);
    }

    struct dexInfo{
        address pair;
        uint256 amountOut;
    }

    function swap(address _pair, address _tokenOut, uint256 _amountOut, bytes memory data) external delegatecallOnly{
        if( _isPancakePairV2(_pair) == true || _isBiswapPair(_pair) == true || _isThenaPair(_pair) == true ){
            bool token0Out = IPancakePairV2(_pair).token0() == _tokenOut;
            IPancakePairV2(_pair).swap(token0Out == true ? _amountOut:0, token0Out == true ? 0: _amountOut, address(this), data);
        }else revert("not found pair type");
    }

    function getSwapPair(address _tokenIn, address _tokenOut, uint256 _amountIn) external view returns(address){
        require(address(tokenStorage) != address(0), "tokenStorage is not initialized");
        require(_tokenIn != address(0) && _tokenOut != address(0), "tokens should not be zero");
        dexInfo memory bestPair;
        if( _tokenIn == address(0)){
            _tokenIn = tokenStorage.WBNB();
        }
        if( _tokenOut == address(0)){
            _tokenOut = tokenStorage.WBNB();
        }

        if(_tokenIn != _tokenOut ){
            address biswapPair = address(biswapFactory.getPair(_tokenIn, _tokenOut));
            if( biswapPair != address(0) && IERC20(_tokenIn).balanceOf(biswapPair) > _amountIn){
               uint256 amount = _getPairAmountOut(biswapPair, _tokenIn, _amountIn, IBiswapPair(biswapPair).swapFee());
               if( amount > bestPair.amountOut){
                bestPair.pair = biswapPair;
                bestPair.amountOut = amount;
               }
            }

            address pancakePair = address(pancakeFactoryV2.getPair(_tokenIn, _tokenOut));
            if( pancakePair != address(0) && IERC20(_tokenIn).balanceOf(pancakePair) > _amountIn){
                uint256 amount = _getPairAmountOut(pancakePair, _tokenIn, _amountIn, pancakeFee);
                if( amount > bestPair.amountOut){
                    bestPair.pair = pancakePair;
                    bestPair.amountOut = amount;
                }
            }
        }else if( _tokenIn == _tokenOut ){
            address[] memory tokens = tokenStorage.getTokens(3);
            bool thenaDisabled = thenaFactory.isPaused();
            for(uint256 i=0; i<tokens.length; i++){
                if( thenaDisabled == true ) break;
                if( tokens[i] == _tokenIn) continue;
                address pair = address(thenaFactory.getPair(_tokenIn, tokens[i], true));
                if( pair == address(0)) continue;
                if( IERC20(_tokenIn).balanceOf(pair) > _amountIn){
                    bestPair.pair = pair;
                    break;
                }
            }
            for(uint256 i=0; i<tokens.length && bestPair.pair == address(0); i++){
                if( tokens[i] == _tokenIn) continue;
                address pair = address(biswapFactory.getPair(_tokenIn, tokens[i]));
                if( pair == address(0)) continue;
                if( IERC20(_tokenIn).balanceOf(pair) > _amountIn && IBiswapPair(pair).swapFee()*10 < pancakeFee ){
                    bestPair.pair = pair;
                    break;
                }
            }
            for(uint256 i=0; i<tokens.length && bestPair.pair == address(0); i++){
                if( tokens[i] == _tokenIn) continue;
                address pair = address(pancakeFactoryV2.getPair(_tokenIn, tokens[i]));
                if( pair == address(0)) continue;
                if( IERC20(_tokenIn).balanceOf(pair) > _amountIn ){
                    bestPair.pair = pair;
                    break;
                }
            }
        }
        
        return bestPair.pair;
    }

    function thenaFee(bool _stable) external view returns(uint256){
        return thenaFactory.getFee(_stable);
    }

    function _getPairAmountOut(address _pair, address _tokenIn, uint256 _amountIn, uint256 _fee ) internal view returns(uint256 amountOut){
        IPancakePairV2 pair = IPancakePairV2(_pair);
        (uint256 reserveIn, uint256 reserveOut,) = pair.getReserves();
        if(pair.token0() != _tokenIn) (reserveIn, reserveOut) = (reserveOut, reserveIn);
        if( reserveIn > 0 && reserveOut > 0 && _amountIn > 0){
            amountOut = getAmountOut(_amountIn, reserveIn, reserveOut, _fee);
        }
    }

    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset
    function getAmountOut(uint256 _amountIn, uint256 _reserveIn, uint256 _reserveOut, uint256 _fee) public pure returns (uint256 amountOut) {
        require(_amountIn > 0, 'PancakeLibrary: INSUFFICIENT_INPUT_AMOUNT');
        require(_reserveIn > 0 && _reserveOut > 0, 'PancakeLibrary: INSUFFICIENT_LIQUIDITY');
        uint256 amountInWithFee = _amountIn * (10000-_fee);
        uint256 numerator = amountInWithFee * _reserveOut;
        uint256 denominator = _reserveIn * 10000 + amountInWithFee;
        amountOut = numerator / denominator;
    }

    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset
    function getAmountIn(uint256 _amountOut, uint256 _reserveIn, uint256 _reserveOut, uint256 _fee) public pure returns (uint amountIn) {
        require(_amountOut > 0, 'PancakeLibrary: INSUFFICIENT_OUTPUT_AMOUNT');
        require(_reserveIn > 0 && _reserveOut > 0, 'PancakeLibrary: INSUFFICIENT_LIQUIDITY');
        uint256 numerator = _reserveIn * _amountOut * 10000;
        uint256 denominator = (_reserveOut - _amountOut) * (10000-_fee);
        amountIn = (numerator / denominator) + 1;
    }

    function _setTokenStorage(address _tokenStorage) internal {
        tokenStorage = ITokenStorage(_tokenStorage);
    }

    function _isTokenStorage(address _tokenStorage) internal view returns(bool){
        if( _hasName(_tokenStorage, "tokenStorage") == true ) return true;
        return false;
    }
    
    function _isPancakePairV2(address _pair) internal view returns(bool){
        if( _hasName(_pair, "Pancake LPs") == true) return true;
        return false;
    }

    function _isBiswapPair(address _pair) internal view returns(bool){
        if( _hasName(_pair, "Biswap LPs") == true) return true;
        return false;
    }

    function _isThenaPair(address _pair) internal view returns(bool){
        try IThenaPair(_pair).isStable() returns(bool){
            return true;
        }catch{}
        return false;
    }

    function _isPancakeFactoryV2(address _factory) internal view returns(bool){
        try IPancakeFactoryV2(_factory).allPairs(0) returns(IPancakePairV2 pair){
            if( _isPancakePairV2(address(pair)) == true) return true;
        }catch{}
        return false;
    }

    function _isDODOFactory(address _factory) internal view returns(bool){
        try IDODOFactory(_factory)._OWNER_() returns(IDODOAdmin){
            return true;
        }catch{}
        return false;
    }

    function _isDODOPool(address _pool) internal view returns(bool){
        return _isDODOFactory(_pool);
    }
    function _hasName(address _addr, string memory _name) internal view returns(bool){
        (bool success, bytes memory data) = _addr.staticcall(abi.encodeWithSignature("name()"));
        if(success == false ) return false;
        bytes32 nameHash = keccak256(abi.encodePacked(_name));
        if(keccak256(abi.encodePacked(abi.decode(data, (string)))) == nameHash) return true;
        return false;
    }
}
