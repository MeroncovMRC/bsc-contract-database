{"Distributor.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\nimport \"./IERC20.sol\";\n\ninterface IToken {\n    function getOwner() external view returns (address);\n}\n\ninterface IMAXI {\n    function token() external view returns (IERC20);\n}\n\ncontract RewardDistributor is IERC20 {\n\n    // Token With Governance\n    address public immutable ownableToken = 0x988ce53ca8d210430d4a9af0DF4b7dD107A50Db6;\n\n    // MAXI Staking Protocol\n    address public immutable MAXI;\n\n    // Internal Token Metrics\n    string private constant _name = \u0027PUSD Rewards\u0027;\n    string private constant _symbol = \u0027rPUSD\u0027;\n    uint8 private constant _decimals = 18;\n\n    // Current Reward Token\n    address public constant rewardToken = 0x9fE2C7040c4b3a8F08d6a8f271a6d15bDADD52B9;\n\n    // User -\u003e Share\n    struct UserInfo {\n        // share in MAXI\n        uint256 balance;\n        // excluded reward debt\n        uint256 totalExcluded;\n        // index in allUsers array\n        uint256 index;\n    }\n    mapping ( address =\u003e UserInfo ) public userInfo;\n    address[] public allUsers;\n\n    // Tracking Info\n    uint256 public totalRewards;\n    uint256 public totalShares;\n    uint256 private dividendsPerShare;\n    uint256 private constant precision = 10**18;\n\n    // Ownership\n    modifier onlyOwner() {\n        require(\n            msg.sender == IToken(ownableToken).getOwner(),\n            \u0027Only Token Owner\u0027\n        );\n        _;\n    }\n    \n    modifier onlyMAXI() {\n        require(\n            msg.sender == MAXI,\n            \u0027Only MAXI Can Call\u0027\n        );\n        _;\n    }\n\n    constructor(\n        address MAXI_\n    ) {\n        require(\n            MAXI_ != address(0),\n            \u0027Zero Addresses\u0027\n        );\n\n        // immutables\n        MAXI = MAXI_;\n    }\n\n\n\n    ////////////////////////////////\n    /////    TOKEN FUNCTIONS    ////\n    ////////////////////////////////\n\n    function name() external pure override returns (string memory) {\n        return _name;\n    }\n    function symbol() external pure override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() external pure override returns (uint8) {\n        return _decimals;\n    }\n    function totalSupply() external view override returns (uint256) {\n        return IERC20(rewardToken).balanceOf(address(this));\n    }\n\n    /** Shows The Amount Of Users\u0027 Pending Rewards */\n    function balanceOf(address account) public view override returns (uint256) {\n        return pendingRewards(account);\n    }\n\n    function transfer(address recipient, uint256) external override returns (bool) {\n        require(\n            userInfo[recipient].balance \u003e 0,\n            \u0027Zero Balance\u0027\n        );\n        _sendReward(recipient);\n        return true;\n    }\n    function transferFrom(address, address recipient, uint256) external override returns (bool) {\n        require(\n            userInfo[recipient].balance \u003e 0,\n            \u0027Zero Balance\u0027\n        );\n        _sendReward(recipient);\n        return true;\n    }\n\n    /** function has no use in contract */\n    function allowance(address, address) external pure override returns (uint256) { \n        return 0;\n    }\n    /** function has no use in contract */\n    function approve(address, uint256) public override returns (bool) {\n        emit Approval(msg.sender, msg.sender, 0);\n        return true;\n    }\n\n\n\n    ////////////////////////////////\n    /////    OWNER FUNCTIONS    ////\n    ////////////////////////////////\n\n    function withdraw(address token, uint256 amount) external onlyOwner {\n        IERC20(token).transfer(msg.sender, amount);\n    }\n\n    function setShare(address user, uint256 newShare) external onlyMAXI {\n        if (userInfo[user].balance \u003e 0) {\n            _sendReward(user);\n        }\n\n        if (userInfo[user].balance == 0 \u0026\u0026 newShare \u003e 0) {\n            // new user\n            userInfo[user].index = allUsers.length;\n            allUsers.push(user);\n        } else if (userInfo[user].balance \u003e 0 \u0026\u0026 newShare == 0) {\n            // user is leaving\n            _removeUser(user);\n        }\n\n        // update total supply and user tracking info\n        totalShares = totalShares - userInfo[user].balance + newShare;\n        userInfo[user].balance = newShare;\n        userInfo[user].totalExcluded = getTotalExcluded(newShare);\n    }\n\n\n\n    /////////////////////////////////\n    /////   PUBLIC FUNCTIONS    /////\n    /////////////////////////////////\n\n    function donateRewards() external payable {\n        _donateRewards();\n    }\n\n    receive() external payable {\n        _donateRewards();\n    }\n\n    function donate(uint256 amount) external {\n        uint256 received = _transferIn(rewardToken, amount);\n        _register(received);\n    }\n\n\n    /////////////////////////////////\n    ////   INTERNAL FUNCTIONS    ////\n    /////////////////////////////////\n\n    function _donateRewards() internal {\n\n        // Token Before\n        uint before = IERC20(rewardToken).balanceOf(address(this));\n\n        // Use Reward Token Swapper To Purchase Reward Tokens\n        (bool s,) = payable(rewardToken).call{value: address(this).balance}(\"\");\n        require(s, \u0027Failure On Swapper Purchase\u0027);\n\n        // Check Amount Received\n        uint After = IERC20(rewardToken).balanceOf(address(this));\n        require(\n            After \u003e before,\n            \u0027Zero Received\u0027\n        );\n\n        // Register Amount Received\n        uint received = After - before;\n        _register(received);\n    }\n\n    function _sendReward(address user) internal {\n        if (userInfo[user].balance == 0) {\n            return;\n        }\n\n        // track pending\n        uint pending = pendingRewards(user);\n\n        // avoid overflow\n        if (pending \u003e IERC20(rewardToken).balanceOf(address(this))) {\n            pending = IERC20(rewardToken).balanceOf(address(this));\n        }\n\n        // update excluded earnings\n        userInfo[user].totalExcluded = getTotalExcluded(userInfo[user].balance);\n        \n        // send reward to user\n        if (pending \u003e 0) {\n            IERC20(rewardToken).transfer(user, pending);\n        }\n    }\n\n    function _register(uint256 amount) internal {\n\n        // Increment Total Rewards\n        unchecked {\n            totalRewards += amount;\n        }\n\n        if (totalShares \u003e 0) {\n            // Add Dividends Per Share\n            unchecked {\n                dividendsPerShare += ( precision * amount ) / totalShares;\n            }\n        }\n    }\n\n    function _transferIn(address token, uint256 amount) internal returns (uint256) {\n        uint before = IERC20(token).balanceOf(address(this));\n        require(\n            IERC20(token).transferFrom(msg.sender, address(this), amount),\n            \u0027Failure On TransferFrom\u0027\n        );\n        uint After = IERC20(token).balanceOf(address(this));\n        require(\n            After \u003e before,\n            \u0027Error On Transfer In\u0027\n        );\n        return After - before;\n    }\n\n    function _removeUser(address user) internal {\n\n        // index to replace\n        uint256 replaceIndex = userInfo[user].index;\n        if (allUsers[replaceIndex] != user) {\n            return;\n        }\n\n        // last user in array\n        address lastUser = allUsers[allUsers.length - 1];\n\n        // set last user\u0027s index to the replace index\n        userInfo[lastUser].index = replaceIndex;\n\n        // set replace index in array to last user\n        allUsers[replaceIndex] = lastUser;\n\n        // pop last user off the end of the array\n        allUsers.pop();\n        delete userInfo[user].index;\n    }\n\n\n    ////////////////////////////////\n    /////    READ FUNCTIONS    /////\n    ////////////////////////////////\n\n    function pendingRewards(address user) public view returns (uint256) {\n        if(userInfo[user].balance == 0){ return 0; }\n\n        uint256 userTotalExcluded = getTotalExcluded(userInfo[user].balance);\n        uint256 userTrackedExcluded = userInfo[user].totalExcluded;\n\n        if(userTotalExcluded \u003c= userTrackedExcluded){ return 0; }\n\n        return userTotalExcluded - userTrackedExcluded;\n    }\n\n    function getTotalExcluded(uint256 amount) public view returns (uint256) {\n        return ( amount * dividendsPerShare ) / precision;\n    }\n\n    function viewAllUsers() external view returns (address[] memory) {\n        return allUsers;\n    }\n\n    function holderCount() external view returns (uint256) {\n        return allUsers.length;\n    }\n}"},"IERC20.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\ninterface IERC20 {\n\n    function totalSupply() external view returns (uint256);\n    \n    function symbol() external view returns(string memory);\n    \n    function name() external view returns(string memory);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n    \n    /**\n     * @dev Returns the number of decimal places\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"}}