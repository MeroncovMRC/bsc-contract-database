// File: @openzeppelin/contracts/security/ReentrancyGuard.sol


// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)

pragma solidity ^0.8.0;

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and making it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        _nonReentrantBefore();
        _;
        _nonReentrantAfter();
    }

    function _nonReentrantBefore() private {
        // On the first call to nonReentrant, _status will be _NOT_ENTERED
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;
    }

    function _nonReentrantAfter() private {
        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a
     * `nonReentrant` function in the call stack.
     */
    function _reentrancyGuardEntered() internal view returns (bool) {
        return _status == _ENTERED;
    }
}

// File: contracts/0xGuard/BullGuard.sol

//SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;


contract BullGuard is ReentrancyGuard {

    uint256 public escrowCount;
    address public owner;
    mapping(address => uint256[]) public escrowMap;
    Escrow[] public escrows;

    uint256 public feesCollected;
    uint256 public feeCollector;

    struct Escrow {
        address payer;
        address payee;
        uint256 value;
        uint256 length;
        uint256 endTime;
        string clause;
        bool signed;
        bool onHold;
        uint256 ticketNumber;
    }

    event EscrowCreated (address indexed _payer, address indexed _payee, uint256 _amount, uint256 _hours);
    event EscrowSigned (address indexed _payer, uint256 _amount, uint256 _ticketNumber);

    function createEscrow(address _payer,
                          address _payee, 
                          uint256 _hours, 
                          uint256 _value,
                          string memory _clause) external nonReentrant{
        require(_value > 0, "An escrow must be worth more than 0 ETH.");
        require(_hours > 0, "An escrow must last longer than 1 hour");
        require(_payer != _payee, "The payer and payee must be 2 seperate addresses");
        require(msg.sender == _payer || msg.sender == _payee, "To create a contract, you must either be the payer or the payee");

        Escrow memory temp = Escrow({
            payer : _payer,
            payee : _payee,
            value : _value,
            length : _hours * 3600,
            endTime : 0,
            clause : _clause,
            signed : false,
            onHold : false,
            ticketNumber : escrows.length
        });

        escrows.push(temp);

        escrowMap[_payer].push(temp.ticketNumber);
        escrowMap[_payee].push(temp.ticketNumber);
        ++escrowCount;
        emit EscrowCreated (_payer, _payee, _value, _hours);
    }

    function signEscrowAsPayer(uint256 _ticketNumber) payable external nonReentrant {

        Escrow memory temp = escrows[_ticketNumber];

        require(temp.payer == msg.sender, "You are not the payer of this contract.");
        require(msg.value == (temp.value * 105 /100), "Insufficient funding");

        temp.signed = true;

        temp.endTime = block.timestamp + temp.length;
        escrows[_ticketNumber] = temp;

        emit EscrowSigned(msg.sender, msg.value, _ticketNumber);
    }

    function releaseFunds(uint256 _ticketNumber) external nonReentrant {
        Escrow memory temp = escrows[_ticketNumber];
        require(temp.payer == msg.sender, "You did not fund this contract.");
        require(temp.signed == true, "This contract has not yet been signed.");
        if(block.timestamp > temp.endTime){
            temp.onHold = true;
            escrows[_ticketNumber] = temp;
        }

        
        (bool payerSuccess,uint256 payerIndex) = findTicketNumber(_ticketNumber, escrowMap[temp.payer]);
        (bool payeeSuccess,uint256 payeeIndex) = findTicketNumber(_ticketNumber, escrowMap[temp.payee]);

        require (payerSuccess == true && payeeSuccess == true, "Could not find the ticket number");
        delete escrows[_ticketNumber];
        delete escrowMap[temp.payer][payerIndex];
        delete escrowMap[temp.payee][payeeIndex];

        require(temp.onHold == false, "This contract is on hold.");

        (bool success,) = temp.payee.call{value : temp.value}("");
        require(success, "Failed to release funds");

        
    }

    function findTicketNumber(uint256 _ticketNumber, uint256[] memory tickets) private pure returns (bool, uint256) {
        for(uint256 index; index < tickets.length; index++){
            if(tickets[index] == _ticketNumber){
                return (true, index);
                
            }
        }
        return (false, 0);
    }


}