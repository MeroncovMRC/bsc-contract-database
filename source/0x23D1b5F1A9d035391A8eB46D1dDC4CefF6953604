{"Address.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(account) }\n        return size \u003e 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length \u003e 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"},"Context.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"INDFILPool.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface INDFILPool {\n    function bindRelationshipExternal(address account, address referrer) external;\n}\n"},"LPTokenWrapper.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \u0027./SafeMath.sol\u0027;\nimport \u0027./SafeERC20.sol\u0027;\nimport \u0027./IERC20.sol\u0027;\ncontract LPTokenWrapper {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    IERC20 public _lpt;\n    uint256 private _totalSupply;\n    mapping(address =\u003e uint256) private _balances;\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n    function _stake(uint256 amount) public virtual {\n        _totalSupply = _totalSupply.add(amount);\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        _lpt.safeTransferFrom(msg.sender, address(this), amount);\n    }\n    function withdraw(uint256 amount) public virtual {\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        _lpt.safeTransfer(msg.sender, amount);\n    }\n}\n"},"NDCEXPoolV2.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \u0027./IERC20.sol\u0027;\nimport \u0027./INDFILPool.sol\u0027;\nimport \u0027./Ownable.sol\u0027;\nimport \u0027./LPTokenWrapper.sol\u0027;\n\ncontract NDCEXPoolV2 is LPTokenWrapper, Ownable {\n\n    uint public _pct;\n    uint256 public _lockDay;\n    uint256 public _totalReward;\n\n    uint256 public _totalToRelease;\n    address public _borrower;\n    IERC20 public _rewardToken;\n    INDFILPool public _relationToken;\n    uint256 public constant DURATION = 1 days;\n    uint256 public constant RELEASE_DURATION = 180 days;\n\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    mapping(address =\u003e uint256) public userRewardPerTokenPaid;\n    mapping(address =\u003e uint256) public rewards;\n\n    mapping(address =\u003e uint256) public releaseRewards;\n    mapping(address =\u003e uint256) public releaseTimes;\n    mapping(address =\u003e uint256) public durations;\n    mapping(address =\u003e uint256) public lockTimes;\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event ReleasePaid(address indexed user, uint256 reward);\n    event ChangeBorrower(address borrower);\n    event RecoverWrongToken(address indexed tokenAddress, uint256 amount);\n\n    constructor(\n        address rewardToken,\n        uint256 reward,\n        address lpt,\n        address token,\n        uint pct,\n        uint lockDay,\n        address borrower\n    ) public {\n        require(rewardToken!=lpt,\u0027\u0027);\n        require(rewardToken != address(0), \"Zero address!\");\n        require(lpt != address(0), \"Zero address!\");\n        require(token != address(0), \"Zero address!\");\n        _rewardToken = IERC20(rewardToken);\n        _totalReward = reward;\n        _lpt = IERC20(lpt);\n        _relationToken = INDFILPool(token);\n        _pct = pct;\n        _lockDay = lockDay;\n        _borrower = borrower;\n    }\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = block.timestamp;\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n    \n    modifier onlyBorrower() {\n        require(_borrower == _msgSender(), \"Caller is not the borrower\");\n        _;\n    }\n\n    function changeReward(uint reward) external onlyOwner updateReward(address(0)) {\n        _totalReward = reward;\n        emit RewardAdded(reward);\n    }\n\n    function changeBorrower(address borrower) external onlyOwner{\n        _borrower = borrower;\n        emit ChangeBorrower(borrower);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        uint nowTime = block.timestamp;\n        uint totalReward = _totalReward;\n        uint rewardRate = totalReward.mul(_pct).mul(1e18).div(100).div(DURATION);\n        return\n        rewardPerTokenStored.add(\n            nowTime\n            .sub(lastUpdateTime)\n            .mul(rewardRate)\n            .div(totalSupply())\n        );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n        balanceOf(account)\n        .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n        .div(1e18)\n        .add(rewards[account]);\n    }\n    \n    function received(address account) public view returns (uint256) {\n        (uint256 release,) = released(account);\n        return earned(account).mul(25).div(100).add(release);\n    }\n\n    // stake visibility is public as overriding LPTokenWrapper\u0027s stake() function\n    function stake(address referrer, uint256 amount) public updateReward(msg.sender) {\n        require(amount \u003e 0, \u0027Cannot stake 0\u0027);\n        address account = msg.sender;\n        _relationToken.bindRelationshipExternal(account, referrer);\n        uint balance = balanceOf(account);\n        uint lockTime = lockTimes[account];\n        uint nowTime = block.timestamp;\n        lockTimes[account] = weightedAvg(balance, lockTime, amount, nowTime.add(_lockDay.mul(DURATION)));\n        super._stake(amount);\n        emit Staked(account, amount);\n    }\n\n    function withdraw(uint256 amount) public override updateReward(msg.sender) {\n        require(amount \u003e 0, \u0027Cannot withdraw 0\u0027);\n        address account = msg.sender;\n        require(block.timestamp \u003e lockTimes[account], \u0027Locked\u0027);\n        super.withdraw(amount);\n        emit Withdrawn(account, amount);\n    }\n\n    function exit() external {\n        withdraw(balanceOf(msg.sender));\n        getReward();\n    }\n\n    function getReward() public updateReward(msg.sender) {\n        address account = msg.sender;\n        _getReleaseReward(account);\n        uint256 reward = earned(account);\n        if (reward \u003e 0) {\n            rewards[account] = 0;\n            emit RewardPaid(account, reward);\n            uint256 toReleaseReward = reward.mul(75).div(100);\n            reward = reward.sub(toReleaseReward);\n            _rewardToken.safeTransfer(account, reward.mul(80).div(100));\n            addReleaseReward(account, toReleaseReward);\n        }\n    }\n    \n    function addReleaseReward(address account, uint256 toReleaseReward) private{\n        uint nowTime = block.timestamp;\n        uint toReleaseTime = nowTime.add(RELEASE_DURATION);\n        uint lastToReleaseTime = releaseTimes[account];\n        uint lastToReleaseReward = releaseRewards[account];\n        _totalToRelease = _totalToRelease.add(toReleaseReward);\n        releaseRewards[account] = lastToReleaseReward.add(toReleaseReward);\n        releaseTimes[account] = weightedAvg(lastToReleaseReward, lastToReleaseTime, toReleaseReward, toReleaseTime);\n        durations[account] = releaseTimes[account].sub(nowTime);\n    }\n\n    function weightedAvg(uint amount1, uint releaseTime1, uint amount2, uint releaseTime2) public view returns (uint avg){\n        uint nowTime = block.timestamp;\n        (, uint time1) = releaseTime1.trySub(nowTime);\n        (, uint time2) = releaseTime2.trySub(nowTime);\n        avg = time1.mul(amount1)\n            .add(time2.mul(amount2))\n            .div(amount1.add(amount2))\n            .add(nowTime);\n    }\n\n    function released(address account) public view returns (uint256, uint256) {\n        uint releaseReward = releaseRewards[account];\n        uint duration = durations[account];\n        if(releaseReward==0 || duration==0) return (0, 0);\n        uint nowTime = block.timestamp;\n        (, uint time) = releaseTimes[account].trySub(nowTime);\n        return (releaseRewards[account].mul(duration.sub(time)).div(duration), time);\n    }\n\n    function getReleaseReward() public {\n        _getReleaseReward(msg.sender);\n    }\n    \n    function _getReleaseReward(address account) private {\n        (uint256 reward, uint256 time) = released(account);\n        if(reward\u003e0){\n            _totalToRelease = _totalToRelease.sub(reward);\n            releaseRewards[account] = releaseRewards[account].sub(reward);\n            durations[account] = time;\n            emit ReleasePaid(account, reward);\n            _rewardToken.safeTransfer(account, reward.mul(80).div(100));\n        }\n    }\n    \n    function getBorrowable(address account) external view returns(uint256){\n        (uint256 reward, ) = released(account);\n        return releaseRewards[account].sub(reward);\n    }\n    \n    function getTotalToRelease() external view returns(uint256){\n        return _totalToRelease;\n    }\n    \n    function borrow(address account, uint256 amount) external onlyBorrower returns(uint256) {\n        _getReleaseReward(account);\n        if(amount == 0){\n            amount = releaseRewards[account];\n        }else{\n            amount = releaseRewards[account].min(amount);\n        }\n        _totalToRelease = _totalToRelease.sub(amount);\n        releaseRewards[account] = releaseRewards[account].sub(amount);\n        return amount;\n    }\n    \n    function repay(address account, uint256 amount) external onlyBorrower {\n        require(amount \u003e 0, \u0027Invalid repayment amount!\u0027);\n        addReleaseReward(account, amount);\n    }\n    \n    function recoverWrongToken(address tokenAddress, uint256 amount) external onlyOwner{\n        require(tokenAddress!=address(_lpt), \"Cannot be stakedToken!\");\n        require(tokenAddress!=address(_rewardToken), \"Cannot be rewardToken!\");\n        IERC20(tokenAddress).safeTransfer(address(msg.sender), amount);\n        emit RecoverWrongToken(tokenAddress, amount);\n    }\n}\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"./Context.sol\";\nabstract contract Ownable is Context {\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"},"SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"./IERC20.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Address.sol\";\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nlibrary SafeMath {\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c \u003c a) return (false, 0);\n        return (true, c);\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b \u003e a) return (false, 0);\n        return (true, a - b);\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003e 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003e 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        return a - b;\n    }\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        return a % b;\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003e= b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003c b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}"}}