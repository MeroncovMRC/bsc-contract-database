//SPDX-License-Identifier: Unlicensed

pragma solidity ^0.8.0;

abstract contract ReentrancyGuard {
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    modifier nonReentrant() {
        _nonReentrantBefore();
        _;
        _nonReentrantAfter();
    }

    function _nonReentrantBefore() private {
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");

        _status = _ENTERED;
    }

    function _nonReentrantAfter() private {
        _status = _NOT_ENTERED;
    }

    function _reentrancyGuardEntered() internal view returns (bool) {
        return _status == _ENTERED;
    }
}

interface IERC20 {
    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );

    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function transfer(address to, uint256 amount) external returns (bool);

    function allowance(
        address owner,
        address spender
    ) external view returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
}

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    constructor() {
        _transferOwnership(_msgSender());
    }

    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    function owner() public view virtual returns (address) {
        return _owner;
    }

    function _checkOwner() internal view virtual {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
    }

    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(
            newOwner != address(0),
            "Ownable: new owner is the zero address"
        );
        _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract BUSDCHAT is Ownable {
    uint256 public totalAirdropped;
    uint256 public lastReset;
    uint256 public nextBonusTokenId = 1;

    constructor() {
        lastReset = block.timestamp;
    }

    struct BonusToken {
        address tokenAddress;
        uint256 minimumHolding;
        uint256 multiplier;
    }

    mapping(uint256 => BonusToken) public bonusTokens;
    mapping(address => bool) public blacklist;
    mapping(address => bool) public airdroppableTokens;

    function addAirdroppableToken(address tokenAddress) external onlyOwner {
        airdroppableTokens[tokenAddress] = true;
    }

    function removeAirdroppableToken(address tokenAddress) external onlyOwner {
        airdroppableTokens[tokenAddress] = false;
    }

    function addToBlacklist(address user) external onlyOwner {
        blacklist[user] = true;
    }

    function removeFromBlacklist(address user) external onlyOwner {
        blacklist[user] = false;
    }

    function addBonusToken(
        address tokenAddress,
        uint256 minimumHolding,
        uint256 multiplier
    ) external onlyOwner {
        BonusToken memory newBonusToken = BonusToken(
            tokenAddress,
            minimumHolding,
            multiplier
        );
        bonusTokens[nextBonusTokenId] = newBonusToken;
        nextBonusTokenId++;
    }

    function removeBonusToken(uint256 tokenId) external onlyOwner {
        require(tokenId > 0 && tokenId < nextBonusTokenId, "Invalid token ID");
        delete bonusTokens[tokenId];
    }

    function multiSend(
        address[] memory recipients,
        uint256[] memory amounts,
        address tokenAddress
    ) external onlyOwner {
        require(
            airdroppableTokens[tokenAddress],
            "Token not allowed for airdrop"
        );
        IERC20 atoken = IERC20(tokenAddress);

        require(
            recipients.length == amounts.length,
            "Recipients and amounts arrays must have the same length"
        );

        uint256 totalAmount = 0;
        for (uint256 i = 0; i < recipients.length; i++) {
            require(
                !blacklist[recipients[i]],
                "TokenAirdrop: recipient is blacklisted"
            );
            uint256 multiplier = getHighestMultiplier(recipients[i]);
            uint256 finalAmount = amounts[i] * multiplier;
            totalAmount += finalAmount;
            require(
                atoken.transferFrom(msg.sender, recipients[i], finalAmount),
                "TokenAirdrop: Failed to transfer tokens"
            );
        }
        totalAirdropped += totalAmount; //
    }

    function airdroppedTokens(
        address tokenAddress
    ) external view returns (uint256) {
        require(
            airdroppableTokens[tokenAddress],
            "Token not allowed for airdrop"
        );
        return IERC20(tokenAddress).balanceOf(address(this));
    }

    function getHighestMultiplier(
        address user
    ) internal view returns (uint256) {
        uint256 highestMultiplier = 1;
        for (uint256 i = 1; i < nextBonusTokenId; i++) {
            BonusToken memory bonusToken = bonusTokens[i];
            if (bonusToken.tokenAddress != address(0)) {
                IERC20 btoken = IERC20(bonusToken.tokenAddress);
                uint256 userBalance = btoken.balanceOf(user);
                if (
                    userBalance >= bonusToken.minimumHolding &&
                    bonusToken.multiplier > highestMultiplier
                ) {
                    highestMultiplier = bonusToken.multiplier;
                }
            }
        }
        return highestMultiplier;
    }

    function getBonusTokenIdByAddress(
        address tokenAddress
    ) external view returns (uint256) {
        for (uint256 i = 1; i < nextBonusTokenId; i++) {
            if (bonusTokens[i].tokenAddress == tokenAddress) {
                return i;
            }
        }
        return 0; // Return 0 if the token address is not found
    }

    function emergencyWithdraw(address tokenAddress) external onlyOwner {
        IERC20 atoken = IERC20(tokenAddress);
        uint256 tokenBalance = atoken.balanceOf(address(this));
        require(
            atoken.transfer(owner(), tokenBalance),
            "TokenAirdrop: Failed to transfer tokens."
        );
    }
}