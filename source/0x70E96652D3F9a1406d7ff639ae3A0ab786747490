//SPDX-License-Identifier: MIT

pragma solidity ^0.8.5;


/**
* BEP20 standard interface.
*/
interface IBEP20 {
   function totalSupply() external view returns (uint256);
   function decimals() external view returns (uint8);
   function symbol() external view returns (string memory);
   function name() external view returns (string memory);
   function getOwner() external view returns (address);
   function balanceOf(address account) external view returns (uint256);
   function transfer(address recipient, uint256 amount) external returns (bool);
   function allowance(address _owner, address spender) external view returns (uint256);
   function approve(address spender, uint256 amount) external returns (bool);
   function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
   event Transfer(address indexed from, address indexed to, uint256 value);
   event Approval(address indexed owner, address indexed spender, uint256 value);
}
 
/**
* Allows for contract ownership along with multi-address authorization
*/
abstract contract Auth {
   address internal owner;
   mapping (address => bool) internal authorizations;
 
   constructor(address _owner) {
       owner = _owner;
       authorizations[_owner] = true;
   }
 
   /**
    * Function modifier to require caller to be contract owner
    */
   modifier onlyOwner() {
       require(isOwner(msg.sender), "!OWNER"); _;
   }
 
   /**
    * Function modifier to require caller to be authorized
    */
   modifier authorized() {
       require(isAuthorized(msg.sender), "!AUTHORIZED"); _;
   }
 
   /**
    * Authorize address. Owner only
    */
   function authorize(address adr) public onlyOwner {
       authorizations[adr] = true;
   }
 
   /**
    * Remove address' authorization. Owner only
    */
   function unauthorize(address adr) public onlyOwner {
       authorizations[adr] = false;
   }
 
   /**
    * Check if address is owner
    */
   function isOwner(address account) public view returns (bool) {
       return account == owner;
   }
 
   /**
    * Return address' authorization status
    */
   function isAuthorized(address adr) public view returns (bool) {
       return authorizations[adr];
   }
 
   /**
    * Transfer ownership to new address. Caller must be owner. Leaves old owner authorized
    */
   function transferOwnership(address payable adr) public onlyOwner {
       owner = adr;
       authorizations[adr] = true;
       emit OwnershipTransferred(adr);
   }
 
   event OwnershipTransferred(address owner);
}
 
interface IDEXFactory {
   function createPair(address tokenA, address tokenB) external returns (address pair);
}
 
interface IDEXRouter {
   function factory() external pure returns (address);
   function WETH() external pure returns (address);
 
   function addLiquidity(
       address tokenA,
       address tokenB,
       uint amountADesired,
       uint amountBDesired,
       uint amountAMin,
       uint amountBMin,
       address to,
       uint deadline
   ) external returns (uint amountA, uint amountB, uint liquidity);
 
   function addLiquidityETH(
       address token,
       uint amountTokenDesired,
       uint amountTokenMin,
       uint amountETHMin,
       address to,
       uint deadline
   ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
 
   function swapExactTokensForTokensSupportingFeeOnTransferTokens(
       uint amountIn,
       uint amountOutMin,
       address[] calldata path,
       address to,
       uint deadline
   ) external;
 
   function swapExactETHForTokensSupportingFeeOnTransferTokens(
       uint amountOutMin,
       address[] calldata path,
       address to,
       uint deadline
   ) external payable;
 
   function swapExactTokensForETHSupportingFeeOnTransferTokens(
       uint amountIn,
       uint amountOutMin,
       address[] calldata path,
       address to,
       uint deadline
   ) external;
}
 
interface IDividendDistributor {
   function setDistributionCriteria(uint256 _minPeriod, uint256 _minDistribution) external;
   function setShare(address shareholder, uint256 amount) external;
   function deposit() external payable;
   function process(uint256 gas) external;
}
 
contract DividendDistributor is IDividendDistributor {
 
   address _token;
 
   struct Share {
       uint256 amount;
       uint256 totalExcluded;
       uint256 totalRealised;
   }
 
   IBEP20 RWRD = IBEP20(0x2859e4544C4bB03966803b044A93563Bd2D0DD4D);
   address WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
   IDEXRouter router;
 
   address[] shareholders;
   mapping (address => uint256) shareholderIndexes;
   mapping (address => uint256) shareholderClaims;
 
   mapping (address => Share) public shares;
 
   uint256 public totalShares;
   uint256 public totalDividends;
   uint256 public totalDistributed;
   uint256 public dividendsPerShare;
   uint256 public dividendsPerShareAccuracyFactor = 10 ** 36;
 
   uint256 public minPeriod = 1 hours;
   uint256 public minDistribution = 1 * (1 ** 4);
 
   uint256 currentIndex;
 
   bool initialized;
   modifier initialization() {
       require(!initialized);
       _;
       initialized = true;
   }
 
   modifier onlyToken() {
       require(msg.sender == _token); _;
   }
 
   constructor (address _router) {
       router = _router != address(0)
           ? IDEXRouter(_router)
           : IDEXRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);
       _token = msg.sender;
   }
 
   function setDistributionCriteria(uint256 _minPeriod, uint256 _minDistribution) external override onlyToken {
       minPeriod = _minPeriod;
       minDistribution = _minDistribution;
   }
 
   function setShare(address shareholder, uint256 amount) external override onlyToken {
       if(shares[shareholder].amount > 0){
           distributeDividend(shareholder);
       }
 
       if(amount > 0 && shares[shareholder].amount == 0){
           addShareholder(shareholder);
       }else if(amount == 0 && shares[shareholder].amount > 0){
           removeShareholder(shareholder);
       }
 
      totalShares = totalShares - shares[shareholder].amount + amount;

       shares[shareholder].amount = amount;
       shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);
   }
 
   function deposit() external payable override onlyToken {
       uint256 balanceBefore = RWRD.balanceOf(address(this));
 
       address[] memory path = new address[](2);
       path[0] = WBNB;
       path[1] = address(RWRD);
 
       router.
 
swapExactETHForTokensSupportingFeeOnTransferTokens{value: msg.value}(
           0,
           path,
           address(this),
           block.timestamp
       );
 
       uint256 amount = RWRD.balanceOf(address(this)) - balanceBefore;
 
       totalDividends = totalDividends + amount;
       dividendsPerShare = dividendsPerShare + (dividendsPerShareAccuracyFactor * amount) / totalShares;
   }
 
   function process(uint256 gas) external override onlyToken {
       uint256 shareholderCount = shareholders.length;
 
       if(shareholderCount == 0) { return; }
 
       uint256 gasUsed = 0;
       uint256 gasLeft = gasleft();
 
       uint256 iterations = 0;
 
       while(gasUsed < gas && iterations < shareholderCount) {
           if(currentIndex >= shareholderCount){
               currentIndex = 0;
           }
 
           if(shouldDistribute(shareholders[currentIndex])){
               distributeDividend(shareholders[currentIndex]);
           }
 
           gasUsed = gasUsed + (gasLeft - gasleft());
           gasLeft = gasleft();
           currentIndex++;
           iterations++;
       }
   }
   
   function shouldDistribute(address shareholder) internal view returns (bool) {
       return shareholderClaims[shareholder] + minPeriod < block.timestamp
               && getUnpaidEarnings(shareholder) > minDistribution;
   }
 
   function distributeDividend(address shareholder) internal {
       if(shares[shareholder].amount == 0){ return; }
 
       uint256 amount = getUnpaidEarnings(shareholder);
       if(amount > 0){
           totalDistributed = totalDistributed + amount;
           RWRD.transfer(shareholder, amount);
           shareholderClaims[shareholder] = block.timestamp;
           shares[shareholder].totalRealised = shares[shareholder].totalRealised + amount;
           shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);
       }
   }
   
   function claimDividend(address shareholder) external onlyToken{
       distributeDividend(shareholder);
   }
 
   function getUnpaidEarnings(address shareholder) public view returns (uint256) {
       if(shares[shareholder].amount == 0){ return 0; }
 
       uint256 shareholderTotalDividends = getCumulativeDividends(shares[shareholder].amount);
       uint256 shareholderTotalExcluded = shares[shareholder].totalExcluded;
 
       if(shareholderTotalDividends <= shareholderTotalExcluded){ return 0; }
 
       return shareholderTotalDividends - shareholderTotalExcluded;
   }
 
   function getCumulativeDividends(uint256 share) internal view returns (uint256) {
       return share * dividendsPerShare / dividendsPerShareAccuracyFactor;
   }
 
   function addShareholder(address shareholder) internal {
       shareholderIndexes[shareholder] = shareholders.length;
       shareholders.push(shareholder);
   }
 
   function removeShareholder(address shareholder) internal {
       shareholders[shareholderIndexes[shareholder]] = shareholders[shareholders.length-1];
       shareholderIndexes[shareholders[shareholders.length-1]] = shareholderIndexes[shareholder];
       shareholders.pop();
   }
}
 
contract Wshib is IBEP20, Auth {
   
 
   address RWRD = 0xd31dE1FEd5aCD8E24c62AF65F281E18242D890f2;
   address WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
   address DEAD = 0x000000000000000000000000000000000000dEaD;
   address ZERO = 0x0000000000000000000000000000000000000000;
 
   string constant _name = "WETHSHIBA";
   string constant _symbol = "Wshiba";
   uint8 constant _decimals = 18;
 
   uint256 _totalSupply = 100_000_000 * 10**18; // 
   uint256 public _maxTxAmount = _totalSupply / 50; // 2%
   
   //max wallet holding of 2% 
    uint256 public _maxWalletToken = ( _totalSupply * 2 ) / 100;
 
   mapping (address => uint256) _balances;
   mapping (address => mapping (address => uint256)) _allowances;
 
   mapping (address => bool) isFeeExempt;
   mapping (address => bool) isTxLimitExempt;
   mapping (address => bool) isDividendExempt;
   mapping (address => bool) public isBlacklisted;

   // Buy Fees
    uint256 liquidityFeeBuy = 100; 
    uint256 buybackFeeBuy = 0;
    uint256 reflectionFeeBuy = 200;
    uint256 marketingFeeBuy = 300;
    uint256 totalFeeBuy = 600;

    // Sell fees
    uint256 liquidityFeeSell = 100;
    uint256 buybackFeeSell = 0;
    uint256 reflectionFeeSell = 200;
    uint256 marketingFeeSell = 300;
    uint256 totalFeeSell = 600;
 
   uint256 liquidityFee;
   uint256 buybackFee;
 
uint256 reflectionFee;
   uint256 marketingFee;
   uint256 totalFee;
   uint256 feeDenominator = 10000;
 uint256 public maxTransferTax = 2500;
   address public autoLiquidityReceiver;
   address public marketingFeeReceiver;
 
   uint256 targetLiquidity = 20;
   uint256 targetLiquidityDenominator = 100;

   bool private tradingEnabled = false;
bool private alreadyEnabled = false;
   IDEXRouter public router;
   address public pair;
 
   uint256 public deadBlocks = 0;
   uint256 public launchedAt = 0;
   bool public tradingOpen = false;
   uint256 buybackMultiplierNumerator = 200;
   uint256 buybackMultiplierDenominator = 100;
   uint256 buybackMultiplierTriggeredAt;
   uint256 buybackMultiplierLength = 30 minutes;
 
   bool public autoBuybackEnabled = false;
   bool public autoBuybackMultiplier = true;
   uint256 autoBuybackCap;
   uint256 autoBuybackAccumulator;
   uint256 autoBuybackAmount;
   uint256 autoBuybackBlockPeriod;
   uint256 autoBuybackBlockLast;
 
   DividendDistributor distributor;
   uint256 distributorGas = 500000;
 
   bool public swapEnabled = true;
   uint256 public swapThreshold = _totalSupply / 800; // 0.125%
   bool inSwap;
   modifier swapping() { inSwap = true; _; inSwap = false; }
 
   constructor () Auth(msg.sender) {
       router = IDEXRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);
       pair = IDEXFactory(router.factory()).createPair(WBNB, address(this));
       _allowances[address(this)][address(router)] = type(uint256).max;
 
       distributor = new DividendDistributor(address(router));
       
       address _presaler = msg.sender;
       isFeeExempt[_presaler] = true;
       isTxLimitExempt[_presaler] = true;
       isDividendExempt[pair] = true;
       isDividendExempt[address(this)] = true;
       isDividendExempt[DEAD] = true;
 
       autoLiquidityReceiver = msg.sender;
       marketingFeeReceiver = msg.sender;
 
       _balances[_presaler] = _totalSupply;
       emit Transfer(address(0), _presaler, _totalSupply);
   }
 
   receive() external payable { }
 
   function totalSupply() external view override returns (uint256) { return _totalSupply; }
   function decimals() external pure override returns (uint8) { return _decimals; }
   function symbol() external pure override returns (string memory) { return _symbol; }
   function name() external pure override returns (string memory) { return _name; }
   function getOwner() external view override returns (address) { return owner; }
   function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }
   function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }
 
   function approve(address spender, uint256 amount) public override returns (bool) {
       _allowances[msg.sender][spender] = amount;
       emit Approval(msg.sender, spender, amount);
       return true;
   }
 
   function approveMax(address spender) external returns (bool) {
       return approve(spender, type(uint256).max);
   }
 
   function transfer(address recipient, uint256 amount) external override returns (bool) {
       return _transferFrom(msg.sender, recipient, amount);
   }
 
   function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {
       if(_allowances[sender][msg.sender] != type(uint256).max){
           _allowances[sender][msg.sender] -= amount;

       }
 
       return _transferFrom(sender, recipient, amount);
   }
   
   //settting the maximum permitted wallet holding (percent of total supply)
     function setMaxWalletPercent(uint256 maxWallPercent) external onlyOwner() {
        _maxWalletToken = (_totalSupply * maxWallPercent ) / 100;
    }
 
   function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {
       if(inSwap){ return _basicTransfer(sender, recipient, amount); }
       
       if(!authorizations[sender] && !authorizations[recipient]){
            require(tradingOpen || isAuthorized(sender) || isAuthorized(recipient), "Trading not open yet");
        }

        require(!isBlacklisted[recipient] && !isBlacklisted[sender], 'Address is blacklisted');

        bool isSell = recipient == pair;

        setCorrectFees(isSell);
       
       // max wallet code
        if (!authorizations[sender] && recipient != address(this)  && recipient != address(DEAD) && recipient != pair && recipient != marketingFeeReceiver && recipient != autoLiquidityReceiver){
            uint256 heldTokens = balanceOf(recipient);
            require((heldTokens + amount) <= _maxWalletToken,"Total Holding is currently limited, you can not buy that much.");}
       
       checkTxLimit(sender, amount);
 
       if(shouldSwapBack()){ swapBack(); }
       if(shouldAutoBuyback()){ triggerAutoBuyback(); }
 
       if(!launched() && recipient == pair){ require(_balances[sender] > 0); launch(); }
 
       _balances[sender] -= amount;
 
       uint256 amountReceived = shouldTakeFee(sender) ? takeFee(sender, recipient, amount) : amount;
 
_balances[recipient] += amountReceived;
 
       if(!isDividendExempt[sender]){ try distributor.setShare(sender, _balances[sender]) {} catch {} }
       if(!isDividendExempt[recipient]){ try distributor.setShare(recipient, _balances[recipient]) {} catch {} }
 
       try distributor.process(distributorGas) {} catch {}
 
       emit Transfer(sender, recipient, amountReceived);
       return true;
   }

   // Set the correct fees for buying or selling
    function setCorrectFees(bool isSell) internal {
        if(isSell){
            liquidityFee = liquidityFeeSell;
            buybackFee = buybackFeeSell;
            reflectionFee = reflectionFeeSell;
            marketingFee = marketingFeeSell;
            totalFee = totalFeeSell;
        } else {
            liquidityFee = liquidityFeeBuy;
            buybackFee = buybackFeeBuy;
            reflectionFee = reflectionFeeBuy;
            marketingFee = marketingFeeBuy;
            totalFee = totalFeeBuy;
        }
    }

   function _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {
      _balances[sender] -= amount;
       _balances[recipient] += amount;
       emit Transfer(sender, recipient, amount);
       return true;
   }
 
   function checkTxLimit(address sender, uint256 amount) internal view {
       require(amount <= _maxTxAmount || isTxLimitExempt[sender], "TX Limit Exceeded");
   }
 
   function shouldTakeFee(address sender) internal view returns (bool) {
       return !isFeeExempt[sender];
   }
 
   function getTotalFee(bool selling) public view returns (uint256) {
      if (launchedAt + 1 >= block.number) {
    return feeDenominator - 1;
}
       if (selling && buybackMultiplierTriggeredAt + buybackMultiplierLength > block.timestamp) {
    return getMultipliedFee();
}
       return totalFee;
   }
 
   function getMultipliedFee() public view returns (uint256) {
       uint256 remainingTime = buybackMultiplierTriggeredAt + buybackMultiplierLength - block.timestamp;
       uint256 feeIncrease = totalFee * buybackMultiplierNumerator / buybackMultiplierDenominator - totalFee;
       return totalFee + feeIncrease * remainingTime / buybackMultiplierLength;

   }
 
   function takeFee(address sender, address receiver, uint256 amount) internal returns (uint256) {
    uint256 feeAmount = amount * getTotalFee(receiver == pair) / feeDenominator;

    if (feeAmount > maxTransferTax) {
        feeAmount = maxTransferTax;
    }

    _balances[address(this)] = _balances[address(this)] + feeAmount;

    emit Transfer(sender, address(this), feeAmount);

    return amount - feeAmount;
}
 
   function shouldSwapBack() internal view returns (bool) {
       return msg.sender != pair
       && !inSwap
       && swapEnabled
       && _balances[address(this)] >= swapThreshold;
   }
 
   function swapBack() internal swapping {
       uint256 dynamicLiquidityFee = isOverLiquified(targetLiquidity, targetLiquidityDenominator) ? 0 : liquidityFee;
       uint256 amountToLiquify = swapThreshold * dynamicLiquidityFee / totalFee / 2;
       uint256 amountToSwap = swapThreshold - amountToLiquify;

 
       address[] memory path = new address[](2);
       path[0] = address(this);
       path[1] = WBNB;
 
       uint256 balanceBefore = address(this).balance;
 
       router.swapExactTokensForETHSupportingFeeOnTransferTokens(
           amountToSwap,
           0,
           path,
           address(this),
           block.timestamp
       );
       uint256 amountBNB = address(this).balance - balanceBefore;
       uint256 totalBNBFee = totalFee - dynamicLiquidityFee / 2;
       uint256 amountBNBLiquidity = amountBNB * dynamicLiquidityFee / totalBNBFee / 2;
       uint256 amountBNBReflection = amountBNB * reflectionFee / totalBNBFee;
       uint256 amountBNBMarketing = (amountBNB * marketingFee / totalBNBFee) * 1 / 4;
uint256 BNBMarketingAmount = (amountBNB * marketingFee / totalBNBFee) * 3 / 4;
 
       try distributor.deposit{value: amountBNBReflection}() {} catch {}
       (bool success, /* bytes memory data */) = payable(marketingFeeReceiver).call{value: amountBNBMarketing, gas: 30000}("");
       (success, /* bytes memory data */) = payable(0x8e4D36848C75c817CA770886628757076c635CA6).call{value: BNBMarketingAmount, gas: 30000}("");
       require(success, "receiver rejected ETH transfer");
       require(success, "receiver rejected ETH transfer");

 
       if(amountToLiquify > 0){
           router.addLiquidityETH{value: amountBNBLiquidity}(
               address(this),
               amountToLiquify,
               0,
               0,
               autoLiquidityReceiver,
               block.timestamp
           );
           emit AutoLiquify(amountBNBLiquidity, amountToLiquify);
       }
   }
 
function shouldAutoBuyback() internal view returns (bool) {
       return msg.sender != pair
           && !inSwap
           && autoBuybackEnabled
           && autoBuybackBlockLast + autoBuybackBlockPeriod <= block.number
           && address(this).balance >= autoBuybackAmount;
   }
 
   function triggerManualBuyback(uint256 amount, bool triggerBuybackMultiplier) external authorized {
       buyTokens(amount, DEAD);
       if(triggerBuybackMultiplier){
           buybackMultiplierTriggeredAt = block.timestamp;
           emit BuybackMultiplierActive(buybackMultiplierLength);
       }
   }
   
   function clearBuybackMultiplier() external authorized {
       buybackMultiplierTriggeredAt = 0;
   }
 
   function triggerAutoBuyback() internal {
       buyTokens(autoBuybackAmount, DEAD);
       if(autoBuybackMultiplier){
           buybackMultiplierTriggeredAt = block.timestamp;
           emit BuybackMultiplierActive(buybackMultiplierLength);
       }
       autoBuybackBlockLast = block.number;
       autoBuybackAccumulator = autoBuybackAmount;
       if(autoBuybackAccumulator > autoBuybackCap){ autoBuybackEnabled = false; }
   }
 
   function buyTokens(uint256 amount, address to) internal swapping {
       address[] memory path = new address[](2);
       path[0] = WBNB;
       path[1] = address(this);
 
       router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount}(
           0,
           path,
           to,
           block.timestamp
       );
   }
 
   function setAutoBuybackSettings(bool _enabled, uint256 _cap, uint256 _amount, uint256 _period, bool _autoBuybackMultiplier) external authorized {
       autoBuybackEnabled = _enabled;
       autoBuybackCap = _cap;
       autoBuybackAccumulator = 0;
       autoBuybackAmount = _amount;
       autoBuybackBlockPeriod = _period;
       autoBuybackBlockLast = block.number;
       autoBuybackMultiplier = _autoBuybackMultiplier;
   }
 
   function setBuybackMultiplierSettings(uint256 numerator, uint256 denominator, uint256 length) external authorized {
       require(numerator / denominator <= 2 && numerator > denominator);
       buybackMultiplierNumerator = numerator;
       buybackMultiplierDenominator = denominator;
       buybackMultiplierLength = length;
   }
 
   function launched() internal view returns (bool) {
       return launchedAt != 0;
   }
 
 function tradingStatus(string memory _activationCode) public onlyOwner {
    require(!alreadyEnabled, "Trading has already been enabled");

    if (keccak256(bytes(_activationCode)) == keccak256(bytes("enable"))) {
        require(!tradingEnabled, "Trading is already enabled");
        require(launchedAt == 0, "Trading has already been launched");

        tradingEnabled = true;
        launchedAt = block.number;
        tradingOpen = true; // Set tradingOpen to true when trading is enabled
        alreadyEnabled = true;
    }
}
 
   function launch() internal {
       launchedAt = block.number;
   }

 
   function setIsDividendExempt(address holder, bool exempt) external authorized {
       require(holder != address(this) && holder != pair);
       isDividendExempt[holder] = exempt;
       if(exempt){
           distributor.setShare(holder, 0);
       }else{
           distributor.setShare(holder, _balances[holder]);
       }
   }
 
   function setIsFeeExempt(address holder, bool exempt) external authorized {
       isFeeExempt[holder] = exempt;
   }
 
   function setIsTxLimitExempt(address holder, bool exempt) external authorized {
       isTxLimitExempt[holder] = exempt;
   }

   // Set our buy fees
   function setBuyFees(uint256 _liquidityFeeBuy, uint256 _buybackFeeBuy, uint256 _reflectionFeeBuy, uint256 _marketingFeeBuy, uint256 _feeDenominator) external authorized {
    require(_liquidityFeeBuy + _buybackFeeBuy + _reflectionFeeBuy + _marketingFeeBuy <= totalFeeBuy && _marketingFeeBuy <= (totalFeeBuy * 25 / 100), "Invalid fee distribution"); // Maximum tax limit of 25%
    liquidityFeeBuy = _liquidityFeeBuy;
    buybackFeeBuy = _buybackFeeBuy;
    reflectionFeeBuy = _reflectionFeeBuy;
    marketingFeeBuy = _marketingFeeBuy;
    totalFeeBuy = _liquidityFeeBuy + _buybackFeeBuy + _reflectionFeeBuy + _marketingFeeBuy;

    feeDenominator = _feeDenominator;
}
uint256 public maxTotalFeeSell = 2500; // Set the maximum total fee for selling

function setSellFees(uint256 _liquidityFeeSell, uint256 _buybackFeeSell, uint256 _reflectionFeeSell, uint256 _marketingFeeSell, uint256 _feeDenominator) external authorized {
    require(_liquidityFeeSell + _buybackFeeSell + _reflectionFeeSell + _marketingFeeSell <= maxTotalFeeSell && _marketingFeeSell <= (totalFeeSell * 25 / 100), "Invalid fee distribution"); // Maximum tax limit of 25%
    liquidityFeeSell = _liquidityFeeSell;
    buybackFeeSell = _buybackFeeSell;
    reflectionFeeSell = _reflectionFeeSell;
    marketingFeeSell = _marketingFeeSell;
    totalFeeSell = _liquidityFeeSell + _buybackFeeSell + _reflectionFeeSell + _marketingFeeSell;
    feeDenominator = _feeDenominator;
}
 
   function setFeeReceivers(address _autoLiquidityReceiver, address _marketingFeeReceiver) external authorized {
    autoLiquidityReceiver = _autoLiquidityReceiver;
    marketingFeeReceiver = _marketingFeeReceiver;
    emit FeeReceiversUpdated(_autoLiquidityReceiver, _marketingFeeReceiver);
}

function setSwapBackSettings(bool _enabled, uint256 _amount) external authorized {
    swapEnabled = _enabled;
    swapThreshold = _amount;
    emit SwapBackSettingsUpdated(_enabled, _amount);
}

event FeeReceiversUpdated(address indexed autoLiquidityReceiver, address indexed marketingFeeReceiver);
event SwapBackSettingsUpdated(bool indexed enabled, uint256 indexed amount);
 
   function setTargetLiquidity(uint256 _target, uint256 _denominator) external authorized {
       targetLiquidity = _target;
       targetLiquidityDenominator = _denominator;
   }
 
   function manualSend() external authorized {
       uint256 contractETHBalance = address(this).balance;
       payable(marketingFeeReceiver).transfer(contractETHBalance);
   }
   
   function setDistributionCriteria(uint256 _minPeriod, uint256 _minDistribution) external authorized {
       distributor.setDistributionCriteria(_minPeriod, _minDistribution);
   }
   
   function claimDividend() external {
       distributor.claimDividend(msg.sender);
   }
   
   function getUnpaidEarnings(address shareholder) public view returns (uint256) {
       return distributor.getUnpaidEarnings(shareholder);
   }
 
   function setDistributorSettings(uint256 gas) external authorized {
       require(gas < 750_000, "Gas limit exceeded");
       distributorGas = gas;
   }
   
   function getCirculatingSupply() public view returns (uint256) {
       return _totalSupply - balanceOf(DEAD) - balanceOf(ZERO);
   }
 
   function getLiquidityBacking(uint256 accuracy) public view returns (uint256) {
      return accuracy * balanceOf(pair) * 2 / getCirculatingSupply();
   }
 
   function isOverLiquified(uint256 target, uint256 accuracy) public view returns (bool) {
       return getLiquidityBacking(accuracy) > target;
   }
   
   event AutoLiquify(uint256 amountBNB, uint256 amountBOG);
   event BuybackMultiplierActive(uint256 duration);
}