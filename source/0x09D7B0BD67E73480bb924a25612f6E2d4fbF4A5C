// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;


// CAUTION
// This version of SafeMath should only be used with Solidity 0.8 or later,
// because it relies on the compiler's built in overflow checks.
library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return a - b;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        return a * b;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }
}


// safe transfer
library TransferHelper {
    function safeApprove(address token, address to, uint value) internal {
        // bytes4(keccak256(bytes('approve(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');
    }

    function safeTransfer(address token, address to, uint value) internal {
        // bytes4(keccak256(bytes('transfer(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');
    }

    function safeTransferFrom(address token, address from, address to, uint value) internal {
        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');
    }

    function safeTransferETH(address to, uint value) internal {
        (bool success,) = to.call{value:value}(new bytes(0));
        // (bool success,) = to.call.value(value)(new bytes(0));
        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');
    }
}


library SafeCast {
    function toUint248(uint256 value) internal pure returns (uint248) {
        require(value <= type(uint248).max, "SafeCast: value doesn't fit in 248 bits");
        return uint248(value);
    }

    function toUint240(uint256 value) internal pure returns (uint240) {
        require(value <= type(uint240).max, "SafeCast: value doesn't fit in 240 bits");
        return uint240(value);
    }

    function toUint232(uint256 value) internal pure returns (uint232) {
        require(value <= type(uint232).max, "SafeCast: value doesn't fit in 232 bits");
        return uint232(value);
    }

    function toUint224(uint256 value) internal pure returns (uint224) {
        require(value <= type(uint224).max, "SafeCast: value doesn't fit in 224 bits");
        return uint224(value);
    }

    function toUint216(uint256 value) internal pure returns (uint216) {
        require(value <= type(uint216).max, "SafeCast: value doesn't fit in 216 bits");
        return uint216(value);
    }

    function toUint208(uint256 value) internal pure returns (uint208) {
        require(value <= type(uint208).max, "SafeCast: value doesn't fit in 208 bits");
        return uint208(value);
    }

    function toUint200(uint256 value) internal pure returns (uint200) {
        require(value <= type(uint200).max, "SafeCast: value doesn't fit in 200 bits");
        return uint200(value);
    }

    function toUint192(uint256 value) internal pure returns (uint192) {
        require(value <= type(uint192).max, "SafeCast: value doesn't fit in 192 bits");
        return uint192(value);
    }

    function toUint184(uint256 value) internal pure returns (uint184) {
        require(value <= type(uint184).max, "SafeCast: value doesn't fit in 184 bits");
        return uint184(value);
    }

    function toUint176(uint256 value) internal pure returns (uint176) {
        require(value <= type(uint176).max, "SafeCast: value doesn't fit in 176 bits");
        return uint176(value);
    }

    function toUint168(uint256 value) internal pure returns (uint168) {
        require(value <= type(uint168).max, "SafeCast: value doesn't fit in 168 bits");
        return uint168(value);
    }

    function toUint160(uint256 value) internal pure returns (uint160) {
        require(value <= type(uint160).max, "SafeCast: value doesn't fit in 160 bits");
        return uint160(value);
    }

    function toUint152(uint256 value) internal pure returns (uint152) {
        require(value <= type(uint152).max, "SafeCast: value doesn't fit in 152 bits");
        return uint152(value);
    }

    function toUint144(uint256 value) internal pure returns (uint144) {
        require(value <= type(uint144).max, "SafeCast: value doesn't fit in 144 bits");
        return uint144(value);
    }

    function toUint136(uint256 value) internal pure returns (uint136) {
        require(value <= type(uint136).max, "SafeCast: value doesn't fit in 136 bits");
        return uint136(value);
    }

    function toUint128(uint256 value) internal pure returns (uint128) {
        require(value <= type(uint128).max, "SafeCast: value doesn't fit in 128 bits");
        return uint128(value);
    }

    function toUint120(uint256 value) internal pure returns (uint120) {
        require(value <= type(uint120).max, "SafeCast: value doesn't fit in 120 bits");
        return uint120(value);
    }

    function toUint112(uint256 value) internal pure returns (uint112) {
        require(value <= type(uint112).max, "SafeCast: value doesn't fit in 112 bits");
        return uint112(value);
    }

    function toUint104(uint256 value) internal pure returns (uint104) {
        require(value <= type(uint104).max, "SafeCast: value doesn't fit in 104 bits");
        return uint104(value);
    }

    function toUint96(uint256 value) internal pure returns (uint96) {
        require(value <= type(uint96).max, "SafeCast: value doesn't fit in 96 bits");
        return uint96(value);
    }

    function toUint88(uint256 value) internal pure returns (uint88) {
        require(value <= type(uint88).max, "SafeCast: value doesn't fit in 88 bits");
        return uint88(value);
    }

    function toUint80(uint256 value) internal pure returns (uint80) {
        require(value <= type(uint80).max, "SafeCast: value doesn't fit in 80 bits");
        return uint80(value);
    }

    function toUint72(uint256 value) internal pure returns (uint72) {
        require(value <= type(uint72).max, "SafeCast: value doesn't fit in 72 bits");
        return uint72(value);
    }

    function toUint64(uint256 value) internal pure returns (uint64) {
        require(value <= type(uint64).max, "SafeCast: value doesn't fit in 64 bits");
        return uint64(value);
    }

    function toUint56(uint256 value) internal pure returns (uint56) {
        require(value <= type(uint56).max, "SafeCast: value doesn't fit in 56 bits");
        return uint56(value);
    }

    function toUint48(uint256 value) internal pure returns (uint48) {
        require(value <= type(uint48).max, "SafeCast: value doesn't fit in 48 bits");
        return uint48(value);
    }

    function toUint40(uint256 value) internal pure returns (uint40) {
        require(value <= type(uint40).max, "SafeCast: value doesn't fit in 40 bits");
        return uint40(value);
    }

    function toUint32(uint256 value) internal pure returns (uint32) {
        require(value <= type(uint32).max, "SafeCast: value doesn't fit in 32 bits");
        return uint32(value);
    }

    function toUint24(uint256 value) internal pure returns (uint24) {
        require(value <= type(uint24).max, "SafeCast: value doesn't fit in 24 bits");
        return uint24(value);
    }

    function toUint16(uint256 value) internal pure returns (uint16) {
        require(value <= type(uint16).max, "SafeCast: value doesn't fit in 16 bits");
        return uint16(value);
    }

    function toUint8(uint256 value) internal pure returns (uint8) {
        require(value <= type(uint8).max, "SafeCast: value doesn't fit in 8 bits");
        return uint8(value);
    }
}


// Interface of the ERC20 standard as defined in the EIP.
interface IERC20 {
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint8);
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);
    function allowance(address from, address to) external view returns (uint256);
    function approve(address to, uint256 amount) external returns (bool);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
}


// linkedin inferface
interface ILinkedin {
    function mySuper(address user) external view returns (address);
    function myJuniors(address user) external view returns (address[] memory);
    function getSuperList(address user, uint256 list) external view returns (address[] memory);
}


// owner
abstract contract Ownable {
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, 'owner error');
        _;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }
}


// non reentrant
abstract contract ReentrancyGuard {
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;
    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    modifier nonReentrant() {
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
        _status = _ENTERED;
        _;
        _status = _NOT_ENTERED;
    }
}


// non contract
abstract contract ContractGuard {

    constructor() {}

    modifier nonContract() {
        require(!isContract(msg.sender), "ContractGuard: not user1 error");
        require(tx.origin == msg.sender, "ContractGuard: not user2 error");
        _;
    }

    function isContract(address account) internal view returns (bool) {
        return account.code.length > 0;
    }
}


// eternity.
// share token.
contract Eternity is Ownable, ReentrancyGuard, ContractGuard {
    using SafeMath for uint256;


    // pid is deposit pool.
    struct PoolInfo {
        address token;                    // token address.
        uint256 totalDepositAmount;       // token deposit in pool.
        uint256 totalStaked;              // total staked. The current dividend amount shall be calculated once a day.
        uint256 leastDepositAmount;       // least deposit amount.
        uint256 luckyPoolEarnLimitAmount; // lucky pool earn limit.
        uint256 nextRewardTime;           // next share time. The time of the next dividend, once a day
        uint256 teamEarnCount;            // tean earn count.
        uint256 teamEarnAmount;           // team earn amount.
        uint256 teamEarnLimitAmount;      // team earn limit amount.
        uint256 juniorAmount;             // junior amount condition.
        uint256 userTokenPerShare;        // Accumulated Token per share, times SCALING_FACTOR. Check code.
        bool isOpen;                      // is open.
    }
    PoolInfo[] public poolInfo;   // (index pid 0 start)
    // user deposit.
    mapping(uint256 => mapping(address => UserInfo)) public userInfo;
    struct UserInfo {
        uint256 depositAmount;        // deposit amount.
        uint256 takedAmount;          // already taked amount.
        uint256 takeLimitAmount;      // taked amount limit.
        uint256 rewardDebt;           // reward debt. Accumulated Token per share, times SCALING_FACTOR. Check code.
        uint256 residueAmount;        // residue amount. release residue.
        uint256 releaseStartTime;     // release start time.
        uint256 releaseEndTime;       // release end time.
    }
    // 30 day release dividend.
    uint256 public releaseTime;
    bool public allIsOpen = true;

    // lucky pool
    uint256 private constant LUCKY_SEATS = 50;        // Seats limit, default 50.
    uint256 private immutable ONE_DAY_SECOND_NUMBER;  // mainnet=86400, testnet=60.
    uint256 public luckyIntervalTime;                 // interval time
    struct LuckyPool {
        uint256 earnTotalAmount;                      // earn total amount.
        uint256 expireTime;                           // expire time.
        uint256 isState;                              // 1=underway, 2=poised, 3=complete.
        uint256 luckyNextIndex;                       // next index, (0 start)
    }
    // (luck pool id 1 start)      
    mapping(uint256 => mapping(uint256 => LuckyPool)) public luckyPool;                        // lucky pool.         pid => round => lucky pool infor
    mapping(uint256 => mapping(uint256 => address[LUCKY_SEATS])) public luckyPoolAccounts;     // lucky address.      pid => round => luckyaddress
    mapping(uint256 => uint256) public luckyPoolCount;                                         // lucky pool count.   pid => luck pool count
    uint256 public luckyLastAddrssRatio = 3000;                                                // last address earn ratio. default. %%

    // 0 = super ratio. 1 = super super ratio. 2 = super super super ratio. %%
    uint256[3] public superRatio = [2000, 1000, 500];
    // mining pool ratio. lucky pool ratio. team pool ratio. leader address ratio.  %%
    uint256 public miningPoolRatio = 4000;
    uint256 public luckyPoolRatio = 500;
    uint256 public teamPoolRatio = 1500;
    uint256 public leaderRatio = 500;
    uint256 private constant RATIO_DENOMINATOR = 10000;   // denominator
    uint256 private constant SCALING_FACTOR = 1e18;       // Scaling this up increases support for high supply tokens
    // 2 mul earn limit.
    uint256 public earnMul = 2;

    // super earn condition.
    mapping(uint256 => mapping(address => JuniorMsg)) public juniorMsg;   // pid => account => junior msg.
    struct JuniorMsg {
        address oneJunior;    // 1-3 juniro and amount.
        address twoJunior;
        address threeJunior;
        uint256 oneAmount;
        uint256 twoAmount;
        uint256 threeAmount;
    }

    // linkedin. teamEarn. leader. leaderLucky.
    address public linkedin;
    address public leader;
    address public leaderLucky;
    // stLTC, ltc, coin
    address public stLTC;
    address public ltc;
    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    // owner2
    address public owner2;                      // sign address.
    mapping(uint256 => bool) public nonceUsed;  // nonce only one.
    bool public isOpen = true;                  // is open
    

    constructor(
        uint256 oneDaySecondNumber_,
        address linkedin_,
        address leader_,
        address leaderLucky_,
        address stLTC_,
        address ltc_,
        address owner2_
    ) {
        ONE_DAY_SECOND_NUMBER = oneDaySecondNumber_;     // mainnet=86400, testnet=60.
        releaseTime = 30 * ONE_DAY_SECOND_NUMBER;        // default 30 day.
        luckyIntervalTime = 3 * ONE_DAY_SECOND_NUMBER;   // default 3 day.

        linkedin = linkedin_;
        leader = leader_;
        leaderLucky = leaderLucky_;
        ltc = ltc_;
        stLTC = stLTC_;

        owner2 = owner2_;
    }


    event Mining(uint256 pid, address token, address account, uint256 amount, uint256 surplus);
    event UserTake(uint256 pid, address token, address account, uint256 amount);
    event TeamEarn(uint256 pid, address token, uint256 count, uint256 amount);
    event SuperEarn(uint256 pid, address token, address account, address superAddress, uint256 amount);
    event BackendTransferToken(uint256 pid, address token, address user, uint256 amount, uint256 nonce);
    

    // set releaseTime.
    function setReleaseTime(uint256 dayNumber) external onlyOwner {
        require(dayNumber > 0 && dayNumber <= 100, "Eternity-setReleaseTime: day number error");
        releaseTime = dayNumber * ONE_DAY_SECOND_NUMBER;
    }

    // set allIsOpen.
    function setAllIsOpen(bool newAllIsOpen) external onlyOwner {
        allIsOpen = newAllIsOpen;
    }

    // add pool.
    function addPool(address token, uint256 leastDepositAmount, uint256 luckyPoolEarnLimitAmount, uint256 teamEarnLimitAmount, uint256 juniorAmount) external onlyOwner {
        require(token != address(0), "Eternity-addPool: token is zaro address error");
        require(leastDepositAmount > 0, "Eternity-addPool: least depoist amount is zero error");
        require(luckyPoolEarnLimitAmount > 0, "Eternity-addPool: lucky pool earn limit amount is zero error");
        _startNewLuckPool(poolInfo.length, 0, address(0));

        // add pool
        poolInfo.push(PoolInfo({
            token: token,
            totalDepositAmount: 0,
            totalStaked: 0,
            leastDepositAmount: leastDepositAmount,
            luckyPoolEarnLimitAmount: luckyPoolEarnLimitAmount,
            nextRewardTime: block.timestamp.add(ONE_DAY_SECOND_NUMBER),
            teamEarnCount: 0,
            teamEarnAmount: 0,
            teamEarnLimitAmount: teamEarnLimitAmount,
            juniorAmount: juniorAmount,
            userTokenPerShare: 0,
            isOpen: true
        }));
    }

    // change pool.
    function changePool(
        uint256 pid, 
        address token, 
        uint256 leastDepositAmount, 
        uint256 luckyPoolEarnLimitAmount, 
        uint256 teamEarnLimitAmount, 
        uint256 juniorAmount,
        bool isOpen2
    ) external  onlyOwner {
        PoolInfo storage _PoolInfo = poolInfo[pid];
        if(pid == 0) _PoolInfo.token = token;

        _PoolInfo.leastDepositAmount = leastDepositAmount;
        _PoolInfo.luckyPoolEarnLimitAmount = luckyPoolEarnLimitAmount;
        _PoolInfo.teamEarnLimitAmount = teamEarnLimitAmount;
        _PoolInfo.juniorAmount = juniorAmount;
        _PoolInfo.isOpen = isOpen2;
    }

    // new a luck pool.
    function _startNewLuckPool(uint256 pid, uint256 amount, address firstAccount) private {
        luckyPoolCount[pid]++;
        LuckyPool storage _LuckyPool = luckyPool[pid][luckyPoolCount[pid]];
        _LuckyPool.earnTotalAmount = amount;
        _LuckyPool.expireTime = block.timestamp.add(luckyIntervalTime);
        _LuckyPool.isState = 1;
        if(firstAccount != address(0)) {
            luckyPoolAccounts[pid][luckyPoolCount[pid]][0] = firstAccount;
            _LuckyPool.luckyNextIndex = 1;
        }
    }

    // get all pool
    function getAllPool() external view returns(PoolInfo[] memory) {
        return poolInfo;
    }

    // git pid all lucky pool
    function getAllLuckyPool(uint256 pid) external view returns(LuckyPool[] memory) {
        uint256 _length = luckyPoolCount[pid];
        LuckyPool[] memory _LuckyPool = new LuckyPool[](_length);
        for(uint256 i = 0; i < _length; i++) {
            _LuckyPool[i] = luckyPool[pid][i+1];
        }
        return _LuckyPool;
    }

    // set luckyIntervalTime.
    function setLuckyIntervalTime(uint256 dayNumber) external onlyOwner {
        require(dayNumber > 0 && dayNumber <= 30, "Eternity-setLuckyIntervalTime: day number error");
        luckyIntervalTime = dayNumber * ONE_DAY_SECOND_NUMBER;
    }

    // set luckyLastAddrssRatio.
    function setLuckyLastAddrssRatio(uint256 newLuckyLastAddrssRatio) external onlyOwner {
        require(newLuckyLastAddrssRatio > 0 && newLuckyLastAddrssRatio < 10000, "Eternity-setLuckyLastAddrssRatio: ratio error");
        luckyLastAddrssRatio = newLuckyLastAddrssRatio;
    }

    // set all ratio.
    function setAllRatio(uint256[7] memory allRatio) external onlyOwner {
        uint256 _total;
        for(uint256 i = 0; i < 7; i++) {
            _total += allRatio[i];
        }
        require(_total == 10000, "Eternity-setAllRatio: ratio total error");
        superRatio[0] = allRatio[0];
        superRatio[1] = allRatio[1];
        superRatio[2] = allRatio[2];
        miningPoolRatio = allRatio[3];
        luckyPoolRatio = allRatio[4];
        teamPoolRatio = allRatio[5];
        leaderRatio = allRatio[6];
    }

    // set earnMul.
    function setEarnMul(uint256 newEarnMul) external onlyOwner {
        require(newEarnMul > 0, "Eternity-setEarnMul: earnMul error");
        earnMul = newEarnMul;
    }

    // set linkedin.
    function setLinkedin(address newLinkedin) external onlyOwner {
        require(newLinkedin != address(0), "Eternity-setLinkedin: address error");
        linkedin = newLinkedin;
    }

    // set leader.
    function setLeader(address newLeader) external onlyOwner {
        require(newLeader != address(0), "Eternity-setLeader: address error");
        leader = newLeader;
    }

    // set linkedin.
    function setLeaderLucky(address newLeaderLucky) external onlyOwner {
        require(newLeaderLucky != address(0), "Eternity-newLeaderLucky: address error");
        leaderLucky = newLeaderLucky;
    }

    // set stLTC.
    function setStLTC(address newStLTC) external onlyOwner {
        require(newStLTC != address(0), "Eternity-setStLTC: address error");
        stLTC = newStLTC;
    }

    // set ltc.
    function setLtc(address newLtc) external onlyOwner {
        require(newLtc != address(0), "Eternity-setLtc: address error");
        ltc = newLtc;
    }
    
    // git pid lucky pool account.
    function getLuckyPoolAccount(uint256 pid, uint256 luckyPoolID) external view returns(address[LUCKY_SEATS] memory) {
        return luckyPoolAccounts[pid][luckyPoolID];
    }

    // user deposit.
    function deposit(uint256 pid, uint256 amount) external payable nonReentrant nonContract {
        address msg_sender = msg.sender;
        PoolInfo storage _PoolInfo = poolInfo[pid];
        require(allIsOpen, "Eternity-deposit: not all open");
        require(_PoolInfo.isOpen, "Eternity-deposit: not open");
        require(amount >= _PoolInfo.leastDepositAmount, "Eternity-deposit: amount least error");

        if(_PoolInfo.token == ETH) {
            // is bnb.
            require(msg.value == amount, "Eternity-deposit: amount and value is error");
        }else {
            // is token.
            TransferHelper.safeTransferFrom(_PoolInfo.token, msg_sender, address(this), amount);
        }

        // amount .
        uint256 minging_amount = amount.mul(miningPoolRatio).div(RATIO_DENOMINATOR);
        uint256 lucky_amount = amount.mul(luckyPoolRatio).div(RATIO_DENOMINATOR);
        uint256 team_amount = amount.mul(teamPoolRatio).div(RATIO_DENOMINATOR);
        uint256 leader_amount = amount.mul(leaderRatio).div(RATIO_DENOMINATOR);

        // user.
        _userEarn(pid, msg_sender, amount, minging_amount);
        // mining.
        _updatePool(pid, minging_amount); // 0.5
        // lucky.
        _luckyPool(pid, lucky_amount, msg_sender);
        // team.
        _teamEarn(pid, team_amount);

        // super.
        if(_PoolInfo.token != stLTC) _superEarn(pid, msg_sender, amount);

        // leader.
        if(leader_amount > 0) _transferTokenOrETH(_PoolInfo.token, leader, leader_amount);
    }

    // mass update pools
    function massUpdatePools() external nonReentrant nonContract {
        uint256 _length = poolInfo.length;
        for (uint256 i = 0; i < _length; i++) {
            _updatePool(i, 0);
        }
    }

    // update pool
    function updatePool(uint256 pid) external nonReentrant nonContract {
        _updatePool(pid, 0);
    }

    function _updatePool(uint256 pid, uint256 amount) private {
        PoolInfo storage _PoolInfo = poolInfo[pid];
        if (block.timestamp <= _PoolInfo.nextRewardTime) {
            // not reward time || not reward
            _PoolInfo.totalStaked += amount;
            _PoolInfo.totalDepositAmount += amount;
            return;
        }
        if(_PoolInfo.totalStaked != 0) {
            uint256 add_per = _PoolInfo.totalStaked.mul(SCALING_FACTOR).div(_PoolInfo.totalDepositAmount);
            _PoolInfo.userTokenPerShare += add_per;
        }
        _PoolInfo.totalStaked = amount;
        _PoolInfo.totalDepositAmount += amount;
        _PoolInfo.nextRewardTime = block.timestamp.add(ONE_DAY_SECOND_NUMBER);
    }

    // pending token
    function pendingToken(uint256 pid, address account) public view returns (uint256, uint256) {
        PoolInfo memory _PoolInfo = poolInfo[pid];
        UserInfo memory _UserInfo = userInfo[pid][account];
        if(_UserInfo.depositAmount == 0) return (0, 0);
        uint256 amount = _UserInfo.depositAmount.mul(_PoolInfo.userTokenPerShare).div(SCALING_FACTOR).sub(_UserInfo.rewardDebt);
        amount = amount + _UserInfo.residueAmount;
        if(amount == 0 ) return (0, 0);

        // 30 day release dividend.
        if(block.timestamp >= _UserInfo.releaseEndTime) {
            return (amount, amount);
        }
        uint256 _totalReleaseTime = _UserInfo.releaseEndTime - _UserInfo.releaseStartTime;
        uint256 _perTimeAmount = amount.mul(1e10).div(_totalReleaseTime);
        uint256 take_amount = block.timestamp.sub(_UserInfo.releaseStartTime).mul(_perTimeAmount).div(1e10);
        return (amount, take_amount);
    }

    function _userTake(uint256 pid, address account) private {
        UserInfo storage _UserInfo = userInfo[pid][account];
        (uint256 _amount, uint256 take_amount) = pendingToken(pid, account);
        take_amount = _UserInfo.takedAmount + take_amount > _UserInfo.takeLimitAmount ? _UserInfo.takeLimitAmount - _UserInfo.takedAmount : take_amount;
        
        if(take_amount > 0) _transferTokenOrETH(poolInfo[pid].token, account, take_amount);
        _UserInfo.takedAmount += take_amount;
        _UserInfo.residueAmount = _amount.sub(take_amount);
        emit UserTake(pid, poolInfo[pid].token, account, take_amount);
    }

    // user earn.
    function _userEarn(uint256 pid, address account, uint256 amount, uint256 depositAmount) private {
        UserInfo storage _UserInfo = userInfo[pid][account];
        _UserInfo.takeLimitAmount += amount.mul(earnMul);
        _userTake(pid, account);

        uint256 _partAmount = depositAmount / 2;
        _UserInfo.depositAmount += _partAmount;
        _UserInfo.residueAmount += _partAmount;
        _UserInfo.rewardDebt = _UserInfo.depositAmount.mul(poolInfo[pid].userTokenPerShare).div(SCALING_FACTOR);
        _UserInfo.releaseStartTime = block.timestamp;
        _UserInfo.releaseEndTime = block.timestamp + releaseTime;

        emit Mining(pid, poolInfo[pid].token, account, depositAmount, _UserInfo.depositAmount);
    }

    // lucky pool.
    function _luckyPool(uint256 pid, uint256 amount, address account) private {
        LuckyPool storage _LuckyPool = luckyPool[pid][luckyPoolCount[pid]];

        // is expire.
        if(block.timestamp > _LuckyPool.expireTime) {
            // now lucky pool is poised. start new lucky pool.
            _LuckyPool.isState = 2;
            _startNewLuckPool(pid, amount, account);
        }else {
            // add pool amount. lengthen time. add lucky account address.
            _LuckyPool.earnTotalAmount = _LuckyPool.earnTotalAmount.add(amount);
            _LuckyPool.expireTime = block.timestamp.add(luckyIntervalTime);
            uint256 _nowLuckyIndex = _LuckyPool.luckyNextIndex >= LUCKY_SEATS ? 0 : _LuckyPool.luckyNextIndex;
            luckyPoolAccounts[pid][luckyPoolCount[pid]][_nowLuckyIndex] = account;
            _LuckyPool.luckyNextIndex = _nowLuckyIndex + 1;
            if(_LuckyPool.earnTotalAmount >= poolInfo[pid].luckyPoolEarnLimitAmount) {
                // take 50%.
                uint256 _newEarnTotalAmount = _LuckyPool.earnTotalAmount.div(2);
                _transferTokenOrETH(poolInfo[pid].token, leaderLucky, _newEarnTotalAmount);
                _LuckyPool.earnTotalAmount = _newEarnTotalAmount;
            }
        }
    }

    // team earn.
    function _teamEarn(uint256 pid, uint256 amount) private {
        PoolInfo storage _PoolInfo = poolInfo[pid];
        _PoolInfo.teamEarnAmount += amount;
        if(_PoolInfo.teamEarnAmount >= _PoolInfo.teamEarnLimitAmount) {
            _PoolInfo.teamEarnCount++;
            emit TeamEarn(pid, _PoolInfo.token, _PoolInfo.teamEarnCount, _PoolInfo.teamEarnAmount);
            _PoolInfo.teamEarnAmount = 0;
        }
    }

    // super earn.
    function _superEarn(uint256 pid, address account, uint256 amount) private {
        address[] memory super_three  = ILinkedin(linkedin).getSuperList(account, 3);
        require(super_three.length == 3, "Eternity-_superEarn: super list error");
        address _token = poolInfo[pid].token;

        // update condition.
        _juniorRecord(pid, account, super_three[0]);

        uint256 super_amount;
        for(uint256 i = 0; i < 3; i++) {
            super_amount =  amount.mul(superRatio[i]).div(RATIO_DENOMINATOR);
            if(super_three[i] != address(0)) {
                if(_superTakeVerify(pid, super_three[i], i)) {
                    UserInfo storage _UserInfo = userInfo[pid][super_three[i]];
                    super_amount = _UserInfo.takedAmount + super_amount > _UserInfo.takeLimitAmount ? _UserInfo.takeLimitAmount - _UserInfo.takedAmount : super_amount;
                    _UserInfo.takedAmount = _UserInfo.takedAmount + super_amount;
                    _transferTokenOrETH(_token, super_three[i], super_amount);
                    emit SuperEarn(pid, _token, account, super_three[i], super_amount);
                }
            }
        }
    }

    // is min.
    function _isMin(uint256 a, uint256 b, uint256 c) private pure returns(uint256) {
        if (a <= b && a <= c) {
            return a;
        } else if (b <= a && b <= c) {
            return b;
        } else {
            return c;
        }
    }

    // junior record.
    function _juniorRecord(uint256 pid, address account, address superAddress) private {
        UserInfo memory _UserInfo = userInfo[pid][account];
        JuniorMsg storage _JuniorMsg = juniorMsg[pid][superAddress];

        uint256 min_number = _isMin(_JuniorMsg.oneAmount, _JuniorMsg.twoAmount, _JuniorMsg.threeAmount);
        if(_UserInfo.depositAmount <= min_number) return;
        if(account == _JuniorMsg.oneJunior) {
            _JuniorMsg.oneAmount = _UserInfo.depositAmount;
        }else if(account == _JuniorMsg.twoJunior) {
            _JuniorMsg.twoAmount = _UserInfo.depositAmount;
        }else if(account == _JuniorMsg.threeJunior) {
            _JuniorMsg.threeAmount = _UserInfo.depositAmount;
        }else {
            if(_JuniorMsg.oneAmount == min_number) {
                _JuniorMsg.oneJunior = account;
                _JuniorMsg.oneAmount = _UserInfo.depositAmount;
            }else if(_JuniorMsg.twoAmount == min_number) {
                _JuniorMsg.twoJunior = account;
                _JuniorMsg.twoAmount = _UserInfo.depositAmount;
            }else {
                _JuniorMsg.threeJunior = account;
                _JuniorMsg.threeAmount = _UserInfo.depositAmount;
            }
        }
    }

    // super take verify.
    // rank is 0-2, corresponding 1-3.
    function _superTakeVerify(uint256 pid, address superAddress, uint256 rankIndex) private view returns(bool) {
        PoolInfo memory _PoolInfo = poolInfo[pid];
        JuniorMsg memory _JuniorMsg = juniorMsg[pid][superAddress];
        uint256 _amount = _PoolInfo.juniorAmount;
        uint256 _count = 0;
        if(_JuniorMsg.oneAmount >= _amount) {
            _count++;
        }
        if(_JuniorMsg.twoAmount >= _amount) {
            _count++;
        }
        if(_JuniorMsg.threeAmount >= _amount) {
            _count++;
        }

        if(rankIndex == 0) {
            return _count >= 1;
        }else if(rankIndex == 1) {
            return _count >= 2;
        }else {
            return _count >= 3;
        }
    }

    // user withdraw.
    function withdraw(uint256 pid) external nonReentrant nonContract {
        address msg_sender = msg.sender;
        _userTake(pid, msg_sender);
        UserInfo storage _UserInfo = userInfo[pid][msg_sender];
        
        _UserInfo.rewardDebt = _UserInfo.depositAmount.mul(poolInfo[pid].userTokenPerShare).div(SCALING_FACTOR);
        _UserInfo.releaseStartTime = block.timestamp;
    }

    // anybody can give lucky pool earn
    function anybodyLuckyPoolEarn(uint256 pid, uint256 luckyPoolID) external nonReentrant nonContract {
        LuckyPool storage _LuckyPool = luckyPool[pid][luckyPoolID];
        require(_LuckyPool.isState == 2, "Eternity-anybodyLuckyPoolEarn: state error");
        require(_LuckyPool.earnTotalAmount > 0, "Eternity-anybodyLuckyPoolEarn: amount1 error");
        _LuckyPool.isState = 3;

        address _token = poolInfo[pid].token;
        // luckyLastAddrssRatio
        uint256 _soLuckyIndex = _LuckyPool.luckyNextIndex == 0 ? LUCKY_SEATS - 1 : _LuckyPool.luckyNextIndex - 1;
        uint256 _soLuckyAmount = _LuckyPool.earnTotalAmount.mul(luckyLastAddrssRatio).div(RATIO_DENOMINATOR);
        uint256 _luckAmount = _LuckyPool.earnTotalAmount.sub(_soLuckyAmount).div((LUCKY_SEATS - 1));
        require(_soLuckyAmount > 0, "Eternity-anybodyLuckyPoolEarn: amount2 error");
        require(_luckAmount > 0, "Eternity-anybodyLuckyPoolEarn: amount3 error");

        address[LUCKY_SEATS] memory _luckyAccounts = luckyPoolAccounts[pid][luckyPoolID];
        for(uint256 i = 0; i < _luckyAccounts.length; i++) {
            if(i == _soLuckyIndex) {
                if(_luckyAccounts[i] != address(0)) _transferTokenOrETH(_token, _luckyAccounts[i], _soLuckyAmount);
            }else {
                if(_luckyAccounts[i] != address(0)) _transferTokenOrETH(_token, _luckyAccounts[i], _luckAmount);
            }
        }
    }
    

    // set owner2.
    function setOwner2(address newOwner2) public onlyOwner {
        require(newOwner2 != address(0), "0 address error");
        owner2 = newOwner2;
    }

    // set is open.
    function setIsOpen(bool newIsOpen) public onlyOwner {
        isOpen = newIsOpen;
    }

    // set nonce is true
    function setNonceUsed(uint256 nonce) public onlyOwner {
        nonceUsed[nonce] = true;
    }

    // set nonce is true
    function setNonceUseds(uint256[] memory nonces) public onlyOwner {
        for(uint256 i = 0; i < nonces.length; i++) {
            nonceUsed[nonces[i]] = true;
        }
    }

    // sign take token.
    // data: (this contract address, pid, token address, user address, token amount, random nonce).
    function backendTransferToken(uint256 _pid,address _token,address _to,uint256 _amount,uint256 _nonce,bytes memory _signature) external nonReentrant nonContract {
        require(isOpen, "not is open");
        // only myself
        require(msg.sender == _to, "not you");

        bytes32 hashData = keccak256(abi.encodePacked(address(this),_pid,_token,_to,_amount,_nonce));
        bytes32 messageHash = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hashData));
        address signer = recoverSigner(messageHash, _signature);
        require(signer == owner2, "Signer is not owner2");
        require(signer != address(0), "Signer is 0 address");
        require(!nonceUsed[_nonce], "nonce used");
        nonceUsed[_nonce] = true;

        // transfer
        _transferTokenOrETH(_token, _to, _amount);
        // emit
        emit BackendTransferToken(_pid, _token, _to, _amount, _nonce);

        // amount limit
        UserInfo storage _UserInfo = userInfo[_pid][_to];
        require(_UserInfo.takeLimitAmount >= _UserInfo.takedAmount.add(_amount), "Eternity-backendTransferToken: earm limit error");
        _UserInfo.takedAmount = _UserInfo.takedAmount.add(_amount);
    }

    function recoverSigner(bytes32 message, bytes memory sig) internal pure returns (address) {
        (uint8 v, bytes32 r, bytes32 s) = splitSignature(sig);
        return ecrecover(message, v, r, s);
    }

    function splitSignature(bytes memory sig) internal pure returns (uint8 v, bytes32 r, bytes32 s) {
        require(sig.length == 65);
        assembly {
            r := mload(add(sig, 32))
            s := mload(add(sig, 64))
            v := byte(0, mload(add(sig, 96)))
        }
        return (v, r, s);
    }

    // take token.
    function takeToken(address _token, address _to , uint256 _value) external onlyOwner {
        require(_to != address(0), "zero address error");
        require(_value > 0, "value zero error");
        TransferHelper.safeTransfer(_token, _to, _value);
    }

    // receive eth
    receive() external payable {}

    // take eth.
    function takeETH(address _to, uint256 _value) public onlyOwner {
        require(_to != address(0), "zero address error");
        require(_value > 0, "value zero error");
        TransferHelper.safeTransferETH(_to, _value);
    }

    // transfer 
    function _transferTokenOrETH(address _token, address _to, uint256 _value) private {
        if(_token == stLTC) {
            // if stLTC transfer ltc
            TransferHelper.safeTransfer(ltc, _to, _value);
        }else if(_token == ETH) {
            // if 0xeeee.. transfer bnb
            TransferHelper.safeTransferETH(_to, _value);
        }else {
            TransferHelper.safeTransfer(_token, _to, _value);
        }
    }


}