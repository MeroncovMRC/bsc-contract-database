// File: contracts/IController.sol

pragma solidity =0.8.7;

interface IController {
    function getAssetData(uint256 _globalId)
        external
        view
        returns (
            uint256 nftPoolId,
            uint256 currPoolId,
            uint256 amount,
            uint256 level,
            uint256 rarity,
            uint256 boostersMults
        );

    function transferBeacon(
        uint256 _poolId,
        address _poolAddr,
        address _from,
        address _to,
        uint256 _globalId
    ) external;

    function getBaseURL () external view returns (string memory _baseURL);

    function getBaseImgURL () external view returns (string memory _baseImgURL);
}

// File: contracts/IStaking.sol

pragma solidity =0.8.7;

interface IStaking {
    function deposit(
        uint256 _currPoolId,
        uint256 _globalId,
        uint256 _amount
    ) external;

    function claim(
        uint256 _globalId,
        address _owner,
        uint256 _currPoolId
    ) external returns (uint256 _reward);

    function withdraw(
        uint256 _globalId,
        address _owner,
        uint256 _currPoolId,
        uint256 _amount
    ) external returns (uint256 _reward);

    function getInfo(
        uint256 _globalId,
        uint256 _currPoolId,
        uint256 _amount
    )
        external
        view
        returns (
            uint256 _reward,
            uint256 _boosterReward,
            uint256 _apr,
            uint256 _timeToClaimFreeze,
            uint256 _commonWeight,
            uint256 _assetWeight
        );

    function addCurrency(
        uint256 _currPoolId,
        string memory _name,
        uint256 _allocPoint
    ) external;

    function getPoolInfo(uint256 _currPoolId)
        external
        view
        returns (
            string memory name,
            uint256 allocPoint,
            uint256 commonAllocWeight,
            uint256 commonSum
        );

    function getCurrPoolStats(uint256 _currPoolId)
        external
        view
        returns (uint256 count, uint256 amount);

    function activateBooster(
        uint256 _globalId,
        address _owner,
        uint256 _currPoolId
    ) external;

    function setBoostersActiveInterval(uint256 _intervalInSeconds) external;

    function getBoostersActiveInterval()
        external
        view
        returns (uint256 interval);

    function changeAllocPoint(uint256 _poolId, uint256 _newAllocPoint) external;

    function weightCorrector(uint256 _globalId) external;

    function boosterInfo(uint256 _assetId)
        external
        view
        returns (bool isActive, uint256 activeMult, uint256 boostersTimer);

    function emergencyBoosterClearer(uint256 _globalId) external;

    function getYieldInterval () external view returns (uint256 yieldInterval);

    function setYieldInterval (uint256 newYieldInterval) external;
}

// File: contracts/IRandom.sol

pragma solidity >=0.6.6;

interface IRandom {
  event Request(bytes32 requestId, address user, uint256 poolId, uint256 globalAssetId);
  event Response(bytes32 requestId);
  function getRandomNumber(address user, uint256 poolId, uint256 globalAssetId) external returns (bytes32 requestId);
  function addAllowedAddr(address _contract) external returns (bool);
  function removeAllowedAddr(address _contract) external returns (bool);
  function expandByRequest(bytes32 requestId, uint8 randomAmount) external view returns(uint256[] memory);
}
// File: contracts/IOracle.sol

pragma solidity =0.8.7;

interface IOracle {
  function getPrice(uint256 _currPoolId) external view returns (uint256 price);
}
// File: contracts/IERC165.sol



pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC165 standard, as defined in the
 * https://eips.ethereum.org/EIPS/eip-165[EIP].
 *
 * Implementers can declare support of contract interfaces, which can then be
 * queried by others ({ERC165Checker}).
 *
 * For an implementation, see {ERC165}.
 */
interface IERC165 {
    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

// File: contracts/IERC721.sol



pragma solidity ^0.8.0;


/**
 * @dev Required interface of an ERC721 compliant contract.
 */
interface IERC721 is IERC165 {
    /**
     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
     */
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
     */
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
     */
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    /**
     * @dev Returns the number of tokens in ``owner``'s account.
     */
    function balanceOf(address owner) external view returns (uint256 balance);

    /**
     * @dev Returns the owner of the `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function ownerOf(uint256 tokenId) external view returns (address owner);

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
     * are aware of the ERC721 protocol to prevent tokens from being forever locked.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    /**
     * @dev Transfers `tokenId` token from `from` to `to`.
     *
     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    /**
     * @dev Gives permission to `to` to transfer `tokenId` token to another account.
     * The approval is cleared when the token is transferred.
     *
     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
     *
     * Requirements:
     *
     * - The caller must own the token or be an approved operator.
     * - `tokenId` must exist.
     *
     * Emits an {Approval} event.
     */
    function approve(address to, uint256 tokenId) external;

    /**
     * @dev Returns the account approved for `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function getApproved(uint256 tokenId) external view returns (address operator);

    /**
     * @dev Approve or remove `operator` as an operator for the caller.
     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
     *
     * Requirements:
     *
     * - The `operator` cannot be the caller.
     *
     * Emits an {ApprovalForAll} event.
     */
    function setApprovalForAll(address operator, bool _approved) external;

    /**
     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
     *
     * See {setApprovalForAll}
     */
    function isApprovedForAll(address owner, address operator) external view returns (bool);

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes calldata data
    ) external;
}

// File: contracts/INFT.sol

pragma solidity =0.8.7;

interface INFT is IERC721 {
  function mint(address _to, uint256 _globalId) external;
  function burn(uint256 _globalId) external;
  function isExist (uint256 _globalId) external view returns (bool);
  function getPoolInfo () external view returns (string memory name, string memory symbol);
  function tokenURL(uint256 _globalId) external view returns (string memory);
}
// File: contracts/ReentrancyGuard.sol



pragma solidity ^0.8.0;

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and make it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}

// File: contracts/IERC20.sol



pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

// File: contracts/Context.sol



pragma solidity ^0.8.0;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

// File: contracts/Ownable.sol



pragma solidity ^0.8.0;


/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _setOwner(_msgSender());
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

// File: contracts/Controller.sol

pragma solidity =0.8.7;









contract Controller is IController, Ownable, ReentrancyGuard {
    constructor() {
        availableToReroll = 604800;
        Managers[msg.sender] = true;
        generationFee = 150000 * 10**9;
        boostersFee = 150000 * 10**9;
        levelsFee = 150000 * 10**9;
    }

    //***Variables***//
    uint256 public NFTPoolCounter;
    uint256 public assetCounter;
    uint256 public currencyPoolCounter;

    uint256 public availableToReroll;
    uint256 public generationFee;
    uint256 public boostersFee;
    uint256 public levelsFee;
    address public feeReceiver;
    address public rerollFeeReceiver;
    address public unstakeFeeReceiver;
    string public baseURL;
    string public baseImgURL;

    address public generator;
    IRandom internal Random;
    address public staking;
    IStaking internal Staking;
    address public oracle;
    IOracle internal Oracle;

    //***Mappings***//
    mapping(uint256 => INFT) NFTPoolsToIds;
    mapping(uint256 => Asset) public AssetsToIds;
    mapping(address => bool) internal Managers;
    mapping(uint256 => Currency) public CurrencyPools;

    //***Structs***//
    struct Asset {
        uint256 nftPoolId;
        uint256 currPoolId;
        uint256 amount;
        uint256 level;
        uint256 rarity;
        uint256 createdAt;
        uint256 boostersMults;
        uint256 unsyncLevel;
        uint256 unsyncBoostersMults;
        uint256 boostersUpdateAmount;
        uint256 levelsUpdateAmount;
        bool isStaked;
        bool isExist;
    }

    struct UpdateAssetStruct {
        uint256 globalId;
        uint256 value;
    }

    struct UpdateAssetBoosters {
        uint256 globalId;
        uint256 boostersMults;
    }

    struct Currency {
        IERC20 token;
        uint256 minimalAmount;
        uint256 maximalAmount;
        uint256 rerollPercent;
        uint256 unstakePercent;
    }

    //***Modificators***//
    modifier onlyManager() {
        require(
            Managers[msg.sender],
            "Only managers allow to execute this operation"
        );
        _;
    }

    modifier onlyAssetOwner(uint256 _globalId) {
        require(AssetsToIds[_globalId].isExist, "Asset is not exist??");
        uint256 poolId = AssetsToIds[_globalId].nftPoolId;
        INFT currPool = NFTPoolsToIds[poolId];
        // Maybe add to require "|| Managers[msg.sender]" ???
        require(
            currPool.ownerOf(_globalId) == msg.sender,
            "Available for asset owner only"
        );
        _;
    }

    //***Events***//
    event AssetGenerated(
        address ownerAddres,
        bytes32 randomRequestId,
        uint256 assetPoolId,
        uint256 currencyPoolId,
        uint256 assetGlobalId,
        uint256 assetsCountInCurrencyPool,
        uint256 currencyPoolSummaryStakeAmount,
        uint256 assetStakedAmount,
        string data
    );
    event AssetReroll(
        address ownerAddress,
        bytes32 randomRequestId,
        uint256 assetGlobalId,
        uint256 assetsCountInCurrencyPool,
        uint256 currencyPoolSummaryStakeAmount
    );
    event AssetTransfer(
        uint256 assetPoolId,
        address assetPoolAddress,
        address addressFrom,
        address addressTo,
        uint256 assetGlobalId
    );
    event AssetUnstake(uint256 assetGlobalId, uint256 rewardAmount);
    event AssetUpdateLevel(uint256 assetGlobalId, uint256 level);
    event AssetUpdateBoosters(
        uint256 assetGlobalId,
        uint256 boostersSummaryMultiplier
    );
    event BoostersActivated(
        uint256 assetGlobalId,
        uint256 boostersSummaryMultiplier,
        uint256 startTimestamp,
        uint256 intervalInSeconds
    );
    event Claim(uint256 assetGlobalId, uint256 rewardAmount);
    event AddAssetPool(uint256 assetPoolId, address assetPoolContractAddress);
    event AddCurrencyPool(
        uint256 currencyPoolId,
        string currenctName,
        address currencyPoolTokenAddress,
        uint256 currencyPoolAllocPoint,
        uint256 minimalStakeAmount,
        uint256 rerollFeePercent
    );
    event UpdateCurrencyPoolBaseAPY(uint256 currencyPoolId, uint256 newAPY);
    event UpdateCurrencyPoolMultipliers(
        uint256 currencyPoolId,
        uint256 levelMultiplier,
        uint256 rarityMultiplier
    );

    //***NFT Pool Functions***//
    function addNFTPool(address _pool) external onlyManager {
        NFTPoolCounter += 1;
        INFT currPool = INFT(_pool);
        NFTPoolsToIds[NFTPoolCounter] = currPool;
        emit AddAssetPool(NFTPoolCounter, _pool);
    }

    function getNFTPool(uint256 _poolId)
        external
        view
        returns (
            address poolAddress,
            string memory name,
            string memory symbol
        )
    {
        INFT currPool = NFTPoolsToIds[_poolId];
        (string memory _name, string memory _symbol) = currPool.getPoolInfo();
        return (address(currPool), _name, _symbol);
    }

    function getNFTPoolsAmount() external view returns (uint256) {
        return (NFTPoolCounter);
    }

    //***Asset Functions***//
    function generateAsset(
        uint256 _poolId,
        uint256 _currPoolId,
        uint256 _amount,
        string calldata data
    ) external payable {
        require(
            _amount >= CurrencyPools[_currPoolId].minimalAmount,
            "Too low amount for generation"
        );
        require(
            _amount <= CurrencyPools[_currPoolId].maximalAmount,
            "Too big amount for generation"
        );
        require(msg.value >= generationFee, "Insufficient commission");
        payable(feeReceiver).transfer(generationFee);
        require(
            CurrencyPools[_currPoolId].token.transferFrom(
                msg.sender,
                address(this),
                _amount
            ),
            "Transfer error"
        );
        assetCounter += 1;

        INFT currPool = NFTPoolsToIds[_poolId];
        currPool.mint(msg.sender, assetCounter);
        AssetsToIds[assetCounter].nftPoolId = _poolId;
        AssetsToIds[assetCounter].level = 1;
        AssetsToIds[assetCounter].unsyncLevel = 1;
        AssetsToIds[assetCounter].amount = _amount;
        AssetsToIds[assetCounter].currPoolId = _currPoolId;
        AssetsToIds[assetCounter].createdAt = block.timestamp;
        AssetsToIds[assetCounter].isExist = true;

        (uint256 count, uint256 amount) = Staking.getCurrPoolStats(_currPoolId);

        bytes32 requestId = Random.getRandomNumber(msg.sender, _poolId, assetCounter);
        emit AssetGenerated (msg.sender, requestId, _poolId, _currPoolId, assetCounter, count, amount, _amount, data);
    }

    function rerollAsset(uint256 _globalId)
        external
        payable
        onlyAssetOwner(_globalId)
    {
        (bool _isAvailableToReroll, uint256 rerollAmount) = rerollHelper(
            _globalId
        );
        require(_isAvailableToReroll, "Time to reroll is over");
        require(msg.value >= rerollAmount, "Insufficient commission");
        payable(feeReceiver).transfer(generationFee);
        payable(rerollFeeReceiver).transfer(rerollAmount - generationFee);

        (uint256 count, uint256 amount) = Staking.getCurrPoolStats(
            AssetsToIds[_globalId].currPoolId
        );
        bytes32 requestId = Random.getRandomNumber(
            msg.sender,
            AssetsToIds[_globalId].currPoolId,
            _globalId
        );
        emit AssetReroll(msg.sender, requestId, _globalId, count, amount);
    }

    function rerollHelper(uint256 _globalId)
        public
        view
        returns (bool _isAvailableToReroll, uint256 rerollFee)
    {
        require(AssetsToIds[_globalId].isExist, "Asset is not exist");
        rerollFee =
            (AssetsToIds[_globalId].amount *
                CurrencyPools[AssetsToIds[_globalId].currPoolId]
                    .rerollPercent) /
            10000;
        uint256 rerollAmount = (rerollFee *
            Oracle.getPrice(AssetsToIds[_globalId].currPoolId)) /
            Oracle.getPrice(0);
        bool isAvailToReroll = AssetsToIds[_globalId].createdAt +
            availableToReroll >
            block.timestamp;
        if (isAvailToReroll) {
            rerollFee = generationFee + rerollAmount;
        }
        return (isAvailToReroll, rerollFee);
    }

    function fulfillAsset(uint256 _globalId, uint256 _rarity)
        external
        onlyManager
        nonReentrant
    {
        require(AssetsToIds[_globalId].isExist, "Asset is not exist");
        AssetsToIds[_globalId].rarity = _rarity;
        uint256 _currPoolId = AssetsToIds[_globalId].currPoolId;
        uint256 _amount = AssetsToIds[_globalId].amount;
        if (!AssetsToIds[_globalId].isStaked) {
            Staking.deposit(_currPoolId, _globalId, _amount);
            AssetsToIds[_globalId].isStaked = true;
        } else {
            Staking.weightCorrector(_globalId);
        }
    }

    function getAssetData(uint256 _globalId)
        public
        view
        override
        returns (
            uint256 nftPoolId,
            uint256 currPoolId,
            uint256 amount,
            uint256 level,
            uint256 rarity,
            uint256 boostersMults
        )
    {
        require(AssetsToIds[_globalId].isExist, "Asset is not exist");
        return (
            AssetsToIds[_globalId].nftPoolId,
            AssetsToIds[_globalId].currPoolId,
            AssetsToIds[_globalId].amount,
            AssetsToIds[_globalId].level,
            AssetsToIds[_globalId].rarity,
            AssetsToIds[_globalId].boostersMults
        );
    }

    function getAssetUrl(uint256 _globalId)
        external
        view
        returns (string memory tokenURL)
    {
        require(AssetsToIds[_globalId].isExist, "Asset is not exist");
        return (
            NFTPoolsToIds[AssetsToIds[_globalId].nftPoolId].tokenURL(_globalId)
        );
    }

    function syncAsset(uint256 _globalId)
        external
        payable
        onlyAssetOwner(_globalId)
        nonReentrant
    {
        require(
            AssetsToIds[_globalId].boostersUpdateAmount > 0 ||
                AssetsToIds[_globalId].levelsUpdateAmount > 0,
            "Asset is already synchronized"
        );
        uint256 fee = AssetsToIds[_globalId].boostersUpdateAmount *
            boostersFee +
            AssetsToIds[_globalId].levelsUpdateAmount *
            levelsFee;
        require(msg.value >= fee, "Insufficient commission");
        payable(feeReceiver).transfer(fee);
        AssetsToIds[_globalId].level = AssetsToIds[_globalId].unsyncLevel;
        AssetsToIds[_globalId].boostersMults = AssetsToIds[_globalId]
            .unsyncBoostersMults;
        AssetsToIds[_globalId].unsyncBoostersMults = 0;
        AssetsToIds[_globalId].boostersUpdateAmount = 0;
        AssetsToIds[_globalId].levelsUpdateAmount = 0;
        if (AssetsToIds[_globalId].isStaked) {
            Staking.weightCorrector(_globalId);
        }
    }

    function syncHelper(uint256 _globalId)
        external
        view
        returns (
            uint256 levelUpdateFee,
            uint256 levelUpdateAmount,
            uint256 boosterUpdateFee,
            uint256 boosterUpdateAmount,
            uint256 summaryFee
        )
    {
        uint256 fee = AssetsToIds[_globalId].boostersUpdateAmount *
            boostersFee +
            AssetsToIds[_globalId].levelsUpdateAmount *
            levelsFee;
        return (
            levelsFee,
            AssetsToIds[_globalId].levelsUpdateAmount,
            boostersFee,
            AssetsToIds[_globalId].boostersUpdateAmount,
            fee
        );
    }

    function updateAssetLevel(uint256 _globalId, uint256 _level)
        public
        onlyManager
    {
        require(AssetsToIds[_globalId].isExist, "Asset is not exist");
        AssetsToIds[_globalId].levelsUpdateAmount += 1;
        AssetsToIds[_globalId].unsyncLevel = _level;
        emit AssetUpdateLevel(_globalId, _level);
    }

    function bulkUpdateAssetLevel(bytes calldata data) external onlyManager {
        UpdateAssetStruct[] memory assetsArr = abi.decode(
            data,
            (UpdateAssetStruct[])
        );
        uint256 arrLength = assetsArr.length;
        require(arrLength > 0, "Empty array");
        for (uint256 i = 0; i < arrLength; i++) {
            updateAssetLevel(assetsArr[i].globalId, assetsArr[i].value);
        }
    }

    function updateAssetBoosters(uint256 _globalId, uint256 _boostersMult)
        public
        onlyManager
    {
        require(AssetsToIds[_globalId].isExist, "Asset is not exist");
        AssetsToIds[_globalId].boostersUpdateAmount += 1;
        AssetsToIds[_globalId].unsyncBoostersMults += _boostersMult;
        emit AssetUpdateBoosters(_globalId, _boostersMult);
    }

    function bulkUpdateAssetBoosters(bytes calldata data) external onlyManager {
        UpdateAssetStruct[] memory assetsArr = abi.decode(
            data,
            (UpdateAssetStruct[])
        );
        uint256 arrLength = assetsArr.length;
        require(arrLength > 0, "Empty array");
        for (uint256 i = 0; i < arrLength; i++) {
            updateAssetBoosters(assetsArr[i].globalId, assetsArr[i].value);
        }
    }

    function unstakeAsset(uint256 _globalId)
        public
        onlyAssetOwner(_globalId)
        nonReentrant
    {
        require(
            AssetsToIds[_globalId].boostersUpdateAmount == 0 &&
                AssetsToIds[_globalId].levelsUpdateAmount == 0,
            "Synchronize asset first"
        );
        uint256 _currPoolId = AssetsToIds[_globalId].currPoolId;
        uint256 _amount = AssetsToIds[_globalId].amount;
        uint256 poolId = AssetsToIds[_globalId].nftPoolId;
        INFT currPool = NFTPoolsToIds[poolId];
        uint256 reward;
        if (AssetsToIds[_globalId].isStaked) {
            reward = Staking.withdraw(
                _globalId,
                currPool.ownerOf(_globalId),
                _currPoolId,
                _amount
            );
        }
        currPool.burn(_globalId);
        uint256 commission = (AssetsToIds[_globalId].amount * CurrencyPools[AssetsToIds[_globalId].currPoolId].unstakePercent) / 10000;
        AssetsToIds[_globalId].amount -= commission;
        require(
            CurrencyPools[AssetsToIds[_globalId].currPoolId].token.transfer(
                msg.sender,
                AssetsToIds[_globalId].amount
            ),
            "Transfer error"
        );
        if (commission > 0) {
          require(
            CurrencyPools[AssetsToIds[_globalId].currPoolId].token.transfer(
                unstakeFeeReceiver,
                commission
            ),
            "Transfer error"
        );  
        }
        AssetsToIds[_globalId].amount = 0;
        AssetsToIds[_globalId].isExist = false;
        emit AssetUnstake(_globalId, reward);
    }

    function bulkUnstakeAsset(uint256[] calldata _idsArray) external {
        uint256 length = _idsArray.length;
        require(length > 0, "Empty array");

        for (uint256 i = 0; i < length; i++) {
            unstakeAsset(_idsArray[i]);
        }
    }

    function getUpdateAmount(uint256 _globalId)
        external
        view
        returns (uint256 levels, uint256 boosters)
    {
        require(AssetsToIds[_globalId].isExist, "Asset is not exist");
        return (
            AssetsToIds[_globalId].levelsUpdateAmount,
            AssetsToIds[_globalId].boostersUpdateAmount
        );
    }

    function activateBoosters(uint256 _globalId)
        external
        onlyAssetOwner(_globalId)
        nonReentrant
    {
        require(
            AssetsToIds[_globalId].boostersUpdateAmount == 0 &&
                AssetsToIds[_globalId].levelsUpdateAmount == 0,
            "Synchronize asset first"
        );
        require(
            AssetsToIds[_globalId].boostersMults > 0,
            "You don't have any boosters"
        );
        require(AssetsToIds[_globalId].isStaked, "Asset is not staked");

        uint256 mult = AssetsToIds[_globalId].boostersMults;
        uint256 poolId = AssetsToIds[_globalId].nftPoolId;
        INFT currPool = NFTPoolsToIds[poolId];
        uint256 _currPoolId = AssetsToIds[_globalId].currPoolId;
        Staking.activateBooster(
            _globalId,
            currPool.ownerOf(_globalId),
            _currPoolId
        );
        AssetsToIds[_globalId].boostersMults = 0;
        uint256 interval = Staking.getBoostersActiveInterval();

        emit BoostersActivated(_globalId, mult, block.timestamp, interval);
    }

    function boosterInfo(uint256 _globalId)
        external
        view
        returns (
            bool _isBoosterActive,
            uint256 activeMult,
            uint256 boostersTimer,
            bool isBoostersAvail,
            uint256 availBoostersMult
        )
    {
        require(AssetsToIds[_globalId].isExist, "Asset is not exist");
        (_isBoosterActive, activeMult, boostersTimer) = Staking.boosterInfo(
            _globalId
        );
        if (!_isBoosterActive && AssetsToIds[_globalId].boostersMults > 0) {
            isBoostersAvail = true;
            availBoostersMult = AssetsToIds[_globalId].boostersMults;
        }
        return (
            _isBoosterActive,
            activeMult,
            boostersTimer,
            isBoostersAvail,
            availBoostersMult
        );
    }

    //***Staking Functions***//
    function addCurrencyPool(
        address _tokenAddress,
        string calldata _name,
        uint256 _allocPoint,
        uint256 _minimalAmount,
        uint256 _maximalAmount,
        uint256 _rerollPercent,
        uint256 _unstakePercent
    ) external onlyOwner {
        currencyPoolCounter += 1;
        Staking.addCurrency(currencyPoolCounter, _name, _allocPoint);
        CurrencyPools[currencyPoolCounter].token = IERC20(_tokenAddress);
        CurrencyPools[currencyPoolCounter].minimalAmount = _minimalAmount;
        CurrencyPools[currencyPoolCounter].maximalAmount = _maximalAmount;
        CurrencyPools[currencyPoolCounter].rerollPercent = _rerollPercent;
        CurrencyPools[currencyPoolCounter].unstakePercent = _unstakePercent;
        emit AddCurrencyPool(
            currencyPoolCounter,
            _name,
            _tokenAddress,
            _allocPoint,
            _minimalAmount,
            _rerollPercent
        );
    }

    function changeCurrencyPoolAllocPoint(
        uint256 _currPoolId,
        uint256 _newAllocPoint
    ) external onlyOwner {
        Staking.changeAllocPoint(_currPoolId, _newAllocPoint);
    }

    function changeRerollPercent(uint256 _currPoolId, uint256 _newRerollPercent)
        external
        onlyOwner
    {
        CurrencyPools[_currPoolId].rerollPercent = _newRerollPercent;
    }

    function changeMinMaxAmount(
        uint256 _currPoolId,
        uint256 _newMinAmount,
        uint256 _newMaxAmount
    ) external onlyOwner {
        CurrencyPools[_currPoolId].minimalAmount = _newMinAmount;
        CurrencyPools[_currPoolId].maximalAmount = _newMaxAmount;
    }

    function getCurrencyPoolInfo(uint256 _currPoolId)
        external
        view
        returns (
            string memory name,
            address tokenAddress,
            uint256 allocPoint,
            uint256 commonAllocWeight,
            uint256 minAmount,
            uint256 maxAmount,
            uint256 rerollPercent,
            uint256 unstakePercent,
            uint256 commonSum
        )
    {
        (name, allocPoint, commonAllocWeight, commonSum) = Staking.getPoolInfo(
            _currPoolId
        );
        tokenAddress = address(CurrencyPools[currencyPoolCounter].token);
        minAmount = CurrencyPools[currencyPoolCounter].minimalAmount;
        maxAmount = CurrencyPools[currencyPoolCounter].maximalAmount;
        rerollPercent = CurrencyPools[currencyPoolCounter].rerollPercent;
        unstakePercent = CurrencyPools[currencyPoolCounter].unstakePercent;

        return (
            name,
            tokenAddress,
            allocPoint,
            commonAllocWeight,
            minAmount,
            maxAmount,
            rerollPercent,
            unstakePercent,
            commonSum
        );
    }

    function getStakingInfo(uint256 _globalId)
        external
        view
        returns (
            uint256 reward,
            uint256 boosterReward,
            uint256 apr,
            uint256 amount,
            uint256 timeToClaimFreeze,
            uint256 commonWeight,
            uint256 assetWeight
        )
    {
        require(AssetsToIds[_globalId].isExist, "Asset is not exist");
        uint256 _currPoolId = AssetsToIds[_globalId].currPoolId;
        uint256 relativeAmount;
        if (_currPoolId == 1) {
            relativeAmount = AssetsToIds[_globalId].amount;
        } else {
            relativeAmount =
                (AssetsToIds[_globalId].amount * Oracle.getPrice(_currPoolId)) /
                Oracle.getPrice(1);
        }
        if (AssetsToIds[_globalId].isStaked) {
            (reward, boosterReward, apr, timeToClaimFreeze, commonWeight, assetWeight) = Staking.getInfo(
                _globalId,
                _currPoolId,
                relativeAmount
            );
        }
        return (
            reward,
            boosterReward,
            apr,
            AssetsToIds[_globalId].amount,
            timeToClaimFreeze,
            commonWeight,
            assetWeight
        );
    }

    function claim(uint256 _globalId) public onlyAssetOwner(_globalId) {
        require(
            AssetsToIds[_globalId].boostersUpdateAmount == 0 &&
                AssetsToIds[_globalId].levelsUpdateAmount == 0,
            "Synchronize asset first"
        );
        uint256 _currPoolId = AssetsToIds[_globalId].currPoolId;
        uint256 poolId = AssetsToIds[_globalId].nftPoolId;
        uint256 reward;
        INFT currPool = NFTPoolsToIds[poolId];
        if (AssetsToIds[_globalId].isStaked) {
            reward = Staking.claim(
                _globalId,
                currPool.ownerOf(_globalId),
                _currPoolId
            );
        }
        emit Claim(_globalId, reward);
    }

    function bulkClaim(uint256[] calldata _idsArray) external {
        uint256 length = _idsArray.length;
        require(length > 0, "Empty array");
        for (uint256 i = 0; i < length; i++) {
            claim(_idsArray[i]);
        }
    }

    //***Setting Functions***//
    function changeGenerator(address _addr) external onlyOwner {
        require(_addr != address(0), "Zero address");
        generator = _addr;
        Random = IRandom(_addr);
    }

    function changeOracle(address _addr) external onlyOwner {
        require(_addr != address(0), "Zero address");
        oracle = _addr;
        Oracle = IOracle(_addr);
    }

    function changeStaking(address _addr) external onlyOwner {
        require(_addr != address(0), "Zero address");
        staking = _addr;
        Staking = IStaking(_addr);
    }

    function setAvailableToReroll(uint256 _intervalInSeconds)
        external
        onlyOwner
    {
        availableToReroll = _intervalInSeconds;
    }

    function setBoostersActiveInterval(uint256 _intervalInSeconds)
        external
        onlyOwner
    {
        Staking.setBoostersActiveInterval(_intervalInSeconds);
    }

    function setYieldInterval(uint256 newYieldInterval) external onlyOwner {
        Staking.setYieldInterval(newYieldInterval);
    }

    function getYieldInterval() external view returns (uint256) {
        return (Staking.getYieldInterval());
    }

    function addManager(address _addr) external onlyOwner {
        Managers[_addr] = true;
    }

    function removeManager(address _addr) external onlyOwner {
        Managers[_addr] = false;
    }

    function isManager(address _addr)
        external
        view
        onlyOwner
        returns (bool _isManager)
    {
        return (Managers[_addr]);
    }

    function transferBeacon(
        uint256 _poolId,
        address _poolAddr,
        address _from,
        address _to,
        uint256 _globalId
    ) public override {
        require(
            address(NFTPoolsToIds[_poolId]) == _poolAddr,
            "Sender is not a NFT contract"
        );
        emit AssetTransfer(_poolId, _poolAddr, _from, _to, _globalId);
    }

    function changeTrxFee(
        uint256 _generationFeeInWei,
        uint256 _updateLevelsFeeInWei,
        uint256 _updateBoostersFeeOnWei
    ) external onlyOwner {
        generationFee = _generationFeeInWei;
        levelsFee = _updateLevelsFeeInWei;
        boostersFee = _updateBoostersFeeOnWei;
    }

    function changeFeeReciever(address _addr) external onlyOwner {
        require(_addr != address(0), "Zero address");
        feeReceiver = _addr;
    }

    function changeRerollFeeReceiver(address _addr) external onlyOwner {
        require(_addr != address(0), "Zero address");
        rerollFeeReceiver = _addr;
    }

    function changeUnstakeFeeReceiver(address _addr) external onlyOwner {
        require(_addr != address(0), "Zero address");
        unstakeFeeReceiver = _addr;
    }

    function getBaseURL()
        external
        view
        override
        returns (string memory _baseURL)
    {
        return baseURL;
    }

    function changeBaseURL(string memory _newBaseURL) external onlyOwner {
        baseURL = _newBaseURL;
    }

    function getBaseImgURL()
        external
        view
        override
        returns (string memory _baseImgURL)
    {
        return baseImgURL;
    }

    function changeBaseImgURL(string memory _newBaseImgURL) external onlyOwner {
        baseImgURL = _newBaseImgURL;
    }

    function tokensWithdraw(
        address _token,
        address _reciever,
        uint256 _amount
    ) external onlyOwner {
        IERC20 token = IERC20(_token);
        require(
            token.balanceOf(address(this)) >= _amount,
            "Insufficient balance for transaction"
        );
        require(token.transfer(_reciever, _amount), "Transfer error");
    }

    function emergencyWithdraw(uint256 _globalId)
        external
        onlyAssetOwner(_globalId)
        nonReentrant
    {
        require(
            AssetsToIds[_globalId].boostersUpdateAmount == 0 &&
                AssetsToIds[_globalId].levelsUpdateAmount == 0,
            "Synchronize asset first"
        );
        uint256 poolId = AssetsToIds[_globalId].nftPoolId;
        INFT currPool = NFTPoolsToIds[poolId];
        currPool.burn(_globalId);
        uint256 commission = (AssetsToIds[_globalId].amount * CurrencyPools[AssetsToIds[_globalId].currPoolId].unstakePercent) / 10000;
        AssetsToIds[_globalId].amount -= commission;
        require(
            CurrencyPools[AssetsToIds[_globalId].currPoolId].token.transfer(
                msg.sender,
                AssetsToIds[_globalId].amount
            ),
            "Transfer error"
        );
        if (commission > 0) {
          require(
            CurrencyPools[AssetsToIds[_globalId].currPoolId].token.transfer(
                unstakeFeeReceiver,
                commission
            ),
            "Transfer error"
        );  
        }
        AssetsToIds[_globalId].amount = 0;
        if (AssetsToIds[_globalId].isStaked) {
            Staking.weightCorrector(_globalId);
            Staking.emergencyBoosterClearer(_globalId);
        }
        AssetsToIds[_globalId].isExist = false;
        emit AssetUnstake(_globalId, 0);
    }
}