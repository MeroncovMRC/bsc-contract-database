{"DividendDistributor.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IBEP20.sol\";\n\ncontract DividendDistributor {\n    struct Share {\n        uint256 amount;\n        uint256 totalExcluded;\n        uint256 totalRealised;\n    }\n\n    IBEP20 public immutable LLU;\n    address immutable token;\n    address[] shareHolders;\n    uint256 currentIndex;\n\n    mapping (address =\u003e Share) public shares;\n    mapping (address =\u003e uint256) shareholderIndexes;\n    mapping (address =\u003e uint256) shareholderClaims;\n\n    uint256 public totalDistributed;\n    uint256 public totalShares;\n    uint256 public totalDividends;\n    uint256 public dividendsPerShare;\n    uint256 public dividendsPerShareAccuracyFactor = 10**8;\n\n    uint256 public gasLimit = 500000;\n    uint256 public minPeriod = 30 minutes;\n\n    event DividendDistributed(address indexed to, uint256 amount);\n\n    modifier onlyToken() {\n        require(msg.sender == token);\n        _;\n    }\n\n    constructor () {\n        token = msg.sender;\n        LLU = IBEP20(token);\n    }\n\n    // API\n\n    function deposit(uint256 amount) external onlyToken {\n        totalDividends += amount;\n        dividendsPerShare += dividendsPerShareAccuracyFactor * amount / totalShares;\n    }\n\n    function setShare(address shareholder, uint256 amount) external onlyToken {\n        if(shares[shareholder].amount \u003e 0){\n            distributeDividend(shareholder);\n        }\n\n        if(amount \u003e 0 \u0026\u0026 shares[shareholder].amount == 0){\n            addShareholder(shareholder);\n        }else if(amount == 0 \u0026\u0026 shares[shareholder].amount \u003e 0){\n            removeShareholder(shareholder);\n        }\n\n        totalShares = totalShares - shares[shareholder].amount + amount;\n        shares[shareholder].amount = amount;\n        shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);\n    }\n\n    function process() external onlyToken {\n        uint256 shareholderCount = shareHolders.length;\n\n        if(shareholderCount == 0) { return; }\n\n        uint256 gasLeft = gasleft();\n        uint256 gasUsed;\n        uint256 avgGasCost;\n        uint256 iterations;\n\n        while(gasUsed + avgGasCost \u003c gasLimit \u0026\u0026 iterations \u003c shareholderCount) {\n            if(currentIndex \u003e= shareholderCount){\n                currentIndex = 0;\n            }\n\n            if(shouldDistribute(shareHolders[currentIndex])){\n                distributeDividend(shareHolders[currentIndex]);\n            }\n\n            gasUsed += gasLeft - gasleft();\n            gasLeft = gasleft();\n            currentIndex++;\n            iterations++;\n            avgGasCost = gasUsed / iterations;\n        }\n    }\n\n    function claimDividend(address shareholder) external onlyToken {\n        distributeDividend(shareholder);\n    }\n\n    function getUnpaidEarnings(address shareholder) public view returns (uint256) {\n        if(shares[shareholder].amount == 0){ return 0; }\n\n        uint256 shareholderTotalDividends = getCumulativeDividends(shares[shareholder].amount);\n        uint256 shareholderTotalExcluded = shares[shareholder].totalExcluded;\n\n        if(shareholderTotalDividends \u003c= shareholderTotalExcluded){ return 0; }\n\n        return shareholderTotalDividends - shareholderTotalExcluded;\n    }\n\n    // Private\n    \n    function shouldDistribute(address shareholder) private view returns (bool) {\n        return shareholderClaims[shareholder] + minPeriod \u003c block.timestamp\n                \u0026\u0026 getUnpaidEarnings(shareholder) \u003e 0;\n    }\n\n    function distributeDividend(address shareholder) private {\n        if(shares[shareholder].amount == 0){ return; }\n\n        uint256 amount = getUnpaidEarnings(shareholder);\n        if(amount \u003e 0){\n            totalDistributed += amount;\n            shareholderClaims[shareholder] = block.timestamp;\n            shares[shareholder].totalRealised += amount;\n            shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);\n\n            LLU.transfer(shareholder, amount);\n            emit DividendDistributed(shareholder, amount);\n        }\n    }\n\n    function getCumulativeDividends(uint256 share) private view returns (uint256) {\n        return share * dividendsPerShare / dividendsPerShareAccuracyFactor;\n    }\n\n    function addShareholder(address shareholder) private {\n        shareholderIndexes[shareholder] = shareHolders.length;\n        shareHolders.push(shareholder);\n    }\n\n    function removeShareholder(address shareholder) private {\n        shareHolders[shareholderIndexes[shareholder]] = shareHolders[shareHolders.length-1];\n        shareholderIndexes[shareHolders[shareHolders.length-1]] = shareholderIndexes[shareholder];\n        shareHolders.pop();\n    }\n\n    // Maintenance\n\n    function setDistributionCriteria(uint256 _minPeriod) external onlyToken {\n        minPeriod = _minPeriod;\n    }\n\n    function setGasLimit(uint256 gas) external onlyToken {\n        gasLimit = gas;\n    }\n}\n"},"IBEP20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IBEP20 {\n  function totalSupply() external view returns (uint256);\n  function decimals() external view returns (uint8);\n  function symbol() external view returns (string memory);\n  function name() external view returns (string memory);\n  function getOwner() external view returns (address);\n  function balanceOf(address account) external view returns (uint256);\n  function transfer(address recipient, uint256 amount) external returns (bool);\n  function allowance(address _owner, address spender) external view returns (uint256);\n  function approve(address spender, uint256 amount) external returns (bool);\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"IDEX.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IDexFactory {\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n}\n\ninterface IDexRouter {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function swapExactTokensForETH(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable returns (uint[] memory amounts);\n}\n"},"INFT.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface INFT {\n  function balanceOf(address _owner) external view returns (uint256);\n  function taxDiscount(address _owner) external view returns (uint256);\n}\n"},"LightLemonUnicorn.sol":{"content":"// Light Lemon Unicorn Contract\n// The magical token!\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./INFT.sol\";\nimport \"./IDEX.sol\";\nimport \"./IBEP20.sol\";\nimport \"./DividendDistributor.sol\";\n\ncontract LightLemonUnicorn is IBEP20 {\n    enum TxType {\n        BUY,\n        SELL,\n        TRANSFER\n    }\n\n    // Determined Tax Integer Transaction\n    struct DTITx {\n        uint256 amount;\n        TxType txType;\n    }\n\n    INFT public nft;\n    address immutable owner;\n    address public launchpad;\n    address public constant MARKETING = 0x7aD1218F29F20a32948aFdccb8e9099d2946e91f;\n\n    int256[] public buyTaxDTIs = [int256(-1000000), 1123596, 2247191, 3370787, 4494382, 6741573, 7865169, 8988764, 10112360, 11235955, 12359551, 13483146, 14606742, 15730337, 40000000];\n    uint256[] public buyTaxValues = [0, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 1100, 1200, 1300, 1400, 1500];\n \n    int256[] public sellTaxDTIs = [int256(-3000000), -2497143, -1912821, -1406637, -912763, -526852, -274328, 26, 711487, 1599122, 3401769, 6109621, 8967018, 13077371, 26112441];\n    uint256[] public sellTaxValues = [9000, 8100, 7100, 6100, 5700, 5300, 5100, 4800, 4400, 3900, 3400, 2500, 1900, 1300, 600, 0];\n\n    address constant DEAD = 0x000000000000000000000000000000000000dEaD;\n    address constant ZERO = 0x0000000000000000000000000000000000000000;\n    address constant BUSD = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\n    uint16 constant FEE_DENOMINATOR = 10000;\n\n    bool public tradingEnabled;\n    bool public maxTaxEnabled = true;\n    bool public swapEnabled = true;\n    bool inSwap;\n    bool inBuyback;\n\n    uint8 dtiIndex;\n    uint8 constant DECIMALS = 18;\n    uint256 constant TOTAL_SUPPLY = 387131517 * 10**DECIMALS;\n\n    mapping (address =\u003e uint256) _balances;\n    mapping (address =\u003e mapping (address =\u003e uint256)) _allowances;\n\n    mapping (address =\u003e bool) public isWhitelisted;\n    mapping (address =\u003e bool) public isFeeExempt;\n    mapping (address =\u003e bool) public isTxLimitExempt;\n    mapping (address =\u003e bool) public isDividendExempt;\n    mapping (address =\u003e bool) public isAutomatedMarketMaker;\n\n    uint256 public maxBuyLimit = 4000000 * 10**DECIMALS;\n    uint256 public maxSellLimit = 200000 * 10**DECIMALS;\n    uint256 public rewardStorage;\n\n    uint256 public rewardShare = 400;\n    uint256 public marketingShare = 300;\n    uint256 public buybackShare = 9300;\n    uint256 public totalShares = 10000;\n    \n    DTITx[25] public dtiTransactions;\n    DividendDistributor public immutable distributor;\n    IDexRouter public constant ROUTER = IDexRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    address public immutable pair;\n\n    modifier swapping() { \n        inSwap = true;\n        _;\n        inSwap = false;\n    }\n\n    modifier burning() {\n        inBuyback = true;\n        _;\n        inBuyback = false;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    constructor () {\n        owner = msg.sender;\n        \n        pair = IDexFactory(ROUTER.factory()).createPair(BUSD, address(this));\n        _allowances[address(this)][address(ROUTER)] = type(uint256).max;\n        isAutomatedMarketMaker[pair] = true;\n\n        distributor = new DividendDistributor();\n        excludeAccounts();\n\n        _balances[owner] = TOTAL_SUPPLY;\n        emit Transfer(address(0), owner, TOTAL_SUPPLY);\n    }\n\n    // IBEP20\n\n    function totalSupply() external pure override returns (uint256) { return TOTAL_SUPPLY; }\n    function decimals() external pure override returns (uint8) { return DECIMALS; }\n    function symbol() external pure override returns (string memory) { return \"LLU\"; }\n    function name() external pure override returns (string memory) { return \"Light Lemon Unicorn\"; }\n    function getOwner() external view override returns (address) { return owner; }\n    function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }\n    function allowance(address _owner, address spender) external view override returns (uint256) { return _allowances[_owner][spender]; }\n\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\n        return _transferFrom(msg.sender, recipient, amount);\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\n        _transferFrom(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        require(currentAllowance \u003e= amount, \"Transfer amount exceeds allowance\");\n\n        _approve(sender, msg.sender, currentAllowance - amount);\n        return true;\n    }\n\n    // IBEP20 Helpers\n\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\n        uint256 currentAllowance = _allowances[msg.sender][spender];\n        require(currentAllowance \u003e= subtractedValue, \"Decreased allowance below zero\");\n\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\n        return true;\n    }\n\n    // Public\n\n    receive() external payable {}\n\n    // Private\n\n    function _approve(address _owner, address spender, uint256 amount) private {\n        _allowances[_owner][spender] = amount;\n        emit Approval(_owner, spender, amount);\n    }\n\n    function _transferFrom(address sender, address recipient, uint256 amount) private returns (bool) {\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance \u003e= amount, \"Transfer amount exceeds balance\");\n\n        if (inSwap || isWhitelisted[sender]) { return _basicTransfer(sender, recipient, amount); }\n        \n        DTITx memory dtiTx;\n        if (inBuyback) {\n            dtiTx = DTITx(amount, TxType.BUY);\n            updateDTITransactions(dtiTx);\n            return _basicTransfer(sender, recipient, amount);\n        }\n\n        require(tradingEnabled, \"Trading is disabled\");\n\n        TxType txType = TxType.TRANSFER;\n        if (isAutomatedMarketMaker[sender]) {\n            if (!isTxLimitExempt[recipient]) { require(_balances[recipient] + amount \u003c= maxBuyLimit, \"Max buy limit\"); }\n            txType = TxType.BUY;\n        }\n        if (isAutomatedMarketMaker[recipient]) {\n            if (!isTxLimitExempt[sender]) { require(amount \u003c= maxSellLimit, \"Max sell limit\"); }\n            txType = TxType.SELL;\n        }\n\n        dtiTx = DTITx(amount, txType);\n        updateDTITransactions(dtiTx);\n        if (shouldSwapBack(recipient)) { swapBack(); }\n\n        _balances[sender] = senderBalance - amount;\n        uint256 amountReceived = shouldTakeFee(sender, recipient) ? takeFee(sender, dtiTx) : amount;\n        _balances[recipient] += amountReceived;\n\n        if (!isDividendExempt[sender]) { try distributor.setShare(sender, _balances[sender]) {} catch {} }\n        if (!isDividendExempt[recipient]) { try distributor.setShare(recipient, _balances[recipient]) {} catch {} }\n\n        try distributor.process() {} catch {}\n\n        emit Transfer(sender, recipient, amountReceived);\n        return true;\n    }\n\n    function _basicTransfer(address sender, address recipient, uint256 amount) private returns (bool) {\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance \u003e= amount, \"Transfer amount exceeds balance\");\n\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function updateDTITransactions(DTITx memory dtiTx) private {\n        dtiTransactions[dtiIndex] = dtiTx;\n        dtiIndex++;\n        if (dtiIndex \u003e 24) { dtiIndex = 0; }\n    }\n\n    function shouldTakeFee(address sender, address recipient) private view returns (bool) {\n        return !isFeeExempt[sender] \u0026\u0026 !isFeeExempt[recipient];\n    }\n\n    function takeFee(address sender, DTITx memory dtiTx) private returns (uint256) {\n        uint256 tax;\n        uint256 discountMultiplier;\n\n        if (dtiTx.txType == TxType.BUY) {\n            tax = getBuyTax();\n        } else if (dtiTx.txType == TxType.TRANSFER) {\n            tax = 1500;\n        } else {\n            tax = getSellTax();\n            discountMultiplier = getDiscountMultiplier(sender);\n        }\n\n        if (maxTaxEnabled) { tax = FEE_DENOMINATOR - 100; }\n\n        uint256 discountedFee = tax - tax * discountMultiplier / FEE_DENOMINATOR;\n        uint256 feeAmount = dtiTx.amount * discountedFee / FEE_DENOMINATOR;\n\n        _balances[address(this)] += feeAmount;\n        emit Transfer(sender, address(this), feeAmount);\n\n        return dtiTx.amount - feeAmount;\n    }\n\n    function getBuyDTIValue() public view returns (int256) {\n        int256 dtiValue;\n\n        for (uint256 i; i \u003c dtiTransactions.length; i++) {\n            DTITx memory dtiTx = dtiTransactions[i];\n            if (dtiTx.txType == TxType.BUY) {\n                dtiValue += int256(dtiTx.amount / 10**DECIMALS);\n            } else if (dtiTx.txType == TxType.SELL) {\n                dtiValue -= int256(dtiTx.amount / 10**DECIMALS);\n            }\n        }\n\n        return dtiValue;\n    }\n\n    function getSellDTIValue() public view returns (int256) {\n        int256 dtiValue;\n\n        for (uint256 i; i \u003c dtiTransactions.length; i++) {\n            DTITx memory dtiTx = dtiTransactions[i];\n            if (dtiTx.txType == TxType.BUY) {\n                dtiValue += int256(dtiTx.amount / 10**DECIMALS);\n            } else if (dtiTx.txType == TxType.SELL) {\n                dtiValue -= int256(dtiTx.amount / 10**DECIMALS);\n            }\n        }\n\n        return dtiValue;\n    }\n\n    function getBuyTax() public view returns (uint256) {\n        int256 dtiValue = getBuyDTIValue();\n        return buyTaxFromDTI(dtiValue);\n    }\n\n    function getSellTax() public view returns (uint256) {\n        int256 dtiValue = getSellDTIValue();\n        return sellTaxFromDTI(dtiValue);\n    }\n\n    function buyTaxFromDTI(int256 dtiValue) private view returns (uint256) {\n        uint256 currentIndex;\n        for (uint256 i; i \u003c buyTaxDTIs.length; i++) {\n            if (dtiValue \u003c buyTaxDTIs[i]) {\n                return buyTaxValues[currentIndex];\n            } else {\n                currentIndex++;\n            }\n        }\n        return buyTaxValues[buyTaxValues.length - 1];\n    }\n\n    function sellTaxFromDTI(int256 dtiValue) private view returns (uint256) {\n        uint256 currentIndex;\n        for (uint256 i; i \u003c sellTaxDTIs.length; i++) {\n            if (dtiValue \u003c sellTaxDTIs[i]) {\n                return sellTaxValues[currentIndex];\n            } else {\n                currentIndex++;\n            }\n        }\n        return sellTaxValues[sellTaxValues.length - 1];\n    }\n\n    function getDiscountMultiplier(address account) private view returns (uint256) {\n        uint256 nftDiscountMultiplier;\n        if (address(nft) != address(0)) { nftDiscount(account); }\n        uint256 secretDiscountMultiplier = secretDiscount(account);\n\n        if (nftDiscountMultiplier \u003e= secretDiscountMultiplier) {\n            return nftDiscountMultiplier;\n        } else {\n            return secretDiscountMultiplier;\n        }\n    }\n\n    function secretDiscount(address account) private view returns (uint256) {\n        IBEP20 secret = IBEP20(0xed763F7fa6eB3800FE87cC31Ac5B03DCeC03A8c9);\n\n        try secret.balanceOf(account) returns (uint256 balance) {\n            if (balance \u003e= 5 * 10**6 * 10**8) { return 600; }\n        } catch {\n            return 0;\n        }\n\n        return 0;\n    }\n\n    function nftDiscount(address account) private view returns (uint256) {\n        try nft.taxDiscount(account) returns (uint256 discountMultiplier) {\n            return discountMultiplier \u003e FEE_DENOMINATOR ? FEE_DENOMINATOR : discountMultiplier;\n        } catch {\n            return 0;\n        }\n    }\n\n    function shouldSwapBack(address recipient) private view returns (bool) {\n        return isAutomatedMarketMaker[recipient]\n        \u0026\u0026 !inSwap\n        \u0026\u0026 swapEnabled\n        \u0026\u0026 _balances[address(this)] \u003e 0;\n    }\n\n    function swapBack() private swapping {\n        address[] memory path = new address[](3);\n        path[0] = address(this);\n        path[1] = BUSD;\n        path[2] = ROUTER.WETH();\n\n        uint256 taxedTokens = _balances[address(this)] - rewardStorage;\n        uint256 rewardFee = taxedTokens * rewardShare / totalShares;\n        rewardStorage += rewardFee;\n\n        uint256 tokensToSell = taxedTokens - rewardFee;\n\n        if (tokensToSell \u003e 0) {\n            uint256 balanceBefore = address(this).balance;\n\n            ROUTER.swapExactTokensForETH(\n                tokensToSell,\n                0,\n                path,\n                address(this),\n                block.timestamp\n            );\n\n            uint256 amountBNB = address(this).balance - balanceBefore;\n            uint256 marketingBNB = amountBNB * marketingShare / totalShares;\n\n            payable(MARKETING).call{value: marketingBNB, gas: 30000}(\"\");\n        }\n    }\n\n    function buyback(uint256 amount) private burning {\n        address[] memory path = new address[](3);\n        path[0] = ROUTER.WETH();\n        path[1] = BUSD;\n        path[2] = address(this);\n\n        ROUTER.swapExactETHForTokens{value: amount}(\n            0,\n            path,\n            DEAD,\n            block.timestamp\n        );\n    }\n\n    function excludeAccounts() private {\n        isWhitelisted[owner] = true;\n        isFeeExempt[owner] = true;\n        isDividendExempt[owner] = true;\n        isTxLimitExempt[owner] = true;\n\n        isFeeExempt[address(this)] = true;\n        isDividendExempt[address(this)] = true;\n        isTxLimitExempt[address(this)] = true;\n\n        isFeeExempt[address(distributor)] = true;\n        isDividendExempt[address(distributor)] = true;\n        isTxLimitExempt[address(distributor)] = true;\n\n        isDividendExempt[pair] = true;\n        isDividendExempt[DEAD] = true;\n        isDividendExempt[ZERO] = true;\n    }\n\n    // Owner\n\n    function setAutomatedMarketMaker(address amm, bool exempt) external onlyOwner {\n        require(amm != pair);\n        isAutomatedMarketMaker[amm] = exempt;\n    }\n\n    function setIsDividendExempt(address account, bool exempt) external onlyOwner {\n        require(account != address(this) \u0026\u0026 account != pair \u0026\u0026 account != DEAD \u0026\u0026 account != ZERO);\n\n        isDividendExempt[account] = exempt;\n        if(exempt){\n            distributor.setShare(account, 0);\n        }else{\n            distributor.setShare(account, _balances[account]);\n        }\n    }\n\n    function setIsFeeExempt(address account, bool exempt) external onlyOwner {\n        require(account != address(this));\n        isFeeExempt[account] = exempt;\n    }\n\n    function setIsTxLimitExempt(address account, bool exempt) external onlyOwner {\n        require(account != address(this));\n        isTxLimitExempt[account] = exempt;\n    }\n\n    function setMaxBuyLimit(uint256 amount) external onlyOwner {\n        require(amount \u003e= 2000000);\n\n        uint256 tokenAmount = amount * 10**DECIMALS;\n        maxBuyLimit = tokenAmount;\n    }\n\n    function setMaxSellLimit(uint256 amount) external onlyOwner {\n        require(amount \u003e= 100000);\n\n        uint256 tokenAmount = amount * 10**DECIMALS;\n        maxSellLimit = tokenAmount;\n    }\n\n    function setTaxDistribution(uint256 _rewards, uint256 _marketing, uint256 _buyback) external onlyOwner {\n        rewardShare = _rewards;\n        marketingShare = _marketing;\n        buybackShare = _buyback;\n        totalShares = rewardShare + marketingShare + buybackShare;\n    }\n\n    function setBuyTaxes(int256[] calldata thresholds, uint256[] calldata values) external onlyOwner {\n        require(thresholds.length \u003c= 20);\n        require(values.length - 1 == thresholds.length);\n\n        buyTaxDTIs = thresholds;\n        buyTaxValues = values;\n    }\n    \n    function setSellTaxes(int256[] calldata thresholds, uint256[] calldata values) external onlyOwner {\n        require(thresholds.length \u003c= 20);\n        require(values.length - 1 == thresholds.length);\n\n        sellTaxDTIs = thresholds;\n        sellTaxValues = values;\n    }\n\n    function setSwapBackSetting(bool enabled) external onlyOwner {\n        swapEnabled = enabled;\n    }\n\n    function triggerBuyback(uint256 amount) external onlyOwner {\n        buyback(amount);\n    }\n\n    function triggerSwapBack() external onlyOwner {\n        swapBack();\n    }\n\n    function updateNFT(address newNFT) external onlyOwner {\n        nft = INFT(newNFT);\n        nft.taxDiscount(msg.sender);\n    }\n\n    function depositRewards(uint256 amount) external onlyOwner {\n        require(rewardStorage \u003e= amount);\n\n        rewardStorage -= amount;\n        _basicTransfer(address(this), address(distributor), amount);\n        distributor.deposit(amount);\n    }\n\n    function initLaunchpad(address newPad) external onlyOwner {\n        require(launchpad == ZERO, \"Launchpad initialised\");\n        launchpad = newPad;\n        isWhitelisted[launchpad] = true;\n    }\n\n    function enableTrading() external onlyOwner {\n        tradingEnabled = true;\n    }\n\n    function disableMaxTax() external onlyOwner {\n        maxTaxEnabled = false;\n    }\n\n    // Distributor\n\n    function setGasLimit(uint256 gas) external onlyOwner {\n        require(gas \u003c= 750000 \u0026\u0026 gas \u003e= 100000);\n        distributor.setGasLimit(gas);\n    }\n\n    function setDistributionCriteria(uint256 minPeriod) external onlyOwner {\n        require(minPeriod \u003c= 1 days);\n        distributor.setDistributionCriteria(minPeriod);\n    }\n\n    function getUnpaidEarnings(address shareholder) external view returns (uint256) {\n        return distributor.getUnpaidEarnings(shareholder);\n    }\n\n    function claim() external {\n        distributor.claimDividend(msg.sender);\n    }\n}\n"}}