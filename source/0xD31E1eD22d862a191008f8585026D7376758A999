pragma solidity ^0.6.12;

/**


CumFarm

Stake CUMMIES-BNB V2 LP, earn CUMMIES!

Written by Sir Tris of Knights Defi

 */

// SPDX-License-Identifier: MIT License

/**
 * @dev Standard math utilities missing in the Solidity language.
 */
library Math {
    /**
     * @dev Returns the largest of two numbers.
     */
    function max(uint256 a, uint256 b) internal pure returns (uint256) {
        return a >= b ? a : b;
    }

    /**
     * @dev Returns the smallest of two numbers.
     */
    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }

    /**
     * @dev Returns the average of two numbers. The result is rounded towards
     * zero.
     */
    function average(uint256 a, uint256 b) internal pure returns (uint256) {
        // (a + b) / 2 can overflow, so we distribute
        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);
    }
}

/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     *
     * _Available since v2.4.0._
     */
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     *
     * _Available since v2.4.0._
     */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     *
     * _Available since v2.4.0._
     */
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}

/**
 * @dev Interface of the ERC20 standard as defined in the EIP. Does not include
 * the optional functions; to access them see {ERC20Detailed}.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.

        uint256 size;
        // solhint-disable-next-line no-inline-assembly
        assembly { size := extcodesize(account) }
        return size > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value
        (bool success, ) = recipient.call{ value: amount }("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain`call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
      return functionCall(target, data, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.call{ value: value }(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.staticcall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        require(isContract(target), "Address: delegate call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length > 0) {
                // The easiest way to bubble the revert reason is using memory via assembly

                // solhint-disable-next-line no-inline-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
    using SafeMath for uint256;
    using Address for address;

    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        // solhint-disable-next-line max-line-length
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves.

        // A Solidity high level call has three parts:
        //  1. The target address is checked to verify it contains contract code
        //  2. The call itself is made, and success asserted
        //  3. The return value is decoded, which in turn checks the size of the returned data.
        // solhint-disable-next-line max-line-length
        require(address(token).isContract(), "SafeERC20: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length > 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}

/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with GSN meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
contract Context {
    // Empty internal constructor, to prevent people from mistakenly deploying
    // an instance of this contract, which should be used via inheritance.
    constructor () internal { }
    // solhint-disable-previous-line no-empty-blocks

    function _msgSender() internal view returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
contract Ownable is Context {
    address private _owner;
    address private _previousOwner;
    uint256 private _lockTime;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor () internal {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(isOwner(), "Ownable: caller is not the owner");
        _;
    }

    /**
     * @dev Returns true if the caller is the current owner.
     */
    function isOwner() public view returns (bool) {
        return _msgSender() == _owner;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     */
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }

    function getUnlockTime() public view returns (uint256) {
        return _lockTime;
    }

    //Locks the contract for owner for the amount of time provided
    function lock(uint256 time) public virtual onlyOwner {
        _previousOwner = _owner;
        _owner = address(0);
        _lockTime = now + time;
        emit OwnershipTransferred(_owner, address(0));
    }
    
    //Unlocks the contract for owner when _lockTime is exceeds
    function unlock() public virtual {
        require(_previousOwner == msg.sender, "You don't have permission to unlock");
        require(now > _lockTime , "Contract is locked and timer must expire before you can reclaim");
        emit OwnershipTransferred(_owner, _previousOwner);
        _owner = _previousOwner;
    }
}


contract CumFarm is Ownable {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    /* ========== STATE VARIABLES ========== */

    uint256 public lastUpdateBlock = block.number; // Last Block Rewards Were Updated
    uint256 private constant percPrecision = 10**18;
    uint256 private constant rewardRatePrecision = 10**18;
    uint256 private constant eN = 271828; // e Numerator
    uint256 private constant eD = 100000; // e Denominator

    // Structures for adding new tokens and storing rewards.

    struct StakingToken {
        // pid is position in array of stakingTokens.
        address stakingToken;
        uint256 multi;
        uint256 totalAmountStaked;
        uint256 rewardPoolPct;  // Set amount of deposit that will be added as a reward.  Automatically added to contract's balance.
        uint256 burnPct; // Set amount of tokens to be burned upon staking.  0 for most tokens.
        uint256 externalFeePct; // use external fee amount to ensure we don't overstake.
    }

    struct RewardToken {
        address rewardToken; // for transferrable tokens on contract.
        uint256 rewardRate; // This is rate per block, with 18 decimals.  Calculate carefully!
        uint256 blockStart;
        uint256 rewardBalance;
        uint256 rewardsAssigned;
        uint256 externalFeePct; // To ensure the correct amount makes it to the contract only.
    }

    // Hash tables to store data (more efficient than structs for transactional data)

    StakingToken[] public stakingTokens;
    RewardToken[] public rewardTokens;
    mapping(address => mapping(uint256 => uint256)) public userHoldings; // example lookup: userHoldings[holderAddress][StakingTokenPid];
    mapping(address => uint256) public strength; // will contain the total strength of holder.
    mapping(address => mapping(uint256 => uint256)) public holderRewards; // contains holder rewards ready to claim.  Populate before claiming. holderRewards[holderAddress][RewardTokenPid];
    mapping(address => uint256) public holderLastRewardBlock; // determines holder's rewards based on last reward block they claimed.
    uint256 public totalStrength;

    /* ========== CONSTRUCTOR ========== */

    constructor() public {

        totalStrength = 0;
        uint256 cummiesRewardRate = 2000000000000000000; // 7.5M CUMMIES over 120 days = ~2 CUMMIES per block = 57,600 CUMMIES per day (28,800 blocks in a day roughly)
        
        // staking Tokens
        stakingTokens.push(StakingToken({ // CUMMIES-BNB V2 LP
            stakingToken:0x02bFf262b10B7Ae1d2E4455ad4CAE2d0A6ECF086,
            multi:1,
            totalAmountStaked:0, 
            rewardPoolPct: 0, 
            burnPct: 1, // burn 1% of all LPs staked to lock some liquidity
            externalFeePct: 0
        }));

        rewardTokens.push(RewardToken({ // CUMMIES
            rewardToken:0x27Ae27110350B98d564b9A3eeD31bAeBc82d878d,
            rewardRate:cummiesRewardRate,
            blockStart:block.number,
            rewardBalance:0,
            rewardsAssigned:0,
            externalFeePct: 0
        })); 
    }

    

    function getContractStakingBalance(uint256 pid) external view returns (uint256) {
        return stakingTokens[pid].totalAmountStaked;
    }

    function balanceOf(address account, uint256 pid) external view returns (uint256) {
        return userHoldings[account][pid];
    }

    function getContractRewardBalance(uint256 pid) external view returns (uint256) {
        return rewardTokens[pid].rewardBalance;
    }

    function updateUserRewardBlock(address holder) private {
        holderLastRewardBlock[holder] = block.number;
    }

    function getUserCurrentRewards(address holder, uint256 pid) public view returns (uint256) { // show user's rewards by Reward Token
        uint256 newRewards = getRewardsAmount(pid, holder); // Get Rewards To Move
        uint256 currentRewards = holderRewards[holder][pid].add(newRewards.mul(getHolderPercentage(holder)).div(percPrecision));
        return currentRewards;
    }

    /* ========== Custom Functions========= */

    function updateStakingToken(uint256 pid, uint256 _multi, uint256 _rewardPoolPct, uint256 _burnPct, uint256 _externalFeePct) external onlyOwner() returns (bool) {
        // Makes changes to existing token multipliers and whether it counts as an exponent or constant.

        stakingTokens[pid].multi = _multi;
        stakingTokens[pid].rewardPoolPct = _rewardPoolPct;
        stakingTokens[pid].burnPct = _burnPct;
        stakingTokens[pid].externalFeePct = _externalFeePct;
        emit UpdatedStakingToken(stakingTokens[pid].stakingToken);
        return true;
    }

    function addRewardToken(address _rewardToken, uint256 _rewardRate, uint256 _blockStart, uint256 _externalFeePct) external onlyOwner() returns (bool) {

        uint256 length = rewardTokens.length;

        for (uint256 u = 0; u < length; u++) {
            require(_rewardToken != rewardTokens[u].rewardToken, "Reward token already exists.  Cannot add again.");
        }

        // Adds new rewardTokens
        rewardTokens.push(RewardToken({rewardToken:_rewardToken, rewardRate:_rewardRate, blockStart:_blockStart, externalFeePct:_externalFeePct, rewardBalance:0, rewardsAssigned:0}));
        emit NewRewardToken(_rewardToken);
        return true;
    }

    function updateRewardToken(uint256 pid, uint256 _rewardRate, uint256 _blockStart, uint256 _externalFeePct) external onlyOwner() {

        // Update Reward Tokens
        
        rewardTokens[pid].rewardRate = _rewardRate;
        rewardTokens[pid].blockStart = _blockStart;
        rewardTokens[pid].externalFeePct = _externalFeePct; // take fees into account to not overallocate staking or rewards.
        
        emit NewRewardToken(rewardTokens[pid].rewardToken);
    }

    function setHolderStrength(address holderAddress) private returns (bool){
        // Set user's staking strength
        strength[holderAddress] = userHoldings[holderAddress][0];
        return true;
    }
    
    function calculateHolderStrength(address holderAddress) external view returns (uint256){
        return userHoldings[holderAddress][0];
    }

    function getHolderStrength(address holderAddress) external view returns (uint256){
        return strength[holderAddress];
    }

    function getTotalStrength() external view returns (uint256){
        return totalStrength;
    }

    function getHolderPercentage(address holderAddress) public view returns (uint256){
        if(totalStrength > 0){
            return strength[holderAddress].mul(percPrecision).div(totalStrength); // returns a large value, no floats allowed.  Need to divide rewards by percPrecision.
        } else {
            return 0; // prevent divide by 0 error
        }
    }

    function stake(uint256 pid, uint256 amount) external {
        require(amount > 0, "Cannot stake 0");
        
        if (holderLastRewardBlock[msg.sender] == 0){ // ensure people can't claim previous rewards by staking in and withdrawing immediately.
            updateUserRewardBlock(msg.sender);
        }

        updateRewards();

        // instantiate IERC20 for proper staking token
        StakingToken storage _stakingToken = stakingTokens[pid];
        IERC20 token = IERC20(_stakingToken.stakingToken);

        uint256 burnAmount = amount.mul(stakingTokens[pid].burnPct).div(100);
        uint256 rewardPoolAmount = amount.mul(stakingTokens[pid].rewardPoolPct).div(100);
        uint256 externalFeeAmount = amount.mul(stakingTokens[pid].externalFeePct).div(100);
        
        require(burnAmount.add(rewardPoolAmount).add(externalFeeAmount) <= amount, "Tax is too high");
        uint256 amountAfterTaxes = amount.sub(burnAmount).sub(rewardPoolAmount).sub(externalFeeAmount);

        // Update internal holdings
        userHoldings[msg.sender][pid] = userHoldings[msg.sender][pid].add(amountAfterTaxes);
        _stakingToken.totalAmountStaked = _stakingToken.totalAmountStaked.add(amountAfterTaxes);

        // Add reward pool amount to contract (use this to verify reward balances, not contract's actual balance)
        if(rewardPoolAmount > 0){  
            uint256 length = rewardTokens.length;
            for(uint256 i = 0; i <length; ++i){
                if(address(rewardTokens[i].rewardToken) == address(_stakingToken.stakingToken)){
                    RewardToken storage _rewardToken = rewardTokens[i];
                    _rewardToken.rewardBalance = _rewardToken.rewardBalance.add(rewardPoolAmount); 
                }
            }
        }

        // Update Strengths
        if(strength[msg.sender] > 0){
            totalStrength = totalStrength.sub(strength[msg.sender]); // Remove old Strength
        }
        
        setHolderStrength(msg.sender); // update user's strength
        totalStrength = totalStrength.add(strength[msg.sender]); // Add new Strength to keep it updated.

        // Transfer the tokens to contract.
        token.safeTransferFrom(msg.sender, address(this), amount); // don't forget to approve / allow before calling stake function with UI.

        if(burnAmount > 0){
            token.approve(address(0x000000000000000000000000000000000000dEaD), burnAmount);
            token.transfer(address(0x000000000000000000000000000000000000dEaD), burnAmount); // send burn amount to burn address (cannot burn, as not every token allows a burn function)
        }
        emit Staked(msg.sender, pid, amount);
    }

    function withdraw(uint256 pid, uint256 amount, bool ignoreRewards) public {
        require(amount > 0, "Cannot withdraw 0");
        require(userHoldings[msg.sender][pid] >= amount, "User does not have enough tokens to withdraw");
        if(!ignoreRewards){
            updateRewards();
            withdrawAllRewards();
        } else {
            updateUserRewardBlock(msg.sender);
        }

        // instantiate IERC20 for proper staking token
        StakingToken storage _stakingToken = stakingTokens[pid];
        IERC20 token = IERC20(_stakingToken.stakingToken);

        // Update internal holdings
        userHoldings[msg.sender][pid] = userHoldings[msg.sender][pid].sub(amount);
        _stakingToken.totalAmountStaked = _stakingToken.totalAmountStaked.sub(amount);
        
        // Update Strengths
        if(strength[msg.sender] > 0){
            totalStrength = totalStrength.sub(strength[msg.sender]); // Remove old Strength
        }
        setHolderStrength(msg.sender); // update user's strength
        totalStrength = totalStrength.add(strength[msg.sender]); // Add new Strength
        
        // Transfer the tokens to caller.
        token.approve(msg.sender, amount);
        token.transfer(msg.sender, amount); // don't forget to approve / allow before calling withdraw function with UI.
        emit Withdrawn(msg.sender, pid, amount);
    }

    function withdrawAllRewards() public {  // Harvests all rewards in a single txn.
        uint256 length = rewardTokens.length;
        for (uint256 i = 0; i < length; i++){
            withdrawReward(i);
        }
    }

    /// @dev This will allow any tokens *sent* to the contract to get reclaimed as rewards if there is a reward pool.  
    /// Prevents 'lost' tokens and harvests reflect rewards!

    function updateContractRewardBalance(uint256 pid) internal {

        // instantiate IERC20 for proper staking token
        RewardToken storage _rewardToken = rewardTokens[pid];
        
        uint256 stakingTokenPid = ~uint256(0); // set to very high dummy value to ensure a proper staking token is found
        
        uint256 stakingLength = stakingTokens.length;
        for (uint256 u = 0; u < stakingLength; u++){ // loop through staking tokens
            if(address(stakingTokens[u].stakingToken) == address(rewardTokens[pid].rewardToken)){
                stakingTokenPid = u;
            }
        }

        if(stakingTokenPid != ~uint256(0)) {
            // Don't harvest staked or reward allocation for holders
            IERC20 rewardToken = IERC20(address(_rewardToken.rewardToken));
            uint256 totalContractBalance = rewardToken.balanceOf(address(this)); // Check total balance of contract.
            uint256 totalTrackedBalance = _rewardToken.rewardBalance.add(stakingTokens[stakingTokenPid].totalAmountStaked).add(_rewardToken.rewardsAssigned);
            if (totalContractBalance > totalTrackedBalance){
                uint256 rewardsToAdd = totalContractBalance.sub(totalTrackedBalance);
                _rewardToken.rewardBalance = _rewardToken.rewardBalance.add(rewardsToAdd);
                emit RewardsAdded(pid, rewardsToAdd);
            }
        } else { // this means there is no matching Staking token, so it can just look at the reward balances
            IERC20 rewardToken = IERC20(address(_rewardToken.rewardToken));
            uint256 totalContractBalance = rewardToken.balanceOf(address(this)); // Check total balance of contract.
            uint256 totalTrackedBalance = _rewardToken.rewardBalance.add(_rewardToken.rewardsAssigned);
            if (totalContractBalance > totalTrackedBalance){
                uint256 rewardsToAdd = totalContractBalance.sub(totalTrackedBalance);
                _rewardToken.rewardBalance = _rewardToken.rewardBalance.add(rewardsToAdd);
                emit RewardsAdded(pid, rewardsToAdd);
            }
        }
    }

    function withdrawReward(uint256 pid) public returns (bool){
        updateRewards();
        uint256 reward = holderRewards[msg.sender][pid];
        IERC20 rewardsToken = IERC20(rewardTokens[pid].rewardToken);
        if (reward > 0) {
            holderRewards[msg.sender][pid] = 0; // Set holder's rewards to claim to 0.  They're claiming all of them!
            rewardTokens[pid].rewardsAssigned = rewardTokens[pid].rewardsAssigned.sub(reward);
            rewardsToken.safeTransfer(msg.sender, reward);
            emit RewardPaid(msg.sender, pid, reward);
        }

    }
  
    function emergencyExit(bool ignoreRewards) external {
        // user withdraws all rewards and tokens, can ignore rewards or not.
        uint256 length = stakingTokens.length;

        for (uint256 u = 0; u < length; u++) {
            if(userHoldings[msg.sender][u] > 0) {
                withdraw(u, userHoldings[msg.sender][u], ignoreRewards);
            } 
        }
    }

    function getRewardsAmount(uint256 pid, address holder) private view returns (uint256) {
        uint256 lastRewardBlock;
        if (block.number < rewardTokens[pid].blockStart || holderLastRewardBlock[holder] == block.number){ // Don't give out rewards early and don't double dip rewards.
            return 0;
        } else {
            lastRewardBlock = holderLastRewardBlock[holder];
        }

        return Math.min(rewardTokens[pid].rewardRate.mul(block.number - lastRewardBlock), rewardTokens[pid].rewardBalance); // all pending rewards (not moved to holderRewards)
    }

    function updateRewards() internal {

        if (block.number > holderLastRewardBlock[msg.sender]) {
            // Write rewards to holderRewards mapping
            if (holderLastRewardBlock[msg.sender] == 0) { // Fix UI issue for new stakers.
                holderLastRewardBlock[msg.sender] = block.number;    
            } 
            updateUsersReward(msg.sender);
            updateUserRewardBlock(msg.sender);
        }
    }

    function updateUsersReward(address holder) internal {
        uint256 length = rewardTokens.length;
        for (uint256 u = 0; u < length; u++) { // for each reward token, calculate user rewards
            uint256 rewards = getUserCurrentRewards(holder, u); // returns current rewards + new rewards.
            uint256 previousRewards = holderRewards[holder][u];
            uint256 newRewards = rewards.sub(previousRewards); // get new rewards only
            holderRewards[holder][u] = rewards;
            if(rewardTokens[u].rewardBalance < newRewards){ // Prevent math errors from crashing code.
                newRewards = rewardTokens[u].rewardBalance;
            }
            if(newRewards > 0){
                rewardTokens[u].rewardBalance = rewardTokens[u].rewardBalance.sub(newRewards);
                rewardTokens[u].rewardsAssigned = rewardTokens[u].rewardsAssigned.add(newRewards);
            }
            updateContractRewardBalance(u);
        }
    }

    // Added to support recovering Rewards from other systems such as BAL to be distributed to holders
    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {
        uint256 length = stakingTokens.length;
        for (uint256 u = 0; u < length; u++) {
            require(tokenAddress != stakingTokens[u].stakingToken, "Cannot withdraw Staking Token");
        }

        length = rewardTokens.length;
        for (uint256 u = 0; u < length; u++) {
            require(tokenAddress != rewardTokens[u].rewardToken, "Cannot withdraw Reward Token");
        }

        IERC20(tokenAddress).safeTransfer(owner(), tokenAmount);
        emit Recovered(tokenAddress, tokenAmount);
    }
    
    // allow owner to emergency withdraw reward tokens that have not been allocated in the event of an emergency.
    function emergencyRewardTokensWithdrawal(uint256 rewardId) external onlyOwner {
        IERC20 tokenAddress = IERC20(address(rewardTokens[rewardId].rewardToken));
        uint256 tokenAmount = tokenAddress.balanceOf(address(this)).sub(rewardTokens[rewardId].rewardsAssigned);
        rewardTokens[rewardId].rewardBalance = 0;
        tokenAddress.safeTransfer(msg.sender, tokenAmount);
        emit Recovered(address(tokenAddress), tokenAmount);
    }
    
    // refresh rewards without any other interactions from Admin when sending new tokens directly to contract
    function refreshRewards() external onlyOwner {
        uint256 length = rewardTokens.length;
        for (uint256 u = 0; u < length; u++) { // update contract rewards balance for all reward tokens
            updateContractRewardBalance(u);
        }
    }

    /* ========== EVENTS ========== */

    event NewRewardToken(address tokenAddress);
    event NewStakingToken(address tokenAddress);
    event UpdatedStakingToken(address tokenAddress);
    event UpdatedRewardToken(address tokenAddress);
    event RewardsAdded(uint256 pid, uint256 amount);
    event Staked(address indexed user, uint256 pid, uint256 amount);
    event Withdrawn(address indexed user, uint256 pid, uint256 amount);
    event RewardPaid(address indexed user, uint256 pid, uint256 reward);
    event RewardsDurationUpdated(uint256 newDuration);
    event Recovered(address token, uint256 amount);
}