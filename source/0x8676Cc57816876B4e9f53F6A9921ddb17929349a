{"Address.sol":{"content":"/*\r\n\r\n██████╗░░█████╗░██████╗░██╗░░░██╗░█████╗░██╗░░██╗██╗███████╗░█████╗░░█████╗░██╗░░██╗███████╗\r\n██╔══██╗██╔══██╗██╔══██╗╚██╗░██╔╝██╔══██╗╚██╗██╔╝██║██╔════╝██╔══██╗██╔══██╗██║░██╔╝██╔════╝\r\n██████╦╝███████║██████╦╝░╚████╔╝░███████║░╚███╔╝░██║█████╗░░██║░░╚═╝███████║█████═╝░█████╗░░\r\n██╔══██╗██╔══██║██╔══██╗░░╚██╔╝░░██╔══██║░██╔██╗░██║██╔══╝░░██║░░██╗██╔══██║██╔═██╗░██╔══╝░░\r\n██████╦╝██║░░██║██████╦╝░░░██║░░░██║░░██║██╔╝╚██╗██║███████╗╚█████╔╝██║░░██║██║░╚██╗███████╗\r\n╚═════╝░╚═╝░░╚═╝╚═════╝░░░░╚═╝░░░╚═╝░░╚═╝╚═╝░░╚═╝╚═╝╚══════╝░╚════╝░╚═╝░░╚═╝╚═╝░░╚═╝╚══════╝\r\n\r\nwww.babyaxiecake.io\r\n\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\n\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size \u003e 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity\u0027s `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length \u003e 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}"},"BabyAxieCake.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\n\r\nimport \u0027./IBEP20.sol\u0027;\r\nimport \u0027./IPancakeERC20.sol\u0027;\r\nimport \u0027./IPancakeFactory.sol\u0027;\r\nimport \u0027./IPancakeRouter.sol\u0027;\r\nimport \u0027./Ownable.sol\u0027;\r\nimport \u0027./Address.sol\u0027;\r\nimport \u0027./EnumerableSet.sol\u0027;\r\n\r\ncontract BabyAxieCake is IBEP20, Ownable\r\n{\r\n    using Address for address;\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n    \r\n    mapping (address =\u003e uint256) private _balances;\r\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\r\n    mapping (address =\u003e uint256) private _sellLock;\r\n\r\n    EnumerableSet.AddressSet private _excluded;\r\n    EnumerableSet.AddressSet private _whiteList;\r\n    EnumerableSet.AddressSet private _excludedFromSellLock;\r\n    EnumerableSet.AddressSet private _excludedFromStaking;\r\n    \r\n    string private constant _name = \u0027Baby Axie Cake\u0027;\r\n    string private constant _symbol = \u0027BAC\u0027;\r\n    uint8 private constant _decimals = 9;\r\n    uint256 public constant InitialSupply= 100 * 10**6 * 10**_decimals;\r\n\r\n    address public immutable CAKE = address(0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82); //CAKE\r\n    address public immutable AXS = address(0x715D400F88C167884bbCc41C5FeA407ed4D2f8A0); //AXIE INFINITY\r\n\r\n    uint8 public constant BalanceLimitDivider = 100;\r\n    uint16 public constant WhiteListBalanceLimitDivider = 500;\r\n    uint16 public constant SellLimitDivider = 2000;\r\n    uint16 public constant MaxSellLockTime = 30 minutes;\r\n\r\n    uint256 private constant DefaultLiquidityLockTime = 1 hours;\r\n\r\n    address private BurnedContract;\r\n    address private constant PancakeRouter = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\r\n\r\n    uint256 private _circulatingSupply = InitialSupply;\r\n    uint256 public  balanceLimit = _circulatingSupply;\r\n    uint256 public  sellLimit = _circulatingSupply;\r\n\r\n    uint8 public constant MaxTax= 20;\r\n    \r\n    uint8 private _buyTax;\r\n    uint8 private _sellTax;\r\n    uint8 private _transferTax;\r\n\r\n    uint8 private _burnTax;\r\n    uint8 private _liquidityTax;\r\n    uint8 private _stakingTax;\r\n\r\n       \r\n    address private _pancakePairAddress; \r\n    IPancakeRouter02 private  _pancakeRouter;\r\n    \r\n    modifier onlyTeam() {\r\n        require(_isTeam(msg.sender), \"Caller not in Team\");\r\n        _;\r\n    }\r\n    function _isTeam(address addr) private view returns (bool){\r\n        return addr==owner()||addr==BurnedContract;\r\n    }\r\n\r\n    constructor (\r\n        address _BurnContractBAC\r\n    ) {\r\n        uint256 deployerBalance=_circulatingSupply;\r\n        _balances[msg.sender] = deployerBalance;\r\n        emit Transfer(address(0), msg.sender, deployerBalance);\r\n        uint256 injectBalance=_circulatingSupply-deployerBalance;\r\n        _balances[address(this)]=injectBalance;\r\n       emit Transfer(address(0), address(this),injectBalance);\r\n        BurnedContract = _BurnContractBAC;\r\n        _pancakeRouter = IPancakeRouter02(PancakeRouter);\r\n        _pancakePairAddress = IPancakeFactory(_pancakeRouter.factory()).createPair(address(this), _pancakeRouter.WETH());\r\n        balanceLimit=InitialSupply/BalanceLimitDivider;\r\n        sellLimit=InitialSupply/SellLimitDivider;\r\n        sellLockTime=MaxSellLockTime;\r\n\r\n        _buyTax=10;\r\n        _sellTax=20;\r\n        _transferTax=20;\r\n        \r\n        _burnTax=40;\r\n        _liquidityTax=4;\r\n        _stakingTax=2;\r\n        \r\n        _excluded.add(BurnedContract);\r\n        _excluded.add(msg.sender);\r\n        _excludedFromStaking.add(address(_pancakeRouter));\r\n        _excludedFromStaking.add(_pancakePairAddress);\r\n        _excludedFromStaking.add(address(this));\r\n        _excludedFromStaking.add(0x000000000000000000000000000000000000dEaD);\r\n    }\r\n    \r\n    function _transfer(address sender, address recipient, uint256 amount) private{\r\n        require(sender != address(0), \"Transfer from zero\");\r\n        require(recipient != address(0), \"Transfer to zero\");\r\n        \r\n        bool isExcluded = (_excluded.contains(sender) || _excluded.contains(recipient));\r\n        \r\n        bool isContractTransfer=(sender==address(this) || recipient==address(this));\r\n        \r\n        address pancakeRouter=address(_pancakeRouter);\r\n        bool isLiquidityTransfer = ((sender == _pancakePairAddress \u0026\u0026 recipient == pancakeRouter) \r\n        || (recipient == _pancakePairAddress \u0026\u0026 sender == pancakeRouter));\r\n\r\n        bool isBuy=sender==_pancakePairAddress|| sender == pancakeRouter;\r\n        bool isSell=recipient==_pancakePairAddress|| recipient == pancakeRouter;\r\n\r\n        if(isContractTransfer || isLiquidityTransfer || isExcluded){\r\n            _feelessTransfer(sender, recipient, amount);\r\n        }\r\n        else{\r\n            require(tradingEnabled,\"trading not yet enabled\");\r\n            if(whiteListTrading){\r\n                _whiteListTransfer(sender,recipient,amount,isBuy,isSell);\r\n            }\r\n            else{\r\n                _taxedTransfer(sender,recipient,amount,isBuy,isSell);                  \r\n            }\r\n        }\r\n    }\r\n    \r\n    function _whiteListTransfer(address sender, address recipient,uint256 amount,bool isBuy,bool isSell) private{\r\n        if(!isSell){\r\n            require(_whiteList.contains(recipient),\"recipient not on whitelist\");\r\n            require((_balances[recipient]+amount\u003c=InitialSupply/WhiteListBalanceLimitDivider),\"amount exceeds whitelist max\");    \r\n        }\r\n        _taxedTransfer(sender,recipient,amount,isBuy,isSell);\r\n\r\n    }\r\n    \r\n    function _taxedTransfer(address sender, address recipient, uint256 amount,bool isBuy,bool isSell) private{\r\n        uint256 recipientBalance = _balances[recipient];\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance \u003e= amount, \"Transfer exceeds balance\");\r\n\r\n        uint8 tax;\r\n        if(isSell){\r\n            if(!_excludedFromSellLock.contains(sender)){        \r\n                require(_sellLock[sender]\u003c=block.timestamp||sellLockDisabled,\"Seller in sellLock\");\r\n                _sellLock[sender]=block.timestamp+sellLockTime;\r\n            }\r\n            require(amount\u003c=sellLimit,\"Dump protection\");\r\n            tax=_sellTax;\r\n\r\n        } else if(isBuy){\r\n            require(recipientBalance+amount\u003c=balanceLimit,\"whale protection\");\r\n            tax=_buyTax;\r\n\r\n        } else {\r\n            if(amount\u003c=10**(_decimals)) claimAxie(sender);\r\n\r\n            if(amount\u003c=10**(_decimals)) claimCake(sender);\r\n\r\n            require(recipientBalance+amount\u003c=balanceLimit,\"whale protection\");\r\n            if(!_excludedFromSellLock.contains(sender))\r\n                require(_sellLock[sender]\u003c=block.timestamp||sellLockDisabled,\"Sender in Lock\");\r\n            tax=_transferTax;\r\n\r\n        }\r\n        if((sender!=_pancakePairAddress)\u0026\u0026(!manualConversion)\u0026\u0026(!_isSwappingContractModifier)\u0026\u0026isSell)\r\n            _swapContractToken();\r\n        uint256 tokensToBeBurnt=_calculateFee(amount, tax, _burnTax);\r\n        uint256 contractToken=_calculateFee(amount, tax, _stakingTax+_liquidityTax);\r\n        uint256 taxedAmount=amount-(tokensToBeBurnt + contractToken);\r\n\r\n        _removeToken(sender,amount);\r\n        _balances[address(this)] += contractToken;\r\n        _circulatingSupply-=tokensToBeBurnt;\r\n        _addToken(recipient, taxedAmount);\r\n        \r\n        emit Transfer(sender,recipient,taxedAmount);\r\n        \r\n\r\n\r\n    }\r\n    function _feelessTransfer(address sender, address recipient, uint256 amount) private{\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance \u003e= amount, \"Transfer exceeds balance\");\r\n        _removeToken(sender,amount);\r\n        _addToken(recipient, amount);\r\n        \r\n        emit Transfer(sender,recipient,amount);\r\n\r\n    }\r\n    function _calculateFee(uint256 amount, uint8 tax, uint8 taxPercent) private pure returns (uint256) {\r\n        return (amount*tax*taxPercent) / 10000;\r\n    }\r\n\r\n    bool private _isWithdrawing;\r\n    uint256 private constant DistributionMultiplier = 2**64;\r\n    uint256 private profitPerShare;\r\n\r\n    uint256 public profitPerShareAxie = profitPerShare / 2;\r\n    uint256 public profitPerShareCake = profitPerShare / 2;\r\n\r\n    uint256 public totalStakingReward;\r\n    uint256 public totalPayoutsAxie;\r\n    uint256 public totalPayoutsCake;\r\n    \r\n    uint8 public marketingShare=80;\r\n    uint256 public marketingBalance;\r\n\r\n    mapping(address =\u003e uint256) private alreadyPaidShares;\r\n    mapping(address =\u003e uint256) private toBePaid;\r\n\r\n    function isExcludedFromStaking(address addr) public view returns (bool){\r\n        return _excludedFromStaking.contains(addr);\r\n    }\r\n\r\n    function _getTotalShares() public view returns (uint256){\r\n        uint256 shares=_circulatingSupply;\r\n        for(uint i=0; i\u003c_excludedFromStaking.length(); i++){\r\n            shares-=_balances[_excludedFromStaking.at(i)];\r\n        }\r\n        return shares;\r\n    }\r\n\r\n    function _addToken(address addr, uint256 amount) private {\r\n        uint256 newAmount=_balances[addr]+amount;\r\n        \r\n        if(isExcludedFromStaking(addr)){\r\n           _balances[addr]=newAmount;\r\n           return;\r\n        }\r\n        \r\n        uint256 payment=_newDividentsOf(addr);\r\n        alreadyPaidShares[addr] = profitPerShare * newAmount;\r\n        toBePaid[addr]+=payment; \r\n        \r\n        _balances[addr]=newAmount;\r\n    }\r\n    \r\n    \r\n    function _removeToken(address addr, uint256 amount) private {\r\n        uint256 newAmount=_balances[addr]-amount;\r\n        \r\n        if(isExcludedFromStaking(addr)){\r\n           _balances[addr]=newAmount;\r\n           return;\r\n        }\r\n        \r\n        uint256 payment=_newDividentsOf(addr);\r\n        _balances[addr]=newAmount;\r\n        alreadyPaidShares[addr] = profitPerShare * newAmount;\r\n        toBePaid[addr]+=payment; \r\n    }\r\n    \r\n    function _newDividentsOf(address staker) private view returns (uint256) {\r\n        uint256 fullPayout = profitPerShare * _balances[staker];\r\n        if(fullPayout\u003calreadyPaidShares[staker]) return 0;\r\n        return (fullPayout - alreadyPaidShares[staker]) / DistributionMultiplier;\r\n    }\r\n\r\n    function _distributeStake(uint256 BNBamount) private {\r\n        uint256 marketingSplit = (BNBamount * marketingShare) / 100;\r\n        uint256 amount = BNBamount - marketingSplit;\r\n\r\n       marketingBalance+=marketingSplit;\r\n       \r\n        if (amount \u003e 0) {\r\n            totalStakingReward += amount;\r\n            uint256 totalShares=_getTotalShares();\r\n            if (totalShares == 0) {\r\n                marketingBalance += amount;\r\n            }else{\r\n                profitPerShare += ((amount * DistributionMultiplier) / totalShares);\r\n            }\r\n        }\r\n    }\r\n    event OnWithdrawAxie(uint256 amount, address recipient);\r\n    event OnWithdrawCake(uint256 amount, address recipient);\r\n    \r\n    function claimAxie(address addr) private{\r\n        require(!_isWithdrawing);\r\n        _isWithdrawing=true;\r\n        uint256 amount;\r\n        if(isExcludedFromStaking(addr)){\r\n            amount=toBePaid[addr];\r\n            toBePaid[addr]=0;\r\n        }\r\n        else{\r\n            uint256 newAmount=_newDividentsOf(addr);\r\n            alreadyPaidShares[addr] = profitPerShareAxie * _balances[addr];\r\n            amount=(toBePaid[addr]+newAmount) / 2;\r\n            toBePaid[addr]=0;\r\n        }\r\n        if(amount==0){\r\n            _isWithdrawing=false;\r\n            return;\r\n        }\r\n        totalPayoutsAxie+=amount;\r\n        address[] memory path = new address[](2);\r\n        path[0] = _pancakeRouter.WETH();\r\n        path[1] = AXS;\r\n\r\n        _pancakeRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount}(\r\n        0,\r\n        path,\r\n        addr,\r\n        block.timestamp);\r\n        \r\n        emit OnWithdrawAxie(amount, addr);\r\n        _isWithdrawing=false;\r\n    }\r\n\r\n\r\n    function claimCake(address addr) private{\r\n        require(!_isWithdrawing);\r\n        _isWithdrawing=true;\r\n        uint256 amount;\r\n        if(isExcludedFromStaking(addr)){\r\n            amount=toBePaid[addr];\r\n            toBePaid[addr]=0;\r\n        }\r\n        else{\r\n            uint256 newAmount=_newDividentsOf(addr);\r\n            alreadyPaidShares[addr] = profitPerShareCake * _balances[addr];\r\n            amount=(toBePaid[addr]+newAmount) / 2;\r\n            toBePaid[addr]=0;\r\n        }\r\n        if(amount==0){\r\n            _isWithdrawing=false;\r\n            return;\r\n        }\r\n        totalPayoutsCake+=amount;\r\n        address[] memory path = new address[](2);\r\n        path[0] = _pancakeRouter.WETH();\r\n        path[1] = CAKE;\r\n\r\n        _pancakeRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount}(\r\n        0,\r\n        path,\r\n        addr,\r\n        block.timestamp);\r\n        \r\n        emit OnWithdrawCake(amount, addr);\r\n        _isWithdrawing=false;\r\n    }\r\n\r\n    \r\n    uint256 public totalLPBNB;\r\n    bool private _isSwappingContractModifier;\r\n    modifier lockTheSwap {\r\n        _isSwappingContractModifier = true;\r\n        _;\r\n        _isSwappingContractModifier = false;\r\n    }\r\n    \r\n    function _swapContractToken() private lockTheSwap{\r\n        uint256 contractBalance=_balances[address(this)];\r\n        uint16 totalTax=_liquidityTax+_stakingTax;\r\n        uint256 tokenToSwap=sellLimit;\r\n        if(contractBalance\u003ctokenToSwap||totalTax==0){\r\n            return;\r\n        }\r\n        uint256 tokenForLiquidity=(tokenToSwap*_liquidityTax)/totalTax;\r\n        uint256 tokenForMarketing= tokenToSwap-tokenForLiquidity;\r\n\r\n        uint256 liqToken=tokenForLiquidity/2;\r\n        uint256 liqBNBToken=tokenForLiquidity-liqToken;\r\n\r\n        uint256 swapToken=liqBNBToken+tokenForMarketing;\r\n        uint256 initialBNBBalance = address(this).balance;\r\n        _swapTokenForBNB(swapToken);\r\n        uint256 newBNB=(address(this).balance - initialBNBBalance);\r\n        uint256 liqBNB = (newBNB*liqBNBToken)/swapToken;\r\n        _addLiquidity(liqToken, liqBNB);\r\n        uint256 distributeBNB=(address(this).balance - initialBNBBalance);\r\n        _distributeStake(distributeBNB);\r\n    }\r\n    \r\n    function _swapTokenForBNB(uint256 amount) private {\r\n        _approve(address(this), address(_pancakeRouter), amount);\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = _pancakeRouter.WETH();\r\n\r\n        _pancakeRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            amount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n    \r\n    function _addLiquidity(uint256 tokenamount, uint256 bnbamount) private {\r\n        totalLPBNB+=bnbamount;\r\n        _approve(address(this), address(_pancakeRouter), tokenamount);\r\n        _pancakeRouter.addLiquidityETH{value: bnbamount}(\r\n            address(this),\r\n            tokenamount,\r\n            0,\r\n            0,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function getLiquidityReleaseTimeInSeconds() public view returns (uint256){\r\n        if(block.timestamp\u003c_liquidityUnlockTime){\r\n            return _liquidityUnlockTime-block.timestamp;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function getBurnedTokens() public view returns(uint256){\r\n        return (InitialSupply-_circulatingSupply)/10**_decimals;\r\n    }\r\n\r\n    function getLimits() public view returns(uint256 balance, uint256 sell){\r\n        return(balanceLimit/10**_decimals, sellLimit/10**_decimals);\r\n    }\r\n\r\n    function getTaxes() public view returns(uint256 burnTax,uint256 liquidityTax,uint256 marketingTax, uint256 buyTax, uint256 sellTax, uint256 transferTax){\r\n        return (_burnTax,_liquidityTax,_stakingTax,_buyTax,_sellTax,_transferTax);\r\n    }\r\n\r\n    function getWhitelistedStatus(address AddressToCheck) public view returns(bool){\r\n        return _whiteList.contains(AddressToCheck);\r\n    }\r\n    \r\n    function getAddressSellLockTimeInSeconds(address AddressToCheck) public view returns (uint256){\r\n       uint256 lockTime=_sellLock[AddressToCheck];\r\n       if(lockTime\u003c=block.timestamp)\r\n       {\r\n           return 0;\r\n       }\r\n       return lockTime-block.timestamp;\r\n    }\r\n    function getSellLockTimeInSeconds() public view returns(uint256){\r\n        return sellLockTime;\r\n    }\r\n    \r\n    function AddressResetSellLock() public{\r\n        _sellLock[msg.sender]=block.timestamp+sellLockTime;\r\n    }\r\n    \r\n    function AxieWithdraw() public{\r\n        claimAxie(msg.sender);\r\n    }\r\n\r\n    function CakeWithdraw() public{\r\n        claimCake(msg.sender);\r\n    }\r\n    function getDividentsAxie(address addr) public view returns (uint256){\r\n        if(isExcludedFromStaking(addr)) return toBePaid[addr];\r\n        return (_newDividentsOf(addr)+toBePaid[addr]) / 2;\r\n    }\r\n\r\n    function getDividentsCake(address addr) public view returns (uint256){\r\n        if(isExcludedFromStaking(addr)) return toBePaid[addr];\r\n        return (_newDividentsOf(addr)+toBePaid[addr]) / 2;\r\n    }\r\n\r\n    bool public sellLockDisabled;\r\n    uint256 public sellLockTime;\r\n    bool public manualConversion;\r\n\r\n    function TiExcludeFromStaking(address addr) public onlyTeam{\r\n        require(_excludedFromStaking.length()\u003c30);\r\n        require(!isExcludedFromStaking(addr));\r\n        uint256 newDividents=_newDividentsOf(addr);\r\n        alreadyPaidShares[addr]=_balances[addr]*profitPerShare;\r\n        toBePaid[addr]+=newDividents;\r\n        _excludedFromStaking.add(addr);\r\n        \r\n    }    \r\n\r\n    function TiIncludeToStaking(address addr) public onlyTeam{\r\n        require(isExcludedFromStaking(addr));\r\n        _excludedFromStaking.remove(addr);\r\n        alreadyPaidShares[addr]=_balances[addr]*profitPerShare;\r\n    }\r\n\r\n    function TiWithdrawTiBNB() public onlyTeam{\r\n        uint256 amount=marketingBalance;\r\n        marketingBalance=0;\r\n        (bool sent,) =BurnedContract.call{value: (amount)}(\"\");\r\n        require(sent,\"withdraw failed\");\r\n    }\r\n    function WithdrawTiBNB(uint256 amount) public onlyTeam{\r\n        require(amount\u003c=marketingBalance);\r\n        marketingBalance-=amount;\r\n        (bool sent,) =BurnedContract.call{value: (amount)}(\"\");\r\n        require(sent,\"withdraw failed\");\r\n    } \r\n\r\n    function TiSwitchManualBNBConversion(bool manual) public onlyTeam{\r\n        manualConversion=manual;\r\n    }\r\n    \r\n    function TiDisableSellLock(bool disabled) public onlyTeam{\r\n        sellLockDisabled=disabled;\r\n    }\r\n    \r\n    function TiSetSellLockTime(uint256 sellLockSeconds)public onlyTeam{\r\n            require(sellLockSeconds\u003c=MaxSellLockTime,\"Sell Lock time too high\");\r\n            sellLockTime=sellLockSeconds;\r\n    } \r\n\r\n    function TiSetTaxes(uint8 burnTaxes, uint8 liquidityTaxes, uint8 stakingTaxes,uint8 buyTax, uint8 sellTax, uint8 transferTax) public onlyTeam{\r\n        uint8 totalTax=burnTaxes+liquidityTaxes+stakingTaxes;\r\n        require(totalTax==100, \"burn+liq+marketing needs to equal 100%\");\r\n        require(buyTax\u003c=MaxTax\u0026\u0026sellTax\u003c=MaxTax\u0026\u0026transferTax\u003c=MaxTax,\"taxes higher than max tax\");\r\n        \r\n        _burnTax=burnTaxes;\r\n        _liquidityTax=liquidityTaxes;\r\n        _stakingTax=stakingTaxes;\r\n        \r\n        _buyTax=buyTax;\r\n        _sellTax=sellTax;\r\n        _transferTax=transferTax;\r\n    }\r\n    \r\n    function TiChangeMarketingShare(uint8 newShare) public onlyTeam{\r\n        require(newShare\u003c=50); \r\n        marketingShare=newShare;\r\n    }\r\n    \r\n    function StakingCreateLPandBNB() public onlyTeam{\r\n    _swapContractToken();\r\n    }\r\n    \r\n    function TiExcludeAccountFromFees(address account) public onlyTeam {\r\n        _excluded.add(account);\r\n    }\r\n    function TiIncludeAccountToFees(address account) public onlyTeam {\r\n        _excluded.remove(account);\r\n    }\r\n    \r\n    function TiExcludeAccountFromSellLock(address account) public onlyTeam {\r\n        _excludedFromSellLock.add(account);\r\n    }\r\n    function TiIncludeAccountToSellLock(address account) public onlyTeam {\r\n        _excludedFromSellLock.remove(account);\r\n    }\r\n    \r\n    function TiUpdateLimits(uint256 newBalanceLimit, uint256 newSellLimit) public onlyTeam{\r\n        \r\n        require(newSellLimit\u003c_circulatingSupply/100);\r\n        newBalanceLimit=newBalanceLimit*10**_decimals;\r\n        newSellLimit=newSellLimit*10**_decimals;\r\n        uint256 targetBalanceLimit=_circulatingSupply/BalanceLimitDivider;\r\n        uint256 targetSellLimit=_circulatingSupply/SellLimitDivider;\r\n\r\n        require((newBalanceLimit\u003e=targetBalanceLimit), \r\n        \"newBalanceLimit needs to be at least target\");\r\n        require((newSellLimit\u003e=targetSellLimit), \r\n        \"newSellLimit needs to be at least target\");\r\n\r\n        balanceLimit = newBalanceLimit;\r\n        sellLimit = newSellLimit;     \r\n    }\r\n\r\n    bool public tradingEnabled;\r\n    bool public whiteListTrading;\r\n    address private _liquidityTokenAddress;\r\n    \r\n    function SetupEnableWhitelistTrading() public onlyTeam{\r\n        require(!tradingEnabled);\r\n        \r\n        tradingEnabled=true;\r\n        whiteListTrading=true;\r\n        \r\n        _liquidityUnlockTime=block.timestamp+DefaultLiquidityLockTime;\r\n    }\r\n    \r\n    function SetupEnableTrading() public onlyTeam{\r\n        require(tradingEnabled\u0026\u0026whiteListTrading);\r\n        whiteListTrading=false;\r\n    }\r\n\r\n    function SetupLiquidityTokenAddress(address liquidityTokenAddress) public onlyTeam{\r\n        _liquidityTokenAddress=liquidityTokenAddress;\r\n    }\r\n    \r\n    function SetupAddToWhitelist(address addressToAdd) public onlyTeam{\r\n        _whiteList.add(addressToAdd);\r\n    }\r\n    function SetupAddArrayToWhitelist(address[] memory addressesToAdd) public onlyTeam{\r\n        for(uint i=0; i\u003caddressesToAdd.length; i++){\r\n            _whiteList.add(addressesToAdd[i]);\r\n        }\r\n    }\r\n    function SetupRemoveFromWhitelist(address addressToRemove) public onlyTeam{\r\n        _whiteList.remove(addressToRemove);\r\n    } \r\n\r\n    uint256 private _liquidityUnlockTime;\r\n\r\n    bool public liquidityRelease20Percent;\r\n    function TilimitLiquidityReleaseTo20Percent() public onlyTeam{\r\n        liquidityRelease20Percent=true;\r\n    }\r\n\r\n    function TiUnlockLiquidityInSeconds(uint256 secondsUntilUnlock) public onlyTeam{\r\n        _prolongLiquidityLock(secondsUntilUnlock+block.timestamp);\r\n    }\r\n    function _prolongLiquidityLock(uint256 newUnlockTime) private{\r\n        require(newUnlockTime\u003e_liquidityUnlockTime);\r\n        _liquidityUnlockTime=newUnlockTime;\r\n    }\r\n\r\n    function TiReleaseLiquidity() public onlyTeam {\r\n        require(block.timestamp \u003e= _liquidityUnlockTime, \"Not yet unlocked\");\r\n        \r\n        IPancakeERC20 liquidityToken = IPancakeERC20(_liquidityTokenAddress);\r\n        uint256 amount = liquidityToken.balanceOf(address(this));\r\n        if(liquidityRelease20Percent)\r\n        {\r\n            _liquidityUnlockTime=block.timestamp+DefaultLiquidityLockTime;\r\n            amount=amount*2/10;\r\n            liquidityToken.transfer(BurnedContract, amount);\r\n        }\r\n        else\r\n        {\r\n            liquidityToken.transfer(BurnedContract, amount);\r\n        }\r\n    }\r\n\r\n    function TiRemoveLiquidity(bool addToStaking) public onlyTeam {\r\n        IPancakeERC20 liquidityToken = IPancakeERC20(_liquidityTokenAddress);\r\n        uint256 amount = liquidityToken.balanceOf(address(this));\r\n        if(liquidityRelease20Percent){\r\n            amount=amount*2/10;\r\n        } \r\n        liquidityToken.approve(address(_pancakeRouter),amount);\r\n        uint256 initialBNBBalance = address(this).balance;\r\n        _pancakeRouter.removeLiquidityETHSupportingFeeOnTransferTokens(\r\n            address(this),\r\n            amount,\r\n            0,\r\n            0,\r\n            address(this),\r\n            block.timestamp\r\n            );\r\n        uint256 newBNBBalance = address(this).balance-initialBNBBalance;\r\n        if(addToStaking){\r\n            _distributeStake(newBNBBalance);\r\n        }\r\n        else{\r\n            marketingBalance+=newBNBBalance;\r\n        }\r\n\r\n    }\r\n    function TiRemoveRemainingBNB() public onlyTeam{\r\n        require(block.timestamp \u003e= _liquidityUnlockTime+1 minutes, \"Not yet unlocked\");\r\n        _liquidityUnlockTime=block.timestamp+DefaultLiquidityLockTime;\r\n        (bool sent,) =BurnedContract.call{value: (address(this).balance)}(\"\");\r\n        require(sent);\r\n    }\r\n\r\n    receive() external payable {}\r\n    fallback() external payable {}\r\n\r\n    function getOwner() external view override returns (address) {\r\n        return owner();\r\n    }\r\n\r\n    function name() external pure override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() external pure override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() external pure override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() external view override returns (uint256) {\r\n        return _circulatingSupply;\r\n    }\r\n\r\n    function balanceOf(address account) external view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address spender) external view override returns (uint256) {\r\n        return _allowances[_owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) external override returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n    function _approve(address owner, address spender, uint256 amount) private {\r\n        require(owner != address(0), \"Approve from zero\");\r\n        require(spender != address(0), \"Approve to zero\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n\r\n        uint256 currentAllowance = _allowances[sender][msg.sender];\r\n        require(currentAllowance \u003e= amount, \"Transfer \u003e allowance\");\r\n\r\n        _approve(sender, msg.sender, currentAllowance - amount);\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\r\n        uint256 currentAllowance = _allowances[msg.sender][spender];\r\n        require(currentAllowance \u003e= subtractedValue, \"\u003c0 allowance\");\r\n\r\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\r\n        return true;\r\n    }\r\n\r\n}"},"EnumerableSet.sol":{"content":"/*\r\n\r\n██████╗░░█████╗░██████╗░██╗░░░██╗░█████╗░██╗░░██╗██╗███████╗░█████╗░░█████╗░██╗░░██╗███████╗\r\n██╔══██╗██╔══██╗██╔══██╗╚██╗░██╔╝██╔══██╗╚██╗██╔╝██║██╔════╝██╔══██╗██╔══██╗██║░██╔╝██╔════╝\r\n██████╦╝███████║██████╦╝░╚████╔╝░███████║░╚███╔╝░██║█████╗░░██║░░╚═╝███████║█████═╝░█████╗░░\r\n██╔══██╗██╔══██║██╔══██╗░░╚██╔╝░░██╔══██║░██╔██╗░██║██╔══╝░░██║░░██╗██╔══██║██╔═██╗░██╔══╝░░\r\n██████╦╝██║░░██║██████╦╝░░░██║░░░██║░░██║██╔╝╚██╗██║███████╗╚█████╔╝██║░░██║██║░╚██╗███████╗\r\n╚═════╝░╚═╝░░╚═╝╚═════╝░░░░╚═╝░░░╚═╝░░╚═╝╚═╝░░╚═╝╚═╝╚══════╝░╚════╝░╚═╝░░╚═╝╚═╝░░╚═╝╚══════╝\r\n\r\nwww.babyaxiecake.io\r\n\r\n*/\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\n\r\nlibrary EnumerableSet {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Set type with\r\n    // bytes32 values.\r\n    // The Set implementation uses private functions, and user-facing\r\n    // implementations (such as AddressSet) are just wrappers around the\r\n    // underlying Set.\r\n    // This means that we can only create new EnumerableSets for types that fit\r\n    // in bytes32.\r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping (bytes32 =\u003e uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value\u0027s index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as \u0027swap and pop\u0027).\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\r\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an \u0027if\u0027 statement.\r\n\r\n            bytes32 lastvalue = set._values[lastIndex];\r\n\r\n            // Move the last value to the index where the value to delete is\r\n            set._values[toDeleteIndex] = lastvalue;\r\n            // Update the index for the moved value\r\n            set._indexes[lastvalue] = valueIndex; // Replace lastvalue\u0027s index to valueIndex\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        require(set._values.length \u003e index, \"EnumerableSet: index out of bounds\");\r\n        return set._values[index];\r\n    }\r\n\r\n    // Bytes32Set\r\n\r\n    struct Bytes32Set {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _add(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _remove(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\r\n        return _contains(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(Bytes32Set storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\r\n        return _at(set._inner, index);\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint160(uint256(_at(set._inner, index))));\r\n    }\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n}"},"IBEP20.sol":{"content":"/*\r\n\r\n██████╗░░█████╗░██████╗░██╗░░░██╗░█████╗░██╗░░██╗██╗███████╗░█████╗░░█████╗░██╗░░██╗███████╗\r\n██╔══██╗██╔══██╗██╔══██╗╚██╗░██╔╝██╔══██╗╚██╗██╔╝██║██╔════╝██╔══██╗██╔══██╗██║░██╔╝██╔════╝\r\n██████╦╝███████║██████╦╝░╚████╔╝░███████║░╚███╔╝░██║█████╗░░██║░░╚═╝███████║█████═╝░█████╗░░\r\n██╔══██╗██╔══██║██╔══██╗░░╚██╔╝░░██╔══██║░██╔██╗░██║██╔══╝░░██║░░██╗██╔══██║██╔═██╗░██╔══╝░░\r\n██████╦╝██║░░██║██████╦╝░░░██║░░░██║░░██║██╔╝╚██╗██║███████╗╚█████╔╝██║░░██║██║░╚██╗███████╗\r\n╚═════╝░╚═╝░░╚═╝╚═════╝░░░░╚═╝░░░╚═╝░░╚═╝╚═╝░░╚═╝╚═╝╚══════╝░╚════╝░╚═╝░░╚═╝╚═╝░░╚═╝╚══════╝\r\n\r\nwww.babyaxiecake.io\r\n\r\n*/\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\n\r\ninterface IBEP20 {\r\n  function totalSupply() external view returns (uint256);\r\n  function decimals() external view returns (uint8);\r\n  function symbol() external view returns (string memory);\r\n  function name() external view returns (string memory);\r\n  function getOwner() external view returns (address);\r\n  function balanceOf(address account) external view returns (uint256);\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n  function allowance(address _owner, address spender) external view returns (uint256);\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"},"IPancakeERC20.sol":{"content":"/*\r\n\r\n██████╗░░█████╗░██████╗░██╗░░░██╗░█████╗░██╗░░██╗██╗███████╗░█████╗░░█████╗░██╗░░██╗███████╗\r\n██╔══██╗██╔══██╗██╔══██╗╚██╗░██╔╝██╔══██╗╚██╗██╔╝██║██╔════╝██╔══██╗██╔══██╗██║░██╔╝██╔════╝\r\n██████╦╝███████║██████╦╝░╚████╔╝░███████║░╚███╔╝░██║█████╗░░██║░░╚═╝███████║█████═╝░█████╗░░\r\n██╔══██╗██╔══██║██╔══██╗░░╚██╔╝░░██╔══██║░██╔██╗░██║██╔══╝░░██║░░██╗██╔══██║██╔═██╗░██╔══╝░░\r\n██████╦╝██║░░██║██████╦╝░░░██║░░░██║░░██║██╔╝╚██╗██║███████╗╚█████╔╝██║░░██║██║░╚██╗███████╗\r\n╚═════╝░╚═╝░░╚═╝╚═════╝░░░░╚═╝░░░╚═╝░░╚═╝╚═╝░░╚═╝╚═╝╚══════╝░╚════╝░╚═╝░░╚═╝╚═╝░░╚═╝╚══════╝\r\n\r\nwww.babyaxiecake.io\r\n\r\n*/\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\n\r\ninterface IPancakeERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n}"},"IPancakeFactory.sol":{"content":"/*\r\n\r\n██████╗░░█████╗░██████╗░██╗░░░██╗░█████╗░██╗░░██╗██╗███████╗░█████╗░░█████╗░██╗░░██╗███████╗\r\n██╔══██╗██╔══██╗██╔══██╗╚██╗░██╔╝██╔══██╗╚██╗██╔╝██║██╔════╝██╔══██╗██╔══██╗██║░██╔╝██╔════╝\r\n██████╦╝███████║██████╦╝░╚████╔╝░███████║░╚███╔╝░██║█████╗░░██║░░╚═╝███████║█████═╝░█████╗░░\r\n██╔══██╗██╔══██║██╔══██╗░░╚██╔╝░░██╔══██║░██╔██╗░██║██╔══╝░░██║░░██╗██╔══██║██╔═██╗░██╔══╝░░\r\n██████╦╝██║░░██║██████╦╝░░░██║░░░██║░░██║██╔╝╚██╗██║███████╗╚█████╔╝██║░░██║██║░╚██╗███████╗\r\n╚═════╝░╚═╝░░╚═╝╚═════╝░░░░╚═╝░░░╚═╝░░╚═╝╚═╝░░╚═╝╚═╝╚══════╝░╚════╝░╚═╝░░╚═╝╚═╝░░╚═╝╚══════╝\r\n\r\nwww.babyaxiecake.io\r\n\r\n*/\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\n\r\ninterface IPancakeFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}"},"IPancakeRouter.sol":{"content":"/*\r\n\r\n██████╗░░█████╗░██████╗░██╗░░░██╗░█████╗░██╗░░██╗██╗███████╗░█████╗░░█████╗░██╗░░██╗███████╗\r\n██╔══██╗██╔══██╗██╔══██╗╚██╗░██╔╝██╔══██╗╚██╗██╔╝██║██╔════╝██╔══██╗██╔══██╗██║░██╔╝██╔════╝\r\n██████╦╝███████║██████╦╝░╚████╔╝░███████║░╚███╔╝░██║█████╗░░██║░░╚═╝███████║█████═╝░█████╗░░\r\n██╔══██╗██╔══██║██╔══██╗░░╚██╔╝░░██╔══██║░██╔██╗░██║██╔══╝░░██║░░██╗██╔══██║██╔═██╗░██╔══╝░░\r\n██████╦╝██║░░██║██████╦╝░░░██║░░░██║░░██║██╔╝╚██╗██║███████╗╚█████╔╝██║░░██║██║░╚██╗███████╗\r\n╚═════╝░╚═╝░░╚═╝╚═════╝░░░░╚═╝░░░╚═╝░░╚═╝╚═╝░░╚═╝╚═╝╚══════╝░╚════╝░╚═╝░░╚═╝╚═╝░░╚═╝╚══════╝\r\n\r\nwww.babyaxiecake.io\r\n\r\n*/\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\n\r\ninterface IPancakeRouter01 {\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getamountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getamountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getamountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getamountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\n\r\ninterface IPancakeRouter02 is IPancakeRouter01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}"},"Ownable.sol":{"content":"/*\r\n\r\n██████╗░░█████╗░██████╗░██╗░░░██╗░█████╗░██╗░░██╗██╗███████╗░█████╗░░█████╗░██╗░░██╗███████╗\r\n██╔══██╗██╔══██╗██╔══██╗╚██╗░██╔╝██╔══██╗╚██╗██╔╝██║██╔════╝██╔══██╗██╔══██╗██║░██╔╝██╔════╝\r\n██████╦╝███████║██████╦╝░╚████╔╝░███████║░╚███╔╝░██║█████╗░░██║░░╚═╝███████║█████═╝░█████╗░░\r\n██╔══██╗██╔══██║██╔══██╗░░╚██╔╝░░██╔══██║░██╔██╗░██║██╔══╝░░██║░░██╗██╔══██║██╔═██╗░██╔══╝░░\r\n██████╦╝██║░░██║██████╦╝░░░██║░░░██║░░██║██╔╝╚██╗██║███████╗╚█████╔╝██║░░██║██║░╚██╗███████╗\r\n╚═════╝░╚═╝░░╚═╝╚═════╝░░░░╚═╝░░░╚═╝░░╚═╝╚═╝░░╚═╝╚═╝╚══════╝░╚════╝░╚═╝░░╚═╝╚═╝░░╚═╝╚══════╝\r\n\r\nwww.babyaxiecake.io\r\n\r\n*/\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\n\r\nabstract contract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () {\r\n        address msgSender = msg.sender;\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}"}}