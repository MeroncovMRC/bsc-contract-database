{"IERC20.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\ninterface IERC20 {\n\n    function totalSupply() external view returns (uint256);\n    \n    function symbol() external view returns(string memory);\n    \n    function name() external view returns(string memory);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n    \n    /**\n     * @dev Returns the number of decimal places\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"},"RewardDistributor.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\nimport \"./IERC20.sol\";\n\ninterface IDaylight {\n    function getOwner() external view returns (address);\n}\n\ninterface IEmissions {\n    function trigger() external;\n}\n\ninterface IFarm {\n    function depositRewards(uint256 amount) external;\n}\n\ncontract RewardDistributor {\n\n    // daylight token\n    address public constant daylight = 0x62529D7dE8293217C8F74d60c8C0F6481DE47f0E;\n\n    // emission distributor\n    address public constant emissionDistributor = 0xfA5F9b81Ee35F679d2Cf0C569EfAcf8Cba7b00aC;\n\n    // Yield Farm\n    address public farm = 0x348e66555F85da4D84C80B917a17aeF7750705Bb;\n    address public longFarm = 0x8f0E57e961b6B3C767F01A9d045C7457c22d338C;\n    address public staking = 0x77fCC833fbb6e1e39262B817466041c183424867;\n    address public mdbFarm = 0x6aB99fE4075361CD6063FF1f2B3d1bA2A5850930;\n\n    // Percentages\n    uint256 public farmPercent = 125;\n    uint256 public longFarmPercent = 550;\n    uint256 public stakingPercent = 75;\n    uint256 public mdbFarmPercent = 250;\n\n    // only daylight owner\n    modifier onlyOwner() {\n        require(\n            msg.sender == IDaylight(daylight).getOwner(),\n            \u0027Only Daylight Owner\u0027\n        );\n        _;\n    }\n\n    function trigger() external {\n\n        // trigger emission distributor to receive tokens\n        IEmissions(emissionDistributor).trigger();\n\n        // get balance\n        uint256 balance = IERC20(daylight).balanceOf(address(this));\n        if (balance == 0) {\n            return;\n        }\n\n        // denom for math\n        uint256 DENOM = farmPercent + longFarmPercent + stakingPercent + mdbFarmPercent;\n        if (DENOM == 0) {\n            return;\n        }\n\n        // split amounts\n        uint256 forFarm = ( balance * farmPercent ) / DENOM;\n        uint256 forLongFarm = ( balance * longFarmPercent ) / DENOM;\n        uint256 forMDB = ( balance * mdbFarmPercent ) / DENOM;\n\n        if (farm != address(0) \u0026\u0026 forFarm \u003e 0) {\n            IERC20(daylight).approve(farm, forFarm);\n            IFarm(farm).depositRewards(forFarm);\n        }\n\n        if (longFarm != address(0) \u0026\u0026 forLongFarm \u003e 0) {\n            IERC20(daylight).approve(longFarm, forLongFarm);\n            IFarm(longFarm).depositRewards(forLongFarm);\n        }\n\n        if (mdbFarm != address(0) \u0026\u0026 forMDB \u003e 0) {\n            IERC20(daylight).approve(mdbFarm, forMDB);\n            IFarm(mdbFarm).depositRewards(forMDB);\n        }\n\n        uint256 forStaking = IERC20(daylight).balanceOf(address(this));\n        if (staking != address(0) \u0026\u0026 forStaking \u003e 0) {\n            IERC20(daylight).transfer(staking, forStaking);\n        }\n    }\n\n    function setPercents(uint256 farm_, uint256 longFarm_, uint256 staking_, uint256 mdb_) external onlyOwner {\n        farmPercent = farm_;\n        longFarmPercent = longFarm_;\n        stakingPercent = staking_;\n        mdbFarmPercent = mdb_;\n    }\n\n    function reset(uint256 decrement) external onlyOwner {\n        IERC20(daylight).transfer(emissionDistributor, IERC20(daylight).balanceOf(address(this)) - decrement);\n    }\n\n    function setFarm(address farm_) external onlyOwner {\n        farm = farm_;\n    }\n\n    function setLongFarm(address farm_) external onlyOwner {\n        longFarm = farm_;\n    }\n\n    function setStaking(address staking_) external onlyOwner {\n        staking = staking_;\n    }\n\n    function setMDBFarm(address mdb_) external onlyOwner {\n        mdbFarm = mdb_;\n    }\n\n}"}}